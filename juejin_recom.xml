<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱]]></title>    <link>https://juejin.cn/post/7602488966610108454</link>    <guid>https://juejin.cn/post/7602488966610108454</guid>    <pubDate>2026-02-03T15:11:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966610108454" data-draft-id="7602154088476819494" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T15:11:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GetcharZp"/> <meta itemprop="url" content="https://juejin.cn/user/4328150938692264"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4328150938692264/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GetcharZp
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T15:11:43.000Z" title="Tue Feb 03 2026 15:11:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><blockquote>
<p>从“为什么要自建邮箱”讲起，拆解 Mailu 的架构、优缺点，以及普通人也能照着做的安装实战。</p>
<p>Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMailu%2FMailu" target="_blank" title="https://github.com/Mailu/Mailu" ref="nofollow noopener noreferrer">github.com/Mailu/Mailu</a></p>
<p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmailu.io%2F" target="_blank" title="https://mailu.io/" ref="nofollow noopener noreferrer">mailu.io/</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/401cc5720a8449ceaacd10398ca7934a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=csROttHHvmKZH1iYvGUiQbMFeaI%3D" alt="b4104652304a1f868421518e475c6c1d.png" loading="lazy"/></p>
<p>这几年，越来越多团队开始重新审视一件事：<strong>邮箱，到底要不要掌握在自己手里？</strong></p>
<p>用第三方企业邮箱当然省事，但账号封禁、功能限制、隐私不可控的问题，一旦遇到，几乎没有回旋余地。于是，自建邮件服务器这件事，又被不少技术团队重新捡了起来。</p>
<p>而在一堆方案里，<strong>Mailu</strong> 是被频繁提到的一个名字。</p>
<h3 data-id="heading-0">Mailu 是什么？一句话先讲明白</h3>
<p><strong>Mailu 是一套基于 Docker 的开源邮件服务器整体解决方案。</strong></p>
<p>它不是某一个单独的软件，而是把<strong>收信、发信、反垃圾、Web 邮箱、管理后台</strong>这些组件，全部拆分成容器，再用一套统一的方式帮你组装好。</p>
<p>你不用再自己去拼 Postfix + Dovecot + SpamAssassin + Webmail，也不用被复杂的配置文件折磨，Mailu 的目标很直接：<br/>
<strong>让“自建邮件服务器”这件事，变得工程化、可复制。</strong></p>
<h3 data-id="heading-1">Mailu 内部是怎么工作的？</h3>
<p>Mailu 本质上是一套“邮件系统拼装模板”，核心组件包括：</p>
<ul>
<li><strong>Postfix</strong>：负责邮件发送（SMTP）</li>
<li><strong>Dovecot</strong>：负责邮件接收（IMAP / POP3）</li>
<li><strong>Rspamd</strong>：反垃圾、反病毒</li>
<li><strong>Webmail（Roundcube 或 RainLoop）</strong> ：网页邮箱</li>
<li><strong>Admin 管理后台</strong>：域名、用户、别名统一管理</li>
<li><strong>Redis / MariaDB</strong>：状态和数据存储</li>
</ul>
<p>所有组件都通过 Docker 运行，你看到的不是一堆零散服务，而是一套已经编排好的系统。</p>
<p>这也是 Mailu 最大的特点：<br/>
<strong>它不是“教你怎么搭”，而是“直接给你一套能跑的”。</strong></p>
<h3 data-id="heading-2">Mailu 的基本安装思路（不踩坑版）</h3>
<p>整体流程其实很清晰：</p>
<p><strong>第一步：配置 DNS</strong></p>
<p>假设域名为 <code>example.com</code>，服务器IP为 <code>1.2.3.4</code></p>
<ul>
<li>
<p>A 记录</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 主机记录           记录类型  IP</span>
mail.example.com    A    1.2.3.4
</code></pre>
</li>
<li>
<p>MX 记录</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 主机记录@    记录类型  优先级  记录值</span>
example.com    MX    10 mail.example.com
</code></pre>
</li>
</ul>
<p>核心是配置 A、MX 记录，这是邮件系统成败的关键一步，不能省。另外还有 SPF、DKIM、DMARC 可以按需配置。</p>
<p><strong>第二步：启动 Mailu</strong></p>
<ul>
<li>
<p>创建 mailu 文件夹</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> /mailu
<span class="hljs-built_in">cd</span> /mailu
</code></pre>
</li>
<li>
<p>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsetup.mailu.io%2F" target="_blank" title="https://setup.mailu.io/" ref="nofollow noopener noreferrer">setup.mailu.io/</a> 填写域名信息后（参考以下截图填写主域名、二级域名），点击界面最下方的 <strong>Setup Mailu</strong> ,此时官方会跳转到 Mailu configuration - 界面，下载界面提供 <strong>docker-compose.yml</strong> 、<strong>mailu.env</strong> 的两个文件到服务器的 mailu 目录下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4da49385afcd43d68d7c4195bfbc793d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=pScsZFwxYhVGFH5NjXfkOahvmY0%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca7ea51b7d5e42579dd158f99c25a9fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=VCKi1MpQNM1HbNp21H56hAjJWas%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f29e49b36cce4673a23c525fb14e35ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=k5AUT9iMiIcQlVTOTNqAJurrkj0%3D" alt="ef0a9155f8456effe2f44b4846712252.png" loading="lazy"/></p>
</li>
<li>
<p>手动修改 <strong>docker-compose.yml</strong> ，移除 front 端口映射中的 <code>127.0.0.1</code> ，使其能够被外部访问到</p>
</li>
<li>
<p>一条命令启动服务 <code>docker compose up -d</code></p>
</li>
</ul>
<p><strong>第三步：后台创建用户</strong></p>
<ul>
<li>
<p>登录 Admin 页面，在浏览器中访问 <code>服务器IP/admin</code> 或者 <code>mail.主域名/admin</code>，服务默认在 80 端口上</p>
</li>
<li>
<p>添加域名、邮箱账号，执行下面命令后会获取到一个超管账户，邮箱为 <code>me.example.com</code> ，密码为 <code>password</code></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># docker compose exec admin flask mailu admin [用户名] [主域名] [密码]</span>
<span class="hljs-comment"># 示例：</span>
docker compose <span class="hljs-built_in">exec</span> admin flask mailu admin me example.com <span class="hljs-string">'password'</span>
</code></pre>
</li>
<li>
<p>测试收发邮件</p>
<p>访问 <code>服务器IP/webmail</code> 或者 <code>mail.主域名/webmail</code> 如果能收到其他邮件系统发送过来的邮件，说明收件相关的配置没有问题咯</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e84190ae52894eecbe3d79c430dd1735~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=e7DOmreRsijNrLCrP9CnunAqHIo%3D" alt="227b722c1c28869466385f52dc90b875.png" loading="lazy"/></p>
</li>
</ul>
<h3 data-id="heading-3">写在最后</h3>
<p>Mailu 并不是“最简单”的邮件方案，但它是<strong>少数能把复杂事情系统化的方案之一</strong>。</p>
<p>当你真正把邮件当成一项基础设施，而不是一个外包服务时，你会发现，自建并没有想象中那么可怕。</p>
<p>真正难的，从来不是工具，而是你是否愿意为“可控”付出一点学习成本。</p>
<p>如果你已经在考虑这一步，Mailu，值得你认真试一次。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[type-challenges（ts类型体操）: 20 - Promise.all]]></title>    <link>https://juejin.cn/post/7602503154505351209</link>    <guid>https://juejin.cn/post/7602503154505351209</guid>    <pubDate>2026-02-03T14:05:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505351209" data-draft-id="7602420156397600811" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="type-challenges（ts类型体操）: 20 - Promise.all"/> <meta itemprop="keywords" content="TypeScript"/> <meta itemprop="datePublished" content="2026-02-03T14:05:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="fxss"/> <meta itemprop="url" content="https://juejin.cn/user/3702810892856808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            type-challenges（ts类型体操）: 20 - Promise.all
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3702810892856808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    fxss
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:05:39.000Z" title="Tue Feb 03 2026 14:05:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">20 - Promise.all</h2>
<p>by Anthony Fu (@antfu) #中等 #array #promise</p>
<h3 data-id="heading-1">题目</h3>
<p>给函数<code>PromiseAll</code>指定类型，它接受元素为 Promise 或者类似 Promise 的对象的数组，返回值应为<code>Promise&lt;T&gt;</code>，其中<code>T</code>是这些 Promise 的结果组成的数组。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">'foo'</span>);
});

<span class="hljs-comment">// 应推导出 `Promise&lt;[number, 42, string]&gt;`</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">PromiseAll</span>([promise1, promise2, promise3] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
</code></pre>
<blockquote>
<p>在 Github 上查看：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fzh-CN" target="_blank" title="https://tsch.js.org/20/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/20/zh-CN</a></p>
</blockquote>
<h3 data-id="heading-2">代码</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/* _____________ 你的代码 _____________ */</span>

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">PromiseAll</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;(<span class="hljs-attr">values</span>: [...T]): <span class="hljs-title class_">Promise</span>&lt;{ [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Awaited</span>&lt;T[K]&gt; }&gt;

</code></pre>
<p>关键解释：</p>
<ul>
<li><code>T extends any[]</code>：约束 <code>T</code> 必须是数组类型。</li>
<li><code>[...T]</code>：是数组扩展语法（元组展开），用于保留输入数组的元组结构。</li>
<li><code>Awaited&lt;T[K]&gt;</code>：获取 <code>Promise</code> 或者类似 <code>Promise</code> 的对象的结果类型。</li>
<li><code>Promise&lt;...&gt;</code>：函数返回一个 <code>Promise</code>。</li>
<li><code>{ [K in keyof T]: Awaited&lt;T[K]&gt; }</code>：将结果类型组成数组。
<ul>
<li><code>{ [K in keyof T]: ... }</code>：这是一个映射类型，遍历元组 <code>T</code> 的所有索引 <code>K</code>（如 0、1、2...），并为每个索引生成对应的类型。</li>
<li><code>Awaited&lt;T[K]&gt;</code>：获取 <code>Promise</code> 或者类似 <code>Promise</code> 的对象的结果类型。
<ul>
<li>若 <code>T[K]</code> 是 <code>Promise&lt;X&gt;</code>，则 <code>Awaited&lt;T[K]&gt;</code> 为 <code>X</code>;</li>
<li>若 <code>T[K]</code> 是普通值 <code>X</code>，则 <code>Awaited&lt;T[K]&gt;</code> 仍为 <code>X</code>;</li>
<li><code>Awaited</code> 支持嵌套 <code>Promise</code>，如 <code>Awaited&lt;Promise&lt;Promise&lt;X&gt;&gt;&gt;</code> 也会解析为 <code>X</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-3">相关知识点</h3>
<h4 data-id="heading-4"><code>extends</code></h4>




















<table><thead><tr><th>使用维度</th><th>核心作用</th><th>示例场景</th></tr></thead><tbody><tr><td>类型维度</td><td>做类型约束或条件判断（类型编程核心）</td><td>限定泛型范围、判断类型是否兼容、提取类型片段</td></tr><tr><td>语法维度</td><td>做继承（复用已有结构）</td><td>接口继承、类继承</td></tr></tbody></table>
<h5 data-id="heading-5"><code>extends</code> 做类型约束或条件判断</h5>
<ol>
<li>泛型约束：限定泛型的取值范围</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 约束 T 必须是「拥有 length 属性」的类型（比如 string/数组）</span>
<span class="hljs-keyword">function</span> getLength&lt;T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">arg</span>: T): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">length</span>;
}

<span class="hljs-comment">// 合法调用（符合约束）</span>
<span class="hljs-title function_">getLength</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// ✅ string 有 length，返回 5</span>
<span class="hljs-title function_">getLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// ✅ 数组有 length，返回 3</span>

<span class="hljs-comment">// 非法调用（超出约束）</span>
<span class="hljs-title function_">getLength</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// ❌ 报错：number 没有 length 属性</span>
</code></pre>
<ol start="2">
<li>条件类型：类型版 <strong>三元运算符</strong></li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基础示例：判断类型是否为字符串</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;

<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-string">"test"</span>&gt;; <span class="hljs-comment">// true（符合）</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-number">123</span>&gt;; <span class="hljs-comment">// false（不符合）</span>
</code></pre>
<p>分布式条件类型（联合类型专用）: 当 <code>T</code> 是联合类型时，<code>extends</code> 会自动拆分联合类型的每个成员，逐个判断后再合并结果。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Union</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span>;

<span class="hljs-comment">// 拆分逻辑：string→string，number→never，boolean→never → 合并为 string</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OnlyString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? T : <span class="hljs-built_in">never</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">OnlyString</span>&lt;<span class="hljs-title class_">Union</span>&gt;; <span class="hljs-comment">// Result = string</span>
</code></pre>
<p>注意：只有泛型参数是 裸类型（没有被 []/{} 包裹）时，才会触发分布式判断：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 包裹后不触发分布式，整体判断 [string|number] 是否兼容 [string]</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">NoDist</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">string</span>] ? T : <span class="hljs-built_in">never</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">NoDist</span>&lt;<span class="hljs-title class_">Union</span>&gt;; <span class="hljs-comment">// never（整体不兼容）</span>
</code></pre>
<ol start="3">
<li>配合 <code>infer</code>：提取类型片段（黄金组合）</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 提取 Promise 的返回值类型</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnwrapPromise</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer V&gt; ? V : T;

<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">UnwrapPromise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;; <span class="hljs-comment">// string（提取成功）</span>
<span class="hljs-keyword">type</span> D = <span class="hljs-title class_">UnwrapPromise</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// number（不满足条件，返回原类型）</span>
</code></pre>
<h5 data-id="heading-6"><code>extends</code> 做继承（复用已有结构）</h5>
<ol>
<li>接口继承：复用 + 扩展属性</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基础接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 继承 User，并扩展新属性</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">role</span>: <span class="hljs-string">"admin"</span> | <span class="hljs-string">"super_admin"</span>; <span class="hljs-comment">// 新增权限属性</span>
}

<span class="hljs-comment">// 必须包含继承的 + 扩展的所有属性</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">admin</span>: <span class="hljs-title class_">Admin</span> = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">role</span>: <span class="hljs-string">"admin"</span>
};

<span class="hljs-comment">// 多接口继承</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasAge</span> { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span>, <span class="hljs-title class_">HasAge</span> {
  <span class="hljs-attr">className</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 同时继承 User + HasAge</span>
}
</code></pre>
<ol start="2">
<li>类继承：复用父类的属性 / 方法</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}

<span class="hljs-comment">// 继承 Parent 类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 必须调用父类构造函数（初始化父类属性）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }
  <span class="hljs-comment">// 重写父类方法</span>
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 调用父类原方法</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
  }
}

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">10</span>);
child.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出：Hi, 李四 → I'm 10 years old</span>
</code></pre>
<p>补充：类实现接口用 <code>implements</code>（不是 <code>extends</code>）</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义接口（契约：规定必须有 id、name 属性，以及 greet 方法）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 仅定义方法签名，无实现</span>
}

<span class="hljs-comment">// 类实现接口（必须严格遵守契约）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-comment">// 必须实现接口的所有属性</span>
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// 构造函数初始化属性</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-comment">// 必须实现接口的 greet 方法（具体实现由类自己定义）</span>
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, ID: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.id}</span>`</span>);
  }
}

<span class="hljs-comment">// 实例化使用</span>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"张三"</span>);
emp.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hi, I'm 张三, ID: 1</span>


<span class="hljs-comment">// 接口1：基础信息</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identifiable</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">getId</span>(): <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 接口2：可打印</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span> {
  <span class="hljs-title function_">printInfo</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">// 类同时实现两个接口（必须实现所有接口的成员）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Identifiable</span>, <span class="hljs-title class_">Printable</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 类可扩展接口外的属性</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-comment">// 实现 Identifiable 的方法</span>
  <span class="hljs-title function_">getId</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>;
  }

  <span class="hljs-comment">// 实现 Printable 的方法</span>
  <span class="hljs-title function_">printInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Product: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, ID: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getId()}</span>`</span>);
  }
}

<span class="hljs-keyword">const</span> product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(<span class="hljs-number">100</span>, <span class="hljs-string">"手机"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(product.<span class="hljs-title function_">getId</span>()); <span class="hljs-comment">// 100</span>
product.<span class="hljs-title function_">printInfo</span>(); <span class="hljs-comment">// Product: 手机, ID: 100</span>
</code></pre>
<h4 data-id="heading-7"><code>in</code></h4>
<p><code>in</code> 运算符用于遍历联合类型中的每个成员，将其转换为映射类型的属性名。</p>
<p>例如：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoKeys</span> = <span class="hljs-string">'title'</span> | <span class="hljs-string">'description'</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = {
  [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">TodoKeys</span>]: <span class="hljs-title class_">Todo</span>[P]
}
<span class="hljs-comment">// TodoPreview 类型为：</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   title: string</span>
<span class="hljs-comment">//   completed: boolean</span>
<span class="hljs-comment">// }</span>
</code></pre>
<h4 data-id="heading-8"><code>keyof</code></h4>
<p><code>keyof</code> 运算符用于获取一个类型（接口、类型别名、对象类型等）的所有公共属性名，并返回这些属性名组成的联合类型。</p>
<p>例如：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoKeys</span> = keyof <span class="hljs-title class_">Todo</span> <span class="hljs-comment">// "title" | "description" | "completed"</span>
</code></pre>
<h4 data-id="heading-9"><code>Awaited</code></h4>
<p><code>Awaited&lt;Type&gt;</code> 用于提取嵌套 <code>Promise</code> 类型的最终解析值。</p>
<ol>
<li>当 <code>T</code> 是 <code>Promise&lt;U&gt;</code> 时，<code>Awaited&lt;T&gt;</code> 会返回 <code>U</code>。</li>
<li>如果 <code>U</code> 本身也是 <code>Promise&lt;V&gt;</code>，则 <code>Awaited&lt;T&gt;</code> 会继续递归，返回 <code>V</code>。</li>
<li>若 <code>T</code> 不是 <code>Promise</code> 类型，则直接返回 <code>T</code>。</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;; <span class="hljs-comment">// string</span>

<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;; <span class="hljs-comment">// number</span>

<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;; <span class="hljs-comment">// number | boolean</span>
</code></pre>
<h3 data-id="heading-10">测试用例</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/* _____________ 测试用例 _____________ */</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Equal</span>, <span class="hljs-title class_">Expect</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@type-challenges/utils'</span>

<span class="hljs-keyword">const</span> promiseAllTest1 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
<span class="hljs-keyword">const</span> promiseAllTest2 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
<span class="hljs-keyword">const</span> promiseAllTest3 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)])
<span class="hljs-keyword">const</span> promiseAllTest4 = <span class="hljs-title class_">PromiseAll</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-keyword">const</span> promiseAllTest5 = <span class="hljs-title class_">PromiseAll</span>&lt;(<span class="hljs-built_in">number</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;)[]&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'3'</span>)])

<span class="hljs-keyword">type</span> cases = [
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest1, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest2, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">number</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest3, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest4, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>[]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest5, <span class="hljs-title class_">Promise</span>&lt;(<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[]&gt;&gt;&gt;,
]

</code></pre>
<h3 data-id="heading-11">相关链接</h3>
<blockquote>
<p>分享你的解答：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fanswer%2Fzh-CN" target="_blank" title="https://tsch.js.org/20/answer/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/20/answer/z…</a>
查看解答：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fsolutions" target="_blank" title="https://tsch.js.org/20/solutions" ref="nofollow noopener noreferrer">tsch.js.org/20/solution…</a>
更多题目：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2Fzh-CN" target="_blank" title="https://tsch.js.org/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/zh-CN</a></p>
</blockquote>
<p>下面是我的公众号，欢迎关注。关注后有新的功能点会及时收到推送。</p>
<blockquote>
<p><strong>前端功能点</strong>：实战为王！专注于汇总各种功能点，致力于打造一系列能够帮助工程师实现各种功能的想法思路的优质文章。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Ooder A2UI 第一性原理出发 深度解析核心逻辑]]></title>    <link>https://juejin.cn/post/7602454700503810089</link>    <guid>https://juejin.cn/post/7602454700503810089</guid>    <pubDate>2026-02-03T14:10:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700503810089" data-draft-id="7602503154505383977" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Ooder A2UI 第一性原理出发 深度解析核心逻辑"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-03T14:10:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Ooder A2UI 第一性原理出发 深度解析核心逻辑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:10:58.000Z" title="Tue Feb 03 2026 14:10:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>Ooder A2UI（Annotation to UI）是Ooder框架的核心组件之一，负责将Java类通过注解驱动的方式自动转换为UI组件。这一机制是Ooder实现"配置即代码"理念的关键技术，也是外界最质疑的地方：<strong>究竟是什么逻辑让它能够完成拆解？如何保证确定性？组织类方法的原则规则是什么？</strong></p>
<p>本文将从第一性原理出发，深入剖析A2UI的核心设计，还原作者的设计思考过程。</p>
<h2 data-id="heading-1">A2UI 拆解机制的核心原理</h2>
<h3 data-id="heading-2">1. 整体架构概览</h3>
<p>A2UI的拆解机制基于<strong>注解驱动的反射分析</strong>，通过多层次的抽象和映射，将Java类转换为UI组件。整体架构如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b86710486af040f1a74cb9edd948eb08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=Cb9%2FKytN7lOQYLEYLt8sp1xZ9JY%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h3 data-id="heading-3">2. 六阶段拆解流程</h3>
<p>A2UI的拆解过程分为六个明确的阶段，每个阶段都有其特定的职责和确定性保障。</p>
<h4 data-id="heading-4">阶段1：类加载阶段</h4>
<p>ReflectionClassLoaderBridgeClassUserReflectionClassLoaderBridgeClassUser创建BridgeClass加载Java类获取类信息返回类信息返回类对象获取所有字段返回字段列表获取所有方法返回方法列表返回BridgeClass实例</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23b5694417794ea9b6fdb8afbaaf2535~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=686cL98ysllVGLIi%2BD%2FvQszPW8Q%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Class ctClass</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctClass</span> = ctClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-comment">// 获取声明的字段（非静态、非内部类字段）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getDeclaredFields</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(field.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取公共字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getFields</span>()) {
        <span class="hljs-keyword">if</span> (field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取声明的方法（非静态）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtMethods</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; methodNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getDeclaredMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
            methodNames.<span class="hljs-title function_">add</span>(method.<span class="hljs-title function_">getName</span>());
        }
    }

    <span class="hljs-comment">// 获取公共方法（去重）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !methodNames.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getName</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">class</span>)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
        }
    }
}
</code></pre>
<h4 data-id="heading-5">设计思考：</h4>
<ol>
<li><strong>为什么区分声明字段和公共字段？</strong>
<ul>
<li>声明字段：获取类自己定义的字段，包括私有字段</li>
<li>公共字段：获取继承的公共字段，支持继承场景</li>
</ul>
</li>
<li><strong>为什么过滤静态成员？</strong>
<ul>
<li>静态成员属于类而非实例，不适合UI绑定</li>
<li>避免静态成员干扰UI渲染</li>
</ul>
</li>
<li><strong>为什么过滤内部类字段？</strong>
<ul>
<li>内部类字段通常用于编译器生成的辅助逻辑</li>
<li>避免将编译器生成的字段误认为业务字段</li>
</ul>
</li>
</ol>
<h4 data-id="heading-6">阶段2：注解解析阶段</h4>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d070da24dc441669ae7c902480889d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=GBqm3R8RHzlBOxFvj5G5r%2Fv78HI%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">MethodChinaName</span> chinaName = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MethodChinaName</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (chinaName != <span class="hljs-literal">null</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChinaBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChinaMeta</span>(chinaName);
}

<span class="hljs-title class_">RepositoryAnnotation</span> repository = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RepositoryAnnotation</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (repository != <span class="hljs-literal">null</span>) {
    repositoryBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepositoryMeta</span>(repository);
}

<span class="hljs-title class_">Aggregation</span> aggregationClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (aggregationClass != <span class="hljs-literal">null</span>) {
    aggregationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregationBean</span>(aggregationClass);
}

<span class="hljs-title class_">ESDEntity</span> dsmEntityClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">ESDEntity</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (dsmEntityClass != <span class="hljs-literal">null</span>) {
    entityBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityBean</span>(dsmEntityClass);
}

<span class="hljs-title class_">MenuBarMenu</span> menuBarMenu = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MenuBarMenu</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (menuBarMenu != <span class="hljs-literal">null</span>) {
    menuBarBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuBarMeta</span>(menuBarMenu);
}

<span class="hljs-title class_">DBTable</span> dbTable = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">DBTable</span>.<span class="hljs-property">class</span>);

<span class="hljs-title class_">RequestMapping</span> requestMapping = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RequestMapping</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (requestMapping != <span class="hljs-literal">null</span>) {
    requestMappingBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingBean</span>(requestMapping);
}

<span class="hljs-title class_">View</span> view = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">View</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) {
    viewBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewBean</span>(view);
}
</code></pre>
<h4 data-id="heading-7">设计思考：</h4>
<ol>
<li><strong>为什么需要这么多类级别注解？</strong>
<ul>
<li>不同的注解对应不同的业务场景</li>
<li>@Aggregation：聚合视图，用于组合多个实体</li>
<li>@Repository：仓储视图，用于数据访问</li>
<li>@ESDEntity：实体视图，用于数据实体</li>
<li>@MenuBarMenu：菜单视图，用于导航菜单</li>
<li>@RequestMapping：REST视图，用于API接口</li>
<li>@View：通用视图，用于自定义视图</li>
</ul>
</li>
<li><strong>为什么注解解析后要转换为Bean？</strong>
<ul>
<li>统一的数据结构，便于后续处理</li>
<li>解耦注解类型和业务逻辑</li>
<li>支持注解的版本演进</li>
</ul>
</li>
</ol>
<h4 data-id="heading-8">阶段3：字段拆解阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89ece97dcf744ef18cc23c16d13daaed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=hivxwzegVDtGfCrBWurs9kPen7w%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initField</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; fieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; disableFieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CustomAnnotation</span>&gt; customAnnotationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    int index = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 并行处理字段初始化</span>
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt;&gt; fieldTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
        fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
        index++;
    }
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt; fields = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">invokFieldTasks</span>(className, fieldTasks);

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeFieldConfig</span> fieldInfo : fields) {
        <span class="hljs-title class_">Field</span> field = fieldInfo.<span class="hljs-property">field</span>;
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isSerialize</span>()) {
            fieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            esdFieldMap.<span class="hljs-title function_">put</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>(), fieldInfo);
            fieldNameList.<span class="hljs-title function_">add</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>());
        } <span class="hljs-keyword">else</span> {
            disableFieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            disableFieldList.<span class="hljs-title function_">add</span>(fieldInfo);
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isUid</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = field.<span class="hljs-title function_">getName</span>();
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isCaptionField</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captionField</span> = fieldInfo;
        }
    }
}
</code></pre>
<h4 data-id="heading-9">设计思考：</h4>
<ol>
<li><strong>为什么使用LinkedHashMap而不是HashMap？</strong>
<ul>
<li>LinkedHashMap保持插入顺序</li>
<li>保证字段的显示顺序与声明顺序一致</li>
<li>提供确定性的字段顺序</li>
</ul>
</li>
<li><strong>为什么区分fieldMap和disableFieldMap？</strong>
<ul>
<li>fieldMap：需要序列化和显示的字段</li>
<li>disableFieldMap：不需要显示的字段（如隐藏字段、系统字段）</li>
<li>分离关注点，提高处理效率</li>
</ul>
</li>
<li><strong>为什么使用并行处理？</strong>
<ul>
<li>字段初始化是CPU密集型操作</li>
<li>并行处理可以显著提高性能</li>
<li>特别是在字段数量较多时</li>
</ul>
</li>
</ol>
<h4 data-id="heading-10">阶段4：方法拆解阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1b12def00994a139fa1a34e344d2904~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=t0EqQdb9%2BqNlIwkKw3WlRQNIdgU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">BridgeMethodConfig</span>(<span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">BridgeClass</span> bridgeClass) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerMethod</span> = method;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnType</span> = method.<span class="hljs-title function_">getReturnType</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">domainId</span> = bridgeClass.<span class="hljs-title function_">getDomainId</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridgeClass</span> = bridgeClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = method.<span class="hljs-title function_">getName</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerMethod</span> = method;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = fieldName;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = fieldName;

    <span class="hljs-title class_">String</span> fieldName = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);

    <span class="hljs-comment">// 查找对应的字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> fieldInfo : <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridgeClass</span>.<span class="hljs-title function_">getAllCtFields</span>()) {
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">equals</span>(fieldName)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">field</span> = fieldInfo;
            <span class="hljs-keyword">continue</span>;
        }
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (returnType.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(returnType)) {
            <span class="hljs-title class_">Class</span> innerClass = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerReturnType</span>(method);
            <span class="hljs-keyword">if</span> (innerClass != <span class="hljs-literal">null</span>) {
                returnType = innerClass;
            }
        }
        <span class="hljs-title function_">init</span>(index, bridgeClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRefBean</span>() != <span class="hljs-literal">null</span>) {
            <span class="hljs-title class_">CustomRefMeta</span> ref = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRefBean</span>();
            <span class="hljs-keyword">if</span> (ref.<span class="hljs-title function_">getView</span>() != <span class="hljs-literal">null</span> &amp;&amp; ref.<span class="hljs-title function_">getView</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ViewType</span>.<span class="hljs-property">DIC</span>)) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
            }
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">refType</span> = ref.<span class="hljs-title function_">getRef</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewType</span> = ref.<span class="hljs-title function_">getView</span>();
        }

        <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span>) {
            componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
        }
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }

    <span class="hljs-comment">// 检查是否为模块方法</span>
    <span class="hljs-title class_">ModuleAnnotation</span> annotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">ModuleAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (annotation != <span class="hljs-literal">null</span>) {
        isModule = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-title class_">ModuleRefFieldAnnotation</span> comboModuleAnnotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">ModuleRefFieldAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (comboModuleAnnotation != <span class="hljs-literal">null</span>) {
        isModule = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-title class_">APIEventAnnotation</span> apiEventAnnotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (apiEventAnnotation != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">CustomMenuItem</span> menuItem : apiEventAnnotation.<span class="hljs-title function_">bindMenu</span>()) {
            <span class="hljs-keyword">if</span> (!menuItem.<span class="hljs-title function_">getReturnView</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ModuleViewType</span>.<span class="hljs-property">NONE</span>) &amp;&amp; menuItem.<span class="hljs-title function_">getDefaultView</span>()) {
                isModule = <span class="hljs-literal">true</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-11">设计思考：</h4>
<ol>
<li><strong>为什么需要查找对应的字段？</strong>
<ul>
<li>方法可能对应某个字段的Getter/Setter</li>
<li>字段的注解可以补充方法的元数据</li>
<li>支持字段和方法的协同工作</li>
</ul>
</li>
<li><strong>为什么需要处理数组和集合类型？</strong>
<ul>
<li>数组和集合需要获取内部类型</li>
<li>内部类型决定UI组件类型</li>
<li>支持泛型类型的正确处理</li>
</ul>
</li>
<li><strong>为什么需要检查是否为模块方法？</strong>
<ul>
<li>模块方法返回的是UI组件</li>
<li>需要特殊处理模块方法的渲染</li>
<li>支持动态UI组件的生成</li>
</ul>
</li>
</ol>
<h4 data-id="heading-12">阶段5：类型映射阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a63eb31301ce453e9589699481fa4e4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=QE0lCgRQRkwZOuh%2B5%2BC%2FvatyUKs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">static</span> <span class="hljs-title class_">ComponentType</span> <span class="hljs-title function_">getComponentType</span>(<span class="hljs-params">Class typeClass, Type type</span>) {
    <span class="hljs-title class_">Class</span> clazz = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerType</span>(type);

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Enumstype</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz) || clazz.<span class="hljs-title function_">isEnum</span>()) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (typeClass != <span class="hljs-literal">null</span> &amp;&amp; (typeClass.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(typeClass))) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(customClass).<span class="hljs-title function_">contains</span>(clazz) || typeClass.<span class="hljs-title function_">equals</span>(clazz)) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
        }
    }

    <span class="hljs-keyword">if</span> (java.<span class="hljs-property">sql</span>.<span class="hljs-property">Date</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(short.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Short</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(int.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Integer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(boolean.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Boolean</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">CHECKBOX</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(long.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Long</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(float.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Float</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">BigDecimal</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">BigInteger</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Reader</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">StringBuffer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
}
</code></pre>
<h4 data-id="heading-13">设计思考：</h4>
<ol>
<li><strong>为什么需要处理泛型类型？</strong>
<ul>
<li>泛型类型在编译时会被擦除</li>
<li>需要通过反射获取实际类型</li>
<li>支持泛型集合的正确映射</li>
</ul>
</li>
<li><strong>为什么Boolean映射到CHECKBOX而不是INPUT？</strong>
<ul>
<li>CHECKBOX更符合布尔值的语义</li>
<li>提供更好的用户体验</li>
<li>减少用户输入错误</li>
</ul>
</li>
<li><strong>为什么StringBuffer映射到RICHEDITOR？</strong>
<ul>
<li>StringBuffer通常用于存储长文本</li>
<li>RICHEDITOR支持富文本编辑</li>
<li>提供更好的文本编辑体验</li>
</ul>
</li>
</ol>
<h4 data-id="heading-14">阶段6：组件生成阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4abbe19e437f4ff492d454fadc01a1a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=vUYLyq6fU2yFFG6SrDBuJye2n%2FU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title function_">C2UConfigFactory</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt; allClassMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    allClassMap.<span class="hljs-title function_">putAll</span>(<span class="hljs-title class_">EsbBeanFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getAllClass</span>());
    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt;&gt; allClass = allClassMap.<span class="hljs-title function_">entrySet</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt; clazzEntry : allClass) {
        <span class="hljs-title class_">Class</span> clazz = clazzEntry.<span class="hljs-title function_">getValue</span>();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title function_">initClass</span>(clazz);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> e) {
            <span class="hljs-comment">// 忽略初始化失败的类</span>
        }
    }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initClass</span>(<span class="hljs-params">Class beanClazz</span>) {
    <span class="hljs-title class_">CustomClass</span> customClass = (<span class="hljs-title class_">CustomClass</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">CustomClass</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CustomBean</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(beanClazz) &amp;&amp; customClass != <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">AnnotationType</span> ann = (<span class="hljs-title class_">AnnotationType</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">AnnotationType</span>.<span class="hljs-property">class</span>);
        viewTypeAnnMap.<span class="hljs-title function_">put</span>(ann.<span class="hljs-title function_">clazz</span>(), customClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UIComponent</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(customClass.<span class="hljs-title function_">clazz</span>())) {
            <span class="hljs-keyword">switch</span> (customClass.<span class="hljs-title function_">viewType</span>()) {
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMPONENT</span>:
                    <span class="hljs-title class_">WidgetMetaMap</span>.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), beanClazz);
                    widgetComponentMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), customClass.<span class="hljs-title function_">clazz</span>());
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMBOBOX</span>:
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                            comboBoxAnnMap.<span class="hljs-title function_">put</span>(inputType, ann.<span class="hljs-title function_">clazz</span>());
                            comboBoxComponentMap.<span class="hljs-title function_">put</span>(inputType, customClass.<span class="hljs-title function_">clazz</span>());
                        }
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }

                    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                        comboBoxBeanMap.<span class="hljs-title function_">put</span>(inputType, beanClazz);
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-15">设计思考：</h4>
<ol>
<li><strong>为什么需要扫描所有类？</strong>
<ul>
<li>自动发现所有UI组件</li>
<li>避免手动注册组件</li>
<li>支持组件的热插拔</li>
</ul>
</li>
<li><strong>为什么使用Map存储组件映射？</strong>
<ul>
<li>快速查找组件类</li>
<li>O(1)时间复杂度</li>
<li>提高组件创建效率</li>
</ul>
</li>
<li><strong>为什么需要区分COMPONENT和COMBOBOX？</strong>
<ul>
<li>COMPONENT：独立组件（如Input、Checkbox）</li>
<li>COMBOBOX：下拉组件（如Date、Number）</li>
<li>不同的组件类型有不同的渲染逻辑</li>
</ul>
</li>
</ol>
<h2 data-id="heading-16">确定性来源分析</h2>
<p>A2UI的确定性来自以下五个层次，每个层次都有其特定的确定性保障机制。</p>
<h3 data-id="heading-17">1. 注解层确定性</h3>
<p>注解是A2UI确定性的第一层保障，通过注解提供明确的元数据。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47e11fa9bb90457197559de294fd611d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=3axOZ4m2lSPDCeCiAcKfvsnppC8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>注解确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">@<span class="hljs-title class_">CustomAnnotation</span>(
    caption = <span class="hljs-string">"用户名"</span>,
    uid = <span class="hljs-literal">true</span>,
    readonly = <span class="hljs-literal">true</span>,
    required = <span class="hljs-literal">true</span>
)
private <span class="hljs-title class_">String</span> username;

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. caption明确字段的显示名称</span>
<span class="hljs-comment">// 2. uid明确字段为主键</span>
<span class="hljs-comment">// 3. readonly明确字段为只读</span>
<span class="hljs-comment">// 4. required明确字段为必填</span>
</code></pre>
<h4 data-id="heading-18">设计思考：</h4>
<ol>
<li><strong>为什么注解能提供确定性？</strong>
<ul>
<li>注解是编译时元数据，不会在运行时改变</li>
<li>注解的值是明确的字符串或枚举</li>
<li>注解的解析规则是固定的</li>
</ul>
</li>
<li><strong>为什么需要这么多注解？</strong>
<ul>
<li>不同的注解对应不同的字段属性</li>
<li>支持灵活的字段配置</li>
<li>满足不同的业务场景</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">2. 类型层确定性</h3>
<p>Java类型系统是A2UI确定性的第二层保障，通过类型映射提供组件选择的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b1e7a4f3dcd45d0945fed256a7be5c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=T2C4FtlQUY03YY9bYpA%2F9gQcg1k%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>类型确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">private <span class="hljs-title class_">Boolean</span> isActive;  <span class="hljs-comment">// -&gt; CHECKBOX</span>
private <span class="hljs-title class_">Integer</span> age;      <span class="hljs-comment">// -&gt; COMBOINPUT</span>
private <span class="hljs-title class_">Date</span> birthday;    <span class="hljs-comment">// -&gt; COMBOINPUT</span>
private <span class="hljs-title class_">UserStatus</span> status; <span class="hljs-comment">// -&gt; COMBOINPUT (Enum)</span>
private <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; tags; <span class="hljs-comment">// -&gt; LIST</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. Boolean类型必然映射到CHECKBOX</span>
<span class="hljs-comment">// 2. Integer类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 3. Date类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 4. Enum类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 5. Collection类型必然映射到LIST</span>
</code></pre>
<h4 data-id="heading-20">设计思考：</h4>
<ol>
<li><strong>为什么类型能提供确定性？</strong>
<ul>
<li>Java类型系统是静态的，编译时确定</li>
<li>类型的继承关系是明确的</li>
<li>类型映射规则是固定的</li>
</ul>
</li>
<li><strong>为什么需要区分基本类型和包装类型？</strong>
<ul>
<li>基本类型和包装类型在反射中处理不同</li>
<li>包装类型支持null值</li>
<li>基本类型有默认值</li>
</ul>
</li>
</ol>
<h3 data-id="heading-21">3. 命名约定层确定性</h3>
<p>Java Bean命名约定是A2UI确定性的第三层保障，通过命名约定提供方法识别的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1ea4f17a559438ba74c672df94e6a99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=U7cHel5sOkegxqwi0YQ%2Bhx%2F5xr8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>命名约定确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> name;
}  <span class="hljs-comment">// -&gt; fieldName = "name"</span>

public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUserName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> userName;
}  <span class="hljs-comment">// -&gt; fieldName = "userName"</span>

public boolean <span class="hljs-title function_">isActive</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> active;
}  <span class="hljs-comment">// -&gt; fieldName = "active"</span>

public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">Integer age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}  <span class="hljs-comment">// -&gt; fieldName = "age"</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. getName()必然对应name字段</span>
<span class="hljs-comment">// 2. getUserName()必然对应userName字段</span>
<span class="hljs-comment">// 3. isActive()必然对应active字段</span>
<span class="hljs-comment">// 4. setAge()必然对应age字段</span>
</code></pre>
<h4 data-id="heading-22">设计思考：</h4>
<ol>
<li><strong>为什么命名约定能提供确定性？</strong>
<ul>
<li>Java Bean规范是业界标准</li>
<li>命名规则是明确的</li>
<li>方法名到字段名的映射是固定的</li>
</ul>
</li>
<li><strong>为什么需要支持多种命名模式？</strong>
<ul>
<li>支持标准的Getter/Setter</li>
<li>支持Boolean的isXxx模式</li>
<li>支持驼峰命名转换</li>
</ul>
</li>
</ol>
<h3 data-id="heading-23">4. 索引层确定性</h3>
<p>索引属性是A2UI确定性的第四层保障，通过索引保证字段顺序的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4f842ee622a4ecfad9740ef52a62f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=fZrx%2BFa6joZcbFb%2B%2FLBj%2FHTzXmw%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>索引确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserForm</span> {
    private <span class="hljs-title class_">String</span> name;        <span class="hljs-comment">// index = 0</span>
    private <span class="hljs-title class_">Integer</span> age;       <span class="hljs-comment">// index = 1</span>
    private <span class="hljs-title class_">Date</span> birthday;     <span class="hljs-comment">// index = 2</span>
    private <span class="hljs-title class_">Boolean</span> active;    <span class="hljs-comment">// index = 3</span>

    @<span class="hljs-title class_">CustomAnnotation</span>(index = <span class="hljs-number">10</span>)
    private <span class="hljs-title class_">String</span> email;      <span class="hljs-comment">// index = 10 (自定义索引)</span>
}

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. name字段必然在第一个位置</span>
<span class="hljs-comment">// 2. age字段必然在第二个位置</span>
<span class="hljs-comment">// 3. birthday字段必然在第三个位置</span>
<span class="hljs-comment">// 4. active字段必然在第四个位置</span>
<span class="hljs-comment">// 5. email字段必然在第十个位置（自定义索引）</span>
</code></pre>
<h4 data-id="heading-24">设计思考：</h4>
<ol>
<li><strong>为什么索引能提供确定性？</strong>
<ul>
<li>索引是整数，可以排序</li>
<li>索引的分配规则是固定的</li>
<li>索引的优先级是明确的</li>
</ul>
</li>
<li><strong>为什么需要支持自定义索引？</strong>
<ul>
<li>允许开发者调整字段顺序</li>
<li>支持字段的灵活排列</li>
<li>满足不同的UI需求</li>
</ul>
</li>
</ol>
<h3 data-id="heading-25">5. 映射规则层确定性</h3>
<p>映射规则是A2UI确定性的第五层保障，通过映射规则提供组件选择的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4594f0f83e9f46d1a75a9031a04a65c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=m5zl9EEW69yRKrAHfmXvOlmUtmc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>映射规则确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ComponentType -&gt; UIComponent</span>
<span class="hljs-variable constant_">INPUT</span> -&gt; <span class="hljs-title class_">InputUIComponent</span>
<span class="hljs-variable constant_">CHECKBOX</span> -&gt; <span class="hljs-title class_">CheckboxUIComponent</span>
<span class="hljs-variable constant_">COMBOINPUT</span> -&gt; <span class="hljs-title class_">ComboInputUIComponent</span>
<span class="hljs-variable constant_">RICHEDITOR</span> -&gt; <span class="hljs-title class_">RichEditorUIComponent</span>

<span class="hljs-comment">// ComboInputType -&gt; ComboBoxMeta</span>
number -&gt; <span class="hljs-title class_">NumberComboBoxMeta</span>
date -&gt; <span class="hljs-title class_">DateComboBoxMeta</span>
checkbox -&gt; <span class="hljs-title class_">CheckboxComboBoxMeta</span>
listbox -&gt; <span class="hljs-title class_">ListboxComboBoxMeta</span>

<span class="hljs-comment">// ColType -&gt; ComponentType</span>
<span class="hljs-variable constant_">BOOLEAN</span> -&gt; <span class="hljs-variable constant_">CHECKBOX</span>
<span class="hljs-variable constant_">TEXT</span> -&gt; <span class="hljs-variable constant_">MULTILINES</span>
<span class="hljs-variable constant_">DATETIME</span> -&gt; <span class="hljs-variable constant_">COMBOINPUT</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. INPUT必然映射到InputUIComponent</span>
<span class="hljs-comment">// 2. CHECKBOX必然映射到CheckboxUIComponent</span>
<span class="hljs-comment">// 3. number必然映射到NumberComboBoxMeta</span>
<span class="hljs-comment">// 4. BOOLEAN必然映射到CHECKBOX</span>
</code></pre>
<h4 data-id="heading-26">设计思考：</h4>
<ol>
<li><strong>为什么映射规则能提供确定性？</strong>
<ul>
<li>映射规则是预定义的</li>
<li>映射关系是一对一的</li>
<li>映射规则不会在运行时改变</li>
</ul>
</li>
<li><strong>为什么需要多层次的映射？</strong>
<ul>
<li>支持不同的抽象层次</li>
<li>支持不同的使用场景</li>
<li>提供灵活的映射机制</li>
</ul>
</li>
</ol>
<h2 data-id="heading-27">组织类方法的原则规则</h2>
<p>A2UI组织类方法遵循六大原则，每个原则都有其特定的设计目的和实现方式。</p>
<h3 data-id="heading-28">原则1：字段优先原则</h3>
<p>字段优先原则是指在字段和方法都存在时，优先使用字段的定义。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fb551f5bb63480eb2443910c69c8354~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=YjjNnxFx3mHlQkPVauwJ1nWmY%2FQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeMethodConfig</span> methodInfo : methodInfos) {
    <span class="hljs-keyword">if</span> (methodInfo.<span class="hljs-title function_">isSerialize</span>()) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">isGetMethod</span>(methodInfo.<span class="hljs-title function_">getInnerMethod</span>()) || methodInfo.<span class="hljs-title function_">isModule</span>()) {
            <span class="hljs-title class_">String</span> fieldName = methodInfo.<span class="hljs-title function_">getFieldName</span>();
            <span class="hljs-title class_">CustomAnnotation</span> allmapping = customAnnotationMap.<span class="hljs-title function_">get</span>(fieldName);

            <span class="hljs-comment">// 字段必须可见</span>
            <span class="hljs-keyword">if</span> (!disableFieldMap.<span class="hljs-title function_">containsKey</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>())) {
                <span class="hljs-comment">// 如果字段未定义或为默认字段，才使用方法</span>
                <span class="hljs-title class_">BridgeField</span> field = fieldMap.<span class="hljs-title function_">get</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>());
                <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>
                        || !(field <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">BridgeFieldConfig</span>)
                        || ((<span class="hljs-title class_">BridgeFieldConfig</span>) fieldMap.<span class="hljs-title function_">get</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>())).<span class="hljs-title function_">isDefault</span>()) {
                    fieldMap.<span class="hljs-title function_">put</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>(), methodInfo);
                    esdFieldMap.<span class="hljs-title function_">put</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>(), methodInfo);
                    <span class="hljs-keyword">if</span> (!fieldNameList.<span class="hljs-title function_">contains</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>())) {
                        fieldNameList.<span class="hljs-title function_">add</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>());
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (allmapping == <span class="hljs-literal">null</span> &amp;&amp; (methodInfo.<span class="hljs-title function_">isCustomFiled</span>() || methodInfo.<span class="hljs-title function_">isDynLoad</span>())) {
                        <span class="hljs-comment">// 优先使用字段注解</span>
                        fieldMap.<span class="hljs-title function_">put</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>(), methodInfo);
                    }
                }
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-29">设计思考：</h4>
<ol>
<li><strong>为什么字段优先？</strong>
<ul>
<li>字段是数据的直接表示，更直观</li>
<li>字段的类型和注解更明确</li>
<li>减少方法解析的复杂性</li>
</ul>
</li>
<li><strong>什么时候使用方法？</strong>
<ul>
<li>字段未定义时</li>
<li>字段为默认字段时</li>
<li>方法有自定义注解时</li>
</ul>
</li>
</ol>
<h3 data-id="heading-30">原则2：Getter/Setter识别原则</h3>
<p>Getter/Setter识别原则是指通过方法名识别Getter和Setter方法。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bc0882c7478471a9446aa9658380782~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=MHndJ9OMtG6NbK%2Fyanx0jPaYQew%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);

<span class="hljs-comment">// MethodUtil.getFieldName() 实现逻辑</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getFieldName</span>(<span class="hljs-params">Method method</span>) {
    <span class="hljs-title class_">String</span> methodName = method.<span class="hljs-title function_">getName</span>();
    <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"get"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">3</span>), <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"set"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">3</span>), <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"is"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>), <span class="hljs-literal">false</span>);
    }
    <span class="hljs-keyword">return</span> methodName;
}
</code></pre>
<h4 data-id="heading-31">设计思考：</h4>
<ol>
<li><strong>为什么识别Getter/Setter？</strong>
<ul>
<li>符合Java Bean规范</li>
<li>提供对私有字段的访问</li>
<li>支持动态计算字段</li>
</ul>
</li>
<li><strong>为什么需要三种模式？</strong>
<ul>
<li>getXxx：标准Getter</li>
<li>setXxx：标准Setter</li>
<li>isXxx：Boolean Getter</li>
</ul>
</li>
</ol>
<h3 data-id="heading-32">原则3：注解优先级原则</h3>
<p>注解优先级原则是指不同注解之间有明确的优先级顺序。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5495561b33dc40088bf7206a9cba0eb8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=hngpTzNUiSyJ6WM0vDtM%2Bk3tmgs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Integer index, BridgeClass bridgeClass</span>) {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// CustomAnnotation - 最高优先级</span>
    <span class="hljs-keyword">if</span> (customAnnotation != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">customBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFieldMeta</span>(customAnnotation);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = customBean.<span class="hljs-title function_">getIndex</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">target</span> = customBean.<span class="hljs-title function_">getTarget</span>();
        <span class="hljs-keyword">if</span> (customAnnotation.<span class="hljs-title function_">hidden</span>()) {
            componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">HIDDENINPUT</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">hidden</span> = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isCaption</span> = customAnnotation.<span class="hljs-title function_">captionField</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = customAnnotation.<span class="hljs-title function_">uid</span>();
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// JSONField - 覆盖基本属性</span>
    <span class="hljs-keyword">if</span> (jsonField != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">serialize</span> = jsonField.<span class="hljs-title function_">serialize</span>();
        <span class="hljs-keyword">if</span> (!jsonField.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = jsonField.<span class="hljs-title function_">name</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = jsonField.<span class="hljs-title function_">name</span>();
        }
        <span class="hljs-keyword">if</span> (!jsonField.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
            id = jsonField.<span class="hljs-title function_">name</span>();
        }
    }

    <span class="hljs-comment">// 中文注解 - 最后覆盖</span>
    <span class="hljs-keyword">if</span> (caption == <span class="hljs-literal">null</span> || caption.<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
        <span class="hljs-keyword">if</span> (methodChinaName != <span class="hljs-literal">null</span>) {
            caption = methodChinaName.<span class="hljs-title function_">cname</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (caption.<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">caption</span> = name;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-33">设计思考：</h4>
<ol>
<li><strong>为什么需要优先级？</strong>
<ul>
<li>支持灵活的配置</li>
<li>允许覆盖默认行为</li>
<li>保持向后兼容性</li>
</ul>
</li>
<li><strong>为什么CustomAnnotation优先级最高？</strong>
<ul>
<li>CustomAnnotation是业务注解</li>
<li>业务需求优先于框架需求</li>
<li>支持自定义业务逻辑</li>
</ul>
</li>
</ol>
<h3 data-id="heading-34">原则4：索引排序原则</h3>
<p>索引排序原则是指按照索引值对字段进行排序。</p>
<p>Index Sorting</p>
<p>Get All Fields</p>
<p>Sort by Index</p>
<p>Render in Order</p>
<p>Field1: index=0</p>
<p>Field2: index=1</p>
<p>Field3: index=2</p>
<p>Field4: index=10</p>
<p>Field1, Field2, Field3, Field4</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">int index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
    fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
    index++;
}

<span class="hljs-comment">// BridgeBaseField.java</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = index;

@<span class="hljs-title class_">Override</span>
public int <span class="hljs-title function_">compareTo</span>(<span class="hljs-params">BridgeField o</span>) {
    <span class="hljs-keyword">if</span> (index == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">null</span> &amp;&amp; o.<span class="hljs-title function_">getIndex</span>() != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> - o.<span class="hljs-title function_">getIndex</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 data-id="heading-35">设计思考：</h4>
<ol>
<li><strong>为什么需要索引排序？</strong>
<ul>
<li>保证字段顺序的确定性</li>
<li>支持自定义排序</li>
<li>便于UI渲染</li>
</ul>
</li>
<li><strong>为什么使用compareTo？</strong>
<ul>
<li>支持Collections.sort()</li>
<li>提供灵活的排序机制</li>
<li>符合Java规范</li>
</ul>
</li>
</ol>
<h3 data-id="heading-36">原则5：类型推断原则</h3>
<p>类型推断原则是指根据Java类型推断UI组件类型。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1863ca9a3d44df6ab8775a50cd2e673~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=ZEXXjwpffg16Pgu6BoWTLXC1OWQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">static</span> <span class="hljs-title class_">ComponentType</span> <span class="hljs-title function_">getComponentType</span>(<span class="hljs-params">Class typeClass, Type type</span>) {
    <span class="hljs-title class_">Class</span> clazz = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerType</span>(type);

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Enumstype</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz) || clazz.<span class="hljs-title function_">isEnum</span>()) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (typeClass != <span class="hljs-literal">null</span> &amp;&amp; (typeClass.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(typeClass))) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(customClass).<span class="hljs-title function_">contains</span>(clazz) || typeClass.<span class="hljs-title function_">equals</span>(clazz)) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
        }
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(boolean.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Boolean</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">CHECKBOX</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(int.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Integer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Reader</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">StringBuffer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
}
</code></pre>
<h4 data-id="heading-37">设计思考：</h4>
<ol>
<li><strong>为什么需要类型推断？</strong>
<ul>
<li>减少注解的使用</li>
<li>提供合理的默认值</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>为什么需要检查多种类型？</strong>
<ul>
<li>支持不同的Java类型</li>
<li>支持泛型类型</li>
<li>支持自定义类型</li>
</ul>
</li>
</ol>
<h3 data-id="heading-38">原则6：组件映射原则</h3>
<p>组件映射原则是指将组件类型映射到具体的UI组件类。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8c3883281184a8bb21c5990c82effe8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=8reYmzBQCuWdC5vdk4JGTJooJvU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">UIComponent</span>&gt; <span class="hljs-title function_">getComponent</span>(<span class="hljs-params">ComponentType componentType</span>) {
    <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">UIComponent</span>&gt; componentClass = widgetComponentMap.<span class="hljs-title function_">get</span>(componentType);
    <span class="hljs-keyword">return</span> componentClass;
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initClass</span>(<span class="hljs-params">Class beanClazz</span>) {
    <span class="hljs-title class_">CustomClass</span> customClass = (<span class="hljs-title class_">CustomClass</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">CustomClass</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CustomBean</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(beanClazz) &amp;&amp; customClass != <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">AnnotationType</span> ann = (<span class="hljs-title class_">AnnotationType</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">AnnotationType</span>.<span class="hljs-property">class</span>);
        viewTypeAnnMap.<span class="hljs-title function_">put</span>(ann.<span class="hljs-title function_">clazz</span>(), customClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UIComponent</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(customClass.<span class="hljs-title function_">clazz</span>())) {
            <span class="hljs-keyword">switch</span> (customClass.<span class="hljs-title function_">viewType</span>()) {
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMPONENT</span>:
                    <span class="hljs-title class_">WidgetMetaMap</span>.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), beanClazz);
                    widgetComponentMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), customClass.<span class="hljs-title function_">clazz</span>());
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMBOBOX</span>:
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                            comboBoxAnnMap.<span class="hljs-title function_">put</span>(inputType, ann.<span class="hljs-title function_">clazz</span>());
                            comboBoxComponentMap.<span class="hljs-title function_">put</span>(inputType, customClass.<span class="hljs-title function_">clazz</span>());
                        }
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }

                    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                        comboBoxBeanMap.<span class="hljs-title function_">put</span>(inputType, beanClazz);
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-39">设计思考：</h4>
<ol>
<li><strong>为什么需要组件映射？</strong>
<ul>
<li>支持组件扩展</li>
<li>提供组件查找机制</li>
<li>实现组件工厂模式</li>
</ul>
</li>
<li><strong>为什么需要区分COMPONENT和COMBOBOX？</strong>
<ul>
<li>COMPONENT：独立组件</li>
<li>COMBOBOX：下拉组件</li>
<li>不同的组件类型有不同的渲染逻辑</li>
</ul>
</li>
</ol>
<h2 data-id="heading-40">构建编译与列结构抽象建模</h2>
<h3 data-id="heading-41">1. 构建阶段</h3>
<p>构建阶段是指将Java类加载到内存中，并创建BridgeClass实例。</p>
<p>C2UConfigFactoryReflectionBridgeClassBridgeClassLoaderUserC2UConfigFactoryReflectionBridgeClassBridgeClassLoaderUser加载类获取类信息返回类信息创建BridgeClass获取字段和方法返回字段和方法初始化字段返回字段配置初始化方法返回方法配置返回BridgeClass实例</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Class ctClass</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctClass</span> = ctClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-comment">// 获取所有字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getDeclaredFields</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(field.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getFields</span>()) {
        <span class="hljs-keyword">if</span> (field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取所有方法</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtMethods</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; methodNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getDeclaredMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
            methodNames.<span class="hljs-title function_">add</span>(method.<span class="hljs-title function_">getName</span>());
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !methodNames.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getName</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">class</span>)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
        }
    }

    <span class="hljs-comment">// 解析类级别注解</span>
    <span class="hljs-title class_">MethodChinaName</span> chinaName = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MethodChinaName</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (chinaName != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChinaBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChinaMeta</span>(chinaName);
    }

    <span class="hljs-title class_">RepositoryAnnotation</span> repository = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RepositoryAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (repository != <span class="hljs-literal">null</span>) {
        repositoryBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepositoryMeta</span>(repository);
    }

    <span class="hljs-title class_">Aggregation</span> aggregationClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (aggregationClass != <span class="hljs-literal">null</span>) {
        aggregationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregationBean</span>(aggregationClass);
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h4 data-id="heading-42">设计思考：</h4>
<ol>
<li><strong>为什么需要构建阶段？</strong>
<ul>
<li>将类信息加载到内存</li>
<li>创建统一的数据结构</li>
<li>为后续处理做准备</li>
</ul>
</li>
<li><strong>为什么需要缓存字段和方法？</strong>
<ul>
<li>避免重复反射</li>
<li>提高性能</li>
<li>支持懒加载</li>
</ul>
</li>
</ol>
<h3 data-id="heading-43">2. 编译阶段</h3>
<p>编译阶段是指动态编译Java类，并注册到Spring容器。</p>
<p>SpringContainerClassLoaderJavaCompilerBridgeClassUserSpringContainerClassLoaderJavaCompilerBridgeClassUser动态编译编译Java源码加载编译后的类注册Bean注册成功返回Class对象</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">compileJavaSrc</span>(<span class="hljs-params">List&lt;JavaSrcMeta&gt; srcBeanList, <span class="hljs-built_in">String</span> projectName, ChromeProxy chrome</span>) {
    D2CGenerator javaGen = D2CGenerator.<span class="hljs-title function_">getInstance</span>(projectName);
    <span class="hljs-keyword">try</span> {
        javaGen.<span class="hljs-title function_">compileJavaSrc</span>(srcBeanList, chrome);
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">JDSException</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }

    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Class</span>?&gt;&gt; classSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    <span class="hljs-comment">// 更新服务注册</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">JavaSrcMeta</span> srcBean : srcBeanList) {
        <span class="hljs-title class_">Class</span> clazz = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            clazz = <span class="hljs-title class_">ClassUtility</span>.<span class="hljs-title function_">loadClass</span>(srcBean.<span class="hljs-title function_">getClassName</span>());
            classSet.<span class="hljs-title function_">add</span>(clazz);
            <span class="hljs-title function_">registerClass</span>(clazz);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassNotFoundException</span> e) {
            log.<span class="hljs-title function_">warn</span>(e.<span class="hljs-title function_">getMessage</span>());
        }
    }
    <span class="hljs-title class_">APIConfigFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">dyReload</span>(classSet);
}

public <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerClass</span>(<span class="hljs-params">Class clazz</span>) {
    <span class="hljs-keyword">if</span> (clazz != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(clazz, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>
                || <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(clazz, <span class="hljs-title class_">EsbBeanAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
            <span class="hljs-title class_">EsbBeanFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">registerService</span>(clazz);
        }
        <span class="hljs-title class_">String</span> className = clazz.<span class="hljs-title function_">getName</span>();
        <span class="hljs-keyword">try</span> {
            classManager.<span class="hljs-title function_">clear</span>(className);
            <span class="hljs-title class_">APIConfigFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">reload</span>(className);
            <span class="hljs-title class_">APIFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">loadApiConfig</span>(className);
            <span class="hljs-title class_">ClassUtility</span>.<span class="hljs-title function_">loadClass</span>(className);

        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
        }
    }
}
</code></pre>
<h4 data-id="heading-44">设计思考：</h4>
<ol>
<li><strong>为什么需要动态编译？</strong>
<ul>
<li>支持运行时生成代码</li>
<li>支持热部署</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>为什么需要注册到Spring容器？</strong>
<ul>
<li>支持依赖注入</li>
<li>支持AOP</li>
<li>支持事务管理</li>
</ul>
</li>
</ol>
<h3 data-id="heading-45">3. 列结构抽象阶段</h3>
<p>列结构抽象阶段是指提取字段列表，确定字段类型，建立字段映射关系。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea62ab1855f644ee95b5dc30afbe09f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=UIxH2SPmQDp2AZvNuwuiCN3Ue%2FM%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initField</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; fieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; disableFieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CustomAnnotation</span>&gt; customAnnotationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    int index = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 并行处理字段初始化</span>
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt;&gt; fieldTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
        fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
        index++;
    }
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt; fields = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">invokFieldTasks</span>(className, fieldTasks);

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeFieldConfig</span> fieldInfo : fields) {
        <span class="hljs-title class_">Field</span> field = fieldInfo.<span class="hljs-property">field</span>;
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isSerialize</span>()) {
            fieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            esdFieldMap.<span class="hljs-title function_">put</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>(), fieldInfo);
            fieldNameList.<span class="hljs-title function_">add</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>());
        } <span class="hljs-keyword">else</span> {
            disableFieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            disableFieldList.<span class="hljs-title function_">add</span>(fieldInfo);
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isUid</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = field.<span class="hljs-title function_">getName</span>();
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isCaptionField</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captionField</span> = fieldInfo;
        }
    }
}
</code></pre>
<h4 data-id="heading-46">设计思考：</h4>
<ol>
<li><strong>为什么需要列结构抽象？</strong>
<ul>
<li>统一字段的数据结构</li>
<li>支持字段的批量处理</li>
<li>提高字段处理的效率</li>
</ul>
</li>
<li><strong>为什么需要区分fieldMap和disableFieldMap？</strong>
<ul>
<li>fieldMap：需要显示的字段</li>
<li>disableFieldMap：不需要显示的字段</li>
<li>分离关注点，提高处理效率</li>
</ul>
</li>
</ol>
<h3 data-id="heading-47">4. 建模阶段</h3>
<p>建模阶段是指创建UI组件，建立组件层次结构，配置组件属性，绑定数据源。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/772ea3a5a34041e0a496988440769eae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=mC%2Bhpx58NVXtt1ekda3Y%2BvNA0OI%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">initWidget</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Class</span>? clazz = <span class="hljs-literal">null</span>;
    <span class="hljs-title class_">ComponentType</span>[] skipComs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentType</span>[]{<span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">TOOLBAR</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">APICALLER</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>};
    <span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;[] skipAnnotations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">ComboInputAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">ToolBarMenu</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">ListAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">InputAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>};

    <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span> || <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(skipComs).<span class="hljs-title function_">contains</span>(componentType)) {
        <span class="hljs-title class_">CustomClass</span> customClass = C2UConfigFactory.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getWidgetCustomAnnotation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>().<span class="hljs-title function_">toArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Annotation</span>[]{}));
        <span class="hljs-keyword">if</span> (customClass != <span class="hljs-literal">null</span>) {
            componentType = customClass.<span class="hljs-title function_">componentType</span>();
        }

        <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span> || componentType.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">InputAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">ListAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">ToolBarMenu</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">TOOLBAR</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">APICALLER</span>;
            }
        }
    }

    <span class="hljs-keyword">try</span> {
        clazz = C2UConfigFactory.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getDefaultWidgetClass</span>(componentType);
        <span class="hljs-title class_">Constructor</span> constructor = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            constructor = clazz.<span class="hljs-title function_">getConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">BridgeField</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">Set</span>.<span class="hljs-property">class</span>});
            widgetConfig = (M) constructor.<span class="hljs-title function_">newInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>()});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NoSuchMethodException</span> e) {
            constructor = clazz.<span class="hljs-title function_">getConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">Set</span>.<span class="hljs-property">class</span>});
            widgetConfig = (M) constructor.<span class="hljs-title function_">newInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>()});
        }
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }
}
</code></pre>
<h4 data-id="heading-48">设计思考：</h4>
<ol>
<li><strong>为什么需要建模阶段？</strong>
<ul>
<li>创建UI组件实例</li>
<li>建立组件层次结构</li>
<li>配置组件属性</li>
</ul>
</li>
<li><strong>为什么需要多种构造函数？</strong>
<ul>
<li>支持不同的初始化方式</li>
<li>支持不同的参数组合</li>
<li>提高灵活性</li>
</ul>
</li>
</ol>
<h2 data-id="heading-49">架构优势与设计哲学</h2>
<h3 data-id="heading-50">1. 架构优势</h3>
<p>A2UI架构具有以下优势：</p>
<h4 data-id="heading-51">1.1 可扩展性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb7c492127104c74ba7b7e4c73b1247e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=swGE5GNygTJs64OhBS82pAkiPNc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-52">设计思考：</h4>
<ol>
<li><strong>注解扩展</strong>
<ul>
<li>通过添加新的注解支持新功能</li>
<li>注解的解析规则是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
<li><strong>组件扩展</strong>
<ul>
<li>通过添加新的UI组件支持新UI元素</li>
<li>组件的注册机制是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
<li><strong>类型扩展</strong>
<ul>
<li>通过添加新的类型映射支持新数据类型</li>
<li>类型映射的规则是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
</ol>
<h4 data-id="heading-53">1.2 可维护性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b9506434b6e41539a20cf8ed3b7ed13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=Xbiry0f8Mf1%2B2lHMvD56Pl6evF8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-54">设计思考：</h4>
<ol>
<li><strong>分层架构</strong>
<ul>
<li>每层有明确的职责</li>
<li>层与层之间通过接口通信</li>
<li>便于理解和维护</li>
</ul>
</li>
<li><strong>单一职责</strong>
<ul>
<li>每个类只负责一个功能</li>
<li>类的职责清晰</li>
<li>便于测试和维护</li>
</ul>
</li>
<li><strong>集中规则</strong>
<ul>
<li>规则集中在配置类中</li>
<li>便于修改和扩展</li>
<li>避免规则分散</li>
</ul>
</li>
</ol>
<h4 data-id="heading-55">1.3 确定性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f33cfde8024947af86da4a1d180bade4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=6FkehMpMVTSq%2Fjym4R3Ij7MghEs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-56">设计思考：</h4>
<ol>
<li><strong>五层确定性</strong>
<ul>
<li>每层都有明确的确定性保障</li>
<li>层与层之间相互补充</li>
<li>保证结果的可预测性</li>
</ul>
</li>
<li><strong>有序处理</strong>
<ul>
<li>字段按照声明顺序处理</li>
<li>方法按照声明顺序处理</li>
<li>保证处理顺序的稳定性</li>
</ul>
</li>
<li><strong>固定规则</strong>
<ul>
<li>类型映射规则是固定的</li>
<li>组件映射规则是固定的</li>
<li>保证映射结果的一致性</li>
</ul>
</li>
</ol>
<h4 data-id="heading-57">1.4 灵活性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/928f0ee6baf14165beab075d64f28f22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=UrQL0hLCRtCZTYk6tM2%2BlsZwU7s%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-58">设计思考：</h4>
<ol>
<li><strong>字段和方法两种定义方式</strong>
<ul>
<li>支持字段定义</li>
<li>支持方法定义</li>
<li>满足不同的开发习惯</li>
</ul>
</li>
<li><strong>注解覆盖默认行为</strong>
<ul>
<li>支持通过注解覆盖默认行为</li>
<li>支持灵活的配置</li>
<li>满足不同的业务需求</li>
</ul>
</li>
<li><strong>自定义组件映射</strong>
<ul>
<li>支持自定义组件映射</li>
<li>支持自定义组件</li>
<li>满足不同的UI需求</li>
</ul>
</li>
</ol>
<h3 data-id="heading-59">2. 设计哲学</h3>
<p>A2UI的设计哲学体现了以下原则：</p>
<h4 data-id="heading-60">2.1 约定优于配置</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39d23753c3dc44b88ab58a4d6dab7c09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=kE5pbZWZ7SyOISQTEaeTWtYEKWQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-61">设计思考：</h4>
<ol>
<li><strong>默认行为</strong>
<ul>
<li>提供合理的默认值</li>
<li>减少配置的工作量</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>最小配置</strong>
<ul>
<li>只在必要时配置</li>
<li>减少配置文件</li>
<li>简化项目结构</li>
</ul>
</li>
<li><strong>显式覆盖</strong>
<ul>
<li>需要时显式覆盖</li>
<li>配置意图明确</li>
<li>避免隐式行为</li>
</ul>
</li>
</ol>
<h4 data-id="heading-62">2.2 开闭原则</h4>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/506a676e4ca54460b41e4492a11fae12~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=aNN7otGkIMqX5tT3lcu8mcGWsyY%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h4 data-id="heading-63">设计思考：</h4>
<ol>
<li><strong>对扩展开放</strong>
<ul>
<li>支持添加新的注解</li>
<li>支持添加新的组件</li>
<li>支持添加新的类型映射</li>
</ul>
</li>
<li><strong>对修改关闭</strong>
<ul>
<li>不需要修改核心代码</li>
<li>核心代码保持稳定</li>
<li>保证向后兼容</li>
</ul>
</li>
</ol>
<h4 data-id="heading-64">2.3 依赖倒置原则</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e6f28f714fd43688c11c05ab96c6344~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=m%2B2nwmagulKgp3KFt9CHgamL58g%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-65">设计思考：</h4>
<ol>
<li><strong>依赖抽象</strong>
<ul>
<li>依赖BridgeField接口</li>
<li>依赖BridgeClass接口</li>
<li>依赖BridgeMethodConfig接口</li>
</ul>
</li>
<li><strong>不依赖实现</strong>
<ul>
<li>不依赖具体的字段类</li>
<li>不依赖具体的组件类</li>
<li>不依赖具体的方法类</li>
</ul>
</li>
</ol>
<h4 data-id="heading-66">2.4 单一职责原则</h4>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9542af01c59a4788b4c8bcc703bfb01a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=adO5OZF5EdYAu4LxlM1T0rKYEKc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<h4 data-id="heading-67">设计思考：</h4>
<ol>
<li><strong>一个类一个职责</strong>
<ul>
<li>BridgeClass：类分析</li>
<li>BridgeFieldConfig：字段配置</li>
<li>BridgeMethodConfig：方法配置</li>
<li>C2UConfigFactory：组件映射</li>
<li>OODTypeMapping：类型映射</li>
</ul>
</li>
<li><strong>专注的功能</strong>
<ul>
<li>每个类只负责一个功能</li>
<li>功能边界清晰</li>
<li>便于理解和维护</li>
</ul>
</li>
</ol>
<h2 data-id="heading-68">总结</h2>
<p>A2UI（Annotation to UI）是Ooder框架的核心组件，通过注解驱动的反射分析，将Java类自动转换为UI组件。其核心逻辑包括：</p>
<h3 data-id="heading-69">核心机制</h3>
<ol>
<li><strong>六阶段拆解流程</strong>
<ul>
<li>类加载阶段</li>
<li>注解解析阶段</li>
<li>字段拆解阶段</li>
<li>方法拆解阶段</li>
<li>类型映射阶段</li>
<li>组件生成阶段</li>
</ul>
</li>
<li><strong>五层确定性保障</strong>
<ul>
<li>注解层确定性</li>
<li>类型层确定性</li>
<li>命名约定层确定性</li>
<li>索引层确定性</li>
<li>映射规则层确定性</li>
</ul>
</li>
<li><strong>六大组织原则</strong>
<ul>
<li>字段优先原则</li>
<li>Getter/Setter识别原则</li>
<li>注解优先级原则</li>
<li>索引排序原则</li>
<li>类型推断原则</li>
<li>组件映射原则</li>
</ul>
</li>
</ol>
<h3 data-id="heading-70">设计优势</h3>
<ol>
<li><strong>可扩展性</strong>
<ul>
<li>支持注解扩展</li>
<li>支持组件扩展</li>
<li>支持类型扩展</li>
</ul>
</li>
<li><strong>可维护性</strong>
<ul>
<li>分层架构</li>
<li>单一职责</li>
<li>集中规则</li>
</ul>
</li>
<li><strong>确定性</strong>
<ul>
<li>五层确定性保障</li>
<li>有序处理</li>
<li>固定规则</li>
</ul>
</li>
<li><strong>灵活性</strong>
<ul>
<li>字段和方法两种定义方式</li>
<li>注解覆盖默认行为</li>
<li>自定义组件映射</li>
</ul>
</li>
</ol>
<h3 data-id="heading-71">设计哲学</h3>
<ol>
<li><strong>约定优于配置</strong>
<ul>
<li>提供合理的默认值</li>
<li>最小化配置</li>
<li>显式覆盖</li>
</ul>
</li>
<li><strong>开闭原则</strong>
<ul>
<li>对扩展开放</li>
<li>对修改关闭</li>
</ul>
</li>
<li><strong>依赖倒置原则</strong>
<ul>
<li>依赖抽象</li>
<li>不依赖实现</li>
</ul>
</li>
<li><strong>单一职责原则</strong>
<ul>
<li>一个类一个职责</li>
<li>专注的功能</li>
<li>易于测试</li>
</ul>
</li>
</ol>
<p>A2UI通过这些机制和原则，实现了从Java类到UI组件的自动化转换，为Ooder框架提供了强大的"配置即代码"能力。这一设计不仅提高了开发效率，也保证了系统的可维护性和可扩展性。</p>
<p>© 2024 Ooder Framework. All rights reserved.</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 自带“加速器”：node --run 是否比 Bun 更快？]]></title>    <link>https://juejin.cn/post/7602246300454436899</link>    <guid>https://juejin.cn/post/7602246300454436899</guid>    <pubDate>2026-02-03T14:17:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300454436899" data-draft-id="7584353612501368873" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 自带“加速器”：node --run 是否比 Bun 更快？"/> <meta itemprop="keywords" content="Bun,Node.js,deno"/> <meta itemprop="datePublished" content="2026-02-03T14:17:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Legend80s"/> <meta itemprop="url" content="https://juejin.cn/user/2568105753839790"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 自带“加速器”：node --run 是否比 Bun 更快？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2568105753839790/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Legend80s
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:17:36.000Z" title="Tue Feb 03 2026 14:17:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 JavaScript 后端运行时领域，速度一直是核心战场。近年来，Bun 以其宣称的“一体化”工具链和闪电般的启动速度异军突起，对老牌王者 Node.js 发起了强劲挑战。<code>bun run</code> 的迅捷，让许多开发者开始重新评估他们的工具选择。</p>
<p>然而，Node.js 并未止步。自 v22.0.0 起，它悄然引入了一个专为启动性能而生的秘密武器：<code>node --run</code>。这个内置于 Node.js 核心的命令，旨在以最精简、最直接的方式执行 <code>package.json</code> 中的脚本，宣称要为最常见的用例提供“顶级性能”。</p>
<p>这引发了我们的好奇：在真实的场景下，这位新秀的表现究竟如何？它与 <code>bun run</code> 及传统的 <code>npm run</code> 相比，孰优孰劣？</p>
<p>本文将通过一系列严谨的对比测试，揭开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest%2Fapi%2Fcli.html%23--run" target="_blank" title="https://nodejs.org/docs/latest/api/cli.html#--run" ref="nofollow noopener noreferrer"><code>node --run</code></a> 的神秘面纱，用数据回答：在 2026 年的脚本启动性能竞赛中，谁才是真正的速度王者？</p>
<p><strong/></p><p align="center"><strong>各位小伙伴请注意！本文将颠覆这个传统观念“bun 启动一定比 Node.js 更快”。</strong></p><p/>
<hr/>
<p>首先我们回顾下 Node.js 运行文件有三种方式：</p>
<ol>
<li>直接启动 <code>node foo.[jt]s</code> 🤼‍♂️ <code>bun foo.[jt]s</code></li>
<li>package.json 脚本运行 <code>npm run foo</code> 🤼‍♂️ <code>bun run foo</code></li>
<li>脚本 <code>--run</code> 直接运行 <code>node --run foo</code> <em>Added in: v22.0.0</em> 🤼‍♂️ <code>bun --run foo</code></li>
</ol>
<p>统计方法，我们模仿竞技比赛中，去掉一个最高分和一个最低分，可以避免“冷启动”等极端数据干扰，采取去掉最大和最小值然后取平均值，这样<strong>抗干扰性强</strong>、<strong>更公平</strong>。</p>
<h2 data-id="heading-1">第一轮：直接启动 JS 文件速度</h2>
<p>分别启动两个 mjs 文件，一个空一个有 IO 输出。测试文件：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// empty.mjs</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// io.mjs</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello world'</span>);

</code></pre>
<h3 data-id="heading-2">Node.js 🟢</h3>
<p>分别执行 <code>time node empty.js</code> <code>time node io.mjs</code> 各自三次。</p>
<p><code>❯ time node empty.mjs</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">78</span>% cpu <span class="hljs-number">0.217</span> total
node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">84</span>% cpu <span class="hljs-number">0.203</span> total
node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.225</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>217</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx217ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">217</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p><code>❯ time node io.mjs</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.234</span> total
node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">72</span>% cpu <span class="hljs-number">0.236</span> total
node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">74</span>% cpu <span class="hljs-number">0.229</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>234</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx234ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">234</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>225</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx225ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">225</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<h3 data-id="heading-3">Bun 🍞</h3>
<pre><code class="hljs language-ts" lang="ts">bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.375</span> total
bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">63</span>% cpu <span class="hljs-number">0.337</span> total
bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">70</span>% cpu <span class="hljs-number">0.371</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>371</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx371ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">371</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<pre><code class="hljs language-ts" lang="ts">bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">63</span>% cpu <span class="hljs-number">0.338</span> total
bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>20s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.351</span> total
bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>20s system <span class="hljs-number">62</span>% cpu <span class="hljs-number">0.369</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>351</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx351ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">351</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>整体：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>361</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx361ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">361</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>这数据有点反常，1 bun 启动 io 文件速度反而快于空文件，2 其次得到本文第一个<strong>非常重要的结论：bun 对 js 文件启动速度反而劣于 Node.js</strong>（二者相差 100ms+）。</p>
<h2 data-id="heading-4">第二轮：直接启动 TS 文件速度</h2>
<blockquote>
<p>[!TIP]
注意：想要不加参数直接运行 TS，Node.js 版本需 <strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"/><span class="mrel">≥</span></span></span></span></span> v22.18.0</strong>。</p>
</blockquote>
<p>分别启动两个 ts 文件，一个空一个有 IO 输出。测试文件：</p>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment"># 文件内容一样</span>
empty-ts.ts
io-ts.ts
</code></pre>
<h3 data-id="heading-5">Node.js 🟢</h3>
<pre><code class="hljs language-ts" lang="ts">node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>19s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.254</span> total
node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">72</span>% cpu <span class="hljs-number">0.236</span> total
node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">71</span>% cpu <span class="hljs-number">0.240</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>240</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx240ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">240</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p><code>❯ time node io-ts.ts</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">64</span>% cpu <span class="hljs-number">0.263</span> total
node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.255</span> total
node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.254</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>255</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx255ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">255</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>248</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx248ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">248</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<blockquote>
<p>[!TIP]
小结：Node.js 运行 ts 耗时比 js 增加 <strong>~20ms</strong>，这在预期内因为先要 <a href="https://juejin.cn/spost/7407763018472046629#heading-12" target="_blank" title="https://juejin.cn/spost/7407763018472046629#heading-12">amacro ts 编译器即将所有类型用空格替代</a>。</p>
</blockquote>
<h3 data-id="heading-6">Bun 🍞</h3>
<pre><code class="hljs language-ts" lang="ts">bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.372</span> total
bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>15s system <span class="hljs-number">45</span>% cpu <span class="hljs-number">0.372</span> total
bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.402</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>372</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx372ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">372</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<pre><code class="hljs language-ts" lang="ts">bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>25s system <span class="hljs-number">64</span>% cpu <span class="hljs-number">0.405</span> total
bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">55</span>% cpu <span class="hljs-number">0.388</span> total
bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>09s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">74</span>% cpu <span class="hljs-number">0.429</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>405</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx 405ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">405</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>388.5</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx 388.5ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">388.5</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<blockquote>
<p>[!TIP]
小结：Bun 运行 ts 耗时比 js 增加 <strong>~20ms</strong>，预期内。</p>
</blockquote>
<p>本文第二个<strong>结论：bun 执行 ts 文件启动速度劣于 Node.js</strong>（二者相差 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>388</mn><mo>−</mo><mn>248</mn><mo>=</mo><mn>140</mn><mi>m</mi><mi>s</mi><mo>+</mo></mrow><annotation encoding="application/x-tex">388 - 248 = 140ms+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">388</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">248</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">140</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">+</span></span></span></span></span>）。</p>
<p>有读者可能会问是否是通过环境变量寻址 bun 耗时导致的。那我们直接跳过寻址：</p>
<p><code>❯ time /e/pnpm/bun io-ts.ts</code></p>
<pre><code class="hljs language-ts" lang="ts">/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">55</span>% cpu <span class="hljs-number">0.384</span> total
/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.341</span> total
/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.407</span> total
</code></pre>
<p>直接寻址耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>384</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex"> 384ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">384</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，确实少于 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>405</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex"> 405ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">405</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，但依然显著高于 Node.js 的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>255</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">255ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">255</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>！所以</p>
<h2 data-id="heading-7">结论一</h2>
<p>Bun 无论<strong>启动</strong> JavaScript 还是 TypeScript 文件<strong>都要慢于 Node.js</strong>！</p>
<blockquote>
<p>注意这里是<strong>启动</strong>而非运行。</p>
</blockquote>
<h2 data-id="heading-8">第三轮：package.json 脚本启动</h2>
<p>结论先行：执行 package.json 内的 scripts <code>bun run</code> 的启动速度快于 <code>npm run</code>。我们测试下。</p>
<p>npm v11.7.0</p>
<p>我们定义两个 script io 和不含 io 的：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"io"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"hello world\""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"empty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-9">npm run</h3>
<p><code>❯ time command npm run io</code></p>
<blockquote>
<p>[!TIP]
<code>command npm</code> 是因为我在 <code>~/.zshrc</code> 内对 npm 做了同名 alias 需通过 <code>command</code> 找到原始命令。</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts">&gt; rsbuild-react-<span class="hljs-number">19</span>@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> io
&gt; io <span class="hljs-string">"hello world"</span>

<span class="hljs-string">"hello world"</span>
command npm run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>39s system <span class="hljs-number">58</span>% cpu <span class="hljs-number">0.660</span> total
</code></pre>
<pre><code class="hljs language-ts" lang="ts">command npm run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>34s system <span class="hljs-number">52</span>% cpu <span class="hljs-number">0.649</span> total
command npm run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>31s system <span class="hljs-number">50</span>% cpu <span class="hljs-number">0.638</span> total
</code></pre>
<p><code>npm run io</code> 耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>650</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">650ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">650</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>去除 IO：<code>❯ time command npm run empty</code></p>
<pre><code class="hljs language-ts" lang="ts">command npm run empty  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>32s system <span class="hljs-number">60</span>% cpu <span class="hljs-number">0.610</span> total
command npm run empty  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>34s system <span class="hljs-number">59</span>% cpu <span class="hljs-number">0.626</span> total
command npm run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>33s system <span class="hljs-number">53</span>% cpu <span class="hljs-number">0.611</span> total
</code></pre>
<p>纯启动耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>616</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">616ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">616</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<code>npm run</code> 启动需 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>600</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx600ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">600</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。这也太慢了，代码啥都没干呢！</p>
<p>接下来试试 <code>bun run</code>。</p>
<h3 data-id="heading-10">bun run</h3>
<p><code>❯ time bun run io</code>:</p>
<pre><code class="hljs language-ts" lang="ts">bun run io  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">79</span>% cpu <span class="hljs-number">0.308</span> total
bun run io  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">78</span>% cpu <span class="hljs-number">0.347</span> total
bun run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">68</span>% cpu <span class="hljs-number">0.313</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>313</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">313 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">313</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 左右</p>
<p><code>❯ time bun run empty</code>：</p>
<pre><code class="hljs language-ts" lang="ts">bun run empty  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>18s system <span class="hljs-number">60</span>% cpu <span class="hljs-number">0.380</span> total
bun run empty  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.330</span> total
bun run empty  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.361</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>361</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">361 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">361</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 左右。第二个反常 io 反而更慢。</p>
<p>整体耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>337</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">337 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">337</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。结论 <code>bun run</code> 大概是 <code>npm run</code> 的两倍（<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>600</mn><mi mathvariant="normal">/</mi><mn>300</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">600 / 300=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">600/300</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">2</span></span></span></span></span>）性能。</p>
<p>突然想起 Node.js v22.0.0 支持 <code>node --run</code> 运行脚本，专为性能而生，看看它表现如何。</p>
<h2 data-id="heading-11">第四轮：package.json 脚本 `--run` 直接运行</h2>
<p>先解释下 <code>node --run</code>，是的，它也可以执行 package.json 中的脚本，而且生来就是为性能考虑（不会执行 <code>pre</code> / <code>post</code> 钩子）。</p>
<blockquote>
<p>它将从 <code>package.json</code> 文件的 <code>"scripts"</code> 对象中运行指定的命令。如果提供的 <code>"command"</code> 不存在，则会列出可用的脚本。</p>
<p><code>node --run</code> 并不旨在完全匹配 <code>npm run</code> 或其他包管理器的运行命令的行为。Node.js 的实现<strong>有意更加精简</strong>，以便在最常见的用例中<strong>专注于顶级性能</strong>。其他运行实现中一些被有意排除的功能包括：</p>
<ul>
<li>除了运行指定的脚本外，还会运行前置（<code>pre</code>）或后置（<code>post</code>）脚本。</li>
<li>定义特定于包管理器的环境变量。</li>
</ul>
<p>—— <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest%2Fapi%2Fcli.html%23--run" target="_blank" title="https://nodejs.org/docs/latest/api/cli.html#--run" ref="nofollow noopener noreferrer">nodejs.org/docs/latest…</a></p>
</blockquote>
<h3 data-id="heading-12">node --run</h3>
<p><code>❯ time node --run io</code>:</p>
<pre><code class="hljs language-ts" lang="ts">node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">79</span>% cpu <span class="hljs-number">0.216</span> total
node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">81</span>% cpu <span class="hljs-number">0.192</span> total
node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>19s system <span class="hljs-number">84</span>% cpu <span class="hljs-number">0.220</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>216</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">216ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">216</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 完美 🤩</p>
<p><code>❯ time node --run empty</code>:</p>
<pre><code class="hljs language-ts" lang="ts">node --run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">89</span>% cpu <span class="hljs-number">0.192</span> total
node --run empty  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">80</span>% cpu <span class="hljs-number">0.212</span> total
node --run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">89</span>% cpu <span class="hljs-number">0.192</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">192 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">192</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 完美 🤩🤩</p>
<p><code>node --run</code> 整体平均：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>204</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">204 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">204</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，确实做了性能优化，<strong>三倍性能提升 🚀</strong>：<code>npm run 616ms</code> VS <code>node --run 204ms</code></p>
<h3 data-id="heading-13">bun --run</h3>
<pre><code class="hljs language-ts" lang="ts">bun --run empty  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>14s system <span class="hljs-number">53</span>% cpu <span class="hljs-number">0.370</span> total
bun --run empty  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">75</span>% cpu <span class="hljs-number">0.347</span> total
bun --run empty  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">68</span>% cpu <span class="hljs-number">0.379</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>370</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">370 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">370</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<pre><code class="hljs language-ts" lang="ts">bun --run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>18s system <span class="hljs-number">61</span>% cpu <span class="hljs-number">0.324</span> total
bun --run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.334</span> total
bun --run io  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">52</span>% cpu <span class="hljs-number">0.382</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>334</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">334 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">334</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> （io 反而速度快于空脚本 -_-||）</p>
<p><code>bun --run</code> 整体耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>352</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">352 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">352</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，<strong>反常三：<code>bun --run</code> 慢于 <code>node --run</code></strong> 的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>204</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">204 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">204</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<h2 data-id="heading-14">性能数据总结</h2>
<p>文章从三个维度（直接启动文件、运行 package.json 脚本、使用 <code>--run</code> 命令）对比了 Node.js 和 Bun 的性能。</p>
<h3 data-id="heading-15">核心结论</h3>
<ol>
<li><strong>直接启动文件</strong>：无论 TS or JS，Node.js 以显著优势胜出。</li>
<li><strong>运行 package.json 脚本</strong>：Bun (<code>bun run</code>) 击败 npm (<code>npm run</code>)，但 <code>node --run</code> 凭借其精简设计击败 <code>bun run / npm run / bun --run</code>。</li>
</ol>
<p><strong/></p><p align="center"><strong>至此本文颠覆了一个传统观念“bun 启动一定比 Node.js 更快”。</strong></p><p/>
<h4 data-id="heading-16">附录：详细数据</h4>
<h6 data-id="heading-17">表格一：直接运行 JS/TS 文件性能对比 (单位：ms)</h6>















































<table><thead><tr><th>测试场景</th><th>Node.js (v22.18.0)</th><th>Bun (v1.3.2)</th><th><strong>性能胜出方</strong></th></tr></thead><tbody><tr><td>启动空 JS 文件</td><td>~217</td><td>~371</td><td>Node.js (快 ~41%)</td></tr><tr><td>启动含 IO 的 JS 文件</td><td>~234</td><td>~351</td><td>Node.js (快 ~33%)</td></tr><tr><td><strong>JS 文件启动综合耗时</strong></td><td><strong>~225</strong></td><td>~361</td><td><strong>Node.js 胜出</strong></td></tr><tr><td>启动空 TS 文件</td><td>~240</td><td>~372</td><td>Node.js (快 ~35%)</td></tr><tr><td>启动含 IO 的 TS 文件</td><td>~255</td><td>~405</td><td>Node.js (快 ~37%)</td></tr><tr><td><strong>TS 文件启动综合耗时</strong></td><td><strong>~248</strong></td><td>~389</td><td><strong>Node.js 胜出</strong></td></tr></tbody></table>
<p><strong>结论一：</strong>  在直接启动文件（无论 JS 或 TS）的场景下，<strong>Node.js 🚀 性能显著优于 Bun</strong>，平均领先幅度在 35%-41% 左右。虽然有反直觉但是我的 Windows 下确实如此。</p>
<hr/>
<h5 data-id="heading-18">表格二：运行 package.json 脚本性能对比 (单位：ms)</h5>








































<table><thead><tr><th>执行方式</th><th>平均耗时 (含IO)</th><th>平均耗时 (空脚本)</th><th>综合平均耗时</th><th><strong>性能排序 (由快到慢)</strong></th></tr></thead><tbody><tr><td><strong><code>node --run</code></strong></td><td>~216 ms</td><td>~192 ms</td><td><strong>~204 ms</strong></td><td>🥇 <strong>第1名</strong></td></tr><tr><td><strong><code>bun run</code></strong></td><td>~313 ms</td><td>~361 ms</td><td>~337 ms</td><td>🥈 <strong>第2名</strong></td></tr><tr><td><strong><code>bun --run</code></strong></td><td>~334 ms</td><td>~370 ms</td><td>~352 ms</td><td>🥉 <strong>第3名</strong></td></tr><tr><td><strong><code>npm run</code></strong></td><td>~650 ms</td><td>~616 ms</td><td>~633 ms</td><td><strong>第4名</strong></td></tr></tbody></table>
<p><strong>结论二：</strong></p>
<ol>
<li><strong><code>node --run</code> 是绝对的性能冠军</strong>，速度是 <code>npm run</code> 的 <strong>3.1 倍</strong>，也比 <code>bun run</code> 快约 <strong>65%</strong> 。</li>
<li>Bun 相关命令性能接近：<code>bun run</code> 和 <code>bun --run</code> 性能在同一水平，都显著快于 <code>npm run</code>（快约 88%）。</li>
<li><strong><code>npm run</code> 垫底</strong>：传统 npm 脚本的启动开销最大，耗时最长。</li>
</ol>
<h2 data-id="heading-19">对我们的启发</h2>
<ul>
<li><strong>Node.js vs. Bun 启动速度</strong>：在直接启动 <code>.js</code> 或 <code>.ts</code> 文件时，Node.js 比 Bun 快约 <strong>40%-60%</strong> 。这是“<strong>一个非常重要的结论</strong>”。</li>
<li><strong>Package Script 运行速度</strong>：
<ul>
<li><code>bun run</code> 比 <code>npm run</code> 快约 <strong>2 倍</strong>。</li>
<li>而黑马 🐎 <code>node --run</code> 比 <code>npm run</code> 快约 <strong>3 倍</strong>！</li>
</ul>
</li>
</ul>
<p><strong><code>node --run</code> 的意义</strong>——<strong>包脚本运行的革新</strong>：<code>node --run</code> 无疑是本次测试的最大亮点，其速度非常接近直接运行 <code>node foo.js</code> 的速度，实现了近乎“裸奔”的脚本执行性能。它通过<strong>牺牲 npm 脚本的部分高级功能</strong>（如 <code>pre</code>/<code>post</code> 钩子、特定的环境变量），换来了  <strong>~3 倍于 <code>npm run</code> 的速度提升</strong>，甚至超越了以速度见长的 <code>bun run</code>。对于追求极致构建、测试或启动速度，且不依赖这些高级特性的项目，<code>node --run</code> 提供了一个近乎完美的“性能模式”。</p>
<p>启发：如果你要直接执行文件请使用 Node.js，如果要执行 npm script 建议 99% 情况下用 <code>node --run</code>（无需运行 <code>pre / post npm script</code> 时）否则 <code>bun run</code>。</p>
<h2 data-id="heading-20">说明</h2>
<p>测试环境 Windows 10、git bash、Node.js 🟢 v22.18.0、npm v11.7.0、bun 🍞 v1.3.2。</p>
<hr/>
<p><em/></p><p align="center"><em>—— 完 🎉 最新文章请关注公众号 <strong><code>JavaScript与编程艺术</code></strong> ——</em></p><p/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《实时渲染》第2章-图形渲染管线-2.6管线综述]]></title>    <link>https://juejin.cn/post/7602472997920473088</link>    <guid>https://juejin.cn/post/7602472997920473088</guid>    <pubDate>2026-02-03T13:14:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602472997920473088" data-draft-id="7602472997920456704" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《实时渲染》第2章-图形渲染管线-2.6管线综述"/> <meta itemprop="keywords" content="计算机图形学"/> <meta itemprop="datePublished" content="2026-02-03T13:14:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="charlee44"/> <meta itemprop="url" content="https://juejin.cn/user/1117549770846872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《实时渲染》第2章-图形渲染管线-2.6管线综述
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1117549770846872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    charlee44
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:14:53.000Z" title="Tue Feb 03 2026 13:14:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>实时渲染</strong></h2>
<h2 data-id="heading-1">2. 图形渲染管线</h2>
<h3 data-id="heading-2">2.6 管线综述</h3>
<p>点、线和三角形是构建模型或对象的渲染图元。假设该应用程序是一个交互式计算机辅助设计 (CAD) 应用程序，并且用户正在检查华夫饼制造商的设计。在这里，我们将在整个图形渲染管线中遵循这个模型，包括四个主要阶段：应用程序、几何、光栅化和像素处理。场景以透视图渲染到屏幕上的窗口中。在这个简单的示例中，华夫饼机模型包括线条（以显示零件的边缘）和三角形（以显示表面）。华夫饼机有一个可以打开的盖子。一些三角形由带有制造商标志的二维图像构成。对于这个例子，表面着色完全在几何阶段计算，除了纹理的应用，它发生在光栅化阶段。</p>
<h4 data-id="heading-3">2.6.1 应用程序阶段</h4>
<p>CAD应用程序允许用户选择和移动模型的各个部分。例如，用户可能会选择盖子，然后移动鼠标将其打开。应用阶段必须将鼠标移动转换为相应的旋转矩阵，然后确保该矩阵在渲染时正确应用于盖子。另一个示例：播放的动画沿着预定义的路径移动相机以从不同视图显示华夫饼机。然后，应用程序必须根据时间更新相机参数，例如位置和视图方向。对于要渲染的每一帧，应用程序阶段将模型的相机位置、光照和图元提供给管道中的下一个主要阶段——几何阶段。</p>
<h4 data-id="heading-4">2.6.2 几何处理</h4>
<p>对于透视视图，我们假设应用程序提供了一个投影矩阵。此外，对于每个对象，应用程序都计算了一个矩阵，该矩阵描述了视图变换以及对象本身的位置和方向。在我们的例子中，华夫饼机的底座有一个矩阵，盖子是另一个。在几何阶段，对象的顶点和法线使用该矩阵进行变换，将对象放入视图空间。然后可以使用材质和光源属性计算顶点处的着色或其他计算。然后使用单独的用户提供的投影矩阵执行投影，将对象转换为代表眼睛所见的单位立方体空间。立方体外的所有基元都将被丢弃。与这个单位立方体相交的所有图元都被裁剪在立方体上，以获得一组完全位于单位立方体内部的图元。然后将顶点映射到屏幕上的窗口中。在执行完所有这些每三角形和每顶点操作之后，结果数据将传递到光栅化阶段。</p>
<h4 data-id="heading-5">2.6.3 光栅化</h4>
<p>然后将在前一阶段裁剪后幸存下来的所有图元进行光栅化，这意味着找到图元内的所有像素并将其进一步发送到管线中进行像素处理。</p>
<h4 data-id="heading-6">2.6.4 像素处理</h4>
<p>这里的目标是计算每个可见图元的每个像素的颜色。那些与任何纹理（图像）相关联的三角形将根据需要使用这些图像进行渲染。可见性通过z缓冲区算法以及可选的丢弃和模板测试来解决。依次处理每个对象，然后将最终画面显示在屏幕上。</p>
<h4 data-id="heading-7">2.6.5 总结</h4>
<p>这条管线源于数十年针对实时渲染应用程序的API和图形硬件演变。需要注意的是，这并不是唯一可能的渲染管道；离线渲染管道经历了不同的进化路径。电影制作的渲染通常使用微多边形管道[289, 1734] 完成，但最近已经普遍开始使用光线追踪和路径追踪了。<a href="https://link.juejin.cn?target=%25E7%25AC%25AC11.2.2%25E8%258A%2582" target="_blank" title="%E7%AC%AC11.2.2%E8%8A%82" ref="nofollow noopener noreferrer">第11.2.2节</a>中介绍的这些技术也可用于架构和设计视觉化。</p>
<p>多年来，应用程序开发人员使用此处描述的过程的唯一方法是通过使用中的图形API定义的固定功能管线。固定功能管线之所以如此命名，是因为实现它的图形硬件由无法以灵活方式编程的元素组成。主要固定功能管线的机器的最后一个例子是2006年推出的任天堂Wii。另一方面，可编程GPU可以准确地确定在整个管线的各个子阶段应用哪些操作。对于本书的第四版，我们假设所有开发都是使用可编程GPU完成的。</p>
<h3 data-id="heading-8">2.7 进一步阅读和资源</h3>
<p>Blinn的书《A Trip Down the Graphics Pipeline》[165] 是一本关于从头编写软件渲染器的老书。这是一个很好的资源，可以了解实现渲染管道的一些微妙之处，解释关键算法，例如剪辑和透视插值。古老（但经常更新）的《OpenGL 编程指南》（又名“红皮书”）[885] 提供了图形管线和与其使用相关的算法的全面描述。我们这本书的网站realtimerendering.com提供了指向各种管线图、渲染引擎实现等的链接。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[代码不值钱了，什么更值钱？]]></title>    <link>https://juejin.cn/post/7602205524719452194</link>    <guid>https://juejin.cn/post/7602205524719452194</guid>    <pubDate>2026-02-03T13:13:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524719452194" data-draft-id="7602205524719173666" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="代码不值钱了，什么更值钱？"/> <meta itemprop="keywords" content="AI编程,Agent,VibeCoding"/> <meta itemprop="datePublished" content="2026-02-03T13:13:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AlienZHOU"/> <meta itemprop="url" content="https://juejin.cn/user/3843548380668829"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            代码不值钱了，什么更值钱？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548380668829/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AlienZHOU
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:13:37.000Z" title="Tue Feb 03 2026 13:13:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    17
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>AI 编码时代的一些实践与观察</p>
</blockquote>
<p>前两天我做了一件"轻浮"的事：把 1000 行刚“写"完的代码删了。</p>
<p>原因单纯觉得代码不顺手、逻辑绕、读起来累。以前这种情况下，我一般会硬着头皮去重构。但这次我直接 <code>git restore</code> 了，然后对着 AI 让它 “重头再来”。</p>
<p>最让我自己印象深刻的，不是 AI 又写出了一份"能跑"的实现，而是我删掉代码那一瞬间的心理状态：<strong>我没有任何负罪感与舍不得。</strong></p>
<p>仔细想想这事儿在以前很不可思议。我们过去几十年都把"源代码"当成公司资产、团队心血、个人作品。现在呢？<strong>代码不重要了，丢了不心疼。</strong></p>
<p>那问题来了：<strong>如果代码不值钱了，写代码的人还值钱吗？</strong></p>
<hr/>
<h2 data-id="heading-0">1、Programming ≠ Coding</h2>
<p>图灵奖得主 Leslie Lamport 有一个演讲，题目就叫 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DuyLy7Fu4FB4" target="_blank" title="https://www.youtube.com/watch?v=uyLy7Fu4FB4" ref="nofollow noopener noreferrer">"Programming ≠ Coding"</a></strong>。</p>
<p>他讲得很直接：<strong>很多人以为自己在 Programming，其实只是 Coding</strong>。Programming 是思考问题本质、设计算法和抽象；Coding 是用具体语言把它实现出来。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07d15c6d0e4e4431ab7ac4a42eaeb4d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=kccR8eWUhIb4d1EqcxWXc3l23FU%3D" alt="file" loading="lazy"/></p>
<p>如果把这个观点再往上推一层，可以得到一个三层模型：</p>
<pre><code class="hljs language-markdown" lang="markdown">Engineering
  |  定义目标、边界、约束（What / Why）
  v
Programming
  |  抽象、协议、Spec、状态机（How @ 抽象层）
  v
Coding
<span class="hljs-code">     具体实现（How @ 实现层）
</span></code></pre>
<p>过去和现在，这三层的"主战场"已经不一样了：</p>

























<table><thead><tr><th/><th>过去</th><th>AI 时代</th></tr></thead><tbody><tr><td><strong>主要瓶颈</strong></td><td>实现贵、出错率高</td><td>定义不清、边界模糊</td></tr><tr><td><strong>人的精力焦点</strong></td><td>Coding：怎么写对、写快、少 bug</td><td>Programming/Engineering：怎么定义清楚</td></tr><tr><td><strong>Coding 的角色</strong></td><td>主战场</td><td>执行层（类似编译器）</td></tr></tbody></table>
<p>Lamport 还有一句话很不错：</p>
<blockquote>
<p>"You don't produce ten times less code by better coding. You do it with a cleaner architecture — a better abstraction."
（你不可能通过更好的编码把代码量减少到十分之一；你只能通过更清晰的架构（更好的抽象）做到这一点）</p>
</blockquote>
<p>当 AI 把 Coding 的边际成本打下来之后，一个很自然的问题就浮出来了：<strong>那 Programming 层和 Engineering 层呢？我们应该用什么去定义它们？</strong></p>
<p>这时候，一些"死去的记忆"突然攻击了我。</p>
<h2 data-id="heading-1">2、契约先行：代码正在变成"可蒸发物"</h2>
<p>"死去的记忆"开始攻击我。一些过去在软件工程书籍里被提过、但在业务高速增长年代里常常被忽略的概念，重新复苏了。</p>
<p>比如 <strong>Design by Contract（契约式设计）</strong>——1986 年，Bertrand Meyer 在设计 Eiffel 语言时提出这个理念。它强调：软件组件之间的协作关系，应当通过<strong>可验证的接口 Spec</strong>表达出来，典型形式包括：</p>
<ul>
<li><strong>Precondition（前置条件）</strong>：调用方必须满足的条件</li>
<li><strong>Postcondition（后置条件）</strong>：被调用方在完成后必须保证的条件</li>
<li><strong>Invariant（不变量）</strong>：对象/模块在生命周期中需要长期维持的约束</li>
</ul>
<p>用更短的一句话概括就是：<strong>契约先行——先把边界写清楚，再谈实现。</strong></p>
<p>这一思路甚至可以延伸到系统级设计：上节提到的 Leslie Lamport，它提出的 TLA+，就是用数学化的 Spec 描述分布式、并发等复杂场景的全局契约，提前验证 “数据一致性”“并发死锁” 这类组件级契约难以覆盖的系统级逻辑漏洞，和 DbC 本质都是 “先锁规则，再做实现”。</p>
<p>为什么类似的东西多年前没有成为"默认实践"？可能是因为现实约束：实现成本高、交付压力大、组织扩张快。你让大家先写 Spec、先做形式化建模——这在短期看起来是"额外投入"。</p>
<p>Fred Brooks 在 <em>No Silver Bullet</em>（1986）里区分过两类复杂性：</p>
<ul>
<li><strong>Accidental Complexity（偶然复杂性）</strong>：语法、样板代码、环境配置、重复劳动——主要由工具和流程造成</li>
<li><strong>Essential Complexity（本质复杂性）</strong>：需求澄清、抽象设计、系统边界、一致性语义——来自问题域本身</li>
</ul>
<p>AI 来了之后，这个账要重新算：</p>






























<table><thead><tr><th/><th>过去</th><th>AI 时代</th></tr></thead><tbody><tr><td><strong>偶然复杂性</strong></td><td>消耗大量工程精力</td><td>AI 大幅压缩（写接口、补样板、修 lint）</td></tr><tr><td><strong>本质复杂性</strong></td><td>同样存在，但常被"赶进度"掩盖</td><td>仍然存在，甚至更容易被 AI 的"完整实现"掩盖</td></tr><tr><td><strong>核心资产</strong></td><td>代码本身</td><td>契约层（类型 / 接口 / 测试 / Spec）</td></tr><tr><td><strong>代码的性质</strong></td><td>资产、心血、不轻易删</td><td>可蒸发物、可重建的缓存</td></tr></tbody></table>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58f5ebdf78fd4dfd9e1a16e52207e9a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=cwqcwJNqU%2BE04njBdR4Y0mtAy9w%3D" alt="file" loading="lazy"/></p>
<p>回到前几天我删代码的操作——我能那么果断，靠的其实不是勇气，是底气。底气来自一层"契约"已经写在那里：</p>
<ul>
<li>类型：输入输出的结构约束</li>
<li>接口：模块暴露什么能力、怎么调用</li>
<li>测试：哪些行为必须成立，边界在哪里</li>
</ul>
<p>只要这层东西在，代码就没那么神圣了。写得不好？实在不行调整完“契约”，代码删掉重来。某个实现绕了？换一种写法。甚至整个模块都能替换掉——前提是<strong>契约可靠</strong>。</p>
<p>所以我有一个稍微激进但很实用的心智模型：</p>
<blockquote>
<p><strong>Spec（广义契约）与测试更接近"源"，实现更像一种可重建的缓存。</strong></p>
</blockquote>
<p>我不是说实现不重要，而是说：在契约足够清晰、验证足够自动化的前提下，<strong>实现的可替换性会显著提高</strong>。</p>
<h2 data-id="heading-2">3、技术栈会"分层沉淀"</h2>
<p>那么，未来的技术栈会如何分层呢？</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[表层]</span> 业务变化快 / 迭代快
       代码可替换性强，AI 写得最多。大家基本都在这一层工作。

<span class="hljs-selector-attr">[中层]</span> 通用能力沉淀：组件库 / 框架 / 中间件
       变化变慢，开始强调稳定性与兼容性。出现一些未来被叫做“底层"的新基架人。

<span class="hljs-selector-attr">[基岩]</span> runtime / 编译器 / OS / 协议栈
       变动极少，但一动就可能是系统级影响。很多公司可能都没一个这样的人。
</code></pre>
<p>这其实就是历史在重演：</p>






























<table><thead><tr><th>时代</th><th>"主流”开发者在写什么</th><th>"底层"交给谁了</th></tr></thead><tbody><tr><td>1960s</td><td>汇编</td><td>硬件工程师</td></tr><tr><td>1990s</td><td>C/C++</td><td>汇编 / OS 专家</td></tr><tr><td>2010s</td><td>高级语言 / 框架</td><td>系统程序员</td></tr><tr><td>2030s?</td><td>Spec / 契约 / 架构设计</td><td>AI + 少数代码专家</td></tr></tbody></table>
<p>今天写业务的人不懂汇编，也不需要懂；但我们仍然需要懂汇编/懂 runtime 的人 —— 不多，但不能没有。</p>
<p>那么，当下是那些不懂代码的人，成为了 Spec / 契约 / 架构设计师么？</p>
<p>也许不是。我观察到一个有点"残酷"的现象：<strong>那些能上升到 AI x Spec Engineer 的人，往往是本身 Coding 能力就很强的人。</strong></p>
<p>他们不是因为"看不起、看不懂代码"而上去的，而是因为他们真的把代码玩懂了 —— 写得够多、踩过够多坑、读过够多源码，才敢在上层随心所欲。</p>
<p>也就是说，借助 AI 编码，越会写代码的人，越不需要写代码了。这就引出一个困境：</p>
<h2 data-id="heading-3">4、成长路径断裂：不写代码，能懂代码吗？</h2>
<p>Ruby on Rails 的作者 DHH 写过一篇文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fworld.hey.com%2Fdhh%2Fcoding-should-be-a-vibe-50908f49" target="_blank" title="https://world.hey.com/dhh/coding-should-be-a-vibe-50908f49" ref="nofollow noopener noreferrer">《Coding should be a vibe!》</a>，他说 AI 是很好的结对伙伴，但把键盘完全交出去，他宁可退休。他的理由很简单：写代码本身就是乐趣，是手艺。未来手动编码或许会变成类似 “养马代步” 的小众爱好，失去经济价值 ——编程应该以人为本，迎合开发者的需求，带来愉悦的体验。</p>
<p>但他同时还提出了一个更尖锐的问题：</p>
<blockquote>
<p>"If you don't actually write code, how do you learn to code?"</p>
<p>如果你不去真实地写代码，你如何学会 Coding？（来自 DHH 的另一期<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6i5hvNA72ZU" target="_blank" title="https://www.youtube.com/watch?v=6i5hvNA72ZU" ref="nofollow noopener noreferrer">播客访谈</a>）</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5dc12164c1341c58779c8bd9e832c62~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=5SPbUkHeytbq6ymuMsLxQqiyPDs%3D" alt="file" loading="lazy"/></p>
<p>他打了一个弹吉他的比方：你看再多的吉他视频，只要你没有亲手去学习，你就很难学会弹吉他。放在我们今天的语境里，这个问题可以再推一步：</p>
<blockquote>
<p>要成为顶尖的 Spec Engineer，需要深刻理解代码。</p>
<p>但如果 Coding 被 AI 接管了，这种理解从哪里来？</p>
</blockquote>
<p>这就是我说的"成长路径断裂"：过去我们靠"写得多 → 踩坑多 → 理解深"来积累能力。现在第一步被 AI 替掉了，中间会不会断层？</p>
<p>面对这个困难，在其他事情上也许能找到一些参考：</p>
<ul>
<li><strong>飞行员不是每天都手动飞</strong>，但他们定期用模拟器保持手感、训练极端情况。代码会不会变成类似的"模拟器"——不是日常生产工具，而是用来建立直觉、训练诊断能力的训练工具？</li>
<li><strong>指挥家不需要精通每种乐器</strong>，但他懂乐理、懂配器、听过足够多、也指挥过足够多。未来的 Spec Engineer，也许不需要"能手写一切"，但需要"能听懂代码在说什么、能诊断哪里出了问题"。</li>
<li><strong>医生的住院实习期仍然存在</strong>，即使手术机器人越来越强。也许我们仍然需要一段"强制手写代码"的阶段，作为建立底层理解的必经之路。</li>
</ul>
<p>"懂代码"的定义可能会变：从"我能把它写出来"，变成"我能审查它、能评判它、能在关键时刻诊断它"。</p>
<p>这只是一些推测，现在没有答案。甚至"没有答案"本身就是答案的一部分：我们正在经历一次职业路径的巨大变化。</p>
<h2 data-id="heading-4">5、那现在应该学什么？</h2>
<p>最近面试的时候，有候选人问：<strong>现在应该学什么？</strong></p>
<p>他们的困惑很真实：过去花时间掌握的很多编码知识，AI 现在都会了；而且在日常工作里，大家也确实越来越依赖 AI 来写代码。那接下来往哪走？</p>
<p>同样这也是我们很多人的困惑。如果要尝试回答，可能是：</p>
<h3 data-id="heading-5">第一，重新学习软件工程和架构设计。</h3>
<p>这听起来像句废话，但认真想想：过去十几年互联网高速增长的时候，大家的注意力大多在"怎么更快写出来"上。软件工程那些东西——抽象建模、系统边界、契约设计——在课上听过，在工作里落实得不多。</p>
<p>现在 AI 把 Coding 成本打下来了，这些"上层能力"反而变得更值钱。重新把它们捡起来，不是复古，是顺势而为。比如现在大家热议的 SDD（Spec-Driven Development）、TDD（Test-Driven Development）、PBT（Property-Based Testing）——这些概念都不是 AI 时代新创的，最早的可以追溯到二三十年前。只是现在 AI 让"先写 Spec/测试，让机器填实现"这件事变得真正可行，它们才重新翻红。</p>
<h3 data-id="heading-6">第二，把 Vibe Coding/Vibe Engineering 当成一门实践课来学。</h3>
<p>Vibe Coding 上手太简单，让大家会误以为它并没有技巧。其实不然。OpenAI 创始成员、特斯拉前 AI 总监 Andrej Karpathy <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fkarpathy%2Fstatus%2F2004607146781278521" target="_blank" title="https://x.com/karpathy/status/2004607146781278521" ref="nofollow noopener noreferrer">发推</a>说自己"作为程序员从未感到如此落后"，他觉得如果能把过去一年出现的东西串起来，生产力可以提升 10 倍，但没做到就是技能问题。Steve Yegge 在<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fk147AyWj01W-V7IpkV0g2A" target="_blank" title="https://mp.weixin.qq.com/s/k147AyWj01W-V7IpkV0g2A" ref="nofollow noopener noreferrer">近期访谈</a>里更激进：他认为驾驭 AI 编程需要约 2000 小时的刻意练习。</p>
<p>不管你叫它 Vibe Coding、Vibe Engineering 还是别的什么，它本质上是一种<strong>新的协作模式</strong>——需要主动学习和刻意练习，不是天然就会的（前一篇文章也有提到：<a href="https://link.juejin.cn?target=https%3A%2F%2Fkstack.corp.kuaishou.com%2Farticle%2F14474" target="_blank" title="https://kstack.corp.kuaishou.com/article/14474" ref="nofollow noopener noreferrer">《Vibe Coding 中的 5 个选择》</a>）。</p>
<p>那对于我们这些接触不深的开发者，可以如何循序渐进呢？</p>
<ol>
<li><strong>尝试用"计划模式"入门 SDD</strong>——很多 AI 编码工具都有类似的能力，根据你的需求先生成计划文档（spec），等你确认后再生成实现。这是最低成本的入门方式。慢慢找到用文档和 Spec 驱动开发的感觉</li>
<li><strong>解锁并行工作的能力</strong>——同时让多个 Agent 帮你一起干活。大家可以在很多工具里找个这个能力。</li>
<li><strong>发现适合自己的工作模式</strong>——每个人的习惯不一样，有人喜欢先写测试，有人喜欢先画架构图，有人喜欢对话式迭代。找到你自己的节奏，逐步去挑战更复杂的任务。</li>
<li><strong>打造自己的工作流</strong>——借助 Skills、Rules、MCP 等，打造自己的高效工作模式。</li>
</ol>
<h3 data-id="heading-7">第三，多花点时间关注自己的业务。</h3>
<p>不要光死盯着代码了，理解业务，理解目标，理解整个事情为什么要这么做。拒绝成为 AI 人柱力。</p>
<h2 data-id="heading-8">6、一个开放问题</h2>
<p>最后留一个问题给大家，可以尽情在评论区大战：</p>
<blockquote>
<p><strong>会不会出现"代码盲"的优秀架构师？</strong>—— 从未亲手写过代码，但能设计出色的系统</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2dd8afd93254c11a252ed20a0104c61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=wqJbjYvu1LaUvsq7h6f2VGJWJJY%3D" alt="file" loading="lazy"/></p>
<p>无论答案是什么，<strong>当实现成本下降时，能够把事情"想清楚、写清楚、验证清楚"的能力，会变得更稀缺</strong>。</p>
<p>回到开头的问题：<strong>如果代码不值钱了，写代码的人还值钱吗？</strong></p>
<p>我的回答是：<strong>写代码的人不会消失，但能"定义清楚要写什么"的人会更值钱。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）]]></title>    <link>https://juejin.cn/post/7602466689712078863</link>    <guid>https://juejin.cn/post/7602466689712078863</guid>    <pubDate>2026-02-03T13:28:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602466689712078863" data-draft-id="7602246300454092835" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T13:28:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LucianaiB"/> <meta itemprop="url" content="https://juejin.cn/user/1269294586664749"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1269294586664749/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LucianaiB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:28:07.000Z" title="Tue Feb 03 2026 13:28:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是热爱探索AI前沿技术的LucianaiB。</p>
<p>前面我尝试了，感兴趣的可以才是部署一下试试</p>
<p>1.在 Windows 上部署 Openclaw：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FiF3ED1e649kkmdR26Y1xiw" target="_blank" title="https://mp.weixin.qq.com/s/iF3ED1e649kkmdR26Y1xiw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/iF3ED1e64…</a></p>
<p>2.把 Openclaw 接入到 Moltbook：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQUrB50iwRGGdkl1LO-Tl8Q" target="_blank" title="https://mp.weixin.qq.com/s/QUrB50iwRGGdkl1LO-Tl8Q" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QUrB50iwR…</a></p>
<p>相信很多技术爱好者都有这样的经历：趁着双十一或者大促，脑子一热买了一台腾讯云或者阿里云的服务器。买的时候雄心勃勃，想着要搭建博客、跑脚本、做图床。结果呢？大概率是跑了几个自动化签到脚本后，它就静静地躺在控制台里“吃灰”，每个月白白扣费。</p>
<p>但是在自己的电脑运行 Openclaw 无法做到24小时的在运行，于是我就想到了我有一个好久不用的腾讯云服务器，之前购买主要是跑一些自动化签到脚本，并没有实际做什么具体工作。于是我就想到把废弃的腾讯云服务器改为 Openclaw 的24小时的服务器。</p>
<p>于是，一个大胆的想法诞生了：<strong>能不能把我那个闲置的腾讯**</strong>云服务器*<strong>*，改造成一个 24 小时在线的 Openclaw？</strong></p>
<p>今天，我就手把手教大家，如何用一句话，把服务器秒改 Openclaw。</p>
<h2 data-id="heading-0">一句话让腾讯云服务器改为 Openclaw</h2>
<p>首先打开你的服务器管理网站</p>
<p>👉 <strong>直达链接</strong>：：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Flighthouse%2Finstance%2F" target="_blank" title="https://console.cloud.tencent.com/lighthouse/instance/" ref="nofollow noopener noreferrer">console.cloud.tencent.com/lighthouse/…</a></p>
<p>（如果没有服务器的可以通过左侧的 Openclaw 专属链接获取有更大优惠：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.tencentcloud.com%2Fact%2Fpro%2FFreeTier%3Freferral_code%3DU0R814D3%26lang%3Den" target="_blank" title="https://www.tencentcloud.com/act/pro/FreeTier?referral_code=U0R814D3&amp;lang=en" ref="nofollow noopener noreferrer">www.tencentcloud.com/act/pro/Fre…</a>）</p>
<p>注：我用的是国内腾讯云服务器，而专属链接获得的是腾讯云国际服务器，网络连接 OpenAI 或 GitHub 会更顺畅。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7bd3f5da6dee4a5c83b9a0fcc2ac1420~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=kCIOi%2FDWATc7sRbNpdytYQEcers%3D" alt="img" loading="lazy"/></p>
<p>选择你要部署的服务器直接登录即可，登录后如下所示。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f8d78bbd7b04d79a77d968918a39519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=fSWJPyGLwuMUeYqALTP2%2B3jyzy4%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-1">真正的「0 门槛」启动</h3>
<p>你不需要懂代码！！！</p>
<p>直接在右上角点击<code>OrcaTerm AI</code>，唤醒AI助手。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d7c47d80183431183b1501224b5f142~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=inwf%2Bap%2BL7w%2FR4EwVIbTdepgZ%2B4%3D" alt="img" loading="lazy"/></p>
<p>只要在 AI 助手中用提示词表达即可，例如：<strong>“部署OpenClaw🔥”</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1726ff205ada489786c4e32532be8bdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Nzkda4e9%2Bkb%2F4TuM2dyRq%2BslsNg%3D" alt="img" loading="lazy"/></p>
<p>AI 助手就会自动识别你的需求，并进入部署引导流程。</p>
<p><strong>整个过程不需要输入任何命令，只需要“点确认”。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57cf262dbd3a4fd8ad24772ef6e9f43a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Ip2FmqoHbLXrRNblBQqt0wW96l4%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-2">初始化配置向导</h3>
<p>部署完成后需要点击手动运行配置一下向导：</p>
<pre><code class="hljs language-Plain" lang="Plain">openclaw onboard --install-daemon
</code></pre>
<p>下面的现在可以把我的作为参考，详细的也可以看开头1.在 Windows 上部署 Openclaw 位置中有介绍</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36f09e9e47b544d3ac071b6ca1b85668~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=k7MrWP%2BBtzpU1MsdUKP69HV%2BZmk%3D" alt="img" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ac86c0999da42f1b14052fadb2bfa95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=cYJ2Na7YjieYnp19a5y83kZkovU%3D" alt="img" loading="lazy"/></p>
<p>下面就是成功了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b100d5b614a7467286540796d6bc46a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=pc8KuwINUGGvJG8cSSDIW%2FrSowg%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-3">免费白嫖AI模型（包括 kimi-k2.5 等）</h3>
<p>1.注册账号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbuild.nvidia.com%2F" target="_blank" title="https://build.nvidia.com/" ref="nofollow noopener noreferrer">build.nvidia.com/</a>，建议用谷歌登录即可。</p>
<p>2.左上角点击头像，新建一个API Key。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4284ab240e1c4288a6b2782f3bd6835c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=pTTMlmHzaY%2F5suPoRwdP45%2B9CzA%3D" alt="img" loading="lazy"/></p>
<p>3.再次唤醒AI助手，把下面的API KEY换为你自己的，直接扔给它等待就好了。</p>
<pre><code class="hljs language-Python" lang="Python">帮我打开 ~/.openclaw/openclaw.json文件，在 models 部分增加下面的代码，注意：providers 外面还要加一层 models，如果原来配置有models就加到原来的里面
{
  ... 其他内容不要改
  <span class="hljs-string">"models"</span>: {
   <span class="hljs-string">"providers"</span>:{
        <span class="hljs-string">"英伟达nvidia"</span>: {
            <span class="hljs-string">"baseUrl"</span>: <span class="hljs-string">"https://integrate.api.nvidia.com/v1"</span>,
            <span class="hljs-string">"apiKey"</span>: <span class="hljs-string">"nvapi-HxKN8Zp2-xxxxx-替换成你的 key,
            "</span>api<span class="hljs-string">": "</span>openai-completions<span class="hljs-string">",
            "</span>models<span class="hljs-string">": [
              {
                "</span><span class="hljs-built_in">id</span><span class="hljs-string">": "</span>moonshotai/kimi-k2<span class="hljs-number">.5</span><span class="hljs-string">",
                "</span>name<span class="hljs-string">": "</span>moonshotai/kimi-k2<span class="hljs-number">.5</span><span class="hljs-string">",
                "</span>reasoning<span class="hljs-string">": false,
                "</span><span class="hljs-built_in">input</span><span class="hljs-string">": [
                  "</span>image<span class="hljs-string">",
                  "</span>text<span class="hljs-string">"
                ],
                "</span>cost<span class="hljs-string">": {
                  "</span><span class="hljs-built_in">input</span><span class="hljs-string">": 0,
                  "</span>output<span class="hljs-string">": 0,
                  "</span>cacheRead<span class="hljs-string">": 0,
                  "</span>cacheWrite<span class="hljs-string">": 0
                },
                "</span>contextWindow<span class="hljs-string">": 200000,
                "</span>maxTokens<span class="hljs-string">": 8192
              }
            ]
        }
        ... 其他内容不要改
    }
    ... 其他内容不要改
  }
}
</span></code></pre>
<p>助手直接帮你配置成功</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eeb61cc13f584f3d9627b81627ab2c21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=xakRpVOCGwzGVqP8UJy0GH3o9%2Fg%3D" alt="img" loading="lazy"/></p>
<p>修改模型，输入：<code>openclaw config</code>，修改模型。切记</p>
<p>Model/auth provider 选择  Skip for now</p>
<p>Filter models by provider 中选择你添加的 模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa01190623604aeda89d79b1ffbf1610~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=94BO84Lxt0Qsz%2B5udtMwlQAPNOk%3D" alt="img" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea7544550e274da185f2359b56198afa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=YLjQfukdUrYKrs5aJhm4Sb3XshQ%3D" alt="img" loading="lazy"/></p>
<p>输入<code>openclaw gateway restart</code> 重启网关，再输入 <code>openclaw tui</code> 测试模型，问他是什么模型即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e57a9f22227046419c53b9d8a74c2d0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=LKHrLkyavAbR7wsTUG8z%2FkwpIVk%3D" alt="img" loading="lazy"/></p>
<h2 data-id="heading-4">赋予灵魂：接入飞书实现远程操控</h2>
<p>在本地运行虽然好，但我们不可能永远守在电脑前。接入飞书（Lark），就能让你在手机上随时随地给家里的电脑下达指令。</p>
<p>1.打开飞书开放平台配置：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopen.feishu.cn%2Fapp" target="_blank" title="https://open.feishu.cn/app" ref="nofollow noopener noreferrer">open.feishu.cn/app</a>，新建一个，输入相关信息。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0431793bbff643b28b1010e302e9b31f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Qx6aZTSTA5MbL%2BihJEzWWMd%2F5dQ%3D" alt="img" loading="lazy"/></p>
<p>2.获取到：App ID和App Secret</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5f1f0df483840f0b3f6436f050e43e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=KHHR%2F3VE4jVFn31XpaFQ9%2FenayA%3D" alt="img" loading="lazy"/></p>
<p>3.在添加应用能力里选择机器人并添加。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ea2789aa62e4f12a4968484e8b0a49d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=lK3YWL3kkl4ykg%2B%2FRGLPgjafvlU%3D" alt="img" loading="lazy"/></p>
<p>4.给机器人开通全部的权限。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b2520fe8618432c97c95b807044b25f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=i1rhGIp4zquJtFGAS74m8alAh8Y%3D" alt="img" loading="lazy"/></p>
<p>4.接下来就是下载插件使飞书和 Openclaw 连接。</p>
<pre><code class="hljs language-Plain" lang="Plain">openclaw plugins inatall @m1heng-clawd/feishu
安装插件：飞书插件 - 支持飞书通道，并且配置好

openclaw config set channels.feishu.appId "cli_xxxxx"
openclaw config set channels.feishu.appSecret "your_app_secret"
openclaw config set channels.feishu.enabled true


我的飞书信息：
App ID：换为你自己在步骤2得到的
App Secret：换为你自己在步骤2得到的

openclaw gateway restart
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38b8f851a5dc4597ad5d5b977eaddae0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=UDIfcNNL9yWknmO5SxhAsNfk80o%3D" alt="img" loading="lazy"/></p>
<p>如果它还是没配置好，那就单独让它配置一下就好了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60dd7dca97e74b9e84583bcce9032ec4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=lfNre70CrA85oSu7fSRIV494itY%3D" alt="img" loading="lazy"/></p>
<p>5.接下来就是在<strong>事件与**</strong>回调****（二者缺一不可）**中选择长连接即可（如果没有成功，可能需要上一步重启 Openclaw Gateway 服务）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bef366f3894b457d84de393444a7bdd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=42Of8YVYztwnQr%2FQSCozxf8fGPA%3D" alt="img" loading="lazy"/></p>
<p>然后在添加事件中全部勾选即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/364e3fb19fed4108829a2237769bb089~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=381eUjecKnTQq7gbSihVobCZITM%3D" alt="img" loading="lazy"/></p>
<p>6.最后就是插件一个版本进行发布即可，点击左侧“版本管理与发布” -&gt; 创建版本 -&gt; 申请发布。。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21e391d4145d4c388f306218723671e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=YwLAyT1f24a%2BSFmypEBqnhhNsz8%3D" alt="img" loading="lazy"/></p>
<p>打开飞书</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c17e3d4af5c246549ea365f3f03931cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=DSYs3dx70tGcR84dV%2Fu83wWu%2F9k%3D" alt="img" loading="lazy"/></p>
<h2 data-id="heading-5">总结与建议</h2>
<p>写在最后，我对这套 <strong>OpenClaw + 腾讯云 + NVIDIA +</strong> <strong>飞书</strong> 的技术栈做一个客观的总结。</p>
<p><strong>瑕不掩瑜，强烈推荐！</strong></p>
<p>对于手里有闲置服务器（尤其是腾讯云轻量应用服务器）的朋友来说，这几乎是<strong>性价比最高</strong>的玩法。它不仅能让你熟悉 Linux、API 调试、IM 机器人开发等全套技术栈，还能给你提供一个实实在在的生产力工具。</p>
<p>别让你的服务器再“吃灰”了，现在就动手，把它变成你的赛博伙伴吧！</p>
<h2 data-id="heading-6">ending</h2>
<p>我创建了一个读者 <strong>AI 极客交流及搞钱群</strong>，群里都是一群前沿的 AI 极客，经常讨论最新的 AI 消息，用法，以及变现方法。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34b157f303214483bb9421a0aa8fa5cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=ogfXlG0QfdBQoB120pz%2Blm7FHrA%3D" alt="img" loading="lazy"/></p>
<p>但是任何人在群里打任何广告，都会被我 T 掉。</p>
<p>如果你对这个特别的群，感兴趣，可以公众号后台私信我加入。</p>
<p>暗号：<strong>AI</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-深入浅出Vue Diff 算法]]></title>    <link>https://juejin.cn/post/7602488966609829926</link>    <guid>https://juejin.cn/post/7602488966609829926</guid>    <pubDate>2026-02-03T13:35:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966609829926" data-draft-id="7602464510607343642" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-深入浅出Vue Diff 算法"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-02-03T13:35:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-深入浅出Vue Diff 算法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:35:52.000Z" title="Tue Feb 03 2026 13:35:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在 Vue 的响应式系统中，当数据发生变化时，Vue 会生成一颗新的虚拟 DOM 树（VNode Tree）。Diff 算法的核心任务就是通过对比新旧两棵树，以<strong>最小的性能代价</strong>完成真实 DOM 的更新。本文将带你深度拆解 Vue Diff 的核心机制。</p>
<h2 data-id="heading-1">一、 Diff 算法的核心策略</h2>
<p>Vue 的 Diff算法就是比较dom树的新旧节点，一边比较一边给真实dom移动、插入或者删除节点。Diff 算法基于两个基本假设，从而将时间复杂度从 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 降低到了 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>：</p>
<ol>
<li>
<p><strong>同层比较</strong>：算法只会对同一层级的节点进行比较，不会跨层级操作。</p>
</li>
<li>
<p><strong>深度优先</strong>：通过递归的方式，先处理子节点，再处理父节点。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-2">二、 三大核心函数解析</h2>
<p>Diff 的过程主要由 <code>patch</code>、<code>patchVnode</code> 和 <code>updateChildren</code> 三个函数协同完成。</p>
<h3 data-id="heading-3">1. patch 函数：同层比对的入口</h3>
<p>这是 Diff 的起点，它负责决定是直接替换整个节点，还是深入比对，比较策略如下:</p>
<ul>
<li><strong>如果新节点不存在</strong>：直接删除旧节点。</li>
<li><strong>如果新节点存在，旧节点不存在</strong>：直接新建并插入节点。</li>
<li><strong>如果两个节点都存在，但节点类型不同</strong>：认为节点已改变，销毁旧的，创建新的。</li>
<li><strong>如果两个节点都存在，且节点类型相同</strong>：则调用 <code>patchVnode</code> 继续比对</li>
<li>。</li>
</ul>
<h3 data-id="heading-4">2. patchVnode 函数：属性与文本的更新</h3>
<p>当确定两个节点“值得比较”时，执行以下逻辑：</p>
<ul>
<li>
<p><strong>首先判断新节点是否为文本节点</strong>（为文本节点就说明没有子节点了），如果是的话，则直接更新dom的文本内容为新节点的文本内容。</p>
</li>
<li>
<p><strong>如果新节点不是文本节点，而旧节点是文本节点的话</strong>，说明节都是全新的，所以直接将新节点添加到父节点中</p>
</li>
<li>
<p><strong>如果新旧节点都不是文本节点</strong>，则说明两者都有子节点，接下来就进<code>updateChildren()</code>函数进行下一步比较并更新子节点</p>
</li>
</ul>
<h3 data-id="heading-5">3. updateChildren 函数：双端比较算法</h3>
<p>这是 Vue Diff 的灵魂。它通过 <strong>“双端指针”</strong> （新头、新尾、旧头、旧尾）向中间靠拢，寻找可复用的节点。<code>updateChildren</code>函数对会新旧两个节点设置4个指针，分别指向<strong>新头、旧头、新尾、旧尾</strong>，它主要对5种情况进行比较：</p>
<p><strong>比较的五种优先级：</strong></p>
<ol>
<li>
<p><strong>首先是旧头新头进行比较</strong>：如果二者相同，就对二者执行<code>patchVnode()</code>，并将旧头新头两个指针向中间移动。</p>
</li>
<li>
<p><strong>如果旧头新头不相同，就进行旧尾新尾的比较</strong>：如果旧尾新尾相同的话，则将旧尾新尾两指针向中间移动。</p>
</li>
<li>
<p><strong>如果旧头与新头，旧尾与新尾都不相同</strong>：那就进行交叉比较，比较方式如下：</p>
<ul>
<li>首先是<code>旧头新尾</code>比较，如果二者相同，那么就执行<code>patchVnode()</code>，并将<code>旧头</code>指针向后移一位，<code>新尾</code>指针前移一位</li>
<li>如果<code>旧头新尾</code>不相同，那就比较<code>新头旧尾</code>，如果二者相同，那么就执行<code>patchVnode()</code>，并将<code>新头</code>指针后移一位，<code>旧尾</code>指针前移一位</li>
</ul>
</li>
<li>
<p><strong>如果以上四种情形都不满足的话，那说明没有相同的节点可以复用，则将在旧节点中遍历寻找与新头节点<code>key</code>值相同的节点</strong>。</p>
<ul>
<li>如果没有在旧节点中找到<code>key</code>值相同的节点，则说明新头节点是一个新的节点，那么就直接新建，并将新头指针后移</li>
<li>如果在旧节点中找到了<code>key</code>值相同的节点，则执行<code>patchVnode()</code>函数继续比较对应key值相同的节点是否为同一节点，并将新头指针后移</li>
</ul>
</li>
</ol>
<h2 data-id="heading-6">三、 案例实战：双端比对全过程</h2>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ec83030ce1a4cf0a180fa9831cb19b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=9hsqO%2BQujd1tCY9DCIbT7MHwiic%3D" alt="image.png" loading="lazy"/></p>
<p>第一次循环后，发现旧头新尾、旧头新头不相同，但旧尾新头相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/badf80934baf489e936512fcc13fa46f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=12EtkYLn9HC6vz0kMn5C9yk6hF0%3D" alt="image.png" loading="lazy"/></p>
<p>二次循环后，同样是旧尾新头相同，这时就将diff 后创建的真实节点 C 插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3cad57541253446d8cc24bc9b3587f9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=8K6arhQ%2BJG97Ds6WZFty9hvyvhk%3D" alt="image.png" loading="lazy"/>
第三次循环中，发现在旧节点中没有找到E节点，这时候直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。<code>旧节点startIndex</code> 和 endIndex 都保持不动。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d18c036d24b84dd281f2b17407430125~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=sKW3IPwYH8T3O%2BZqBXSMwY74YAI%3D" alt="image.png" loading="lazy"/></p>
<p>四次循环中，发现了新头旧头相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，<code>新节点的startIndex</code> 移动到了 B</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51c36115bc9c435e8b2698b46d68b7eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=VZKbtZB%2BSktwdgKS%2B0ACZ63%2B700%3D" alt="image.png" loading="lazy"/></p>
<p>第五次循环中，发现了新头旧头相同，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的<code>startIndex</code>移动到了 F。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/662bbc50b30047deb95e168722d32442~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=ESZQ3wJH4F1QV1N2JOZbWRoFg2Y%3D" alt="image.png" loading="lazy"/></p>
<p>最后一次循环中，发现在旧节点中没有找到F节点，这时直接创建 F 对应的真实节点，直接将其插入到 B 节点后面，并将新头指针向后移动一位，发现startIndex大于endIndex ，这时循环结束。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87fd8bbdeb9c42af89fcd05f1e28b5c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=LTtsxKfLVaERF4%2FHU95Fy6mqghM%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-7">四、 总结</h2>
<ul>
<li><strong>Diff 的本质</strong>：是虚拟 DOM 周期的终点，也是真实 DOM 更新的起点。</li>
<li><strong>Key 的重要性</strong>：没有 <code>key</code> 会导致 Diff 算法回退到性能极差的逐个更新模式。务必在 <code>v-for</code> 中提供稳定、唯一的 <code>key</code>。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！]]></title>    <link>https://juejin.cn/post/7602420156397568043</link>    <guid>https://juejin.cn/post/7602420156397568043</guid>    <pubDate>2026-02-03T13:44:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397568043" data-draft-id="7602503154505269289" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！"/> <meta itemprop="keywords" content="后端,.NET"/> <meta itemprop="datePublished" content="2026-02-03T13:44:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追逐时光者"/> <meta itemprop="url" content="https://juejin.cn/user/2770425031690333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2770425031690333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追逐时光者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:44:38.000Z" title="Tue Feb 03 2026 13:44:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>今天大姚给大家分享一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用：<strong>Magic.NET</strong>。</p>
<h2 data-id="heading-1">项目介绍</h2>
<p>Magic.NET 是一个基于 .NET 6、7 实现的通用权限管理平台（RBAC模式），基于 Apache-2.0 协议开源。整合最新技术高效快速开发，前后端分离模式，开箱即用，模块化架构设计，层次清晰。前端基于小诺Vue（antd）框架，整体 RBAC 基础数据结构+API接口风格采用小诺vue版本模式。</p>
<h2 data-id="heading-2">应用场景</h2>
<p>Magic.NET 适用于需要精细权限管理的企业管理应用系统（如 ERP、CRM、OA 等）。</p>
<h2 data-id="heading-3">功能模块</h2>
<ul>
<li>
<p><strong>用户管理</strong>：对企业用户和系统管理员用户的维护，可绑定用户职务、机构、角色、数据权限等。</p>
</li>
<li>
<p><strong>角色管理</strong>：角色绑定菜单后，可限制相关角色的人员登录系统的功能范围。角色也可以绑定数据授权范围。</p>
</li>
<li>
<p><strong>职位管理</strong>：用户职务管理，职务可作为用户的一个标签，职务目前没有和权限等其他功能挂钩。</p>
</li>
<li>
<p><strong>组织机构管理</strong>：公司组织架构维护，支持多层级结构的树形结构。</p>
</li>
<li>
<p><strong>菜单管理</strong>：菜单目录、菜单和按钮的维护是权限控制的基本单位。</p>
</li>
<li>
<p><strong>字典管理</strong>：系统内各种枚举类型的维护。</p>
</li>
<li>
<p><strong>日志管理</strong>：</p>
<ul>
<li><strong>访问日志</strong>：用户的登录和退出日志的查看和管理。</li>
<li><strong>操作日志</strong>：用户的操作业务的日志的查看和管理。</li>
</ul>
</li>
<li>
<p><strong>多应用管理</strong>：通过应用来控制不同维度的菜单展示。</p>
</li>
<li>
<p><strong>文件管理</strong>：文件的上传、下载、查看等操作，文件可使用本地存储、阿里云 OSS、腾讯 COS 接入，支持拓展。</p>
</li>
<li>
<p><strong>定时任务</strong>：定时任务的维护，通过 cron 表达式控制任务的执行频率。</p>
</li>
<li>
<p><strong>系统配置</strong>：系统运行的参数的维护，参数的配置与系统运行机制息息相关。</p>
</li>
<li>
<p><strong>服务监控</strong>：服务器的运行状态，CPU、内存、网络等信息数据的查看。</p>
</li>
<li>
<p>等等等...</p>
</li>
</ul>
<h2 data-id="heading-4">功能特点</h2>
<ul>
<li><strong>前后端分离</strong>：前端基于 Vue 框架，后端基于 .NET 6/7，实现前后端解耦。</li>
<li><strong>模块化架构设计</strong>：层次清晰，业务层推荐写到单独模块，框架升级不影响业务。</li>
<li><strong>RBAC 权限模型</strong>：基于角色的访问控制，实现精细化的权限管理。</li>
<li><strong>易扩展</strong>：代码量少、通俗易懂、功能强大，易于扩展和维护。</li>
<li>等等等...</li>
</ul>
<h2 data-id="heading-5">项目技术栈</h2>
<ul>
<li><strong>后端技术栈：</strong> .NET、Furion、MiniExcel、SqlSugar等。</li>
<li><strong>前端技术栈：</strong> Vue、Ant Design of Vue等。</li>
<li><strong>数据库支持：</strong> SQLite、SQL Server、MySQL。</li>
</ul>
<h2 data-id="heading-6">项目源代码</h2>
<h3 data-id="heading-7">后端代码</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/337eedd3b98b4639afcaa0c9b56bd9e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=b7q4sP6ePYxy%2BC7HPhirGNOlzU0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb2a9e747a5148528bf5d56f43bd2b50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=SDFLc7fbD%2FQJ88yQsXbIXv2WzZo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">前端代码</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/40d4e77896474be1bdf901dd6dfcb994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=g1iFS4WLuLZolzolcBel67O3zf0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">项目演示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17bcae953bb0477cbb4e6260af3edb50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=%2F7nxsvuHLFjrn94PxidQ%2FuOZ%2FuY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cce8faf2b89747e7a62a3e2c174d63d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=jR%2BViPVRCjhYkruvO%2BbA7P7uBbk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c1c8d5156834ae7b3f0fc8f74521a0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=L04s1vGlYjbgrqM1fmidZU9e2qY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f94bfb9b6b34d57986440ee9aa7917c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=Q2Y5S65dBqtQDvV7cInEckdtUIM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b6c268f5c68435a9cc37b7c20589eca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=9WUS0BH1HUe8yRZ1wvcauwsduBk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce0584b04f8848ecbbc285132809d387~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=7H7OedLYPzUV8Jz8In%2BzUTituxg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/472d1bec9e374d2fb7a26fc6e6a41d6a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=VwKxbtvp%2BAH%2BNSRaOlU8b5PnJA0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8ab02f57ddb4672856325eb5331aa3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=UcSLicZQA7lQ%2BonaGJ16Bbx2RYw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9266cf395c7a4d3f8a2a2e30e66590ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=7293C5O75HvN3QXCrNHft0Pa458%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa5db3a356c84a5a848af2f8c3a456d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=wF3nVWbyUdReosIWb3RjLp0gd%2Bo%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d21e27a1211e4032b8f9fe2760fe6d23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=vdeCgwj1gPEdVvUX5Tu6C64TBZI%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1248cf9ad4c4aedb65ac33677891eb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=5fP1iXTgwwTENc9FBZ2ZqQbM7uU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">项目源码地址</h2>
<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>
<ul>
<li><strong>Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fzhengguojing%2Fmagic-net" target="_blank" title="https://gitee.com/zhengguojing/magic-net" ref="nofollow noopener noreferrer">gitee.com/zhengguojin…</a></li>
</ul>
<h2 data-id="heading-11">优秀项目和框架精选</h2>
<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>
<ul>
<li><strong>GitHub开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYSGStudyHards%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectPicks.md" target="_blank" title="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md" ref="nofollow noopener noreferrer">github.com/YSGStudyHar…</a></li>
<li><strong>Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fysgdaydayup%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectPicks.md" target="_blank" title="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md" ref="nofollow noopener noreferrer">gitee.com/ysgdaydayup…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（81）如何在数据同步中使用Hibernate？]]></title>    <link>https://juejin.cn/post/7602503154505039913</link>    <guid>https://juejin.cn/post/7602503154505039913</guid>    <pubDate>2026-02-03T12:11:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505039913" data-draft-id="7602455806446075910" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（81）如何在数据同步中使用Hibernate？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T12:11:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（81）如何在数据同步中使用Hibernate？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:11:56.000Z" title="Tue Feb 03 2026 12:11:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据同步过程中使用Hibernate，可以帮助你从一个数据库中提取数据，并将这些数据同步到另一个数据库中。以下是一个详细的示例，结合代码演示如何在数据同步过程中使用Hibernate。</p>
<h3 data-id="heading-0">1. 设置Hibernate配置</h3>
<p>首先，创建两个Hibernate配置文件，分别用于源数据库和目标数据库的连接。</p>
<h4 data-id="heading-1"><code>hibernate_source.cfg.xml</code>（源数据库配置文件）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/source_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>source_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>source_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>validate<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-2"><code>hibernate_target.cfg.xml</code>（目标数据库配置文件）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/target_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>target_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>target_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">2. 创建实体类</h3>
<p>创建两个实体类分别对应源数据库和目标数据库中的表。</p>
<h4 data-id="heading-4"><code>SourceEntity.java</code>（源数据库实体类）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "source_table")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SourceEntity</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String dataField;
    <span class="hljs-keyword">private</span> String timestamp;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h4 data-id="heading-5"><code>TargetEntity.java</code>（目标数据库实体类）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "target_table")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetEntity</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String dataField;
    <span class="hljs-keyword">private</span> String timestamp;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h3 data-id="heading-6">3. 编写数据同步流程</h3>
<p>编写数据同步流程来提取、转换和加载数据。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSync</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Configure Hibernate for source database</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">sourceConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate_source.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sourceSessionFactory</span> <span class="hljs-operator">=</span> sourceConfig.buildSessionFactory();

        <span class="hljs-comment">// Configure Hibernate for target database</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">targetConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate_target.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">targetSessionFactory</span> <span class="hljs-operator">=</span> targetConfig.buildSessionFactory();

        <span class="hljs-comment">// Extract Data from source database</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">sourceSession</span> <span class="hljs-operator">=</span> sourceSessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">sourceTransaction</span> <span class="hljs-operator">=</span> sourceSession.beginTransaction();
        List&lt;SourceEntity&gt; sourceData = sourceSession.createQuery(<span class="hljs-string">"FROM SourceEntity"</span>, SourceEntity.class).list();
        sourceTransaction.commit();
        sourceSession.close();

        <span class="hljs-comment">// Transform Data</span>
        List&lt;TargetEntity&gt; transformedData = transformData(sourceData);

        <span class="hljs-comment">// Sync Data to target database</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">targetSession</span> <span class="hljs-operator">=</span> targetSessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">targetTransaction</span> <span class="hljs-operator">=</span> targetSession.beginTransaction();
        <span class="hljs-keyword">for</span> (TargetEntity targetEntity : transformedData) {
            targetSession.saveOrUpdate(targetEntity);
        }
        targetTransaction.commit();
        targetSession.close();

        sourceSessionFactory.close();
        targetSessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;TargetEntity&gt; <span class="hljs-title function_">transformData</span><span class="hljs-params">(List&lt;SourceEntity&gt; sourceData)</span> {
        <span class="hljs-comment">// Example transformation logic</span>
        <span class="hljs-keyword">return</span> sourceData.stream()
                .map(sourceEntity -&gt; {
                    <span class="hljs-type">TargetEntity</span> <span class="hljs-variable">targetEntity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetEntity</span>();
                    targetEntity.setDataField(sourceEntity.getDataField());
                    targetEntity.setTimestamp(sourceEntity.getTimestamp());
                    <span class="hljs-keyword">return</span> targetEntity;
                })
                .toList();
    }
}
</code></pre>
<h3 data-id="heading-7">4. 运行数据同步流程</h3>
<p>编译并运行上面的Java代码，它将连接到源数据库，提取数据，对数据进行转换，并将这些数据同步到目标数据库。</p>
<h3 data-id="heading-8">例子解释</h3>
<ol>
<li><strong>Hibernate配置：</strong> 配置两个Hibernate配置文件，分别用于源数据库和目标数据库的连接。</li>
<li><strong>实体类：</strong> 创建对应源数据表和目标数据表的实体类。</li>
<li><strong>数据同步流程：</strong>
<ul>
<li><strong>抽取（Extract）：</strong> 从源数据库中提取数据。</li>
<li><strong>转换（Transform）：</strong> 对提取的数据进行转换。</li>
<li><strong>加载（Load）：</strong> 将转换后的数据同步到目标数据库中。</li>
</ul>
</li>
</ol>
<p>通过以上配置和代码示例，我们展示了如何在数据同步过程中使用Hibernate。这个示例包括如何配置Hibernate、如何定义实体类以及如何编写数据同步流程，帮助你实现从源数据库到目标数据库的数据同步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（82）如何在数据加密中使用Hibernate？]]></title>    <link>https://juejin.cn/post/7602401081265897508</link>    <guid>https://juejin.cn/post/7602401081265897508</guid>    <pubDate>2026-02-03T12:13:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265897508" data-draft-id="7602401081265881124" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（82）如何在数据加密中使用Hibernate？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T12:13:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（82）如何在数据加密中使用Hibernate？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:13:00.000Z" title="Tue Feb 03 2026 12:13:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据加密过程中使用Hibernate，可以确保敏感数据在存储到数据库时得到加密处理，从而提高数据的安全性。以下是一个详细的示例，结合代码演示如何在数据加密过程中使用Hibernate。</p>
<h3 data-id="heading-0">1. 设置Hibernate配置</h3>
<p>创建一个Hibernate配置文件<code>hibernate.cfg.xml</code>，用于连接数据库。</p>
<h4 data-id="heading-1"><code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/encryption_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>db_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>db_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h3 data-id="heading-2">2. 创建加密和解密工具类</h3>
<p>实现一个简单的加密和解密工具类，使用Java的AES加密算法。</p>
<h4 data-id="heading-3"><code>EncryptionUtils.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.crypto.Cipher;
<span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;
<span class="hljs-keyword">import</span> javax.crypto.SecretKey;
<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;
<span class="hljs-keyword">import</span> java.util.Base64;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionUtils</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">"AES"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] KEY = <span class="hljs-string">"MySuperSecretKey"</span>.getBytes(); <span class="hljs-comment">// 应该使用更安全的密钥管理方式</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(KEY, ALGORITHM);
        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        <span class="hljs-type">byte</span>[] encryptedBytes = cipher.doFinal(value.getBytes());
        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(encryptedBytes);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(KEY, ALGORITHM);
        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        <span class="hljs-type">byte</span>[] decodedBytes = Base64.getDecoder().decode(value);
        <span class="hljs-type">byte</span>[] decryptedBytes = cipher.doFinal(decodedBytes);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decryptedBytes);
    }
}
</code></pre>
<h3 data-id="heading-4">3. 创建自定义Hibernate类型</h3>
<p>创建一个自定义的Hibernate用户类型，用于处理加密字段的映射。</p>
<h4 data-id="heading-5"><code>EncryptedStringType.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.engine.spi.SharedSessionContractImplementor;
<span class="hljs-keyword">import</span> org.hibernate.usertype.UserType;

<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> java.sql.PreparedStatement;
<span class="hljs-keyword">import</span> java.sql.ResultSet;
<span class="hljs-keyword">import</span> java.sql.SQLException;
<span class="hljs-keyword">import</span> java.sql.Types;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptedStringType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserType</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sqlTypes() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{Types.VARCHAR};
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class <span class="hljs-title function_">returnedClass</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> String.class;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object x, Object y)</span> {
        <span class="hljs-keyword">return</span> x == <span class="hljs-literal">null</span> ? y == <span class="hljs-literal">null</span> : x.equals(y);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(Object x)</span> {
        <span class="hljs-keyword">return</span> x.hashCode();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nullSafeGet</span><span class="hljs-params">(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getString(names[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> EncryptionUtils.decrypt(value);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">"Failed to decrypt value"</span>, e);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nullSafeSet</span><span class="hljs-params">(PreparedStatement st, Object value, <span class="hljs-type">int</span> index, SharedSessionContractImplementor session)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            st.setNull(index, Types.VARCHAR);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">try</span> {
                st.setString(index, EncryptionUtils.encrypt((String) value));
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">"Failed to encrypt value"</span>, e);
            }
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object value)</span> {
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMutable</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Serializable <span class="hljs-title function_">disassemble</span><span class="hljs-params">(Object value)</span> {
        <span class="hljs-keyword">return</span> (Serializable) value;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">assemble</span><span class="hljs-params">(Serializable cached, Object owner)</span> {
        <span class="hljs-keyword">return</span> cached;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">replace</span><span class="hljs-params">(Object original, Object target, Object owner)</span> {
        <span class="hljs-keyword">return</span> original;
    }
}
</code></pre>
<h3 data-id="heading-6">4. 创建实体类</h3>
<p>创建实体类并使用自定义的类型来对字段进行加密。</p>
<h4 data-id="heading-7"><code>User.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.annotations.Type;
<span class="hljs-keyword">import</span> org.hibernate.annotations.TypeDef;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "users")</span>
<span class="hljs-meta">@TypeDef(name = "encryptedString", typeClass = EncryptedStringType.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Type(type = "encryptedString")</span>
    <span class="hljs-keyword">private</span> String sensitiveData;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h3 data-id="heading-8">5. 编写数据加密和解密流程</h3>
<p>编写代码来创建和读取加密数据。</p>
<h4 data-id="heading-9"><code>Main.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Configure Hibernate</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> config.buildSessionFactory();

        <span class="hljs-comment">// Save encrypted data</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
        user.setSensitiveData(<span class="hljs-string">"MySecretData"</span>);
        session.save(user);
        transaction.commit();
        session.close();

        <span class="hljs-comment">// Read encrypted data</span>
        session = sessionFactory.openSession();
        <span class="hljs-type">User</span> <span class="hljs-variable">retrievedUser</span> <span class="hljs-operator">=</span> session.get(User.class, user.getId());
        System.out.println(<span class="hljs-string">"Decrypted data: "</span> + retrievedUser.getSensitiveData());
        session.close();

        sessionFactory.close();
    }
}
</code></pre>
<h3 data-id="heading-10">6. 运行数据加密和解密流程</h3>
<p>编译并运行上面的Java代码，它将加密敏感数据保存到数据库，并将加密数据读取并解密后输出。</p>
<h3 data-id="heading-11">例子解释</h3>
<ol>
<li><strong>Hibernate配置：</strong> 配置一个Hibernate配置文件，用于连接数据库。</li>
<li><strong>加密和解密工具类：</strong> 实现一个简单的加密和解密工具类，使用AES加密算法。</li>
<li><strong>自定义Hibernate类型：</strong> 创建一个自定义的Hibernate用户类型，用于处理加密字段的映射。</li>
<li><strong>实体类：</strong> 创建实体类并使用自定义的类型来对字段进行加密。</li>
<li><strong>数据加密和解密流程：</strong> 编写代码来创建和读取加密数据。</li>
</ol>
<p>通过以上配置和代码示例，我们展示了如何在数据加密过程中使用Hibernate。这个示例包括如何配置Hibernate、如何定义加密和解密工具类、如何创建自定义Hibernate类型以及如何编写数据加密和解密流程，帮助你实现数据的加密存储和读取。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来]]></title>    <link>https://juejin.cn/post/7602420156397371435</link>    <guid>https://juejin.cn/post/7602420156397371435</guid>    <pubDate>2026-02-03T12:25:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397371435" data-draft-id="7602454700503613481" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来"/> <meta itemprop="keywords" content="人工智能,开源"/> <meta itemprop="datePublished" content="2026-02-03T12:25:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:25:07.000Z" title="Tue Feb 03 2026 12:25:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<blockquote>
<p>"如果语音合成能在你的设备上以每秒1000+字符的速度运行，完全离线，支持50+语言，那该多好？"</p>
</blockquote>
<p>这是"一天一个开源项目"系列的第11篇文章。今天带你了解的项目是 <strong>Supertonic</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsupertone-inc%2Fsupertonic" target="_blank" title="https://github.com/supertone-inc/supertonic" ref="nofollow noopener noreferrer">GitHub</a>）。</p>
<p>传统的TTS系统要么依赖云端API（有延迟和隐私问题），要么速度慢、质量差。Supertonic通过ONNX运行时实现了极速、高质量、完全设备端的语音合成，在M1 Mac上达到1000+字符/秒的速度，支持50+语言，内置智能文本规范化，无需预处理，让语音合成真正"飞起来"。</p>
<h3 data-id="heading-1">你将学到什么</h3>
<ul>
<li>Supertonic的核心架构和技术特点</li>
<li>如何在各种平台上使用Supertonic进行TTS</li>
<li>ONNX运行时的优势和实现</li>
<li>内置文本规范化的智能处理</li>
<li>流式处理和实时语音合成</li>
<li>与其他TTS系统的对比分析</li>
<li>如何开始使用Supertonic构建应用</li>
</ul>
<h3 data-id="heading-2">前置知识</h3>
<ul>
<li>对TTS（文本转语音）有基本了解</li>
<li>熟悉至少一种编程语言（Python、JavaScript、Swift、Java等）</li>
<li>了解ONNX的基本概念（可选）</li>
<li>对设备端AI有基本认识（可选）</li>
</ul>
<hr/>
<h2 data-id="heading-3">项目背景</h2>
<h3 data-id="heading-4">项目简介</h3>
<p><strong>Supertonic</strong> 是一个<strong>极速、设备端、多语言的文本转语音（TTS）系统</strong>，专为极致性能和最小计算开销而设计。通过ONNX Runtime运行，完全在设备上运行——无需云端、无需API调用、无需隐私担忧。</p>
<p><strong>项目解决的核心问题</strong>：</p>
<ul>
<li>云端TTS有延迟和隐私问题</li>
<li>传统设备端TTS速度慢、质量差</li>
<li>缺乏多语言支持</li>
<li>文本规范化需要预处理</li>
<li>不同平台需要不同的实现</li>
</ul>
<p><strong>面向的用户群体</strong>：</p>
<ul>
<li>需要设备端TTS的移动应用开发者</li>
<li>需要离线语音合成的桌面应用开发者</li>
<li>对隐私有要求的开发者</li>
<li>需要多语言TTS的国际化应用开发者</li>
<li>对性能有极致要求的开发者</li>
</ul>
<h3 data-id="heading-5">作者/团队介绍</h3>
<p><strong>团队：Supertone Inc.</strong></p>
<ul>
<li><strong>背景</strong>：专注于语音技术和AI的科技公司</li>
<li><strong>贡献者</strong>：4位贡献者，包括核心开发团队</li>
<li><strong>理念</strong>：打造极速、高质量、完全设备端的TTS系统</li>
</ul>
<p><strong>项目创建时间</strong>：2024年（从GitHub活动来看是持续活跃的项目）</p>
<h3 data-id="heading-6">项目数据</h3>
<ul>
<li>⭐ <strong>GitHub Stars</strong>: 2.6k+（持续快速增长）</li>
<li>🍴 <strong>Forks</strong>: 232+</li>
<li>📦 <strong>版本</strong>: v2.0.0（最新版本，2026年1月6日发布）</li>
<li>📄 <strong>License</strong>: MIT（代码），OpenRAIL-M（模型）</li>
<li>🌐 <strong>Demo</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fspaces%2FSupertone%2Fsupertonic-2" target="_blank" title="https://huggingface.co/spaces/Supertone/supertonic-2" ref="nofollow noopener noreferrer">Hugging Face Spaces</a></li>
<li>📚 <strong>文档</strong>: GitHub README包含完整使用指南</li>
<li>💬 <strong>社区</strong>: GitHub Issues活跃</li>
</ul>
<p><strong>项目发展历程</strong>：</p>
<ul>
<li>2024年：项目创建，发布v1版本</li>
<li>2024-2025年：持续优化，添加多语言支持</li>
<li>2025年：发布v2版本，性能大幅提升</li>
<li>2026年：持续迭代，社区活跃度持续提升</li>
</ul>
<hr/>
<h2 data-id="heading-7">主要功能</h2>
<h3 data-id="heading-8">核心作用</h3>
<p>Supertonic的核心作用是<strong>提供极速、高质量、完全设备端的TTS系统</strong>，主要功能包括：</p>
<ol>
<li><strong>极速语音合成</strong>：M1 Mac上达到1000+字符/秒的速度</li>
<li><strong>多语言支持</strong>：支持50+语言，包括英语、中文、日语、韩语等</li>
<li><strong>智能文本规范化</strong>：内置文本规范化，无需预处理</li>
<li><strong>流式处理</strong>：支持流式TTS，实现实时语音合成</li>
<li><strong>完全离线</strong>：无需云端，完全在设备上运行</li>
</ol>
<h3 data-id="heading-9">使用场景</h3>
<ol>
<li>
<p><strong>移动应用</strong></p>
<ul>
<li>阅读助手应用</li>
<li>语音导航应用</li>
<li>无障碍应用</li>
</ul>
</li>
<li>
<p><strong>桌面应用</strong></p>
<ul>
<li>电子书阅读器</li>
<li>文档朗读工具</li>
<li>语音助手</li>
</ul>
</li>
<li>
<p><strong>Web应用</strong></p>
<ul>
<li>浏览器扩展</li>
<li>在线语音合成服务</li>
<li>语音聊天应用</li>
</ul>
</li>
<li>
<p><strong>IoT设备</strong></p>
<ul>
<li>智能音箱</li>
<li>语音交互设备</li>
<li>边缘计算设备</li>
</ul>
</li>
</ol>
<h3 data-id="heading-10">快速开始</h3>
<h4 data-id="heading-11">安装方式</h4>
<p>Supertonic支持多种编程语言和平台：</p>
<p><strong>Python</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装Python包</span>
pip install supertonic

<span class="hljs-comment"># 使用示例</span>
from supertonic import SupertonicTTS

tts = SupertonicTTS()
audio = tts.synthesize(<span class="hljs-string">"Hello, world!"</span>)
</code></pre>
<p><strong>JavaScript/Node.js</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装npm包</span>
npm install supertonic

<span class="hljs-comment"># 使用示例</span>
const { SupertonicTTS } = require(<span class="hljs-string">'supertonic'</span>);

const tts = new SupertonicTTS();
const audio = await tts.synthesize(<span class="hljs-string">"Hello, world!"</span>);
</code></pre>
<p><strong>其他平台</strong>：</p>
<ul>
<li><strong>C++</strong>: 使用cpp目录下的实现</li>
<li><strong>Swift</strong>: 使用swift目录下的实现</li>
<li><strong>Java</strong>: 使用java目录下的实现</li>
<li><strong>C#</strong>: 使用csharp目录下的实现</li>
<li><strong>Go</strong>: 使用go目录下的实现</li>
<li><strong>Rust</strong>: 使用rust目录下的实现</li>
<li><strong>Flutter</strong>: 使用flutter目录下的实现</li>
<li><strong>Web</strong>: 使用web目录下的实现</li>
</ul>
<h4 data-id="heading-12">最简单的使用示例</h4>
<p><strong>Python示例</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> supertonic <span class="hljs-keyword">import</span> SupertonicTTS

<span class="hljs-comment"># 初始化TTS引擎</span>
tts = SupertonicTTS()

<span class="hljs-comment"># 合成语音</span>
text = <span class="hljs-string">"Supertonic is a lightning-fast, on-device TTS system."</span>
audio = tts.synthesize(text)

<span class="hljs-comment"># 保存音频文件</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"output.wav"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:
    f.write(audio)
</code></pre>
<p><strong>JavaScript示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SupertonicTTS</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'supertonic'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">synthesize</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> tts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupertonicTTS</span>();
    <span class="hljs-keyword">const</span> audio = <span class="hljs-keyword">await</span> tts.<span class="hljs-title function_">synthesize</span>(<span class="hljs-string">"Supertonic is lightning-fast!"</span>);
    <span class="hljs-comment">// 处理音频数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Audio generated:"</span>, audio.<span class="hljs-property">length</span>, <span class="hljs-string">"bytes"</span>);
}

<span class="hljs-title function_">synthesize</span>();
</code></pre>
<h3 data-id="heading-13">核心特性</h3>
<ul>
<li><strong>极速性能</strong>：M1 Mac上1000+字符/秒，远超传统TTS系统</li>
<li><strong>多语言支持</strong>：支持50+语言，包括主要国际语言</li>
<li><strong>智能文本规范化</strong>：内置文本规范化，处理数字、日期、缩写等复杂表达</li>
<li><strong>流式处理</strong>：支持流式TTS，实现实时语音合成</li>
<li><strong>完全离线</strong>：无需云端，完全在设备上运行，保护隐私</li>
<li><strong>跨平台支持</strong>：支持C++、Swift、JavaScript、Java、C#、Go、Rust、Flutter、Web等</li>
<li><strong>ONNX运行时</strong>：基于ONNX Runtime，高效推理</li>
<li><strong>高质量语音</strong>：生成自然、清晰的语音</li>
</ul>
<h3 data-id="heading-14">项目优势</h3>





















































<table><thead><tr><th align="left">对比项</th><th align="left">Supertonic</th><th align="left">云端TTS</th><th align="left">传统设备端TTS</th></tr></thead><tbody><tr><td align="left"><strong>速度</strong></td><td align="left">✅ 1000+字符/秒</td><td align="left">⚠️ 受网络影响</td><td align="left">❌ 慢</td></tr><tr><td align="left"><strong>隐私</strong></td><td align="left">✅ 完全本地</td><td align="left">❌ 数据上传</td><td align="left">✅ 本地</td></tr><tr><td align="left"><strong>延迟</strong></td><td align="left">✅ 极低</td><td align="left">❌ 网络延迟</td><td align="left">⚠️ 中等</td></tr><tr><td align="left"><strong>多语言</strong></td><td align="left">✅ 50+语言</td><td align="left">✅ 支持</td><td align="left">⚠️ 有限</td></tr><tr><td align="left"><strong>文本规范化</strong></td><td align="left">✅ 内置智能处理</td><td align="left">⚠️ 需要预处理</td><td align="left">❌ 需要预处理</td></tr><tr><td align="left"><strong>离线使用</strong></td><td align="left">✅ 完全离线</td><td align="left">❌ 需要网络</td><td align="left">✅ 离线</td></tr><tr><td align="left"><strong>成本</strong></td><td align="left">✅ 免费开源</td><td align="left">❌ API费用</td><td align="left">✅ 免费</td></tr></tbody></table>
<p><strong>为什么选择Supertonic？</strong></p>
<p>相比云端TTS和传统设备端TTS，Supertonic提供极速性能、完全离线、智能文本规范化、多语言支持，是设备端TTS的理想选择。</p>
<hr/>
<h2 data-id="heading-15">项目详细剖析</h2>
<h3 data-id="heading-16">架构设计</h3>
<p>Supertonic采用<strong>ONNX Runtime</strong>作为推理引擎，实现高效的设备端TTS。</p>
<h4 data-id="heading-17">核心架构</h4>
<pre><code class="hljs language-vbnet" lang="vbnet">Supertonic TTS System
├── <span class="hljs-keyword">Text</span> Normalization（文本规范化）
│   ├── 数字处理
│   ├── 日期时间处理
│   ├── 缩写展开
│   └── 多语言支持
├── <span class="hljs-keyword">Text</span>-<span class="hljs-keyword">to</span>-Latent（文本到潜在空间）
│   ├── Flow Matching模型
│   ├── Length-Aware RoPE
│   └── 文本-语音对齐
├── Latent-<span class="hljs-keyword">to</span>-Speech（潜在空间到语音）
│   ├── Speech Autoencoder
│   ├── 流式处理
│   └── 音频生成
└── ONNX Runtime（推理引擎）
    ├── 模型优化
    ├── 硬件加速
    └── 跨平台支持
</code></pre>
<h4 data-id="heading-18">ONNX Runtime优势</h4>
<p>ONNX Runtime提供了以下优势：</p>
<ul>
<li><strong>跨平台</strong>：统一的模型格式，支持多种平台</li>
<li><strong>硬件加速</strong>：支持GPU、NPU等硬件加速</li>
<li><strong>模型优化</strong>：自动优化模型推理性能</li>
<li><strong>易于部署</strong>：模型导出后可直接部署</li>
</ul>
<h4 data-id="heading-19">文本规范化</h4>
<p>Supertonic内置智能文本规范化，能够处理：</p>
<ul>
<li><strong>数字</strong>：123 → "one hundred twenty-three"</li>
<li><strong>日期</strong>：2024-01-01 → "January first, twenty twenty-four"</li>
<li><strong>时间</strong>：2:30 → "two thirty"</li>
<li><strong>缩写</strong>：Dr. → "Doctor"</li>
<li><strong>单位</strong>：30kph → "thirty kilometers per hour"</li>
<li><strong>技术缩写</strong>：h → "hours"</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>无需预处理，直接处理原始文本</li>
<li>智能识别上下文，正确展开缩写</li>
<li>支持多语言，每种语言有专门的规范化规则</li>
</ul>
<h4 data-id="heading-20">流式处理</h4>
<p>Supertonic支持流式TTS，实现实时语音合成：</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li>文本分块处理</li>
<li>逐块生成音频</li>
<li>实时输出音频流</li>
<li>低延迟响应</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>低延迟，适合实时应用</li>
<li>内存占用小，适合移动设备</li>
<li>用户体验好，响应迅速</li>
</ul>
<h3 data-id="heading-21">多语言支持</h3>
<p>Supertonic支持50+语言，包括：</p>
<p><strong>主要语言</strong>：</p>
<ul>
<li>英语、中文、日语、韩语</li>
<li>西班牙语、法语、德语、意大利语、葡萄牙语</li>
<li>俄语、阿拉伯语、印地语</li>
<li>泰语、越南语、印尼语</li>
</ul>
<p><strong>其他语言</strong>：</p>
<ul>
<li>荷兰语、波兰语、土耳其语、捷克语</li>
<li>罗马尼亚语、匈牙利语、希腊语</li>
<li>芬兰语、瑞典语、挪威语、丹麦语</li>
<li>以及更多语言</li>
</ul>
<p>每种语言都有专门的：</p>
<ul>
<li>文本规范化规则</li>
<li>语音模型</li>
<li>发音字典</li>
</ul>
<h3 data-id="heading-22">性能优化</h3>
<p>Supertonic通过多种技术实现极速性能：</p>
<h4 data-id="heading-23">模型优化</h4>
<ul>
<li><strong>模型压缩</strong>：减小模型大小，提升推理速度</li>
<li><strong>量化</strong>：使用INT8量化，在保持质量的同时提升速度</li>
<li><strong>算子融合</strong>：融合多个算子，减少计算开销</li>
</ul>
<h4 data-id="heading-24">硬件加速</h4>
<ul>
<li><strong>GPU加速</strong>：利用GPU并行计算能力</li>
<li><strong>NPU加速</strong>：支持NPU硬件加速（如Apple Neural Engine）</li>
<li><strong>CPU优化</strong>：针对CPU的SIMD优化</li>
</ul>
<h4 data-id="heading-25">推理优化</h4>
<ul>
<li><strong>批处理</strong>：批量处理多个请求</li>
<li><strong>缓存</strong>：缓存常用文本的音频结果</li>
<li><strong>预加载</strong>：预加载模型到内存</li>
</ul>
<h3 data-id="heading-26">应用案例</h3>
<p>多个项目基于Supertonic构建：</p>
<ol>
<li><strong>TLDRL</strong>：Chrome扩展，免费设备端TTS，可朗读任何网页</li>
<li><strong>Read Aloud</strong>：开源TTS浏览器扩展，支持Chrome和Edge</li>
<li><strong>PageEcho</strong>：iOS电子书阅读器应用</li>
<li><strong>VoiceChat</strong>：浏览器中的设备端语音到语音LLM聊天机器人</li>
<li><strong>OmniAvatar</strong>：从照片和语音生成说话头像视频</li>
<li><strong>CopiloTTS</strong>：Kotlin多平台TTS SDK</li>
<li><strong>Voice Mixer</strong>：PyQt5工具，用于混合和修改语音风格</li>
<li><strong>Supertonic MNN</strong>：基于MNN的轻量级库（fp32/fp16/int8）</li>
<li><strong>Transformers.js</strong>：Hugging Face的JS库，支持Supertonic</li>
<li><strong>Pinokio</strong>：Mac、Windows、Linux的一键本地云</li>
</ol>
<h3 data-id="heading-27">技术论文</h3>
<p>Supertonic基于三篇核心论文：</p>
<ol>
<li>
<p><strong>SupertonicTTS: Main Architecture</strong></p>
<ul>
<li>介绍SupertonicTTS的整体架构</li>
<li>包括语音自编码器、基于Flow Matching的文本到潜在空间模块</li>
<li>高效设计选择</li>
</ul>
</li>
<li>
<p><strong>Length-Aware RoPE: Text-Speech Alignment</strong></p>
<ul>
<li>提出Length-Aware Rotary Position Embedding (LARoPE)</li>
<li>改善交叉注意力机制中的文本-语音对齐</li>
</ul>
</li>
<li>
<p><strong>Self-Purifying Flow Matching: Training with Noisy Labels</strong></p>
<ul>
<li>描述自净化技术</li>
<li>使用噪声或不可靠标签稳健训练Flow Matching模型</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-28">项目地址与资源</h2>
<h3 data-id="heading-29">官方资源</h3>
<ul>
<li>🌟 <strong>GitHub</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsupertone-inc%2Fsupertonic" target="_blank" title="https://github.com/supertone-inc/supertonic" ref="nofollow noopener noreferrer">github.com/supertone-i…</a></li>
<li>🌐 <strong>Demo</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fspaces%2FSupertone%2Fsupertonic-2" target="_blank" title="https://huggingface.co/spaces/Supertone/supertonic-2" ref="nofollow noopener noreferrer">Hugging Face Spaces</a></li>
</ul>
<h3 data-id="heading-30">适用人群</h3>
<p><strong>Supertonic特别适合</strong>：需要设备端TTS的移动应用开发者、需要离线语音合成的桌面应用开发者、对隐私有要求的开发者、需要多语言TTS的国际化应用开发者、对性能有极致要求的开发者、需要实时语音合成的应用开发者。</p>
<p><strong>不适合</strong>：只需要云端TTS的用户、不需要多语言支持的场景、对模型大小有严格限制的极端场景。</p>
<hr/>
<p><em>欢迎来我中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>找到更多有用的知识和有趣的产品</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[团队宪法:CLAUDE.md 和rule使用技巧与复利模式]]></title>    <link>https://juejin.cn/post/7602454700503646249</link>    <guid>https://juejin.cn/post/7602454700503646249</guid>    <pubDate>2026-02-03T12:33:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700503646249" data-draft-id="7602503154505089065" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="团队宪法:CLAUDE.md 和rule使用技巧与复利模式"/> <meta itemprop="keywords" content="Claude,AI编程"/> <meta itemprop="datePublished" content="2026-02-03T12:33:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            团队宪法:CLAUDE.md 和rule使用技巧与复利模式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:33:46.000Z" title="Tue Feb 03 2026 12:33:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>你有没有遇到过这样的场景?</p>
<blockquote>
<p><strong>场景 1: 规范执行靠"吼"</strong></p>
<ul>
<li>代码评审时:"这个命名不符合规范啊,改一下"</li>
<li>提交代码时:"提交信息格式不对,重新写"</li>
<li>写完功能后:"测试呢?单元测试写了吗?"</li>
<li>每次都要提醒,每次都要返工</li>
</ul>
</blockquote>
<blockquote>
<p><strong>场景 2: AI 助手"不听话"</strong></p>
<ul>
<li>Claude Code 生成的代码风格乱七八糟</li>
<li>函数命名有时驼峰有时下划线</li>
<li>注释写得像天书,或者干脆不写</li>
<li>每次都要手动修改,效率大打折扣</li>
</ul>
</blockquote>
<p>传统团队靠"人盯人"执行规范,效率低、成本高、容易遗漏。而 AI 辅助开发时代,如果没有明确的规范,AI 生成的代码质量参差不齐,反而增加了维护负担。</p>
<p><strong>答案是</strong>: <strong>团队宪法 — CLAUDE.md + rules/</strong></p>
<p>就像国家需要宪法来规定基本原则,团队也需要一套"宪法"来定义:</p>
<ul>
<li><strong>项目的技术栈和常用命令是什么?</strong>（CLAUDE.md）</li>
<li><strong>我们的编码规范和安全底线是什么?</strong>（rules/ 目录）</li>
</ul>
<p><strong>团队宪法是区别草台班子和正规军的分水岭。</strong></p>
<p>本文将深入探讨如何通过 CLAUDE.md + rules/ 建立团队规范,并通过<strong>复利模式</strong>让这份宪法不断演进,让 Claude Code 成为越来越资深的队友。</p>
<p>阅读本文后,你将学会:</p>
<ul>
<li>理解团队宪法的目录结构和各部分的职责</li>
<li>正确使用 CLAUDE.md 存放项目事实,使用 rules/ 存放底线规则</li>
<li>建立复利思维:发现问题 → 更新宪法 → 全员受益</li>
<li>掌握让 AI 理解和遵守规范的技巧</li>
</ul>
<hr/>
<h2 data-id="heading-1">一、为什么需要"团队宪法"?</h2>
<h3 data-id="heading-2">1.1 传统团队的规范问题</h3>
<p>在没有自动化工具之前,团队规范靠什么维护?</p>
<p><strong>方式 1: 文档 + 口头传承</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">某公司编码规范.docx (上次更新: 3年前)
<span class="hljs-bullet">  -</span> 第 3 章 命名规范
<span class="hljs-bullet">  -</span> 第 5 章 注释规范
<span class="hljs-bullet">  -</span> 第 8 章 异常处理
  ...

现实:
<span class="hljs-bullet">  -</span> 新人入职不知道这份文档
<span class="hljs-bullet">  -</span> 老员工也不记得具体内容
<span class="hljs-bullet">  -</span> 规范更新后没人通知
</code></pre>
<p><strong>方式 2: Code Review 人肉检查</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">评审者:"这里应该用 Optional 而不是 null"</span>
<span class="hljs-section">开发者:"哦,好的" (心里想:又是这个问题,上次也提过)</span>
<span class="hljs-section">评审者:"下次注意" (心里想:已经说了 N 遍了)</span>

<span class="hljs-section">下周:</span>
  同样的问题再次出现...
</code></pre>
<p><strong>方式 3: Lint 工具 + Git Hooks</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># .eslintrc.js</span>
rules: {
  <span class="hljs-string">'semi'</span>: [<span class="hljs-string">'error'</span>, <span class="hljs-string">'always'</span>],
  <span class="hljs-string">'quotes'</span>: [<span class="hljs-string">'error'</span>, <span class="hljs-string">'single'</span>],
  ...100+ 条规则
}

问题:
  - 只能检查语法,不能检查逻辑
  - 配置复杂,维护困难
  - 无法覆盖架构层面的规范
</code></pre>
<p><strong>共同的痛点</strong>:</p>
<ul>
<li>❌ 规范执行<strong>不一致</strong> - 靠人工检查,难免遗漏</li>
<li>❌ 新人学习<strong>成本高</strong> - 需要阅读大量文档</li>
<li>❌ 规范更新<strong>难同步</strong> - 改了文档,代码不一定改</li>
<li>❌ 违规发现<strong>太晚</strong> - 代码写完才发现问题</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3efadae671a64ae7be8d193fa00da9a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=cakr03AXRFI0Uoqn1b3KkEBDYPk%3D" alt="03-01-CR-problem.png" loading="lazy"/>
在我们公司，我已经在Gerrit上部署了AI CodeReview系统，能抓出很多人工写的代码不按照公司规范来的情况，并且在AI都提示出来的情况下还不修改。</p>
<h3 data-id="heading-3">1.2 AI 辅助开发的新挑战</h3>
<p>引入 AI 后,问题不仅没有减少,反而增加了新的挑战:</p>
<p><strong>挑战 1: AI 不知道你的团队规范</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 你希望的代码风格</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findOne</span>({ id });
    <span class="hljs-keyword">return</span> user ?? <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed to get user'</span>, { id, error });
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseError</span>(<span class="hljs-string">'User query failed'</span>, { <span class="hljs-attr">cause</span>: error });
  }
}

<span class="hljs-comment">// AI 默认生成的代码(没有规范约束)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">return</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findOne</span>({ id }).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  })
}
</code></pre>
<p><strong>差异</strong>:</p>
<ul>
<li>❌ 缺少类型标注</li>
<li>❌ 使用 <code>console.log</code> 而不是 logger</li>
<li>❌ 错误处理不规范</li>
<li>❌ 没有异常抛出和上下文信息</li>
</ul>
<p><strong>挑战 2: 每次对话都要重复说明规范</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: "帮我实现用户登录功能"</span>
<span class="hljs-section">AI: [生成代码,不符合规范]</span>

<span class="hljs-section">你: "记得使用 logger 而不是 console.log"</span>
<span class="hljs-section">AI: [修改代码]</span>

<span class="hljs-section">你: "还要加上类型标注"</span>
<span class="hljs-section">AI: [再次修改]</span>

<span class="hljs-section">你: "异常处理要抛出 CustomError"</span>
<span class="hljs-section">AI: [又一次修改]</span>

效率大打折扣!
</code></pre>
<p><strong>挑战 3: AI 生成的代码风格不一致</strong></p>
<p>第一次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) { ... }  <span class="hljs-comment">// 驼峰命名</span>
</code></pre>
<p>第二次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) { ... }  <span class="hljs-comment">// 下划线命名</span>
</code></pre>
<p>第三次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GetUserList</span>(<span class="hljs-params"/>) { ... }  <span class="hljs-comment">// 大写开头</span>
</code></pre>
<p>同一个项目,三种命名风格混杂,维护噩梦!</p>
<h3 data-id="heading-4">1.3 claude.md 的定位与价值</h3>
<p><strong>团队宪法是什么?</strong></p>
<p>团队宪法是一套完整的配置体系,包括 CLAUDE.md（项目事实）和 .claude/ 目录下的 rules/ 规则文件,共同定义了 AI 在工作时应该遵守的规范和约束。</p>
<p><strong>核心价值</strong>:</p>
<ol>
<li><strong>自动加载,无需重复</strong> - Claude Code 启动时自动读取配置,每次对话都生效</li>
<li><strong>职责分离,易于维护</strong> - CLAUDE.md 存项目事实,rules/ 存底线规则,结构清晰</li>
<li><strong>可版本管理</strong> - 和代码一起提交到 Git,团队共享</li>
<li><strong>可持续改进</strong> - 发现问题就更新,形成复利效应</li>
</ol>
<p><strong>类比理解</strong>:</p>
<pre><code class="hljs language-objectivec" lang="objectivec">团队宪法就像国家的<span class="hljs-string">"宪法体系"</span>
  ├─ <span class="hljs-built_in">CLAUDE</span>.md: 项目事实(技术栈、常用命令、约束)
  ├─ rules/: 底线规则(编码规范、测试要求、安全规范)
  └─ 可以修正和完善(宪法修正案)
</code></pre>
<p><strong>对比传统方式</strong>:</p>















































<table><thead><tr><th align="left">维度</th><th align="left">传统规范文档</th><th align="left">Lint 工具</th><th align="left">claude.md</th></tr></thead><tbody><tr><td align="left"><strong>自动执行</strong></td><td align="left">❌ 靠人工</td><td align="left">✅ 自动检查</td><td align="left">✅ AI 自动遵守</td></tr><tr><td align="left"><strong>覆盖范围</strong></td><td align="left">✅ 全面</td><td align="left">⚠️ 仅语法层面</td><td align="left">✅ 全面(语法+逻辑+架构)</td></tr><tr><td align="left"><strong>学习成本</strong></td><td align="left">❌ 需要阅读大量文档</td><td align="left">⚠️ 需要理解规则</td><td align="left">✅ AI 直接理解并应用</td></tr><tr><td align="left"><strong>实时生效</strong></td><td align="left">❌ 写完代码才发现</td><td align="left">⚠️ 提交时检查</td><td align="left">✅ 生成时就符合规范</td></tr><tr><td align="left"><strong>版本管理</strong></td><td align="left">⚠️ 文档独立管理</td><td align="left">✅ 配置文件管理</td><td align="left">✅ 和代码一起管理</td></tr><tr><td align="left"><strong>可演进性</strong></td><td align="left">❌ 更新困难</td><td align="left">⚠️ 需要改配置</td><td align="left">✅ 随时更新,立即生效</td></tr></tbody></table>
<blockquote>
<p>"claude.md 不是约束 AI 的枷锁,而是让 AI 成为资深队友的训练手册"</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">二、claude.md 文件详解</h2>
<h3 data-id="heading-6">2.1 配置层级与工作原理</h3>
<p>Claude Code 支持<strong>两级配置</strong>,优先级规则: <strong>项目配置 &gt; 全局配置 &gt; Claude 默认行为</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-number">1.</span> 项目级配置(优先级最高)
   路径: &lt;项目根目录&gt;/<span class="hljs-variable constant_">CLAUDE</span>.<span class="hljs-property">md</span>
   作用域: 当前项目

<span class="hljs-number">2.</span> 全局配置(默认配置)
   路径: ~<span class="hljs-regexp">/.claude/</span><span class="hljs-variable constant_">CLAUDE</span>.<span class="hljs-property">md</span>
   作用域: 所有项目
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9474fc977550496daae032eb7a25da45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=rfhIcgMFaM6gMAqUqbl90A8zUQ8%3D" alt="03-02-config-hierarchy.png" loading="lazy"/></p>
<p><em>图2: claude.md 配置层级与加载机制,项目配置优先级高于全局配置</em></p>
<p><strong>工作原理</strong>: claude.md 的内容会被插入到每次 API 调用的系统提示词中,作为团队宪法让 AI 自动遵守。项目配置会覆盖全局配置中的同名规则,未覆盖的规则会继承。</p>
<p><strong>示例</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 全局配置: 使用双引号、末尾分号、2空格缩进</span>
<span class="hljs-section"># 项目配置: 使用单引号(覆盖)、4空格缩进(覆盖)</span>

<span class="hljs-section"># 最终生效: 单引号、末尾分号(继承)、4空格缩进</span>
</code></pre>
<h3 data-id="heading-7">2.2 团队宪法的目录结构</h3>
<p>根据 Claude 中文社区的官方实践，团队宪法应该采用以下目录结构（建议放进仓库，团队共享）：</p>
<pre><code class="hljs language-text" lang="text">your-repo/
├─ CLAUDE.md              # 项目事实（技术栈、常用命令、约束）
└─ .claude/
   └─ rules/              # 底线规则（拆成小文件）
      ├─ security.md      # 安全底线
      ├─ testing.md        # 测试底线
      └─ coding-style.md  # 代码风格底线
</code></pre>
<p><strong>CLAUDE.md 的定位：存放"项目事实"</strong></p>
<p>CLAUDE.md 的重点是写<strong>可执行、可验证的信息</strong>，而不是详细的规则：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：TypeScript + React 18+ + Next.js 14
<span class="hljs-bullet">-</span> 目录结构入口：src/ 为源代码目录

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`pnpm install`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`pnpm test`</span>
<span class="hljs-bullet">-</span> 构建：<span class="hljs-code">`pnpm build`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`pnpm format`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`pnpm lint`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
</code></pre>
<p><strong>rules/ 目录：存放"底线"规则</strong></p>
<p>规则应该拆成可组合、可审查的小文件：</p>
<ul>
<li><code>rules/security.md</code>：密钥与输入校验底线（禁硬编码、边界校验、最小权限）</li>
<li><code>rules/testing.md</code>：测试底线（TDD 流程、覆盖率门槛、关键路径必须 E2E）</li>
<li><code>rules/coding-style.md</code>：代码组织底线（文件大小、函数长度、错误处理等）</li>
</ul>
<p>这些规则不要"抄一大段"，而是写成<strong>团队真的会执行</strong>的清单。</p>
<p><strong>职责分离原则</strong>：</p>
<ul>
<li><strong>CLAUDE.md</strong>：只写项目事实，不写详细规则</li>
<li><strong>rules/</strong>：只写规则约束，不写项目事实</li>
<li>两者配合，形成完整的团队宪法</li>
</ul>
<h3 data-id="heading-8">2.3 上下文优先级</h3>
<p>CLAUDE.md 和 rules/ 目录中的配置优先级高于对话历史,确保规范始终生效:</p>
<pre><code class="hljs language-ini" lang="ini">优先级排序:
1. CLAUDE.md 和 rules/ 中的规范  <span class="hljs-section">[最高优先级]</span>
2. 用户当前输入的指令            <span class="hljs-section">[高优先级]</span>
3. 对话历史中的上下文            <span class="hljs-section">[中优先级]</span>
4. Claude 的默认行为             <span class="hljs-section">[低优先级]</span>
</code></pre>
<p><strong>实际效果</strong>: 即使之前对话中使用了不符合规范的代码,CLAUDE.md 和 rules/ 中的规范仍会在新代码生成时生效。用户可以在单次对话中临时覆盖规范,但下次对话会自动恢复。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1064288d1b1410a8df35a170d359e34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=T9ynkkREShW8ZSEJ1AkMEFEUyNM%3D" alt="03-03-claude-md-mechanism.png" loading="lazy"/></p>
<p><em>图3: claude.md 工作原理,展示如何被解析并插入到 API 调用的系统提示词中</em></p>
<hr/>
<h2 data-id="heading-9">三、团队宪法的内容设计</h2>
<h3 data-id="heading-10">3.1 CLAUDE.md：项目事实</h3>
<p>CLAUDE.md 的定位是"项目记忆"，重点写可执行、可验证的信息：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：TypeScript + React 18+ + Next.js 14
<span class="hljs-bullet">-</span> 目录结构入口：src/ 为源代码目录，packages/ 为共享包

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`pnpm install`</span>
<span class="hljs-bullet">-</span> 运行开发服务器：<span class="hljs-code">`pnpm dev`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`pnpm test`</span>
<span class="hljs-bullet">-</span> 构建：<span class="hljs-code">`pnpm build`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`pnpm format`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`pnpm lint`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
<span class="hljs-bullet">-</span> 提交前必须通过 lint 和测试
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>✅ 写具体的技术栈和版本号</li>
<li>✅ 写准确的命令（AI 会直接执行）</li>
<li>✅ 写团队共识的约束（不是详细规则）</li>
<li>❌ 不要写详细的编码规范（应该放在 rules/ 目录）</li>
</ul>
<h3 data-id="heading-11">3.2 rules/ 目录：底线规则</h3>
<p>规则应该拆成可组合、可审查的小文件。以下是三个核心规则文件的示例：</p>
<p><strong>rules/coding-style.md</strong>：代码组织底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 代码风格规范</span>

<span class="hljs-section">## TypeScript 风格</span>
<span class="hljs-bullet">-</span> 严格模式: 启用 <span class="hljs-code">`strict: true`</span>
<span class="hljs-bullet">-</span> 类型标注: 所有函数参数和返回值必须标注类型
<span class="hljs-bullet">-</span> 类型断言: 避免使用 <span class="hljs-code">`any`</span>,优先使用 <span class="hljs-code">`unknown`</span>

<span class="hljs-section">## 代码格式</span>
<span class="hljs-bullet">-</span> 缩进: 2 空格
<span class="hljs-bullet">-</span> 引号: 单引号(字符串),双引号(JSX 属性)
<span class="hljs-bullet">-</span> 分号: 必须使用
<span class="hljs-bullet">-</span> 行宽: 最大 100 字符

<span class="hljs-section">## 命名约定</span>
<span class="hljs-bullet">-</span> 组件: PascalCase (UserProfile.tsx)
<span class="hljs-bullet">-</span> 函数: camelCase (getUserData)
<span class="hljs-bullet">-</span> 常量: UPPER<span class="hljs-emphasis">_SNAKE_</span>CASE (API<span class="hljs-emphasis">_BASE_</span>URL)
<span class="hljs-bullet">-</span> 布尔值: is/has/can 开头 (isLoading, hasPermission)

<span class="hljs-section">## 注释要求</span>
<span class="hljs-bullet">-</span> ✅ 必须: 复杂逻辑、算法实现、业务规则
<span class="hljs-bullet">-</span> ✅ 推荐: 公共 API、工具函数
<span class="hljs-bullet">-</span> 所有导出的函数/类必须添加 JSDoc
</code></pre>
<p><strong>rules/testing.md</strong>：测试底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 测试规范</span>

<span class="hljs-section">## 单元测试</span>
<span class="hljs-bullet">-</span> 覆盖率: &gt; 80%
<span class="hljs-bullet">-</span> 框架: Jest + Testing Library
<span class="hljs-bullet">-</span> 每个公共函数必须有测试
<span class="hljs-bullet">-</span> 测试用例命名: <span class="hljs-code">`should ... when ...`</span>

<span class="hljs-section">## 集成测试</span>
<span class="hljs-bullet">-</span> 工具: Cypress / Playwright
<span class="hljs-bullet">-</span> 覆盖: 关键用户流程
<span class="hljs-bullet">-</span> 运行时机: PR 合并前

<span class="hljs-section">## TDD 流程</span>
<span class="hljs-bullet">-</span> RED: 先写失败的测试
<span class="hljs-bullet">-</span> GREEN: 实现最小代码让测试通过
<span class="hljs-bullet">-</span> REFACTOR: 重构优化代码
</code></pre>
<p><strong>rules/security.md</strong>：安全底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 安全规范</span>

<span class="hljs-section">## 敏感信息处理</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 将密钥/密码硬编码到代码中
<span class="hljs-bullet">-</span> ✅ 使用: 环境变量 + .env 文件

<span class="hljs-section">## 输入验证</span>
<span class="hljs-bullet">-</span> 所有用户输入必须验证和净化
<span class="hljs-bullet">-</span> 使用 Zod / Yup 进行 schema 验证

<span class="hljs-section">## XSS 防护</span>
<span class="hljs-bullet">-</span> 使用 React 的自动转义
<span class="hljs-bullet">-</span> 避免 <span class="hljs-code">`dangerouslySetInnerHTML`</span>
</code></pre>
<hr/>
<h2 data-id="heading-12">四、复利模式:持续优化的团队宪法</h2>
<h3 data-id="heading-13">4.1 什么是复利模式?</h3>
<p><strong>传统模式</strong>:写一次规范,长期不更新,最终过时无用。</p>
<p><strong>复利模式</strong>:发现问题 → 更新宪法 → 全员受益 → 持续改进。</p>
<p><strong>类比</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile">复利模式就像投资理财
  - 初始投入: 编写基础宪法
  - 持续投入: 每次遇到问题就更新
  - 复利收益: 团队整体能力提升,问题逐渐减少

<span class="hljs-section">第1周: 发现 10 个规范问题</span>
<span class="hljs-section">第2周: 发现 7 个问题(之前的 3 个不再出现)</span>
<span class="hljs-section">第3周: 发现 5 个问题</span>
...
<span class="hljs-section">第N周: 发现 0-1 个问题(规范已经很完善)</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d3c9f67e9b54467b0bc2556b72ea92b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=Mn4egti7cGFr7Z2ByB2%2BOkhip9k%3D" alt="03-04-compound-mode.png" loading="lazy"/></p>
<p><em>图4: 复利模式的循环流程,展示持续优化如何带来复利收益</em></p>
<h3 data-id="heading-14">4.2 复利模式的工作流程</h3>
<p><strong>步骤 1: 发现问题</strong></p>
<p>在 Code Review、Bug 修复、性能优化等场景中发现规范缺失或不明确的地方。</p>
<p><strong>示例场景</strong>:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Code Review 发现的问题</span>
<span class="hljs-comment">// 开发者 A 的代码:</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-comment">// 复杂的业务逻辑,没有注释</span>
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span> * <span class="hljs-number">1.1</span> + (item.<span class="hljs-property">bonus</span> ?? <span class="hljs-number">0</span>) - item.<span class="hljs-property">discount</span>;
  });
}

<span class="hljs-comment">// 评审者: "这个计算逻辑是什么意思?为什么乘 1.1?"</span>
<span class="hljs-comment">// 开发者: "哦,这是加上 10% 的税费"</span>
<span class="hljs-comment">// 评审者: "这种业务逻辑应该加注释啊"</span>
</code></pre>
<p><strong>步骤 2: 分析根因</strong></p>
<p>思考:为什么会出现这个问题?是规范缺失还是规范不够明确?</p>
<pre><code class="hljs language-markdown" lang="markdown">根因分析:
<span class="hljs-bullet">  -</span> rules/ 目录中没有规定"复杂业务逻辑必须添加注释"
<span class="hljs-bullet">  -</span> 开发者和 AI 都不知道这个规范
<span class="hljs-bullet">  -</span> 导致每次都要在 Code Review 中提醒
</code></pre>
<p><strong>步骤 3: 更新宪法</strong></p>
<p>在 rules/ 目录下的相应规则文件中添加或修改规范,明确要求。</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># rules/coding-style.md</span>

<span class="hljs-section">## 注释要求</span>

<span class="hljs-section">### 业务逻辑注释</span>
<span class="hljs-bullet">-</span> ✅ 必须: 所有包含数字常量的计算逻辑必须注释说明含义
<span class="hljs-bullet">-</span> ✅ 必须: 复杂的业务规则必须注释说明原因

<span class="hljs-section">### 示例:</span>
\<span class="hljs-code">`\`</span>\`typescript
// ✅ 正确
function calculateTotalPrice(item: Item): number {
  // 基础价格 + 10% 增值税
  const priceWithTax = item.value * 1.1;

  // 加上奖励积分(如有),减去折扣
  return priceWithTax + (item.bonus ?? 0) - item.discount;
}

// ❌ 错误: 缺少注释
function calculateTotalPrice(item: Item): number {
  return item.value * 1.1 + (item.bonus ?? 0) - item.discount;
}
\<span class="hljs-code">`\`</span>\`
</code></pre>
<p><strong>注意</strong>：规则应该放在 rules/ 目录下，而不是 CLAUDE.md 中。CLAUDE.md 只存放项目事实。</p>
<p><strong>步骤 4: 提交与同步</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 更新规则文件</span>
git add .claude/rules/coding-style.md
git commit -m <span class="hljs-string">"docs(claude): add business logic comment requirement"</span>

<span class="hljs-comment"># 2. 推送到远程仓库</span>
git push origin main

<span class="hljs-comment"># 3. 团队成员拉取最新代码</span>
<span class="hljs-comment"># 下次使用 Claude Code 时自动生效</span>
</code></pre>
<p><strong>步骤 5: 全员受益</strong></p>
<p>所有团队成员(包括 AI)都自动遵守新规范,类似问题不再出现。</p>
<pre><code class="hljs language-less" lang="less">效果:
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">A</span>: 下次写代码时,<span class="hljs-selector-tag">Claude</span> <span class="hljs-selector-tag">Code</span> 自动添加注释
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">B</span>: 第一次接触这个规范,<span class="hljs-selector-tag">AI</span> 生成的代码已经符合
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">C</span>: 维护老代码时,<span class="hljs-selector-tag">AI</span> 重构时自动加上注释

结果: 团队整体代码质量提升,<span class="hljs-selector-tag">Code</span> <span class="hljs-selector-tag">Review</span> 效率提高
</code></pre>
<h3 data-id="heading-15">4.3 真实案例:从代码缺陷到宪法条款</h3>
<p><strong>背景</strong>:</p>
<p>某 Android 项目在生产环境出现内存泄漏,排查后发现是因为 Activity 中的匿名内部类持有了外部引用。</p>
<p><strong>问题代码</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MainActivity.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: String = <span class="hljs-string">""</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)

        <span class="hljs-comment">// ❌ 问题: 匿名内部类持有 Activity 引用</span>
        button.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>?)</span></span> {
                <span class="hljs-comment">// 使用了外部类的成员变量</span>
                processData(<span class="hljs-keyword">data</span>)
            }
        })
    }
}
</code></pre>
<p><strong>根因分析</strong>:</p>
<ol>
<li>匿名内部类隐式持有外部类引用</li>
<li>如果 listener 的生命周期超过 Activity,会导致内存泄漏</li>
<li>团队之前没有明确的规范来避免这个问题</li>
</ol>
<p><strong>解决方案</strong>:</p>
<p>更新 rules/security.md,添加 Android 内存泄漏防护规范:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># rules/security.md</span>

<span class="hljs-section">## Android 内存泄漏防护</span>

<span class="hljs-section">#### 避免匿名内部类持有 Activity 引用</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 在 Activity/Fragment 中使用匿名内部类作为长生命周期监听器
<span class="hljs-bullet">-</span> ✅ 使用: Lambda 表达式或静态内部类 + 弱引用

\<span class="hljs-code">`\`</span>\`kotlin
// ❌ 错误: 匿名内部类
button.setOnClickListener(object : View.OnClickListener {
<span class="hljs-code">    override fun onClick(v: View?) {
        processData(data)  // 持有外部引用
    }
})
</span>
// ✅ 正确: Lambda 表达式
button.setOnClickListener { view -&gt;
<span class="hljs-code">    processData(data)  // Kotlin 编译器优化,不会泄漏
}
</span>
// ✅ 正确: 静态内部类 + 弱引用
class MainActivity : AppCompatActivity() {
<span class="hljs-code">    private val clickListener = ClickListener(this)
</span>
<span class="hljs-code">    override fun onCreate(savedInstanceState: Bundle?) {
        button.setOnClickListener(clickListener)
    }
</span>
<span class="hljs-code">    private class ClickListener(activity: MainActivity) : View.OnClickListener {
        private val activityRef = WeakReference(activity)
</span>
<span class="hljs-code">        override fun onClick(v: View?) {
            activityRef.get()?.processData()
        }
    }
}
\`\`\`
</span>
<span class="hljs-section">#### Handler 使用规范</span>
<span class="hljs-bullet">-</span> 使用静态 Handler + 弱引用
<span class="hljs-bullet">-</span> 在 onDestroy 中移除所有消息

\<span class="hljs-code">`\`</span>\`kotlin
// ✅ 正确
class MainActivity : AppCompatActivity() {
<span class="hljs-code">    private val handler = MyHandler(this)
</span>
<span class="hljs-code">    override fun onDestroy() {
        super.onDestroy()
        handler.removeCallbacksAndMessages(null)
    }
</span>
<span class="hljs-code">    private class MyHandler(activity: MainActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
</span>
<span class="hljs-code">        override fun handleMessage(msg: Message) {
            activityRef.get()?.handleMessage(msg)
        }
    }
}
\`\`\`
</span></code></pre>
<p><strong>效果</strong>:</p>
<ol>
<li><strong>immediate(立即生效)</strong>: 下次使用 Claude Code 生成代码时,自动符合新规范</li>
<li><strong>Prevention(预防问题)</strong>: 类似的内存泄漏问题不再出现</li>
<li><strong>Knowledge Transfer(知识传递)</strong>: 新入职的开发者通过 AI 生成的代码学习最佳实践</li>
</ol>
<p><strong>关键点</strong>：这个规范应该放在 <code>rules/security.md</code> 中，而不是 <code>CLAUDE.md</code>。CLAUDE.md 只存放项目事实（如技术栈、常用命令），详细的规则约束都应该放在 rules/ 目录下。</p>
<h3 data-id="heading-16">4.4 版本管理:宪法的演进历史</h3>
<p><strong>为什么需要版本管理?</strong></p>
<ul>
<li>追溯规范变更的原因和时间</li>
<li>回滚不合理的规范修改</li>
<li>了解团队规范的演进路径</li>
</ul>
<p><strong>实践方法</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. CLAUDE.md 和 rules/ 与代码一起提交到 Git</span>
git add CLAUDE.md .claude/rules/
git commit -m <span class="hljs-string">"docs(claude): add memory leak prevention rules"</span>

<span class="hljs-comment"># 2. 查看宪法演进历史</span>
git <span class="hljs-built_in">log</span> --oneline -- CLAUDE.md .claude/rules/

<span class="hljs-comment"># 输出:</span>
a1b2c3d docs(claude): add memory leak prevention rules
d4e5f6g docs(claude): update naming conventions
g7h8i9j docs(claude): add security guidelines
j0k1l2m docs(claude): initial team constitution

<span class="hljs-comment"># 3. 查看某次修改的具体内容</span>
git show a1b2c3d

<span class="hljs-comment"># 4. 回滚到之前的版本(如果需要)</span>
git checkout d4e5f6g -- CLAUDE.md .claude/rules/
</code></pre>
<p><strong>版本号管理(可选)</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Team Constitution</span>

<span class="hljs-strong">**Version**</span>: 2.3.0
<span class="hljs-strong">**Last Updated**</span>: 2026-01-29
<span class="hljs-strong">**Changelog**</span>: See CLAUDE<span class="hljs-emphasis">_CHANGELOG.md

## Version History
- v2.3.0 (2026-01-29): Add Android memory leak prevention
- v2.2.0 (2026-01-15): Update testing requirements
- v2.1.0 (2026-01-05): Add security guidelines
- v2.0.0 (2025-12-20): Major refactor, adopt Clean Architecture
- v1.0.0 (2025-12-01): Initial team constitution
</span></code></pre>
<h3 data-id="heading-17">4.5 团队协作:宪法的共同维护</h3>
<p><strong>维护策略</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 团队宪法维护指南</span>

<span class="hljs-section">### 谁可以修改?</span>
<span class="hljs-bullet">-</span> 所有团队成员都可以提出修改建议
<span class="hljs-bullet">-</span> Tech Lead 负责最终审核

<span class="hljs-section">### 修改流程</span>
<span class="hljs-bullet">1.</span> 发现问题或改进点
<span class="hljs-bullet">2.</span> 创建 Issue 讨论必要性
<span class="hljs-bullet">3.</span> 提交 PR 修改 CLAUDE.md 或 .claude/rules/ 下的规则文件
<span class="hljs-bullet">4.</span> Tech Lead 审核
<span class="hljs-bullet">5.</span> 合并后全员通知

<span class="hljs-section">### 定期回顾</span>
<span class="hljs-bullet">-</span> 每月: 团队会议回顾宪法执行情况
<span class="hljs-bullet">-</span> 每季度: 全面审查和优化
</code></pre>
<p><strong>沟通机制</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 示例: PR 提交说明</span>

<span class="hljs-section">## 为什么需要这个修改?</span>
在最近的 Code Review 中,我们发现多个 PR 都出现了日期格式不统一的问题:
<span class="hljs-bullet">-</span> 有的用 <span class="hljs-code">`YYYY-MM-DD`</span>
<span class="hljs-bullet">-</span> 有的用 <span class="hljs-code">`MM/DD/YYYY`</span>
<span class="hljs-bullet">-</span> 有的用时间戳

这导致前后端对接时经常出错。

<span class="hljs-section">## 提议的规范</span>
统一使用 ISO 8601 格式(<span class="hljs-code">`YYYY-MM-DDTHH:mm:ssZ`</span>)

<span class="hljs-section">## 影响范围</span>
<span class="hljs-bullet">-</span> 前端展示日期时需要格式化
<span class="hljs-bullet">-</span> 后端 API 返回统一格式
<span class="hljs-bullet">-</span> 数据库存储使用 UTC 时间

<span class="hljs-section">## 相关讨论</span>
Issue #123: Date format inconsistency
</code></pre>
<hr/>
<h2 data-id="heading-18">五、实战案例:构建 Android 团队的团队宪法</h2>
<h3 data-id="heading-19">5.1 目录结构</h3>
<pre><code class="hljs language-text" lang="text">android-project/
├─ CLAUDE.md
└─ .claude/
   └─ rules/
      ├─ security.md
      ├─ testing.md
      └─ coding-style.md
</code></pre>
<h3 data-id="heading-20">5.2 CLAUDE.md：项目事实</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Android Project - Claude Code Configuration</span>

<span class="hljs-section">## 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：Kotlin 1.9+、Android 14 (API 34)、MVVM + Clean Architecture
<span class="hljs-bullet">-</span> DI：Hilt
<span class="hljs-bullet">-</span> Async：Coroutines + Flow
<span class="hljs-bullet">-</span> UI：Jetpack Compose
<span class="hljs-bullet">-</span> Testing：JUnit5, Mockk, Espresso

<span class="hljs-section">## 目录结构入口</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/main/java/`</span> - 源代码目录
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/test/java/`</span> - 单元测试目录
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/androidTest/java/`</span> - UI 测试目录

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`./gradlew build`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`./gradlew test`</span>
<span class="hljs-bullet">-</span> 运行 UI 测试：<span class="hljs-code">`./gradlew connectedAndroidTest`</span>
<span class="hljs-bullet">-</span> 构建 APK：<span class="hljs-code">`./gradlew assembleDebug`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`./gradlew ktlintFormat`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`./gradlew ktlintCheck`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
<span class="hljs-bullet">-</span> ViewModel 不持有 Activity/Fragment 引用
<span class="hljs-bullet">-</span> 网络/数据库操作必须使用 suspend 函数
</code></pre>
<h3 data-id="heading-21">5.3 rules/coding-style.md：代码风格底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Kotlin 代码风格规范</span>

<span class="hljs-section">## 命名约定</span>
<span class="hljs-bullet">-</span> 类/接口: PascalCase (UserRepository)
<span class="hljs-bullet">-</span> 函数/属性: camelCase (getUserById)
<span class="hljs-bullet">-</span> 常量: UPPER<span class="hljs-emphasis">_SNAKE_</span>CASE (MAX<span class="hljs-emphasis">_RETRY_</span>COUNT)
<span class="hljs-bullet">-</span> 包名: 小写,单词间用点分隔 (com.example.app)

<span class="hljs-section">## 属性声明</span>
<span class="hljs-bullet">-</span> 优先使用 <span class="hljs-code">`val`</span> 而不是 <span class="hljs-code">`var`</span>
<span class="hljs-bullet">-</span> 私有属性使用 <span class="hljs-code">`private`</span> 显式标记
<span class="hljs-bullet">-</span> 可空类型明确标注 <span class="hljs-code">`?`</span>

<span class="hljs-section">## 异步编程</span>
<span class="hljs-bullet">-</span> 使用 Coroutines,避免 Callback
<span class="hljs-bullet">-</span> 网络/数据库操作使用 <span class="hljs-code">`suspend`</span> 函数
<span class="hljs-bullet">-</span> UI 层使用 <span class="hljs-code">`StateFlow`</span> / <span class="hljs-code">`SharedFlow`</span>

<span class="hljs-section">## 资源命名</span>
<span class="hljs-bullet">-</span> Drawable: <span class="hljs-code">`ic_*`</span> (图标), <span class="hljs-code">`bg_*`</span> (背景), <span class="hljs-code">`img_*`</span> (图片)
<span class="hljs-bullet">-</span> Layout: <span class="hljs-code">`activity_*.xml`</span>, <span class="hljs-code">`fragment_*.xml`</span>, <span class="hljs-code">`item_*.xml`</span>
<span class="hljs-bullet">-</span> String: 模块<span class="hljs-emphasis">_功能_</span>描述 (<span class="hljs-code">`user_profile_title`</span>)
</code></pre>
<h3 data-id="heading-22">5.4 rules/testing.md：测试底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 测试规范</span>

<span class="hljs-section">## 单元测试</span>
<span class="hljs-bullet">-</span> 覆盖率: &gt; 80%
<span class="hljs-bullet">-</span> UseCase 和 Repository 必须有单元测试
<span class="hljs-bullet">-</span> 使用 Mockk 进行 Mock
<span class="hljs-bullet">-</span> 测试用例命名: <span class="hljs-code">`should ... when ...`</span>

<span class="hljs-section">## UI 测试</span>
<span class="hljs-bullet">-</span> 关键流程必须有 Espresso 测试
<span class="hljs-bullet">-</span> 使用 Hilt Test 进行依赖注入

<span class="hljs-section">## TDD 流程</span>
<span class="hljs-bullet">-</span> RED: 先写失败的测试
<span class="hljs-bullet">-</span> GREEN: 实现最小代码让测试通过
<span class="hljs-bullet">-</span> REFACTOR: 重构优化代码
</code></pre>
<h3 data-id="heading-23">5.5 rules/security.md：安全底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 安全规范</span>

<span class="hljs-section">## 敏感信息处理</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 将密钥/密码硬编码到代码中
<span class="hljs-bullet">-</span> ✅ 使用: BuildConfig 或 NDK 存储 API Key
<span class="hljs-bullet">-</span> ✅ 使用: EncryptedSharedPreferences 存储用户密码/Token

<span class="hljs-section">## 内存泄漏防护</span>
<span class="hljs-bullet">-</span> ViewModel 不持有 Activity/Fragment 引用
<span class="hljs-bullet">-</span> 长生命周期对象使用 ApplicationContext
<span class="hljs-bullet">-</span> 使用 Lifecycle-aware 组件

<span class="hljs-section">## 权限请求</span>
<span class="hljs-bullet">-</span> 使用 ActivityResultContracts
<span class="hljs-bullet">-</span> 说明权限用途,提升授权率
</code></pre>
<hr/>
<h2 data-id="heading-24">六、最佳实践与建议</h2>
<h3 data-id="heading-25">6.1 如何编写有效的宪法条款</h3>
<p><strong>原则 1: 具体而非抽象</strong></p>
<p>❌ 不好的例子:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">-</span> 代码应该写得清晰
<span class="hljs-bullet">-</span> 注释要写好
<span class="hljs-bullet">-</span> 性能要优化
</code></pre>
<p>✅ 好的例子:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">-</span> 所有公共 API 必须添加 JSDoc 注释,包含参数说明和示例
<span class="hljs-bullet">-</span> 函数复杂度不超过 15(Cyclomatic Complexity)
<span class="hljs-bullet">-</span> API 响应时间 P95 &lt; 200ms
</code></pre>
<p><strong>原则 2: 提供正反示例</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 错误处理</span>

✅ 正确:
\<span class="hljs-code">`\`</span>\`typescript
try {
  const data = await fetchData();
  return data;
} catch (error: unknown) {
  if (error instanceof NetworkError) {
<span class="hljs-code">    logger.error('Network request failed', { error });
    throw new ServiceUnavailableError('Service temporarily unavailable');
  }
  throw error;
}
\`\`\`
</span>
❌ 错误:
\<span class="hljs-code">`\`</span>\`typescript
try {
  const data = await fetchData();
  return data;
} catch (e) {
  console.log(e);  // 只打印日志,不处理
  return null;     // 吞掉异常
}
\<span class="hljs-code">`\`</span>\`
</code></pre>
<p><strong>原则 3: 说明"为什么"</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 优先使用 `const` 而不是 `let`</span>

<span class="hljs-strong">**原因**</span>:
<span class="hljs-bullet">-</span> 提高代码可读性:变量不可变更,减少认知负担
<span class="hljs-bullet">-</span> 避免意外修改:防止 bug
<span class="hljs-bullet">-</span> 优化性能:编译器可以更好地优化

<span class="hljs-strong">**例外情况**</span>:
<span class="hljs-bullet">-</span> 循环计数器
<span class="hljs-bullet">-</span> 累加器变量
</code></pre>
<p><strong>原则 4: 设置优先级</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 编码规范优先级</span>

<span class="hljs-section">### P0 (必须遵守,否则拒绝合并)</span>
<span class="hljs-bullet">-</span> 所有敏感信息不得硬编码
<span class="hljs-bullet">-</span> 必须通过单元测试
<span class="hljs-bullet">-</span> 不得出现 ESLint error

<span class="hljs-section">### P1 (强烈建议,Code Review 会提出)</span>
<span class="hljs-bullet">-</span> 公共 API 必须有 JSDoc
<span class="hljs-bullet">-</span> 复杂逻辑必须有注释
<span class="hljs-bullet">-</span> 测试覆盖率 &gt; 80%

<span class="hljs-section">### P2 (建议,但不强制)</span>
<span class="hljs-bullet">-</span> 使用 TypeScript 类型推断简化代码
<span class="hljs-bullet">-</span> 优先使用函数式编程
</code></pre>
<h3 data-id="heading-26">6.2 如何让 AI 理解和遵守规范</h3>
<p><strong>技巧 1: 使用清晰的标记</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 规范标记说明</span>

<span class="hljs-bullet">-</span> ✅ <span class="hljs-strong">**必须**</span>: 强制执行,不可违反
<span class="hljs-bullet">-</span> ⚠️ <span class="hljs-strong">**推荐**</span>: 强烈建议,有特殊原因可例外
<span class="hljs-bullet">-</span> 💡 <span class="hljs-strong">**建议**</span>: 最佳实践,可根据情况调整
<span class="hljs-bullet">-</span> ❌ <span class="hljs-strong">**禁止**</span>: 绝对不允许
</code></pre>
<p><strong>技巧 2: 结构化组织</strong></p>
<p>按照官方推荐的目录结构组织：</p>
<pre><code class="hljs language-text" lang="text">your-repo/
├─ CLAUDE.md              # 项目事实
└─ .claude/
   └─ rules/              # 底线规则
      ├─ security.md
      ├─ testing.md
      └─ coding-style.md
</code></pre>
<p>每个文件职责单一，便于维护和审查。</p>
<p><strong>技巧 3: 使用关键词强调</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 安全规范</span>

⚠️ <span class="hljs-strong">**CRITICAL**</span>: 绝对不允许将密钥硬编码到代码中

❌ <span class="hljs-strong">**NEVER**</span> do this:
\<span class="hljs-code">`\`</span>\`typescript
const API<span class="hljs-emphasis">_KEY = 'sk-1234567890abcdef';
\`\`\`

✅ <span class="hljs-strong">**ALWAYS**</span> use environment variables:
\`\`\`typescript
const API_</span>KEY = process.env.API<span class="hljs-emphasis">_KEY;
\`\`\`
</span></code></pre>
<p><strong>技巧 4: 提供决策树</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 何时使用缓存?</span>

\<span class="hljs-code">`\`</span>\`
数据是否频繁读取?
  ├─ 是 → 数据是否经常变化?
  │       ├─ 是 → 使用短 TTL 缓存(5分钟)
  │       └─ 否 → 使用长 TTL 缓存(1小时)
  └─ 否 → 不使用缓存,直接查询
\<span class="hljs-code">`\`</span>\`
</code></pre>
<h3 data-id="heading-27">6.3 团队推广策略</h3>
<p><strong>阶段 1: 试点项目(第1周)</strong></p>
<ol>
<li>选择一个小型项目作为试点</li>
<li>编写基础的 CLAUDE.md（项目事实）和 rules/ 目录（核心规范）</li>
<li>团队成员轮流使用 Claude Code</li>
<li>收集反馈,快速迭代</li>
</ol>
<p><strong>阶段 2: 规范完善(第2-4周)</strong></p>
<ol>
<li>根据实际使用发现的问题更新规范</li>
<li>添加更多示例和说明</li>
<li>组织团队培训,讲解规范的价值</li>
<li>建立规范更新机制</li>
</ol>
<p><strong>阶段 3: 全面推广(第5-8周)</strong></p>
<ol>
<li>在所有项目中启用 claude.md</li>
<li>将 claude.md 检查加入 CI/CD 流程</li>
<li>定期回顾和优化规范</li>
<li>分享成功案例和数据</li>
</ol>
<p><strong>阶段 4: 持续改进(长期)</strong></p>
<ol>
<li>建立复利模式:发现问题 → 更新宪法</li>
<li>跟踪指标:代码质量、Code Review 时间、Bug 数量</li>
<li>定期团队分享:最佳实践、踩坑经验</li>
<li>版本管理:重大更新时升级版本号</li>
</ol>
<p><strong>推广技巧</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 让团队接受 claude.md 的技巧</span>

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**展示收益,不是约束**</span>
<span class="hljs-bullet">   -</span> "这能让 Code Review 时间减少 50%"
<span class="hljs-bullet">   -</span> "新人上手速度提升 3 倍"
<span class="hljs-bullet">   -</span> "Bug 数量下降 40%"

<span class="hljs-bullet">2.</span> <span class="hljs-strong">**从痛点出发**</span>
<span class="hljs-bullet">   -</span> "还记得上周那个低级 Bug 吗?如果有规范就能避免"
<span class="hljs-bullet">   -</span> "每次 Code Review 都在说同样的问题,累不累?"

<span class="hljs-bullet">3.</span> <span class="hljs-strong">**小步快跑**</span>
<span class="hljs-bullet">   -</span> 不要一次性写 100 条规范
<span class="hljs-bullet">   -</span> 从 3-5 条核心规范开始（放在 rules/ 目录）
<span class="hljs-bullet">   -</span> 逐步完善,让团队适应

<span class="hljs-bullet">4.</span> <span class="hljs-strong">**让大家参与**</span>
<span class="hljs-bullet">   -</span> 规范不是 Tech Lead 一个人定的
<span class="hljs-bullet">   -</span> 鼓励所有人提出改进建议
<span class="hljs-bullet">   -</span> 定期讨论和投票决定重要条款
</code></pre>
<hr/>
<h2 data-id="heading-28">七、总结与行动指南</h2>
<h3 data-id="heading-29">7.1 核心要点回顾</h3>
<p>通过本文,我们深入探讨了 claude.md 作为"团队宪法"的价值:</p>
<p><strong>1. 为什么需要团队宪法?</strong></p>
<ul>
<li>传统规范靠人肉执行,效率低、易遗漏</li>
<li>AI 辅助开发需要明确规范,否则代码质量参差不齐</li>
<li>claude.md 是自动化、统一、可演进的解决方案</li>
</ul>
<p><strong>2. claude.md 的工作机制</strong></p>
<ul>
<li>两级配置:全局 + 项目,项目配置覆盖全局配置</li>
<li>作为系统提示词注入到每次 AI 调用,优先级高于对话历史</li>
</ul>
<p><strong>3. 团队宪法的内容设计</strong></p>
<ul>
<li>CLAUDE.md：项目事实（技术栈、常用命令、约束）</li>
<li>rules/ 目录：底线规则（security.md、testing.md、coding-style.md）</li>
</ul>
<p><strong>4. 复利模式:持续演进</strong></p>
<ul>
<li>发现问题 → 更新宪法 → 全员受益</li>
<li>版本管理:Git 跟踪规范演进</li>
<li>团队协作:共同维护,定期回顾</li>
</ul>
<p><strong>5. 实战案例:Android 团队</strong></p>
<ul>
<li>完整的 CLAUDE.md 和 rules/ 目录示例</li>
<li>职责分离：CLAUDE.md 存项目事实，rules/ 存规则约束</li>
<li>数据证明:Code Review 时间减少 80%</li>
</ul>
<hr/>
<blockquote>
<p>💡 <strong>思考题</strong>: 你的团队目前有哪些规范执行不到位的问题?如果用 CLAUDE.md 和rule来解决,你会先写哪 3 条规范?</p>
</blockquote>
<p>🔗 <strong>相关文章</strong>:</p>
<ul>
<li><a href="https://juejin.cn/post/7601034810313080886" target="_blank" title="https://juejin.cn/post/7601034810313080886">上一篇: 深入理解 Claude Code</a></li>
</ul>
<hr/>
<p>📥 <strong>下载资源</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchendongqi%2Fawesome-ai-coding%2Ftree%2Fmain%2Frules" target="_blank" title="https://github.com/chendongqi/awesome-ai-coding/tree/main/rules" ref="nofollow noopener noreferrer">Awesome AI Coding</a> - 覆盖大部分开发领域的规则集合</li>
</ul>
<p><em>如果这篇文章对你有帮助,欢迎点赞、收藏、分享!有任何问题或建议,欢迎在评论区留言讨论。让我们一起学习,一起成长!</em></p>
<p><em>也欢迎访问我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>发现更多宝藏资源</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[微服务管理 | 服务注册与发现]]></title>    <link>https://juejin.cn/post/7602401081265979428</link>    <guid>https://juejin.cn/post/7602401081265979428</guid>    <pubDate>2026-02-03T12:41:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265979428" data-draft-id="7602411521071251475" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="微服务管理 | 服务注册与发现"/> <meta itemprop="keywords" content="微服务,后端"/> <meta itemprop="datePublished" content="2026-02-03T12:41:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码财同行"/> <meta itemprop="url" content="https://juejin.cn/user/3883950915978728"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            微服务管理 | 服务注册与发现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3883950915978728/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码财同行
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:41:56.000Z" title="Tue Feb 03 2026 12:41:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一句话</h2>
<p><strong>分布式系统中，服务往往是独立运行的，他们之间如何交流也是有很多可以挖掘的点。让服务之间自动“找到彼此”，并建立连接，且在服务增删变化时，连接关系能自动调整，这就是服务注册和发现要做的事情</strong>。</p>
<h2 data-id="heading-1">为什么需要服务发现</h2>
<p><strong>例子 1：网关找登录服</strong></p>
<ul>
<li>登录服可能多台，地址也可能变。</li>
<li>如果靠配置文件写死，运维一改地址就会出错。</li>
<li>服务发现就像“自动通讯录”，登录服上线就自动加入，掉线就自动移除。</li>
</ul>
<h2 data-id="heading-2">服务发现要做到什么</h2>
<p>简单理解就是三件事：</p>
<ol>
<li><strong>注册</strong>：服务实例将自身节点信息写入注册中心（例如 Zookeeper），也就是服务自己把“我是谁、我的网络地址是什么” 写进去</li>
<li><strong>发现</strong>：订阅并获取自己关心的服务节点，即能拿到“我发现了哪些服务以及需要连接哪些服务”</li>
<li><strong>更新</strong>：服务变化时自动通知，变更不仅有“来/走”，还有“节点属性更新”（比如权重/版本变化）</li>
</ol>
<p><strong>通俗地说，对于一个服务：</strong></p>
<ul>
<li><strong>启动时先给我一张其他服务的完整名单</strong>（快照）</li>
<li><strong>运行中有服务加入或离开就通知我</strong>（增量订阅）</li>
</ul>
<p>这里其实有一个数据的一致性需求 ：启动时需要“全量快照”，运行时需要“增量变更”，避免漏连或重复。</p>
<h2 data-id="heading-3">实现方案</h2>
<h3 data-id="heading-4">1) 注册：服务自己告诉系统“我是谁”，我的地址是多少</h3>
<p>每个服务启动后把信息写进注册中心，通常就是 key-value 的形式，比如：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">login.tcp.3</span> =&gt; <span class="hljs-number">10.1</span>.<span class="hljs-number">2.3</span>:<span class="hljs-number">8001</span>
</code></pre>
<p>这里，<code>login</code> 是服务类型，<code>tcp</code> 是地址的类型（也可以是http），<code>3</code> 是服务的编号，这对于有状态服务的区分比较重要。</p>
<p>如果要更多信息，也可以带上权重、版本、元数据：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-number">10.1</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>|<span class="hljs-number">8001</span>|<span class="hljs-number">20</span>|v1|<span class="hljs-punctuation">{</span><span class="hljs-attr">"region"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"cn"</span><span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-5">2) 发现：获得别的服务的地址，关注地址变更</h3>
<p>服务启动后订阅自己关心的目标，例如：</p>
<ul>
<li>Gate 关心 Login、Router</li>
<li>Game 关心 Battle、Router</li>
</ul>
<p>当 Gate 启动时，需要先拿到 <strong>全量快照</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">snapshot</span> = [login-<span class="hljs-number">1</span>, login-<span class="hljs-number">2</span>, login-<span class="hljs-number">3</span>, router-<span class="hljs-number">1</span>, router-<span class="hljs-number">2</span>]
</code></pre>
<p>这些服务的地址如果发生了变更，如权重从 20 变成 0，就需要关注。</p>
<h3 data-id="heading-6">3) 增量：有变化就通知</h3>
<p>如果登录服新增了一台：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">新增: login-tcp-4</span>
</code></pre>
<p>订阅者收到事件后，只需要做一件事：  <code>建立和 login-tcp-4 的连接</code></p>
<p>如果 login-tcp-2 下线：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">删除: login-2</span>
</code></pre>
<p>订阅者自动断开即可。</p>
<h2 data-id="heading-7">简化流程图（Mermaid）</h2>
<p>我们把上面的几个过程串联起来，得到一个流程图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3db1a2589d64661992088e01df545dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB6LSi5ZCM6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770727319&amp;x-signature=nvNalqcuK%2Fd4JNIwYf%2FFW3mi8hw%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">更深入的点</h2>
<ol>
<li>在现代 kubernetes 云部署盛行的当下，服务注册和发现往往已经支持，但是如果需要自己来更细粒度更深度的定制和控制路由，自己实现一套服务注册和发现是很有必要的；</li>
<li>如果是 kubernetes 部署，服务注册的地址一般是 DNS 域名，因为服务本身的地址是会动态变化的；</li>
<li>在很多异构的系统中，往往由不同的语言来实现不同的服务，为了避免实现多套服务注册和发现，增加维护成本，可以将其抽象成agent 服务（以sidecar的形式部署），使用方用 gRPC 这种解耦的协议形式，和 agent 通信。</li>
</ol>
<h2 data-id="heading-9">总结</h2>
<ul>
<li>服务注册和发现做的是一套“自动通讯录 + 实时变更提醒”</li>
<li>快照解决“启动时看到全量”</li>
<li>增量解决“运行中看到变化”</li>
<li>可以挖掘更适合k8s及异构系统的实现方式</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-响应式原理深度解析（含手写源码）]]></title>    <link>https://juejin.cn/post/7602463463105249326</link>    <guid>https://juejin.cn/post/7602463463105249326</guid>    <pubDate>2026-02-03T10:07:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602463463105249326" data-draft-id="7602303923171393545" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-响应式原理深度解析（含手写源码）"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:07:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-响应式原理深度解析（含手写源码）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:34.000Z" title="Tue Feb 03 2026 10:07:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>双向数据绑定是 Vue 的灵魂特性。它将 <strong>Model（数据层）</strong> 与 <strong>View（视图层）</strong> 紧密相连：JS 逻辑更新 Model，视图自动重绘；用户操作 View，数据自动同步。本文将带你从源码级别对比 Vue 2 与 Vue 3 在响应式实现上的异同。</p>
<h2 data-id="heading-1">一、 Vue 2：数据劫持 + 发布订阅</h2>
<h3 data-id="heading-2">1. 核心原理</h3>
<p>Vue 2 基于 <code>Object.defineProperty</code> 实现数据劫持，通过 <strong>Observer（监听器）</strong> 、<strong>Compile（解析器）</strong> 和 <strong>Watcher（订阅者）</strong> 的配合完成。</p>
<h3 data-id="heading-3">2. 关键步骤</h3>
<ol>
<li>
<p><strong>数据劫持 (Observer)</strong> ：遍历 <code>data</code> 属性，利用 <code>Object.defineProperty</code> 注入 <code>getter</code>（依赖收集）和 <code>setter</code>（分发更新）。</p>
</li>
<li>
<p><strong>模板解析 (Compile)</strong> ：解析指令（如 <code>v-model</code>）和插值表达式（<code>{{}}</code>），为每个绑定点创建一个 <strong>Watcher</strong>。</p>
</li>
<li>
<p><strong>依赖收集 (Dep)</strong> ：每个属性对应一个 <code>Dep</code> 容器。读取属性时，将对应的 Watcher 存入 Dep。</p>
</li>
<li>
<p><strong>派发更新 (Watcher)</strong> ：修改数据时会触发 <code>setter</code>，通知所有关联的 Watcher 执行 <code>update</code> 方法更新 DOM。</p>
</li>
</ol>
<h3 data-id="heading-4">3. 源码仿真实现</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue2 响应式原理简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"vm.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖收集器 Dep：管理所有 Watcher，数据变化时通知更新 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 存储订阅者（Watcher 实例）</span>
      }

      <span class="hljs-comment">// 添加订阅者</span>
      <span class="hljs-title function_">addSub</span>(<span class="hljs-params">sub</span>) {
        <span class="hljs-keyword">if</span> (sub &amp;&amp; sub.<span class="hljs-property">update</span>) { <span class="hljs-comment">// 确保是合法的 Watcher</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub);
        }
      }

      <span class="hljs-comment">// 通知所有订阅者更新</span>
      <span class="hljs-title function_">notify</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub.<span class="hljs-title function_">update</span>());
      }
    }

    <span class="hljs-comment">//  2. 数据劫持器 Observer：劫持 data 所有属性的 get/set </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(data);
      }

      <span class="hljs-comment">// 遍历数据对象，劫持所有属性</span>
      <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 非对象直接返回</span>
        }

        <span class="hljs-comment">// 遍历对象的所有属性</span>
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">defineReactive</span>(data, key, data[key]);
        });
      }

      <span class="hljs-comment">// 核心：用 Object.defineProperty 劫持单个属性</span>
      <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) {
        <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 每个属性对应一个 Dep</span>
        <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 保存 Observer 实例的 this</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归劫持子属性（处理嵌套对象）</span>

        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可枚举</span>
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可配置</span>
          <span class="hljs-comment">// 读取属性时触发：收集依赖</span>
          <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// Dep.target 是当前正在执行的 Watcher，添加到 Dep 中</span>
            <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> &amp;&amp; dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);
            <span class="hljs-keyword">return</span> value;
          },
          <span class="hljs-comment">// 赋值属性时触发：通知更新</span>
          <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
            <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 值未变化则不处理</span>
            value = newValue;
            that.<span class="hljs-title function_">observe</span>(newValue); <span class="hljs-comment">// 使用保存的 that 调用 observe</span>
            dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知所有 Watcher 更新</span>
          }
        });
      }
    }

    <span class="hljs-comment">//  3. 订阅者 Watcher：连接 Observer 和 Compile，负责更新 DOM </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> {
      <span class="hljs-comment">/**
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">vm</span> - Vue 实例
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">expr</span> - data 中的属性名（如 'message'）
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">cb</span> - 更新 DOM 的回调函数
       */</span>
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expr, cb</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span> = expr;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOldValue</span>(); <span class="hljs-comment">// 记录旧值</span>
      }

      <span class="hljs-comment">// 获取旧值：触发 get 方法，完成依赖收集</span>
      <span class="hljs-title function_">getOldValue</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 将当前 Watcher 挂载到 Dep.target</span>
        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>); <span class="hljs-comment">// 读取属性，触发 get</span>
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 收集完依赖后清空</span>
        <span class="hljs-keyword">return</span> oldValue;
      }

      <span class="hljs-comment">// 解析属性路径（处理嵌套对象，如 'user.name'）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[currentKey];
        }, vm.<span class="hljs-property">$data</span>);
      }

      <span class="hljs-comment">// 数据变化时执行：更新 DOM</span>
      <span class="hljs-title function_">update</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> newValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>);
        <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(newValue); <span class="hljs-comment">// 执行回调更新 DOM</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = newValue; <span class="hljs-comment">// 更新旧值</span>
        }
      }
    }

    <span class="hljs-comment">//  4. 模板解析器 Compile：解析 v-model 和 {{}}，创建 Watcher </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, vm</span>) {
        <span class="hljs-comment">// 获取挂载元素（支持选择器或 DOM 元素）</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(el) ? el : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>) {
          <span class="hljs-comment">// 1. 将模板内容移到文档碎片中（减少 DOM 操作，提升性能）</span>
          <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">node2Fragment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);
          <span class="hljs-comment">// 2. 解析模板中的指令和插值表达式</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(fragment);
          <span class="hljs-comment">// 3. 将解析后的碎片放回原元素</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(fragment);
        }
      }

      <span class="hljs-comment">// 判断是否是元素节点（如 div、input）</span>
      <span class="hljs-title function_">isElementNode</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>;
      }

      <span class="hljs-comment">// 判断是否是指令（以 v- 开头）</span>
      <span class="hljs-title function_">isDirective</span>(<span class="hljs-params">attrName</span>) {
        <span class="hljs-keyword">return</span> attrName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'v-'</span>);
      }

      <span class="hljs-comment">// 将节点移到文档碎片</span>
      <span class="hljs-title function_">node2Fragment</span>(<span class="hljs-params">el</span>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> firstChild;
        <span class="hljs-keyword">while</span> (firstChild = el.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(firstChild); <span class="hljs-comment">// 移动节点（原节点会被移除）</span>
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心：解析文档碎片中的所有节点</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">fragment</span>) {
        <span class="hljs-keyword">const</span> childNodes = fragment.<span class="hljs-property">childNodes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(childNodes).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
          <span class="hljs-comment">// 1. 处理元素节点（解析 v-model 等指令）</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(node)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
          } 
          <span class="hljs-comment">// 2. 处理文本节点（解析 {{}} 插值）</span>
          <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
          }
          <span class="hljs-comment">// 递归解析子节点（处理嵌套模板）</span>
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span> &amp;&amp; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(node);
          }
        });
      }

      <span class="hljs-comment">// 解析元素节点（如 v-model）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> attrName = attr.<span class="hljs-property">name</span>;
          <span class="hljs-comment">// 判断是否是指令</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDirective</span>(attrName)) {
            <span class="hljs-keyword">const</span> expr = attr.<span class="hljs-property">value</span>; <span class="hljs-comment">// 指令对应的数据属性（如 'message'）</span>
            <span class="hljs-keyword">const</span> [, directive] = attrName.<span class="hljs-title function_">split</span>(<span class="hljs-string">'-'</span>); <span class="hljs-comment">// 提取指令名（如 'model'）</span>
            <span class="hljs-comment">// 执行指令对应的更新方法</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>[directive](node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, expr);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> textContent = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 正则匹配 {{xxx}} 格式</span>
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(textContent)) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>.<span class="hljs-title function_">text</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, textContent);
        }
      }

      <span class="hljs-comment">// 指令处理工具集</span>
      compileUtil = {
        <span class="hljs-comment">// 获取数据属性的值</span>
        <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 设置数据属性的值（用于 v-model）</span>
        <span class="hljs-title function_">setVal</span>(<span class="hljs-params">vm, expr, value</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey, index, arr</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> data[currentKey] = value;
            }
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 处理 v-model 指令</span>
        <span class="hljs-title function_">model</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">modelUpdater</span>;
          <span class="hljs-comment">// 1. 初始化：设置输入框默认值</span>
          <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, expr));
          <span class="hljs-comment">// 2. 创建 Watcher：数据变化时更新输入框</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
            <span class="hljs-title function_">updateFn</span>(node, newValue);
          });
          <span class="hljs-comment">// 3. 监听输入框事件：输入内容同步到 data</span>
          node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> newValue = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(vm, expr, newValue);
          });
        },

        <span class="hljs-comment">// 处理 {{}} 插值文本</span>
        <span class="hljs-title function_">text</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">textUpdater</span>;
          <span class="hljs-comment">// 替换 {{}} 为真实数据</span>
          <span class="hljs-keyword">const</span> content = expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> prop = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
            <span class="hljs-comment">// 创建 Watcher：数据变化时更新文本</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, prop, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
              <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getContentValue</span>(vm, expr));
            });
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, prop);
          });
          <span class="hljs-comment">// 初始化文本内容</span>
          <span class="hljs-title function_">updateFn</span>(node, content);
        },

        <span class="hljs-comment">// 获取插值文本的完整内容（处理多个 {{}} 情况）</span>
        <span class="hljs-title function_">getContentValue</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>());
          });
        },

        <span class="hljs-comment">// DOM 更新方法集</span>
        <span class="hljs-attr">updater</span>: {
          <span class="hljs-comment">// 更新 v-model 指令的 DOM（输入框值）</span>
          <span class="hljs-title function_">modelUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">value</span> = value;
          },
          <span class="hljs-comment">// 更新文本节点内容</span>
          <span class="hljs-title function_">textUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">textContent</span> = value;
          }
        }
      };
    }

    <span class="hljs-comment">//  5. Vue 核心类：整合所有模块 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = options.<span class="hljs-property">el</span>; <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = options.<span class="hljs-property">data</span>; <span class="hljs-comment">// 响应式数据</span>

        <span class="hljs-comment">// 1. 如果有挂载元素，初始化响应式</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>) {
          <span class="hljs-comment">// 劫持 data 所有属性</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 代理 data 属性到 Vue 实例（可通过 vm.message 访问 vm.$data.message）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">proxyData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 解析模板</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>, <span class="hljs-variable language_">this</span>);
        }
      }

      <span class="hljs-comment">// 代理 data 属性到 Vue 实例</span>
      <span class="hljs-title function_">proxyData</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, key, {
            <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
              <span class="hljs-keyword">return</span> data[key];
            },
            <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
              data[key] = newValue;
            }
          });
        });
      }
    }

    <span class="hljs-comment">//  测试例子 </span>
    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
      <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue2 响应式！'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-5">二、 Vue 3：基于 Proxy 的升级进化</h2>
<h3 data-id="heading-6">1. 核心改进</h3>
<p>Vue 3 彻底放弃了 <code>Object.defineProperty</code>，转而使用 ES6 的 <code>Proxy</code>。它不仅解决了 Vue 2 无法监听对象新增属性和数组索引的问题，还显著提升了初始化性能。</p>
<h3 data-id="heading-7">2. 响应式流程</h3>
<ol>
<li>
<p><strong>Proxy 代理</strong>：拦截对象的 <code>get</code> 和 <code>set</code>。</p>
</li>
<li>
<p><strong>依赖追踪 (Track)</strong> ：在 <code>get</code> 时，将当前正在执行的 <code>Effect</code>（副作用函数）记录在全局映射表 <code>targetMap</code> 中。</p>
</li>
<li>
<p><strong>触发更新 (Trigger)</strong> ：在 <code>set</code> 时，从 <code>targetMap</code> 中找到该属性对应的所有 <code>Effect</code> 并重新执行。</p>
</li>
</ol>
<h3 data-id="heading-8">3. 源码仿真实现</h3>
<p>在 Vue3中，我们通过 <code>reactive</code> 声明响应式数据。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue3 双向数据绑定简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ user.age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">onclick</span>=<span class="hljs-string">"state.user.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"user.age"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖管理核心：存储「数据-副作用」映射 </span>
    <span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">// 全局依赖映射：target → key → effects</span>
    <span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前正在执行的副作用函数</span>

    <span class="hljs-comment">// 收集依赖（追踪）</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 无副作用函数则不收集</span>
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) {
        depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
        targetMap.<span class="hljs-title function_">set</span>(target, depsMap);
      }
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) {
        deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 用 Set 避免重复副作用</span>
        depsMap.<span class="hljs-title function_">set</span>(key, deps);
      }
      <span class="hljs-comment">// 3. 添加当前副作用到集合</span>
      deps.<span class="hljs-title function_">add</span>(activeEffect);
    }

    <span class="hljs-comment">// 触发依赖更新</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 3. 执行所有副作用函数</span>
      deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());
    }

    <span class="hljs-comment">//  2. 创建响应式对象：reactive（基于 Proxy + Reflect） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
      <span class="hljs-comment">// 非对象直接返回</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">'object'</span> || target === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> target;
      }

      <span class="hljs-comment">// 创建 Proxy 代理</span>
      <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {
        <span class="hljs-comment">// 拦截属性读取</span>
        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-title function_">track</span>(target, key); <span class="hljs-comment">// 收集依赖</span>
          <span class="hljs-comment">// 递归处理嵌套对象（懒代理，读取时才创建响应式）</span>
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(result);
        },
        <span class="hljs-comment">// 拦截属性赋值</span>
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
          <span class="hljs-keyword">const</span> oldValue = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);
          <span class="hljs-comment">// 值变化才触发更新</span>
          <span class="hljs-keyword">if</span> (oldValue !== value) {
            <span class="hljs-title function_">trigger</span>(target, key); <span class="hljs-comment">// 触发依赖更新</span>
          }
          <span class="hljs-keyword">return</span> result;
        },
        <span class="hljs-comment">// 拦截属性删除（可选，补充完整度）</span>
        <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key);
          <span class="hljs-title function_">trigger</span>(target, key);
          <span class="hljs-keyword">return</span> result;
        }
      });

      <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-comment">//  3. 副作用函数：effect（依赖收集的入口） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {
      <span class="hljs-comment">// 包装副作用函数</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"/>) =&gt; {
        activeEffect = effectFn; <span class="hljs-comment">// 标记当前副作用</span>
        <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行函数，触发 get 拦截，收集依赖</span>
        activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重置</span>
      };
      <span class="hljs-title function_">effectFn</span>(); <span class="hljs-comment">// 立即执行一次，完成初始依赖收集</span>
      <span class="hljs-keyword">return</span> effectFn;
    }

    <span class="hljs-comment">//  4. 模板解析器：Compile（解析 {{}} 和 v-model） </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el); <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data; <span class="hljs-comment">// 响应式数据</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFragment</span>(); <span class="hljs-comment">// 创建文档碎片</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 解析模板</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 挂载到 DOM</span>
      }

      <span class="hljs-comment">// 创建文档碎片（减少 DOM 操作）</span>
      <span class="hljs-title function_">createFragment</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> child;
        <span class="hljs-keyword">while</span> (child = <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(child);
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心解析方法</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 元素节点（解析 v-model）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-regexp">/\{\{(.+?)\}\}/</span>.<span class="hljs-title function_">test</span>(node.<span class="hljs-property">textContent</span>)) { <span class="hljs-comment">// 文本节点（解析 {{}}）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
        }

        <span class="hljs-comment">// 递归解析子节点</span>
        node.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(child));
      }

      <span class="hljs-comment">// 解析元素节点（v-model 指令）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> { name, value } = attr;
          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'v-model'</span>) { <span class="hljs-comment">// 处理 v-model</span>
            <span class="hljs-comment">// 1. 初始化：用响应式数据设置 DOM 值</span>
            node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            <span class="hljs-comment">// 2. 监听输入事件，同步到响应式数据</span>
            node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(value, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
            });
            <span class="hljs-comment">// 3. 监听数据变化，更新 DOM</span>
            <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
              node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            });
            <span class="hljs-comment">// 移除指令属性（可选，美化 DOM）</span>
            node.<span class="hljs-title function_">removeAttribute</span>(name);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">const</span> text = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 替换 {{}} 为真实数据，并创建副作用</span>
        node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, expr</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> prop = expr.<span class="hljs-title function_">trim</span>();
          <span class="hljs-comment">// 监听数据变化，更新文本</span>
          <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
            node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, innerExpr</span>) =&gt;</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(innerExpr.<span class="hljs-title function_">trim</span>());
            });
          });
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(prop);
        });
      }

      <span class="hljs-comment">// 获取响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }

      <span class="hljs-comment">// 设置响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">setVal</span>(<span class="hljs-params">expr, value</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key, index, arr</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 处理数字类型（如 age）</span>
            <span class="hljs-keyword">return</span> data[key] = <span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(value)) ? value : <span class="hljs-title class_">Number</span>(value);
          }
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }
    }

    <span class="hljs-comment">//  4. 测试代码 </span>
    <span class="hljs-comment">// 1. 创建响应式数据</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue3 双向绑定！'</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });

    <span class="hljs-comment">// 2. 解析模板，完成双向绑定</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-string">'#app'</span>, state);

    <span class="hljs-comment">// 暴露到全局，方便控制台测试</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">state</span> = state;
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h2 data-id="heading-9">三、 总结：Vue 2 vs Vue 3 响应式对比</h2>






























<table><thead><tr><th><strong>特性</strong></th><th><strong>Vue 2 (defineProperty)</strong></th><th><strong>Vue 3 (Proxy)</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>必须全量遍历属性，开销大</td><td>懒代理（读取时才处理），更高效</td></tr><tr><td><strong>动态性</strong></td><td>无法检测属性新增、删除</td><td>完美支持属性新增、删除及数组索引</td></tr><tr><td><strong>实现复杂度</strong></td><td>需要手动重写数组方法</td><td>原生支持所有对象操作</td></tr><tr><td><strong>兼容性</strong></td><td>支持 IE9+</td><td>不支持 IE (依赖 ES6)</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法]]></title>    <link>https://juejin.cn/post/7602225961095807010</link>    <guid>https://juejin.cn/post/7602225961095807010</guid>    <pubDate>2026-02-03T10:01:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961095807010" data-draft-id="7602216700747808768" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法"/> <meta itemprop="keywords" content="Go"/> <meta itemprop="datePublished" content="2026-02-03T10:01:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:01:21.000Z" title="Tue Feb 03 2026 10:01:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在 Go 里，构造函数经常会遇到一个问题：参数越来越多。例如  <code>NewServer(port, healthz, middlewares, jwt, serviceName, ...) </code> 这种函数签名，一旦需求增长就会变成“参数灾难”：</p>
<ul>
<li>
<p>可读性差：调用处一串参数，看不出谁是谁</p>
</li>
<li>
<p>易用性差：可选项很多时，必须传一堆默认值占位</p>
</li>
<li>
<p>兼容性差：新增一个参数就破坏所有调用方（编译报错）</p>
</li>
<li>
<p>维护成本高：参数顺序、默认值、校验逻辑分散</p>
</li>
</ul>
<p><code>NewServer</code>参数泛滥问题，正是 Go 语言中构造函数的常见痛点，而<strong>函数式选项模式（Functional Options Pattern）</strong> 是应对这类场景的优雅最优解。它不直接传递零散参数，而是将每个配置项封装为独立的 “选项函数”，构造函数仅接收可变长度的选项函数切片，内部遍历执行以完成结构体初始化。这种模式完美攻克参数灾难的四大痛点。</p>
<p>为了在不同复杂度与工程约束下都能落地，函数式选项模式在实践中常见三种变体：（1）轻量函数型：样板代码最少、上手最快；（2）接口 + 配置载体型（<code>gRPC</code> 风格）：进一步解耦，避免核心结构体被配置“污染”；（3）不可变配置型（<code>OpenTelemetry</code> 风格）：通过值传递返回新配置，更利于并发安全与配置可追溯。下面按顺序逐一展开。</p>
<h2 data-id="heading-1">第一种：轻量版 Functional Options（最常见）</h2>
<p>这是<strong>函数式选项模式</strong>最基础、简洁的实现形式，核心无需引入复杂接口，仅通过<strong>定义一个接收目标结构体指针的函数类型</strong>，再封装一系列<code>WithXXX</code>命名的工厂函数，返回能修改结构体字段的闭包即可。构造函数中先初始化结构体的合理默认值，再遍历执行传入的所有选项函数，覆盖用户需要自定义的配置。这种模式以极简的代码量解决了多参数构造函数的四大痛点。</p>
<p>下面例子是简单的对 <code>gin</code>  进行封装的 <code>Server</code> 端，简化了大部分逻辑，用来认识这种实现形式，在用时可根据自己的业务逻辑自行添加。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义选项函数类型 接收*Server指针，用于修改结构体字段</span>
<span class="hljs-keyword">type</span> ServerOption <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server)</span></span>

<span class="hljs-comment">// WithServiceName 设置服务名称</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithServiceName</span><span class="hljs-params">(srvName <span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.serviceName = srvName
	}
}
<span class="hljs-comment">// WithPort 设置服务端口</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithPort</span><span class="hljs-params">(port <span class="hljs-type">int</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.port = port
	}
}
<span class="hljs-comment">// WithMiddlewares 设置中间件列表</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithMiddlewares</span><span class="hljs-params">(middlewares []<span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.middlewares = middlewares
	}
}
<span class="hljs-comment">// WithHealthz 设置健康检查开关</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithHealthz</span><span class="hljs-params">(healthz <span class="hljs-type">bool</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.healthz = healthz
	}
}

</code></pre>
<p>这种形式一般都是一个文件夹下两个文件，一个为 <code>option.go</code>， 一个为 <code>Server.go</code>，在程序的主入口，直接调用 。<code>NewServer(With...)</code>函数，拿到返回值 <code>srv</code> 之后，即可通过 <code>srv.Start()</code> 启动服务，当然可以根据自己加更多逻辑，比如优雅退出等等。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
	*gin.Engine
	port <span class="hljs-type">int</span>
	<span class="hljs-comment">// 是否开启健康检查接口， 默认开启， 如果开启会自动添加 /health 接口</span>
	healthz <span class="hljs-type">bool</span>
	<span class="hljs-comment">// 中间件</span>
	middlewares []<span class="hljs-type">string</span>
    <span class="hljs-comment">// jwt配置信息 后续自己可扩展</span>
	jwt *JwtInfo
	server *http.Server
	serviceName <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opts ...ServerOption)</span></span> *Server {
	srv := &amp;Server{
		port:            <span class="hljs-number">8080</span>,
		healthz:         <span class="hljs-literal">true</span>,
		serviceName: <span class="hljs-string">"test"</span>,
        Engine:      gin.Default(),
	}

	<span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts {
		o(srv)
	}
	
	<span class="hljs-comment">// 遍历用户传的中间件 在自己库中查找 没找到就跳过 这是只是为了演示配置</span>
	<span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> srv.middlewares {
		mw, ok := Middlewares[m]
		<span class="hljs-keyword">if</span> !ok {
			log.Warnf(<span class="hljs-string">"can not find middleware: %s"</span>, m)
			<span class="hljs-keyword">continue</span>
		}

		log.Infof(<span class="hljs-string">"intall middleware: %s"</span>, m)
		srv.Engine.Use(mw)
	}
    
    <span class="hljs-keyword">return</span> srv
}

<span class="hljs-comment">// 绑定一些方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Start(ctx context.Context) <span class="hljs-type">error</span> {}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Stop(ctx context.Context) <span class="hljs-type">error</span> {}



<span class="hljs-comment">// 这里的代码是放到其他目录的 由于这里会用到 自己去写的时候 建议不要放到这里</span>
<span class="hljs-keyword">var</span> Middlewares = defaultMiddlewares()

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultMiddlewares</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc{
		<span class="hljs-string">"cors"</span>:     Cors(),  <span class="hljs-comment">// 跨域的中间件 需自行实现跨域逻辑</span>
		<span class="hljs-string">"context"</span>:  Context(), <span class="hljs-comment">// 自定义上下文传递中间件，需自行实现</span>
	}
}

</code></pre>
<h2 data-id="heading-2">第二种：接口型选项模式（<code>gRPC</code> 经典实现）</h2>
<p>这种模式是基础函数式选项的进阶，核心是引入了<strong>选项接口</strong>（<code>DialOption</code>）和<strong>专门的配置载体结构体</strong>（<code>dialOptions</code>），不再让选项函数直接耦合目标结构体（<code>ClientConn</code>）。通过定义<code>apply</code>方法作为接口约定，将所有配置项聚合到<code>dialOptions</code>中，选项的实现都围绕这个配置载体展开，最后在构造函数中统一将配置应用到目标结构体。这种模式让配置逻辑与目标结构体解耦，同时接口的约束让选项扩展更具规范性。</p>
<p>代码中有注释，等了解完代码，再回过头看下面文字会有更深的理解。</p>
<p>首先第一点<strong>解耦</strong>，解耦无论在哪种语言中提到，大部分就是多加一层，这里也是同理。比如在第一种基础的选项模式中，随着功能越来越完善，要新加一些超时字段，比如连接超时读写超时，或者就是单纯加字段，这个时候，只能在 <code>Server</code>结构体中添加这些字段，然后还要手动去写它们的默认值，再加一些 <code>with...()</code> 方法，我们要清楚的是这个结构体核心职责是 “管理网络连接”，但最终却塞满了超时还有一堆额外加的配置项，可读性和维护性极差，这就是常说的业务结构体被配置 “污染”，下面这一种就是解决这个问题，<code>DialOption</code>接口 + <code>dialOptions</code> 配置载体（<code>dialOptions</code> 里面承担了所有配置相关的逻辑 ），使得 <code>ClientConn </code>只专注于自己的核心业务，需求迭代时完全不用改动<code>ClientConn</code>。</p>
<p>第二点<strong>扩展性</strong>，这也源于 Go 面向接口编程思想，在Go语言中，<strong>接口约定优于实现</strong>：<code>DialOption</code>接口只定义了<code>apply(*dialOptions)</code>一个方法，这是一种<strong>行为约定</strong>，它不关心实现者是<code>funcDialOption</code>还是其他实现比如自己实现一个<code>ValidateTargetOption</code>，只要满足这个行为约定，就能被构造函数处理。</p>
<p>比如现在需要验证合法性，如果说是第一种，必然是在需要验证的 <code>with...()</code> 函数中添加，无疑是需要修改核心逻辑，这里只是举一个很好理解的例子，在大多数情况下，比如链路跟踪，有了一个公认的规范 <code>OpenTelemetry</code>  可以理解成类似 <code>Type-C</code> 硬件协议规范，这时候你的系统要接入链路跟踪，之前可能用的不是这种规范，如果用第一种，无疑是需要修改核心业务逻辑，如果是这一种，逻辑都再配置层，核心逻辑不需要动，这里给大家用 <code>ValidateTargetOption</code>  自己写的实现接口的结构体，用于验证<code>url</code> 是否合法，放在文章最后。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> DialOption <span class="hljs-keyword">interface</span> {
	apply(*dialOptions)
}

<span class="hljs-comment">// 实现上面接口 </span>
<span class="hljs-keyword">type</span> funcDialOption <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// 结构体字段是函数</span>
	f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*dialOptions)</span></span>
}
<span class="hljs-comment">// 这个方法 在后续 NewClient 会用到</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fdo *funcDialOption)</span></span> apply(do *dialOptions) {
    <span class="hljs-comment">// fdo.f 本质上就是一个函数 func(*dialOptions) 里面有一些逻辑 逻辑是通过 with...() 传来的 可以看完下面的在回来理解</span>
    <span class="hljs-comment">// 把传来的 dialOptions 配置项（全局唯一） 放入f这个函数中执行对应逻辑 这些逻辑就是向它的各个字段赋值</span>
	fdo.f(do)
}

<span class="hljs-comment">// 主 ClientConn 里面有个 dialOptions 这个字段就解耦了</span>
<span class="hljs-keyword">type</span> dialOptions <span class="hljs-keyword">struct</span> {
	unaryInt  UnaryClientInterceptor
	streamInt StreamClientInterceptor
	chainUnaryInts  []UnaryClientInterceptor
	chainStreamInts []StreamClientInterceptor
    target 						<span class="hljs-type">string</span>
	compressorV0                Compressor
	dc                          Decompressor
	bs                          internalbackoff.Strategy
	block                       <span class="hljs-type">bool</span>
	returnLastError             <span class="hljs-type">bool</span>
	timeout                     time.Duration
 	disableHealthCheck          <span class="hljs-type">bool</span>
   <span class="hljs-comment">// ..... 等等一系列配置相关的  巧妙的与 主 ClientConn 分开 这使得 ClientConn 只专注于自己的核心业务</span>
}


<span class="hljs-comment">// 这个函数是用于封装的 这使得 以后的 with 方法直接调用这个函数就可以很方便的返回 实现接口的 funcDialOption 结构体</span>
<span class="hljs-comment">/* 
拆解一下这个函数便于理解： 
首先 newFuncDialOption 接收的参数就是一个 f 函数 函数长相是 func(*dialOptions) 没有返回值，形参介绍完成
其次：newFuncDialOption 的返回值 就是 实现接口的 funcDialOption 结构体  返回值介绍完成
函数内容：实现接口的 funcDialOption 结构体 有个字段是函数 把传来的形参直接赋值上并返回
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newFuncDialOption</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(*dialOptions)</span></span>) *funcDialOption {
	<span class="hljs-keyword">return</span> &amp;funcDialOption{
		f: f,
	}
}

<span class="hljs-comment">// 大家看完这种 with 函数返回的 内部逻辑  就能明白 就是给 dialOptions 里面的值赋值的</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithChainUnaryInterceptor</span><span class="hljs-params">(interceptors ...UnaryClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.chainUnaryInts = <span class="hljs-built_in">append</span>(o.chainUnaryInts, interceptors...)
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStreamInterceptor</span><span class="hljs-params">(f StreamClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.streamInt = f
	})
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDisableHealthCheck</span><span class="hljs-params">()</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.disableHealthCheck = <span class="hljs-literal">true</span>
	})
}
<span class="hljs-comment">// 等等.... 几乎能用的字段都放一个 with </span>
</code></pre>
<p>这里的最大重点就是 <code>defaultDialOptions()</code> 这个函数就是存放默认值，解耦的关键，无论后续添加什么字段，都放在该函数中进行初始化，在 <code>NewClient() </code>函数中任何地方都不需要改。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(target <span class="hljs-type">string</span>, opts ...DialOption)</span></span> (conn *ClientConn, err <span class="hljs-type">error</span>) {
    cc := &amp;ClientConn{
       target: target,
       conns:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*addrConn]<span class="hljs-keyword">struct</span>{}),
       dopts:  defaultDialOptions(),   <span class="hljs-comment">// 一切相关的配置都放在这里 不污染主路线</span>
    }

	<span class="hljs-comment">// 这边就是我们传入的 with.... 去进行 赋值</span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       <span class="hljs-comment">// 调用上面的 apply 方法 </span>
       opt.apply(&amp;cc.dopts)
    }

    chainUnaryClientInterceptors(cc)
    chainStreamClientInterceptors(cc)


   <span class="hljs-comment">// 各种逻辑....</span>

    <span class="hljs-keyword">return</span> cc, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// 同样绑定各种方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> GetState() connectivity.State {
	<span class="hljs-keyword">return</span> cc.csMgr.getState()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> waitForResolvedAddrs(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) {...}
</code></pre>
<h2 data-id="heading-3">第三种：不可变配置型选项模式（<code>OpenTelemetry</code> 风格）</h2>
<p>这种模式是<strong>函数式选项的安全进阶版</strong>，核心区别于前两种的<strong>可变配置修改</strong>，它采用<strong>值传递 + 返回新配置</strong>的方式实现不可变性，所有配置操作都不会修改原有配置对象，而是返回一个全新的配置副本。这种模式在 <code>OpenTelemetry</code>、<code>Prometheus</code> 等核心组件中广泛使用，特别适合对<strong>并发安全、配置不可篡改、数据一致性</strong>有严格要求的场景（比如链路追踪、监控采集、全局配置管理等）。</p>
<p>前两种模式中，配置的修改都是就地修改（通过指针操作修改结构体字段）：第一种直接修改目标结构体 <code>*Server</code>，第二种修改配置载体 <code>*dialOptions</code>，这种可变模式在单协程场景下没问题，但在并发场景中，如果配置被意外复用、修改，可能会引发不可预期的问题。而不可变配置模式从根源上解决了这个问题 ，配置一旦创建，就无法被修改，后续的所有配置调整都只会生成新的配置对象，天然具备线程安全，且能追溯配置变更轨迹。</p>
<p>这里的 <code>tracerProviderConfig</code> 同样是用于解耦的配置项，只不过是安全进阶版。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 同样定义选项接口   不可变核心：接收旧配置，返回新配置 </span>
<span class="hljs-keyword">type</span> TracerProviderOption <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// 与前两种的区别：apply方法不是修改指针，而是入参旧配置，返回新配置</span>
	apply(tracerProviderConfig) tracerProviderConfig
}

<span class="hljs-comment">// 定义接口的函数类型实现，类似第二种的 funcDialOption，只是简化选项创建，本质是一样的</span>
<span class="hljs-comment">// 第二种是 结构体里字段是函数  这里是 这个结构体就是个函数 函数形式 func(tracerProviderConfig) tracerProviderConfig</span>
<span class="hljs-keyword">type</span> traceProviderOptionFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tracerProviderConfig)</span></span> tracerProviderConfig

<span class="hljs-comment">// 依旧实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fn traceProviderOptionFunc)</span></span> apply(cfg tracerProviderConfig) tracerProviderConfig {
	<span class="hljs-keyword">return</span> fn(cfg)
}


<span class="hljs-comment">// 各种 with 函数 返回都是接口   主要看 return 地方</span>
<span class="hljs-comment">/*
首先 内层 匿名函数 func(cfg tracerProviderConfig) tracerProviderConfig 这是实际承载配置逻辑的函数
traceProviderOptionFunc() 可以理解成同签名函数类型的安全转换  转换的双方是 “同构” 的，没有数据丢失 
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithResource</span><span class="hljs-params">(r *resource.Resource)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
		cfg.resource, err = resource.Merge(resource.Environment(), r)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 错误逻辑....</span>
		}
		<span class="hljs-keyword">return</span> cfg
	})
}


<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithIDGenerator</span><span class="hljs-params">(g IDGenerator)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> g != <span class="hljs-literal">nil</span> {
			cfg.idGenerator = g
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSampler</span><span class="hljs-params">(s Sampler)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> {
			cfg.sampler = s
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-comment">// ....</span>
</code></pre>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTracerProvider</span><span class="hljs-params">(opts ...TracerProviderOption)</span></span> *TracerProvider {
    <span class="hljs-comment">// 默认值</span>
    o := tracerProviderConfig{
       spanLimits: NewSpanLimits(),
    }
    <span class="hljs-comment">// 从环境变量里读取</span>
    o = applyTracerProviderEnvConfigs(o)
    
	<span class="hljs-comment">// 用户 with... 传来的 </span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       o = opt.apply(o)
    }
	
	<span class="hljs-comment">// 生成 要返回值</span>
    tp := &amp;TracerProvider{
       namedTracer: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[instrumentation.Scope]*tracer),
       sampler:     o.sampler,
       idGenerator: o.idGenerator,
       spanLimits:  o.spanLimits,
       resource:    o.resource,
    }

    <span class="hljs-comment">// 其他逻辑  ...</span>

    <span class="hljs-keyword">return</span> tp
}
<span class="hljs-comment">// 同样绑定一系列方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> Tracer(name <span class="hljs-type">string</span>, opts ...trace.TracerOption) trace.Tracer {...}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> RegisterSpanProcessor(sp SpanProcessor) {...}

</code></pre>
<h2 data-id="heading-4">自己实现的 <code>ValidateTargetOption</code></h2>
<p>通过下面自己编写的实现 <code>DialOption</code> 接口的结构体，就能封装复杂的 <code>gRPC</code> 客户端目标地址（target）合法性校验逻辑，还能携带额外配置参数满足多样化校验需求。后续调用方只需通过我们提供的 <code>WithValidateTarget()</code> 方法传入校验规则，即可让 <code>gRPC</code> 客户端在初始化时自动完成地址校验，整个扩展过程对原有代码零侵入，扩展性和可维护性拉满。</p>
<p><code>gRPC</code> 实际 Target 格式校验更复杂，这里只是通过这个例子告诉大家可以自己写实现接口的结构体，并应用到它们内部。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义结构体：专门用于校验target合法性</span>
<span class="hljs-keyword">type</span> ValidateTargetOption <span class="hljs-keyword">struct</span> {
	<span class="hljs-comment">// 可携带额外配置，比如是否允许本地地址、是否必须是https等</span>
	allowLocal <span class="hljs-type">bool</span>
}

<span class="hljs-comment">// 实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *ValidateTargetOption)</span></span> apply(do *dialOptions) {
	<span class="hljs-comment">// 判断target是否为空</span>
	<span class="hljs-keyword">if</span> do.target == <span class="hljs-string">""</span> {
        <span class="hljs-comment">// 这里不建议直接 Fatal 这里为了演示 代码尽量少</span>
		log.Fatalf(<span class="hljs-string">"validate failed: target address is empty"</span>)
	}

	<span class="hljs-comment">// 解析url，校验格式合法性</span>
	_, err := url.Parse(do.target)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatalf(<span class="hljs-string">"validate failed: target address format is invalid, err: %v"</span>, err)
	}

	<span class="hljs-comment">//根据allowLocal配置，判断是否允许本地地址（127.0.0.1、localhost）</span>
	<span class="hljs-keyword">if</span> !v.allowLocal &amp;&amp; (do.target == <span class="hljs-string">"127.0.0.1"</span> || do.target == <span class="hljs-string">"localhost"</span>) {
		log.Fatalf(<span class="hljs-string">"validate failed: local address is not allowed"</span>)
	}

	<span class="hljs-comment">// 校验通过，打印日志</span>
	log.Printf(<span class="hljs-string">"validate success: target address %s is valid"</span>, do.target)
}

<span class="hljs-comment">// 提供 with 函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValidateTarget</span><span class="hljs-params">(allowLocal <span class="hljs-type">bool</span>)</span></span> DialOption {
	<span class="hljs-keyword">return</span> &amp;ValidateTargetOption{allowLocal: allowLocal}
}
</code></pre>
<h2 data-id="heading-5">总结</h2>
<p>函数式选项模式是 Go 语言解决构造函数 "参数灾难" 的最优解，三种实现形式各有侧重、按需选用：轻量版极简直观，无需额外接口，通过闭包直接修改目标结构体，适合普通业务服务的快速落地；接口型（<code>gRPC</code> 风格）通过引入配置载体结构体和解耦接口，让核心业务结构体摆脱配置污染，扩展性和规范性更强，适合复杂基础组件的开发；不可变配置型（<code>OpenTelemetry</code> 风格）采用值传递返回新配置的方式，从根源上保证并发安全和配置不可篡改，适合链路追踪、监控采集等对数据一致性有严格要求的场景。三种模式均能解决多参数带来的可读性、易用性等问题，核心差异在于解耦程度和安全等级，实际开发中可根据业务复杂度和场景要求选择对应的实现方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比]]></title>    <link>https://juejin.cn/post/7602440800295731246</link>    <guid>https://juejin.cn/post/7602440800295731246</guid>    <pubDate>2026-02-03T10:03:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295731246" data-draft-id="7602464510607310874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-02-03T10:03:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="让我上个超影吧"/> <meta itemprop="url" content="https://juejin.cn/user/3411151088782442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3411151088782442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    让我上个超影吧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:03:59.000Z" title="Tue Feb 03 2026 10:03:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 Skills？它到底解决了什么痛点？</h2>
<p>想象这样一个场景：你正在用<strong>CodeBuddy</strong>写代码，每次让 AI 帮忙审查代码，都要重复说： <strong>"请用中文写注释"、"记得检查空指针"、"按照我们团队的 RESTful 规范来</strong>"。说了一遍又一遍，AI 还是经常忘记。</p>
<p><strong>Skills（技能）就是来解决这个问题的。</strong></p>
<p>简单来说，<strong>Skills 是给 AI 准备的一份"专业上岗培训手册"</strong> 。你可以把团队的代码规范、特定的开发流程、或者某个领域（如 Chrome 插件开发）的最佳实践，打包成一个 Skill。一旦安装，AI 就会自动记住这些规则，在你需要的时候自动调用，无需反复提醒。</p>
<h4 data-id="heading-1">核心痛点解决</h4>






























<table><thead><tr><th>痛点</th><th>传统方式</th><th>使用 Skills 后</th></tr></thead><tbody><tr><td>重复劳动</td><td>每次都要粘贴同样的 prompt</td><td>一次编写，永久复用，自动触发</td></tr><tr><td>团队标准不一</td><td>新人不知道团队规范，AI 输出风格各异</td><td>Skill 随 Git 仓库共享，全员统一标准</td></tr><tr><td>上下文溢出</td><td>长 prompt 占用大量 token，导致 AI 失忆</td><td>渐进式加载，用时才展开，节省 token</td></tr><tr><td>知识沉淀困难</td><td>好的提示词散落在聊天记录里</td><td>标准化文件，可版本控制，沉淀为团队资产</td></tr></tbody></table>
<p><strong>一句话总结</strong>：Skills 让 AI 从"通用实习生"变成"懂行老手"，知道在什么时候该用什么方法做什么事。</p>
<p>这里也推荐我在B站看的科普视频，讲得很形象</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1dz6oBWEWx%2F%3Fspm_id_from%3D333.1391.0.0" target="_blank" title="https://www.bilibili.com/video/BV1dz6oBWEWx/?spm_id_from=333.1391.0.0" ref="nofollow noopener noreferrer">www.bilibili.com/video/BV1dz…</a></p>
<h2 data-id="heading-2">二、在 CodeBuddy中使用 Skills：从零开始</h2>
<p>这里为啥用CodeBuddy这个软件，无他，就因为免费，大多数人能够直接接触到，国外的一些IDE和模型都要用魔法，新手使用不方便</p>
<p>CodeBuddy（腾讯的 AI IDE）近期全面支持了 Skills 功能，并且支持<strong>全局 Skills</strong>（所有项目通用）和<strong>项目 Skills</strong>（仅当前项目生效）两种类型</p>
<h3 data-id="heading-3">第一步：创建 Skills 的目录</h3>
<p>Skills 通过在特定目录中创建 <code>SKILL.md</code> 文件来定义：</p>
<blockquote>
<ol>
<li><strong>项目级 Skills</strong>：<code>.codebuddy/skills/</code>（项目根目录下）</li>
<li><strong>用户级 Skills</strong>：<code>~/.codebuddy/skills/</code>（用户主目录下）</li>
</ol>
</blockquote>
<p>每个 Skill 一个独立的目录，包含 <code>SKILL.md</code> 文件，整体框架目录如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">.codebuddy/skills/
├── pdf/
│   └── <span class="hljs-built_in">SKILL</span>.md
├── data-analysis/
│   └── <span class="hljs-built_in">SKILL</span>.md
└── code-review/
    └── <span class="hljs-built_in">SKILL</span>.md
</code></pre>
<p>每个技能文件夹下面又可以细分</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">skill-name</span>(pdf)/
├── SKILL<span class="hljs-selector-class">.md</span> (必需)
│   ├── YAML frontmatter 元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown 指令 (必需)
└── Bundled Resources (可选)
    ├── scripts/          - 可执行代码 (Python/Bash 等)
    ├── references/       - 旨在根据需要加载到上下文中的文档
    └── assets/           - 用在输出中的文件 (模板、图标、字体等)
</code></pre>
<h4 data-id="heading-4"><strong>SKILL.md (必需)</strong></h4>
<p>这是 Skill 的核心定义文件。</p>
<p><strong>元数据 (</strong> <strong>YAML</strong> <strong>Frontmatter):</strong> <strong><code>name</code></strong> ****和 <strong><code>description</code></strong> ****决定了 AI 何时会使用这个 Skill。描述需具体说明 Skill 的功能和使用场景。</p>
<p>示例：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">pdf-editor</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">This</span> <span class="hljs-string">skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">when</span> <span class="hljs-string">users</span> <span class="hljs-string">ask</span> <span class="hljs-string">to</span> <span class="hljs-string">modify,</span> <span class="hljs-string">rotate,</span> <span class="hljs-string">or</span> <span class="hljs-string">extract</span> <span class="hljs-string">text</span> <span class="hljs-string">from</span> <span class="hljs-string">PDF</span> <span class="hljs-string">files.</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-comment"># 可选，指定允许使用的工具</span>
<span class="hljs-attr">disable:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 可选，是否禁用</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># PDF Editor</span>

<span class="hljs-string">To</span> <span class="hljs-string">rotate</span> <span class="hljs-string">a</span> <span class="hljs-string">PDF...</span>
</code></pre>
<h4 data-id="heading-5">打包资源 (可选)</h4>
<ol>
<li>
<h5 data-id="heading-6">Scripts (<code>scripts/</code>)</h5>
</li>
</ol>
<p>用于需要确定性可靠性或被重复重写的任务的可执行代码。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：当代码被重复重写或需要高可靠性时。</li>
<li><strong>示例</strong>：<code>scripts/rotate_pdf.py</code> 用于 PDF 旋转。</li>
</ul>
</blockquote>
<ol start="2">
<li>
<h5 data-id="heading-7">References (<code>references/</code>)</h5>
</li>
</ol>
<p>旨在根据需要加载到上下文中以辅助 AI 思考的文档和参考资料。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：数据库架构、API 文档、领域知识、公司政策等。</li>
<li><strong>优势</strong>：保持 <code>SKILL.md</code> 精简，仅在 AI 确定需要时才加载。</li>
</ul>
</blockquote>
<ol start="3">
<li>
<h5 data-id="heading-8">Assets (<code>assets/</code>)</h5>
</li>
</ol>
<p>不打算加载到上下文中，而是用于 AI 生成的输出中的文件。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：品牌资产、PPT 模板、HTML/React 样板代码等。</li>
</ul>
</blockquote>
<p>了解完上面，创建的目录如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95ef5ff2961446ffaab769cd380d7c7e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=GEQXlKl4R5PfFisTnG6kejVThW0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">第二步：创建你的第一个 Skill：比想象中简单</h3>
<p>一个标准的 Skill 就是一个文件夹，核心是 ****<strong><code>SKILL.md</code></strong> <strong>文件</strong></p>
<p>一个 Skill 本质上就是一个 Markdown 文件（文件名固定为 SKILL.md），内容几乎只由下面三段组成：</p>
<p>SKILL.md 基本模板:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">What</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">and</span> <span class="hljs-string">when</span> <span class="hljs-string">Claude</span> <span class="hljs-string">should</span> <span class="hljs-string">use</span> <span class="hljs-string">it</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># Skill Title</span>

<span class="hljs-comment">## Instructions</span>
<span class="hljs-string">Clear,</span> <span class="hljs-string">concrete,</span> <span class="hljs-string">actionable</span> <span class="hljs-string">rules.</span>

<span class="hljs-comment">## Examples</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">2</span>

<span class="hljs-comment">## Guidelines</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">2</span>
</code></pre>



































<table><thead><tr><th>字段</th><th>必填</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>name</td><td>否</td><td>Skill 名称,未指定时使用目录名</td><td>pdf</td></tr><tr><td>description</td><td>否</td><td>Skill 描述,帮助 AI 理解何时使用</td><td>PDF 文档处理专家 （project)</td></tr><tr><td>allowed-tools</td><td>否</td><td>允许使用的工具白名单,逗号分隔</td><td>Read, Write, Bash</td></tr><tr><td>disable-model-invocation</td><td>否</td><td>设置为 true 时，Skill 不会出现在 Skill 工具中，只能通过 /skill-name 手动触发</td><td>TRUE</td></tr></tbody></table>
<p>这里给出一个案例，大家可以进行尝试，比较简单，所以只是用<strong>SKILL.md</strong>即可，不需要脚本和素材之类的</p>
<p><strong>示例 ：前端页面设计 Skill</strong></p>
<p><strong>文件</strong>：<code>.codebuddy/skills/frontend-design/SKILL.md</code></p>
<pre><code class="hljs language-markdown" lang="markdown">---
name: frontend-design
description: 创建具有高品质设计的独特、生产级前端界面。当用户要求构建 Web 组件、页面、作品、海报或应用程序时使用此技能（示例包括网站、落地页、仪表盘、React 组件、HTML/CSS 布局，或为任何 Web UI 进行美化/优化）。生成具有创意、精致代码和 UI 设计，避免通用 AI 美学。
<span class="hljs-section">license: 完整条款见 LICENSE.txt
---</span>

本技能指导创建独特、生产级前端界面，避免通用的"AI 垃圾"美学。实现真正可用的代码，对美学细节和创意选择给予特别关注。

用户提供前端需求：要构建的组件、页面、应用程序或界面。他们可能包含有关用途、受众或技术约束的上下文。

<span class="hljs-section">## 设计思维</span>

在编码之前，理解上下文并致力于<span class="hljs-strong">**大胆**</span>的美学方向：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**目的**</span>：此界面解决什么问题？谁使用它？
<span class="hljs-bullet">-</span> <span class="hljs-strong">**风格**</span>：选择一个极端：极简主义、极繁主义混乱、复古未来主义、有机/自然、奢华/精致、趣味/玩具风、编辑/杂志风、粗野主义/原始、装饰艺术/几何、柔和/ pastel、工业/实用等。有众多风格可供选择。将这些作为灵感，但设计出忠于美学方向的风格。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**约束**</span>：技术要求（框架、性能、无障碍）。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**差异化**</span>：是什么让它<span class="hljs-strong">**令人难忘**</span>？有什么是别人会记住的？

<span class="hljs-strong">**关键**</span>：选择清晰的概念方向并精准执行。大胆极繁和精致极简都有效——关键是意图性，而非强度。

然后实现可用的代码（HTML/CSS/JS、React、Vue 等），具备：
<span class="hljs-bullet">-</span> 生产级和功能完整
<span class="hljs-bullet">-</span> 视觉冲击力和令人难忘
<span class="hljs-bullet">-</span> 具有清晰美学观点的连贯性
<span class="hljs-bullet">-</span> 每个细节都精心打磨

<span class="hljs-section">## 前端美学指南</span>

专注于：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**字体排版**</span>：选择美观、独特、有趣的字体。避免通用字体如 Arial 和 Inter；选择能够提升前端美学的独特字体；出人意料、有个性的字体选择。将独特的展示字体与精致正文字体搭配。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**色彩与主题**</span>：致力于连贯的美学。使用 CSS 变量保持一致性。主色调搭配锐利点缀色胜过胆怯、均匀分布的调色板。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**动效**</span>：使用动画实现效果和微交互。HTML 优先使用纯 CSS 方案。React 可用时使用 Motion 库。专注于高影响力时刻：一个精心编排的页面加载配合交错显示（animation-delay）比分散的微交互带来更多愉悦。使用滚动触发和令人惊喜的悬停状态。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**空间构图**</span>：意想不到的布局。不对称。重叠。对角线流动。打破网格的元素。充足的负空间<span class="hljs-strong">**或**</span>控制的密度。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**背景与视觉细节**</span>：创造氛围和深度，而非默认纯色。添加与整体美学匹配的上下文效果和纹理。应用创意形式如渐变网格、噪点纹理、几何图案、分层透明、戏剧性阴影、装饰性边框、自定义光标和颗粒叠加。

永远不要使用通用的 AI 生成美学，如过度使用的字体家族（Inter、Roboto、Arial、系统字体）、陈词滥调的配色方案（特别是白色背景上的紫色渐变）、可预测的布局和组件模式，以及缺乏上下文特性的千篇一律设计。

富有创意地诠释并做出出人意料的选择，让人感觉真正为上下文而设计。没有设计应该是相同的。在明暗主题、不同字体、不同美学之间变化。永远不要跨越世代趋同于常见选择（例如 Space Grotesk）。

<span class="hljs-strong">**重要**</span>：将实现复杂度与美学愿景匹配。极繁主义设计需要包含大量动画和效果的复杂代码。极简或精致设计需要克制、精确，并仔细关注间距、字体和微妙细节。优雅来自于良好地执行愿景。

记住：Claude 能够创造非凡的创意作品。不要退缩，展示当跳出思维定势并完全致力于独特愿景时，真正能创造什么。
</code></pre>
<h3 data-id="heading-10">第三步：使用Skill</h3>
<p>我们写一个前端html页面，刚好满足这个Skill，看下AI如何操作吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61ad47b1f8744996ab1d898759babf3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=6HnIquCrBV%2BHYJfmqVk17y7lgtU%3D" alt="" loading="lazy"/></p>
<p>可以看到AI自己自动使用Skill，接下来我们看一下页面的效果吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc64e64a445847bbbff04545f870d821~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=fJxW27jONiCVsEPno1mANSUrOgI%3D" alt="" loading="lazy"/></p>
<p>还是比较好看的</p>
<h2 data-id="heading-11">三、推荐开源 Skills及如何下载使用</h2>
<p>以下是 GitHub 上最热门的 Skills 仓库，下载后按照需要将对应的Skill导入到 <code>.codebuddy/skills/</code> 目录：</p>
<h3 data-id="heading-12">开源Skills</h3>
<blockquote>
<h4 data-id="heading-13">1. <strong>anthropics/skills</strong>（官方，必装）</h4>
<ul>
<li><strong>Star</strong>: 40k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></li>
<li><strong>亮点</strong>：官方出品，包含文档处理（PDF/Word/Excel/PPT）、skill-creator（创建 Skill 的 Skill）、MCP 构建器等。新手入门首选。</li>
</ul>
</blockquote>
<h4 data-id="heading-14">2. <strong>obra/superpowers</strong>（社区最强）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 22k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a></li>
<li><strong>亮点</strong>：包含 20+ 实战技能，涵盖 TDD 测试驱动开发、Debug 调试模式、团队协作规范等，非常接地气。</li>
</ul>
</blockquote>
<h4 data-id="heading-15">3. <strong>vercel-labs/agent-skills</strong>（前端专属）</h4>
<blockquote>
<ul>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel-labs%2Fagent-skills" target="_blank" title="https://github.com/vercel-labs/agent-skills" ref="nofollow noopener noreferrer">github.com/vercel-labs…</a></li>
<li><strong>亮点</strong>：Vercel 团队维护，包含 <code>react-best-practices</code> 和 <code>vue-best-practices</code>，整理了 40+ 条 React/Next.js 性能与架构规则，AI 写代码时会主动提示性能陷阱。</li>
</ul>
</blockquote>
<h4 data-id="heading-16">4. <strong>K-Dense-AI/claude-scientific-skills</strong>（科研专属）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 5.8k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FK-Dense-AI%2Fclaude-scientific-skills" target="_blank" title="https://github.com/K-Dense-AI/claude-scientific-skills" ref="nofollow noopener noreferrer">github.com/K-Dense-AI/…</a></li>
<li><strong>亮点</strong>：140+ 科学领域技能，生物、化学、数据分析、文献整理全覆盖，研究人员必备。</li>
</ul>
</blockquote>
<h4 data-id="heading-17">5. <strong>ComposioHQ/awesome-claude-skills</strong>（资源合集）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 19k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FComposioHQ%2Fawesome-claude-skills" target="_blank" title="https://github.com/ComposioHQ/awesome-claude-skills" ref="nofollow noopener noreferrer">github.com/ComposioHQ/…</a></li>
<li><strong>亮点</strong>：Awesome 列表形式，汇集了官方和社区的各种 Skills，分类清晰，持续更新。</li>
</ul>
</blockquote>
<h3 data-id="heading-18"><strong>导入方法</strong>：</h3>
<ul>
<li><strong>CodeBuddy</strong> <strong>IDE</strong>：设置 → Skill 配置路径 → 导入本地文件夹</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c67b033257584487b2cb671da8e6ffcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=axxYAgivrObZiTrbkt0pPc2fco4%3D" alt="" loading="lazy"/></p>
<p>下载Skills，这里我是下载的第一个开源项目的所有的Skills</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4908fe0749a1430399b886710b293e11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=k16fcVv7YABX5oFk9Jdl4pWYvu0%3D" alt="" loading="lazy"/></p>
<p>选中你所需要的一条Skill导入CodeBuddy即可</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e34c1aa35244f1eaf7a4d6183a0744b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=uA8%2FqOUN6daxIsIPEZm262j6Ah4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76f2098873f244f4af5b541fb8e1a4af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=TmIH4TjSfrtUNjKjSFyl6uOk86w%3D" alt="" loading="lazy"/></p>
<p>可以看到导入成功了</p>
<p>其实刚才最开始的示例我也是直接复制的这个开源项目的Skill才使得前端页面生成比较好看</p>
<h2 data-id="heading-19">四、Skills与MCP的区别</h2>
<p>最后就是很多人会混淆Skills和MCP，它们确实有相似之处，但解决的问题完全不同：</p>



































<table><thead><tr><th>对比维度</th><th>Skills</th><th>MCP</th></tr></thead><tbody><tr><td>核心定位</td><td>解决"方法论"问题，教AI怎么做某类任务</td><td>解决"连接"问题，让AI能访问外部世界</td></tr><tr><td>加载方式</td><td>按需加载，只加载技能名字和描述，使用时才加载执行细节</td><td>全量加载，不管用不用都全部加载进去</td></tr><tr><td>适用场景</td><td>固定工作流程，需要AI按步骤执行</td><td>访问外部数据或服务，深度集成外部系统</td></tr><tr><td>输入输出</td><td>自然语言描述和结果，灵活易读</td><td>JSON结构化参数和结果，可组合可测试</td></tr><tr><td>扩展性</td><td>可以无限增加技能，不会明显拖慢对话</td><td>工具越多，上下文越爆炸，成本和延迟越高</td></tr></tbody></table>
<p><strong>大白话理解</strong>：</p>
<blockquote>
<ul>
<li>Skills主要聚焦于工具处理，是一套完整的方法论，例如处理文件、设计、写文章</li>
<li>MCP主要起到连接作用，适合深度集成外部系统，自定义上传、下载、推送等流程</li>
</ul>
</blockquote>
<p>两者并不是竞争或替代的关系，而是结合关系。对于普通用户、日常工作，大部分时候只需要Skills就足够；对于复杂的企业场景、跨平台/自动分发等任务，使用Skills + MCP可以实现更加稳定和高效的输出。</p>
<p><strong>什么时候用Skills，什么时候用</strong> <strong>mcp</strong> <strong>？</strong></p>
<p>判断标准：任务是"如何做"还是"做什么"？</p>
<blockquote>
<ul>
<li>
<p><strong>Skills</strong>：当你有固定的工作流程，需要AI按步骤执行时</p>
<ul>
<li>示例："按什么格式写技术教程"、"代码审查的5个步骤"</li>
</ul>
</li>
<li>
<p><strong>MCP</strong>：当你需要AI访问外部数据或服务时</p>
<ul>
<li>示例："查询GitHub的Issue"、"读取SQLite数据库"</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>感兴趣的宝子可以关注一波，后续会更新更多有用的知识！！！</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94d92b4ed927471ba156d58f7dd69c7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=mLWFttNhmqNRforBOjGFITujbJs%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析]]></title>    <link>https://juejin.cn/post/7602205524718927906</link>    <guid>https://juejin.cn/post/7602205524718927906</guid>    <pubDate>2026-02-03T10:07:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718927906" data-draft-id="7602246300453306403" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析"/> <meta itemprop="keywords" content="源码"/> <meta itemprop="datePublished" content="2026-02-03T10:07:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:36.000Z" title="Tue Feb 03 2026 10:07:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Go errgroup</h2>
<p>专门用于简化一组 goroutine 的生命周期管理和错误收集，解决了普通<code>WaitGroup</code>无法便捷收集错误、无法快速取消其他 goroutine 的痛点。</p>
<h2 data-id="heading-1">errgroup vs 原生 WaitGroup</h2>






























<table><thead><tr><th align="center">特性</th><th align="center">sync.WaitGroup</th><th align="center">errgroup</th></tr></thead><tbody><tr><td align="center">等待 goroutine 结束</td><td align="center">需要手动 Add/Done</td><td align="center">自动管理，无需手动调用</td></tr><tr><td align="center">收集错误</td><td align="center">需要自己用 channel 实现</td><td align="center">自动收集第一个非 nil 错误</td></tr><tr><td align="center">取消其他 goroutine</td><td align="center">需要自己结合 Context 实现</td><td align="center">内置 Context，自动取消</td></tr><tr><td align="center">使用复杂度</td><td align="center">低（但扩展功能复杂）</td><td align="center">中（一站式解决多 goroutine 问题）</td></tr></tbody></table>
<h2 data-id="heading-2">使用示例</h2>
<p>下面代码是 通过开启三个 goroutine 并发执行，能够感知错误，并且便捷收集第一个错误</p>
<p><code>context.Cause(ctx)</code>  这个函数是专门用来获取 Context 取消原因的，后续会详细介绍</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"golang.org/x/sync/errgroup"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	eg, ctx := errgroup.WithContext(context.Background())
	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		fmt.Println(<span class="hljs-string">"doing task1"</span>)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"task1 error"</span>) <span class="hljs-comment">// 业务错误：作为取消原因 这边取消 其他 goroutine  就会走 &lt;-ctx.Done()</span>
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task2"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task2 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因 </span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task2 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()  <span class="hljs-comment">//这时候 return 的错误 是第二次或者第三次了 我们只记录第一次的</span>
			}
		}
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task3"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task3 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因</span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task3 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()
			}
		}
	})

	err := eg.Wait()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"task failed"</span>)
		<span class="hljs-comment">// 在 Wait() 后, 返回第一次错误</span>
		fmt.Printf(<span class="hljs-string">"整体任务被取消的原因：%v\n"</span>, err)
	} <span class="hljs-keyword">else</span> {
		fmt.Println(<span class="hljs-string">"task success"</span>)
	}
}

</code></pre>
<h2 data-id="heading-3">errgroup 源码解析</h2>
<h3 data-id="heading-4">内部结构体</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 空结构体在 Go 中不占用字节内存，是标准用于通知的</span>
<span class="hljs-keyword">type</span> token <span class="hljs-keyword">struct</span>{}

<span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> {
	cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">error</span>)</span></span>  <span class="hljs-comment">//  取消下级关联 Context 的函数</span>

	wg sync.WaitGroup  <span class="hljs-comment">// 管理 goroutine 的等待，替代手动 Add/Done</span>

	sem <span class="hljs-keyword">chan</span> token  <span class="hljs-comment">// 带缓冲的通道 限制最大能有几个 goroutine 并行 用 SetLimit 函数去指明 不用这个函数那这个字段就不用管</span>

	errOnce sync.Once  <span class="hljs-comment">// 原子语句  无论多少 goroutine 写入 都只执行一次 </span>
	err     <span class="hljs-type">error</span>
}

</code></pre>
<h3 data-id="heading-5">入口函数</h3>
<p>新版本使用了 <code>WithCancelCause</code>  换掉了传统的 <code>context.WithCancel</code></p>
<p>对于  <code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 放在文章最后，深入理解 <code>context</code>  可阅读</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span></span> (*Group, context.Context) {
    <span class="hljs-comment">//返回 子Context 和 可以取消的函数  这里覆盖了主 ctx 无所谓</span>
	ctx, cancel := context.WithCancelCause(ctx)
 	<span class="hljs-comment">// 返回 errgroup 内置 结构体 和 context</span>
	<span class="hljs-keyword">return</span> &amp;Group{cancel: cancel}, ctx
}

</code></pre>
<h3 data-id="heading-6"><code>(g *Group) SetLimit(n int)</code> 函数</h3>
<p>用于控制同时活跃的 goroutine 数量，实现并发限制，小于0，就没有限制，也就不用 <code>g.sem</code> 字段</p>
<p>必须是在初始化的时候去调用 <code>SetLimit</code>  函数，必须保证当前无活跃 goroutine，否则直接 panic 为了安全</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> SetLimit(n <span class="hljs-type">int</span>) {
	<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> {
		g.sem = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-keyword">if</span> active := <span class="hljs-built_in">len</span>(g.sem); active != <span class="hljs-number">0</span> {
		<span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">"errgroup: modify limit while %v goroutines in the group are still active"</span>, active))
	}
    <span class="hljs-comment">// 启动 容量为 n 的 cannel </span>
	g.sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> token, n)
}

</code></pre>
<h3 data-id="heading-7"><code>(g *Group) done()</code> 函数</h3>
<p>本质对 <code>WaitGroup</code> 封装了一个 对 goroutine 数量限制 不设置的话 就相当于 <code>WaitGroup.Done()</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> done() {
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">// 如果设置了goroutine数量限制</span>
		&lt;-g.sem       <span class="hljs-comment">// 释放信号量，从sem通道取出一个token，允许新的goroutine启动</span>
	}
	g.wg.Done()       <span class="hljs-comment">// 通知 WaitGroup：一个goroutine执行完成</span>
}
</code></pre>
<h3 data-id="heading-8"><code>(g *Group) Wait()</code> 函数</h3>
<p>同样也是多封装了一下 调用 <code>cancel(g.err) </code>方法 去记录错误（如果有的话） 内部具体细节可以看最后源码</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Wait() <span class="hljs-type">error</span> {
	g.wg.Wait()          <span class="hljs-comment">// 阻塞，直到所有goroutine调用了wg.Done()</span>
	<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 如果绑定了Context（通过WithContext创建）</span>
		g.cancel(g.err)  <span class="hljs-comment">// 取消Context，传递错误作为取消原因</span>
	}
	<span class="hljs-keyword">return</span> g.err         <span class="hljs-comment">// 返回第一个非nil错误（无错误则返回nil）</span>
}
</code></pre>
<h3 data-id="heading-9">核心 <code>(g *Group) Go</code> 函数</h3>
<p>这里并没有捕获 <code>panic</code> ，如果捕捉的话可能导致 <code>panic</code> 时机延迟，调试困难，<code>panic</code> 栈会被转为普通值，无法被监控工具捕获，而且还可能导致死锁</p>
<p>比如 两个<code>goroutine</code>被创建 第一个发生 <code>panic </code>第二个在阻塞等待，<code>Wait</code> 需要等待两个任务结束才返回，死锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Go(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) {
	<span class="hljs-comment">// 若设置了goroutine数量限制，先获取信号量 如果已经满了 阻塞直到有空闲token</span>
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		g.sem &lt;- token{} <span class="hljs-comment">// 发送空token到sem通道，占用一个并发名额</span>
	}

	<span class="hljs-comment">// 增加WaitGroup计数</span>
	g.wg.Add(<span class="hljs-number">1</span>)
	
	<span class="hljs-comment">// 启动新goroutine执行任务</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">defer</span> g.done() <span class="hljs-comment">// 最后执行无论错误还是正常</span>

		<span class="hljs-comment">// 执行用户传入的函数，获取错误</span>
		<span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 仅第一次执行  保证只存第一个错误</span>
			g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
				g.err = err          <span class="hljs-comment">// 存储第一个错误</span>
				<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 若绑定了Context，取消所有关联 goroutine 大部分都会有的 因为我们在入口传了</span>
					g.cancel(g.err)
				}
			})
		}
	}()
}

<span class="hljs-comment">// 这个函数和 Go 的唯一区别就是 它不阻塞 一旦数量满了 直接退出</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> TryGo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> {
    	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> g.sem &lt;- token{}: <span class="hljs-comment">// 成功获取token</span>
		<span class="hljs-keyword">default</span>:               <span class="hljs-comment">// 无空闲token  并发数达上限，直接返回false</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		}
	}
    ...  <span class="hljs-comment">//逻辑一样</span>
}

</code></pre>
<h2 data-id="heading-10">Context 部分源码</h2>
<h3 data-id="heading-11"><code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 区别</h3>
<p>简单理解就是在返回 <code>cancel</code>函数的时候多了一个参数而已</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancelCause</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cause <span class="hljs-type">error</span>)</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, cause) }
}

</code></pre>
<h3 data-id="heading-12">先介绍核心结构体 <code>cancelCtx</code>  和 <code>cancelCtx.cancel</code> 方法</h3>
<p><code>context.WithCancel</code> 和 <code>context.WithCancelCause</code> 以及 <code>context.WithTimeout</code> 都有它的影子</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 核心结构体 cancelCtx</span>
<span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> {
	Context          <span class="hljs-comment">//       嵌入父Context，继承父Context的所有方法（Done/Err/Value等）  该字段是个接口</span>
	mu       sync.Mutex            <span class="hljs-comment">// 保护以下字段的并发读写安全</span>
	done     atomic.Value       <span class="hljs-comment">// 存储chan struct{}，负责通知外部阻塞函数 查看 Done方法 和 Cancel 方法 之后就明白</span>
	children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{} <span class="hljs-comment">// 存储当前Context的子canceler，取消时会遍历取消所有子Context</span>
	err      atomic.Value          <span class="hljs-comment">// 存储取消时的错误（如context.Canceled），原子操作避免锁竞争</span>
	cause    <span class="hljs-type">error</span>                 <span class="hljs-comment">// WithCancelCause的核心 ：存储取消原因，仅在第一次取消时赋值</span>
}

<span class="hljs-comment">// context包内部的接口，定义了「可取消」的行为</span>
<span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> {
	cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>, cause <span class="hljs-type">error</span>)
	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{}
}
</code></pre>
<h3 data-id="heading-13">核心方法 <code>cancelCtx.cancel</code></h3>
<p>这个函数 是写方法，使用频率是极低的 可能就是手动 cancel 或者 父 context 进行 cancel，为了防止并发问题也就是同时进行 <code>c.err.Load()</code> 发现没有，然后都执行了 <code>c.err.Store(err)</code> 是有问题的 我们只记录第一次 而且后面 <code>close(d)</code> 会报错，这里必须用锁，也不会影响性能</p>
<p>读方法 <code>Err()、Done()</code> 方法 常见 <code>for + select</code> 可能每个 goroutine 每毫秒跑几万次，这种就不能加锁，太影响性能 这个时候就体现出来 <code>atomic.Value </code> 这个字段的好处，防止一个 goroutine 在 <code>cancel() </code>里写 <code>c.err</code>，另一个 goroutine 同时在 Err() 里读 <code>c.err</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// Context 设计原则：取消必须关联错误</span>
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"context: internal error: missing cancel error"</span>)
    }
    
    <span class="hljs-comment">// 旧版本 并没有 WithCancelCause 也就没有这个字段 兼容 旧逻辑</span>
    <span class="hljs-keyword">if</span> cause == <span class="hljs-literal">nil</span> {
        cause = err
    }

    <span class="hljs-comment">// 上面已经解释</span>
    c.mu.Lock()
    <span class="hljs-comment">// 看一下 里面有没有数据</span>
    <span class="hljs-keyword">if</span> c.err.Load() != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//原子地把值拿出来</span>
        c.mu.Unlock()
        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 说明有数据 已经写过了 只要写过了 就一定是在这个函数中写的 说明运行过一次 直接return</span>
    }

    <span class="hljs-comment">// 到这说明第一次进 cancel 方法 写入错误下一个 goroutine 再来调用 直接 return</span>
    c.err.Store(err)   <span class="hljs-comment">// 原子操作：高频读取时无需加锁，性能更优</span>
    c.cause = cause    <span class="hljs-comment">// 保证了仅第一次赋值有效  因为第二次直接 return </span>

    
    <span class="hljs-comment">// 关闭取消信号通道，用于通知外部 select { case &lt;-ctx.Done(): } 消除阻塞</span>
    d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 懒创建 下面会详细讲</span>
        c.done.Store(closedchan)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 若 done 通道已创建，关闭通道 消除阻塞</span>
        <span class="hljs-built_in">close</span>(d)
    }

    <span class="hljs-comment">// 递归取消所有子 Context</span>
    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children {
        <span class="hljs-comment">// 持有父锁时获取子锁会有嵌套锁风险，但 Context 取消是低频操作，可接受 </span>
        child.cancel(<span class="hljs-literal">false</span>, err, cause)
    }
    <span class="hljs-comment">// 清空子列表，释放内存，避免泄漏</span>
    c.children = <span class="hljs-literal">nil</span>

    <span class="hljs-comment">//解锁</span>
    c.mu.Unlock()

    <span class="hljs-comment">// 基本上都是 True  默认移除 避免内存泄漏</span>
    <span class="hljs-keyword">if</span> removeFromParent {
        <span class="hljs-comment">// 从父 Context 移除自身</span>
        removeChild(c.Context, c)
    }
}

</code></pre>
<h3 data-id="heading-14">懒创建</h3>
<p>我们在写代码的时候，很少去写 <code>ctx.Done()</code>  方法，非常常见的两种，要么不用，要么只用  <code>cancel</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 第一种 不用</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ctx context.Context)</span></span> {
    time.Sleep(<span class="hljs-number">10</span> * time.Second)
}

<span class="hljs-comment">// 第二种 只 cancel</span>
ctx, cancel := context.WithCancel(parent)
<span class="hljs-keyword">defer</span> cancel()

doSomething(ctx) <span class="hljs-comment">// ctx 只是被传来传去</span>
</code></pre>
<p>正常逻辑是 建完 <code>ctx</code> 要使用 <code>Done()</code>方法</p>
<p>它进行了两次判断 其实可以进行一次 在刚开始进来的时候加锁就可以直接判断是否有值，可以一样的效果，但是这个函数读极多，就写一次，所以大多数情况下都直接返回，根本不需要锁，如果按刚开始就加锁，性能直线下降</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{} {  <span class="hljs-comment">//返回一个只能接收的 channel</span>
	d := c.done.Load() <span class="hljs-comment">//第一次读取</span>
	<span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">//之前已经调用过 Done() </span>
		<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
	}
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	d = c.done.Load() <span class="hljs-comment">// 第二次重新读取</span>
	<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 第一次 初始化并存入</span>
		d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
		c.done.Store(d)
	}
	<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
}
</code></pre>
<p>解释  <code> Done()</code>  是 极高频函数</p>
<p>go语言非常常见的 阻塞循环，每次执行 <code>ctx.Done()</code> 函数 返回的没有数据的 channel 只能走 default 逻辑，default 啥也不干 然后再回到 select 语句中 在执行 <code>ctx.Done()</code> 函数 直到 调用 <code>concel</code> 函数 ，可能每毫秒跑几万次，只第一次进行了修改，进行了两次判断，其他的都是直接返回，所以不能在刚开始进行加锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">for</span> {
    <span class="hljs-keyword">select</span> {
    <span class="hljs-keyword">case</span> &lt;-ctx.Done():
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">default</span>:
    }
}
</code></pre>
<h3 data-id="heading-15">深入 <code>withCancel</code> 函数</h3>
<p>我们都知道 <code>parent</code> 参数一般情况就是我们自己传的 <code>ctx</code> 可能是 <code>context.WithCancel</code> 或者 <code>context.Background</code></p>
<p>在标准项目或者大型项目中，在主要内部结构体中会定义 <code>cancel</code> 字段用于 优雅退出</p>
<p>如果 <code>parent</code> 是  <code>context.Background</code>  没啥意义，</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withCancel</span><span class="hljs-params">(parent Context)</span></span> *cancelCtx {
	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> {
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"cannot create context from nil parent"</span>)
	}
	<span class="hljs-comment">// 1. 创建空的cancelCtx实例</span>
	c := &amp;cancelCtx{}
	<span class="hljs-comment">// 2. 建立当前 cancelCtx 和父 Context 的关联，作用是父取消时，子也会被取消</span>
	c.propagateCancel(parent, c)
	<span class="hljs-keyword">return</span> c
}
</code></pre>
<h3 data-id="heading-16"><code>propagateCancel</code> 函数</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) {
	<span class="hljs-comment">// 挂载到字段 </span>
	c.Context = parent

	<span class="hljs-comment">// 查看 父Context是否可取消</span>
	done := parent.Done()
	<span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> 		<span class="hljs-comment">//  如果是 context.Background 无需关联，父永远不会取消，子只能手动取消</span>
	}

	<span class="hljs-comment">// 检查父Context是否已经取消  非阻塞</span>
	<span class="hljs-keyword">select</span> {
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-comment">// 父已取消：立即取消子Context，继承父的错误和原因  这里的child 也就是我们刚创建的  空的cancelCtx实例</span>
		child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">return</span>
	<span class="hljs-keyword">default</span>:  <span class="hljs-comment">// 父没取消  正常情况，在代码健壮的情况下 不太可能刚创建就取消了</span>
	}

	<span class="hljs-comment">// 断言 将父Context转为 *cancelCtx  几乎所有的Context 底层都有它的影子 这是最常见的</span>
	<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock() <span class="hljs-comment">// 加锁保证并发安全</span>
		<span class="hljs-keyword">if</span> err := p.err.Load(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 父已取消：立即取消刚创建的 cancelCtx实例</span>
			child.cancel(<span class="hljs-literal">false</span>, err.(<span class="hljs-type">error</span>), p.cause)
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// 父未取消：将子Context加入父的children列表 当父取消时会遍历取消子</span>
			<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//第一次需要创建</span>
				p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{})
			}
			p.children[child] = <span class="hljs-keyword">struct</span>{}{}
		}
		p.mu.Unlock()
		<span class="hljs-keyword">return</span>   <span class="hljs-comment">// 大多数到这返回了</span>
	}

	<span class="hljs-comment">// 特殊情况：父Context实现了afterFuncer接口（比如WithDeadline/WithTimeout）</span>
	<span class="hljs-keyword">if</span> a, ok := parent.(afterFuncer); ok {
		c.mu.Lock()
		<span class="hljs-comment">// 注册回调：父取消时，触发子取消</span>
		stop := a.AfterFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		})
		<span class="hljs-comment">// 包装父Context，记录stop函数（子取消时可停止回调）</span>
		c.Context = stopCtx{
			Context: parent,
			stop:    stop,
		}
		c.mu.Unlock()
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// 兜底方案：父Context不是cancelCtx也不是afterFuncer，但可取消（Done()≠nil） 自己实现的 Context</span>
	goroutines.Add(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> &lt;-parent.Done():
			<span class="hljs-comment">// 父取消时，取消子Context</span>
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">case</span> &lt;-child.Done():
			<span class="hljs-comment">// 子先取消，无需处理</span>
		}
	}()
}
</code></pre>
<h3 data-id="heading-17">核心函数 <code>context.Cause</code></h3>
<p><code>Cause</code> 是用户获取 Context 取消原因的 <strong>唯一入口</strong>， <code>errgroup</code> 在 <code>wait</code> 判断时，可以拿到第一个错误，你也可以调用这个函数拿到错误，阅读源码我们知道，<code>errgroup</code> 内部主动 <code>cancel(err)</code> 传入了错误，并存储在了 <code>cause</code> 当然可以用该函数拿出</p>
<p>后续可以通过 <code>cause := context.Cause(ctx)</code>  拿到错误</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(c Context)</span></span> <span class="hljs-type">error</span> {
    <span class="hljs-comment">// 每个 Context 都有 Value(key any) any 这个函数 </span>
	<span class="hljs-keyword">if</span> cc, ok := c.Value(&amp;cancelCtxKey).(*cancelCtx); ok {
		cc.mu.Lock()
		cause := cc.cause
		cc.mu.Unlock()
		<span class="hljs-keyword">if</span> cause != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> cause
		}
	}

	<span class="hljs-keyword">return</span> c.Err()
}

</code></pre>
<h3 data-id="heading-18"><code>Value</code> 函数</h3>
<p>其实就是递归向上找，我们这种情况直接返回，需要想上找的情况是自己存的业务 <code>key</code> ，后面会举例</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any {
	<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
		<span class="hljs-keyword">return</span> c
	}
	<span class="hljs-keyword">return</span> value(c.Context, key)
}

<span class="hljs-comment">// switch 所有的 已知的 context 找不到继续 向上找</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any {
	<span class="hljs-keyword">for</span> {
		<span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) {
		<span class="hljs-keyword">case</span> *valueCtx:
			<span class="hljs-keyword">if</span> key == ctx.key {
				<span class="hljs-keyword">return</span> ctx.val
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> *cancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> c
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> withoutCancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
			}
			c = ctx.c
		<span class="hljs-keyword">case</span> *timerCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> &amp;ctx.cancelCtx
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> backgroundCtx, todoCtx:  <span class="hljs-comment">// 空 emptyCtx</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">return</span> c.Value(key)
		}
	}
}
</code></pre>
<h3 data-id="heading-19">自定义业务 key</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义业务 key</span>
<span class="hljs-keyword">type</span> userKey <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 根 context，存入业务数据</span>
    ctx1 := context.WithValue(context.Background(), userKey{}, <span class="hljs-string">"张三"</span>)
    
    <span class="hljs-comment">// 在它基础上创建 cancelCtx</span>
    ctx2, cancel := context.WithCancel(ctx1)
    
    <span class="hljs-comment">// 再套一层 cancelCtx</span>
    ctx3, cancel2 := context.WithCancel(ctx2)
    
    <span class="hljs-comment">// 现在的结构：</span>
    <span class="hljs-comment">// Background (空)</span>
    <span class="hljs-comment">//    └── ctx1 (valueCtx, 存了 userKey="张三")</span>
    <span class="hljs-comment">//           └── ctx2 (cancelCtx)</span>
    <span class="hljs-comment">//                  └── ctx3 (cancelCtx)  ← 我们拿着这个</span>
    
    <span class="hljs-comment">// 查询业务数据：ctx3 本身没有，会递归向上找</span>
    user := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"找到用户:"</span>, user)  <span class="hljs-comment">// 输出: 找到用户: 张三</span>
    
    <span class="hljs-comment">// 即使 cancel 了，依然能找到</span>
    cancel2()
    cancel()
    
    user2 := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"cancel后:"</span>, user2)  <span class="hljs-comment">// 输出: cancel后: 张三</span>
}
</code></pre>
<h2 data-id="heading-20">总结</h2>
<p><code>errgroup</code> 是对  <code>sync.WaitGroup </code> 的增强封装，可以对 goroutine 数量限制 ，并且不需要显式的写<code>WaitGroup..Add(1)</code>，内部自动管理，防止漏写，出错自动 <code>cancel</code></p>
<p>如果自己相加业务逻辑 直接可以复制代码，按自己的需求添加字段或者函数</p>
<p>对于 <code>context</code> 源代码，要搞清楚当 <code>cancel</code> 后切断的是父对子的连接，但子有个字段专门存放父，这个并没有切断，才使得我们可以调用 <code>context.Cause</code> 方法一直向上找</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 内存机制与闭包原理深度剖析]]></title>    <link>https://juejin.cn/post/7602411521072087059</link>    <guid>https://juejin.cn/post/7602411521072087059</guid>    <pubDate>2026-02-03T10:02:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602411521072087059" data-draft-id="7602401081265504292" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 内存机制与闭包原理深度剖析"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:02:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NEXT06"/> <meta itemprop="url" content="https://juejin.cn/user/1176918763246011"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 内存机制与闭包原理深度剖析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176918763246011/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NEXT06
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:02:42.000Z" title="Tue Feb 03 2026 10:02:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常的前端开发中，我们往往专注于业务逻辑的实现，而忽略了 JavaScript 引擎底层的内存管理。作为一门高级语言，JavaScript 确实帮我们屏蔽了手动分配和释放内存的繁琐（如 C 语言中的 malloc 和 free），但这并不意味着我们可以完全无视内存机制。</p>
<p>你是否遇到过这样的困惑：为什么修改一个变量会莫名其妙地影响另一个变量？为什么看似执行完毕的函数，其内部变量却依然驻留在内存中？或者在性能优化时，面对内存泄漏束手无策？</p>
<p>这一切的答案，都隐藏在 JavaScript 的内存布局与闭包的底层实现之中。如果不理解这些底层原理，就很难写出高性能且健壮的代码。本文将结合 V8 引擎的实现机制，深入剖析 JS 的内存管理与闭包真相。</p>
<h2 data-id="heading-0">一、JS 的内存世界：栈与堆</h2>
<p>JavaScript 引擎（以 Chrome V8 为例）在执行代码时，会将内存划分为两个核心区域：<strong>栈内存（Stack）</strong>  和 <strong>堆内存（Heap）</strong> 。这种划分并非随意为之，而是为了在“执行效率”与“存储容量”之间找到平衡。</p>
<h3 data-id="heading-1">1. 栈内存（Stack）：执行的主战场</h3>
<p>栈内存主要用于存储<strong>基本数据类型</strong>（Number, String, Boolean, Undefined, Null, Symbol, BigInt）以及<strong>执行上下文（Execution Context）</strong> 。</p>
<ul>
<li><strong>特点</strong>：空间较小，内存地址连续。</li>
<li><strong>管理方式</strong>：遵循“后进先出”（LIFO）原则。</li>
<li><strong>优势</strong>：操作极快。V8 引擎只需移动栈顶指针（ESP），即可完成上下文的切换和内存的回收。</li>
</ul>
<p>由于 JavaScript 是单线程语言，主线程的调用栈切换非常频繁。如果栈内存过大或存储的数据结构过于复杂，会导致栈指针移动受阻，直接阻塞主线程，造成页面卡顿。因此，栈主要用于处理轻量级的数据和维持程序执行流。</p>
<h3 data-id="heading-2">2. 堆内存（Heap）：数据的仓库</h3>
<p>堆内存用于存储<strong>引用数据类型</strong>（Object, Array, Function 等）。</p>
<ul>
<li><strong>特点</strong>：空间巨大，内存地址不连续（杂乱）。</li>
<li><strong>管理方式</strong>：由垃圾回收器（GC）进行管理。</li>
<li><strong>劣势</strong>：内存分配和回收的开销较大。</li>
</ul>
<h3 data-id="heading-3">3. 代码实战：赋值行为的差异</h3>
<p>理解了栈和堆的区别，就能解释为什么不同类型的变量在赋值时表现截然不同。</p>
<p><strong>场景一：基本类型的赋值（值拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 1.js
function foo() {
    var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; </span>
    var <span class="hljs-attr">b</span> = a<span class="hljs-comment">; // 在栈中开辟新空间，将 1 拷贝给 b</span>
    <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;     // 修改 a，不影响 b</span>
    console.log(a)<span class="hljs-comment">; // 2</span>
    console.log(b)<span class="hljs-comment">; // 1</span>
}
foo()<span class="hljs-comment">;</span>
</code></pre>
<p>对于基本类型，变量直接在栈中存储其<strong>值</strong>。var b = a 执行的是<strong>完整的值拷贝</strong>，a 和 b 在内存中是完全独立的两个块。</p>
<p><strong>场景二：引用类型的赋值（地址拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-css" lang="css">// 对应 File <span class="hljs-number">2</span><span class="hljs-selector-class">.js</span>
function foo() {
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = {name: <span class="hljs-string">"极客时间"</span>}; // 堆中存储对象，栈中 <span class="hljs-selector-tag">a</span> 存储该对象的堆地址
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span>;                // 栈中 <span class="hljs-selector-tag">b</span> 复制了 <span class="hljs-selector-tag">a</span> 的地址指针
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.name</span> = "极客邦";         // 通过地址修改堆中的实体
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>); // {name: <span class="hljs-string">"极客邦"</span>}
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">b</span>); // {name: <span class="hljs-string">"极客邦"</span>}
}
foo();
</code></pre>
<p>对于引用类型，变量在栈中存储的是<strong>指向堆内存的地址（指针）</strong> ，真正的实体数据存在堆中。var b = a 仅仅是拷贝了这个指针。因此，a 和 b 指向同一个堆内存块，修改其中一个，必然影响另一个。</p>
<hr/>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07b90eda429f43ff9b5c9264ad6bb34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=MjXhPw77oW1s5brelPbQhI93vaU%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-4">二、动态类型的双刃剑</h2>
<p>JavaScript 是一门<strong>动态弱类型</strong>语言，这意味着变量本身没有类型，<strong>值</strong>才有类型，且类型可以在运行时改变。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 3.js
var bar<span class="hljs-comment">; </span>
<span class="hljs-attr">bar</span> = <span class="hljs-number">12</span><span class="hljs-comment">;           // Number</span>
<span class="hljs-attr">bar</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;    // String</span>
<span class="hljs-attr">bar</span> = {name: <span class="hljs-string">"G"</span>}<span class="hljs-comment">;  // Object</span>
</code></pre>
<p>相比之下，C 语言等静态语言在编译阶段就需要确定变量类型和内存大小：</p>
<p>C</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 4.c
int <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; // 编译期分配 4 字节</span>
char* <span class="hljs-attr">b</span> = <span class="hljs-string">"hello"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>对比分析</strong>：</p>
<ul>
<li><strong>静态语言</strong>：编译器知道 int 永远占 4 个字节，因此可以生成极其高效的内存指令。</li>
<li><strong>JavaScript</strong>：V8 引擎无法在编译期确定 bar 到底需要多少空间（可能是 8 字节的数字，也可能是巨大的对象）。</li>
</ul>
<p>为了应对这种动态性，V8 采用了复杂的**对象模型（Object Model）<strong>和</strong>隐藏类（Hidden Class）**技术，将易变的数据结构尽量标准化。这也解释了为什么在 JS 中不建议频繁更改对象的形状（如动态添加属性），因为这会破坏引擎的优化策略。</p>
<p>值得注意的是 JS 的一个历史遗留 Bug：</p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// "object"</span>
</code></pre>
<p>这是因为在 JS 的第一版实现中，使用低位二进制标签表示类型，000 开头表示对象，而 null 全是 0，导致被误判为 Object。为了兼容性，这个 Bug 被保留至今。</p>
<h2 data-id="heading-5">三、闭包的底层真相：逃逸的变量</h2>
<p>许多开发者对闭包的理解仅停留在“函数内部访问外部变量”。但从内存角度看，<strong>闭包的本质是变量从栈内存“逃逸”到了堆内存</strong>。</p>
<p>按照常规逻辑，函数执行完毕后，其执行上下文（Execution Context）会从调用栈弹出，栈上的局部变量应该被销毁。那么，闭包是如何让变量“活”下来的？</p>
<h3 data-id="heading-6">1. 预扫描与逃逸分析</h3>
<p>V8 引擎在执行代码前，会进行<strong>词法扫描（Scoping）</strong> 。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 6.html
function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">; // 外部变量</span>
    let <span class="hljs-attr">test1</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">test2</span> = <span class="hljs-number">2</span><span class="hljs-comment">;        // 未被内部函数引用</span>
    
    var <span class="hljs-attr">innerBar</span> = { 
        setName: function(newName){
            <span class="hljs-attr">myName</span> = newName<span class="hljs-comment">; // 引用 myName</span>
        },
        getName: function(){
            console.log(test1)<span class="hljs-comment">; // 引用 test1</span>
            return myName<span class="hljs-comment">;</span>
        }
    }
    return innerBar<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">bar</span> = foo()<span class="hljs-comment">;</span>
</code></pre>
<p><strong>执行过程深度剖析</strong>：</p>
<ol>
<li>
<p><strong>编译阶段</strong>：当编译 foo 函数时，引擎会快速扫描其内部函数（setName, getName）。</p>
</li>
<li>
<p><strong>闭包检测</strong>：引擎发现内部函数引用了 foo 作用域下的 myName 和 test1。</p>
</li>
<li>
<p><strong>堆内存分配</strong>：</p>
<ul>
<li>引擎判断这两个变量需要“长生不老”，于是不会把它们仅仅放在栈上。</li>
<li>引擎会在<strong>堆内存</strong>中创建一个专门的对象（通常称为 Closure Scope 或 Context Extension）。</li>
<li>myName 和 test1 被存储到这个堆对象中。</li>
<li><strong>注意</strong>：test2 没有被引用，所以它依然只留在栈上，随 foo 执行结束而销毁。</li>
</ul>
</li>
<li>
<p><strong>引用维持</strong>：foo 返回的 innerBar 对象中，包含了指向这个堆内存闭包对象的指针（即 [[Scopes]] 属性）。</p>
</li>
</ol>
<h3 data-id="heading-7">2. 执行结束后的内存状态</h3>
<p>当 foo() 执行完毕出栈后：</p>
<ul>
<li>foo 的执行上下文被销毁。</li>
<li>栈上的 test2 被销毁。</li>
<li><strong>堆上的闭包对象依然存在</strong>，因为 bar 变量引用了 innerBar，而 innerBar 引用了该闭包对象。</li>
</ul>
<p>这就是闭包的“魔法”：<strong>通过在堆中开辟空间，打破了栈内存的生命周期限制。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75b14f9933324377a46a6fcd9153272a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=cMPRizfOzCMZo96CW5pVH1zeUYA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">四、闭包实战与陷阱</h2>
<p>理解了内存模型，我们来看两个容易踩坑的实战题目。</p>
<h3 data-id="heading-9">题目 1：共享的闭包环境</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function createCounter() {
    let <span class="hljs-attr">count</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    return {
        increment: function() { count++<span class="hljs-comment">; },</span>
        get: function() { return count<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
}

const <span class="hljs-attr">counterA</span> = createCounter()<span class="hljs-comment">;</span>
const <span class="hljs-attr">counterB</span> = createCounter()<span class="hljs-comment">;</span>

counterA.increment()<span class="hljs-comment">;</span>
console.log(counterA.get())<span class="hljs-comment">; // 输出什么？</span>
console.log(counterB.get())<span class="hljs-comment">; // 输出什么？</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>输出：1 和 0。</li>
<li><strong>原因</strong>：每次调用 createCounter 都会创建一个<strong>新的</strong>执行上下文，并在堆中分配一个<strong>新的</strong>闭包对象。counterA 和 counterB 拥有各自独立的闭包环境，互不干扰。</li>
</ul>
<h3 data-id="heading-10">题目 2：引用的副作用</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;</span>
    var <span class="hljs-attr">inner</span> = {
        setName: function(name) { <span class="hljs-attr">myName</span> = name<span class="hljs-comment">; },</span>
        getName: function() { return myName<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
    return inner<span class="hljs-comment">;</span>
}

var <span class="hljs-attr">bar1</span> = foo()<span class="hljs-comment">;</span>
bar1.setName("极客邦")<span class="hljs-comment">;</span>
console.log(bar1.getName())<span class="hljs-comment">; // 输出 "极客邦"</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>这里 setName 和 getName 是定义在同一个 foo 调用中的。</li>
<li>它们共享同一个堆内存中的 Closure(foo) 对象。</li>
<li>setName 修改的是堆中那个唯一的 myName，所以 getName 读取到的也是修改后的值。</li>
</ul>
<p><strong>陷阱提示</strong>：这也意味着，如果不小心持有了对闭包的引用且不释放（例如将回调函数挂载到全局事件上），那么这个闭包对象及其引用的所有变量将永远驻留在堆内存中，造成<strong>内存泄漏</strong>。</p>
<h2 data-id="heading-11">五、总结</h2>
<p>JavaScript 的内存管理机制是其灵活性与性能之间的精妙平衡：</p>
<ol>
<li><strong>栈（Stack）</strong> ：负责程序执行的控制流和短期数据的存储，追求极致的速度。</li>
<li><strong>堆（Heap）</strong> ：负责长期大数据的存储，通过引用计数和标记清除等 GC 算法管理生命周期。</li>
<li><strong>闭包（Closure）</strong> ：本质是<strong>空间换时间</strong>。它牺牲了堆内存空间，换取了变量生命周期的延长和状态的封装。</li>
</ol>
<p>作为开发者，我们不需要手动 malloc 内存，但必须清晰地知道每一行代码背后，变量究竟是在栈上瞬息即逝，还是在堆中长久驻留。只有对内存保持敬畏，才能在享受 JavaScript 动态特性的同时，写出高效、稳定的应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter——页面跳转（路由、导航）]]></title>    <link>https://juejin.cn/post/7602440800295747630</link>    <guid>https://juejin.cn/post/7602440800295747630</guid>    <pubDate>2026-02-03T10:06:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295747630" data-draft-id="7602303923171426313" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter——页面跳转（路由、导航）"/> <meta itemprop="keywords" content="APP,Flutter"/> <meta itemprop="datePublished" content="2026-02-03T10:06:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Haha_bj"/> <meta itemprop="url" content="https://juejin.cn/user/2612027844214647"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter——页面跳转（路由、导航）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612027844214647/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Haha_bj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:06:17.000Z" title="Tue Feb 03 2026 10:06:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Flutter 开发中实现页面跳转的核心知识点。Flutter 提供了两种导航方式：<strong>基础导航（适用于简单场景、少量页面）</strong> 和 <strong>命名路由（适用于复杂场景、多页面应用）</strong></p>
<h3 data-id="heading-0">一、核心概念</h3>
<p>在 Flutter 中，所有页面都是「Widget」，导航的本质是「管理页面栈（Stack）」：</p>
<ul>
<li>「跳转页面」：将新页面「压入」栈顶（<code>push</code>）。</li>
<li>「返回页面」：将当前页面「弹出」栈顶（<code>pop</code>）。</li>
<li>Flutter 提供了 <code>Navigator</code> 组件来管理页面栈，日常开发中常用 <code>Navigator.of(context)</code> 来获取导航实例。</li>
</ul>
<hr/>
<h2 data-id="heading-1">方案 1：基础导航（直接跳转，简单高效）</h2>
<p>适用于 <strong>页面数量少（3-5 个）、无需传参 / 少量传参</strong> 的场景（如简单工具类 App），核心是 <code>Navigator.push()</code> 和 <code>Navigator.pop()</code>。</p>
<h3 data-id="heading-2">1.1 基本页面跳转（无参）</h3>
<h4 data-id="heading-3">步骤 1：定义两个页面 Widget（首页 + 详情页）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 导航示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      home: <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页</span>
    );
  }
}

<span class="hljs-comment">// 首页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：跳转至详情页（push 压入栈顶）</span>
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 目标页面</span>
              ),
            );
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'跳转到详情页'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 详情页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(
        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'详情页'</span>),
        <span class="hljs-comment">// 导航栏默认自带返回按钮，点击等价于 Navigator.pop()</span>
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：返回上一页（pop 弹出栈顶）</span>
            Navigator.pop(context);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-4">关键说明：</h4>
<ul>
<li><code>MaterialPageRoute</code>：Material 风格的路由过渡动画（Android 上下滑动、iOS 左右滑动），无需手动配置。</li>
<li><code>Navigator.push(context, route)</code>：将目标页面压入栈顶，实现跳转。</li>
<li><code>Navigator.pop(context)</code>：将当前页面弹出栈顶，返回上一页（无返回值）。</li>
<li>详情页的 <code>AppBar</code> 会默认添加返回按钮，点击后自动调用 <code>Navigator.pop()</code>，无需手动实现。</li>
</ul>
<h3 data-id="heading-5">1.2 页面传参（带参跳转 + 返回值传递）</h3>
<p>实际开发中常需要给下一页传参（如传递商品 ID），或接收下一页的返回值（如选择图片后返回图片路径）。</p>
<h4 data-id="heading-6">步骤 1：带参跳转（首页 → 详情页，传递字符串 / 数字）</h4>
<p>修改 <code>DetailPage</code> 增加构造函数接收参数，修改首页的跳转逻辑：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页（修改：添加构造函数接收参数）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title; <span class="hljs-comment">// 接收的标题参数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> id; <span class="hljs-comment">// 接收的ID参数</span>

  <span class="hljs-comment">// 构造函数（必填参数，也可设置可选参数）</span>
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(title)),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">$id</span>'</span>),
            <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">20</span>),
            ElevatedButton(
              onPressed: () {
                <span class="hljs-comment">// 返回上一页，并携带返回值（"从详情页返回的内容"）</span>
                Navigator.pop(context, <span class="hljs-string">"从详情页返回的内容"</span>);
              },
              child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页并传值'</span>),
            ),
          ],
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 首页（修改：带参跳转 + 接收返回值）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () <span class="hljs-keyword">async</span> {
            <span class="hljs-comment">// 异步接收返回值（await 等待 Navigator.push 执行完成）</span>
            <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(
                  title: <span class="hljs-string">'详情页（带参）'</span>,
                  id: <span class="hljs-number">1001</span>,
                ),
              ),
            );

            <span class="hljs-comment">// 打印返回值（详情页传递的内容）</span>
            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(<span class="hljs-string">'接收的返回值：<span class="hljs-subst">$result</span>'</span>)),
              );
            }
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'带参跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-7">关键说明：</h4>
<ol>
<li><strong>给下一页传参</strong>：通过目标页面的「构造函数」传递，支持所有 Dart 数据类型（字符串、数字、对象等）。</li>
<li><strong>接收下一页返回值</strong>：<code>Navigator.push()</code> 是异步操作，返回 <code>Future</code>，通过 <code>await</code> 可接收目标页面 <code>pop</code> 时传递的参数。</li>
<li><strong><code>Navigator.pop(context, result)</code></strong> ：第二个参数是返回值，可省略（无返回值时）。</li>
</ol>
<h2 data-id="heading-8">方案 2：命名路由（配置式跳转，适合复杂应用）</h2>
<p>适用于 <strong>页面数量多（5 个以上）、需要统一管理、频繁跳转</strong> 的场景（如电商、社交 App），核心是「提前配置路由表，通过路由名称跳转」。</p>
<h3 data-id="heading-9">2.1 基本配置与跳转（无参）</h3>
<h4 data-id="heading-10">步骤 1：在 <code>MaterialApp</code> 中配置 <code>routes</code> 路由表</h4>
<p>路由表是一个 <code>Map&lt;String, WidgetBuilder&gt;</code>，key 是路由名称（通常以 <code>/</code> 开头），value 是页面构建函数。</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      <span class="hljs-comment">// 1. 配置路由表</span>
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页（默认路由）</span>
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 详情页</span>
      },
      <span class="hljs-comment">// 2. 设置默认启动页面（等价于 home: const HomePage()）</span>
      initialRoute: <span class="hljs-string">'/'</span>,
    );
  }
}
</code></pre>
<h4 data-id="heading-11">步骤 2：通过路由名称跳转 / 返回</h4>
<p>修改首页的跳转逻辑，使用 <code>Navigator.pushNamed()</code> 替代 <code>Navigator.push()</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 首页</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：通过路由名称跳转</span>
            Navigator.pushNamed(context, <span class="hljs-string">'/detail'</span>);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'命名路由跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-12">关键说明：</h4>
<ul>
<li><code>routes</code>：路由表，统一管理所有页面，便于后期维护（修改页面只需修改路由表，无需修改所有跳转处）。</li>
<li><code>initialRoute</code>：默认启动路由（替代 <code>home</code>），必须和路由表中的某个 key 对应。</li>
<li><code>Navigator.pushNamed(context, '/detail')</code>：通过路由名称跳转，无需再创建 <code>MaterialPageRoute</code>。</li>
<li>返回逻辑不变，依然使用 <code>Navigator.pop(context)</code>。</li>
</ul>
<h3 data-id="heading-13">2.2 命名路由传参（带参跳转）</h3>
<p>命名路由传参有两种常用方式：<code>arguments</code> 传参（推荐）、路由名称拼接参数（不推荐，仅适用于简单参数）。</p>
<h4 data-id="heading-14">方式 1：<code>arguments</code> 传参（推荐，支持任意数据类型）</h4>
<ol>
<li>跳转时通过 <code>arguments</code> 传递参数：</li>
</ol>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 首页跳转逻辑修改</span>
<span class="hljs-title function_ invoke__">ElevatedButton</span>(
  <span class="hljs-attr">onPressed</span>: () {
    <span class="hljs-comment">// 传递参数（可传字符串、数字、Map、自定义对象等）</span>
    Navigator.<span class="hljs-title function_ invoke__">pushNamed</span>(
      context,
      <span class="hljs-string">'/detail'</span>,
      <span class="hljs-attr">arguments</span>: {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（命名路由传参）'</span>,
        <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>,
      },
    );
  },
  child: <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Text</span>(<span class="hljs-string">'命名路由带参跳转'</span>),
),
</code></pre>
<ol start="2">
<li>详情页通过 <code>ModalRoute.of(context)?.settings.arguments</code> 接收参数：</li>
</ol>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页修改</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">// 接收 arguments 参数</span>
    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args = ModalRoute.of(context)?.settings.arguments <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;

    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(args[<span class="hljs-string">'title'</span>])),
      body: Center(
        child: Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">${args[<span class="hljs-string">'id'</span>]}</span>'</span>),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-15">方式 2：路由名称拼接参数（仅适用于简单参数，如 ID）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 跳转时拼接参数</span>
Navigator.pushNamed(context, <span class="hljs-string">'/detail/1001'</span>);

<span class="hljs-comment">// 配置路由表时使用通配符</span>
routes: {
  <span class="hljs-string">'/detail/:id'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
},

<span class="hljs-comment">// 详情页提取参数（需额外解析，较繁琐，不推荐）</span>
<span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id = ModalRoute.of(context)?.settings.name?.split(<span class="hljs-string">'/'</span>).last ?? <span class="hljs-string">''</span>;
</code></pre>
<h3 data-id="heading-16">2.3 未知路由处理（404 页面）</h3>
<p>当跳转的路由名称不在路由表中时，会出现错误，可通过 <code>onUnknownRoute</code> 配置兜底页面（404 页面）：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
      },
      initialRoute: <span class="hljs-string">'/'</span>,
      <span class="hljs-comment">// 未知路由兜底</span>
      onUnknownRoute: (settings) {
        <span class="hljs-keyword">return</span> MaterialPageRoute(
          builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
        );
      },
    );
  }
}

<span class="hljs-comment">// 404 页面</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFoundPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> NotFoundPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'页面不存在'</span>)),
      body: <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'404 - 页面未找到'</span>)),
    );
  }
}
</code></pre>
<h2 data-id="heading-17">方案 3：进阶：路由管理（封装路由工具类）</h2>
<p>当项目页面非常多时，直接在 <code>MaterialApp</code> 中配置路由表会显得臃肿，推荐封装「路由工具类」，统一管理路由跳转、传参、拦截等逻辑。</p>
<h3 data-id="heading-18">3.1 封装路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/home_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/detail_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/not_found_page.dart'</span>;

<span class="hljs-comment">// 路由名称常量（避免硬编码，便于维护）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteNames</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> home = <span class="hljs-string">'/'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> detail = <span class="hljs-string">'/detail'</span>;
}

<span class="hljs-comment">// 路由工具类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteManager</span> </span>{
  <span class="hljs-comment">// 配置路由表</span>
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; routes = {
    RouteNames.home: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
    RouteNames.detail: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
  };

  <span class="hljs-comment">// 路由跳转（封装 pushNamed，统一处理传参）</span>
  <span class="hljs-keyword">static</span> Future&lt;T?&gt; pushNamed&lt;T&gt;(BuildContext context, <span class="hljs-built_in">String</span> routeName, {<span class="hljs-built_in">Object?</span> arguments}) {
    <span class="hljs-keyword">return</span> Navigator.pushNamed&lt;T&gt;(context, routeName, arguments: arguments);
  }

  <span class="hljs-comment">// 返回上一页（封装 pop，统一处理返回值）</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> pop&lt;T&gt;(BuildContext context, {T? result}) {
    Navigator.pop&lt;T&gt;(context, result);
  }

  <span class="hljs-comment">// 未知路由处理</span>
  <span class="hljs-keyword">static</span> Route&lt;<span class="hljs-built_in">dynamic</span>&gt; onUnknownRoute(RouteSettings settings) {
    <span class="hljs-keyword">return</span> MaterialPageRoute(
      builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
    );
  }
}
</code></pre>
<h3 data-id="heading-19">3.2 使用封装后的路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// MyApp 中配置</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 路由封装示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: RouteManager.routes,
      initialRoute: RouteNames.home,
      onUnknownRoute: RouteManager.onUnknownRoute,
    );
  }
}

<span class="hljs-comment">// 首页跳转</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pushNamed(
      context,
      RouteNames.detail,
      arguments: {<span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（封装路由）'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>},
    );
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'封装路由带参跳转'</span>),
),

<span class="hljs-comment">// 详情页返回</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pop(context, result: <span class="hljs-string">"从封装路由详情页返回"</span>);
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
),
</code></pre>
<h2 data-id="heading-20">关键补充：路由过渡动画自定义</h2>
<p>默认的 <code>MaterialPageRoute</code> 是 Material 风格动画，若需要自定义过渡动画（如淡入淡出、缩放），可使用 <code>PageRouteBuilder</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 自定义淡入淡出动画跳转</span>
Navigator.push(
  context,
  PageRouteBuilder(
    pageBuilder: (context, animation, secondaryAnimation) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      <span class="hljs-comment">// 淡入淡出动画</span>
      <span class="hljs-keyword">return</span> FadeTransition(
        opacity: animation,
        child: child,
      );
    },
    transitionDuration: <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">500</span>), <span class="hljs-comment">// 动画时长</span>
  ),
);
</code></pre>
<h3 data-id="heading-21">总结</h3>
<ol>
<li>Flutter 导航核心是「页面栈管理」，通过 <code>Navigator</code> 实现 <code>push</code>（跳转）和 <code>pop</code>（返回）。</li>
<li>简单场景用「基础导航」（<code>Navigator.push</code>），快速高效；复杂场景用「命名路由」（<code>Navigator.pushNamed</code>），便于统一管理。</li>
<li>传参方式：基础导航用「构造函数」，命名路由用「<code>arguments</code>」（推荐）。</li>
<li>最佳实践：页面较多时封装「路由工具类」，统一管理路由表、跳转、未知路由，提升项目可维护性。</li>
<li>自定义过渡动画可使用 <code>PageRouteBuilder</code>，满足个性化 UI 需求。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手写 React KeepAlive 组件：实现组件缓存与切换]]></title>    <link>https://juejin.cn/post/7602205524718944290</link>    <guid>https://juejin.cn/post/7602205524718944290</guid>    <pubDate>2026-02-03T10:09:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718944290" data-draft-id="7602225961095790626" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手写 React KeepAlive 组件：实现组件缓存与切换"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-02-03T10:09:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lIIIllIlIllIIl"/> <meta itemprop="url" content="https://juejin.cn/user/793196846923641"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手写 React KeepAlive 组件：实现组件缓存与切换
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/793196846923641/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lIIIllIlIllIIl
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:09:07.000Z" title="Tue Feb 03 2026 10:09:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 React 开发中，组件的<strong>频繁挂载和卸载</strong>往往会导致<strong>状态丢失和性能开销</strong>，尤其在 tab 切换或路由场景下。例如，当用户在不同视图间切换时，如果组件每次都重新渲染，内部的计数器、表单数据等状态就会重置，用户体验变差。为了解决这个问题，<code>React</code> 官方提供了 <code>&lt;KeepAlive&gt;</code> 组件，但理解其原理并手写实现，能帮助我们更深入掌握组件生命周期管理和状态缓存。本文将基于一个简单的计数器 tab 切换示例，详细讲解 <code>KeepAlive</code> 的手写过程。我们会使用对象作为缓存结构（类似于 Map），通过 <code>display</code> 属性<strong>控制组件显示隐藏</strong>，从而实现<strong>缓存活化</strong>。</p>
<h3 data-id="heading-0">KeepAlive 的核心原理</h3>
<p><code>KeepAlive</code> 的本质是<strong>缓存组件实例，避免卸载</strong>。它不像条件渲染（如 if 语句）那样销毁组件，而是将不活跃的组件“隐藏”起来，保留其状态。当切换回该组件时，直接显示即可，无需重新挂载。这涉及到 React 的渲染机制：组件可以通过 CSS 中 <code>display: none</code> <strong>隐藏</strong>，但仍保持在 DOM 中，生命周期钩子不会触发卸载。</p>
<p>为什么用缓存结构？因为需要存储多个组件。例如，在多 tab 场景下，每个 tab 对应一个组件，我们用一个键值对存储：key 为 tab ID，value 为组件 JSX。Map（ES6 新增的数据结构），它允许任意类型作为 key（如对象），而对象字面量的 key 只能是字符串。但在简单场景下，对象 {} 也能胜任，且更轻量。JSON 与此类似，都是 key-value，但 JSON 是字符串序列化形式，不适合直接作为缓存。</p>
<p>切换显示的逻辑：当 <code>activeId</code> 变化时，检查缓存中是否有对应组件；如果没有，添加当前 children；然后遍历缓存，渲染所有组件，但只显示 active 的那个。通过 Object.entries 将缓存转为二维数组 <code>[[key1, value1], [key2, value2]]</code>，便于 map 渲染。</p>
<p>这种设计提升了组件的复用性：父组件通过 <code>children</code> 传入任意内容，<code>KeepAlive</code> 只负责<strong>缓存和显示控制</strong>。props 如 <code>activeId</code> 用于标识当前活跃 tab。</p>
<h3 data-id="heading-1">示例场景：计数器 tab 切换</h3>
<p>假设我们有一个 <code>App</code> 组件，包含两个计数器视图 A 和 B。用户点击按钮切换 tab，我们希望切换时保留计数器状态，而不是重置为 0。以下是 <code>App.jsx</code> 的完整代码：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">KeepAlive</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/KeepAlive.jsx'</span>;


<span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">OtherCounter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}


<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [activeTab, setActiveTab] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'A'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{marginBottom:</span> '<span class="hljs-attr">20px</span>'}}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('A')}&gt;显示A组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('B')}&gt;显示B组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {/* children 提升组件的定制能力 给父组件方便 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">activeId</span>=<span class="hljs-string">{activeTab}</span>&gt;</span>
        { activeTab === 'A' ? <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"A"</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">OtherCounter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"B"</span> /&gt;</span> }
      <span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>
</code></pre>
<p>在这里，Counter 和 OtherCounter 是两个独立的计数器组件，使用 useEffect 记录挂载/卸载日志。App 通过 useState 管理 activeTab，按钮切换它。KeepAlive 包裹条件渲染的 children：当 activeTab 为 'A' 时渲染 Counter，否则 OtherCounter。</p>
<p>运行这个 App，如果没有 KeepAlive，切换 tab 时会看到控制台打印“卸载 A”和“挂载 B”，计数器重置。但有了 KeepAlive，只在首次渲染时挂载，以后切换只隐藏/显示，无卸载日志，状态保留。</p>
<h3 data-id="heading-2">手写 KeepAlive 组件</h3>
<p>现在，我们实现 KeepAlive.jsx。它使用 useState 存储缓存，useEffect 在 activeId 或 children 变化时更新缓存。渲染时遍历缓存，应用 display 样式。代码如下：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">KeepAlive</span> = (<span class="hljs-params">{
  activeId,
  children,
}</span>) =&gt; {
  <span class="hljs-keyword">const</span> [cache, setCache] = <span class="hljs-title function_">useState</span>({});  <span class="hljs-comment">// 缓存组件的</span>
  <span class="hljs-comment">// console.log(children, "--------");</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// activeId updata 切换显示</span>
    <span class="hljs-comment">// children updata 保存</span>
    <span class="hljs-keyword">if</span> (!cache[activeId]) {  <span class="hljs-comment">// activeId key</span>
      <span class="hljs-title function_">setCache</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> ({
        ...pre,
        [activeId]: children
      }))
    }
    <span class="hljs-comment">// console.log(cache, "????????");</span>
  }, [activeId, children, cache])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      {
        // Object.entries 对象变成数组
        // [key, value] 又方便使用
        Object.entries(cache).map(([id, components]) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{id}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{display:</span> <span class="hljs-attr">id</span> === <span class="hljs-string">activeId</span> ? '<span class="hljs-attr">block</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">none</span>'}}
          &gt;</span>
            {components}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ))
      }
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">KeepAlive</span>
</code></pre>
<p>剖析代码：</p>
<ul>
<li>useState({}) 初始化 cache 为空对象。</li>
<li>useEffect 依赖 [activeId, children, cache]：当这些变化时，检查 cache 是否有 activeId；如果没有，添加 children 到 cache。</li>
<li>渲染部分：使用 Object.entries(cache) 转为 [[id, components]] 数组，map 渲染每个缓存项。每个项包裹在 div 中，key 为 id（确保唯一），style 根据 id === activeId 设置 display: block 或 none。</li>
<li>注释解释了 Object.entries 的作用：将对象拆成易迭代的二维数组。</li>
</ul>
<p>这个实现简单有效。首次切换到 'A' 时，cache 添加 {'A':  }，渲染 div display: block。切换 'B' 时，添加 {'B':  }，现在渲染两个 div：A 为 none，B 为 block。组件实例保留，状态不丢。</p>
<p>总结，手写 KeepAlive 考察了对 React 状态、effect 和渲染的理解。通过缓存和 display 控制，我们实现了高效组件复用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[新手必看｜5个Python基础语法避坑技巧（附代码示例）]]></title>    <link>https://juejin.cn/post/7602246300453126179</link>    <guid>https://juejin.cn/post/7602246300453126179</guid>    <pubDate>2026-02-03T09:30:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300453126179" data-draft-id="7602188264114962447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="新手必看｜5个Python基础语法避坑技巧（附代码示例）"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-03T09:30:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="躺平大鹅"/> <meta itemprop="url" content="https://juejin.cn/user/2455634286221657"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            新手必看｜5个Python基础语法避坑技巧（附代码示例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2455634286221657/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    躺平大鹅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T09:30:32.000Z" title="Tue Feb 03 2026 09:30:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为刚入门编程的新手，Python基础语法看似简单，但很容易在细节上踩坑，导致代码报错、运行异常，既影响效率又打击积极性。今天整理了5个最常见的Python语法避坑点，搭配可直接复制运行的代码示例，新手看完就能避开90%的基础错误，快速夯实基础～</p>
<h3 data-id="heading-0">一、缩进错误（最高频！）</h3>
<p>Python的缩进不是“可选装饰”，而是语法的一部分，这和Java、C++的括号分隔不同，新手最容易忽略缩进规范，导致IndentationError。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 缩进不一致，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 统一使用4个空格缩进（CSDN规范）</span>
    
</code></pre>
<p>💡 避坑技巧：固定使用4个空格缩进（不要用Tab键，避免不同编辑器显示异常），IDE（如PyCharm、VS Code）可设置“Tab自动转为4个空格”，从根源避免缩进问题。</p>
<h3 data-id="heading-1">二、变量命名规范（避免语法报错+提高可读性）</h3>
<p>Python变量命名有明确规则，新手容易使用关键字、特殊符号，导致代码无法运行，同时混乱的命名会让后续调试变得困难。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">123name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 不能以数字开头</span>
name@age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 不能包含@、#等特殊符号（下划线_除外）</span>
<span class="hljs-keyword">if</span> = <span class="hljs-number">5</span>           <span class="hljs-comment"># 不能使用关键字（if、for、while等）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">user_name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 小写字母+下划线（蛇形命名法，Python推荐）</span>
user_age = <span class="hljs-number">20</span>
flag = <span class="hljs-number">5</span>
    
</code></pre>
<h3 data-id="heading-2">三、中英文符号混淆（隐蔽性极强！）</h3>
<p>这是新手最容易踩的“隐形坑”，中英文的括号、引号、逗号看起来相似，但Python只识别英文符号，一旦用了中文符号，就会报SyntaxError，却很难快速找到问题所在。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(“Hello Python”)  <span class="hljs-comment"># 中文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>：            <span class="hljs-comment"># 中文冒号</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello Python"</span>)  <span class="hljs-comment"># 英文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>:            <span class="hljs-comment"># 英文冒号</span>
    
</code></pre>
<p>💡 避坑技巧：编程时固定切换到英文输入法，IDE可安装“中英文符号检测插件”，实时提醒错误。</p>
<h3 data-id="heading-3">四、列表/字典索引取值错误</h3>
<p>Python中列表、字典是最常用的数据结构，新手容易出现“索引越界”“字典键不存在”的错误，尤其是循环取值时。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 列表索引从0开始，不是1</span>
list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># 列表长度为4，最大索引是3，报错</span>

<span class="hljs-comment"># 字典取值时，键不存在报错</span>
dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])  <span class="hljs-comment"># 键gender不存在，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">3</span>])  <span class="hljs-comment"># 取最后一个元素，索引3</span>

dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-comment"># 方法1：判断键是否存在</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">"gender"</span> <span class="hljs-keyword">in</span> dict1:
    <span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])
<span class="hljs-comment"># 方法2：使用get()方法，不存在返回默认值None</span>
<span class="hljs-built_in">print</span>(dict1.get(<span class="hljs-string">"gender"</span>))
    
</code></pre>
<h3 data-id="heading-4">五、循环中修改可迭代对象（容易导致死循环/漏值）</h3>
<p>新手在for循环中，经常直接修改列表、字典等可迭代对象，导致循环次数异常、漏取元素，甚至死循环。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 循环中删除列表元素，导致漏值</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 预期[1,3,5]，实际[1,3,5]（此处看似正确，复杂场景会漏值）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 遍历列表副本，修改原列表</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1[:]:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 正确输出[1,3,5]</span>
    
</code></pre>
<h3 data-id="heading-5">最后</h3>
<p>Python基础语法的坑，大多集中在细节上，新手只要多注意规范、多练习，就能快速避开。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉树解题心法：从思维到实战，一文理解所有核心考点]]></title>    <link>https://juejin.cn/post/7602420156397142059</link>    <guid>https://juejin.cn/post/7602420156397142059</guid>    <pubDate>2026-02-03T10:20:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397142059" data-draft-id="7602488966609371174" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉树解题心法：从思维到实战，一文理解所有核心考点"/> <meta itemprop="keywords" content="JavaScript,后端,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:20:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉树解题心法：从思维到实战，一文理解所有核心考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:20:35.000Z" title="Tue Feb 03 2026 10:20:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉树解题心法：从思维到实战，一文理解所有核心考点</h2>
<p>二叉树是算法面试的<strong>核心基础考点</strong>，无论是遍历、构造、序列化还是子树相关问题，都有一套统一的解题框架和思维模式。本文将从<strong>解题总纲</strong>出发，依次讲解<strong>遍历与分解问题思维</strong>、<strong>二叉树构造</strong>、<strong>序列化与反序列化</strong>三大核心模块，结合LeetCode经典真题，从原理到代码实现层层拆解，让你形成一套可复用的二叉树解题体系，轻松应对各类二叉树问题。</p>
<h3 data-id="heading-1">一、二叉树解题总纲（纲领篇）</h3>
<p>所有二叉树问题的解题思维，都可以归为两类，且无论使用哪种思维，都要聚焦<strong>单个节点的操作</strong>和<strong>执行时机</strong>：</p>
<h4 data-id="heading-2">核心思维模式</h4>
<ol>
<li>
<p><strong>遍历思维</strong>：能否通过<strong>遍历一遍二叉树</strong>得到答案？若可以，编写<code>traverse</code>遍历函数，配合外部变量记录结果，让每个节点执行相同操作。</p>
</li>
<li>
<p><strong>分解问题思维</strong>：能否通过<strong>子问题（子树）的答案推导原问题答案</strong>？若可以，定义递归函数并明确其<strong>返回值含义</strong>，充分利用子树的返回值构建原问题解。</p>
</li>
</ol>
<h4 data-id="heading-3">核心思考步骤</h4>
<p>单独抽出一个二叉树节点，思考两个关键问题：</p>
<ol>
<li>
<p>这个节点<strong>需要做什么事情</strong>？（如交换左右子节点、计算子树高度、序列化子树等）</p>
</li>
<li>
<p>这件事需要在<strong>什么时候做</strong>？（前序/中序/后序位置，层序的当前层）</p>
</li>
</ol>
<p><strong>其他节点无需操心</strong>，递归函数会帮你在所有节点上执行相同的操作——这是二叉树递归解题的核心，也是「分治思想」的完美体现。</p>
<h3 data-id="heading-4">二、二叉树解题思维：遍历 vs 分解问题（思维篇）</h3>
<p>我们通过3道LeetCode经典简单题，实战区分两种思维模式的差异与适用场景，理解<strong>前/中/后序位置</strong>的核心作用。</p>
<h4 data-id="heading-5">题1：翻转二叉树（LeetCode 226）</h4>
<p><strong>题目要求</strong>：原地翻转二叉树，交换每个节点的左右子节点，返回翻转后的根节点。</p>
<p><strong>核心结论</strong>：前后序位置均可实现，遍历思维更直观，分解思维更贴合递归本质。</p>
<h5 data-id="heading-6">解法1：遍历思维（前序遍历）</h5>
<p>遍历每个节点，在<strong>前序位置</strong>直接交换当前节点的左右子节点，递归处理子节点即可。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：前序递归，直接操作每个节点
 * 核心：前序位置交换左右子节点，原地修改
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 前序位置：当前节点操作——交换左右子节点</span>
  [root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>] = [root.<span class="hljs-property">right</span>, root.<span class="hljs-property">left</span>];
  <span class="hljs-comment">// 递归遍历左右子树，完成下层翻转</span>
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-7">解法2：分解问题思维</h5>
<p><strong>函数定义</strong>：<code>invertTree(root)</code> 表示「翻转以<code>root</code>为根的二叉树，返回翻转后的根节点」。</p>
<p>利用函数定义，先翻转左右子树，再交换当前节点的左右子节点，贴合「子问题推导原问题」的思路。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：利用子树结果推导原问题
 * 核心：先解子问题（翻转左右子树），再处理当前节点
 */</span>
<span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 子问题1：翻转左子树，得到翻转后的左子树根</span>
    <span class="hljs-keyword">var</span> left = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：翻转右子树，得到翻转后的右子树根</span>
    <span class="hljs-keyword">var</span> right = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理当前节点：交换左右子节点</span>
    root.<span class="hljs-property">left</span> = right;
    root.<span class="hljs-property">right</span> = left;
    <span class="hljs-comment">// 符合函数定义：返回翻转后的当前根节点</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-8">题2：填充节点的右侧指针（LeetCode 116）</h4>
<p><strong>题目要求</strong>：完美二叉树中，将同一层相邻节点通过<code>next</code>指针连接，最右侧节点<code>next</code>为<code>null</code>，原地修改。</p>
<p><strong>核心结论</strong>：<strong>遍历思维更适用</strong>，需将「两个相邻节点」作为遍历单元（三叉树思维），中后序无法实现。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：自定义遍历单元（两个相邻节点）
 * 核心：前序位置连接相邻节点，递归处理下层所有相邻对
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;
  <span class="hljs-comment">// 从根节点的左右子节点开始，处理第一层相邻对</span>
  <span class="hljs-title function_">link</span>(root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;

  <span class="hljs-comment">// 遍历单元：两个相邻节点，负责连接并处理下层</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">node1, node2</span>) {
    <span class="hljs-keyword">if</span> (!node1 || !node2) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 前序位置：核心操作——连接两个相邻节点</span>
    node1.<span class="hljs-property">next</span> = node2;
    <span class="hljs-comment">// 处理同父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">left</span>, node1.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理跨父节点的相邻子节点（核心难点）</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">right</span>, node2.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 处理另一父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node2.<span class="hljs-property">left</span>, node2.<span class="hljs-property">right</span>);
  }
}
</code></pre>
<h4 data-id="heading-9">题3：将二叉树展开为链表（LeetCode 114）</h4>
<p><strong>题目要求</strong>：原地将二叉树展开为单链表，按<strong>前序遍历顺序</strong>通过<code>right</code>指针连接，<code>left</code>指针置空。</p>
<p><strong>核心结论</strong>：<strong>分解问题思维更高效</strong>，后序位置利用子树展开结果，直接拼接即可；遍历思维需额外记录前序节点，实现复杂。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：后序遍历，利用子树展开结果拼接
 * 函数定义：flatten(root) 表示「将root为根的树展开为前序链表」
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 子问题1：展开左子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：展开右子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">right</span>);

    <span class="hljs-comment">// 后序位置：利用子树结果处理当前节点（关键！后序能获取子树处理后的结果）</span>
    <span class="hljs-keyword">const</span> left = root.<span class="hljs-property">left</span>;  <span class="hljs-comment">// 已展开的左链表</span>
    <span class="hljs-keyword">const</span> right = root.<span class="hljs-property">right</span>; <span class="hljs-comment">// 已展开的右链表</span>

    <span class="hljs-comment">// 核心操作：将左链表拼接到root.right，左指针置空</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;
    root.<span class="hljs-property">right</span> = left;

    <span class="hljs-comment">// 找到左链表的尾节点，拼接右链表</span>
    <span class="hljs-keyword">let</span> p = root;
    <span class="hljs-keyword">while</span> (p.<span class="hljs-property">right</span> !== <span class="hljs-literal">null</span>) p = p.<span class="hljs-property">right</span>;
    p.<span class="hljs-property">right</span> = right;
}
</code></pre>
<h4 data-id="heading-10">思维对比与前/后序核心作用</h4>




























<table><thead><tr><th>思维模式</th><th>核心特点</th><th>适用场景</th><th>关键位置</th></tr></thead><tbody><tr><td>遍历思维</td><td>直接操作节点，配合外部变量</td><td>无需子树结果，仅需遍历节点执行操作</td><td>前序（优先）、层序</td></tr><tr><td>分解问题思维</td><td>利用子树返回值，推导原问题</td><td>需基于子树处理结果完成当前节点操作</td><td>后序（优先）、前序</td></tr><tr><td><strong>前序 vs 后序核心区别</strong>：</td><td/><td/></tr></tbody></table>
<ul>
<li>
<p>前序位置：<strong>只能获取父节点传递的参数</strong>，无法获取子树的处理结果，适合「先操作当前节点，再递归子节点」；</p>
</li>
<li>
<p>后序位置：<strong>既能获取参数，又能获取子树的返回值</strong>，是「分解问题思维」的核心位置，几乎所有子树相关问题都需要在后序位置处理。</p>
</li>
</ul>
<h3 data-id="heading-11">三、二叉树构造问题：分解问题的极致应用（构造篇）</h3>
<p>二叉树的构造问题是<strong>分解问题思维</strong>的典型场景，核心框架为：</p>
<p><strong>构造整棵树 = 构建根节点 + 递归构造左子树 + 递归构造右子树</strong></p>
<p>所有构造问题的解题步骤可总结为<strong>四步通用框架</strong>：</p>
<ol>
<li>
<p><strong>定根</strong>：确定当前子树的根节点（如最大值、前序首元素、后序尾元素）；</p>
</li>
<li>
<p><strong>找边界</strong>：根据根节点，划分左/右子树的元素边界（如数组区间、遍历序列索引）；</p>
</li>
<li>
<p><strong>算大小</strong>：计算左/右子树的节点个数，作为分割遍历序列的依据；</p>
</li>
<li>
<p><strong>分治构建</strong>：递归构建左/右子树，挂载到当前根节点的左右指针。</p>
</li>
</ol>
<p>下面结合4道LeetCode经典构造题，从简单到复杂，吃透构造问题的通用解法。</p>
<h4 data-id="heading-12">题1：最大二叉树（LeetCode 654）</h4>
<p><strong>题目要求</strong>：给定无重复整数数组，构建最大二叉树——根为数组最大值，左子树用最大值左区间构建，右子树用最大值右区间构建。</p>
<p><strong>核心思路</strong>：<strong>数组索引分治</strong>，全程操作原数组，无数组拷贝，空间效率最优。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 最大二叉树构造：数组区间分治，分解问题思维
 * 核心：找区间最大值定根，分割区间递归构建左右子树
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructMaximumBinaryTree</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用nums[low..high]构建最大二叉树，返回根节点</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">nums, low, high</span>) {
    <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 区间无效，返回null</span>

    <span class="hljs-comment">// 步骤1：找区间最大值及索引（定根）</span>
    <span class="hljs-keyword">let</span> maxVal = -<span class="hljs-title class_">Infinity</span>, maxIdx = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = low; i &lt;= high; i++) {
      <span class="hljs-keyword">if</span> (nums[i] &gt; maxVal) {
        maxVal = nums[i];
        maxIdx = i;
      }
    }

    <span class="hljs-comment">// 步骤2：构建当前根节点</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxVal);
    <span class="hljs-comment">// 步骤3：分治构建左右子树（找边界）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(nums, low, maxIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(nums, maxIdx + <span class="hljs-number">1</span>, high);

    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-13">题2：从前序与中序遍历序列构造二叉树（LeetCode 105）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和中序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>：</p>
<ol>
<li>
<p>前序：<strong>根 → 左子树 → 右子树</strong>（首元素为根）；</p>
</li>
<li>
<p>中序：<strong>左子树 → 根 → 右子树</strong>（根为分割点，划分左右子树）；</p>
</li>
<li>
<p>关键桥梁：中序中左子树的节点个数，是分割前序序列的唯一依据。</p>
</li>
</ol>
<p><strong>性能优化</strong>：构建中序「值→索引」Map，将根节点查询时间从O(n)降至O(1)，时间复杂度从O(n²)优化为O(n)。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+中序构造二叉树：索引分治+Map优化
 * 核心：前序定根，中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">preorder, inorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建中序值→索引Map，O(1)查询根节点位置</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-comment">// 初始区间：全数组[0, len-1]</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用pre[pStart..pEnd]和in[iStart..iEnd]构建子树</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：前序首元素为根（定根）</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：中序中找根节点索引（找边界）</span>
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数（做桥梁）</span>
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-14">题3：从中序与后序遍历序列构造二叉树（LeetCode 106）</h4>
<p><strong>题目要求</strong>：给定二叉树的中序和后序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>（与前序+中序的唯一区别）：</p>
<ul>
<li>
<p>后序：<strong>左子树 → 右子树 → 根</strong>（尾元素为根）；</p>
</li>
<li>
<p>后序序列分割时，需<strong>排除尾节点的根</strong>，右区间结束位置为<code>pEnd - 1</code>。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 中序+后序构造二叉树：索引分治+Map优化
 * 核心：后序定根（尾元素），中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">inorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (postorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：后序尾元素为根（定根，与前序的核心区别）</span>
    <span class="hljs-keyword">const</span> rootVal = postorder[pEnd];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤2：分治构建左右子树（后序区间分割与前序不同）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart, pStart + leftSize - <span class="hljs-number">1</span>, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize, pEnd - <span class="hljs-number">1</span>, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-15">题4：从前序与后序遍历序列构造二叉树（LeetCode 889）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和后序遍历序列，构造并返回二叉树（节点值无重复，答案不唯一）。</p>
<p><strong>核心特性</strong>（与前两题的关键区别）：</p>
<ol>
<li>
<p>前序+后序<strong>无法唯一确定二叉树</strong>（根节点加单个子节点，左/右均可），题目允许返回任意合法答案；</p>
</li>
<li>
<p>前序第二个元素为<strong>左子树的根</strong>，通过后序找到其位置，计算左子树大小（分割序列的依据）；</p>
</li>
<li>
<p>递归终止时需单独处理<strong>叶子节点</strong>（避免数组越界）。</p>
</li>
</ol>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+后序构造二叉树：索引分治+叶子节点单独处理
 * 核心：前序定根，后序定左子树边界，答案不唯一
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructFromPrePost</span>(<span class="hljs-params">preorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建后序值→索引Map</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  postorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, postStart, postEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 单独处理叶子节点（避免preStart+1越界，关键！）</span>
    <span class="hljs-keyword">if</span> (pStart === pEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[pStart]);

    <span class="hljs-comment">// 步骤1：前序首元素为根</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：前序第二个元素为左子树根，找其在后序的位置</span>
    <span class="hljs-keyword">const</span> leftRootVal = preorder[pStart + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> leftPostIdx = valToIndex.<span class="hljs-title function_">get</span>(leftRootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数</span>
    <span class="hljs-keyword">const</span> leftSize = leftPostIdx - postStart + <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, postStart, leftPostIdx);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, leftPostIdx + <span class="hljs-number">1</span>, postEnd - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-16">构造问题通用总结</h4>
<ol>
<li>
<p><strong>必用分解问题思维</strong>：构造整棵树的本质是递归构造子树，必须定义「区间构建子树」的递归函数；</p>
</li>
<li>
<p><strong>索引分治是最优解</strong>：全程操作原数组，无数组拷贝，空间复杂度O(n)（递归栈）；</p>
</li>
<li>
<p><strong>Map是性能刚需</strong>：将根节点查询时间从O(n)降至O(1)，避免时间复杂度升至O(n²)；</p>
</li>
<li>
<p><strong>节点数是核心桥梁</strong>：中序/后序中计算的左子树节点数，是分割前序/后序序列的唯一依据；</p>
</li>
<li>
<p><strong>边界处理要严谨</strong>：区间为<strong>闭区间</strong>，不可随意增减索引，避免节点缺失/重复。</p>
</li>
</ol>
<h3 data-id="heading-17">四、二叉树后序篇：子树相关问题的核心解法（后序篇）</h3>
<p>通过前面的题目我们发现：<strong>后序位置是处理子树相关问题的黄金位置</strong>——因为后序能获取左右子树的返回值，而子树问题的本质，正是基于子树的结果推导当前节点的答案。</p>
<p>LeetCode 652「寻找重复的子树」是后序思维的经典应用，结合<strong>子树序列化</strong>和<strong>哈希表统计</strong>，完美体现「后序+分解问题」的解题思路。</p>
<h4 data-id="heading-18">题：寻找重复的子树（LeetCode 652）</h4>
<p><strong>题目要求</strong>：找出二叉树中所有重复的子树，返回重复子树的根节点数组（每个重复子树仅返回一次）。</p>
<p><strong>核心思路</strong>：</p>
<ol>
<li>
<p><strong>后序序列化子树</strong>：按「左→右→根」拼接子树标识（唯一标识子树结构，避免歧义）；</p>
</li>
<li>
<p><strong>哈希表统计次数</strong>：用Map记录每个子树标识的出现次数；</p>
</li>
<li>
<p><strong>首次重复时收集</strong>：仅当子树出现次数从1→2时收集根节点（避免重复添加）。</p>
</li>
</ol>
<p><strong>关键细节</strong>：</p>
<ul>
<li>
<p>空节点必须用<strong>统一标记（#）</strong> 表示，不可省略（缺失会导致结构歧义）；</p>
</li>
<li>
<p>节点值/空标记必须用<strong>分隔符（,）</strong> 分隔，避免多位数拼接冲突（如12和1,2）；</p>
</li>
<li>
<p>序列化顺序必须为<strong>左→右→根</strong>（标准后序），能最大程度保留子树结构信息，避免标识重复。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 寻找重复子树：后序序列化+哈希统计+分解问题思维
 * 核心：后序位置返回子树标识，利用子树结果统计重复
 */</span>
<span class="hljs-keyword">var</span> findDuplicateSubtrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">const</span> countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 子树标识→出现次数</span>
    <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储重复子树根节点</span>

    <span class="hljs-comment">// 函数定义：序列化当前节点为根的子树，返回唯一标识</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，不可省略</span>
        <span class="hljs-comment">// 后序遍历：先序列化左右子树（子问题）</span>
        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 后序位置：拼接当前子树标识（左→右→根，标准后序）</span>
        <span class="hljs-keyword">const</span> curStr = <span class="hljs-string">`<span class="hljs-subst">${left}</span>,<span class="hljs-subst">${right}</span>,<span class="hljs-subst">${node.val}</span>`</span>;
        <span class="hljs-comment">// 统计次数，首次重复时收集（count===2）</span>
        <span class="hljs-keyword">const</span> count = (countMap.<span class="hljs-title function_">get</span>(curStr) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
        countMap.<span class="hljs-title function_">set</span>(curStr, count);
        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) result.<span class="hljs-title function_">push</span>(node);
        <span class="hljs-comment">// 返回子树标识，供父节点拼接（分解问题的核心）</span>
        <span class="hljs-keyword">return</span> curStr;
    }

    <span class="hljs-title function_">serialize</span>(root);
    <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h4 data-id="heading-19">后序思维核心总结</h4>
<ol>
<li>
<p><strong>子树问题必用后序</strong>：只要题目与子树相关，大概率需要在后序位置写代码，利用子树的返回值；</p>
</li>
<li>
<p><strong>后序是分解问题的核心</strong>：后序位置能获取左右子树的处理结果，是「子问题推导原问题」的最佳时机；</p>
</li>
<li>
<p><strong>序列化标识要唯一</strong>：子树序列化需满足「空节点标记+分隔符+标准遍历顺序」，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-20">五、二叉树序列化与反序列化：遍历的极致应用（序列化篇）</h3>
<p>序列化的目的是<strong>将二叉树转换为独立于编程语言的格式</strong>（如字符串），方便存储/传输；反序列化则是将序列化格式还原为二叉树，核心要求是<strong>能还原出唯一的二叉树</strong>。</p>
<h4 data-id="heading-21">序列化与反序列化的核心结论</h4>
<p>当二叉树节点值无重复时，序列化结果的<strong>唯一性</strong>取决于「是否包含空节点信息」和「遍历顺序」，总结为3条核心规则：</p>
<ol>
<li>
<p><strong>无空节点信息</strong>：仅一种遍历顺序无法唯一还原，前序+中序/后序+中序可还原，前序+后序不可还原；</p>
</li>
<li>
<p><strong>有空节点信息</strong>：前序/后序可唯一还原（根节点位置固定），中序<strong>无法还原</strong>（根节点位置不固定）；</p>
</li>
<li>
<p><strong>层序遍历</strong>：包含空节点信息时可唯一还原，是工程中最常用的序列化方式（按层存储，结构直观）。</p>
</li>
</ol>
<h4 data-id="heading-22">核心通用规则</h4>
<p>无论哪种遍历方式的序列化/反序列化，都需遵守3条通用规则：</p>
<ol>
<li>
<p><strong>空节点显式标记</strong>：用统一符号（如#）标记空节点，不可省略；</p>
</li>
<li>
<p><strong>分隔符分隔</strong>：用逗号（,）分隔节点值/空标记，避免拼接冲突；</p>
</li>
<li>
<p><strong>遍历顺序一致</strong>：反序列化的遍历顺序必须与序列化完全一致（如前序序列化→前序反序列化）。</p>
</li>
</ol>
<p>下面依次讲解<strong>前序、后序、层序</strong>的序列化与反序列化实现（中序无法唯一反序列化，无需实现），均为<strong>工程优化版</strong>，兼顾效率与鲁棒性。</p>
<h4 data-id="heading-23">1. 前序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「根→左→右」，反序列化也按「根→左→右」，用<strong>索引指针</strong>替代数组shift（O(1)效率）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，单一数据源</span>

<span class="hljs-comment">/**
 * 前序序列化：根→左→右，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePreorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 前序：先根</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 再左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 最后右</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 前序反序列化：根→左→右，索引指针优化
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePreorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 索引指针，O(1)取数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr[idx++];
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建左子树</span>
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建右子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-24">2. 后序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「左→右→根」，反序列化从<strong>数组尾部取元素</strong>（根在尾部），且<strong>先构建右子树，再构建左子树</strong>（与序列化顺序镜像）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 后序序列化：左→右→根，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePostorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 先左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 再右</span>
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 最后根</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 后序反序列化：从尾部取元素，先右后左构建
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePostorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 尾部取元素，根在最后</span>
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建右子树（镜像顺序）</span>
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建左子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-25">3. 层序序列化与反序列化（工程推荐）</h4>
<p><strong>核心规则</strong>：按「从上到下、从左到右」遍历，用<strong>队列</strong>实现按层访问，反序列化时用队列维护<strong>待构建子树的父节点</strong>，按顺序分配左右子节点。</p>
<p><strong>工程优化</strong>：序列化时去除末尾冗余空标记，让结果更紧凑；反序列化时增加边界校验，增强鲁棒性。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 层序序列化：队列实现，去除末尾冗余空标记（工程优化）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializeLevelorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span>;
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> queue = [root];
  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> node = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">continue</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 左右子节点均入队，无论是否为空</span>
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);
  }
  <span class="hljs-comment">// 去除末尾冗余空标记，优化存储</span>
  <span class="hljs-keyword">while</span> (res[res.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) res.<span class="hljs-title function_">pop</span>();
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 层序反序列化：队列维护父节点，按顺序分配左右子节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializeLevelorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(arr[idx++]));
  <span class="hljs-keyword">const</span> queue = [root]; <span class="hljs-comment">// 队列存储待构建子树的父节点</span>

  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &amp;&amp; idx &lt; arr.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> parent = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-comment">// 构建左子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> leftVal = arr[idx++];
      parent.<span class="hljs-property">left</span> = leftVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(leftVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">left</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">left</span>);
    }
    <span class="hljs-comment">// 构建右子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> rightVal = arr[idx++];
      parent.<span class="hljs-property">right</span> = rightVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(rightVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">right</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">right</span>);
    }
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-26">序列化核心总结</h4>
<ol>
<li>
<p><strong>前/后序</strong>：实现简单，递归即可，适合算法题；</p>
</li>
<li>
<p><strong>层序</strong>：结构直观，工程中常用，队列实现按层访问；</p>
</li>
<li>
<p><strong>反序列化关键</strong>：前序用索引指针，后序从尾部取元素，层序用队列维护父节点；</p>
</li>
<li>
<p><strong>唯一性保障</strong>：包含空节点信息的前/后/层序，均可唯一还原二叉树。</p>
</li>
</ol>
<h3 data-id="heading-27">六、二叉树解题心法终极总结</h3>
<p>本文从<strong>解题总纲</strong>到<strong>思维模式</strong>，再到<strong>构造、后序、序列化</strong>三大核心模块，层层拆解了二叉树的解题规律，最终可总结为<strong>三大核心心法</strong>，记牢这几点，所有二叉树问题均可迎刃而解：</p>
<h4 data-id="heading-28">心法1：思维模式二选一，聚焦节点与时机</h4>
<ol>
<li>
<p>遍历思维：直接操作节点，配合外部变量，前序/层序优先；</p>
</li>
<li>
<p>分解问题思维：定义递归函数返回值，利用子树结果，后序优先；</p>
</li>
<li>
<p>所有问题都要聚焦「单个节点该做什么，在什么时候做」。</p>
</li>
</ol>
<h4 data-id="heading-29">心法2：前中后序有分工，后序是子树核心</h4>
<ol>
<li>
<p>前序：先操作当前节点，再递归子节点，适合遍历、翻转、连接等操作；</p>
</li>
<li>
<p>中序：仅适合二叉搜索树（BST）的有序遍历，普通二叉树应用极少；</p>
</li>
<li>
<p>后序：能获取子树返回值，是分解问题、子树相关问题的黄金位置；</p>
</li>
<li>
<p>层序：按层访问，工程常用，适合层序遍历、层序序列化等问题。</p>
</li>
</ol>
<h4 data-id="heading-30">心法3：构造与序列化，各有通用框架</h4>
<ol>
<li>
<p>构造问题：定根→找边界→算大小→分治构建，索引分治+Map优化是最优解；</p>
</li>
<li>
<p>序列化问题：空节点标记+分隔符+一致遍历顺序，前/后/层序均可实现，层序工程首选；</p>
</li>
<li>
<p>子树序列化：左→右→根标准后序，保证标识唯一，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-31">最后</h3>
<p>二叉树的所有问题，本质都是<strong>递归分治</strong>的应用，而递归的核心是「相信递归函数的定义，聚焦当前节点」。本文的所有解法和框架，都建立在「二叉树解题总纲」之上，只要你能理解并灵活运用「遍历」和「分解问题」两种思维，掌握前/中/后序的核心作用，就能轻松应对各类二叉树问题。</p>
<p>建议大家结合本文的代码，在LeetCode上动手实现一遍，从简单题到复杂题，逐步形成自己的解题体系——二叉树的基础打牢了，后续的二叉搜索树（BST）、平衡二叉树（AVL）、红黑树等高级数据结构，都会迎刃而解。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉搜索树（BST）核心心法：从特性到实战，理解高频考点]]></title>    <link>https://juejin.cn/post/7602420156397158443</link>    <guid>https://juejin.cn/post/7602420156397158443</guid>    <pubDate>2026-02-03T10:21:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397158443" data-draft-id="7602411521072136211" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉搜索树（BST）核心心法：从特性到实战，理解高频考点"/> <meta itemprop="keywords" content="后端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:21:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉搜索树（BST）核心心法：从特性到实战，理解高频考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:21:20.000Z" title="Tue Feb 03 2026 10:21:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读42分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉搜索树（BST）核心心法：从特性到实战，理解高频考点</h2>
<p>二叉搜索树（Binary Search Tree，简称BST）是算法领域最基础、最常用的树形数据结构之一，其「左小右大」的核心特性赋予了它高效的查找、插入、删除能力，时间复杂度均为O(logN)（平衡BST下）。同时，BST的中序遍历天然升序的特性，使其能轻松解决有序性相关问题。本文将从<strong>BST核心特性</strong>出发，循序渐进讲解<strong>基础操作、经典题型、进阶实战</strong>，提炼通用解题心法，帮你彻底吃透BST所有高频考点。</p>
<h3 data-id="heading-1">一、BST核心特性：一切操作的基础</h3>
<p>BST的定义看似简单，却是所有解题思路的源头，必须牢牢掌握<strong>严格定义</strong>和<strong>衍生性质</strong>，避免因理解偏差导致解题错误。</p>
<h4 data-id="heading-2">1.1 严格定义（3条核心规则）</h4>
<p>对于BST的任意一个节点<code>node</code>，必须同时满足：</p>
<ol>
<li>
<p>左子树的<strong>所有节点</strong>值都<strong>严格小于</strong><code>node.val</code>；</p>
</li>
<li>
<p>右子树的<strong>所有节点</strong>值都<strong>严格大于</strong><code>node.val</code>；</p>
</li>
<li>
<p>左子树和右子树自身也必须是合法的BST。</p>
</li>
</ol>
<p><strong>关键误区</strong>：切勿简化为「仅当前节点大于左子节点、小于右子节点」，深层子节点的约束会被忽略，导致BST合法性判断、遍历等操作出错。</p>
<h4 data-id="heading-3">1.2 核心衍生性质（算法解题的关键）</h4>
<p>从严格定义可推导出2个最常用的性质，几乎所有BST题目都围绕这两个性质展开：</p>
<ol>
<li>
<p><strong>高效查找性</strong>：根据「左小右大」，查找目标节点时可一次性排除一半子树，无需遍历所有节点，基础查找/插入/删除的时间复杂度为O(logN)（平衡BST），远优于普通二叉树的O(N)；</p>
</li>
<li>
<p><strong>中序遍历有序性</strong>：BST的中序遍历（左→根→右）结果为<strong>严格升序</strong>，逆序中序遍历（右→根→左）结果为<strong>严格降序</strong>。这一性质是解决「第K小元素」「累加树转换」等有序性问题的核心。</p>
</li>
</ol>
<h4 data-id="heading-4">1.3 BST与普通二叉树的核心区别</h4>
<p>普通二叉树的操作仅能通过<strong>全遍历</strong>（前/中/后序）实现，而BST可通过<strong>特性引导遍历</strong>（根据目标值与当前节点值的大小，决定左/右子树遍历），大幅提升效率；同时，BST的有序性是普通二叉树不具备的，这是解决各类有序问题的天然优势。</p>
<h3 data-id="heading-5">二、BST基础操作：查、增、删、验（高频面试题）</h3>
<p>BST的基础操作是所有进阶题型的铺垫，核心思路是**「特性引导遍历找位置 + 针对性修改」**，其中「删除」和「合法性验证」略复杂，需重点掌握。</p>
<h4 data-id="heading-6">2.1 查找节点（力扣700题）</h4>
<h5 data-id="heading-7">核心思路</h5>
<p>利用「左小右大」特性，递归/迭代引导遍历：目标值大于当前节点值则走右子树，小于则走左子树，等于则找到目标节点，空节点则表示未找到。</p>
<h5 data-id="heading-8">实现代码（递归版，简洁高效）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中值为target的节点，找到返回节点，未找到返回null
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} target 目标值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 目标节点/null
 */</span>
<span class="hljs-keyword">var</span> searchBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, target</span>) {
    <span class="hljs-comment">// 递归终止：空节点未找到，直接返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 目标值更大，去右子树查找</span>
    <span class="hljs-keyword">if</span> (target &gt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">right</span>, target);
    <span class="hljs-comment">// 目标值更小，去左子树查找</span>
    <span class="hljs-keyword">if</span> (target &lt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">left</span>, target);
    <span class="hljs-comment">// 找到目标节点，返回当前节点</span>
    <span class="hljs-keyword">return</span> root
};
</code></pre>
<h5 data-id="heading-9">复杂度</h5>
<p>时间：O(logN)（平衡BST）/ O(N)（链状BST），空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-10">2.2 插入节点（力扣701题）</h4>
<h5 data-id="heading-11">核心思路</h5>
<ol>
<li>
<p>BST插入的<strong>关键性质</strong>：新节点最终必作为<strong>叶子节点</strong>插入，无需调整原有树结构（输入保证新值唯一）；</p>
</li>
<li>
<p>利用特性找到空节点（插入位置），创建新节点并返回，回溯时完成父节点与新节点的链接。</p>
</li>
</ol>
<h5 data-id="heading-12">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 向BST插入新值，保持BST性质，返回插入后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} value 新值（保证唯一）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 插入后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">root, value</span>) {
    <span class="hljs-comment">// 递归终止：找到空节点，创建新节点作为插入位置</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(value);
    <span class="hljs-comment">// 新值更大，去右子树插入，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (value &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">right</span>, value);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 新值更小，去左子树插入，更新左子树链接</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">left</span>, value);
    }
    <span class="hljs-comment">// 回溯返回当前节点，保证树结构连续</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-13">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-14">2.3 验证BST合法性（力扣98题）</h4>
<h5 data-id="heading-15">核心思路</h5>
<ol>
<li>
<p>关键问题：单个节点的合法值范围由<strong>所有祖先节点</strong>共同决定，而非仅父节点；</p>
</li>
<li>
<p>解决方案：递归传递<strong>动态上下界</strong>，为每个节点划定开区间合法范围<code>(min, max)</code>，节点值必须严格在区间内，同时左右子树也需合法。</p>
</li>
</ol>
<h5 data-id="heading-16">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 验证二叉树是否为合法BST
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>} 是否为合法BST
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 空树视为合法BST，根节点初始上下界为负无穷/正无穷</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverse</span>(root, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-title class_">Infinity</span>);
    
    <span class="hljs-comment">// 递归辅助：验证当前节点是否在(min, max)区间内</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, min, max</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 节点值超出开区间，直接判定非法</span>
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">val</span> &lt;= min || node.<span class="hljs-property">val</span> &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 验证左子树：上界更新为当前节点值，下界继承</span>
        <span class="hljs-keyword">const</span> leftValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, min, node.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 验证右子树：下界更新为当前节点值，上界继承</span>
        <span class="hljs-keyword">const</span> rightValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, node.<span class="hljs-property">val</span>, max);
        <span class="hljs-comment">// 左右子树都合法，当前子树才合法</span>
        <span class="hljs-keyword">return</span> leftValid &amp;&amp; rightValid;
    }
}
</code></pre>
<h5 data-id="heading-17">关键易错点</h5>
<ul>
<li>
<p>初始上下界必须为<code>(-Infinity, Infinity)</code>，根节点无祖先约束；</p>
</li>
<li>
<p>必须用<strong>开区间</strong>（<code>&lt;= / &gt;=</code>），避免节点值等于边界（如<code>[2,2,2]</code>误判为合法）。</p>
</li>
</ul>
<h4 data-id="heading-18">2.4 删除节点（力扣450题，核心难点）</h4>
<h5 data-id="heading-19">核心思路</h5>
<p>先通过特性找到目标节点，再分<strong>4种情况</strong>处理删除，核心是「删除后保持BST性质」，其中「有左右双孩子」的情况是难点。</p>
<h5 data-id="heading-20">4种删除情况</h5>
<ol>
<li>
<p>目标节点是<strong>叶子节点</strong>（左右子树均空）：直接删除，返回null让父节点置空该子树；</p>
</li>
<li>
<p>只有右子树：用右子树替换当前节点，返回右子树根节点；</p>
</li>
<li>
<p>只有左子树：用左子树替换当前节点，返回左子树根节点；</p>
</li>
<li>
<p>有<strong>左右双孩子</strong>（核心）：选择「左子树最大值节点（前驱）」或「右子树最小值节点（后继）」替换当前节点，再删除该替换节点（保证BST性质不变）。</p>
</li>
</ol>
<h5 data-id="heading-21">实现代码（前驱节点替换法，不修改节点值，仅调整指针）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 删除BST中值为key的节点，保持BST性质，返回删除后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} key 要删除的节点值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 删除后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">root, key</span>) {
    <span class="hljs-comment">// 递归终止：空树/未找到目标节点，返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// 目标值更大，去右子树递归删除，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (key &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">right</span>, key);
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-comment">// 目标值更小，去左子树递归删除，更新左子树链接</span>
    <span class="hljs-keyword">if</span> (key &lt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, key);
        <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-comment">// 找到目标节点，分情况处理</span>
    <span class="hljs-keyword">if</span> (key === root.<span class="hljs-property">val</span>) {
        <span class="hljs-comment">// 情况1：叶子节点，直接删除</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span> &amp;&amp; !root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">// 情况2：只有右子树，用右子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 情况3：只有左子树，用左子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 情况4：有双孩子，左子树最大值（前驱）替换</span>
        <span class="hljs-keyword">let</span> maxLeft = root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 找到左子树最右侧节点（最大值）</span>
        <span class="hljs-keyword">while</span> (maxLeft.<span class="hljs-property">right</span>) maxLeft = maxLeft.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 先删除左子树的最大值节点</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, maxLeft.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 用前驱节点替换当前节点，调整指针</span>
        maxLeft.<span class="hljs-property">left</span> = root.<span class="hljs-property">left</span>;
        maxLeft.<span class="hljs-property">right</span> = root.<span class="hljs-property">right</span>;
        <span class="hljs-keyword">return</span> maxLeft;
    }

    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-22">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h3 data-id="heading-23">三、BST经典题型：利用有序性解决问题</h3>
<p>BST的中序遍历有序性是解决这类问题的「黄金钥匙」，核心思路是**「通过中序遍历将BST转化为有序序列，再针对性处理」**，无需额外排序，时间复杂度最优。</p>
<h4 data-id="heading-24">3.1 寻找第K小的元素（力扣230题）</h4>
<h5 data-id="heading-25">题目要求</h5>
<p>给定BST，查找其中第K小的元素（从1开始计数）。</p>
<h5 data-id="heading-26">核心思路</h5>
<p>利用BST<strong>中序遍历升序</strong>的特性，中序遍历过程中维护全局计数，遍历到第K个节点时即为答案，找到后立即终止遍历（剪枝）。</p>
<h5 data-id="heading-27">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中第K小的元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} k 第k小（1&lt;=k&lt;=节点总数）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 第k小节点值
 */</span>
<span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, k</span>) {
    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 存储结果</span>
    <span class="hljs-keyword">let</span> rank = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 全局计数，记录当前遍历节点的排名</span>

    <span class="hljs-comment">// 中序遍历：左→根→右</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-comment">// 递归终止：空节点/已找到目标，直接返回</span>
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> || res !== <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 遍历左子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-comment">// 处理当前节点：计数+判断是否为第k小</span>
        rank++;
        <span class="hljs-keyword">if</span> (rank === k) {
            res = node.<span class="hljs-property">val</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 遍历右子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> res;
};
</code></pre>
<h5 data-id="heading-28">关键优化</h5>
<p>找到目标后立即终止遍历，避免无效的后续递归，提升实际执行效率。</p>
<h4 data-id="heading-29">3.2 BST转化为累加树（力扣538/1038题）</h4>
<h5 data-id="heading-30">题目要求</h5>
<p>将BST转化为累加树，使每个节点的新值等于原树中<strong>大于或等于</strong>该节点值的所有节点值之和。</p>
<h5 data-id="heading-31">核心思路</h5>
<ol>
<li>
<p>BST中序遍历（左→根→右）为升序 → <strong>逆序中序遍历（右→根→左）为降序</strong>；</p>
</li>
<li>
<p>逆序遍历过程中维护全局累加和<code>sum</code>，先遍历的节点值一定更大，累加后赋值给当前节点，自然得到「所有大于等于当前节点值的和」。</p>
</li>
</ol>
<h5 data-id="heading-32">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 将BST转化为累加树，直接修改原树，返回根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 累加树根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">convertBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局累加和，记录所有已遍历节点值的和</span>

    <span class="hljs-comment">// 逆序中序遍历：右→根→左</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 先遍历右子树（更大的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 处理当前节点：累加+更新值</span>
        sum += node.<span class="hljs-property">val</span>;
        node.<span class="hljs-property">val</span> = sum;
        <span class="hljs-comment">// 再遍历左子树（更小的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-33">优势</h5>
<p>直接修改原树节点值，空间复杂度仅为O(logN)（递归栈），无需额外创建节点，为最优解。</p>
<h3 data-id="heading-34">四、BST进阶题型：构造与子树问题</h3>
<p>这类题目属于BST的高频难题，核心考察<strong>动态规划</strong>和<strong>后序遍历的信息收集能力</strong>，其中「二叉搜索子树的最大键值和」是综合考察的典型代表。</p>
<h4 data-id="heading-35">4.1 构造不同的BST（力扣96/95题）</h4>
<p>这类题目考察BST的组合特性，核心是**「以任意节点为根，拆分左右子树节点数，利用乘法原理计算组合数/生成组合」**。</p>
<h5 data-id="heading-36">4.1.1 计算BST种数（力扣96题，动态规划+卡特兰数）</h5>
<h6 data-id="heading-37">核心思路</h6>
<ol>
<li>
<p>关键性质：BST的种数仅与<strong>节点数量</strong>有关，与节点具体值无关；</p>
</li>
<li>
<p>动态规划定义：<code>dp[i]</code>表示<code>i</code>个节点能组成的不同BST种数；</p>
</li>
<li>
<p>状态转移：选<code>j</code>为根节点，左子树有<code>j-1</code>个节点，右子树有<code>i-j</code>个节点，总种数为<code>dp[j-1] * dp[i-j]</code>（乘法原理）。</p>
</li>
</ol>
<h6 data-id="heading-38">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 计算n个节点（1~n）能组成的不同BST种数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} BST种数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">numTrees</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// 边界条件：0个/1个节点，仅1种BST</span>
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算2~n个节点的种数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 枚举根节点j，拆分左右子树</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
            total += dp[j - <span class="hljs-number">1</span>] * dp[i - j];
        }
        dp[i] = total;
    }

    <span class="hljs-keyword">return</span> dp[n];
}
</code></pre>
<h6 data-id="heading-39">本质</h6>
<p>该问题的解为<strong>卡特兰数</strong>，适用于所有「合法组合数」问题（如括号生成、出栈顺序等）。</p>
<h5 data-id="heading-40">4.1.2 生成所有BST（力扣95题，递归+子问题复用）</h5>
<h6 data-id="heading-41">核心思路</h6>
<p>递归构造闭区间<code>[lo, hi]</code>的所有BST：枚举区间内每个数为根节点，递归生成左右子树的所有组合，再通过笛卡尔积组合左右子树与根节点。</p>
<h6 data-id="heading-42">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 生成n个节点（1~n）的所有不同BST，返回根节点数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode[]</span>} 所有BST根节点数组
 */</span>
<span class="hljs-keyword">var</span> generateTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-comment">// 构造闭区间[1, n]的所有BST</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">1</span>, n);

    <span class="hljs-comment">// 递归构造闭区间[lo, hi]的所有BST</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">lo, hi</span>) {
        <span class="hljs-keyword">const</span> res = [];
        <span class="hljs-comment">// 边界条件：lo&gt;hi，添加null（保证叶子节点能被正确创建）</span>
        <span class="hljs-keyword">if</span> (lo &gt; hi) {
            res.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// 枚举根节点</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = lo; i &lt;= hi; i++) {
            <span class="hljs-comment">// 递归生成左右子树的所有组合</span>
            <span class="hljs-keyword">const</span> leftTrees = <span class="hljs-title function_">build</span>(lo, i - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">const</span> rightTrees = <span class="hljs-title function_">build</span>(i + <span class="hljs-number">1</span>, hi);
            <span class="hljs-comment">// 组合左右子树与根节点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> left <span class="hljs-keyword">of</span> leftTrees) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> right <span class="hljs-keyword">of</span> rightTrees) {
                    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);
                    root.<span class="hljs-property">left</span> = left;
                    root.<span class="hljs-property">right</span> = right;
                    res.<span class="hljs-title function_">push</span>(root);
                }
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</code></pre>
<h4 data-id="heading-43">4.2 二叉搜索子树的最大键值和（力扣1373题，BST综合实战）</h4>
<p>该题是BST后序遍历的经典代表，考察**「子树信息收集与传递」**能力，是大厂面试的高频难题。</p>
<h5 data-id="heading-44">题目要求</h5>
<p>给定一棵二叉树，找到其中<strong>所有合法BST子树</strong>的最大键值和（若所有BST子树和为负，返回0）。</p>
<h5 data-id="heading-45">核心思路</h5>
<ol>
<li>
<p>问题拆解：需要同时完成「判断子树是否为BST」和「计算BST子树和」，两个需求都需要<strong>子树的信息支撑</strong>；</p>
</li>
<li>
<p>后序遍历的优势：后序位置可获取子树的返回信息，能基于子树结果判断当前子树是否为BST、计算和值；</p>
</li>
<li>
<p>四元信息推导：从需求倒推递归需要返回的4个关键信息（缺一不可）：</p>
<ul>
<li>
<p><code>isBST</code>：当前子树是否为合法BST；</p>
</li>
<li>
<p><code>minVal</code>：当前子树的最小值（BST判断的关键）；</p>
</li>
<li>
<p><code>maxVal</code>：当前子树的最大值（BST判断的关键）；</p>
</li>
<li>
<p><code>sumVal</code>：当前子树的节点和（计算最大和的关键）。</p>
</li>
</ul>
</li>
<li>
<p>非BST隔离：非BST子树返回无效最值（<code>Infinity/-Infinity</code>），避免父节点误判。</p>
</li>
</ol>
<h5 data-id="heading-46">优化版实现代码（100%通过所有测试用例）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 找到二叉树中合法BST子树的最大键值和，负和返回0
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 最大键值和/0
 */</span>
<span class="hljs-keyword">var</span> maxSumBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">let</span> maxSum = -<span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 初始负无穷，兼容负权值BST</span>

    <span class="hljs-comment">// 后序遍历，返回四元信息[isBST, minVal, maxVal, sumVal]</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">postOrder</span> = (<span class="hljs-params">node</span>) =&gt; {
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>]; <span class="hljs-comment">// 空节点固定返回</span>
        <span class="hljs-comment">// 递归获取左右子树信息</span>
        <span class="hljs-keyword">const</span> [lBST, lMin, lMax, lSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> [rBST, rMin, rMax, rSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">right</span>);

        <span class="hljs-comment">// 仅合法BST时处理，否则返回无效信息</span>
        <span class="hljs-keyword">if</span> (lBST &amp;&amp; rBST &amp;&amp; node.<span class="hljs-property">val</span> &gt; lMax &amp;&amp; node.<span class="hljs-property">val</span> &lt; rMin) {
            <span class="hljs-keyword">const</span> curSum = lSum + node.<span class="hljs-property">val</span> + rSum;
            maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, curSum);
            <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(lMin, node.<span class="hljs-property">val</span>), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(rMax, node.<span class="hljs-property">val</span>), curSum];
        }

        <span class="hljs-comment">// 非BST返回无效信息，彻底隔离</span>
        <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>];
    };

    <span class="hljs-title function_">postOrder</span>(root);
    <span class="hljs-comment">// 有合法BST则取max(maxSum,0)，无则返回0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, <span class="hljs-number">0</span>);
};
</code></pre>
<h5 data-id="heading-47">核心解题心法</h5>
<p><strong>「从需求倒推条件，从条件倒推数据，让子问题的返回值支撑父问题的所有操作」</strong>，这一思路适用于所有树的子树问题。</p>
<h3 data-id="heading-48">五、BST通用解题心法（精华总结）</h3>
<p>通过以上知识点和题型分析，提炼出3条BST通用解题心法，掌握后可应对99%的BST题目：</p>
<h4 data-id="heading-49">心法1：紧抓「左小右大」和「中序有序」两大核心特性</h4>
<ul>
<li>
<p>涉及<strong>查找、插入、删除、合法性验证</strong>等基础操作，优先用「左小右大」特性引导遍历，减少无效操作；</p>
</li>
<li>
<p>涉及<strong>有序性问题</strong>（第K小、累加、排序、区间查询等），优先利用「中序遍历有序」特性，将BST转化为有序序列处理。</p>
</li>
</ul>
<h4 data-id="heading-50">心法2：树的子树问题，优先考虑后序遍历+自定义返回信息</h4>
<ul>
<li>
<p>一旦题目要求「基于子树结果判断当前节点/子树」（如1373题、平衡树判断），必须用后序遍历；</p>
</li>
<li>
<p>自定义返回信息的推导逻辑：<strong>需求→判断条件→所需数据</strong>，确保子问题的返回值能支撑父问题的所有判断和计算，无冗余、无缺失。</p>
</li>
</ul>
<h4 data-id="heading-51">心法3：BST的构造/组合问题，利用「根节点拆分+乘法原理」</h4>
<ul>
<li>
<p>构造BST时，任意节点都可作为根节点，只需拆分左右子树的节点数/值范围；</p>
</li>
<li>
<p>组合数计算用动态规划（卡特兰数），组合生成用递归+笛卡尔积，复用子问题结果避免重复计算。</p>
</li>
</ul>
<h3 data-id="heading-52">总结</h3>
<p>二叉搜索树是算法学习的重点，其核心价值在于「<strong>高效的有序操作能力</strong>」。从基础的「左小右大」定义，到中序遍历的有序性，再到后序遍历的信息收集，所有知识点和题型都围绕这两个核心特性展开。</p>
<p>学习BST的关键不是死记硬背代码，而是<strong>理解特性背后的逻辑，掌握解题心法的推导过程</strong>：比如从需求倒推递归的返回信息，从特性引导遍历的方向。通过练习基础操作、经典有序问题、进阶构造和子树问题，逐步形成BST的解题思维，最终能灵活应对各类高频考点和面试难题。</p>
<p>掌握BST后，后续可深入学习<strong>平衡二叉树</strong>（红黑树、AVL树），理解如何解决BST链状化导致的效率降低问题，进一步完善树形数据结构的知识体系。</p>
</div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从“回答者”进化为“研究员”：全面解析 Deep Research]]></title>    <link>https://juejin.cn/post/7602216700747956224</link>    <guid>https://juejin.cn/post/7602216700747956224</guid>    <pubDate>2026-02-03T10:20:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602216700747956224" data-draft-id="7602246300453322787" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从“回答者”进化为“研究员”：全面解析 Deep Research"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-02-03T10:20:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从“回答者”进化为“研究员”：全面解析 Deep Research
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:20:58.000Z" title="Tue Feb 03 2026 10:20:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1、背景</h2>
<p>在 AI 问世的两年里，我们习惯了把它当作一个超级百科全书：如果你问它一个事实，它会给出答案；如果你给它一段文字，它会帮你总结。然而，当我们面对“分析某行业未来五年的趋势”或“撰写一份详尽的技术竞品调研报告”这样复杂的任务时，传统的 LLM 往往显得力不从心——它们缺乏深度，容易产生幻觉，且受限于上下文长度。</p>
<p>Deep Research正是为了解决这一痛点而生。它不再是一个简单的聊天机器人，而是具备自主推理能力的“AI 研究员”。</p>
<p>我将会在下面的内容中深入剖析 Deep Research 的运行机制、其背后的工程挑战以及它如何通过“ReAct 范式”重塑信息获取的方式。</p>
<h2 data-id="heading-1">2、什么是 Deep Research</h2>
<p>Deep Research 是 专为网页浏览、数据分析和复杂任务处理而优化的全新功能。与普通 LLM “问什么答什么”的被动模式不同，Deep Research 具备<strong>主动规划</strong>和<strong>深度推理</strong>的能力。</p>
<p><strong>它的核心特征可以概括为：</strong></p>
<p>1.自主性（Autonomy）： 它可以一边思考，一边“查资料”。它不仅是检索信息，还能自主判断信息是否足够，如果不足，它会主动调整搜索关键词再次检索。</p>
<p>2.长链条推理（Long-chain Reasoning）： 基于 LLM的推理能力，它能将一个模糊的庞大需求拆解为多个子步骤，分阶段执行。</p>
<p>3.专业报告生成： 最终输出的不是零散的对话，而是包含逻辑摘要、清晰引用来源和完整文档的专业级研究报告。</p>
<p><strong>为什么我们需要它？</strong> 当前的信息需求往往需要跨越多个来源、阅读大量非结构化数据。Deep Research 实际上降低了“海量信息收集”<strong>与</strong>“高质量推理整合”之间的壁垒，尤其擅长挖掘那些需要浏览数十个网页才能拼凑出的小众或非直观信息。</p>
<h2 data-id="heading-2">3、核心原理：从 DeepSearch 到 DeepResearch</h2>
<p>要理解 Deep Research，通过两个层级来看：底层的搜索循环（DeepSearch）和上层的报告框架（DeepResearch）。</p>
<h3 data-id="heading-3">3.1 核心引擎：DeepSearch（循环与迭代）</h3>
<p>DeepSearch 的本质是一个“搜索 - 阅读 - 推理”的无限循环。这与我们熟悉的 <strong>ReAct Agent</strong> 范式高度相似，但通过强化学习（RL）不仅学会了推理，更学会了“搜索策略”：</p>
<p>•搜索（Search）： 探索互联网，获取原始信息。</p>
<p>•阅读（Read）： 对特定网页进行详尽分析，提取关键片段。</p>
<p>•推理（Think）： 这是最关键的一步。模型会评估当前收集到的信息是否足以回答问题。如果不够，它会决定是将问题拆解为更小的子问题，还是尝试全新的搜索关键词。</p>
<p>这种  →  →  →  →  的模式，让 AI 具备了“自我纠错”和“追根究底”的能力。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e6b379a54fc4d3f9432aaaf2fc12943~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=ph%2BGqOLgE3Oj%2BLSW1%2Bvjo%2BNq1Vk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<h3 data-id="heading-4">3.2 上层框架：DeepResearch（结构化输出）</h3>
<p>DeepSearch 负责找答案，而 DeepResearch 负责写报告。它在 DeepSearch 的基础上增加了一个<strong>结构化框架</strong>：</p>
<p>1.用户意图理解 &amp; 目录生成（TOC）： 接收指令后，首先生成报告目录（如引言、方法论、相关工作、结论）。</p>
<p>2.分章节执行： 系统性地将 DeepSearch 引擎应用到报告的每一个章节中。每个章节都是一个独立的研究任务。</p>
<p>3.全局整合： 最后将所有章节内容整合，进行连贯性润色，生成最终报告。</p>
<p>整个执行过程通常耗时 5 到 30 分钟，这在以前的即时问答中是不可想象的，但对于深度研究来说，却是极高的效率。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ea07a0788d040fc9bf941dcaa476acb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=Hy4jUl8GoCzFUsA6qwpXQF7N%2F14%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>让 LLM 在自身推理过程中与搜索引擎交替交互。用户输入query，LLM产生TOC，然后进入循环：查找、读取和推理，直到达到结束的条件，然后再通过LLM做总结，最终给用户输出完整的研究报告（ →  →  →  →  ）的模式，已经非常接近我们熟悉的 ReAct Agent 范式。不同的是，这里的 Agent 不依赖提示词，而是通过 RL 真正“学会了”搜索策略。实质上就是一个 “带搜索能力的 ReAct Agent”，只不过不再依赖提示词工程，而是直接通过强化学习学会何时搜索、何时推理。注意，它是主动认知到何时需要检索信息，这是一个非常显著的特点和不同。</p>
<h2 data-id="heading-5">4、 工程化挑战与解决方案</h2>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fc47547a948485ca5dfb41326ce9987~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=xEyHaOumuSZuUPpoLpFHBxsjSuY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>Deep Research 之所以能超越普通的 RAG（检索增强生成），在于它解决了一系列棘手的工程问题。通过对技术细节的复盘，我们可以了解到其背后的技术实现。</p>
<h3 data-id="heading-6">4.1 解决“垃圾进，垃圾出”：URL 排序与清洗</h3>
<h4 data-id="heading-7">4.1.1 问题</h4>
<p>Deep Research 在一次任务中可能扫描数百个 URL。如果把这些内容一股脑塞给 LLM，不仅浪费 Token，还会导致模型“瞎选”答案。在每一次 DeepReSearch 漫长过程中，你可能会从搜索引擎结果页（SERP）里收集一堆 URL，每打开一个网页，又能顺藤摸瓜找出不少新链接，就算是去重后，也是轻轻松松几百个网址。同样的，一股脑儿全塞给 LLM 肯定不行，浪费宝贵的上下文长度不说，更要命的是，我们发现 LLM 基本上就是瞎选。所以，得想办法引导 LLM 去挑出那些最有可能包含答案的 URL。</p>
<h4 data-id="heading-8">4.1.2 解决方案：两阶段重排序（Re-ranking）</h4>
<p>URL 排序打分评测是 Deep Research 系统中的关键技术环节，它直接影响到信息获取的效率和质量。系统采用了多层次、多维度的排序策略，确保能够从海量的搜索结果中快速定位最有价值的信息源。​</p>
<p>综合评分机制是 URL 排序的核心。系统会综合考虑多个因素：最后更新时间、域名出现的频率、网页路径结构，以及最重要的与问题的语义相关性，算出一个综合评分​。这种多维度的评分机制能够全面评估 URL 的价值，避免了单一维度排序的局限性。​</p>
<p>具体的评分因素包括：​</p>
<p>1.<strong>频率信号：</strong> 如果某个 URL 在不同的信息源中多次出现，它的权重就会更高。另外，如果某个域名在搜索结果中经常出现，来自这个域名的 URL 也会被加分。因为一般来说，热门域名往往包含更权威的内容。​</p>
<p>2.<strong>路径结构：</strong> 会分析 URL 的路径结构，来判断哪些内容是聚集在一起的。如果多个网址都属于同一个路径层级，它们的分数会更高；但路径越深，分数加成会逐渐减少。​</p>
<p>3.<strong>语义相关性：</strong> 使用 小模型（例如：jina-reranker-v2-base-multilingual）或者大模型 来评估问题和每个 URL 的文本信息（例如标题和摘要）的语义相关性，这是一个典型的重排序问题​。每个 URL 的文本信息来自搜索引擎结果页（SERP）API 返回的标题和摘要，以及页面上 URL 的锚文本。​</p>
<p>4.<strong>最后更新时间：</strong> 有些查询对时效性要求很高，所以一般来说，越新的 URL 价值越高。系统采用一套组合拳，综合考虑 SERP API 提供的筛选功能、HTTP Header 信息分析、元数据提取、内容模式识别等，最终给出一个带有置信度评分的时间戳。​</p>
<p>5.<strong>受限内容识别：</strong> 某些社交媒体平台的内容是受限的，或者需要付费才能访问。系统会积极维护一份黑名单，把这些有问题的 URL 和域名都记录下来，降低它们的排名，避免在这些无法访问的内容上浪费计算资源。​</p>
<p>6.<strong>域名多样性：</strong> 为了提高结果的多样性，避免陷入 "局部最优"，系统采用 "探索 - 利用" 的策略：从每个域名下选择排名 Top K 的 URL。</p>
<p><strong>粗排和精排：</strong></p>
<p>•粗排： 快速筛选，追求召回率。</p>
<p>•精排： 针对粗排结果进行深度评估。这里通常采用基于重排模型（Cross-Encoder）或基于 LLM 的重排序。利用 LLM 的语义理解能力，甚至使用滑动窗口算法（从后向前滑动），对候选段落进行相关性打分，确保只有含金量最高的信息进入下一步。</p>
<p>粗排检索效率较快，但是召回的内容并不一定强相关。而精排效率较低，因此适合在粗排的基础上进行进一步优化。重排的任务就是评估这些上下文的相关性，优先考虑那些最有可能提供准确和相关信息的内容。</p>
<p>重排方法主要分为以下两类：</p>
<p><strong>基于重排模型：</strong> 这些模型可以输出文档与查询之间的相关性；够针对一个查询和文档对，输出它们的相似度分数。我们利用这个分数对文档按照与查询的相关性进行重新排序。解决传统检索方法（如BM25、向量检索）的局限性，例如语义模糊性、长尾关键词漏检、多模态意图理解不足等问题。优化检索结果的Top-K排序，提升后续LLM生成答案的准确性和效率</p>
<p><strong>基于 LLM：</strong> 由于大模型可以更全面地捕捉语义信息，也可被用于重排序。使用 Prompt 的方式引导 LLM 进行重排序。直接利用 LLM 的语义理解能力对所有候选段落进行相关性程度排名。如果文档的数量通常非常大，而 LLM 可能无法一次性处理所有的文本数据。使用滑动窗口算法原理，滑顺序是从后向前的，将前一个窗口中的前两个段落参与下一个窗口的重排序。</p>
<h3 data-id="heading-9">4.2 解决“大海捞针”与“上下文丢失”：长网页内容提取</h3>
<h4 data-id="heading-10">4.2.1 问题</h4>
<p>读取网页内容后，我们需要把它作为一条知识，放到 Agent 的上下文里，供它推理。虽然把全部内容一股脑塞进 LLM 的上下文是最省事的办法，但考虑到 Token 成本和生成速度，这肯定不是最好的选择。在实际应用里，我们需要找出内容中与问题最相关的部分，只把这些部分作为知识添加到 Agent 的上下文里。</p>
<p>我们一边是问题（原始查询或“信息差”问题），另一边是大量的 Markdown 内容，其中大部分内容都是无关紧要的。我们需要选出与问题最相关的片段。</p>
<p><strong>有限数量文档中的有限数量的文本块：</strong> 假设每个块大约有 500 个 Token，那么一个典型的长网页文档大约有 20 万 Token（中位数）到 100 万 Token。我们每一步抓取 4-5 个 URL，这样大概会产生几百个文本块。也就是说，几百个向量和几百个余弦相似度。在内存里就能轻松处理，根本不需要向量数据库。</p>
<p><strong>我们需要连续的文本块来形成有效的知识摘要：</strong> 我们不能接受由分散的句子组成的摘要。更有用的知识摘要，更能保持文本的连贯性。这样 LLM 更容易从知识源中复制和引用，也能减少“幻觉”。</p>
<p>网页内容动辄数万 Token，且充满噪音。如何提取有效信息且保持上下文连贯？</p>
<h4 data-id="heading-11">4.2.2 解决方案：迟分算法（Late Chunking）</h4>
<p>传统的 RAG 会直接把文档切块（Chunking）然后向量化，但这会导致切块丢失全局上下文（例如一个代词“它”在切块后不知道指代谁）。</p>
<p>•<strong>Late Chunking（迟分）：</strong> 这是一个极其精妙的优化。它不急着切块，而是先用支持超长上下文的模型（如 jina-embeddings-v3）对整个文档进行编码，保留全局语义。</p>
<p>长文档切块，有俩个问题，第一个问题是：文本块分割得准不准，这不仅关系到搜索结果好不好读，还关系到做 RAG 的时候，给 LLM 喂进去的文本块是不是正好，不多不少；第二个问题是：每个分块里的上下文信息容易丢失。文档切完之后，下一步就是把每个分块拿去批量向量化。但这么做容易把原文档里的全局上下文信息给丢了。</p>
<p>迟分（Late Chunking）主要就是解决第二个问题 —— 上下文丢失。它不是用来找最佳断点或者语义边界的。该用正则表达式，启发式方法，或者其他技术来分块，还是得用。</p>
<p>但迟分不一样的地方是，它不是一切完就立马把每个块拿去向量化，而是先把整个文档在一个上下文窗口里编码了（jina-embeddings-v3最新 SOTA 向量模型，支持 8192 Token 的长输入），然后再根据边界线索去进行均值池化操作。</p>
<p>它的工作原理类似于一维卷积（Conv1D）。这个过程首先把一个长文档分割成固定长度的块，然后用开启了迟分的 jina-embeddings-v3 向量化这些文本块。计算完每个块和问题之间的相似度分数后，一个滑动窗口会在这些相似度分数上移动，以找到平均值最高的窗口。</p>
<p>用迟分和类似“一维卷积”的平均池化，挑出跟问题最相关的段落。</p>
<p>•<strong>均值池化：</strong> 在生成向量后，再根据边界线索进行切分和均值池化。 这就像是先读完一整本书理解了全意，再回过头去摘录段落，而不是每读一段就摘录一段。这样提取出的“知识块”既精准又保留了上下文，极大减少了 LLM 的幻觉。</p>
<h3 data-id="heading-12">4.3 解决“写不长”：突破 Token 输出限制</h3>
<h4 data-id="heading-13">4.3.1 问题</h4>
<p><strong>上下文窗口的根本性限制：</strong> 大部分模型，例如：DeepSeek-V3，单次输出通常限制在 8K Token（约 8000 字）以内，难以一次性生成数万字的详尽报告。（可能有人会提出好多模型输出几万字或者几十万字，例如GPT-5和Claude Opus等，但是又会出现下面"上下文腐烂" 现象的问题）。</p>
<p><strong>"上下文腐烂" 现象：</strong> 当智能体开始频繁调用多次工具，每次调用返回的 "观察结果" 都会追加到对话历史中，导致上下文长度爆炸式增长。这不仅带来高昂的计算成本，更会导致 "上下文腐烂" (Context Rot)—— 随着上下文变长，模型性能反而下降。​</p>
<p>具体表现为：​</p>
<p>1.性能下降：随着上下文长度增加，模型性能会明显下降。Anthropic 把这个现象称为 "上下文腐烂"（context rot）。具体表现是模型开始重复输出、推理速度变慢、回答质量下降​。​</p>
<p>2.注意力分散：Agent 的上下文随时间推移必然熵增，导致注意力机制分散。​</p>
<p>3.信息利用效率降低：研究发现，当相关信息位于长输入上下文的开头或结尾时，模型的性能表现最佳，而当信息被放置在中间位置时，性能会显著下降。此外，在长上下文任务中，模型有时会倾向于直接依赖其预训练的参数知识来回答问题，而不是有效利用所提供的外部长文本，这进一步加剧了性能的下降​。</p>
<h4 data-id="heading-14">4.3.2 解决方案：双层级 Agent 架构（Planner + Workers）</h4>
<p>Deep Research 实际上采用了一种“规划-执行”的分离架构：</p>
<p>•规划 Agent (Planner)： 它是“包工头”。负责理解任务，生成详细的 JSON 格式大纲，并分配每个章节的字数预算。</p>
<p>•执行 Agent 集群 (Workers)： 它是“建筑工”。多个 Agent 并行工作，每个 Agent 认领一个章节的标题，独立去搜索、阅读和写作。</p>
<p>•聚合器： 最后由一个模块像拼积木一样将各章节拼接，并进行逻辑顺滑和长度控制。</p>
<p>﻿</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5f949f5fa5b49d39c36d8af8eb0e9d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770718858&amp;x-signature=m3NX1YnrKG%2BnlYhrOL4F0rEDe0w%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p><strong>双层架构的核心设计包括：​</strong></p>
<p>1.监督者层级：作为系统的 "大脑"，负责将模糊需求转化为可执行计划。在 prompts.py 中定义的结构化提示模板指导规划器完成三项核心任务：需求澄清（通过 clarify_with_user 节点实现）、子主题分解（最大支持 5 个并行子任务）、以及资源分配（根据主题复杂度选择模型与工具）。​</p>
<p>2.执行者层级：负责具体的信息检索、内容提取和初步分析工作。执行者层级包含多个专门的 Agent，如搜索 Agent、阅读 Agent、分析 Agent 等，每个 Agent 负责特定的任务。​</p>
<p>3.状态机控制：基于 LangGraph 构建的状态机实现了复杂流程的精确控制。状态机能够跟踪研究过程的每个步骤，确保任务执行的有序性和完整性。​</p>
<p><strong>上下文管理的创新方案：​</strong></p>
<p>为了缓解上下文腐烂问题，系统采用了多种上下文管理策略：​</p>
<p>1.上下文卸载技术：系统采用 "上下文卸载"来缓解上下文污染，这能帮 agent 保持在正确轨道上。上下文卸载就是把信息存在语言模型的 "活跃上下文窗口" 之外。把关键信息卸载出去，只在需要时检索，我们就避免了模型工作内存的 "过载"​。​</p>
<p>2.分级存储架构：在于引入分级存储架构。通过将信息按照重要性和使用频率进行分级存储，系统能够在有限的上下文中保留最重要的信息，同时在需要时快速检索其他信息。​</p>
<p>3.智能剪枝策略：系统采用上下文剪枝技术。这个技巧是在 RAG 的基础上做的优化。它的核心是在将检索到的信息交给主模型之前，先进行一次 "剪枝"。具体做法是：先检索出相关文档，然后使用一个更小、更快的模型，让它读一遍这些文档，这个小模型的任务是，根据用户的原始问题，只从文档中提取最核心、最相关的信息​。</p>
<p><strong>长文档处理的技术突破：​</strong>​</p>
<p>1.分段处理策略：系统将长文档分成多个段落或章节，每个部分独立处理，然后通过监督者层级进行整合。这种方法避免了一次性处理整个长文档带来的上下文限制问题。​</p>
<p>2.增量生成机制：系统采用增量生成的方式处理长篇报告。监督者层级负责制定整体结构和各部分的生成顺序，执行者层级按照顺序逐步生成各部分内容。这种方式不仅避免了输出长度限制，还提高了生成内容的连贯性。​</p>
<p>3.智能整合算法：在各部分内容生成后，监督者层级会对内容进行智能整合。这包括检查逻辑一致性、消除重复内容、优化章节顺序等，确保最终报告的质量。</p>
<h3 data-id="heading-15">4.4 生成内容打分</h3>
<p>Deep Research 在生成内容的质量控制方面采用了多层次、多维度的评分和优化机制，确保最终输出的内容既准确又有价值。​</p>
<p>自适应评估框架是内容评分的基础。包括两个互补的评估框架来评估 DRA 能力：RACE（基于参考的自适应标准驱动评估框架，具有动态加权）用于评估生成研究报告的质量，FACT（事实丰富性和引用可信度框架）用于评估信息检索有效性和引用准确性​。​</p>
<p><strong>RACE 框架的核心特点包括：​</strong></p>
<p>1.动态权重分配：对于每个任务，评判 LLM 通过多次试验获得每个维度的权重，并取平均值作为最终权重，确保评估与任务意图一致​。所有维度的生成标准被聚合到一个综合列表中，评判 LLM 然后根据每个标准分析目标报告和参考报告，为两份报告生成每个标准的分数列表，用于最终得分计算。​</p>
<p>2.多维度评估：框架首先基于领域知识确立四个顶层评测维度：全面性（COMP）、洞察力 / 深度（DEPTH）、指令遵循（INST）和可读性（READ）。对于每个具体任务，评判 LLM 会动态计算各维度的权重，并为每个维度生成一组定制化的评测标准。​</p>
<p>3.自适应逐点质量评估：评估模块包含自适应逐点质量评估和主动事实核查两大核心组件，既解决了 "判分死板" 的问题，又实现了 "全面查错" 的目标。自适应逐点质量评估打破了固定维度的限制，为每个任务量身定制评分标准。该组件首先保留 4 个通用评估维度，同时针对每个具体任务自动生成 1-3 个专属评估维度。​</p>
<p>主动事实核查机制确保了内容的准确性。系统不会只傻傻地检查报告里标出来的引用来源，而是会像一个侦探一样主动去网上搜索交叉验证报告里的每一个说法，不管你有没有给出处，这就保证了评分的绝对严格​。​</p>
<p><strong>这种机制的实现包括：</strong> ​</p>
<p>1.自动识别关键陈述：系统会自动识别报告中的关键陈述和数据，包括事实性描述、数值数据、因果关系等。​</p>
<p>2.多源交叉验证：对于每个关键陈述，系统会从多个独立来源进行验证，确保其准确性。​</p>
<p>3.置信度评估：系统会为每个验证结果给出置信度评分，高置信度的内容会被保留，低置信度的内容会被标记为需要进一步核实。​</p>
<p><strong>内容修改与优化策略：</strong> 基于评分结果，系统会采用多种策略对内容进行修改和优化：​</p>
<p>1.基于评分的自动修正：当系统发现内容存在事实错误或逻辑问题时，会自动进行修正。这种修正不是简单的替换，而是基于多个可靠来源的信息进行综合判断。​</p>
<p>2.人工干预机制：对于复杂的问题或存在争议的内容，系统会提示用户进行人工干预，确保最终内容的准确性和客观性。​</p>
<p>3.风格一致性优化：系统会检查整篇报告的语言风格、术语使用、格式规范等，确保全文的一致性和专业性。​</p>
<p>4.结构优化：根据内容的逻辑关系，系统会对报告的结构进行优化，确保章节安排合理、层次分明。</p>
<h2 data-id="heading-16">5、 Deep Research vs Manus</h2>
<p>Manus 更像是一个高度工程化的 Agent 平台，它整合了大量工具（浏览器、代码解释器等），强在“调度”。而 Deep Research 是模型层面和架构层面的进化，它通过强化学习或者架构优化让模型了解“如何搜索”和“如何推理”的策略，是一种更原生和自主的智能。所以Deep Research可以进行撰写文献综述、市场与竞品分析、行业研报、投融资研报、市场调研、新闻热点追踪、生活决策等，也可以在检索时沉淀有用信息。</p>
<h2 data-id="heading-17">6、总结</h2>
<p>Deep Research是我在25年年中接触的，当时感觉就很惊艳，感觉正在跨越到一个新的门槛：从信息的搬运工，变成了信息的加工者。它不再需要用户费尽心思想 Prompt，也不需要用户去点击一个个的链接。它展示了 AI 作为一个“思考者”的潜力——它知道自己不知道什么，并且知道去哪里找到答案。对于使用者而言，这意味着我们可以将最耗时的“信息收集与整理”阶段外包给 AI，从而专注于更高维度的决策与创新。</p>
<p>后面会继续写我怎么在真实业务中利用DeepResearch的能力，最后祝大家早安、午安、晚安。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android ViewModel 的简单用法]]></title>    <link>https://juejin.cn/post/7602205524719009826</link>    <guid>https://juejin.cn/post/7602205524719009826</guid>    <pubDate>2026-02-03T10:31:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524719009826" data-draft-id="7602246300452995107" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android ViewModel 的简单用法"/> <meta itemprop="keywords" content="Android,Android Jetpack"/> <meta itemprop="datePublished" content="2026-02-03T10:31:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yen"/> <meta itemprop="url" content="https://juejin.cn/user/4037062426633214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android ViewModel 的简单用法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4037062426633214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:31:09.000Z" title="Tue Feb 03 2026 10:31:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、ViewModel 概述</h2>
<h3 data-id="heading-1">1.1 什么是 ViewModel</h3>
<p>ViewModel 是 Android Jetpack 架构组件之一，用于<strong>以生命周期感知的方式存储和管理 UI 相关数据</strong>。</p>
<h3 data-id="heading-2">1.2 主要特性</h3>
<ul>
<li><strong>生命周期感知</strong>：自动管理数据生命周期</li>
<li><strong>配置变更存活</strong>：屏幕旋转等配置变更时数据不会丢失</li>
<li><strong>UI 数据存储</strong>：专门为 UI 准备和管理数据</li>
<li><strong>分离关注点</strong>：帮助实现 MVVM 架构模式</li>
</ul>
<h2 data-id="heading-3">二、ViewModel 的核心作用</h2>
<h3 data-id="heading-4">2.1 解决的主要问题</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 传统方式的问题：数据在配置变更时丢失</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>  <span class="hljs-comment">// 旋转屏幕时会重置！</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<h3 data-id="heading-5">2.2 ViewModel 的优势</h3>






























<table><thead><tr><th>特性</th><th>传统方式</th><th>ViewModel</th></tr></thead><tbody><tr><td>配置变更</td><td>数据丢失</td><td><strong>数据保留</strong></td></tr><tr><td>生命周期</td><td>手动管理</td><td><strong>自动管理</strong></td></tr><tr><td>内存泄漏</td><td>易发生</td><td><strong>不易发生</strong></td></tr><tr><td>测试难度</td><td>困难</td><td><strong>容易测试</strong></td></tr></tbody></table>
<h2 data-id="heading-6">三、基本用法</h2>
<h3 data-id="heading-7">3.1 添加依赖</h3>
<pre><code class="hljs language-gradle" lang="gradle">// build.gradle (app)
dependencies {
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.0"
    // 或使用最新版本
}
</code></pre>
<h3 data-id="heading-8">3.2 创建 ViewModel</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 简单 ViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _counter = MutableLiveData(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> counter: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = _counter
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> {
        _counter.value = (_counter.value ?: <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
    }
    
    <span class="hljs-comment">// ViewModel 销毁时的清理工作</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCleared()
        <span class="hljs-comment">// 释放资源</span>
    }
}

<span class="hljs-comment">// 2. 带参数的 ViewModel（需要使用 Factory）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userId: String) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _user = MutableLiveData&lt;User&gt;()
    <span class="hljs-keyword">val</span> user: LiveData&lt;User&gt; = _user
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 加载用户数据</span>
    }
}
</code></pre>
<h3 data-id="heading-9">3.3 在 Activity/Fragment 中使用</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Activity 中使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: MyViewModel
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        
        <span class="hljs-comment">// 获取 ViewModel 实例</span>
        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MyViewModel::<span class="hljs-keyword">class</span>.java)
        
        <span class="hljs-comment">// 观察 LiveData</span>
        viewModel.counter.observe(<span class="hljs-keyword">this</span>) { count -&gt;
            updateCounterUI(count)
        }
        
        <span class="hljs-comment">// 触发数据变化</span>
        button.setOnClickListener {
            viewModel.increment()
        }
    }
}

<span class="hljs-comment">// Fragment 中使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()  <span class="hljs-comment">// Kotlin 扩展方式</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)
        
        viewModel.counter.observe(viewLifecycleOwner) { count -&gt;
            <span class="hljs-comment">// 更新 UI</span>
        }
    }
}
</code></pre>
<h2 data-id="heading-10">四、ViewModel 生命周期</h2>
<h3 data-id="heading-11">4.1 生命周期示意图</h3>
<pre><code class="hljs language-text" lang="text">Activity/Fragment Created
        ↓
ViewModel Created (首次创建)
        ↓
Activity/Fragment Started
        ↓
Activity/Fragment Resumed
        ↓
← 屏幕旋转等配置变更 →
（Activity/Fragment 销毁重建，但 ViewModel 保留）
        ↓
Activity/Fragment Destroyed（非配置变更）
        ↓
ViewModel onCleared() 调用
</code></pre>
<h3 data-id="heading-12">4.2 生命周期感知示例</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableLiveData(ViewModelState.IDLE)
    
    <span class="hljs-keyword">init</span> {
        <span class="hljs-comment">// ViewModel 创建时调用</span>
        loadInitialData()
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// ViewModel 销毁时调用（当 Activity/Fragment 永久销毁时）</span>
        cleanupResources()
        <span class="hljs-keyword">super</span>.onCleared()
    }
}
</code></pre>
<h2 data-id="heading-13">五、ViewModelFactory</h2>
<h3 data-id="heading-14">5.1 为什么需要 Factory</h3>
<p>当 ViewModel 需要参数时，必须使用 ViewModelProvider.Factory</p>
<h3 data-id="heading-15">5.2 自定义 Factory</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 创建 Factory</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModelFactory</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userId: String,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository
) : ViewModelProvider.Factory {
    
    <span class="hljs-meta">@Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T {
        <span class="hljs-keyword">if</span> (modelClass.isAssignableFrom(UserViewModel::<span class="hljs-keyword">class</span>.java)) {
            <span class="hljs-keyword">return</span> UserViewModel(userId, repository) <span class="hljs-keyword">as</span> T
        }
        <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"Unknown ViewModel class"</span>)
    }
}

<span class="hljs-comment">// 2. 使用 Factory</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: UserViewModel
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        
        <span class="hljs-keyword">val</span> userId = intent.getStringExtra(<span class="hljs-string">"USER_ID"</span>) ?: <span class="hljs-string">""</span>
        <span class="hljs-keyword">val</span> repository = UserRepository()
        <span class="hljs-keyword">val</span> factory = UserViewModelFactory(userId, repository)
        
        viewModel = ViewModelProvider(<span class="hljs-keyword">this</span>, factory).<span class="hljs-keyword">get</span>(UserViewModel::<span class="hljs-keyword">class</span>.java)
    }
}
</code></pre>
<h2 data-id="heading-16">六、ViewModel 的作用域</h2>
<h3 data-id="heading-17">6.1 不同的作用域</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. Activity 作用域 - 同一个 Activity 的多个 Fragment 共享</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">val</span> sharedViewModel: SharedViewModel <span class="hljs-keyword">by</span> viewModels()
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentA</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-comment">// 获取 Activity 级别的 ViewModel</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> activityViewModel: SharedViewModel <span class="hljs-keyword">by</span> activityViewModels()
}

<span class="hljs-comment">// 2. Fragment 作用域 - 仅限于单个 Fragment</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentViewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()
}

<span class="hljs-comment">// 3. Navigation Graph 作用域</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NavFragment</span> : <span class="hljs-type">Fragment</span>() {
    <span class="hljs-comment">// 需要在 nav_graph.xml 中声明</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> navViewModel: NavViewModel <span class="hljs-keyword">by</span> navGraphViewModels(R.id.nav_graph)
}
</code></pre>
<h3 data-id="heading-18">6.2 Navigation 组件中的 ViewModel</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- navigation/nav_graph.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> 
    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/nav_graph"</span>
    <span class="hljs-attr">app:viewModelScope</span>=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span>
</code></pre>
<h2 data-id="heading-19">七、ViewModel 与 LiveData/StateFlow 结合</h2>
<h3 data-id="heading-20">7.1 配合 LiveData</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _users = MutableLiveData&lt;List&lt;User&gt;&gt;()
    <span class="hljs-keyword">val</span> users: LiveData&lt;List&lt;User&gt;&gt; = _users
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _loading = MutableLiveData(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">val</span> loading: LiveData&lt;<span class="hljs-built_in">Boolean</span>&gt; = _loading
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _error = MutableLiveData&lt;String?&gt;()
    <span class="hljs-keyword">val</span> error: LiveData&lt;String?&gt; = _error
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUsers</span><span class="hljs-params">()</span></span> {
        _loading.value = <span class="hljs-literal">true</span>
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> result = repository.getUsers()
                _users.value = result
                _error.value = <span class="hljs-literal">null</span>
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _error.value = e.message
            } <span class="hljs-keyword">finally</span> {
                _loading.value = <span class="hljs-literal">false</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-21">7.2 配合 StateFlow（推荐）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository) : ViewModel() {
    <span class="hljs-comment">// 私有可变的 StateFlow</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(UserUiState())
    <span class="hljs-comment">// 公开只读的 StateFlow</span>
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;UserUiState&gt; = _uiState.asStateFlow()
    
    <span class="hljs-comment">// 密封类定义 UI 状态</span>
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserUiState</span>(
        <span class="hljs-keyword">val</span> users: List&lt;User&gt; = emptyList(),
        <span class="hljs-keyword">val</span> loading: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,
        <span class="hljs-keyword">val</span> error: String? = <span class="hljs-literal">null</span>
    )
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUsers</span><span class="hljs-params">()</span></span> {
        _uiState.update { it.copy(loading = <span class="hljs-literal">true</span>, error = <span class="hljs-literal">null</span>) }
        viewModelScope.launch {
            repository.getUsers()
                .onSuccess { users -&gt;
                    _uiState.update { it.copy(users = users, loading = <span class="hljs-literal">false</span>) }
                }
                .onFailure { error -&gt;
                    _uiState.update { 
                        it.copy(error = error.message, loading = <span class="hljs-literal">false</span>) 
                    }
                }
        }
    }
}
</code></pre>
<h2 data-id="heading-22">八、最佳实践</h2>
<h3 data-id="heading-23">8.1 推荐的架构模式</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. ViewModel 负责业务逻辑</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductViewModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getProductsUseCase: GetProductsUseCase,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    <span class="hljs-comment">// 2. 使用 StateFlow 管理状态</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableStateFlow(ProductState())
    <span class="hljs-keyword">val</span> state = _state.asStateFlow()
    
    <span class="hljs-comment">// 3. 使用 SavedStateHandle 保存临时状态</span>
    <span class="hljs-keyword">var</span> searchQuery: String
        <span class="hljs-keyword">get</span>() = savedStateHandle[<span class="hljs-string">"search_query"</span>] ?: <span class="hljs-string">""</span>
        <span class="hljs-keyword">set</span>(value) { savedStateHandle[<span class="hljs-string">"search_query"</span>] = value }
    
    <span class="hljs-comment">// 4. 使用协程处理异步操作</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadProducts</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = <span class="hljs-literal">true</span>) }
            <span class="hljs-keyword">val</span> result = getProductsUseCase(searchQuery)
            _state.update { it.copy(
                products = result,
                isLoading = <span class="hljs-literal">false</span>
            ) }
        }
    }
}

<span class="hljs-comment">// 5. 数据类定义状态</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductState</span>(
    <span class="hljs-keyword">val</span> products: List&lt;Product&gt; = emptyList(),
    <span class="hljs-keyword">val</span> isLoading: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,
    <span class="hljs-keyword">val</span> error: String? = <span class="hljs-literal">null</span>
)
</code></pre>
<h3 data-id="heading-24">8.2 注意事项</h3>
<ol>
<li><strong>不要持有 Context 引用</strong>（如果需要，使用 AndroidViewModel）</li>
<li><strong>避免直接暴露 MutableLiveData/MutableStateFlow</strong></li>
<li><strong>使用单向数据流</strong>（UI → ViewModel → Repository）</li>
<li><strong>正确处理配置变更</strong>（使用 SavedStateHandle）</li>
<li><strong>及时清理资源</strong>（重写 onCleared 方法）</li>
</ol>
<h3 data-id="heading-25">8.3 使用 AndroidViewModel（需要 Context 时）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAndroidViewModel</span>(
    application: Application,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: MyRepository
) : AndroidViewModel(application) {
    
    <span class="hljs-comment">// 可以安全地使用 application context</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context = getApplication&lt;Application&gt;().applicationContext
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 使用 context</span>
        <span class="hljs-keyword">val</span> packageName = context.packageName
    }
}
</code></pre>
<h2 data-id="heading-26">九、测试 ViewModel</h2>
<h3 data-id="heading-27">9.1 单元测试示例</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@RunWith(JUnit4::class)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModelTest</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> viewModel: UserViewModel
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mockRepository = mockk&lt;UserRepository&gt;()
    
    <span class="hljs-meta">@Before</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> {
        viewModel = UserViewModel(mockRepository)
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> myTest = runTest {</span>
        <span class="hljs-comment">// Given</span>
        <span class="hljs-keyword">val</span> mockUsers = listOf(User(<span class="hljs-string">"1"</span>, <span class="hljs-string">"John"</span>))
        coEvery { mockRepository.getUsers() } returns Result.success(mockUsers)
        
        <span class="hljs-comment">// When</span>
        viewModel.loadUsers()
        
        <span class="hljs-comment">// Then</span>
        viewModel.uiState.test {
            <span class="hljs-keyword">val</span> initialState = awaitItem()
            assertTrue(initialState.loading)
            
            <span class="hljs-keyword">val</span> finalState = awaitItem()
            assertFalse(finalState.loading)
            assertEquals(mockUsers, finalState.users)
        }
    }
}
</code></pre>
<h2 data-id="heading-28">十、总结</h2>
<p>ViewModel 是 Android 架构的核心组件：</p>
<ol>
<li><strong>管理 UI 数据</strong>的生命周期</li>
<li><strong>在配置变更时保留数据</strong></li>
<li><strong>促进关注点分离</strong>（UI 逻辑 vs 业务逻辑）</li>
<li><strong>便于测试</strong>（不依赖 Android 组件）</li>
<li><strong>支持数据共享</strong>（在 Fragment 之间）</li>
</ol>
<p>正确使用 ViewModel 可以大大提高应用的可维护性、可测试性和稳定性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[中断的理解与代码实现]]></title>    <link>https://juejin.cn/post/7602440800295813166</link>    <guid>https://juejin.cn/post/7602440800295813166</guid>    <pubDate>2026-02-03T10:24:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295813166" data-draft-id="7601144981171372082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="中断的理解与代码实现"/> <meta itemprop="keywords" content="嵌入式"/> <meta itemprop="datePublished" content="2026-02-03T10:24:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RobotMu"/> <meta itemprop="url" content="https://juejin.cn/user/2684353293115578"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            中断的理解与代码实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2684353293115578/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RobotMu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:24:25.000Z" title="Tue Feb 03 2026 10:24:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是中断</h2>
<h3 data-id="heading-1">中断定义</h3>
<p>中断是指在主程序运行过程中，出现了特定的中断触发条件（<strong>中断源</strong>），使得 CPU 暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。</p>
<h3 data-id="heading-2">具象理解</h3>
<p>中断和生活中的中断差不多，比如我们正在闲适地看书呢（<code>主程序</code>），突然导师发来一条消息（<code>中断源</code>），说论文写怎么样了，这时候就不得不放下书本夹好书签，赶紧转去写论文（<code>处理中断</code>）好跟老师交差，然后再重新享受读书时光（<code>返回主程序继续执行</code>）。</p>
<p>中断系统的好处是效率更高，<strong>只有出现中断触发条件</strong>，才会去执行中断。</p>
<p>还是上面的例子，你的计划是在导师催促写论文之前看会书，没有中断机制的系统 belike：</p>
<blockquote>
<p>只能边看书边捧着手机打开聊天框，盯着老师的头像反复查看有没有消息过来（<strong>轮询</strong>）</p>
</blockquote>
<p>但是有中断就不一样啦，只管看书就行，收到导师消息再处理就可以啦。</p>
<h3 data-id="heading-3">中断优先级</h3>
<p>中断也是有优先级的，好比看书的时候同时来了两件事，<em>一边是导师的Push信息，一边是好哥们的海克斯大乱斗邀请</em>，你选哪个先处理？在这个例子中前者的<strong>优先级明显更高，所以会优先处理</strong>。这就是优先的概念。</p>
<h4 data-id="heading-4">抢占 / 响应优先级</h4>
<p>优先级分为两种：抢占优先级和响应优先级，<strong>抢占可以理解成能不能插队，响应则是怎么排队</strong>。两种优先级都遵循<strong>数字越小，优先级越高</strong>的规律，且<strong>抢占优先级高于响应优先级</strong>，或者说先比较抢占再比较响应。</p>
<p><strong>在<code>CPU</code>的世界里没有先来后到，完全按轻重缓急来决定执行顺序。</strong></p>
<blockquote>
<p>这里我们以医院叫号的例子来理解，每一位来医院就诊的病人在系统中都有两种信息，第一条信息表示患者是急诊还是常规就诊（<strong>抢占优先级</strong>），第二条信息表示患者的具体病情（<strong>响应优先级</strong>）。</p>
<p>诊室里有位病人正在就诊中，走的常规就诊通道，但这时候突然送来了一位急诊患者，<strong>情况更加紧急</strong>，就会打断当前患者的就诊过程优先治疗；当多名患者都是急诊或常规就诊时，具体的就诊顺序就由第二条信息决定，比如一位患者感冒一位患者骨折，则骨折患者优先叫号。但是如果感冒患者已经在就诊中，骨折患者是<strong>没法插队</strong>的。</p>
</blockquote>
<h3 data-id="heading-5">中断嵌套</h3>
<p>还有一种现象叫中断嵌套，中断嵌套就是你正看书呢，然后收到了好哥们的大乱斗邀请，转到玩游戏中去了，打着打着收到了老师的消息 ...</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05121ae673e040c09f425fc60f299e74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=PAlLnUGusn9%2FUnAtb3z26ynskic%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">EXTI 外部中断学习笔记</h2>
<h3 data-id="heading-7">EXTI 简介</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a0a173dc3d049b2836bc6cfc527a7c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=gcUT%2BzVPfEw9PFODtSGHrN2IEHM%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p>第三点：上升沿指低电平变为高电平触发中断（下降沿相反）；双边沿指只要电平发生变化，就触发中断；<strong>软件触发</strong>是指<code>CPU</code>主动让<code>EXTI</code>假装被触发了一次，然后<strong>完整地走一遍正常触发中断</strong>的流程，区别如下：</p>
<blockquote>
<p>正常流程：电平变化 --- 触发中断 --- 执行中断程序</p>
<p>软件触发：代码设置 --- 触发中断 --- 执行中断程序</p>
</blockquote>
</li>
<li>
<p>第四点：相同的<code>Pin</code>不能同时触发中断是由内部硬件结构决定的，STM32里只有<code>16</code>条<code>EXTI</code>线，不是<code>PA0</code>一条，<code>PB0</code>一条，而是所有的<code>x0</code>引脚共用<code>EXTI0</code>。<em>就像只有一个插座，但是有多个插头都可以插</em>。</p>
</li>
<li>
<p>第六点：当中断条件触发时，既可以选择触发中断，也可以选择触发一个事件，此时外部中断的信号不会通向<code>CPU</code>，而是通向其他外设，用来触发其他外设的操作。</p>
<blockquote>
<p>这里的事件是什么还没搞清楚，只知道<strong>不是我们想的自己编写的函数</strong></p>
</blockquote>
</li>
</ul>
<hr/>
<h3 data-id="heading-8">STM32之编写中断函数</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/197364c363b8482a9e66ae7ffc044e87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ib3RNdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770719067&amp;x-signature=zyeO1b1LVNnY%2BCF40rua7C0EIXA%3D" alt="image-20260202194433449.png" loading="lazy"/></p>
<p>在编写中断函数时，借助内部的结构图可以更好地理清思绪，<strong>逻辑上就是搭建一个完整的从<code>GPIO</code>外设到<code>NVIC</code>的链路。</strong></p>
<h4 data-id="heading-9">具体步骤</h4>
<blockquote>
<ol>
<li>配置RCC，把我们这里涉及的外设的时钟都打开；</li>
<li>配置GPIO，选择我们的端口为输入模式；</li>
<li>配置AFIO，选择我们用的这一路GPIO，连接到后面的EXTI；</li>
<li>配置EXTI，选择边沿触发方式，比如上升沿，下降沿或者双边沿；还有选择触发相应方式，可以选择<strong>中断响应（一般都是这个）</strong> 和事件响应；</li>
<li>配置NVIC，给我们这个中断选择一个合适的优先级；</li>
</ol>
<p>最后通过NVIC，外部中断信号就能进入CPU了；</p>
</blockquote>
<p>通过<strong>对射式红外传感器计次</strong>的具体代码实现可以看得更清楚：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span>

<span class="hljs-type">uint16_t</span> CountSensor_Count;

<span class="hljs-type">void</span> <span class="hljs-title function_">CountSensor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-comment">// 1、配置RCC，把我们这里涉及的外设的时钟都打开（GPIO AFIO EXTI NVIC)</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	<span class="hljs-comment">// EXTI和NVIC两个外设的时钟是一直开着的，不需要设置</span>
	
    <span class="hljs-comment">// 2、配置GPIO，和前面一样</span>
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &amp;GPIO_InitStruct);
	
    <span class="hljs-comment">// 3、配置AFIO，选择我们用的这一路GPIO，连接到后面的EXTI</span>
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
	
    <span class="hljs-comment">// 4、配置EXTI，选择边沿触发方式，选择触发响应方式等</span>
	EXTI_InitTypeDef EXTI_InitStruct;
	EXTI_InitStruct.EXTI_Line = EXTI_Line14; 				<span class="hljs-comment">//	EXTI14号线 </span>
	EXTI_InitStruct.EXTI_LineCmd = ENABLE; 					<span class="hljs-comment">// 	开启中断</span>
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt; 		<span class="hljs-comment">// 	响应方式为中断响应</span>
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; 	<span class="hljs-comment">// 	下降沿</span>
	EXTI_Init(&amp;EXTI_InitStruct);
	
    <span class="hljs-comment">// 5、配置NVIC，给我们这个中断选择一个合适的优先级</span>
	
	<span class="hljs-comment">// 在配置中断之前，先指定一下中断的分组，这里选了2位抢占2位响应</span>
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef  NVIC_InitStruct;
	NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn; <span class="hljs-comment">// 因为我们设置的EXTI14</span>
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>; <span class="hljs-comment">// 抢占优先级</span>
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>; <span class="hljs-comment">// 响应优先级</span>
	NVIC_Init(&amp;NVIC_InitStruct);
	
}

<span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CountSensor_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">return</span> CountSensor_Count;
}


<span class="hljs-comment">// 中断函数的名字都是固定，建议直接从启动文件（Start第一个）复制</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">if</span>(EXTI_GetITStatus(EXTI_Line14) == SET) <span class="hljs-comment">// 判断标志位</span>
	{
		CountSensor_Count++;
		EXTI_ClearITPendingBit(EXTI_Line14); <span class="hljs-comment">// 清除标志位</span>
	}
}

</code></pre>
<h4 data-id="heading-10">代码小记</h4>
<ul>
<li>
<p>和使用<code>GPIO</code>外设是一样的流程，都是<strong>打开时钟然后初始化</strong>，而<code>EXTI</code>和<code>NVIC</code>的时钟本来就是开着的，所以没有打开时钟这一步；</p>
</li>
<li>
<p>初始化都是同样的套路，甚至名字形式上也是统一的，<strong>除了<code>AFIO</code>的配置外，另外<code>NVIC</code>初始化之前</strong>需要指定优先级的分组类型。其套路如下：</p>
</li>
</ul>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// 根据要配置的外设来定义结构体变量</span>
Which__InitTypeDef  Which_InitStruct;

<span class="hljs-comment">// 用.的方式访问结构体数据（这里会自动弹出，不用死记）</span>
Which_InitStruct.Which = ... ;
...
Which_InitStruct.Which = ... ;

<span class="hljs-comment">// 对结构体变量取值作为参数传入Init函数（这里的参数根据自动弹出的提示来填就行，有时候不止一个，比如GPIO）</span>
Which_Init(&amp;Which_InitStruct);
</code></pre>
<ul>
<li>
<p>配置完各个外设之后就是写中断函数，需要注意中断函数的头是固定的（两个<code>void</code>），对应的<strong>函数名也是固定</strong>的，需要根据我们使用的<code>EXTI</code>线路来对应选择，比如我们使用了<code>EXTI14</code>号线，对应的就是<code>EXTI15_10_IRQHandler</code>;</p>
</li>
<li>
<p>和标志位有关的四个函数</p>
</li>
</ul>
<pre><code class="hljs language-c" lang="c">FlagStatus <span class="hljs-title function_">EXTI_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
ITStatus <span class="hljs-title function_">EXTI_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">EXTI_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span>;
</code></pre>
<blockquote>
<p><code>EXTI</code>线触发之后（<code>Flag</code>标志位），会分成两条路径走，<strong>一种是事件，一种是中断</strong>；</p>
<p>前两个函数处理的标志位是用于说明某条<code>EXTI</code>线是否被触发过，后两个函数处理的标志位是用于说明某条<code>EXTI</code>线是否被配置为中断，并且真的走了中断这条路；</p>
<p><strong>经验法则</strong>：在中断函数中推荐用后两个函数。</p>
</blockquote>
<ul>
<li>关于中断函数</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">void <span class="hljs-built_in">EXTI15_10_IRQHandler</span>(void)
{
    <span class="hljs-built_in">if</span>(EXTI_GetITStatus(EXTI_Line14) == SET) <span class="hljs-comment">// 判断标志位</span>
    {
        CountSensor_Count++;
        <span class="hljs-built_in">EXTI_ClearITPendingBit</span>(EXTI_Line14); <span class="hljs-comment">// 清除标志位</span>
    }
}
</code></pre>
<p>为什么这里要判断一下中断标志位呢？因为<code>EXTI 10 ~ 15</code>号线，共用同一个中断入口，我们需要判断是不是14号线触发的，然后执行相应的逻辑，<strong>再清除对应的标志位</strong>（不清除就卡死在中断里了！！）。</p>
<p>其内部活动类似下面：</p>
<blockquote>
<p>CPU：我被叫进 EXTI15_10 中断了</p>
<p>CPU：先看看是不是 14 号线在叫我</p>
<p>如果是：执行和 14 号线相关的逻辑 + 把 14 号线的小红灯关掉</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程]]></title>    <link>https://juejin.cn/post/7602401081265700900</link>    <guid>https://juejin.cn/post/7602401081265700900</guid>    <pubDate>2026-02-03T10:44:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265700900" data-draft-id="7602411521072168979" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-03T10:44:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OoderAgent实战指南：入境游旅行社游客集合通知邮件发送全流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:44:41.000Z" title="Tue Feb 03 2026 10:44:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本指南以入境游旅行社游客集合通知邮件自动发送为真实业务场景，从基础程序开发到AI Agent化部署、技能桥接全链路拆解OoderAgent的落地方法，充分发挥其低代码、高适配、轻量化部署的优势，适配旅行社无专业服务器、依赖简易设备（NAS/公共办公电脑）的实际办公环境，实现高频业务操作的AI化提效。</p>
<h2 data-id="heading-0">核心业务需求</h2>
<p>为旅行社当天报团的入境游散客发送集合通知邮件，满足以下核心要求：</p>
<ol>
<li>邮件接收人：从Excel表格中读取游客邮箱列数据；</li>
<li>核心信息：支持自然语言输入集合地点、时间，无需固定格式；</li>
<li>发件规范：强制使用旅行社统一对外邮箱，保障品牌一致性；</li>
<li>操作便捷：一线工作人员无需技术背景，自然语言指令即可触发执行。</li>
</ol>
<p>播放</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Fvideo%2F85033" target="_blank" title="https://cloud.tencent.com/developer/video/85033" ref="nofollow noopener noreferrer">OoderAgent 实战指南，10分钟做一个真实应用，P2P服务，零服务依赖</a></p>
<p>OneCode 的视频</p>
<p>视频内容</p>
<h2 data-id="heading-1">实战四步走：从程序开发到AI Agent落地</h2>
<h3 data-id="heading-2">第一步：基础邮件发送程序开发&amp;本地测试启动</h3>
<h4 data-id="heading-3">核心开发要点</h4>
<ol>
<li>Excel数据解析：开发表格读取模块，指定游客邮箱列的解析规则，兼容xlsx/csv等常用格式，支持空值过滤、格式校验；</li>
<li>自然语言信息提取：嵌入基础语义解析逻辑，从输入中提取地点、时间核心字段，无需固定关键词排序；</li>
<li>企业邮箱对接：配置旅行社统一邮箱的SMTP/IMAP协议，完成发件人身份认证、邮件模板（标题/正文）标准化；</li>
<li>批量发送功能：实现邮件批量推送，附带发送状态反馈（成功/失败/数量）。</li>
</ol>
<h4 data-id="heading-4">本地测试验证</h4>
<p>开发完成后本地运行程序，输入测试指令验证核心功能：</p>
<p>测试指令：为我的游客发送集合通知邮件，游客wxl，地点颐和园东宫门，时间下午两点</p>
<p>验证结果：成功识别邮箱、地点、时间，完成批量邮件发送（示例中成功发送5封），无发送异常、信息解析错误。</p>
<h4 data-id="heading-5">开发价值</h4>
<p>完成业务功能的基础闭环，熟手开发+测试仅需5分钟，快速验证技术可行性，为后续Agent化部署打基础。</p>
<h3 data-id="heading-6">第二步：程序调整为「远程Excel部署」</h3>
<h4 data-id="heading-7">核心调整内容</h4>
<ol>
<li>取消本地Excel文件依赖，开发远程文件访问模块，支持旅行社常用的云存储（百度网盘/企业微信云盘/OneDrive）、局域网共享文件夹（NAS/办公电脑）的Excel文件读取；</li>
<li>增加远程文件实时同步&amp;版本校验，确保读取的是最新的游客报名表格，避免数据滞后；</li>
<li>配置远程文件访问权限，仅授权指定工作人员操作，保障游客信息隐私安全。</li>
</ol>
<h4 data-id="heading-8">调整意义</h4>
<p>解决旅行社「多人协作、跨设备办公」的痛点，一线销售/计调无需将Excel表格拷贝到指定设备，远程更新表格后程序可直接读取，提升数据同步效率。</p>
<h3 data-id="heading-9">第三步：服务发布到SkillCenter&amp;远程部署</h3>
<h4 data-id="heading-10">核心部署操作</h4>
<ol>
<li>SkillCenter适配：将邮件发送程序封装为标准化技能服务（Skill），按照OoderAgent的Skill开发规范，定义服务入口、参数格式（自然语言/结构化）、返回结果类型；</li>
<li>轻量化部署：依托旅行社现有简易设备（NAS设备、公共打印机电脑/办公主机）完成SkillCenter部署，无需专业服务器，满足低硬件成本要求；</li>
<li>服务注册与配置：将邮件发送Skill注册到SkillCenter，配置服务名称、触发关键词、权限管理规则。</li>
</ol>
<h4 data-id="heading-11">部署核心目的</h4>
<ol>
<li>满足企业统一邮箱多人操作需求：将发件程序集中部署后，所有工作人员通过统一入口调用，避免个人配置企业邮箱导致的账号泄露、发件格式不统一问题；</li>
<li>保障高频操作稳定性：集合通知发送为旅行社高频业务，集中部署后可实现7*24小时服务可用，避免本地程序因设备故障、关机导致的服务中断；</li>
<li>实现集中化管理：管理员可在SkillCenter统一监控服务运行状态、调用记录、发送数据，便于业务统计和问题排查。</li>
</ol>
<h3 data-id="heading-12">第四步：本地Skills桥接程序开发+游客反馈表单制作</h3>
<h4 data-id="heading-13">模块1：本地Skills桥接程序开发</h4>
<ol>
<li>核心功能：实现本地操作端（电脑/平板）与远程SkillCenter的无缝桥接，支持IDE、CLI、网页端多方式调用，桥接过程零配置、零成本；</li>
<li>自然语言触发适配：桥接程序嵌入OoderAgent的语义交互能力，工作人员无需输入代码/指令格式，直接用自然语言对话即可触发SkillCenter的邮件发送服务；</li>
<li>操作反馈同步：将SkillCenter的邮件发送状态（成功/失败/数量）实时同步到本地操作端，工作人员可即时确认执行结果。</li>
</ol>
<h4 data-id="heading-14">模块2：游客反馈表单制作</h4>
<ol>
<li>表单设计：围绕入境游游客需求，设计简易反馈表单，包含是否收到邮件、集合信息是否清晰、是否有行程疑问、其他需求等核心问题，支持多语言（中/英/日/韩等）适配；</li>
<li>表单挂载：将反馈表单链接嵌入集合通知邮件的正文末尾，方便游客一键打开填写；</li>
<li>反馈数据同步：开发表单数据收集模块，将游客反馈实时同步到旅行社的业务管理表（Excel/小程序），便于计调及时处理游客疑问。</li>
</ol>
<h4 data-id="heading-15">最终落地效果</h4>
<p>一线工作人员仅需在对话框输入自然语言指令，即可完成「远程读取游客邮箱→自动发送集合通知→实时获取发送状态」全流程，无需任何技术操作，真正实现AI提效、零门槛使用。</p>
<h2 data-id="heading-16">场景核心价值：OoderAgent为何适配旅行社行业？</h2>
<h3 data-id="heading-17">1. 贴合入境游行业通讯刚需</h3>
<p>入境游游客的互联网账号体系以邮件为核心，是海外游客最常用、最信任的通讯方式，相比微信/短信，邮件通知的触达率、正式性更高，契合散客预订的业务场景。</p>
<h3 data-id="heading-18">2. 最低成本的AI落地方案</h3>
<p>无需采购专业服务器、无需招聘专职技术人员，依托旅行社现有NAS/办公电脑即可完成全链路部署，Skill桥接过程零成本，一线人员无需培训即可上手，解决中小旅行社「想做AI提效但预算有限、技术能力不足」的痛点。</p>
<h3 data-id="heading-19">3. 高频业务的标准化&amp;稳定性提效</h3>
<p>集合通知发送、行程提醒等属于旅行社高频重复操作，通过OoderAgent实现程序标准化+部署集中化+操作轻量化，既避免了人工发送的漏发、错发问题，又解放了工作人员的时间，使其聚焦于游客服务等核心工作。</p>
<h2 data-id="heading-20">OoderAgent的技术价值：不止于「低代码提效」</h2>
<p>本次实战的核心是业务场景的AI Agent化落地，但OoderAgent的技术价值远不止于低成本的操作提效，其核心竞争力体现在两大底层能力：</p>
<ol>
<li>P2P核心通讯能力：为SkillCenter与本地操作端、远程设备与服务端的连接提供稳定、高速的通讯支持，保障轻量化部署下的服务稳定性，无需依赖第三方云服务；</li>
<li>前沿Skills技术生态：将常用业务字段（地点、时间、游客信息等）抽象配置到Skills模板中，支持网页端可视化配置，后续可快速适配旅行社其他业务（如行程变更通知、签证材料提醒），仅需修改模板参数即可实现新Skill的快速开发，具备极强的业务扩展性。</li>
</ol>
<h2 data-id="heading-21">最终测试验证：全流程自然语言触发</h2>
<p>测试指令：为我的游客发送集合通知邮件，游客wxl，地点颐和园东宫门，时间下午两点</p>
<p>全流程执行结果：</p>
<ol>
<li>自动从远程Excel中读取游客wxl的邮箱数据；</li>
<li>精准提取「颐和园东宫门、下午两点」核心信息；</li>
<li>通过旅行社统一邮箱批量发送5封集合通知邮件；</li>
<li>本地操作端实时反馈「发送成功」状态；</li>
<li>游客可通过邮件内链接填写反馈表单，数据同步至旅行社业务表。</li>
</ol>
<p>执行效率：指令输入后秒级触发，全程无需人工干预，相比人工逐封发送邮件，效率提升10倍以上。</p>
<h2 data-id="heading-22">行业延伸适配</h2>
<p>本实战方案可快速适配旅行社其他高频邮件通知场景：</p>
<ul>
<li>签证材料补交通知</li>
<li>行程变更/天气提醒通知</li>
<li>团费尾款缴纳通知</li>
<li>返程航班确认通知</li>
</ul>
<p>仅需在SkillCenter中修改Skills模板的核心字段和邮件模板，即可实现新场景的快速落地，真正实现「一次开发、多次复用」。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一种轻量级进程间服务隔离方法实践]]></title>    <link>https://juejin.cn/post/7602188264115306511</link>    <guid>https://juejin.cn/post/7602188264115306511</guid>    <pubDate>2026-02-03T10:45:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602188264115306511" data-draft-id="7602216700747972608" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一种轻量级进程间服务隔离方法实践"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-02-03T10:45:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一种轻量级进程间服务隔离方法实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:45:11.000Z" title="Tue Feb 03 2026 10:45:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">系统的复杂性</h2>
<p>我们团队负责的系统是分布式微服务部署架构，随着业务的不断发展壮大和多条线场景化的持续建设丰富，系统的业务逻辑越来越多，功能逻辑也越来越复杂。</p>
<p>﻿</p>
<h3 data-id="heading-1">系统早期单个应用的一个用户故事地图</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77eb8d5b7a5b499eb0a68f2bba921796~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=punYw5iRhe8%2FhxgLLoqj947jGSs%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-2">系统交互</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed397964ee1f42ccadf1ca50ace0e55f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=Tq9T1jyCXWgXoEBwDLP9UepAVyo%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e505874bd1d469ba518d3b180e30cfe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=LfbGMb3ZkYMBiFOJM%2Byk%2BOPspOU%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<h3 data-id="heading-3">物理模型（库表）的复杂性</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c6ef7725857482f80ad2e298c3dd60f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=EQ3%2FbJKCZtaZ67ZvUscJW65ZfQk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-4">一个子系统的代码沉淀</h3>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d783aa32b3294b5a8cb2cc440d3c45ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=dOUD5lqX6WFreOGRrh7%2BLa%2BX8y0%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b896831ad0a40fba2779abbc35f4c53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=zV9qYM7pFqfd0xAbM0gyI0Orc%2Bo%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在应用部署方面，目前现状我们的一个应用对应一个coding代码地址，部署以一个应用为单位发起部署申请，应用下有多个集群，集群下有多个分组，也区分灰度环境、正式线上环境。通过不同的部署编排，使用不同的代码版本部署不同的环境。</p>
<p>﻿</p>
<p>系统的复杂性来自多个方面：业务流程复杂性、架构复杂性、代码实现复杂性、物理模型（库表）的复杂性、监控运维的复杂性等。本文重点不是系统复杂性的治理，而是在现有基础上，如何低成本轻量级方式服务隔离，在大促为系统的稳定性中发挥作用。</p>
<p>﻿</p>
<p>一个容器中部署的应用进程内，提供了各种各样的服务，以在库应用为例，包含了盘点、变更、补货、移库、盘盈亏、预包等相对独立的功能，每个功能又有自己的单据-任务-结果整套业务流程。既有RESTful服务，也有JSF服务，还有MQ消息处理，另外还有定时任务。这些资源虽有线程池隔离，但CPU、内存等资源仍是共享资源，在负载高的时候，比如CPU满载或内存OOM时，会造成服务卡顿，RT时间长，影响服务响应和功能使用。</p>
<p>﻿</p>
<h2 data-id="heading-5">方案</h2>
<h3 data-id="heading-6">方案一：应用拆分</h3>
<p>按业务域、技术域对进行拆分，比如在库应用按盘点、变更、移库、补货等拆分为单独的应用，不仅应用部署做了拆分，对应的数据库层面也按域进行拆分，盘点相关的表，例如盘点单主档、盘点单明细、盘点任务主档、盘点任务明细、盘点结果独立到单独的库中，可以按逻辑库独立，也可以独立到单独的数据库实例中，后者的隔离效果更好。在代码层面，可以将在库coding按域拆分出来单独的代码库，也可以不独立，保持共享代码库，只是在编译时按moudle进行按需集成，例如为盘点应用编译时，包含盘点moudle、公共module，其他不需要的moudle，比如变更module、补货module则不需要参与编译集成。</p>
<p>﻿</p>
<h3 data-id="heading-7">方案二：使用Hystrix进行服务隔离</h3>
<p>Hystrix 主要实现的是‌进程内隔离‌，具体来说，它通过线程池隔离和信号量隔离两种机制，在单个应用进程内部对依赖服务的调用进行资源隔离和故障控制‌。</p>
<h4 data-id="heading-8">‌线程池隔离‌</h4>
<p>Hystrix 为每个依赖服务分配独立的线程池，不同服务的调用请求在各自的线程池中执行，避免因某个服务故障或延迟耗尽整个应用的线程资源‌，这种隔离方式类似于“舱壁隔离”，将故障限制在特定范围内‌。</p>
<p>﻿</p>
<h4 data-id="heading-9">‌信号量隔离‌</h4>
<p>通过控制并发请求的线程数（信号量阈值）实现隔离，适用于耗时短、并发量高的场景（如读缓存）‌。信号量隔离是同步阻塞方式，不涉及线程切换，开销较低‌。</p>
<p>﻿</p>
<h3 data-id="heading-10">方案三：轻量级进程间服务服务隔离</h3>
<p>既不拆分应用，也不需要引入Sping Cloud Hystrix组件，不侵入业务代码，在部署层面实现服务隔离，属于应用内分组机器实例隔离，也是进程间服务隔离。数据库和代码库层面不需要隔离，仍采用共享模式。</p>
<p>以在库为例，为盘点、补货、变更等创建不同的业务分组，当然处于高可用考虑，会为盘点、补货、变更等每个业务分组，又会横跨多个机房分组，不如中云信机房分组、有孚机房分组。</p>
<p>﻿</p>
<p>本文探索实践的方案三示意图如下：</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/841edfbd0b3647318728cdbc4be9cbd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=qGPtxKg26wGmApf0IcSIleJRo%2FQ%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-11">方案简单对比和选择</h3>









































<table><thead><tr><th><strong>方案</strong></th><th><strong>隔离粒度</strong></th><th><strong>隔离效果</strong></th><th><strong>代码侵入性</strong></th><th><strong>实现成本</strong></th><th><strong>落地风险</strong></th><th><strong>落地速度</strong></th></tr></thead><tbody><tr><td>方案一：应用拆分</td><td>应用间隔离</td><td>高</td><td>高</td><td>高</td><td>高</td><td>慢</td></tr><tr><td>方案二：使用Hystrix进行服务隔离</td><td>线程间隔离</td><td>低</td><td>中</td><td>中</td><td>中</td><td>中</td></tr><tr><td>方案三：轻量级进程间服务服务隔离</td><td>进程间隔离</td><td>中</td><td>低</td><td>低</td><td>低</td><td>快</td></tr></tbody></table>
<p>﻿</p>
<p>本文旨在探索一个轻量级的进程级服务隔离方法，短平快，易落地，见效快，可以在大促中快速发挥作用，保障系统的稳定性。</p>
<p>在方案选择上，本文选择方案三进行实操落地。选择方案三，是因为方案三很牛吗？不是的，相比之下方案一和方案二方案更为成熟，行业落地经验更为丰富。</p>
<p>之所以选择方案三，是在众多的因素考量中折中选择，在不同的场景下，采用合适的方案解决相应的痛点，够用 + 1，easy + 1。</p>
<p>方案二和三之间并无冲突，其实可以结合搭配使用。</p>
<p>﻿</p>
<h2 data-id="heading-12">实操</h2>
<h3 data-id="heading-13">隔离部署分组</h3>
<p>配置集合</p>
<p>通过配置集合，实现分组间共享配置，方便多分组管理。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/412c1f699fb3488095955e8f6414e9da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=5TUJzy6rLn9gWLfvATZdRJQG13g%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>跨机房多机房部署</p>
<p>通过多机房部署实现服务高可用。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b8b2f77310045f68e35841fe3af0cb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=aarBbL%2FJT1FG6Rcyto%2FiI2LpNhw%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-14">隔离NP域名</h3>
<p>按域隔离的RESTful，创建单独的NP域名。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6df1f7d96c9a463e8642d0582324900b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=AslAPY9D2n2Gs30%2BQvIYp3NFSJU%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ddc01c0d0f1446c1aaa3ee518ce56089~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=VEJSFrMrcT%2F5FbUv950l4cP1ipY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4307c2a34ade48d48c3d50c462c4c5e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=Or32upHCJa4Zewo5meEYViVpEnY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-15">NGINX拆分流量</h3>
<p>拆分upstream，按照不同域RESTful方法的规则进行路由拆分配置。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22f3b762331e4b2691fbf3814f86c10e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=2KPYiQiRb4BBTeCMsufutHl0gNA%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6914810603d4b3ba8434e283afa7648~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=%2FziMn5f89QrQFU%2FF3s3jVTiqZL4%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<h3 data-id="heading-16">JSF服务隔离</h3>
<p>别名拆分，通过别名隔离服务，调用方无需改动。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bff9677f0ac4033903756c3ca05afc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=FMtvOgHDkWieTs7%2F%2F0L8jqRbBsk%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/740ff0c882694018bed1aee648d11e98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=TZ87O9Gw8EaKFTxGAsiMKJXCsGY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a02b702d21b41468bf310d6baef270b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=k8UiNVGRShgJVYYmU%2BPTsfncZ%2Fs%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>随着服务隔离，同时兼顾机器资源利用率，拆分后的单域内机器数量少于拆分前机器数量，JSF业务线程池大小可适当调大，JSF的单机限流阈值也适当调大。</p>
<p>﻿</p>
<h3 data-id="heading-17">MQ消息队列隔离</h3>
<p>在变更的yml中，只保留变更相关的TOPIC，其他置为NONE。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c3aebfe1b1b47fda66540a08aa3bcf9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=otDvQ0LECL2jXh3S1A2%2FdgY%2BGdY%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在盘点的yml中，只保留盘点相关的TOPIC，其他置为NONE。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a67f64be9dc48ab9ea27f6ab0be64eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=oE3y06n9NAI3s0sBwR7BN7wMFu0%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>其他分组按此调整配置。</p>
<p>﻿</p>
<h2 data-id="heading-18">落地效果</h2>
<h3 data-id="heading-19">RESTFul服务</h3>
<p>对应的logbook自然地按域拆分，方便查询定位流量机器。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5421c33b9cf04d0099a1036d0abf5b18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=SbgoyT0A2ZYXLjHIm4ePzTzKe7w%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38e1a7c58722454bb669ee6dd4ceb24b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=MrfaLsz6EGrEktWnzbWeQy%2BCiJE%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h3 data-id="heading-20">JSF服务</h3>
<p>通过隔离的JSF别名实现流量路由到的机器。</p>
<p>﻿</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed47ad3963f1473aaa1dab8687758578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770720311&amp;x-signature=ZhbNuPq9oAld7B4i4WORAspQqPA%3D" alt="" loading="lazy"/></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 data-id="heading-21">未来演进</h2>
<p>目前，在应用稳定方面，探索并实践落地了一种轻量级进程间服务隔离单元化部署方法，在库和库存按业务域拆分服务部署单元化分组，在库按盘点、补货、变更、导出导出、通用服务部署，库存按库存查询、库容服务、高时效、worker服务等作为独立部署的部署单元，控制爆炸半径，每个部署单元都是双机房高可用，保障系统的稳定性。</p>
<p>未来，随着系统的长期发展，系统复杂性需按域合理拆分治理，业务单元化，服务单元化，系统演进与业务发展齐头并进，相互促进，使系统始终保持在健康的水位，可持续发展</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602225961096052770</link>    <guid>https://juejin.cn/post/7602225961096052770</guid>    <pubDate>2026-02-03T10:49:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961096052770" data-draft-id="7602188264115372047" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:49:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:49:37.000Z" title="Tue Feb 03 2026 10:49:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602225961096069154</link>    <guid>https://juejin.cn/post/7602225961096069154</guid>    <pubDate>2026-02-03T10:50:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961096069154" data-draft-id="7602246300453716003" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:50:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:50:44.000Z" title="Tue Feb 03 2026 10:50:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Amazon Kinesis vs. SQS: Differences & Comparison]]></title>    <link>https://juejin.cn/post/7602188264115388431</link>    <guid>https://juejin.cn/post/7602188264115388431</guid>    <pubDate>2026-02-03T10:52:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602188264115388431" data-draft-id="7602246300453732387" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Amazon Kinesis vs. SQS: Differences &amp; Comparison"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-02-03T10:52:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Amazon Kinesis vs. SQS: Differences &amp; Comparison
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:52:22.000Z" title="Tue Feb 03 2026 10:52:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p># Amazon Kinesis vs. SQS: Differences &amp; Comparison</p>
<p>## Overview</p>
<p>Amazon Web Services \(AWS) offers multiple messaging and streaming services, with Amazon Kinesis and Amazon Simple Queue Service \(SQS) being two of the most widely used options. While both facilitate data movement between application components, they serve fundamentally different purposes and excel in different scenarios. This comprehensive comparison explores their key differences, use cases, and technical considerations.</p>
<p>Before diving into the detailed comparison, the key finding is that Kinesis is optimized for real-time, high-volume data streaming with multiple consumers, while SQS excels at reliable message queuing for decoupling application components with simpler operational requirements.</p>
<p>## Core Concepts and Architecture</p>
<p>### Amazon Kinesis</p>
<p>Kinesis is a platform for streaming data on AWS, allowing real-time processing of high-volume data streams. It's built on the concept of persistent data streams composed of shards, which represent the base throughput unit.</p>
<p>Key components include:</p>
<p>- **Data Streams** : Core service for capturing and storing streaming data</p>
<p>- **Shards** : Base throughput units \(1MB/sec input, 2MB/sec output per shard)</p>
<p>- **Records** : Data units with partition keys for distribution across shards</p>
<p>- **Retention** : Data persists for 24 hours by default, configurable up to 365 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/1.webp)</p>
<p>### Amazon SQS</p>
<p>SQS is a fully managed message queuing service designed to decouple and scale microservices, distributed systems, and serverless applications. It provides a simple queue model with guaranteed at-least-once delivery.</p>
<p>Key components include:</p>
<p>- **Queues** : Standard \(high throughput) or FIFO \(ordered delivery)</p>
<p>- **Messages** : Individual data units \(up to 256KB each)</p>
<p>- **Visibility Timeout** : Period during which messages are invisible after being retrieved</p>
<p>- **Retention** : Messages persist up to 4 days by default, configurable from 1 minute to 14 days</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/2.webp)</p>
<p>## Key Differences</p>
<p>### Purpose and Design Philosophy</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Primary Purpose| Real-time data streaming and analytics| Message queuing and application decoupling|</p>
<p>| Design Focus| High-volume streaming data processing| Reliable message delivery between components|</p>
<p>| Processing Model| Stream processing with multiple consumers| Queue processing with individual consumers|</p>
<p>| Data Lifecycle| Persistent with configurable retention| Deleted after successful processing|</p>
<p>Kinesis is primarily designed for real-time data streaming applications that need to process and analyze large volumes of continuous data. SQS, on the other hand, focuses on reliable message queuing to decouple application components and ensure message delivery.</p>
<p>### Data Model and Consumption Patterns</p>
<p>Kinesis maintains data streams that can be read by multiple consumers simultaneously, allowing for different applications to process the same data independently. With SQS, each message is typically processed by a single consumer and then deleted from the queue.</p>
<p>### Message Ordering and Delivery Guarantees</p>
<p>Kinesis preserves the ordering of records at the shard level, meaning records with the same partition key will be processed in order. SQS offers two queue types:</p>
<p>- **Standard queues** : High throughput with at-least-once delivery but no guaranteed order</p>
<p>- **FIFO queues** : Exactly-once processing with guaranteed ordering but lower throughput</p>
<p>### Scalability Characteristics</p>
<p>| **Feature**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Scaling Model| Manual provisioning or on-demand| Fully automatic|</p>
<p>| Throughput Limits| 1MB/s in, 2MB/s out per shard| 3,000 msgs/sec standard, 30,000 msgs/sec high throughput|</p>
<p>| Maximum Message Size| 1MB| 256KB|</p>
<p>| Operational Overhead| Higher \(shard management)| Lower \(fully managed)|</p>
<p>Kinesis requires explicit capacity planning through shard provisioning, whereas SQS scales automatically to match demand. However, Kinesis can achieve higher overall throughput with appropriate shard allocation.</p>
<p>## Use Cases</p>
<p>### When to Use Kinesis</p>
<p>- **Real-time Analytics** : Processing streaming data for immediate insights</p>
<p>- **IoT Data Processing** : Handling large-scale data from IoT devices</p>
<p>- **Log and Event Data Collection** : Centralized collection of logs and events</p>
<p>- **Clickstream Analysis** : Processing website user activity in real-time</p>
<p>- **Multiple Consumer Applications** : When multiple applications need to process the same data</p>
<p>### When to Use SQS</p>
<p>- **Application Decoupling** : Separating components of distributed applications</p>
<p>- **Task Queues** : Managing job processing and workload distribution</p>
<p>- **Batch Processing** : Queuing items for batch processing workflows</p>
<p>- **Microservice Communication** : Reliable messaging between microservices</p>
<p>- **Load Leveling** : Smoothing out traffic spikes to backend systems</p>
<p>### Hybrid Approaches</p>
<p>Some architectures benefit from using both services together:</p>
<p>- Using Kinesis for initial high-volume data capture and SQS for specific processing tasks</p>
<p>- Implementing Kinesis for real-time processing and SQS for task distribution to workers</p>
<p>## Implementation Details</p>
<p>### Configuration and Management</p>
<p>#### Kinesis Configuration</p>
<p>```</p>
<p># AWS CLI example for creating a Kinesis stream</p>
<p>aws kinesis create-stream --stream-name MyDataStream --shard-count 5</p>
<p>```</p>
<p>Considerations:</p>
<p>- Shard count determines throughput capacity and cost</p>
<p>- Partition key design affects data distribution across shards</p>
<p>- Enhanced fan-out for high-demand consumers requires explicit configuration</p>
<p>- Consumer applications often use Kinesis Client Library \(KCL) with DynamoDB for checkpointing</p>
<p>#### SQS Configuration</p>
<p>```</p>
<p># AWS CLI example for creating an SQS queue</p>
<p>aws sqs create-queue --queue-name MyQueue --attributes DelaySeconds=0,MaximumMessageSize=262144</p>
<p>```</p>
<p>Considerations:</p>
<p>- Queue type selection \(Standard vs. FIFO) based on ordering requirements</p>
<p>- Appropriate visibility timeout to prevent duplicate processing</p>
<p>- Dead-letter queue configuration for handling failed message processing</p>
<p>- Message retention period based on application requirements</p>
<p>### Integration with AWS Ecosystem</p>
<p>#### Kinesis Integrations</p>
<p>Kinesis integrates seamlessly with many AWS services:</p>
<p>- **Lambda** : For serverless stream processing</p>
<p>- **Firehose** : For delivery to S3, Redshift, Elasticsearch, or Splunk</p>
<p>- **Analytics** : For SQL queries against streaming data</p>
<p>- **Data Warehouse Services** : Direct integration with Redshift and S3</p>
<p>#### SQS Integrations</p>
<p>SQS works well with:</p>
<p>- **Lambda** : Direct invocation when messages arrive</p>
<p>- **EC2/ECS** : For traditional worker patterns</p>
<p>- **Step Functions** : For complex workflows</p>
<p>- **EventBridge** : For event-driven architectures</p>
<p>### Best Practices</p>
<p>#### Kinesis Best Practices</p>
<p>- Use shard-level metrics to monitor performance and identify hotspots</p>
<p>- Monitor IteratorAge metric to prevent data loss from expired iterators</p>
<p>- Implement proper exception handling for "poison messages" that can cause batch failures</p>
<p>- Design partition keys to distribute data evenly across shards</p>
<p>- Consider enhanced fan-out for high-throughput consumers</p>
<p>#### SQS Best Practices</p>
<p>- Configure appropriate visibility timeout based on expected processing time</p>
<p>- Implement dead-letter queues to capture and analyze failed messages</p>
<p>- Use batch operations \(SendMessageBatch, ReceiveMessage with MaxNumberOfMessages) for efficiency</p>
<p>- Implement exponential backoff for handling throttling conditions</p>
<p>- Consider long polling to reduce empty responses and API calls</p>
<p>## Cost and Comparison</p>
<p>### Pricing and Cost Optimization</p>
<p>| **Aspect**| **Kinesis**| **SQS**|</p>
<p>| - | - | - |</p>
<p>| Pricing Model| Pay per shard-hour or on-demand| Pay per million requests|</p>
<p>| Small Volume Cost| Higher cost floor| More cost-effective|</p>
<p>| Large Volume Cost| More efficient at very high throughput| Can become expensive at extreme scales|</p>
<p>| Cost Estimation| Based on shard count and data volume| Based on request count and retention|</p>
<p>At small data volumes \(1GB/day), SQS is significantly less expensive \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.20</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">0.20/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.20/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>10.82/month for Kinesis). However, as volume increases to 1TB/day, Kinesis becomes more cost-effective \(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>158</mn><mi mathvariant="normal">/</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>v</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">158/month vs. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">158/</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>201/month for SQS).</p>
<p>### Comparison with Alternative Solutions</p>
<p>#### Kinesis vs. Confluent \(Kafka)</p>
<p>| **Aspect**| **Kinesis**| **Confluent**|</p>
<p>| - | - | - |</p>
<p>| Focus| Streaming data service| Complete streaming platform|</p>
<p>| Data Model| Streams &amp; Shards| Distributed commit logs \(topics)|</p>
<p>| Retention| Up to 365 days| Unlimited potential retention|</p>
<p>| Ecosystem| AWS services integration| Rich connector ecosystem|</p>
<p>| Management| Fully managed by AWS| Self-managed or Confluent Cloud|</p>
<p>Confluent offers greater flexibility and unlimited retention compared to Kinesis' maximum 365-day retention. However, Kinesis provides tighter integration with AWS services and lower operational overhead.</p>
<p>#### Kinesis vs. Redpanda</p>
<p>Redpanda offers higher performance than Kinesis with fewer resources due to its C\+\+ foundation and efficient design. It excels in self-hosted environments with three times fewer nodes than traditional Kafka setups. However, Kinesis benefits from being a fully managed AWS service with automatic scaling and tight AWS ecosystem integration.</p>
<p>## Decision Framework</p>
<p>When choosing between these services, consider:</p>
<p>1. **Data Characteristics** :</p>
<p>    - Volume: High-volume streaming data favors Kinesis</p>
<p>    - Ordering: If strict ordering is required, use Kinesis or SQS FIFO</p>
<p>    - Retention: Long retention needs favor Kinesis</p>
<p>2. **Consumption Pattern** :</p>
<p>    - Single consumer: SQS is simpler</p>
<p>    - Multiple consumers: Kinesis allows multiple applications to process the same data</p>
<p>3. **Operational Preferences** :</p>
<p>    - Fully managed with minimal configuration: SQS</p>
<p>    - Control over scaling and processing: Kinesis</p>
<p>4. **Integration Requirements** :</p>
<p>    - Deep AWS integration: Both work well</p>
<p>    - Event-driven architectures: SQS often simpler</p>
<p>    - Real-time analytics pipeline: Kinesis preferred</p>
<p>## Conclusion</p>
<p>Amazon Kinesis and SQS serve different but complementary purposes in distributed architectures. Kinesis excels at high-volume, real-time data streaming with multiple consumers, while SQS provides simple, reliable message queuing for decoupling application components.</p>
<p>Many modern architectures leverage both: Kinesis for capturing and processing high-volume streaming data and SQS for reliable task distribution and application decoupling. Understanding their distinct characteristics and selecting the right service \(or combination) for your specific use case is essential for building efficient, scalable, and cost-effective cloud-native applications.</p>
<p>If you find this content helpful, you might also be interested in our product [AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fautomq.com%2F" target="_blank" title="https://automq.com/" ref="nofollow noopener noreferrer">automq.com/</a>). AutoMQ is a cloud-native alternative to Kafka by decoupling durability to S3 and EBS. 10x Cost-Effective. No Cross-AZ Traffic Cost. Autoscale in seconds. Single-digit ms latency. AutoMQ now is [source code available](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq" target="_blank" title="https://github.com/AutoMQ/automq" ref="nofollow noopener noreferrer">github.com/AutoMQ/auto…</a>) on github. Big Companies Worldwide are Using AutoMQ. Check the following case studies to learn more:</p>
<p>- [Grab: Driving Efficiency with AutoMQ in DataStreaming Platform](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DIB8sh639Rsg" target="_blank" title="https://www.youtube.com/watch?v=IB8sh639Rsg" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=IB8…</a>)</p>
<p>- [Palmpay Uses AutoMQ to Replace Kafka, Optimizing Costs by 50%\+](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fpalmpay-uses-automq-to-replace-kafka" target="_blank" title="https://www.automq.com/blog/palmpay-uses-automq-to-replace-kafka" ref="nofollow noopener noreferrer">www.automq.com/blog/palmpa…</a>)</p>
<p>- [AutoMQ help Geely Auto\(Fortune Global 500) solve the pain points of Kafka elasticity in the V2X scenario](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" target="_blank" title="https://www.automq.com/blog/automq-help-geely-auto-solve-the-pain-points-of-kafka-elasticity-in-the-v2x-scenario" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [How Asia’s Quora Zhihu uses AutoMQ to reduce Kafka cost and maintenance complexity](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fhow-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" target="_blank" title="https://www.automq.com/blog/how-asias-quora-zhihu-use-automq-to-reduce-kafka-cost-and-maintenance-complexity" ref="nofollow noopener noreferrer">www.automq.com/blog/how-as…</a>)</p>
<p>- [XPENG Motors Reduces Costs by 50%\+ by Replacing Kafka with AutoMQ](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fxpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" target="_blank" title="https://www.automq.com/blog/xpeng-motors-reduces-costs-by-50-by-replacing-kafka-with-automq" ref="nofollow noopener noreferrer">www.automq.com/blog/xpeng-…</a>)</p>
<p>- [Asia's GOAT, Poizon uses AutoMQ Kafka to build observability platform for massive data\(30 GB/s)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fasiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" target="_blank" title="https://www.automq.com/blog/asiax27s-goat-poizon-uses-automq-kafka-to-build-a-new-generation-observability-platform-for-massive-data" ref="nofollow noopener noreferrer">www.automq.com/blog/asiax2…</a>)</p>
<p>- [AutoMQ Helps CaoCao Mobility Address Kafka Scalability During Holidays](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fautomq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" target="_blank" title="https://www.automq.com/blog/automq-helps-caocao-mobility-address-kafka-scalability-issues-during-mid-autumn-and-national-day" ref="nofollow noopener noreferrer">www.automq.com/blog/automq…</a>)</p>
<p>- [JD.com](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging)%255C%255B" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging)%5C%5B" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a> x AutoMQ x CubeFS: A Cost-Effective Journey at Trillion-Scale Kafka Messaging](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fblog%2Fjdcom-automq-cubefs-trillion-scale-kafka-messaging" target="_blank" title="https://www.automq.com/blog/jdcom-automq-cubefs-trillion-scale-kafka-messaging" ref="nofollow noopener noreferrer">www.automq.com/blog/jdcom-…</a>)</p>
<p>![](./amazon-kinesis-vs-sqs-differences-comparison/3.webp)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 AgentScope Java 开家 AI 奶茶店]]></title>    <link>https://juejin.cn/post/7602057555451822134</link>    <guid>https://juejin.cn/post/7602057555451822134</guid>    <pubDate>2026-02-02T07:17:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602057555451822134" data-draft-id="7601728622824898603" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 AgentScope Java 开家 AI 奶茶店"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-02T07:17:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 AgentScope Java 开家 AI 奶茶店
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T07:17:41.000Z" title="Mon Feb 02 2026 07:17:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：屿山</p>
<p>AgentScope 是阿里云推出的一款以开发者为核心，专注于智能体开发的开源框架 <strong>。</strong> 它的核心目标是解决智能体在构建、运行和管理中的难题，提供一套覆盖“开发、部署、调优”全生命周期的生产级解决方案，让智能体应用的开发更简单、运行更稳定、效果持续优化。</p>
<h2 data-id="heading-0">前言</h2>
<p>去年 12 月份，社区正式发布了 AgentScope Java 1.0 版本，面向 Java 开发者提供企业级 Agentic 应用构建的能力。在过去的一个多月，社区快速迭代到了 1.0.7 版本，在这 7 个小版本中，我们更新了很多实用的能力，比如：</p>
<ul>
<li>添加全面的 Ollama 集成，支持聊天和 embedding 功能</li>
<li>新增了对 Agent Skill 的支持</li>
<li>内置的文件操作工具和多模态工具</li>
<li>工具调用 HITL </li>
<li>上下文自动压缩</li>
<li>HTTP 请求和响应内容压缩</li>
<li>MySQL 会话存储</li>
<li>集成 Nacos 的 A2A 架构</li>
<li>集成 Higress 的工具搜索</li>
<li>……</li>
</ul>
<p>至此 AgentScope Java 以 ReActAgent 为核心，配合众多强大的能力，已经能够胜任大多数场景的任务。面对如此多的能力，很多同学在社区反馈光看文档和单一功能的 Example 还是不够效率，不能快速地用好这些能力。为此我们用 AgentScope Java 开了一家奶茶店，来作为一个综合的 Example，为大家演示如何更好地使用 AgentScope Java。</p>
<h2 data-id="heading-1">这家店能干啥？</h2>
<p>首先我们先一起看看这家店能干啥：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16d7969383f640c1aa2087a4d22f8586~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770621461&amp;x-signature=cdkj6EWfzYlJTaC0lxKBwHZxVmM%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>奶茶推荐</strong>：基于 RAG 知识库检索并结合用户偏好分析，回答有理有据，猜你喜欢。</li>
<li><strong>智能下单</strong>：不需要繁琐的表单，自然语言直接下单，Agent 自动识别产品、甜度、冰量。</li>
<li><strong>订单查询 &amp; 用户反馈</strong>：查单、投诉、建议，一站式搞定。</li>
<li><strong>记住你的喜好</strong>：集成 Mem0 长期记忆服务，熟客无须多言，做更懂你的奶茶店。</li>
</ul>
<h2 data-id="heading-2">这家店怎么做的？</h2>
<h3 data-id="heading-3">架构解析</h3>
<p>首先在总体结构上我们采用了 <strong>Supervisor-Worker</strong> 架构，同时集成了一些生态组件来达到最终的效果。</p>
<p>其中 AgentScope 多智能体服务层是由一个 Supervisor Agent 和两个 Sub Agent 构成的智能体系统，负责处理店内大大小小的事项；MCP Server 负责处理具体的业务逻辑，可以直接基于传统的业务系统改造；Nacos 负责 Agent 和 MCP 的动态注册和发现；数据持久层负责数据的持久化，包括知识库、会话、记忆、业务数据等。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32f07a081f16470a8cde91ea6c40f043~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770621461&amp;x-signature=9UIuRmMm9XisBgZ9cIEvtmymA6w%3D" alt="image.png" loading="lazy"/></p>
<p>接下来我们一点一点地来拆解这家店，特别是多智能体服务层。</p>
<ul>
<li><strong>Supervisor Agent</strong>：相当于门店经理，负责接待客户，判断客户意图（点单？咨询？投诉？），然后把活派给对应的子 Agent。</li>
<li><strong>Business Sub Agent</strong>：勤劳的店员，专门处理订单创建、查询、修改以及投诉等业务事项。</li>
<li><strong>Consult Sub Agent</strong>：贴心的客服，接入了 RAG 知识库，能够进行产品推荐，问啥答啥。</li>
</ul>
<h3 data-id="heading-4">能力解析</h3>
<p>在这一部分我们来介绍为了实现上述的效果，我们要用到哪些能力，以及要如何进行开发。当然这边我们只能展示一些关键部分的代码片段，完整实现可以移步 agentscope-java/agentscope-examples/boba-tea-shop <strong>[</strong> <strong>1]</strong> 。</p>
<h4 data-id="heading-5">ReActAgent：能思考会行动</h4>
<p>为了能处理店内大大小小的事项，我们就需要一个能思考会行动的 Agent，而一个符合 Reasoning and Acting 范式的 Agent 能很好地完成这个任务。为了构建这个 Agent 如果不借助框架的话我们需要至少完成以下事项：</p>
<ul>
<li>对接适配各个模型厂商的 API</li>
<li>构建 Reasoning 和 Acting 调用的循环</li>
<li>支持工具的注册和调用</li>
</ul>
<p>而在 AgentScope Java 中我们只需要进行一些配置便可以组装出一个 ReActAgent，由 AgentScope 完成上述的事项，同时我们原生支持了多家厂商的协议，包括 DashScope、Anthropic、Gemini、OpenAI。</p>
<pre><code class="hljs language-scss" lang="scss">DashScopeChatModel<span class="hljs-selector-class">.Builder</span> builder =
    DashScopeChatModel<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.apiKey</span>(dashscopeApiKey)
            <span class="hljs-selector-class">.modelName</span>(dashscopeModelName)
            <span class="hljs-selector-class">.formatter</span>(new DashScopeChatFormatter());
DashScopeChatModel model = builder<span class="hljs-selector-class">.build</span>();
ReActAgent agent = ReActAgent<span class="hljs-selector-class">.builder</span>()
    <span class="hljs-selector-class">.name</span>("supervisor_agent")
    <span class="hljs-selector-class">.sysPrompt</span>(sysPrompt)
    <span class="hljs-selector-class">.toolkit</span>(toolkit)      <span class="hljs-comment">// 挂载工具</span>
    <span class="hljs-selector-class">.model</span>(model)          <span class="hljs-comment">// 配置大模型</span>
    <span class="hljs-selector-class">.memory</span>(memory)        <span class="hljs-comment">// 短期记忆模块</span>
    <span class="hljs-selector-class">.longTermMemory</span>(longTermMemory)  <span class="hljs-comment">//长期记忆模块</span>
    <span class="hljs-selector-class">.build</span>();
</code></pre>
<h4 data-id="heading-6">集成 Nacos 的 A2A 架构：专业的事情让专业的 Agent 来做</h4>
<p>当我们对 AI 应用的需求从单一的对话交互转向复杂的现实世界问题解决，单体智能系统（Single-Agent Systems）的局限性日益凸显。</p>
<ul>
<li>上下文窗口大小和注意力稀释</li>
<li>幻觉难以自我觉察和纠正</li>
<li>专业化能力不足</li>
<li>……</li>
</ul>
<p>为了解决这些问题大家都在逐步探索多智能体架构，我们也借奶茶店这个场景为大家演示如何用 AgentScope Java 开发多智能体系统中 Agent AS Tool 的模式。为了实现这个效果，我们原本需要基于 A2A Java SDK 来构建对应的 Client 和 Server，同时还需要进行一些事件和通讯的适配与对接，繁碎的同时还没有动态注册发现的能力。</p>
<p>所以为了更加便捷地落地 A2A 架构，AgentScope 提供了 A2A extension 来完成 A2A Java SDK 适配和对接，并且集成了 Nacos 来实现动态的 Agent 注册和发现。于是现在在 AgentScope Java 中只需要少量代码就可以完成 A2A 架构的落地。</p>
<p>首先是子 Agent 的注册，只需要定义客制化的内容即可，主要是子 Agent 自身所需要的模型、工具等组件的配置，其他部分由框架搞定。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Bean</span>
public AgentRunner agentRunner(
        AgentPromptConfig promptConfig,
        ConsultTools consultTools,
        Knowledge knowledge,
        Model model) {
    Toolkit toolkit = new <span class="hljs-built_in">NacosToolkit</span>();
    toolkit<span class="hljs-selector-class">.registerTool</span>(consultTools);
    AutoContextConfig autoContextConfig =
            AutoContextConfig<span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.tokenRatio</span>(<span class="hljs-number">0.4</span>)<span class="hljs-selector-class">.lastKeep</span>(<span class="hljs-number">10</span>)<span class="hljs-selector-class">.build</span>();
    <span class="hljs-comment">// Use AutoContextMemory, support context auto compression</span>
    AutoContextMemory memory = new <span class="hljs-built_in">AutoContextMemory</span>(autoContextConfig, model);
    ReActAgent<span class="hljs-selector-class">.Builder</span> builder =
            ReActAgent<span class="hljs-selector-class">.builder</span>()
                    <span class="hljs-selector-class">.name</span>("consult_agent")
                    <span class="hljs-selector-class">.sysPrompt</span>(promptConfig.getConsultAgentInstruction())
                    <span class="hljs-selector-class">.memory</span>(memory)
                    <span class="hljs-selector-class">.hooks</span>(List.of(new MonitoringHook()))
                    <span class="hljs-selector-class">.model</span>(model)
                    <span class="hljs-selector-class">.toolkit</span>(toolkit)
                    <span class="hljs-selector-class">.knowledge</span>(knowledge)
                    <span class="hljs-selector-class">.ragMode</span>(RAGMode.AGENTIC);
    return new <span class="hljs-built_in">CustomAgentRunner</span>(builder);
}
</code></pre>
<p>而对于 Supervisor Agent 来说由于集成了 Nacos，只需要构建一个 AiService 然后做一些简单的配置就可以完成子 Agent 的发现。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> AiService <span class="hljs-title function_">nacosA2aService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException {
    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
    properties.put(PropertyKeyConst.SERVER_ADDR, serverAddress);
    properties.put(PropertyKeyConst.NAMESPACE, namespace);
    <span class="hljs-keyword">return</span> AiFactory.createAiService(properties);
}
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> A2aAgent <span class="hljs-title function_">consultAgent</span><span class="hljs-params">(AiService a2aService)</span> {
    <span class="hljs-keyword">return</span> A2aAgent.builder()
            .name(<span class="hljs-string">"consult_agent"</span>)
            .agentCardResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosAgentCardResolver</span>(a2aService))
            .build();
}
</code></pre>
<p>然后再把子 Agent 注册成一个工具，便可以像使用普通工具一样调用子 Agent。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Tool</span>(description =
    <span class="hljs-string">"Agent for handling consultation-related requests, can process all"</span>
        + <span class="hljs-string">" consultation-related requests, requires passing the complete context in"</span>
        + <span class="hljs-string">" the context parameter"</span>)
public String <span class="hljs-built_in">callConsultAgent</span>(
        <span class="hljs-variable">@ToolParam</span>(name = <span class="hljs-string">"context"</span>, description = <span class="hljs-string">"Complete context"</span>) String context,
        <span class="hljs-variable">@ToolParam</span>(name = <span class="hljs-string">"userId"</span>, description = <span class="hljs-string">"User's UserId"</span>) String userId) {
    <span class="hljs-selector-tag">Msg</span> <span class="hljs-selector-tag">msg</span> = <span class="hljs-selector-tag">Msg</span><span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.content</span>(TextBlock.<span class="hljs-built_in">builder</span>().<span class="hljs-built_in">text</span>(context).<span class="hljs-built_in">build</span>())<span class="hljs-selector-class">.build</span>();
    <span class="hljs-selector-tag">A2aAgent</span> <span class="hljs-selector-tag">consultAgent</span> = <span class="hljs-selector-tag">consultAgentProvider</span><span class="hljs-selector-class">.getObject</span>();
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">combineAgentResponse</span>(consultAgent.<span class="hljs-built_in">call</span>(msg).<span class="hljs-built_in">block</span>());
}
</code></pre>
<h4 data-id="heading-7">集成 Nacos 的 MCP 调用：动态注册&amp;发现</h4>
<p>MCP 几乎已经成为了远程工具调用的事实标准，很多传统的业务系统也会提供 MCP 的 Endpoint 来使 Agent 能够触达真实业务场景。传统的 MCP 工具的注册方式是一个固定的 Endpoint，在灵活性和高可用上都不能完全满足需求。所以 AgentScope 在传统注册方式的基础上也集成了 Nacos 来实现 MCP 的动态发现。只需要在Business Sub Agent 中通过集成的 NacosMcpServerManager 加上几行代码便可以轻松完成 MCP 工具的注册。</p>
<pre><code class="hljs language-ini" lang="ini">Toolkit <span class="hljs-attr">toolkit</span> = new NacosToolkit()<span class="hljs-comment">;</span>
NacosMcpServerManager <span class="hljs-attr">mcpServerManager</span> = new NacosMcpServerManager(aiService)<span class="hljs-comment">;</span>
NacosMcpClientWrapper <span class="hljs-attr">mcpClientWrapper</span> =
        NacosMcpClientBuilder.create("business-mcp-server", mcpServerManager).build()<span class="hljs-comment">;</span>
toolkit.registerMcpClient(mcpClientWrapper).block()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-8">会话持久化：重启不丢失</h4>
<p>会话通常包含了和模型的多轮对话，与记忆等有状态的内容绑定，如果只存储在内存中，在多实例部署或者重启场景下都会导致丢失或者错乱。所以 AgentScope 提供了基于 MySQL 的会话存储能力，能够随时接着上次聊天继续聊，同一会话无缝衔接，不同会话互相隔离。要在 AgentScope 中启用这个能力只需要部署一个 MySql 数据库，然后创建 MysqlSession 实例，在需要的地方 load 即可恢复到之前的状态，继续对话。</p>
<pre><code class="hljs language-ini" lang="ini">MysqlSession <span class="hljs-attr">mysqlSession</span> =
        new MysqlSession(dataSource, System.getenv("DB_NAME"), null, true)<span class="hljs-comment">;</span>
ReActAgent <span class="hljs-attr">agent</span> = createAgent(toolkit, memory)<span class="hljs-comment">;</span>
agent.loadIfExists(mysqlSession, sessionId)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-9">Mem0 长期记忆：记住每一位顾客</h4>
<p>Mem0 是一个长期记忆服务框架，帮助 Agent 持续优化长期记忆，可以使用商业化版本也可以自行部署。在奶茶店的场景下，他能够帮助 Agent 不只拥有当前会话的记忆，还能跨会话记住用户关于饮品、甜度、冰量等偏好。自行对接 Mem0 需要维护与它的通讯以及注入 Agent 的方式和时机。在 AgentScope 中，则只需要配置 Mem0 的BaseUrl 以及 apiKey 即可。</p>
<pre><code class="hljs language-scss" lang="scss">Mem0LongTermMemory longTermMemory =
    Mem0LongTermMemory<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.agentName</span>("BusinessAgent")
            <span class="hljs-selector-class">.userId</span>(userId)
            <span class="hljs-selector-class">.apiBaseUrl</span>("https://api.mem0.ai")
            <span class="hljs-selector-class">.apiKey</span>(System.getenv("MEM0_API_KEY"))
            <span class="hljs-selector-class">.build</span>();
</code></pre>
<h4 data-id="heading-10">AutoContextMemory：上下文压缩</h4>
<p>现在的大模型的上下文窗口大小已经从早期的 4k 扩展至 100k 甚至 1M，但其中要存放历史交互、外部知识库检索结果、复杂的任务指令、中间推理步骤以及工具调用的返回结果等等，在复杂的场景中依旧存在着上下文大小焦虑。同时随着上下文窗口的暴涨，模型在检索和利用中间位置关键信息的效果和性能会显著下降。所以我们往往会考虑对上下文进行压缩，但是如果是简单的压缩很有可能会导致有效信息的损失，为了压缩而损失了准确性是不可取的。所以 AgentScope 推出了AutoContextMemory，它是框架提供的智能上下文内存管理组件，通过自动压缩、卸载和摘要对话历史，在成本控制和信息保留之间找到最佳平衡，具体的原理可以参考我们之前发布的文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIzOTU0NTQ0MA%3D%3D%26mid%3D2247556750%26idx%3D1%26sn%3D65b82a8da8595494dd6e1adbe605e649%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247556750&amp;idx=1&amp;sn=65b82a8da8595494dd6e1adbe605e649&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">《AgentScope AutoContextMemory：告别Agent上下文焦虑》</a>。要使用该能力同样只需要配置一些简单参数即可。</p>
<pre><code class="hljs language-scss" lang="scss">AutoContextConfig autoContextConfig =
        AutoContextConfig<span class="hljs-selector-class">.builder</span>()<span class="hljs-selector-class">.tokenRatio</span>(<span class="hljs-number">0.4</span>)<span class="hljs-selector-class">.lastKeep</span>(<span class="hljs-number">10</span>)<span class="hljs-selector-class">.build</span>();
<span class="hljs-comment">// Use AutoContextMemory, support context auto compression</span>
AutoContextMemory memory = new <span class="hljs-built_in">AutoContextMemory</span>(autoContextConfig, model);
</code></pre>
<h3 data-id="heading-11">快速开始</h3>
<p>为了让大家能够快速体验，同时方便大家拿奶茶店练手，我们提供了多种便捷的部署方式：</p>
<h4 data-id="heading-12">本地开发推荐</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 配置环境变量</span>
cp <span class="hljs-keyword">local</span>-env.example <span class="hljs-keyword">local</span>-env.sh
vim <span class="hljs-keyword">local</span>-env.sh
<span class="hljs-comment"># 一键启动</span>
source <span class="hljs-keyword">local</span>-env.sh &amp;&amp; ./<span class="hljs-keyword">local</span>-deploy.sh start
</code></pre>
<h4 data-id="heading-13">K8s 生产推荐</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 配置变量</span>
vim values.yaml
<span class="hljs-meta"># Helm 一键部署</span>
helm install agentscope helm/ --<span class="hljs-keyword">namespace</span> <span class="hljs-title">agentscope</span>
</code></pre>
<h4 data-id="heading-14">Docker 极简</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 配置环境变量</span>
<span class="hljs-built_in">cp</span> docker-env.example .<span class="hljs-built_in">env</span>
<span class="hljs-comment"># 容器一把梭</span>
docker-compose up -d
</code></pre>
<h4 data-id="heading-15">云产品（AgentRun）部署</h4>
<p>如果想使用云产品部署，可以使用 AgentRun，直接拉取镜像部署，所需要配置的环境变量参考 README.md 文档。</p>
<h2 data-id="heading-16">最后的最后</h2>
<p>这个奶茶店的例子只是 AgentScope Java 能力的冰山一角，用来带大家快速入门。AgentScope Java 框架还支持更多玩法，所有的核心能力都有对应的 Example，欢迎大家体验：</p>
<ul>
<li>实时人类介入</li>
<li>PlanNotebook，先规划后执行</li>
<li>结构化输出</li>
<li>AI 狼人杀</li>
<li>……</li>
</ul>
<p>同时社区也在快速演进中，欢迎大家参与讨论和贡献 🚀</p>
<p><strong>Star 一下不迷路！</strong> ⭐</p>
<p>项目地址：AgentScope Java <strong>[</strong> <strong>2]</strong></p>
<p>Demo 地址：<code>agentscope-examples/boba-tea-shop</code></p>
<p>"Talk is cheap, show me the agents."</p>
<p>快来 Clone 下来跑一把，体验一下 AI 给你点奶茶的快感吧！</p>
<p><strong>相关链接：</strong></p>
<p>[1] agentscope-java/agentscope-examples/boba-tea-shop</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fagentscope-ai%2Fagentscope-java%2Ftree%2Fmain%2Fagentscope-examples%2Fboba-tea-shop" target="_blank" title="https://github.com/agentscope-ai/agentscope-java/tree/main/agentscope-examples/boba-tea-shop" ref="nofollow noopener noreferrer">github.com/agentscope-…</a></p>
<p>[2] AgentScope Java</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fagentscope-ai%2Fagentscope-java" target="_blank" title="https://github.com/agentscope-ai/agentscope-java" ref="nofollow noopener noreferrer">github.com/agentscope-…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Next.js第二十五章(CSS方案)]]></title>    <link>https://juejin.cn/post/7601715462921535498</link>    <guid>https://juejin.cn/post/7601715462921535498</guid>    <pubDate>2026-02-01T21:58:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601715462921535498" data-draft-id="7601441797118443571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Next.js第二十五章(CSS方案)"/> <meta itemprop="keywords" content="前端,Next.js"/> <meta itemprop="datePublished" content="2026-02-01T21:58:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小满zs"/> <meta itemprop="url" content="https://juejin.cn/user/2463384809252397"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Next.js第二十五章(CSS方案)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2463384809252397/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小满zs
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-01T21:58:39.000Z" title="Sun Feb 01 2026 21:58:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Next.js CSS方案</h2>
<p>在Next.js可以使用多种Css方案，包括：</p>
<ul>
<li>Tailwind CSS(个人推荐)</li>
<li>CSS Modules(创建css模块化，类似于Vue的单文件组件)</li>
<li>Next.js内置Sass(css预处理器)</li>
<li>全局Css(全局的css，可以全局使用)</li>
<li>Style(内联样式)</li>
<li>css-in-js(类似于React的styled-components，不推荐)</li>
</ul>
<h4 data-id="heading-1">Tailwind CSS</h4>
<p>Tailwind CSS(css原子化)，他是一个css框架，可以让你快速构建网页，他提供了大量的css类，你只需要使用这些类，就可以快速构建网页。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2F" target="_blank" title="https://tailwindcss.com/" ref="nofollow noopener noreferrer">Tailwind CSS</a></p>
<h5 data-id="heading-2">安装教程</h5>
<pre><code class="hljs language-bash" lang="bash">npx create-next-app@latest my-project
</code></pre>
<p>当我们去创建<code>Next.js</code>项目的时候，选择<code>customize settings(自定义选项)</code> 那么就会出现<code>Tailwind CSS</code>的选项，我们选择<code>Yes</code>即可。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eccfac37d4584e6ca81bef570e16f0d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5ruhenM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770588077&amp;x-signature=bSPfhdHEHQDVvUeo%2FJa2ZKlvy4k%3D" alt="image.png" loading="lazy"/></p>
<p>那么如果我在当时忘记选择<code>Tailwind CSS</code>，我该怎么安装呢？</p>
<h5 data-id="heading-3">在 Next.js 中安装并使用 Tailwind CSS</h5>
<p>下面是如何在 Next.js 项目中集成 Tailwind CSS 的详细流程：</p>
<h6 data-id="heading-4">1. 创建你的 Next.js 项目</h6>
<p>如果还没有项目，可以使用 Create Next App 快速初始化：</p>
<pre><code class="hljs language-bash" lang="bash">npx create-next-app@latest my-project --typescript --eslint --app
<span class="hljs-built_in">cd</span> my-project
</code></pre>
<h6 data-id="heading-5">2. 安装 Tailwind CSS 及相关依赖</h6>
<p>通过 npm 安装 <code>tailwindcss</code>、<code>@tailwindcss/postcss</code> 以及 <code>postcss</code> 依赖：</p>
<pre><code class="hljs language-bash" lang="bash">npm install tailwindcss @tailwindcss/postcss postcss
</code></pre>
<h6 data-id="heading-6">3. 配置 PostCSS 插件</h6>
<p>在项目根目录下创建 <code>postcss.config.mjs</code> 文件，并添加如下内容：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">plugins</span>: {
    <span class="hljs-string">"@tailwindcss/postcss"</span>: {},
  },
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config;
</code></pre>
<h6 data-id="heading-7">4. 导入 Tailwind CSS</h6>
<p>在 <code>./app/globals.css</code> 文件中添加 Tailwind CSS 的导入：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">"tailwindcss"</span>;
</code></pre>
<h6 data-id="heading-8">5. 启动开发服务</h6>
<p>运行开发服务：</p>
<pre><code class="hljs language-bash" lang="bash">npm run dev
</code></pre>
<h6 data-id="heading-9">6. 在项目中开始使用 Tailwind</h6>
<p>现在可以直接在组件或页面中使用 Tailwind CSS 的工具类来进行样式编写。例如：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-3xl font-bold underline"</span>&gt;</span>
      Hello world!
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  )
}
</code></pre>
<p>这样即可在项目中使用 Tailwind CSS 原子类来快速开发样式。</p>
<h5 data-id="heading-10">FAQ</h5>
<p>这么多类名我记不住怎么办？</p>
<p>答：你不需要特意去记忆，tailwindCss的类名都是简称，例如<code>backdround-color:red</code> 你可以简写为<code>bg-red-500</code>。另外就是官网也提供文档可以查询，再其次就是还提供了<code>vscode</code>插件，可以自动补全类名。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e4548071e9747ff9e76261c8ae40d7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5ruhenM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770588077&amp;x-signature=j4D5qszb2BQMyV9Ox87vsxjWFT8%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-11">CSS Modules</h4>
<p>CSS Modules 是一种 CSS 模块化方案，可以让你在组件中使用CSS模块化，类似于Vue的单文件组件(scoped)。</p>
<p>Next.js已经内置了对CSS Modules的支持，你只需要在创建文件的时候新增<code>.module.css</code>后缀即可。例如<code>index.module.css</code>。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/** index.module.css */</span>
<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">background-color</span>: red;
}
</code></pre>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">/** index.tsx */</span>
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.css'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p>你会发现他编译出来的类名，就会生成一个唯一的hash值，这样就可以避免类名冲突。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"index-module__ifV0vq__test"</span>&gt;</span>小满zs Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">Next.js内置Sass</h4>
<p>Next.js已经内置了对Sass的支持，但是依赖还需要手动安装，不过配置项它都内置了，只需要安装一下即可。</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev sass
</code></pre>
<p>另外Next.js还支持配置全局sass变量，只需要在<code>next.config.js</code>中配置即可。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">reactCompiler</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">reactStrictMode</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">cacheComponents</span>:<span class="hljs-literal">false</span>,
  <span class="hljs-attr">sassOptions</span>:{
    <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`$color: blue;`</span>, <span class="hljs-comment">// 全局变量</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<h4 data-id="heading-13">全局Css</h4>
<p>全局CSS，就是把所有样式应用到全局路由/组件，那应该怎么搞呢?</p>
<p>在根目录下创建<code>globals.css</code>文件，然后添加全局样式。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/** app/globals.css */</span>
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background-color</span>: red;
}
<span class="hljs-selector-class">.flex</span>{
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
}
</code></pre>
<p>在<code>layout.tsx</code>文件中引入<code>globals.css</code>文件。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//app/layout.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./globals.css'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
  )
}
</code></pre>
<h4 data-id="heading-14">Style</h4>
<p>Style，就是内联样式，就是直接在组件中使用style属性来定义样式。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">backgroundColor:</span> '<span class="hljs-attr">red</span>' }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<h4 data-id="heading-15">css-in-js</h4>
<p>css-in-js，就是把css + js + html混合在一起，拨入styled-components，不推荐很多人接受不了这种写法。</p>
<h5 data-id="heading-16">1.安装启用styled-components</h5>
<pre><code class="hljs language-bash" lang="bash">npm install styled-components
</code></pre>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">NextConfig</span> = {
  <span class="hljs-attr">compiler</span>:{
    <span class="hljs-attr">styledComponents</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// 启用styled-components</span>
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<h5 data-id="heading-17">2.创建style-component注册表</h5>
<p>使用styled-componentsAPI 创建一个全局注册表组件，用于收集渲染过程中生成的所有 CSS 样式规则，以及一个返回这些规则的函数。最后，使用该useServerInsertedHTML钩子将注册表中收集的样式注入到<code>&lt;head&gt;</code>根布局的 HTML 标签中。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//lib/registry.ts</span>
<span class="hljs-string">'use client'</span>
 
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { useServerInsertedHTML } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerStyleSheet</span>, <span class="hljs-title class_">StyleSheetManager</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">StyledComponentsRegistry</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-comment">// Only create stylesheet once with lazy initial state</span>
  <span class="hljs-comment">// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state</span>
  <span class="hljs-keyword">const</span> [styledComponentsStyleSheet] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerStyleSheet</span>())
 
  <span class="hljs-title function_">useServerInsertedHTML</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> styles = styledComponentsStyleSheet.<span class="hljs-title function_">getStyleElement</span>()
    styledComponentsStyleSheet.<span class="hljs-property">instance</span>.<span class="hljs-title function_">clearTag</span>()
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{styles}<span class="hljs-tag">&lt;/&gt;</span></span>
  })
 
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span></span>
 
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StyleSheetManager</span> <span class="hljs-attr">sheet</span>=<span class="hljs-string">{styledComponentsStyleSheet.instance}</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">StyleSheetManager</span>&gt;</span></span>
  )
}
</code></pre>
<h5 data-id="heading-18">3.注册style-component注册表</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">//app/layout.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">StyledComponentsRegistry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/registry'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">StyledComponentsRegistry</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">StyledComponentsRegistry</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
  )
}
</code></pre>
<h5 data-id="heading-19">4.使用styled-components</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-string">'use client'</span>;
<span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledButton</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`
  background-color: red;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
`</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StyledButton</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">StyledButton</span>&gt;</span></span>
  )
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent Skills：构建可复用 AI 编程知识库的最佳实践]]></title>    <link>https://juejin.cn/post/7602100217656229930</link>    <guid>https://juejin.cn/post/7602100217656229930</guid>    <pubDate>2026-02-02T09:22:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602100217656229930" data-draft-id="7602069205467709486" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent Skills：构建可复用 AI 编程知识库的最佳实践"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-02T09:22:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent Skills：构建可复用 AI 编程知识库的最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T09:22:11.000Z" title="Mon Feb 02 2026 09:22:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    43
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 AI 辅助编程的时代，<code>AGENTS.md</code> 已成为开发者向 AI 工具传递项目上下文的重要文件。
然而，随着项目增多，维护多个项目的 <code>AGENTS.md</code> 文件变得愈发困难——重复的知识、分散的更新、难以同步。新的Agent Skills开放标准针对这些问题有很好的解决方案</p>
<h2 data-id="heading-0">AGENTS.md 的痛点与 Agent Skills 的诞生</h2>
<h3 data-id="heading-1">AGENTS.md 的困境</h3>
<p>传统上，开发者会在每个项目中创建 <code>AGENTS.md</code> 文件，用于记录：</p>
<ul>
<li>项目特定的编码规范</li>
<li>首选的 Swift/SwiftUI 方法</li>
<li>重构策略</li>
<li>Swift Concurrency 使用模式</li>
</ul>
<p>在实践中存在三个核心问题：</p>
<p>第一，知识同步成本高。当在 A 项目中发现 AI 生成了错误代码并更新 <code>AGENTS.md</code> 后，相同的问题修复需要手动同步到 B、C、D 项目，维护成本线性增长。</p>
<p>第二，通用知识与项目知识混杂。<code>AGENTS.md</code> 本应聚焦项目特有逻辑，却不得不包含大量通用编程最佳实践（如 Swift Concurrency 使用规范），导致文件臃肿。</p>
<p>第三，缺乏标准化分享机制。即使想开源自己的 <code>AGENTS.md</code> 帮助他人，其格式也不适合直接分享——它天然为项目特定而设计，而非领域通用。</p>
<h3 data-id="heading-2">Agent Skills 的核心理念</h3>
<p>Agent Skills 是一个开放格式（open format），旨在将 AI Agent 的能力模块化、可复用化。官方定义为：</p>
<blockquote>
<p>Agent Skills 是一种为 AI Agent 提供新能力和专业知识的开放格式。单个 Skill 可包含指令、脚本和资源文件夹，使 Agent 能更准确地执行特定任务。</p>
</blockquote>
<p>其核心优势在于领域专业知识的封装与复用。你可以将 Swift Concurrency、SwiftUI 架构、代码重构等领域的最佳实践打包成独立 Skill，在所有项目中共享。</p>
<p>一句话总结：<code>AGENTS.md</code> 是项目级知识库，而 Agent Skills 是跨项目、领域级的知识库。</p>
<h2 data-id="heading-3">Agent Skills 核心概念详解</h2>
<h3 data-id="heading-4">什么是 Agent Skills？</h3>
<p>Agent Skills 由三个核心要素构成：</p>
<ol>
<li>指令系统（Instructions）：指导 Agent 何时、如何使用该 Skill</li>
<li>参考资源（References）：详细的领域知识文档</li>
<li>可执行脚本（Scripts）：自动化工具或工作流</li>
</ol>
<p>这种结构使 Skill 具备：</p>
<ul>
<li>领域专业性：深度覆盖特定技术栈</li>
<li>可复用性：一次创建，多项目使用</li>
<li>工具兼容性：已被 Codex、Gemini、Claude、Cursor 等主流工具支持</li>
</ul>
<h3 data-id="heading-5">技术生态现状</h3>
<p>Agent Skills 已被广泛采纳：</p>
<ul>
<li>Codex CLI：通过 <code>/skills</code> 命令管理</li>
<li>Cursor AI：集成 openskills CLI</li>
<li>Gemini/Claude：原生支持 Skill 格式</li>
</ul>
<p>这意味着开发者可以立即投入使用，无需等待生态成熟。</p>
<h2 data-id="heading-6">实战案例：Swift Concurrency Skill 深度剖析</h2>
<h3 data-id="heading-7">Skill 结构设计</h3>
<pre><code class="hljs language-bash" lang="bash">swift-concurrency/
├── SKILL.md                    <span class="hljs-comment"># 主技能文件：决策树入口</span>
└── references/
    ├── async-await-basics.md   <span class="hljs-comment"># async/await 基础语法</span>
    ├── tasks.md                <span class="hljs-comment"># Task 生命周期、取消机制、优先级</span>
    ├── sendable.md             <span class="hljs-comment"># 隔离域与 Sendable 协议</span>
    ├── actors.md               <span class="hljs-comment"># Actor 隔离、全局 Actor、可重入性</span>
    ├── async-sequences.md      <span class="hljs-comment"># AsyncSequence 与 AsyncStream 模式</span>
    ├── threading.md            <span class="hljs-comment"># 线程与 Task 对比、挂起点</span>
    ├── memory-management.md    <span class="hljs-comment"># 循环引用、weak self、隔离析构</span>
    ├── core-data.md            <span class="hljs-comment"># Core Data 集成模式</span>
    ├── performance.md          <span class="hljs-comment"># 使用 Xcode Instruments 优化</span>
    ├── testing.md              <span class="hljs-comment"># 并发代码测试策略</span>
    ├── migration.md            <span class="hljs-comment"># Swift 6 迁移分步指南</span>
    ├── glossary.md             <span class="hljs-comment"># 术语与概念词汇表</span>
    └── linting.md              <span class="hljs-comment"># 严格并发 Lint 规则</span>
</code></pre>
<p>结构解析：</p>
<ul>
<li><code>SKILL.md</code> 是智能路由层，类似 API Gateway，根据问题类型分发到对应的参考文档</li>
<li><code>references/</code> 是知识库层，每篇文档聚焦单一主题，深度讲解</li>
<li>这种分层设计使 Agent 能精准定位所需知识，避免上下文过载</li>
</ul>
<h3 data-id="heading-8">代码示例：决策树实现</h3>
<p><code>SKILL.md</code> 中的决策树是 Skill 的核心智能。以下是一个简化的实现示例：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Swift Concurrency Skill - 主决策树</span>

<span class="hljs-section">## 何时使用该 Skill</span>
当开发者提及以下关键词时激活：
<span class="hljs-bullet">-</span> "Swift Concurrency", "async/await", "actors", "tasks"
<span class="hljs-bullet">-</span> "迁移到 Swift 6"
<span class="hljs-bullet">-</span> "数据竞争" 或 "线程安全"
<span class="hljs-bullet">-</span> "@MainActor", "Sendable"
<span class="hljs-bullet">-</span> "并发代码架构" 或 "性能优化"

<span class="hljs-section">## 决策路径</span>

<span class="hljs-section">### 1. 刚开始编写异步代码？</span>
<span class="hljs-code">```bash
# Agent 执行动作：读取基础文档
openskills read swift-concurrency/references/async-await-basics.md
</span></code></pre>
<ul>
<li>需要并行操作？→ 读取 <code>tasks.md</code> (async let, TaskGroup)</li>
</ul>
<ol start="2">
<li>需要保护共享可变状态？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 评估项目类型</span>
<span class="hljs-keyword">if</span> 项目使用类（class）管理状态:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/actors.md
<span class="hljs-keyword">else</span>:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/sendable.md
</code></pre>
<ol start="3">
<li>管理异步操作生命周期？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 区分结构化并发与流式数据</span>
<span class="hljs-keyword">if</span> 需求是结构化任务管理:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/tasks.md
<span class="hljs-keyword">elif</span> 需求是流式数据处理:
    openskills <span class="hljs-built_in">read</span> swift-concurrency/references/async-sequences.md
</code></pre>
<ol start="4">
<li>性能分析与调试？</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 引导使用 Instruments</span>
openskills <span class="hljs-built_in">read</span> swift-concurrency/references/performance.md
</code></pre>
<p>项目配置检查清单
在应用建议前，Agent 必须检查：</p>
<ul>
<li>Swift 版本（6.0+？）</li>
<li>是否启用 <code>StrictConcurrency=complete</code></li>
<li>是否设置 <code>nonisolatednonsendingbydefault</code></li>
<li>默认 Actor 隔离策略</li>
</ul>
<pre><code class="hljs language-markdown" lang="markdown">
<span class="hljs-strong">**注释说明**</span>：
<span class="hljs-bullet">-</span> 决策树本质是<span class="hljs-strong">**条件路由表**</span>，将自然语言问题映射到具体文档
<span class="hljs-bullet">-</span> <span class="hljs-code">`openskills read`</span> 是 Agent 与 Skill 的<span class="hljs-strong">**标准交互接口**</span>
<span class="hljs-bullet">-</span> 项目配置检查确保建议<span class="hljs-strong">**因地制宜**</span>，避免生搬硬套

<span class="hljs-section">## Agent 如何使用 Skills：技术实现原理</span>

<span class="hljs-section">### 安装与同步机制</span>

Agent Skills 通过 <span class="hljs-code">`openskills`</span> CLI 工具管理，其工作流程分为三步：

<span class="hljs-strong">**步骤 1：安装 Skill**</span>
<span class="hljs-code">```bash
# 从 GitHub 安装公开 Skill
openskills install avdlee/Swift-Concurrency-Agent-Skill
</span></code></pre>
<p>技术原理：该命令会：</p>
<ol>
<li>克隆 GitHub 仓库到本地 Skill 存储目录（<code>~/.skills</code> 或项目 <code>.skills</code>）</li>
<li>解析 <code>SKILL.md</code> 提取元数据（名称、描述、触发关键词）</li>
<li>注册 Skill 到全局索引</li>
</ol>
<p>步骤 2：同步到 AGENTS.md</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 将已安装 Skills 注入项目 AGENTS.md</span>
openskills <span class="hljs-built_in">sync</span>
</code></pre>
<p>该命令会自动化修改 <code>AGENTS.md</code>，插入 Skill 引用区块。生成的内容如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">skills_system</span> <span class="hljs-attr">priority</span>=<span class="hljs-string">"1"</span>&gt;</span>

## 可用 Skills

<span class="hljs-comment">&lt;!-- SKILLS_TABLE_START --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">usage</span>&gt;</span>
当用户请求任务时，检查以下可用 Skills 是否能更有效完成工作。Skills 提供专业能力和领域知识。

使用方法：
- 调用：Bash("openskills read <span class="hljs-tag">&lt;<span class="hljs-name">skill-name</span>&gt;</span>")
- Skill 内容将加载，包含完成任务的具体指令
- 输出中提供基础目录，用于解析捆绑资源（references/, scripts/, assets/）

使用注意：
- 仅使用 <span class="hljs-tag">&lt;<span class="hljs-name">available_skills</span>&gt;</span> 下列出的 Skills
- 不要调用已加载到上下文的 Skill
- 每次 Skill 调用是无状态的
<span class="hljs-tag">&lt;/<span class="hljs-name">usage</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">available_skills</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">skill</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>swift-concurrency<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>'Swift Concurrency 最佳实践、模式和实现的专家指导。使用场景：(1) 提及 Swift Concurrency、async/await、actors 或 tasks，(2) "使用 Swift Concurrency" 或 "现代并发模式"，(3) 迁移到 Swift 6，(4) 数据竞争或线程安全问题，(5) 将闭包重构为 async/await，(6) @MainActor、Sendable 或 Actor 隔离，(7) 并发代码架构或性能优化，(8) 并发相关 Lint 警告（SwiftLint 等）'<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>project<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">skill</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">available_skills</span>&gt;</span>
<span class="hljs-comment">&lt;!-- SKILLS_TABLE_END --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">skills_system</span>&gt;</span>
</code></pre>
<p>技术解析：</p>
<ul>
<li>使用 XML 格式 是为了兼容不同 Agent 的解析器</li>
<li><code>priority="1"</code> 确保 Skill 系统被优先评估</li>
<li><code>&lt;description&gt;</code> 是触发器（Trigger），Agent 通过自然语言匹配决定是否调用</li>
<li><code>Bash("openskills read ...")</code> 是标准调用接口，解耦 Agent 与 Skill 实现</li>
</ul>
<h3 data-id="heading-9">Agent 的决策流程</h3>
<p>当用户提问时，Agent 的内部工作流程如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 伪代码：Agent 决策逻辑</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_user_prompt</span>(<span class="hljs-params">prompt: <span class="hljs-built_in">str</span>, skills: <span class="hljs-type">List</span>[Skill]</span>):
    <span class="hljs-comment"># 1. 解析用户意图（Embedding + 关键词匹配）</span>
    intent = extract_intent(prompt)
    
    <span class="hljs-comment"># 2. 遍历可用 Skills，计算相关性得分</span>
    <span class="hljs-keyword">for</span> skill <span class="hljs-keyword">in</span> skills:
        <span class="hljs-comment"># 匹配 Skill 描述中的关键词</span>
        <span class="hljs-keyword">if</span> skill.description.contains_any(intent.keywords):
            score = calculate_relevance(skill.description, intent)
            <span class="hljs-keyword">if</span> score &gt; THRESHOLD:
                <span class="hljs-comment"># 3. 动态加载 Skill 上下文</span>
                skill_content = execute_bash(<span class="hljs-string">f"openskills read <span class="hljs-subst">{skill.name}</span>"</span>)
                
                <span class="hljs-comment"># 4. 决策树路由</span>
                decision_path = parse_decision_tree(skill_content.SKILL.md)
                target_doc = decision_path.evaluate(intent)
                
                <span class="hljs-comment"># 5. 读取具体知识文档</span>
                reference_doc = execute_bash(
                    <span class="hljs-string">f"openskills read <span class="hljs-subst">{skill.name}</span>/references/<span class="hljs-subst">{target_doc}</span>"</span>
                )
                
                <span class="hljs-comment"># 6. 生成带引用的回答</span>
                <span class="hljs-keyword">return</span> generate_answer(
                    prompt, 
                    context=reference_doc,
                    citations=[target_doc]  <span class="hljs-comment"># 引用来源</span>
                )
    
    <span class="hljs-comment"># 无匹配 Skill，使用通用知识</span>
    <span class="hljs-keyword">return</span> generate_answer(prompt, context=general_knowledge)
</code></pre>
<p>关键设计亮点：</p>
<ul>
<li>延迟加载（Lazy Loading）：Skill 内容在需要时才加载，避免上下文窗口浪费</li>
<li>无状态调用：每次调用都是独立的，Skill 内部无复杂状态管理，降低耦合</li>
<li>可溯源性：Agent 必须明确引用参考文档，实现知识审计</li>
</ul>
<h2 data-id="heading-10">领域专业知识的重要性：Skill 质量的基石</h2>
<h3 data-id="heading-11">为什么需要领域专家？</h3>
<p>Agent Skills 的质量取决于创建者的领域深度。其 Swift Concurrency Skill 的优势源于：</p>
<ul>
<li>对 Swift 6 新特性的深度理解（如 Default Actor Isolation）</li>
<li>实际项目中的踩坑经验（如不必要的 <code>@MainActor</code>）</li>
</ul>
<h3 data-id="heading-12">反模式：浅层知识与过度设计</h3>
<p>一些开源 Skill 的问题：</p>
<p>问题 1：缺乏深度</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 反例：浅层 Skill</span>
<span class="hljs-section">## 使用 async/await</span>
<span class="hljs-bullet">-</span> 用 async 标记异步函数
<span class="hljs-bullet">-</span> 用 await 调用异步函数
</code></pre>
<p>这种 Skill 只是语法复述，无法解决实际问题（如线程安全、性能优化）。</p>
<p>问题 2：过度武断</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 反例：强制架构风格</span>
<span class="hljs-comment">// Skill 建议：所有 ViewModel 必须遵循 MVVM</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span>: <span class="hljs-title class_">ObservableObject</span> { <span class="hljs-comment">/* ... */</span> } 
<span class="hljs-comment">// 但如果用户项目使用 TCA 或 Elm，此建议就是错误的</span>
</code></pre>
<p>最佳实践原则：</p>
<ul>
<li>Skill 应聚焦 "最佳实践" 而非 "个人偏好"</li>
<li>应解决 "How to do it right" 而非 "How I do it"</li>
<li>提供 "配置感知" 能力，根据项目实际设置调整建议</li>
</ul>
<h3 data-id="heading-13">配置感知的实现</h3>
<p>Swift Concurrency Skill 会先评估项目配置：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// Skill 决策逻辑示例：评估项目 Swift 版本</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">evaluateProjectSettings</span>() -&gt; <span class="hljs-type">ConcurrencyStrategy</span> {
    <span class="hljs-keyword">let</span> swiftVersion <span class="hljs-operator">=</span> readSwiftVersion() <span class="hljs-comment">// 读取 // swift-tools-version: 6.0</span>
    <span class="hljs-keyword">let</span> concurrencyChecks <span class="hljs-operator">=</span> buildSettings[<span class="hljs-string">"SWIFT_STRICT_CONCURRENCY"</span>] <span class="hljs-comment">// 严格并发设置</span>
    <span class="hljs-keyword">let</span> actorIsolation <span class="hljs-operator">=</span> buildSettings[<span class="hljs-string">"SWIFT_DEFAULT_ACTOR_ISOLATION"</span>] <span class="hljs-comment">// 默认 Actor 隔离</span>
    
    <span class="hljs-keyword">if</span> swiftVersion <span class="hljs-operator">&gt;=</span> .v6_0 <span class="hljs-operator">&amp;&amp;</span> concurrencyChecks <span class="hljs-operator">==</span> <span class="hljs-string">"complete"</span> {
        <span class="hljs-comment">// Swift 6 + 完整严格并发检查</span>
        <span class="hljs-keyword">return</span> .swift6Strict
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> actorIsolation <span class="hljs-operator">==</span> <span class="hljs-string">"mainActor"</span> {
        <span class="hljs-comment">// 默认主 Actor 隔离，可省略多余 @MainActor</span>
        <span class="hljs-keyword">return</span> .mainActorDefault
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> .legacy
    }
}

<span class="hljs-comment">// 根据评估结果，Skill 会生成差异化建议</span>
<span class="hljs-keyword">switch</span> evaluateProjectSettings() {
<span class="hljs-keyword">case</span> .swift6Strict:
    <span class="hljs-comment">// 建议：利用编译时检查，减少运行时保护</span>
    suggest(<span class="hljs-string">"优先使用 Sendable 和 Actor 隔离，减少 DispatchQueue"</span>)
<span class="hljs-keyword">case</span> .mainActorDefault:
    <span class="hljs-comment">// 建议：移除冗余注解</span>
    suggest(<span class="hljs-string">"全局已默认 @MainActor，可移除显式标记"</span>)
<span class="hljs-keyword">case</span> .legacy:
    <span class="hljs-comment">// 建议：保守的向后兼容方案</span>
    suggest(<span class="hljs-string">"逐步迁移，先启用 StrictConcurrency=minimal"</span>)
}
</code></pre>
<p>这种上下文感知能力使 Skill 建议精准而非教条。</p>
<h2 data-id="heading-14">如何使用 Agent Skills：多工具实践</h2>
<h3 data-id="heading-15">使用 openskills CLI（Cursor AI）</h3>
<p>安装 Skill：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 Swift Concurrency Skill</span>
openskills install avdlee/Swift-Concurrency-Agent-Skill

<span class="hljs-comment"># 查看已安装 Skills</span>
openskills list
</code></pre>
<p>同步到项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 自动更新 AGENTS.md</span>
openskills <span class="hljs-built_in">sync</span>

<span class="hljs-comment"># 可指定输出文件</span>
openskills <span class="hljs-built_in">sync</span> --output .cursor/agents.md
</code></pre>
<p>在对话中使用：</p>
<pre><code class="hljs language-markdown" lang="markdown">用户：帮我分析当前项目的 Swift Concurrency 使用是否合理  

Agent 内部：
<span class="hljs-bullet">1.</span> 匹配到关键词 "Swift Concurrency" → 触发 swift-concurrency Skill
<span class="hljs-bullet">2.</span> 执行 <span class="hljs-code">`openskills read swift-concurrency`</span>
<span class="hljs-bullet">3.</span> 读取 SKILL.md，决策树指向 "analyze-project"
<span class="hljs-bullet">4.</span> 执行分析脚本（如有）
<span class="hljs-bullet">5.</span> 生成带引用的报告
</code></pre>
<h3 data-id="heading-16">实用 Prompt 示例</h3>
<p>以下是可直接使用的 Skill 调用示例：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 示例 1：检查冗余 @MainActor</span>
<span class="hljs-string">"使用 swift-concurrency Skill，找出项目中不必要的 @MainActor 使用"</span>

<span class="hljs-comment"># 示例 2：后台任务优化</span>
<span class="hljs-string">"分析当前项目，识别可移动到后台线程的同步代码，使用 Swift Concurrency 重构"</span>

<span class="hljs-comment"># 示例 3：迁移辅助</span>
<span class="hljs-string">"帮我将文件 NetworkManager.swift 从 GCD 迁移到 Swift Concurrency，使用 Skill 指导"</span>

<span class="hljs-comment"># 示例 4：性能分析</span>
<span class="hljs-string">"使用 Skill 的性能模块，分析 async let 和 TaskGroup 的使用效率"</span>

<span class="hljs-comment"># 示例 5：Lint 规则</span>
<span class="hljs-string">"根据 Skill 的 linting.md，检查项目是否符合严格并发 Lint 规则"</span>
</code></pre>
<h2 data-id="heading-17">深入原理性分析</h2>
<h3 data-id="heading-18">Agent Skills 的架构设计哲学</h3>
<p>Agent Skills 的设计遵循三大原则：</p>
<p>原则一：关注点分离（Separation of Concerns）</p>
<ul>
<li><code>AGENTS.md</code> = 项目特定上下文（如业务逻辑、架构决策）</li>
<li><code>Skill</code> = 领域通用知识（如语言特性、框架最佳实践）</li>
</ul>
<p>原则二：知识的层次化封装</p>
<pre><code class="hljs language-markdown" lang="markdown">用户提问
<span class="hljs-code">    ↓
意图识别（Agent 通用能力）
    ↓
Skill 路由（SKILL.md 决策树）
    ↓
知识检索（References 文档）
    ↓
答案生成（带引用）
</span></code></pre>
<p>这种分层使知识从扁平文本升级为结构化知识图谱。</p>
<p>原则三：工具无关性（Tool Agnostic）</p>
<p>通过标准化 <code>openskills read</code> 接口，Skill 创建者无需关心 Agent 实现细节。这是类 Unix 哲学：做一件事，做好，并能与其他工具组合。</p>
<h3 data-id="heading-19">与 RAG（检索增强生成）的对比</h3>
<p>Agent Skills 本质上是一种手动优化的 RAG 系统：</p>








































<table><thead><tr><th align="left">特性</th><th align="left">传统 RAG</th><th align="left">Agent Skills</th></tr></thead><tbody><tr><td align="left">知识组织</td><td align="left">自动分块，可能不连贯</td><td align="left">人工结构化，逻辑清晰</td></tr><tr><td align="left">检索方式</td><td align="left">向量相似度搜索</td><td align="left">规则/决策树路由</td></tr><tr><td align="left">上下文控制</td><td align="left">自动注入，可能冗余</td><td align="left">按需加载，精确控制</td></tr><tr><td align="left">可解释性</td><td align="left">黑盒，难以追溯</td><td align="left">显式引用，可审计</td></tr><tr><td align="left">维护成本</td><td align="left">低（自动化）</td><td align="left">中等（需人工维护）</td></tr><tr><td align="left">回答质量</td><td align="left">一般，可能 hallucinate</td><td align="left">高，专家级深度</td></tr></tbody></table>
<p>适用场景：</p>
<ul>
<li>RAG：通用知识、快速原型</li>
<li>Agent Skills：专业领域、生产环境、团队协作</li>
</ul>
<h2 data-id="heading-20">个人见解与总结</h2>
<h3 data-id="heading-21">核心观点</h3>
<p>Agent Skills 不仅是技术工具，更是编程知识管理的范式升级。它解决了 AI 辅助开发中的三个根本矛盾：</p>
<ol>
<li>
<p>通用性与特异性的矛盾</p>
<ul>
<li><code>AGENTS.md</code> 试图两者兼顾，结果两头不讨好</li>
<li>Skill 将通用知识提取、封装、复用，让项目文件回归本质</li>
</ul>
</li>
<li>
<p>深度与广度的矛盾</p>
<ul>
<li>大模型虽有广度，但缺乏领域深度</li>
<li>Skill 引入人类专家知识，弥补模型能力边界</li>
</ul>
</li>
<li>
<p>个人与团队的矛盾</p>
<ul>
<li>个人 <code>AGENTS.md</code> 难以团队协作</li>
<li>Skill 可版本化、共享、共建，形成团队知识资产</li>
</ul>
</li>
</ol>
<h3 data-id="heading-22">最佳实践建议</h3>
<p>总结如下实践指南：</p>
<p>对于 Skill 使用者：</p>
<ul>
<li>优先使用官方/专家 Skill：如苹果工程师维护的 Swift  Skill，比社区版更可靠</li>
<li>定期更新 Skills：<code>openskills update avdlee/Swift-Concurrency-Agent-Skill</code></li>
<li>小步验证：先让 Skill 分析单个文件，再扩展到整个项目</li>
<li>审查引用：检查 Skill 建议的引用文档，理解其逻辑，而非盲信</li>
</ul>
<p>对于 Skill 创建者：</p>
<ul>
<li>聚焦单一领域：一个 Skill 只解决一个问题（如只做并发，不做架构）</li>
<li>编写决策树：SKILL.md 必须是决策指南，而非平铺文档</li>
<li>提供可运行示例：在 <code>scripts/</code> 目录提供验证脚本，如：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">  <span class="hljs-comment"># scripts/validate-actor-isolation.sh</span>
  <span class="hljs-comment"># 自动扫描 @MainActor 冗余情况</span>
</code></pre>
<ul>
<li>版本兼容：明确 Skill 支持的 Swift/Xcode 版本范围</li>
</ul>
<p>对于团队负责人：</p>
<ul>
<li>建立内部 Skill 市场：将团队编码规范封装为 Skill</li>
<li>CI 集成：在 PR 检查中运行 Skill 分析，如：</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml">  <span class="hljs-comment"># .github/workflows/ai-review.yml</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">Swift</span> <span class="hljs-string">Concurrency</span> <span class="hljs-string">Skill</span> <span class="hljs-string">Audit</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">|
      openskills install team/swift-concurrency-skill
      openskills run audit --skill swift-concurrency --path Sources/
</span></code></pre>
<h3 data-id="heading-23">与传统文档的对比</h3>
<p>Agent Skills 不是取代文档，而是增强：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- 传统文档：人读 → 理解 → 应用（慢、易错）</span>
<span class="hljs-addition">+ Agent Skills：Agent 读 → 直接应用 + 人读 → 学习（快、准确）</span>
</code></pre>
<p>Skill 的双重价值：</p>
<ol>
<li>运行时：Agent 实时指导编码</li>
<li>学习时：开发者阅读参考文档，提升技能</li>
</ol>
<h2 data-id="heading-24">扩展场景与创新应用</h2>
<h3 data-id="heading-25">多 Skill 协同工作</h3>
<p>真实项目中常需多个 Skills 协同：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 复杂场景：重构遗留代码</span>
用户："将这个 VIPER 模块重构为 SwiftUI + Concurrency"

Agent 工作流：
<span class="hljs-bullet">1.</span> 加载 swift-architecture-skill (理解 VIPER)
<span class="hljs-bullet">2.</span> 加载 swiftui-skill (理解 SwiftUI 最佳实践)
<span class="hljs-bullet">3.</span> 加载 swift-concurrency-skill (理解并发迁移)
<span class="hljs-bullet">4.</span> 加载 testing-skill (确保重构后覆盖测试)

协同决策：
<span class="hljs-bullet">-</span> Architecture Skill: "VIPER → TCA 或 MVVM"
<span class="hljs-bullet">-</span> SwiftUI Skill: "使用 @StateObject 和 @EnvironmentObject"
<span class="hljs-bullet">-</span> Concurrency Skill: "将 Interactor 的回调改为 async/await"
<span class="hljs-bullet">-</span> Testing Skill: "为新的 ViewModel 编写异步测试"

最终输出：集成各 Skill 建议的综合重构方案
</code></pre>
<p>技术挑战：多 Skill 可能冲突。解决方案：</p>
<ul>
<li>Skill 优先级：<code>&lt;skills_system priority="1"&gt;</code> 控制加载顺序</li>
<li>冲突仲裁：Agent 需识别矛盾建议，请求人工澄清</li>
</ul>
<h3 data-id="heading-26">企业级应用场景</h3>
<p>场景一：金融 App 合规检查</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建内部 Skill：financial-compliance-skill</span>
/references
  ├── data-encryption.md      <span class="hljs-comment"># 数据加密规范</span>
  ├── audit-logging.md        <span class="hljs-comment"># 审计日志要求</span>
  └── api-security.md         <span class="hljs-comment"># API 安全标准</span>

<span class="hljs-comment"># 在 CI 中强制检查</span>
openskills run compliance-check --skill financial-compliance
<span class="hljs-comment"># 不通过则阻断 PR 合并</span>
</code></pre>
<p>场景二：跨平台知识库</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># multi-platform-skill.yaml</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">multi-platform-ui</span>
<span class="hljs-attr">references:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">shared-state-management.md</span>  <span class="hljs-comment"># 通用状态管理</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">ios/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">swiftui-patterns.md</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">android/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">composable-patterns.md</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">web/</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">react-patterns.md</span>

<span class="hljs-comment"># Agent 根据项目类型自动路由</span>
</code></pre>
<p>场景三：动态 Skill 生成</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 从内部文档自动生成 Skill</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_skill_from_docs</span>(<span class="hljs-params">doc_path: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-comment"># 1. 解析 Markdown 文档</span>
    <span class="hljs-comment"># 2. 提取决策树（基于标题层次）</span>
    <span class="hljs-comment"># 3. 生成 SKILL.md</span>
    <span class="hljs-comment"># 4. 打包为 GitHub 仓库</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 例如：将团队 Notion 知识库转为 Skill</span>
generate_skill_from_docs(<span class="hljs-string">"https://notion.so/team-guide"</span>)
</code></pre>
<h3 data-id="heading-27">AI 原生开发工作流</h3>
<p>展望未来，Skill 可能成为可交易的编程知识资产：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"skill_marketplace"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"swift-concurrency-expert"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Apple Engineer"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"price"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$9.99/month"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"metrics"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"accuracy"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">98.5</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"adoption"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12000</span>+<span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"reviews"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4.9</span>/<span class="hljs-number">5</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"updates"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"与 Swift 版本同步发布"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"rxswift-migration-kit"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ReactiveX Team"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"price"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Free"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"purpose"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"从 RxSwift 迁移到 Combine/Swift Concurrency"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这种模式将人类专家知识与AI 效率结合，创造新的知识经济形态。</p>
<h2 data-id="heading-28">参考资料与进一步学习</h2>
<h3 data-id="heading-29">官方资源</h3>
<ol>
<li>
<p>Agent Skills 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fagentskills.io%2Fhome" target="_blank" title="https://agentskills.io/home" ref="nofollow noopener noreferrer">agentskills.io/home</a></p>
<ul>
<li>官方规范、示例和工具链</li>
</ul>
</li>
<li>
<p>openskills CLI：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnumman-ali%2Fopenskills" target="_blank" title="https://github.com/numman-ali/openskills" ref="nofollow noopener noreferrer">github.com/numman-ali/…</a></p>
<ul>
<li>Skill 管理命令行工具</li>
</ul>
</li>
<li>
<p>Swift Concurrency Skill：</p>
<ul>
<li>GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAvdLee%2FSwift-Concurrency-Agent-Skill" target="_blank" title="https://github.com/AvdLee/Swift-Concurrency-Agent-Skill" ref="nofollow noopener noreferrer">github.com/AvdLee/Swif…</a></li>
</ul>
</li>
</ol>
<h3 data-id="heading-30">相关技术文档</h3>
<ol>
<li>
<p>Swift Concurrency：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0296-async-await.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0296-async-await.md" ref="nofollow noopener noreferrer">SE-0296: async/await</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0306-actors.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0306-actors.md" ref="nofollow noopener noreferrer">SE-0306: Actors</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswiftlang%2Fswift-evolution%2Fblob%2Fmain%2Fproposals%2F0337-support-incremental-migration-to-concurrency-checking.md" target="_blank" title="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" ref="nofollow noopener noreferrer">SE-0337: Strict Concurrency</a></li>
</ul>
</li>
<li>
<p>Default Actor Isolation in Swift 6：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fconcurrency%2Fdefault-actor-isolation-in-swift-6-2%2F" target="_blank" title="https://www.avanderlee.com/concurrency/default-actor-isolation-in-swift-6-2/" ref="nofollow noopener noreferrer">www.avanderlee.com/concurrency…</a></p>
</li>
</ol>
<h3 data-id="heading-31">社区资源</h3>
<ul>
<li>Cursor AI 文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.com%2Fcn" target="_blank" title="https://cursor.com/cn" ref="nofollow noopener noreferrer">cursor.com/cn</a></li>
<li>Codex CLI 指南：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenai%2Fcodex" target="_blank" title="https://github.com/openai/codex" ref="nofollow noopener noreferrer">github.com/openai/code…</a></li>
<li>AI Development Blog：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fai-development%2F" target="_blank" title="https://www.avanderlee.com/ai-development/" ref="nofollow noopener noreferrer">www.avanderlee.com/ai-developm…</a></li>
</ul>
<h2 data-id="heading-32">最终总结</h2>
<p>Agent Skills 标志着 AI 辅助编程从手工提示工程迈向系统化知识工程。它不仅是文件格式的革新，更是开发范式的进化：</p>
<ol>
<li>对开发者：从重复教 AI 基础知识，到专注项目逻辑</li>
<li>对团队：从口头规范，到可执行、可验证的知识资产</li>
<li>对社区：从散落博客，到标准化、可组合的专家系统</li>
</ol>
<p>行动清单</p>
<p>立即开始尝试 Agent Skills：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 安装 openskills</span>
pip install openskills

<span class="hljs-comment"># 2. 安装第一个 Skill</span>
openskills install avdlee/Swift-Concurrency-Agent-Skill

<span class="hljs-comment"># 3. 同步到你的项目</span>
<span class="hljs-built_in">cd</span> your-project
openskills <span class="hljs-built_in">sync</span>

<span class="hljs-comment"># 4. 在 Cursor/Codex 中提问</span>
<span class="hljs-string">"使用 Skill 优化我的并发代码"</span>

<span class="hljs-comment"># 5. 观察效果，逐步构建自己的 Skills</span>
</code></pre>
<p>未来已来，Agent Skills 让 AI 真正理解你的领域，而非仅仅是模式匹配。</p>
<h2 data-id="heading-33">学习资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.avanderlee.com%2Fai-development%2Fagent-skills-replacing-agents-md-with-reusable-ai-knowledge%2F" target="_blank" title="https://www.avanderlee.com/ai-development/agent-skills-replacing-agents-md-with-reusable-ai-knowledge/" ref="nofollow noopener noreferrer">www.avanderlee.com/ai-developm…</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用一个小 Demo，带你入门安卓 Clean Architecture]]></title>    <link>https://juejin.cn/post/7601486204174123058</link>    <guid>https://juejin.cn/post/7601486204174123058</guid>    <pubDate>2026-02-02T00:10:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174123058" data-draft-id="7601028900886462510" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用一个小 Demo，带你入门安卓 Clean Architecture"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-02T00:10:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潜龙勿用之化骨龙"/> <meta itemprop="url" content="https://juejin.cn/user/2313028195058471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用一个小 Demo，带你入门安卓 Clean Architecture
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2313028195058471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潜龙勿用之化骨龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:10:42.000Z" title="Mon Feb 02 2026 00:10:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言：为什么你的代码越来越难维护？</h2>
<p>你是否遇到过这些问题：</p>
<ul>
<li>业务逻辑直接写在 <code>Activity / Fragment</code> 里</li>
<li>UI、网络、数据库代码混在一起，牵一发而动全身</li>
<li>一个接口字段改动，整个项目到处报错</li>
<li>想写单元测试，却发现严重依赖 Android Framework</li>
</ul>
<p>如果你对以上情况并不陌生，那么问题往往不是你写得不够努力，而是<strong>项目缺乏清晰的架构设计</strong>。</p>
<p><strong>Clean Architecture（整洁架构）</strong>，正是为了解决这些问题而提出的一种架构思想。</p>
<hr/>
<h2 data-id="heading-1">什么是 Clean Architecture？</h2>
<p><strong>Clean Architecture 不是一个框架，而是一种设计原则。</strong></p>
<p>它的核心目标可以总结为一句话：</p>
<blockquote>
<p><strong>让核心业务逻辑独立于 UI、框架和实现细节。</strong></p>
</blockquote>
<p>也就是说：</p>
<ul>
<li>UI 可以随意更换（XML → Compose）</li>
<li>网络库可以替换（Retrofit → Ktor）</li>
<li>数据来源可以变化（API → 本地数据库）</li>
</ul>
<p>👉 <strong>但业务逻辑几乎不用改动。</strong></p>
<h3 data-id="heading-2">核心原则：依赖倒置（Dependency Rule）</h3>
<p>Clean Architecture 最重要的一条规则是：</p>
<blockquote>
<p><strong>代码的依赖方向，只能从外层指向内层。</strong></p>
</blockquote>
<ul>
<li>内层：业务规则（最稳定）</li>
<li>外层：UI、网络、数据库（最容易变化）</li>
</ul>
<p>📌 内层永远不知道外层的存在</p>
<hr/>
<h2 data-id="heading-3">Clean Architecture 的分层结构</h2>
<p>在 Android 项目中，Clean Architecture 通常可以拆分为三层：</p>
<h3 data-id="heading-4">1️⃣ Presentation（表现层）</h3>
<p><strong>职责：负责 UI 展示和用户交互</strong></p>
<p>常见组件：</p>
<ul>
<li>Activity / Fragment</li>
<li>Jetpack Compose</li>
<li>ViewModel</li>
</ul>
<p>特点：</p>
<ul>
<li>不包含业务规则</li>
<li>只负责管理 UI State</li>
<li>通过 UseCase 调用业务逻辑</li>
</ul>
<hr/>
<h3 data-id="heading-5">2️⃣ Domain（领域层）⭐ 核心层</h3>
<p><strong>职责：定义业务规则和业务模型</strong></p>
<p>包含内容：</p>
<ul>
<li>Entity / Model</li>
<li>UseCase</li>
<li>Repository 接口（抽象）</li>
</ul>
<p>特点：</p>
<ul>
<li>纯 Kotlin</li>
<li>不依赖 Android</li>
<li>不依赖任何第三方库</li>
<li>是整个项目中最稳定的一层</li>
</ul>
<p>📌 这一层承载了项目真正的“业务价值”。</p>
<hr/>
<h3 data-id="heading-6">3️⃣ Data（数据层）</h3>
<p><strong>职责：负责数据从哪里来、如何获取</strong></p>
<p>包含内容：</p>
<ul>
<li>网络请求（API）</li>
<li>本地数据库</li>
<li>Repository 的具体实现</li>
</ul>
<p>特点：</p>
<ul>
<li>实现 Domain 层定义的接口</li>
<li>可以自由切换数据来源</li>
<li>是变化最频繁的一层</li>
</ul>
<hr/>
<h2 data-id="heading-7"><code>CleanArc</code> 项目实践</h2>
<p>接下来，我们通过一个简单的示例项目 <strong>CleanArc</strong>，来看看 Clean Architecture 在真实 Android 项目中是如何落地的。</p>
<p>🎯 项目目标很简单：</p>
<blockquote>
<p><strong>从服务器获取用户列表，并将其展示在界面上</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-8">Data 层：数据的来源（How）</h2>
<p>Data 层只关心一件事：</p>
<blockquote>
<p><strong>我如何把数据拿到？</strong></p>
</blockquote>
<h3 data-id="heading-9">Repository 实现</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fef8074fe1054699ac8efe7c6a05d763~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=lqKvt7SKd04u0kQeYPBAAW20%2B5A%3D" alt="image.png" loading="lazy"/></p>
<p>📌 在本项目中，<strong>异常是在 Repository 层中被处理的</strong>。
Repository 最清楚异常的来源，因此在这里将技术异常转换为业务可理解的结果。</p>
<hr/>
<h2 data-id="heading-10">Domain 层：核心业务逻辑（What）</h2>
<p>Domain 层只关心：</p>
<blockquote>
<p><strong>我要做什么，而不是怎么做</strong></p>
</blockquote>
<h3 data-id="heading-11">Repository 接口（契约）</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f08b4c0205348018e7c1292f2088c0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=e8Bqwbao19ASJKDPPyrIur3mgwE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-12">UseCase：业务行为的封装</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae2d99513b8241d5924ace93bb3ce7a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=pvp%2BCgOUrf4hLr1BrFR%2Ffvdo6Vs%3D" alt="image.png" loading="lazy"/></p>
<p>📌 UseCase 不负责捕获异常
📌 它只组合和执行业务规则
📌 Domain 层因此保持高度纯净</p>
<hr/>
<h2 data-id="heading-13">Presentation 层：UI 展示（Show）</h2>
<p>Presentation 层负责将数据转换为用户可感知的界面状态。</p>
<h3 data-id="heading-14">ViewModel</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bbd9eaec32c4841a6c79bb816acd6d6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=euHVIi8Y1TQ8ErOtOU6iLEY10Tw%3D" alt="image.png" loading="lazy"/></p>
<p>特点：</p>
<ul>
<li>ViewModel 不直接依赖 Repository</li>
<li>只通过 UseCase 与 Domain 层交互</li>
<li>专注于 UI State 管理</li>
</ul>
<p>UI（Compose / XML）只需根据 State 渲染界面。</p>
<hr/>
<h2 data-id="heading-15">关于异常处理：为什么放在 Repository 层？</h2>
<p>在本项目中，<strong>异常处理主要集中在 Repository（Data 层）中完成</strong>，而不是在 UseCase 层统一 try-catch。</p>
<p>原因包括：</p>
<ul>
<li>Repository 最了解异常的真实来源（网络、数据库、解析）</li>
<li>可以在这里将技术异常转换为业务错误</li>
<li>避免将 Retrofit、HTTP Code 等细节泄露到 Domain 层</li>
<li>保持 Domain 层的纯净和稳定</li>
</ul>
<p>这种做法在 Android 工程实践中非常常见，也更利于长期维护。</p>
<hr/>
<h2 data-id="heading-16">依赖注入：将各层连接起来</h2>
<p>为了将接口和实现解耦，本项目使用 <strong>Koin</strong> 进行依赖注入：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63423494b6e641cdb2a498afcff35225~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5r2c6b6Z5Yu_55So5LmL5YyW6aqo6b6Z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770595842&amp;x-signature=LqcB7EogJ0HZofg2eX1uyv2YdY0%3D" alt="image.png" loading="lazy"/></p>
<p>通过依赖注入：</p>
<ul>
<li>Domain 层只定义接口</li>
<li>Data 层提供实现</li>
<li>Presentation 层只消费能力</li>
<li>各层之间无直接耦合</li>
</ul>
<hr/>
<h2 data-id="heading-17">总结</h2>
<p>通过 <code>CleanArc</code> 这个示例项目，我们可以看到 Clean Architecture 带来的价值：</p>
<ul>
<li>✅ <strong>关注点分离</strong>：UI、业务、数据各司其职</li>
<li>✅ <strong>可测试性强</strong>：UseCase 和 ViewModel 易于单元测试</li>
<li>✅ <strong>高可维护性</strong>：修改数据来源不会影响业务层</li>
<li>✅ <strong>适合长期演进的项目</strong></li>
</ul>
<p>Clean Architecture 对于中大型项目来说，它能显著降低维护成本，让代码结构更加清晰、可控。</p>
<hr/>
<h2 data-id="heading-18">示例代码</h2>
<p>📦 项目完整代码已上传至 GitHub：</p>
<p>👉 <strong>CleanArc 示例项目</strong>
🔗 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FThirdPrince%2FCleanArc" target="_blank" title="https://github.com/ThirdPrince/CleanArc" ref="nofollow noopener noreferrer">github.com/yourname/Cl…</a></p>
<p>欢迎 Star ⭐。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[读完书容易忘？这个开源 AI 应用能帮你！]]></title>    <link>https://juejin.cn/post/7601706140200108095</link>    <guid>https://juejin.cn/post/7601706140200108095</guid>    <pubDate>2026-02-02T02:17:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601706140200108095" data-draft-id="7601464318409785386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="读完书容易忘？这个开源 AI 应用能帮你！"/> <meta itemprop="keywords" content="前端,程序员,开源"/> <meta itemprop="datePublished" content="2026-02-02T02:17:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ssshooter"/> <meta itemprop="url" content="https://juejin.cn/user/3122268751795101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            读完书容易忘？这个开源 AI 应用能帮你！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268751795101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ssshooter
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:17:52.000Z" title="Mon Feb 02 2026 02:17:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>其实我们不必回避看完书就忘的问题，因为大多数人看书都是会忘的。其实人类的大脑就是这么设计的，它会过滤掉大部分不重要的信息，只保留下重要的信息。如果真的想要记住一本书重要的知识，需要反复阅读，反复思考，反复练习。</p>
<p>在前 AI 时代，做读书笔记是一件非常耗费精力的事情，但是有大模型之后，我们可以在做笔记这件事上偷偷懒。</p>
<p><strong>注意：做笔记可以偷懒，但是思考和反复回看是绝对不能偷懒的。</strong></p>
<p>那么有什么好用的工具呢？朋友们，有的！欢迎使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a>！简单来说，你可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 把 pdf 或 epub 格式的电子书转换为分章节的思维导图或者文字总结。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae8178b399294c2aaf146488bd9c4d41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=NEDv08BQW0EsCQIDi4Sp%2FUQFIiA%3D" alt="思维导图模式" loading="lazy"/></p>
<p>点击<a href="https://link.juejin.cn?target=https%3A%2F%2Febook2me-next.mind-elixir.com%2F" target="_blank" title="https://ebook2me-next.mind-elixir.com/" ref="nofollow noopener noreferrer">这里</a>即可立即体验。整个网页应用功能比较简洁，大家可以直接上手，当然，下面我也会比较详细地介绍一下这个应用的使用方法🤗</p>
<h2 data-id="heading-0">模型配置</h2>
<p>使用 ebook-to-mindmap 的第一步是配置模型。它和很多 AI 应用一样，都是选择 <strong>byok</strong>（Bring Your Own Key）的模式，你可以在这里配置你自己的大模型。</p>
<p>这里还是要强调一下，在 ebook-to-mindmap 填写 Key 时不必担心 Key 泄露，因为 <strong>Key 只是保存在你自己的浏览器里</strong>，请求也是直接从你的浏览器发送到大模型提供商的服务器的。你可以在浏览器的开发者工具里查看网络请求，确认这一点。同时，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 作为一个开源项目你可以随时检视它的代码，还可以自己部署一个属于你的 ebook-to-mindmap。</p>
<p>说回模型的选择，可能很多人会担心使用 ebook-to-mindmap 的花费太高，其实倒也不必，毕竟现阶段还是能找到很多免费或者低价的大模型。我的首推还是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai%2F" target="_blank" title="https://openrouter.ai/" ref="nofollow noopener noreferrer"><strong>openrouter</strong></a>，你只需要充值 10 刀，就能获得一个较大的免费模型（其中包括一些 deepseek 变体、最近小米的新模型、之前一段时间还有 grok）使用额度，基本上一天让它处理好几本书都没问题了。其他详细推荐可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fssshooter.com%2Fai-services-guide%2F" target="_blank" title="https://ssshooter.com/ai-services-guide/" ref="nofollow noopener noreferrer">免费和付费 AI API 选择指南</a>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7df7825c97547888d450112acbe2869~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=S1Rf%2FUOaLRPoqInIfZ2pREa8UJ4%3D" alt="model list" loading="lazy"/></p>
<p>在获取到 Key 后如上图填写信息即可。</p>
<p>你还可以配置多个模型，点击左侧的星星后会成为默认模型，后续处理时默认使用星标的模型：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb539405ba5f4eb4838d981a0a99f21a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=xT%2BODB72MtLSA3KS3iUt12ABcf4%3D" alt="model list" loading="lazy"/></p>
<h2 data-id="heading-1">生成笔记</h2>
<p>配置模型后，在主页选择电子书即可。之后 ebook-to-mindmap 会自动识别电子书的格式，然后开始识别章节：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bb41bd7f5f241f08b87cebb770c4d64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=74t4%2B3dFb9pX1NN098zcbdcp4GU%3D" alt="AI 总结页面" loading="lazy"/></p>
<blockquote>
<p>[!TIP]
提示：如果 epub 无法获取到章节，可以在设置里勾选使用 Spine 获取章节</p>
</blockquote>
<p>章节识别成功后，选择你需要总结的章节，或者使用分组功能（可以使用快捷键 Ctrl + G）把零碎的章节组合成分组一起发送给 AI 处理。</p>
<p>一切准备好后，点击开始解释按钮即可开始生成笔记。</p>
<p>默认情况下，ebook-to-mindmap 会生成<strong>思维导图</strong>，你也可以点击小齿轮切换到<strong>文字总结</strong>模式：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3406b66a9484e2dae227d066545f242~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=hUmw%2FJq3eIlmjk4MvzKt63STog8%3D" alt="模式切换" loading="lazy"/></p>
<blockquote>
<p>[!TIP]
虽然有整书思维导图生成功能，但是如果书的内容比较长，AI 可能吃不下这么长的上下文，所以建议还是分章节生成，最后系统会自动拼接</p>
</blockquote>
<p>生成笔记如果想要中途取消，放心点取消就好，<strong>之前处于完成状态的章节会被缓存</strong>，不用担心之后需要再浪费 Token 重新生成。</p>
<h2 data-id="heading-2">提示词</h2>
<p>举个例子吧，你在提示词列表里添加一个“小·红书风格”提示词，在生成环节选择这个提示词，就能直接生成小红书风格的笔记。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9977cb633e3f4ef685ba3dd47198c004~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3NzaG9vdGVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603472&amp;x-signature=5joPgw9qpFUe8rY1R4mM8CfCpyA%3D" alt="小红书风格" loading="lazy"/></p>
<p>不止小红书风格，你也可以让 AI 只简单地提取该章节最重要的 5 个观点，帮助你对整本书的主要内容有一个简要的了解。</p>
<p>你还可以使用“反论法”提示词：</p>
<pre><code class="hljs">选取本章的核心论点或思想，并探索它的对立面。如果作者要为相反的观点辩护，他们需要证明什么？文本中是否有无意间支持反面观点的蛛丝马迹？
</code></pre>
<p>参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fssshooter.com%2Fnotebooklm-prompt%2F" target="_blank" title="https://ssshooter.com/notebooklm-prompt/" ref="nofollow noopener noreferrer">分享几条有意思的 NotebookLM 提示词</a>这篇文章，里面有几个有趣的提示词，或许能让你眼前一亮。</p>
<h2 data-id="heading-3">内容管理</h2>
<p>ebook-to-mindmap 充满了下载按钮，是的，你生成的数据必须还是属于你的！你可以很轻易地把数据拿出来！</p>
<p>导出的文字内容可能是 markdown 文件或是思维导图 json 文件。</p>
<p>markdown 文件可以直接阅读，或者导入到 Obsidian、Notion 等笔记软件再细化修改。</p>
<p>思维导图 json 文件可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Fmind-elixir-core" target="_blank" title="https://github.com/SSShooter/mind-elixir-core" ref="nofollow noopener noreferrer">mind-elixir-core</a> 等前端库渲染，当然，如果你是技术人员，理解 json 数据的结构你也可以随意修改和渲染。</p>
<p>思维导图亦可导出为图片，点击思维导图页面右上角的下载按钮即可。</p>
<h2 data-id="heading-4">格式选择</h2>
<p>最后谈谈电子书格式的问题，ebook-to-mindmap 支持 pdf 和 epub 格式的电子书，但是这两种格式如何选择呢？</p>
<p>或许大家都会比较喜欢看 pdf，因为看起来比较工整，但是使用 ebook-to-mindmap，我还是比较<strong>推荐 epub 格式</strong>的电子书。</p>
<p>稍微讲一下 pdf 和 epub 的原理吧。</p>
<p>pdf 的特点是在任何设备上看起来都一样，这就很容易想到，其实 pdf 的排版是非常固定的，而且更重要的是，pdf 的排版是没有语义的。也就是说，人类能看到一个标题是加粗黑字，但是 pdf 本身并不知道这是一个标题，它只是知道这一块区域的文字是加粗黑字的。</p>
<p>更严重的问题是 pdf 如果有一些复杂的排版，例如在角落嵌入一段文字，在解释的时候就很难理解那段文字的意义。所以，大模型理解 pdf 的难度会比较大。</p>
<p>而 epub 格式就不一样，它更像是一张网页，有语义，有结构，有层次，就跟 HTML 差不多。但缺点就是人类看来这样的排版有点粗糙，在不同的阅读器上显示效果也不同。在某些落后的 epub 阅读器上阅读时可能会觉得排版很有年代感。但是大模型不在乎排版，有清晰的结构就能得到好的输出结果。</p>
<h2 data-id="heading-5">写在最后</h2>
<p>总的来说，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">ebook-to-mindmap</a> 是一个能帮你快速复习或者把书本变薄的工具。在这个信息爆炸的时代，高效地获取和整理知识变得越来越重要。希望这个小工具能成为你阅读路上的得力助手，让你把更多的时间花在深度思考和理解上，而不是机械地摘抄。</p>
<p>如果你觉得这个项目对你有帮助，欢迎在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSSShooter%2Febook-to-mindmap" target="_blank" title="https://github.com/SSShooter/ebook-to-mindmap" ref="nofollow noopener noreferrer">GitHub</a> 上点个 Star ⭐️ 支持一下！如果你有任何建议或发现了 bug，也欢迎提 Issue 或者加入讨论。</p>
<p>Happy Reading!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我为什么讨厌继承？]]></title>    <link>https://juejin.cn/post/7601384029611425807</link>    <guid>https://juejin.cn/post/7601384029611425807</guid>    <pubDate>2026-02-02T01:26:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601384029611425807" data-draft-id="7597722671084699682" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我为什么讨厌继承？"/> <meta itemprop="keywords" content="Android,Kotlin,设计模式"/> <meta itemprop="datePublished" content="2026-02-02T01:26:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RockByte"/> <meta itemprop="url" content="https://juejin.cn/user/1046390797768519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我为什么讨厌继承？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1046390797768519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RockByte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:26:08.000Z" title="Mon Feb 02 2026 01:26:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc52bda5809d440d95f07706efade322~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=ZyRqsw2fw2gZi2bCF8Q3zCyZp0s%3D" alt="a.png" loading="lazy"/></p>
<p>我在之前的一篇文章<a href="https://juejin.cn/post/7599910677578874880" target="_blank" title="https://juejin.cn/post/7599910677578874880">精通 Rust 宏 — 第一个宏</a>中提到过，我讨厌继承。</p>
<p>第二天中午我同事跑过来问我，这东西现在语言都有，你有什么讨厌的？</p>
<p>我问他，你还记得面向对象的三要素吗？</p>
<p>他说：封装，继承...，然后...，多态！</p>
<p>我上大学学习 Java 的时候，很多相关书籍都会讲解这三要素，以现在的我看来，封装和多态是必要的。</p>
<p>但是继承...</p>
<h2 data-id="heading-0">继承有什么问题</h2>
<p>在我刚参加工作的第三年，我参与到了中国移动和地图 App 的开发工作中，当时我负责改造该 App 的核心网络请求模块。</p>
<p>那个时候还没有流行使用 <strong>OkHttp</strong> ，更没有 <strong>Retrofit</strong> 这种优秀的网络开源库，整体还是使用原始的 <strong>HttpConnection</strong> 去完成网络请求，自己封装里面的实现逻辑。</p>
<p>我当时理解完需求之后，整理了网络库需要满足的功能，大概如下：</p>
<ol>
<li>完成对数据的序列化和反序列化。</li>
<li>完成对数据的加密解密。</li>
<li>返回纯文本的数据结构。</li>
<li>返回 <strong>JSONObject</strong> 的数据结构。</li>
<li>返回基于 Java 对象的数据结构。</li>
</ol>
<p>自然而然，我想到了这种方案，</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df7fb263a9e461783f7fc1d063d6c53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=ztQz%2Bhn6xW3F3SsPMMju1nbSdqQ%3D" alt="0.png" loading="lazy"/></p>
<ol>
<li>首先，<code>BaseHttp</code> 作为基类，负责序列化和反序列化和加解密，因为从目前看来，一个请求一定会有这两个需求。</li>
<li><code>TextHttp</code> 继承 <code>BaseHttp</code>，将其字节码转换成文本。</li>
<li><code>JsonHttp</code> 继承 <code>TextHttp</code>，将文本转换成 <code>JSONObject</code> 结构。</li>
<li>以此类推。。。</li>
</ol>
<p>一开始，这样做非常方便，例如：如果一个请求只需要获取文本内容，那么就直接继承 <code>TextHttp</code>。</p>
<p>也就是说，一个请求需要实现哪些能力，那么就继承那个基类就好了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c539669eb55469188b91007dca066fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=v4mDSqZMlKuOBHMc64o12DtnOM0%3D" alt="1.png" loading="lazy"/></p>
<p>而使用这个网络库的人，只需要按照 API 文档中的 API 名称，用这个请求就行了，例如 <code>Sell</code> -&gt; <code>SellHttp</code>，<code>Login</code> -&gt; <code>LoginHttp</code>，用起来会非常方便！</p>
<p>但是后续改动，让我越来越 Hold 不住这种继承链了：有的 API 需要鉴权，有的不需要；部分 API 会有不同的 Header；有的 API 返回结果加密方式和之前的不一样。</p>
<p>慢慢的，我发现我的继承链越来越长，为了让我的 API 使用保持简洁，甚至出现了类似菱形继承的情况（这里不是说 Java 可以菱形继承）：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce3846fd44c94469a6115242e3c0464b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770600367&amp;x-signature=uniKjDNCZDHCXM0ScheHQB6xABc%3D" alt="2.png" loading="lazy"/></p>
<p>实际上 <code>SHACryptJsonHttp</code> 包括其基类有大量相似的代码，只是鉴权方式问题，导致我不得不重新改写整个继承链（这里只是一个示例，真实情况比这个复杂的多）。</p>
<p>后面这种问题越来越多，虽然同事们用起来非常方便（对照文档直接 <code>new</code> 即可），但是对我的维护造成了巨大负担，同时也会犯一些非常低级的错误，例如搞错了鉴权方式！</p>
<p>为什么会这样呢？</p>
<h2 data-id="heading-1">一句话总结</h2>
<p>“继承”这个特性，本来想干三件事，结果三件事互相打架，最后搞得谁都不开心。</p>
<p>好的，我来换个思路解释，以 Java 这种语言为例：</p>
<p>比如你写一个 <code>Animal</code> 类，再写一个 <code>Dog</code> 类继承它，这样 <code>Dog</code> 就自动有了 <code>Animal</code> 的所有方法和属性。</p>
<p>听起来很美好，对吧？（当时我就是这么认为的）</p>
<p>但问题来了——<strong>我们其实用“继承”做了三件完全不同的事</strong>，而这三件事根本不是一回事！</p>
<h3 data-id="heading-2">第一件事：分类 —— 这东西属于哪一类</h3>
<p>比如：“正方形是一种矩形”，“狗是一种动物”。</p>
<p>这是从<strong>现实世界逻辑</strong>出发的，叫“本体论”（别被名字吓到，就是“分类”的意思）。</p>
<p>这合理啊，正方形确实是矩形的一种特殊情况。</p>
<h3 data-id="heading-3">第二件事： 能替换吗 —— 程序能不能当同一种东西用</h3>
<p>比如：如果一个函数要求传入一个 <code>Rectangle</code>（矩形），那我能传一个 <code>Square</code>（正方形）进去吗？</p>
<p>如果可以，就叫“可替换”，这是<strong>程序正确性</strong>的问题。</p>
<p>但现实中不行！因为矩形可以改宽高，而正方形一改宽高就不是正方形了。</p>
<p>所以：<strong>虽然“正方形是矩形”在数学上成立，但在代码里不能随便替换！</strong></p>
<blockquote>
<p>这就是著名的 <strong>“正方形-矩形悖论”</strong> —— 看似合理，实则坑人。</p>
</blockquote>
<h3 data-id="heading-4">第三件事：  省代码 —— 别重复写一样的代码</h3>
<p>比如：<code>Dog</code> 和 <code>Cat</code> 都有 <code>eat()</code> 方法，于是让它们都继承 <code>Animal</code>，把 <code>eat()</code> 写在父类里。</p>
<p>这纯粹是为了<strong>偷懒/复用代码</strong>，跟“是不是动物”没关系。</p>
<p>好处：少写代码。</p>
<p>风险：万一以后某个“动物”不吃东西（比如机器人宠物），你就得硬改，或者搞一个新的继承链，破坏设计。</p>
<h2 data-id="heading-5">问题来了</h2>
<p>Java <strong>只给了你一个“继承”关键字</strong>，却让你同时干这三件事。</p>
<p>结果：</p>
<ul>
<li>你以为你在“分类”（正方形是矩形），</li>
<li>但程序要求你“能替换”（正方形必须能当矩形用），</li>
<li>而你实际只是为了“省代码”（不想重复写宽高设置）。</li>
</ul>
<p><strong>三件事混在一起，必然出问题！</strong></p>
<p>就像公司里面的团队，虽然大家都属于同一个组，但是如果目标不一致，这必然导致开发问题！</p>
<h2 data-id="heading-6">那怎么办</h2>
<p>这是我后来，才学到的知识。</p>
<p><strong>别用“继承”干所有事！分开处理：</strong></p>





















<table><thead><tr><th>你想干啥</th><th>正确做法</th></tr></thead><tbody><tr><td><strong>想分类？</strong></td><td>用<strong>领域模型</strong>画图就行，别非塞进代码继承树里。</td></tr><tr><td><strong>想保证能替换？</strong></td><td>用<strong>接口（Interface）</strong> 或 <strong>协议（Protocol）</strong> ，明确约定行为。</td></tr><tr><td><strong>想省代码？</strong></td><td>用<strong>组合（Composition）</strong> + <strong>委托（Delegation）</strong> ，比如让 <code>Dog</code> 里面“包含”一个 <code>Eater</code> 对象，而不是继承 <code>Animal</code>。</td></tr></tbody></table>
<p>还记得那句经典的建议吗：“<strong>优先使用组合，而不是继承。</strong> ”</p>
<p>来，举个例子，假设你要做“交通工具”系统：</p>
<ul>
<li>
<p><strong>错误做法（用继承干三件事）</strong>：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> {} }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> { }      <span class="hljs-comment">// 是Vehicle，能替换，还复用了move()</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> { } <span class="hljs-comment">// 同上</span>
</code></pre>
<p>→ 这就是我早期开发 Http 框架时候的做法。问题来了，如果以后加个 <code>Hovercraft</code>（气垫船），它既能走陆地又能走水，继承哪个？</p>
</li>
<li>
<p><strong>正确做法（分开处理）：</strong></p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drivable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; }

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drivable</span> { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hovercraft</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drivable</span>, Floatable { ... } <span class="hljs-comment">// 多实现，灵活！</span>
</code></pre>
<p>→ 分类归分类（你是车还是飞机），行为归行为（你会开还是会飞），代码复用靠组合</p>
<p><em>Java 实现委派会有些麻烦，如果是 Kotlin，就方便多了！</em></p>
</li>
</ul>
<h2 data-id="heading-7">总结</h2>
<p>“继承”就像一把瑞士军刀，本来想切菜、开瓶、剪线都行，结果发现：<strong>切菜时刀片会弹出来割手，开瓶时螺丝刀又碍事。</strong></p>
<p>所以聪明人怎么做？</p>
<p><strong>切菜用菜刀，开瓶用开瓶器，剪线用剪刀。各干各的，互不干扰。</strong></p>
<p>编程也一样：</p>
<p><strong>别指望“继承”解决所有问题，该用接口用接口，该用组合用组合。</strong></p>
<p>这样，代码才清爽，bug 才少，而你，我的朋友，才睡得着觉！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[1个月双线作战：AI公文助手从0到1开发，与国产化适配的"踩坑"全记录]]></title>    <link>https://juejin.cn/post/7601576716016058431</link>    <guid>https://juejin.cn/post/7601576716016058431</guid>    <pubDate>2026-02-02T02:18:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601576716016058431" data-draft-id="7601419065128943635" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1个月双线作战：AI公文助手从0到1开发，与国产化适配的&quot;踩坑&quot;全记录"/> <meta itemprop="keywords" content="前端,GitHub,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T02:18:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="徐小夕"/> <meta itemprop="url" content="https://juejin.cn/user/3808363978429613"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1个月双线作战：AI公文助手从0到1开发，与国产化适配的"踩坑"全记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363978429613/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    徐小夕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:18:37.000Z" title="Mon Feb 02 2026 02:18:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>全职创业2年零1个月，接下来和大家分享一下我们最近做了AI协同产品 <strong>JitWord</strong> 的研发历程。</p>
<h2 data-id="heading-0">为什么要在1个月内攻坚两个硬骨头？</h2>
<p>说实话，启动这次迭代前，团队内部是有分歧的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4574c195c39540fe937a3b5930f3092e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=0F7DqBttEtLHbG50wfrtyqfpMmY%3D" alt="2026-01-30 21.09.31.gif" loading="lazy"/></p>
<p>一方面，<strong>AI公文助手</strong> 是很多政企客户反复提的需求——他们想要 Word 那种严谨的公文排版，又想要AI的生成能力，还要能在线协同；另一方面，<strong>国产化适配</strong>是信创大背景下的必选项，涉及国产操作系统、国产浏览器、甚至国产芯片的兼容性问题。</p>
<p>这两个需求，任何一个单独做都要扒层皮。但市场不等人，我们决定在1个月内"双线作战"。</p>
<p>这篇文章记录了我们如何从0搭建AI公文助手模块，以及在国产化适配过程中遇到的那些让人头秃的坑。希望能给同样面临信创改造或富文本技术选型的同学一些参考。</p>
<hr/>
<h2 data-id="heading-1">JitWord 是什么？（如果你第一次听说）</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c27c99c39e2041bea6a4299a63de9bbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=TvYn4Hgg2QXp8TsnOLgNm%2FdFK5Q%3D" alt="2026-01-29 11.02.48.gif" loading="lazy"/></p>
<p>简单给新朋友介绍一下。<strong>JitWord</strong> 是我们团队开发的<strong>协同AI文档引擎</strong>，定位是"<strong>让Web文档拥有桌面级体验</strong>"，打造“<strong>云端Office</strong>”办公体验。</p>
<p>核心能力包括：</p>
<ul>
<li><strong>多人实时协同</strong>：基于CRDT算法，支持Word级别的冲突解决</li>
<li><strong>AI辅助创作</strong>：内置AI续写、润色、总结，支持自定义Prompt</li>
<li><strong>数学公式渲染</strong>：自研公式引擎，支持LaTeX到Word的无损转换（之前文章有详细讲过）</li>
<li><strong>一键导出Word</strong>：不只是PDF，是真正的<code>.docx</code>格式，导出后还能在Office里二次编辑</li>
</ul>





























<table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td><strong>产品名称</strong></td><td>JitWord 协同AI文档</td></tr><tr><td><strong>技术栈</strong></td><td>Vue3 + NestJS + CRDT + WebSocket</td></tr><tr><td><strong>核心功能</strong></td><td>实时协同、AI写作、公文处理、Word导出</td></tr><tr><td><strong>适用场景</strong></td><td>企业文档中台、科研协作、政务办公</td></tr><tr><td><strong>版本状态</strong></td><td>V2.1（AI公文助手 + 国产化适配版）</td></tr></tbody></table>
<p>最近我们也开源了一版sdk，大家可以轻松本地使用和集成：</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fjitword-sdk" target="_blank" title="https://github.com/MrXujiang/jitword-sdk" ref="nofollow noopener noreferrer">github.com/MrXujiang/j…</a></p>
<hr/>
<h2 data-id="heading-2">第一部分：AI公文助手从0到1</h2>
<h3 data-id="heading-3">1.1 需求拆解：公文场景的残酷现实</h3>
<p>做传统富文本编辑器的朋友可能不知道，<strong>公文排版是中文排版的地狱模式</strong>。</p>
<ul>
<li><strong>红头文件</strong>：要严格遵循 GB/T 9704-2012 国家标准，版头、发文字号、签发人都有固定位置</li>
<li><strong>多层嵌套结构</strong>：一、（一）、1.（1）、①，这五种层级格式不能乱</li>
<li><strong>表格与附件</strong>：公文里的表格必须能跨页重复表头，附件说明有特定格式</li>
<li><strong>严格的页面设置</strong>：A4纸张、上白边37mm±1mm、下白边35mm±1mm...</li>
</ul>
<p>我们调研了市面上几乎所有的Web Office方案，发现要么是简单的表单模板（灵活性不够），要么是把PDF转图片（无法二次编辑）。所以决定自己实现一套<strong>结构化公文引擎</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dd37f0f375143758977f135091c3e3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=H9Y9GhCVMjioaPSdYBUILLGByOE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-4">1.2 技术架构：如何把AI塞进公文流程？</h3>
<p>我们采用了 <strong>模板引擎 + AI生成 + 人工调整</strong> 的三段式架构：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ 公文模板库  │────▶│  AI解析层   │────▶│ 编辑渲染层  │
│ (.docx解析) │     │ (LLM+规则)  │     │ (结构化编辑)│
└─────────────┘     └─────────────┘     └─────────────┘
       │                                        │
       │    ┌─────────────┐                     │
       │◄───│  导出引擎   │◄────────────────────┘
       │    │(Word/PDF)   │
       │    └─────────────┘
</code></pre>
<p><strong>关键技术决策：</strong></p>
<ul>
<li><strong>模板解析</strong>：目前了复用 mammoth.js，但是它的样式映射太粗粒度，后面规划重写。</li>
<li><strong>AI提示词工程</strong>：公文写作不是 Creative Writing，而是 Constraint Writing。我们让AI先分析模板结构，再填充内容，最后做<strong>格式合规性检查</strong>（比如检查发文字号是否符合"国发〔2024〕1号"这种格式）。</li>
<li><strong>编辑器选型</strong>：基础还是ProseMirror，但重写了NodeSpec来支持"公文块"（OfficialBlock）概念。每个公文块是一个不可随意拆分的逻辑单元，比如"主送机关"是一个块，"正文"是一个块。</li>
</ul>
<h3 data-id="heading-5">1.3 核心代码：公文模板的JSON Schema设计</h3>
<p>这是我们定义的公文结构规范（节选）：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// types/document.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OfficialDocument</span> {
  <span class="hljs-attr">version</span>: <span class="hljs-string">'GB/T-9704-2012'</span>;
  <span class="hljs-attr">header</span>: {
    <span class="hljs-attr">issuingBody</span>: <span class="hljs-built_in">string</span>;     <span class="hljs-comment">// 发文机关</span>
    <span class="hljs-attr">documentNumber</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// 发文字号</span>
    <span class="hljs-attr">urgencyLevel</span>: <span class="hljs-string">'特急'</span> | <span class="hljs-string">'加急'</span> | <span class="hljs-string">'平急'</span>;
  };
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">OfficialBlock</span>[];  <span class="hljs-comment">// 正文，由多个公文块组成</span>
  attachments?: <span class="hljs-title class_">Attachment</span>[];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OfficialBlock</span> {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'redHeader'</span> | <span class="hljs-string">'recipient'</span> | <span class="hljs-string">'text'</span> | <span class="hljs-string">'level1'</span> | <span class="hljs-string">'level2'</span> | <span class="hljs-string">'table'</span>;
  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">TableContent</span>;
  <span class="hljs-attr">style</span>: {
    <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'仿宋_GB2312'</span> | <span class="hljs-string">'黑体'</span> | <span class="hljs-string">'楷体_GB2312'</span>;  <span class="hljs-comment">// 信创字体</span>
    <span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">number</span>;       <span class="hljs-comment">// 三号=16pt，小三=15pt...</span>
    <span class="hljs-attr">lineHeight</span>: <span class="hljs-built_in">number</span>;     <span class="hljs-comment">// 28-30磅固定值</span>
  };
}
</code></pre>
<p><strong>遇到的坑：</strong> 仿宋_GB2312 这个字体在Mac和Linux上表现差异巨大。Windows上看着好好的文档，在国产系统（基于Linux）上打开后行高会乱掉。解决方案是<strong>用CSS的<code>line-height: fixed</code> + 字体fallback栈</strong>，并且在导出Word时重新计算行高。</p>
<h3 data-id="heading-6">1.4 AI生成流程的优化</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/693d88b4a428488d80064f9e3dd43b7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=lTmc3Igu8KhHzPB1AvBZAWYONZs%3D" alt="image.png" loading="lazy"/></p>
<p>最初我们直接把"写一篇关于XX的通知"扔给GPT-5，结果生成的内容总是<strong>太口语化</strong>，而且格式经常出错。</p>
<p>优化后的流程是：</p>
<ol>
<li><strong>模板匹配</strong>：先根据用户选择的公文类型（通知、通报、请示、报告等），加载对应的Prompt模板</li>
<li><strong>结构化生成</strong>：要求AI输出JSON格式，而不是Markdown</li>
<li><strong>规则校验层</strong>：用正则表达式校验公文要素是否齐全（比如通知必须有"特此通知"结尾，请示必须有"妥否，请批复"）</li>
</ol>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ai/officialWriter.ts</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateOfficialDoc</span>(<span class="hljs-params">params: GenerationParams</span>) {
  <span class="hljs-keyword">const</span> template = <span class="hljs-title function_">loadTemplate</span>(params.<span class="hljs-property">type</span>);
  
  <span class="hljs-keyword">const</span> structuredPrompt = <span class="hljs-string">`
  你是一个严谨的公文写作助手。请根据以下信息，生成符合GB/T 9704-2012的公文内容。
  必须输出为JSON格式，字段定义如下：<span class="hljs-subst">${JSON_SCHEMA}</span>
  
  用户输入：<span class="hljs-subst">${params.topic}</span>
  要求：<span class="hljs-subst">${params.requirements}</span>
  `</span>;
  
  <span class="hljs-keyword">const</span> raw = <span class="hljs-keyword">await</span> llm.<span class="hljs-title function_">generate</span>(structuredPrompt);
  <span class="hljs-keyword">const</span> doc = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(raw);
  
  <span class="hljs-comment">// 规则校验</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateOfficialFormat</span>(doc)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'生成内容不符合公文规范，请重试'</span>);
  }
  
  <span class="hljs-keyword">return</span> doc;
}
</code></pre>
<p><strong>效果：</strong> 生成一份标准通知的时间从人工30分钟缩短到AI 10秒 + 人工审核2分钟，<strong>效率提升90%</strong>。</p>
<hr/>
<h2 data-id="heading-7">第二部分：国产化适配的"踩坑"全记录</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/167b10c864d34b5c985e00c026bbfb87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=cZmP%2BjqFSi63bH9GLxIkXEeK7MI%3D" alt="image.png" loading="lazy"/></p>
<p>如果说AI公文助手是"从0到1的创造"，那国产化适配就是"从能用到好用的磨砺"。</p>
<p>我们的目标是让 <strong>JitWord</strong> 能在<strong>统信UOS</strong>、<strong>麒麟OS</strong>等国产操作系统，以及<strong>360安全浏览器</strong>、<strong>奇安信可信浏览器</strong>等国产Chromium内核浏览器上稳定运行。</p>
<h3 data-id="heading-8">2.1 踩坑一：WebSocket连接的诡异断开</h3>
<p><strong>现象：</strong> 在麒麟V10系统上，协同编辑总是过几分钟就断开，提示"网络异常"，但用户明明能正常刷网页。</p>
<p><strong>排查过程：</strong></p>
<ol>
<li>首先排查Nginx配置，以为是<code>proxy_read_timeout</code>太短，改成3600秒，无效。</li>
<li>检查浏览器Network面板，发现国产浏览器的某些安全策略会<strong>主动断开静默的WebSocket连接</strong>。</li>
<li>最后发现是<strong>奇安信可信浏览器</strong>内置了"长连接保护"策略，超过5分钟没有数据交互就会自动断开。</li>
</ol>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 心跳机制加强版</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReliableWebSocket</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">ws</span>: <span class="hljs-title class_">WebSocket</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">heartbeatInterval</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timer</span>;
  
  <span class="hljs-comment">// 国产浏览器的心跳间隔要更短</span>
  <span class="hljs-keyword">private</span> heartbeatDelay = <span class="hljs-title function_">isDomesticBrowser</span>() ? <span class="hljs-number">10000</span> : <span class="hljs-number">30000</span>; 
  
  <span class="hljs-title function_">connect</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ws</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(url);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 发送空操作或ping帧，保持连接活性</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'heartbeat'</span>, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });
    }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatDelay</span>);
  }
}
</code></pre>
<h3 data-id="heading-9">2.2 踩坑二：富文本编辑器的输入法冲突</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81e820b56dfb4f80a49f33a48b9d9297~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=8oVyUX2qMJJqURsbadkubgoLO3E%3D" alt="协同.png" loading="lazy"/></p>
<p>这是让我最想骂街的坑。</p>
<p><strong>现象：</strong> 在统信UOS + 搜狗输入法（国产版）下，输入中文时，编辑器光标会乱跳，甚至吞字。</p>
<p><strong>根因分析：</strong>
国产操作系统的输入法架构和Windows差异很大。我们用的ProseMirror在处理<code>beforeinput</code>事件时，和一些国产输入法的Composition事件冲突。具体表现为：输入法开始合成（compositionstart）时，ProseMirror尝试更新选区，导致输入法丢失了上下文。</p>
<p><strong>解决方案：</strong>
不得不patch了ProseMirror的view模块，在合成输入期间<strong>暂停所有远程协同更新</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// patches/prosemirror-view.ts</span>
<span class="hljs-keyword">let</span> isComposing = <span class="hljs-literal">false</span>;

editorView.<span class="hljs-property">dom</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'compositionstart'</span>, <span class="hljs-function">() =&gt;</span> {
  isComposing = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 暂停接收远程操作，避免光标跳动</span>
  collaboration.<span class="hljs-title function_">pauseSync</span>();
});

editorView.<span class="hljs-property">dom</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'compositionend'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  isComposing = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> finalData = e.<span class="hljs-property">data</span>;
  
  <span class="hljs-comment">// 延迟恢复同步，等待输入法插入完成</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    collaboration.<span class="hljs-title function_">resumeSync</span>();
  }, <span class="hljs-number">100</span>);
});
</code></pre>
<h3 data-id="heading-10">2.3 踩坑三：字体渲染与导出</h3>
<p><strong>现象：</strong> 同样的"仿宋"，在Windows上叫"仿宋"，在国产系统上可能叫"FangSong"、"Fangsong"、或者"Source Han Serif CN"。公文要求必须用仿宋_GB2312，但这个字体在某些国产系统上没有预装。</p>
<p><strong>解决方案三部曲：</strong></p>
<ol>
<li><strong>前端降级方案</strong>：CSS设置<code>font-family: 'FangSong_GB2312', 'Source Han Serif CN', 'Noto Serif CJK SC', serif;</code></li>
<li><strong>后端字体嵌入</strong>：导出Word时，如果检测目标系统缺少字体，用Java操作POI把字体文件嵌入到生成的docx中</li>
<li><strong>Web字体预加载</strong>：在编辑器初始化时，异步加载WOFF2格式的仿宋字体文件，确保所见即所得</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 导出Word时的字体嵌入逻辑（Java实现）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">embedFonts</span><span class="hljs-params">(XWPFDocument doc, String[] requiredFonts)</span> {
    <span class="hljs-keyword">for</span> (String fontName : requiredFonts) {
        <span class="hljs-keyword">if</span> (!systemHasFont(fontName)) {
            <span class="hljs-type">InputStream</span> <span class="hljs-variable">fontStream</span> <span class="hljs-operator">=</span> getClass().getResourceAsStream(<span class="hljs-string">"/fonts/"</span> + fontName + <span class="hljs-string">".ttf"</span>);
            doc.embedFont(fontName, fontStream);
        }
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-11">性能优化：让国产硬件也能流畅运行</h2>
<p>说实话，很多国产终端的硬件配置（特别是信创笔记本）不如主流Windows本。我们在1个月内做了以下针对性优化：</p>
<h3 data-id="heading-12">虚拟滚动 + 分层渲染</h3>
<p>公文通常很长（几十页很正常），我们在ProseMirror基础上实现了<strong>虚拟滚动</strong>，只渲染可视区域内的DOM节点。同时把静态内容（已经定稿的段落）标记为<code>contenteditable: false</code>，减少MutationObserver的开销。</p>
<h3 data-id="heading-13">AI生成的防抖处理</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50c819b59c114b23ad6a9f4c5c9262e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=hPXZ%2BjQN2bm0AyFTdOWiymRsTsQ%3D" alt="02.gif" loading="lazy"/></p>
<p>当AI生成大段文本时，不能直接一次性插入编辑器（会导致卡顿）。我们改成了<strong>逐句插入 + requestAnimationFrame</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertAIGeneratedContent</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">const</span> sentences = content.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/([。！？])/</span>);  <span class="hljs-comment">// 按句分割</span>
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sentences.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">const</span> sentence = sentences[i] + (sentences[i+<span class="hljs-number">1</span>] || <span class="hljs-string">''</span>);
    
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {
        editor.<span class="hljs-title function_">insertText</span>(sentence);
        <span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>);
      });
    });
    
    <span class="hljs-comment">// 每5句暂停一下，让UI线程喘息</span>
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">10</span>);
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-14">最终效果与场景展示</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7f8d77799e4421faf9ed181c0d61178~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=X8RxFKvtlJ7fbU0n%2FocY3YDX39U%3D" alt="2026-01-15 10.52.12.gif" loading="lazy"/></p>
<h3 data-id="heading-15">公文助手实际应用场景</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8647f345b8fc4ff081a7824a206b87a5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770603516&amp;x-signature=OESMbmwDRP7ot7YAUZOidCFwnX8%3D" alt="jitword-gw.png" loading="lazy"/></p>
<p><strong>场景1：政府机关的请示报告</strong></p>
<ul>
<li>输入："关于申请信息化建设经费的请示"</li>
<li>AI生成：自动匹配"请示"模板，生成红头、发文字号、正文、结尾语</li>
<li>人工调整：只需填写具体金额和项目明细</li>
<li>导出：直接生成符合省级办公厅格式要求的Word文件</li>
</ul>
<p><strong>场景2：国企的发文通知</strong></p>
<ul>
<li>协同：办公室主任起草，分管领导在线批注修改，法务审核合规性</li>
<li>留痕：所有修改记录保存，满足公文归档的审计要求</li>
<li>套红：一键生成带红色抬头的正式公文版式</li>
</ul>
<h3 data-id="heading-16">国产化适配验证环境</h3>
<p>我们在以下环境完成了完整测试：</p>
<ul>
<li><strong>操作系统</strong>：统信UOS 1060、麒麟V10 SP1、中科方德</li>
<li><strong>CPU架构</strong>：x86_64、ARM64（鲲鹏920、飞腾2000）</li>
<li><strong>浏览器</strong>：360安全浏览器v13、奇安信可信浏览器、火狐中国浏览器</li>
</ul>
<hr/>
<h2 data-id="heading-17">技术总结与反思</h2>
<p>这1个月的"双线作战"，最大的收获不是功能本身，而是对<strong>信创环境下的Web开发</strong>有了更深理解：</p>
<ol>
<li>
<p><strong>不要相信浏览器的UserAgent</strong>：国产浏览器都伪装成Chrome，但行为可能完全不同。必须做特性检测（feature detection）而非浏览器嗅探。</p>
</li>
<li>
<p><strong>富文本编辑器要"防御性编程"</strong>：输入法、选区、滚动这些在标准浏览器上稳定的功能，在特殊环境下可能有各种奇奇怪怪的表现。代码要更保守，try-catch要更密集。</p>
</li>
<li>
<p><strong>AI生成必须后接规则校验</strong>：大模型有幻觉，公文又是极其严谨的体裁。AI负责"快"，规则引擎负责"准"，两者结合才能实用。</p>
</li>
<li>
<p><strong>字体和排版是信创隐形大坑</strong>：中西文混排、行高计算、字体回退，这些细节决定了产品看起来是"业余demo"还是"正式产品"。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-18">如何集成和体验？</h2>
<p><strong>JitWord</strong> 目前主要面向<strong>企业级用户</strong>和<strong>开发者集成</strong>。</p>
<ul>
<li><strong>在线演示</strong>：如果你想看看AI公文助手的实际效果，可以访问我们的演示环境（文中不放链接了，掘金私信我或评论获取）</li>
<li><strong>私有化部署</strong>：支持国产服务器私有化部署，适配信创环境</li>
<li><strong>SDK集成</strong>：提供JavaScript SDK，可以Embed到你的业务系统中</li>
</ul>
<p>如果你也是<strong>正在做信创改造的技术负责人</strong>，或者<strong>需要公文处理能力的产品经理</strong>，欢迎评论区交流踩坑经验。国产化这条路，大家互相搀扶才能走得快一点。</p>
<p>我们也开源了一版sdk，大家可以轻松本地使用和集成：</p>
<p>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fjitword-sdk" target="_blank" title="https://github.com/MrXujiang/jitword-sdk" ref="nofollow noopener noreferrer">github.com/MrXujiang/j…</a></p>
<hr/>
<h2 data-id="heading-19">未来规划</h2>
<p>这1个月的攻坚只是开始，接下来的 roadmap 包括：</p>
<ul>
<li><strong>智能校对</strong>：接入NLP模型，自动检查公文中的政治术语准确性、数字逻辑一致性（比如"2024年"不能写成"2024年度"在某些语境下）</li>
<li><strong>手写签批</strong>：对接国产手写板和签章系统，实现移动端批公文</li>
<li><strong>更多公文类型</strong>：从现在的通知、请示、报告，扩展到会议纪要、函、议案等15种法定公文</li>
</ul>
<hr/>
<p><strong>技术栈彩蛋</strong> 🎯</p>
<p>如果你在关注相关技术方向，这是我们用的核心栈，也是目前市面上比较热门的技术方向：</p>
<ul>
<li><strong>Vue3</strong> + <strong>Vite</strong> + <strong>TypeScript</strong>（前端）</li>
<li><strong>NestJS</strong> + <strong>TypeORM</strong>（后端，支持国产数据库适配）🚀</li>
<li><strong>ProseMirror</strong>（编辑器内核，深度定制）</li>
<li><strong>Yjs</strong>（CRDT协同算法）🧩</li>
<li><strong>Docker</strong> + <strong>K8s</strong>（部署）</li>
</ul>
<hr/>
<p>觉得有用的话，点个赞或者收藏吧。信创适配这条路很长，希望这篇文章能帮你少走些弯路。有任何技术问题，评论区留言，我看到都会回复。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[春哥的Agent通关秘籍02：搭建环境及语言选择]]></title>    <link>https://juejin.cn/post/7601419065128239123</link>    <guid>https://juejin.cn/post/7601419065128239123</guid>    <pubDate>2026-02-02T00:07:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601419065128239123" data-draft-id="7601419065128222739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="春哥的Agent通关秘籍02：搭建环境及语言选择"/> <meta itemprop="keywords" content="前端,后端,Python"/> <meta itemprop="datePublished" content="2026-02-02T00:07:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="摸鱼的春哥"/> <meta itemprop="url" content="https://juejin.cn/user/1714893870865303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            春哥的Agent通关秘籍02：搭建环境及语言选择
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893870865303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    摸鱼的春哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:07:51.000Z" title="Mon Feb 02 2026 00:07:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><p>很多想学 AI 开发的朋友，往往倒在了第一步：配环境。</p>
<p>我们要做的不是简单的“安装软件”，而是构建一个专业的数字化工作台。</p>
<p>在这篇文章中，我们将解释为什么 Python 是不二之选，为什么我们需要 Conda，并带你从零开始跑通第一行 AI 代码（以 DeepSeek 为例）。</p>
<h2 data-id="heading-0">一、为什么是 Python</h2>
<p>虽然 Java、Go、JavaScript 也能写 AI 应用，但是。</p>
<p>在 AI Agent 开发领域，Python 是绝对的“第一公民”，它拥有无法撼动的优势：</p>
<ul>
<li>
<p>统治级的生态：几乎所有主流 AI 框架（PyTorch, LangChain, CrewAI）都优先发布 Python 版。</p>
</li>
<li>
<p>胶水语言：Agent 的核心是“连接”——连接大模型、连接 API、连接本地文件。Python 写这种连接逻辑最快。</p>
</li>
<li>
<p>门槛低：它的语法接近英语，让你能把精力集中在“设计智能体逻辑”上，而不是纠结语法细节。</p>
</li>
</ul>
<p>结论：想做 AI Agent，首选 Python。</p>
<p>尤其是学习的话，先学 python，面向最先进最全面的工具链是最优选，等python这块熟悉原理了，再按诉求辐射到自己需要的场景和语言也是非常方便的。</p>
<p><img src="https://pic.zhangshichun.top/pic/20260131131848180.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">二、 为什么要用 Miniconda？</h2>
<p>很多新手会直接去 Python 官网下载安装包，这其实是个“大坑”。</p>
<p>在开发中，我们需要管理各种复杂的库（依赖）。为了防止项目 A 的库和项目 B 的库打架（版本冲突），我们需要 <strong>“虚拟环境”</strong>。</p>
<p>为什么不用 <code>Docker</code> ？</p>
<ul>
<li>Docker虽然隔离性最好，但对初学者来说，操作文件和调试太麻烦，阻碍学习心流。</li>
<li>乱七八糟的环境问题会让初学者信心受挫，容易被打断学习进程。</li>
</ul>
<p><code>Miniconda</code> 有哪些优势？</p>
<p><code>Miniconda</code> 是一个轻量级的环境管理工具。</p>
<ul>
<li>
<p>它可以帮你一键切换 Python 版本（3.10, 3.11, 3.12 随意切）。</p>
</li>
<li>
<p>它能创建独立的“沙盒”，让你随意折腾而不破坏电脑系统。</p>
</li>
<li>
<p>它对文件系统的操作比 <code>docker</code> 方便一万倍，不需要挂载什么<code>volumes</code>映射，对初学者连贯学习更方便。</p>
</li>
</ul>
<p><img src="https://pic.zhangshichun.top/pic/20260131133124958.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">三、 手把手搭建环境</h2>
<h3 data-id="heading-3">第一步：安装 Miniconda及环境变量</h3>
<p>访问 Miniconda 官网 下载对应系统的安装包。地址：<a href="https://link.juejin.cn?target=docs.conda.io%2Fen%2Flatest%2Fminiconda.html" target="_blank" title="docs.conda.io/en/latest/miniconda.html" ref="nofollow noopener noreferrer">docs.conda.io/en/latest/m…</a></p>
<p>安装之后，记得把安装文件夹下<code>condabin</code>目录加入到环境变量里。（针对windows用户哈）</p>
<p>比如我的，就是把 <code>D:\miniconda\condabin</code> 加入到环境变量。</p>
<p><img src="https://pic.zhangshichun.top/pic/20260131155507332.png" alt="" loading="lazy"/></p>
<p>以 <code>cmd</code> 能执行：</p>
<pre><code class="hljs language-bash" lang="bash">conda --version
</code></pre>
<p><img src="https://pic.zhangshichun.top/pic/20260201093046760.png" alt="" loading="lazy"/></p>
<p>输出<code>25.11.1</code>这样的版本号就代表环境变量配置ok。</p>
<h3 data-id="heading-4">第二步：创建 AI 专属环境</h3>
<p>打开你的终端（Windows 用户推荐 PowerShell，Mac 用户用 Terminal），输入以下命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 创建一个名为 ai_agent 的环境，指定使用 Python 3.11（稳定性最佳）</span>
conda create -n ai_agent python=3.11 -y

<span class="hljs-comment"># 2. 激活环境（看到命令行前缀变成 (ai_agent) 即成功）</span>
conda activate ai_agent
</code></pre>
<p>这里 <code>powerShell</code> 可能会遇到一个坑：执行完 <code>conda activate ai_agent</code> 后没反应。</p>
<ul>
<li>
<p>原因：PowerShell 的安全策略默认比较严格，禁止运行未签名的脚本（Conda 的激活脚本本质上是一段 PowerShell 脚本）。</p>
</li>
<li>
<p>解决方法：你需要赋予 PowerShell 执行权限。</p>
<ul>
<li>
<p>以管理员身份打开 PowerShell。</p>
</li>
<li>
<p>运行以下命令：</p>
</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<ul>
<li>输入 Y 确认</li>
<li>重新运行 <code>conda init powershell</code>，然后重启 PowerShell 窗口。</li>
</ul>
</li>
</ul>
<p>分别执行以下代码后：</p>
<pre><code class="hljs language-css" lang="css">conda activate ai_agent
python <span class="hljs-attr">--version</span>
</code></pre>
<p><img src="https://pic.zhangshichun.top/pic/20260201093259212.png" alt="" loading="lazy"/>
如果能成功显示python的版本号代表ok。</p>
<h2 data-id="heading-5">四、接入Deepseek大模型</h2>
<p><code>deepseek</code> 被称为性价比之王。原因在于token单价非常划算，而且对于国内用户来说网络条件支持也是极好的，所以非常适合学习选择。</p>
<p>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2Fusage" target="_blank" title="https://platform.deepseek.com/usage" ref="nofollow noopener noreferrer">platform.deepseek.com/usage</a> 可以非常便捷地完成注册和充值，2-3块钱就足够用很久很久了。</p>
<p>然后在 <code>api keys</code> 页面创建一个 <code>API Key</code>，复制这个key，我们接下来会用到。</p>
<h3 data-id="heading-6">4.1 安装核心库</h3>
<p>随便创建一个学习用的文件夹，在该文件夹里打开命令行，执行以下命令：</p>
<pre><code class="hljs language-bash" lang="bash">conda activate ai_agent
pip install openai python-dotenv pydantic
</code></pre>
<h3 data-id="heading-7">4.2 配置你的key</h3>
<p>永远不要把 API Key 直接写在代码里！ 一旦你不小心截图或把代码上传 GitHub，Key 就会泄露。</p>
<p>我们在项目根目录下创建一个名为 .env 的文件（注意前面有个点），内容如下：</p>
<pre><code class="hljs language-.env" lang=".env"># 这里的 Key 仅作示例，请替换为你自己的
DEEP_SEEK_API_KEY=sk-xxxx
DEEP_SEEK_API_URL=https://api.deepseek.com
</code></pre>
<h3 data-id="heading-8">4.3 3. 编写“Hello World”测试脚本</h3>
<p>新建一个文件 check_env.py，粘贴以下代码。这段代码会自动读取 .env 里的配置来连接 DeepSeek。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI

<span class="hljs-comment"># 1. 加载环境变量</span>
load_dotenv()

<span class="hljs-comment"># 2. 从环境读取配置</span>
api_key = os.getenv(<span class="hljs-string">"DEEP_SEEK_API_KEY"</span>)
base_url = os.getenv(<span class="hljs-string">"DEEP_SEEK_API_URL"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"正在检查环境配置..."</span>)

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> api_key:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 错误：未找到 API KEY，请检查 .env 文件"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># 为了安全，只打印前几位和后几位</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ API Key 读取成功: <span class="hljs-subst">{api_key[:<span class="hljs-number">6</span>]}</span>******<span class="hljs-subst">{api_key[-<span class="hljs-number">4</span>:]}</span>"</span>)

<span class="hljs-comment"># 3. 尝试发起一次真实的对话请求</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># DeepSeek 兼容 OpenAI SDK，只需替换 base_url</span>
    client = OpenAI(api_key=api_key, base_url=base_url)
    
    response = client.chat.completions.create(
        model=<span class="hljs-string">"deepseek-chat"</span>,  <span class="hljs-comment"># DeepSeek 的模型名称</span>
        messages=[
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你是一个有用的AI助手"</span>},
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好，请用一句话证明你已经连接成功了。"</span>},
        ]
    )
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n🎉 连接成功！大模型回复："</span>)
    <span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)
    
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n❌ 连接失败: <span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<h3 data-id="heading-9">4.4 运行验证</h3>
<p>在终端运行：</p>
<pre><code class="hljs">python check_env.py
</code></pre>
<p>如果你看到 “🎉 连接成功！” 以及 DeepSeek 的回复，恭喜你！你已经拥有了一个可以随时调用的 AI 大脑，并且搭建好了专业的 Python 开发环境。
<img src="https://pic.zhangshichun.top/pic/20260201093415136.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">下一步预告</h2>
<p>环境搭好了，只会聊天可不行。</p>
<p>在下一篇 《AI Agent 编程入门 03：结构化输出》 中，我们将学习如何通过 Prompt 工程 和 结构化数据（JSON），强迫 AI 不再“胡言乱语”，而是像程序一样精准输出我们需要的数据格式。</p>
<p>敬请期待！</p>
<p><img src="https://pic.zhangshichun.top/pic/ScreenShot_2026-01-26_082327_821.png" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）]]></title>    <link>https://juejin.cn/post/7601435429409456162</link>    <guid>https://juejin.cn/post/7601435429409456162</guid>    <pubDate>2026-02-02T01:59:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601435429409456162" data-draft-id="7601313474720579619" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）"/> <meta itemprop="keywords" content="IntelliJ IDEA,WebStorm,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T01:59:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="叶落阁主"/> <meta itemprop="url" content="https://juejin.cn/user/2189882891714206"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2189882891714206/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    叶落阁主
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:59:28.000Z" title="Mon Feb 02 2026 01:59:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从模板到实战：写一个 IntelliJ 平台插件（以 I18n Toolkit 为例）</h2>
<p>如果你想为 JetBrains IDE（IntelliJ IDEA、WebStorm、Rider 等）写一个插件，最省心的起点就是官方模板 <code>intellij-platform-plugin-template</code>。本文以开源插件 <strong>I18n Toolkit</strong> 为例，结合真实代码，讲清楚从克隆模板、跑起来，到实现核心功能的完整路径。</p>
<blockquote>
<p>示例仓库：I18n Toolkit（开源）
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyelog%2Fi18n-toolkit" target="_blank" title="https://github.com/yelog/i18n-toolkit" ref="nofollow noopener noreferrer">github.com/yelog/i18n-…</a></p>
<p>模板仓库：IntelliJ Platform Plugin Template
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJetBrains%2Fintellij-platform-plugin-template" target="_blank" title="https://github.com/JetBrains/intellij-platform-plugin-template" ref="nofollow noopener noreferrer">github.com/JetBrains/i…</a></p>
</blockquote>
<hr/>
<h3 data-id="heading-1">一、准备环境</h3>
<p>在插件开发中，IDE 版本、JDK 版本和 Gradle 版本强相关。I18n Toolkit 的约束来自项目配置：</p>
<ul>
<li><strong>JDK</strong>：21</li>
<li><strong>Gradle</strong>：9.2.1（必须使用 <code>./gradlew</code>）</li>
<li><strong>IntelliJ Platform</strong>：2025.2.5</li>
</ul>
<p>建议：<strong>始终使用 Gradle Wrapper</strong>，避免本机 Gradle 版本与项目不一致。</p>
<hr/>
<h3 data-id="heading-2">二、从模板开始：克隆 + 初始化</h3>
<h4 data-id="heading-3">1. 克隆模板</h4>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/JetBrains/intellij-platform-plugin-template
<span class="hljs-built_in">cd</span> intellij-platform-plugin-template
</code></pre>
<h4 data-id="heading-4">2. 初始化项目信息</h4>
<p>你需要修改几个关键文件：</p>
<ul>
<li><code>settings.gradle.kts</code>：项目名称</li>
<li><code>gradle.properties</code>：插件名、版本、ID、平台版本等</li>
<li><code>src/main/resources/META-INF/plugin.xml</code>：插件 ID、名称、描述、扩展点</li>
<li><code>README.md</code>：保留 <code>&lt;!-- Plugin description --&gt;</code> 标记区域</li>
</ul>
<p>模板自带脚本也能一键替换变量，但手工改更直观。</p>
<h4 data-id="heading-5">3. 启动开发 IDE</h4>
<pre><code class="hljs language-bash" lang="bash">./gradlew runIde
</code></pre>
<p>此命令会启动一个 <strong>IDE 沙箱环境</strong>，插件会自动加载在这个测试 IDE 中。</p>
<hr/>
<h3 data-id="heading-6">三、项目结构速览</h3>
<p>插件主要结构是固定的：</p>
<pre><code class="hljs language-bash" lang="bash">src/
├── main/
│   ├── kotlin/…                 <span class="hljs-comment"># Kotlin 源码</span>
│   └── resources/
│       └── META-INF/plugin.xml  <span class="hljs-comment"># 插件描述文件</span>
└── <span class="hljs-built_in">test</span>/                         <span class="hljs-comment"># 测试</span>
</code></pre>
<p>I18n Toolkit 的代码划分更细，按功能分包：</p>
<ul>
<li><code>service/</code>：缓存与核心数据</li>
<li><code>scanner/</code>：翻译文件扫描</li>
<li><code>parser/</code>：多格式解析</li>
<li><code>completion/</code> / <code>annotator/</code> / <code>reference/</code>：补全、诊断、导航</li>
<li><code>searcheverywhere/</code> / <code>statusbar/</code>：搜索与状态栏</li>
</ul>
<p>这样的结构非常适合插件类项目：入口清晰、扩展点映射明确。</p>
<hr/>
<h3 data-id="heading-7">四、核心功能如何实现：I18n Toolkit 代码拆解</h3>
<p>下面从核心功能视角，拆解这款插件的实现方式，并补充关键类与关键流程的实现细节，方便你对 IntelliJ 平台 API 的落点有更清晰的映射。</p>
<h4 data-id="heading-8">0. 启动与更新链路：ProjectActivity + VFS 监听</h4>
<p>插件运行期的“数据生命周期”由两条链路保证稳定：</p>
<ul>
<li><strong>启动初始化</strong>：<code>I18nProjectActivity</code> 实现 <code>ProjectActivity</code>，在项目打开时初始化缓存；同时替换 <code>QuickJavaDoc</code> Action，确保 i18n key 悬停/快捷文档体验一致。</li>
<li><strong>动态加载</strong>：<code>I18nDynamicPluginListener</code> 支持插件动态加载/卸载，无需重启 IDE；加载时对所有已打开项目初始化缓存并刷新 UI。</li>
<li><strong>VFS 变更监听</strong>：<code>I18nFileListener</code> 基于 <code>AsyncFileListener</code> 监听创建/修改/删除/移动/复制事件，仅处理 i18n 翻译文件，触发 <code>I18nCacheService.invalidateFile()</code> → <code>refresh()</code> → <code>I18nUiRefresher.refresh()</code> 的刷新链路。</li>
</ul>
<p>示例代码（启动与监听）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">I18nProjectActivity</span> : <span class="hljs-type">ProjectActivity</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> {
        I18nCacheService.getInstance(project).initialize()
        installQuickDocOverride()
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">I18nFileListener</span> : <span class="hljs-type">AsyncFileListener</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prepareChange</span><span class="hljs-params">(events: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">VFileEvent</span>&gt;)</span></span>: AsyncFileListener.ChangeApplier? {
        <span class="hljs-keyword">val</span> relevantEvents = events.filter { e -&gt;
            <span class="hljs-keyword">val</span> file = e.file ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> <span class="hljs-literal">false</span>
            e <span class="hljs-keyword">is</span> VFileContentChangeEvent || e <span class="hljs-keyword">is</span> VFileCreateEvent ||
                e <span class="hljs-keyword">is</span> VFileDeleteEvent || e <span class="hljs-keyword">is</span> VFileMoveEvent || e <span class="hljs-keyword">is</span> VFileCopyEvent
        }.filter { e -&gt; e.file?.let(I18nDirectoryScanner::isTranslationFile) == <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">if</span> (relevantEvents.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : AsyncFileListener.ChangeApplier {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterVfsChange</span><span class="hljs-params">()</span></span> {
                ProjectManager.getInstance().openProjects.forEach { project -&gt;
                    relevantEvents.forEach { it.file?.let { f -&gt;
                        I18nCacheService.getInstance(project).invalidateFile(f)
                    } }
                }
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-9">1. 统一缓存中心：I18nCacheService</h4>
<p>插件需要频繁获取翻译数据，<strong>缓存服务</strong>是第一优先级：</p>
<ul>
<li>项目启动时初始化</li>
<li>扫描目录 → 解析文件 → 生成 TranslationData</li>
<li>提供 API：按 key 查找、按语言过滤、查找所有翻译</li>
<li>文件变更时刷新缓存并刷新 UI</li>
</ul>
<p>这让补全、导航、搜索等功能都能基于同一份数据源。</p>
<p>实现细节补充：</p>
<ul>
<li><code>initialize()</code> 用 <code>initialized</code> 标记避免重复初始化，实际核心逻辑在 <code>refresh()</code>。</li>
<li><code>refresh()</code> 包裹在 <code>ReadAction.compute</code> 中，确保 PSI 读取安全；同时维护 <code>keyToFiles</code> 方便后续 quick fix 快速定位。</li>
<li><code>TranslationData</code> 内部结构是 <code>key -&gt; locale -&gt; TranslationEntry</code>，并提供 <code>getTranslation()</code> 默认回退策略（<code>zh_CN</code> → <code>zh</code> → <code>en</code> → 首个可用值）。</li>
<li><code>getTranslationStrict()</code> 基于 <code>I18nLocaleUtils.buildLocaleCandidates()</code> 进行严格 locale 匹配，不做全局回退。</li>
</ul>
<p>示例代码（缓存刷新核心流程）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> translationFiles = I18nDirectoryScanner.scanForTranslationFiles(project)
    keyToFiles.clear()
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = ReadAction.compute&lt;TranslationData, RuntimeException&gt; {
        <span class="hljs-keyword">val</span> result = TranslationData(I18nFrameworkDetector.detect(project))
        translationFiles.forEach { file -&gt;
            <span class="hljs-keyword">val</span> pathInfo = I18nKeyGenerator.parseFilePath(file, project.basePath ?: <span class="hljs-string">""</span>)
            <span class="hljs-keyword">val</span> entries = TranslationFileParser.parse(project, file, pathInfo.keyPrefix, pathInfo.locale)
            entries.forEach { (key, entry) -&gt;
                result.addEntry(entry)
                keyToFiles.getOrPut(key) { mutableSetOf() }.add(entry)
            }
        }
        result
    }
    translationData = <span class="hljs-keyword">data</span>
}
</code></pre>
<h4 data-id="heading-10">2. 目录扫描：I18nDirectoryScanner</h4>
<p>扫描逻辑有两个重点：</p>
<ul>
<li>只扫描标准 i18n 目录：<code>locales</code> / <code>i18n</code> / <code>messages</code> / <code>lang</code> 等</li>
<li>排除目录：<code>node_modules</code>、<code>dist</code>、<code>build</code>、隐藏目录</li>
</ul>
<p>这样可以有效避免无关文件的解析成本。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nDirectories.STANDARD_DIRS</code> 维护标准目录白名单；扫描使用 <code>VfsUtil.iterateChildrenRecursively</code>。</li>
<li>目录过滤逻辑同时跳过隐藏目录（以 <code>.</code> 开头）以及 <code>node_modules</code>、<code>dist</code>、<code>build</code>。</li>
<li>识别文件类型来自 <code>TranslationFileType</code>，支持 <code>json/yaml/yml/toml/js/mjs/cjs/ts/mts/cts/properties</code>。</li>
</ul>
<p>示例代码（扫描与类型识别）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> I18nDirectoryScanner {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> excludedDirNames = setOf(<span class="hljs-string">"node_modules"</span>, <span class="hljs-string">"dist"</span>, <span class="hljs-string">"build"</span>)
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scanForTranslationFiles</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span>: List&lt;VirtualFile&gt; {
        <span class="hljs-keyword">val</span> baseDir = project.guessProjectDir() ?: <span class="hljs-keyword">return</span> emptyList()
        <span class="hljs-keyword">val</span> translationFiles = mutableListOf&lt;VirtualFile&gt;()
        findI18nDirectories(baseDir).forEach { dir -&gt;
            VfsUtil.iterateChildrenRecursively(dir, ::shouldTraverse) { file -&gt;
                <span class="hljs-keyword">val</span> ext = file.extension?.lowercase()
                <span class="hljs-keyword">if</span> (!file.isDirectory &amp;&amp; ext <span class="hljs-keyword">in</span> TranslationFileType.allExtensions()) {
                    translationFiles.add(file)
                }
                <span class="hljs-literal">true</span>
            }
        }
        <span class="hljs-keyword">return</span> translationFiles
    }
}
</code></pre>
<h4 data-id="heading-11">3. 多格式解析：TranslationFileParser</h4>
<p>插件支持：</p>
<ul>
<li>JSON / YAML / TOML</li>
<li>Properties</li>
<li>JS / TS（对象字面量）</li>
</ul>
<p>解析方式是“<strong>尽可能利用 PSI</strong>”：</p>
<ul>
<li>JSON / JS / TS：走 PSI 结构，能拿到精确 offset</li>
<li>YAML / TOML：用第三方 parser，offset 为估算值</li>
</ul>
<p>这解释了为什么 YAML / TOML 的定位可能稍有偏差，但实际效果可接受。</p>
<p>实现细节补充：</p>
<ul>
<li><strong>JSON</strong>：用 <code>JsonFile</code> / <code>JsonObject</code> 递归解析，<code>TranslationEntry.offset</code> 精确定位到 key 的 <code>textOffset</code>。</li>
<li><strong>JS/TS</strong>：解析 <code>export default</code>、变量声明与表达式语句，提取对象字面量中的字符串值。</li>
<li><strong>YAML/TOML</strong>：使用 SnakeYAML / toml4j 解析结构，offset 通过累加长度估算。</li>
<li><strong>Properties</strong>：按行扫描 <code>key=value</code>，过滤注释行并记录行内 offset。</li>
</ul>
<p>示例代码（JSON / JS/TS 解析片段）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseJsonObject</span><span class="hljs-params">(obj: <span class="hljs-type">JsonObject</span>, prefix: <span class="hljs-type">String</span>, locale: <span class="hljs-type">String</span>, file: <span class="hljs-type">VirtualFile</span>, <span class="hljs-keyword">out</span>: <span class="hljs-type">MutableMap</span>&lt;<span class="hljs-type">String</span>, TranslationEntry&gt;)</span></span> {
    obj.propertyList.forEach { prop -&gt;
        <span class="hljs-keyword">val</span> key = prop.name
        <span class="hljs-keyword">val</span> fullKey = <span class="hljs-keyword">if</span> (prefix.isEmpty()) key <span class="hljs-keyword">else</span> <span class="hljs-string">"<span class="hljs-variable">$prefix</span><span class="hljs-variable">$key</span>"</span>
        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> value = prop.value) {
            <span class="hljs-keyword">is</span> JsonStringLiteral -&gt; <span class="hljs-keyword">out</span>[fullKey] = TranslationEntry(fullKey, value.value, locale, file, prop.nameElement.textOffset, prop.nameElement.textLength)
            <span class="hljs-keyword">is</span> JsonObject -&gt; parseJsonObject(value, <span class="hljs-string">"<span class="hljs-variable">$fullKey</span>."</span>, locale, file, <span class="hljs-keyword">out</span>)
        }
    }
}

<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseJsExpression</span><span class="hljs-params">(expr: <span class="hljs-type">JSExpression</span>?, prefix: <span class="hljs-type">String</span>, locale: <span class="hljs-type">String</span>, file: <span class="hljs-type">VirtualFile</span>, <span class="hljs-keyword">out</span>: <span class="hljs-type">MutableMap</span>&lt;<span class="hljs-type">String</span>, TranslationEntry&gt;)</span></span> {
    <span class="hljs-keyword">if</span> (expr <span class="hljs-keyword">is</span> JSObjectLiteralExpression) {
        expr.properties.forEach { prop -&gt;
            <span class="hljs-keyword">val</span> key = prop.name ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span>
            <span class="hljs-keyword">val</span> fullKey = <span class="hljs-keyword">if</span> (prefix.isEmpty()) key <span class="hljs-keyword">else</span> <span class="hljs-string">"<span class="hljs-variable">$prefix</span><span class="hljs-variable">$key</span>"</span>
            <span class="hljs-keyword">val</span> value = prop.value <span class="hljs-keyword">as</span>? JSLiteralExpression
            value?.stringValue?.let { <span class="hljs-keyword">out</span>[fullKey] = TranslationEntry(fullKey, it, locale, file, prop.textOffset, key.length) }
        }
    }
}
</code></pre>
<h4 data-id="heading-12">4. Key 前缀生成：I18nKeyGenerator</h4>
<p>i18n 目录结构通常体现模块或业务层级，例如：</p>
<pre><code class="hljs language-bash" lang="bash">src/views/mes/locales/lang/zh_CN/order.ts
</code></pre>
<p>插件通过路径自动推导：</p>
<ul>
<li>locale：<code>zh_CN</code></li>
<li>keyPrefix：<code>mes.order.</code></li>
</ul>
<p>这样在代码里写 <code>t('create')</code>，也能正确定位到 <code>mes.order.create</code>。</p>
<p>实现细节补充：</p>
<ul>
<li><code>parseFilePath()</code> 区分 <strong>views 模式</strong> 与 <strong>标准模式</strong>：views 模式会把业务单元与模块组合为前缀。</li>
<li>对 <code>message/messages</code> 目录进行特殊处理：避免把它作为 module 前缀（常见于 Spring Message）。</li>
<li>当路径里找不到 locale 时，会回退到文件名判断 locale。</li>
</ul>
<p>示例代码（路径解析与前缀生成）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseFilePath</span><span class="hljs-params">(file: <span class="hljs-type">VirtualFile</span>, projectBasePath: <span class="hljs-type">String</span>)</span></span>: PathInfo {
    <span class="hljs-keyword">val</span> relativePath = file.path.removePrefix(projectBasePath).removePrefix(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">val</span> parts = relativePath.split(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">val</span> fileName = file.nameWithoutExtension
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        isViewsLocalePattern(parts) -&gt; parseViewsLocalePattern(parts, fileName)
        isStandardLocalePattern(parts) -&gt; parseStandardLocalePattern(parts, fileName)
        <span class="hljs-keyword">else</span> -&gt; PathInfo(locale = extractLocale(parts, fileName), module = <span class="hljs-literal">null</span>, businessUnit = <span class="hljs-literal">null</span>, keyPrefix = <span class="hljs-string">""</span>)
    }
}
</code></pre>
<h4 data-id="heading-13">5. 框架检测：I18nFrameworkDetector</h4>
<p>插件会自动识别 i18n 框架：</p>
<ul>
<li>vue-i18n</li>
<li>react-i18next</li>
<li>next-intl</li>
<li>@nuxtjs/i18n</li>
<li>react-intl</li>
<li>Spring Message（检测 <code>pom.xml</code> 或 <code>build.gradle</code>）</li>
</ul>
<p>如果识别成功，可自动决定语义规则和函数习惯，减少配置。</p>
<p>实现细节补充：</p>
<ul>
<li><strong>Spring 检测</strong>：直接读取 <code>pom.xml</code> / <code>build.gradle(.kts)</code> 文本，判断关键依赖字符串。</li>
<li><strong>JS/TS 检测</strong>：通过 PSI 解析 <code>package.json</code>，遍历 <code>dependencies / devDependencies / peerDependencies</code>。</li>
</ul>
<p>示例代码（依赖检测）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parsePackageJson</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>, file: <span class="hljs-type">VirtualFile</span>)</span></span>: I18nFramework {
    <span class="hljs-keyword">val</span> psiFile = PsiManager.getInstance(project).findFile(file) <span class="hljs-keyword">as</span>? JsonFile ?: <span class="hljs-keyword">return</span> I18nFramework.UNKNOWN
    <span class="hljs-keyword">val</span> rootObject = psiFile.topLevelValue <span class="hljs-keyword">as</span>? JsonObject ?: <span class="hljs-keyword">return</span> I18nFramework.UNKNOWN
    <span class="hljs-keyword">val</span> deps = mutableSetOf&lt;String&gt;()
    listOf(<span class="hljs-string">"dependencies"</span>, <span class="hljs-string">"devDependencies"</span>, <span class="hljs-string">"peerDependencies"</span>).forEach { depType -&gt;
        (rootObject.findProperty(depType)?.value <span class="hljs-keyword">as</span>? JsonObject)?.propertyList?.forEach { deps.add(it.name) }
    }
    <span class="hljs-keyword">return</span> I18N_PACKAGES.firstOrNull { deps.contains(it) }?.let(I18nFramework::fromPackageName) ?: I18nFramework.UNKNOWN
}
</code></pre>
<h4 data-id="heading-14">6. Inlay 提示：I18nInlayHintsProvider</h4>
<p>这类体验是插件“可感知度”最高的部分：</p>
<ul>
<li>在 <code>t('key')</code> 后面显示翻译内容</li>
<li>支持 Vue template 的注入代码</li>
<li>缓存已处理位置，避免重复插入</li>
<li>可设置为“仅显示翻译”或“key + 翻译”模式</li>
</ul>
<p>这套逻辑结合了 PSI + Inlay API + InjectedLanguageManager。</p>
<p>实现细节补充：</p>
<ul>
<li><code>globalProcessedHints</code> 以 <code>filePath:modStamp:offset</code> 为 key 去重，避免多语言实例重复插入提示。</li>
<li>Vue 模板插值中的 <code>{{ t('key') }}</code> 使用 <code>InjectedLanguageManager</code> 处理 injected PSI。</li>
<li>先用 <code>I18nNamespaceResolver.getFullKey()</code> 拼接命名空间，再做翻译匹配。</li>
<li>若显示语言存在但缺失该 key，会显示 <code>Missing translation for 'locale'</code> 的提示文案。</li>
</ul>
<p>示例代码（Inlay 去重与渲染）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> hintKey = <span class="hljs-string">"<span class="hljs-variable">$filePath</span>:<span class="hljs-variable">$modStamp</span>:<span class="hljs-variable">$offset</span>"</span>
<span class="hljs-keyword">if</span> (globalProcessedHints.putIfAbsent(hintKey, <span class="hljs-literal">true</span>) != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>

<span class="hljs-keyword">val</span> presentation = factory.roundWithBackground(
    factory.smallText(<span class="hljs-string">" → <span class="hljs-variable">$translationText</span>"</span>)
)
sink.addInlineElement(offset, <span class="hljs-literal">true</span>, presentation, <span class="hljs-literal">false</span>)
</code></pre>
<h4 data-id="heading-15">7. 缺失 Key 诊断 + 快速修复</h4>
<p>缺失 key 会被标红，并提供一键创建：</p>
<ul>
<li><code>I18nKeyAnnotator</code> 负责提示错误</li>
<li><code>CreateI18nKeyQuickFix</code> 根据 key 自动选择目标文件</li>
<li>支持 JSON / JS / TS / Properties 直接写入</li>
</ul>
<p>尤其是“根据 key 前缀和兄弟 key 自动选择文件”的逻辑，极大提升了体验。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nKeyAnnotator</code> 使用 <code>I18nFunctionResolver</code> 获取可配置的 i18n 函数名（默认 <code>t/$t/i18n/translate/...</code>）。</li>
<li>只高亮字符串内容本身（排除引号），并挂载 <code>CreateI18nKeyQuickFix</code>。</li>
<li><code>CreateI18nKeyQuickFix</code> 先尝试 <strong>最长前缀匹配</strong>，失败后再用 <strong>兄弟 key</strong> 反推文件。</li>
<li>实际写入通过 <code>WriteCommandAction</code> + PSI 操作完成，写入后用 <code>OpenFileDescriptor</code> 定位并把光标放在引号之间。</li>
</ul>
<p>示例代码（缺失 Key 高亮范围）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> elementRange = literalExpr.textRange
<span class="hljs-keyword">val</span> keyStartOffset = elementRange.startOffset + <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> keyEndOffset = keyStartOffset + partialKey.length
<span class="hljs-keyword">val</span> highlightRange = TextRange(keyStartOffset, keyEndOffset)
holder.newAnnotation(HighlightSeverity.ERROR, <span class="hljs-string">"Unresolved i18n key: '<span class="hljs-variable">$fullKey</span>'"</span>)
    .range(highlightRange)
    .textAttributes(DefaultLanguageHighlighterColors.INVALID_STRING_ESCAPE)
    .withFix(CreateI18nKeyQuickFix(fullKey))
    .create()
</code></pre>
<h4 data-id="heading-16">8. Search Everywhere 集成</h4>
<p>插件在 Search Everywhere 中新增 <strong>I18n</strong> 标签：</p>
<ul>
<li>key 和翻译都支持模糊搜索</li>
<li>Enter：复制 key</li>
<li>Ctrl+Enter：跳转到翻译文件</li>
<li>结果排序有评分策略（前缀匹配 &gt; 包含匹配）</li>
</ul>
<p>这让翻译搜索真正成为“IDE 级别”的能力。</p>
<p>实现细节补充：</p>
<ul>
<li>搜索结果以 “key + 多语言翻译” 合并为一个条目。</li>
<li>评分策略在 <code>calculateMatchScore()</code> 中实现：前缀匹配最高，其次是包含匹配与 value 匹配。</li>
<li>Enter 复制 key，Ctrl+Enter 直接打开翻译文件，行为明确且稳定。</li>
</ul>
<p>示例代码（搜索评分片段）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateMatchScore</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, entries: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">TranslationEntry</span>&gt;, tokens: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;, compactQuery: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">val</span> keyLower = key.lowercase()
    <span class="hljs-keyword">val</span> keyMatchesAll = tokens.isNotEmpty() &amp;&amp; tokens.all { keyLower.contains(it) }
    <span class="hljs-keyword">var</span> score = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> (keyMatchesAll) score += <span class="hljs-number">100</span>
    <span class="hljs-keyword">if</span> (tokens.isNotEmpty() &amp;&amp; keyLower.startsWith(tokens.first())) score += <span class="hljs-number">1000</span>
    <span class="hljs-keyword">return</span> score
}
</code></pre>
<h4 data-id="heading-17">9. 状态栏语言切换 + 翻译编辑</h4>
<ul>
<li>状态栏小部件支持显示与切换当前语言</li>
<li>翻译弹窗支持多语言编辑，并可实时写入文件</li>
</ul>
<p>这些 UI 功能用到 <code>StatusBarWidget</code> 和 <code>JBPopupFactory</code>，是典型插件 UI 技术。</p>
<p>实现细节补充：</p>
<ul>
<li><code>I18nStatusBarWidget</code> 通过 <code>ListPopup</code> 提供语言列表与“Go to Settings”入口，切换语言后触发 UI refresh。</li>
<li><code>I18nTranslationEditPopup</code> 使用 <code>Alarm</code> 做 300ms 防抖，编辑后实时写回文件。</li>
<li><code>I18nTranslationWriter</code> 根据文件类型分别替换 JSON/JS/Properties 内容，并处理引号与转义。</li>
</ul>
<p>示例代码（状态栏切换与写回）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> step = <span class="hljs-keyword">object</span> : BaseListPopupStep&lt;PopupItem&gt;(<span class="hljs-string">"I18n Toolkit"</span>, allItems) {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChosen</span><span class="hljs-params">(selectedValue: <span class="hljs-type">PopupItem</span>?, finalChoice: <span class="hljs-type">Boolean</span>)</span></span>: PopupStep&lt;*&gt;? {
        <span class="hljs-keyword">if</span> (selectedValue <span class="hljs-keyword">is</span> PopupItem.LocaleItem) {
            settings.state.displayLocale = selectedValue.locale
            I18nUiRefresher.refresh(project)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onChosen(selectedValue, finalChoice)
    }
}

WriteCommandAction.runWriteCommandAction(project, <span class="hljs-string">"Update i18n Translation"</span>, <span class="hljs-literal">null</span>, Runnable {
    <span class="hljs-keyword">val</span> document = FileDocumentManager.getInstance().getDocument(entry.file) ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@Runnable</span>
    document.replaceString(valueStart, lineEnd, newValue)
})
</code></pre>
<hr/>
<h3 data-id="heading-18">五、插件功能如何挂载：plugin.xml 扩展点</h3>
<p>所有功能都需要通过 <code>plugin.xml</code> 注册：</p>
<ul>
<li><code>projectService</code>：缓存服务</li>
<li><code>inlayProvider</code>：内联提示</li>
<li><code>annotator</code>：错误提示</li>
<li><code>completion.contributor</code>：补全</li>
<li><code>psi.referenceContributor</code>：导航</li>
<li><code>searchEverywhereContributor</code>：搜索</li>
<li><code>statusBarWidgetFactory</code>：状态栏</li>
</ul>
<p>这里是 IntelliJ 平台插件开发的核心：</p>
<blockquote>
<p><strong>一切功能都是“扩展点 + 实现类”的组合。</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-19">六、构建、测试与发布</h3>
<p>常用命令：</p>
<pre><code class="hljs language-bash" lang="bash">./gradlew runIde          <span class="hljs-comment"># 本地运行</span>
./gradlew buildPlugin     <span class="hljs-comment"># 构建分发包</span>
./gradlew <span class="hljs-built_in">test</span>            <span class="hljs-comment"># 运行测试</span>
./gradlew check           <span class="hljs-comment"># 测试 + 覆盖率</span>
./gradlew verifyPlugin    <span class="hljs-comment"># 插件兼容性验证</span>
</code></pre>
<p>如果要发布到 JetBrains Marketplace，补齐签名配置即可。</p>
<hr/>
<h3 data-id="heading-20">七、总结：从模板到可用插件的关键路径</h3>
<p><strong>模板给你骨架，真正的价值来自你的“功能设计”与“用户体验”。</strong></p>
<p>I18n Toolkit 的实现告诉我们：</p>
<ul>
<li>缓存与解析是插件性能的核心</li>
<li>IntelliJ 扩展点体系决定功能边界</li>
<li>体验要足够“IDE 级”，才能真正提升开发效率</li>
</ul>
<p>如果你也想写一个生产力插件，不妨从这个开源项目入手，读一遍核心类，跑一遍 <code>runIde</code>，就能快速进入实战状态。</p>
<hr/>
<p>如果你对该插件感兴趣或想参与贡献：</p>
<ul>
<li>模板项目：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJetBrains%2Fintellij-platform-plugin-template" target="_blank" title="https://github.com/JetBrains/intellij-platform-plugin-template" ref="nofollow noopener noreferrer">github.com/JetBrains/i…</a></li>
<li>插件仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyelog%2Fi18n-toolkit" target="_blank" title="https://github.com/yelog/i18n-toolkit" ref="nofollow noopener noreferrer">github.com/yelog/i18n-…</a></li>
</ul>
<p>祝你玩得开心，写出属于自己的 JetBrains 插件！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[速通-微信小程序]]></title>    <link>https://juejin.cn/post/7601822421609889819</link>    <guid>https://juejin.cn/post/7601822421609889819</guid>    <pubDate>2026-02-02T08:07:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601822421609889819" data-draft-id="7602069205467185198" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="速通-微信小程序"/> <meta itemprop="keywords" content="前端,微信小程序,微信"/> <meta itemprop="datePublished" content="2026-02-02T08:07:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="慈様ya"/> <meta itemprop="url" content="https://juejin.cn/user/3281384295639245"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            速通-微信小程序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3281384295639245/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    慈様ya
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T08:07:47.000Z" title="Mon Feb 02 2026 08:07:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">速通-微信小程序🟢</h2>
<p>2026年1月，最近又空闲了，没错我 <code>叒叒</code> 没有工作了，最近一段时间好迷茫啊，</p>
<p>因为学历问题，外面大城市不好找工作(没有面试机会)，这个三线小城市基本上本人面试成功率80%</p>
<p>目前小地方公司，又出现发不起工资的情况，所以 ………… 种种原因，后面还是要计划，出去找一下！</p>
<p><strong>正好，</strong> 最近就利用空闲时间学习一下 <code>微信小程序吧！</code> 总不能一直摸鱼，玩到过年吧，blog 也好久没🆙🆙🆙</p>
<ul>
<li>一方面，是因为AI 的出现，不得不说，AI真的很厉害，任何问题都能轻松的解决，省去了很多时间！</li>
<li>另一方面，最近在准备自考相关的学历提升，工作，生活，等后面，写个年总吧……</li>
</ul>
<p><strong>运气不错，</strong> 最近有幸接了一个私活，<code>WX小程序相关的</code> 仔细想想，也是小程序</p>
<ul>
<li>更方便，被大众市场需求，能接到更多需求，觉得是一个方向，对于个体开发者！！开始学习！！！</li>
</ul>
<hr/>
<p><strong>本篇文章及后续学习参考：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1834y1676P%3Fspm_id_from%3D333.788.videopod.episodes%26vd_source%3D19e007a1660dfd5c8f1744e56d027bf4%26p%3D2" target="_blank" title="https://www.bilibili.com/video/BV1834y1676P?spm_id_from=333.788.videopod.episodes&amp;vd_source=19e007a1660dfd5c8f1744e56d027bf4&amp;p=2" ref="nofollow noopener noreferrer">黑马—微信小程序简介</a></p>
<h2 data-id="heading-1">WX小程序-简介</h2>
<p><strong>小程序与普通网页开发的区别：</strong></p>
<p><strong>运行环境不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：运行在 Chrome 等浏览器内核中，</p>
<p>依赖完整的 DOM（文档对象模型）和 BOM（浏览器对象模型）</p>
<p>跨浏览器兼容性是核心痛点（比如不同浏览器对 CSS 属性的支持差异）</p>
</li>
<li>
<p><strong>小程序</strong>：运行在微信内置的双线程环境，无 DOM/BOM，</p>
<p>所有能力由微信桥接层提供，兼容性完全由微信保障，无需适配多浏览器</p>
</li>
</ul>
<p><strong>开发模式不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：可调用浏览器提供的 DOM/BOM API</p>
<p>如：<code>document.getElementById</code>、<code>window.location</code>，也能使用前端框架的API</p>
</li>
<li>
<p><strong>小程序</strong>：<strong>完全禁止 DOM/BOM API</strong>，只能使用微信专属 API</p>
<p>如：<code>wx.request</code>发起网络请求、<code>wx.scanCode</code>调用扫码、<code>wx.pay</code>发起支付</p>
<p>这些 API 直接对接微信生态能力，体验接近原生 App，<code>小程序开发需要熟悉微信 API 文档</code>；</p>
</li>
</ul>
<p><strong>API 不同：</strong></p>
<ul>
<li>
<p><strong>普通网页</strong>：开发工具仅需 <code>浏览器 + 代码编辑器 如 VS Code</code></p>
<p>调试用浏览器 F12，上线只需将文件上传至服务器，无平台审核；</p>
</li>
<li>
<p><strong>小程序</strong>：必须遵循微信的标准流程：</p>
<p>申请小程序开发账号、安装微信开发者工具、</p>
<p>创建并配置小程序项目创建并配置小程序项目、</p>
<p>调试依赖开发者工具的模拟器 / 真机预览，上线需经过微信平台审核(1-3 个工作日)</p>
</li>
</ul>
<p><strong>🧊体验小程序：</strong> 可使用手机微信(6.7.2 及以上版本)扫码下方小程序码，体验小程序，相关组件模块：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fi-blog.csdnimg.cn%2Fdirect%2Fa6360f35808e4d6f919e03315f1e500c.png" target="_blank" title="https://i-blog.csdnimg.cn/direct/a6360f35808e4d6f919e03315f1e500c.png" ref="nofollow noopener noreferrer">i-blog.csdnimg.cn/direct/a636…</a></p>
<h2 data-id="heading-2">第一个微信小程序：</h2>
<h3 data-id="heading-3">注册小程序开发账号：</h3>
<p>使用浏览器打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2F" target="_blank" title="https://mp.weixin.qq.com/" ref="nofollow noopener noreferrer">mp.weixin.qq.com/</a> 网址，</p>
<p>点击右上角的“<strong>立即注册</strong>”即可进入到小程序开发账号的注册流程，<strong>此处就不详细介绍：</strong></p>
<ul>
<li>
<p><strong>选择注册账号的类型：</strong> 小程序；</p>
</li>
<li>
<p><strong>填写账号信息，邮箱注册：</strong> 注意，每个邮箱仅可以申请一个小程序！<code>邮箱认证！</code></p>
</li>
<li>
<p><strong>选择小程序主体类型：信息登记</strong>  按需求填写即可，学习阶段建议：<code>中国大陆</code> / <code>个人</code></p>
<p>个人与企业主体的差异直接决定了小程序的 <strong>功能权限、审核难度、法律责任和商业变现能力</strong></p>
</li>
</ul>
<p>个人主体：仅需 <strong>身份证 + 微信实名认证</strong>，无需营业执照，流程 5 分钟完成，<strong>限制多</strong>：</p>
<ul>
<li>不可开通 <strong>微信支付、云开发、敏感接口</strong> <code>如手机号快速验证、unionID</code>  等…………</li>
<li>仅 1 个管理员账号，同一身份证最多注册 <strong>5 个</strong> 小程序</li>
</ul>
<p>企业主体：需 <strong>营业执照 + 法人身份证 + 对公账户 / 法人微信认证</strong>，</p>
<ul>
<li>部分行业需行业资质，如<code>食品</code>、<code>医疗</code>， <strong>全功能、审核严格</strong>，同一企业最多注册 <strong>50 个</strong> 小程序；</li>
</ul>
<hr/>
<p><strong>获取小程序APPID：</strong> 🆗经过上面的操作，已经成功注册了小程序账号，接下来：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2F" target="_blank" title="https://mp.weixin.qq.com/" ref="nofollow noopener noreferrer">⌨️登录，微信公众平台</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84e2c730ef1f456ab47a96dffb05bdf8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=K%2Besir5sRwNUfUf3jOeFIeh9Xd4%3D" alt="image-20260129153600067.png" loading="lazy"/>
<strong>开发与服务——开发设置：</strong> 时间推移，可能会有所变化，影响不大！</p>
<p><strong>AppID 小程序唯一标识：</strong></p>
<p>AppID 是微信给每个小程序分配的<strong>全球唯一字符串</strong></p>
<p>如 <code>wx8407df8e55ebb60d</code> 相当于小程序的 “身份证号”，<strong>公开可暴露</strong></p>
<ul>
<li>
<p><strong>新建项目必备</strong>：在微信开发者工具中创建项目时，必须填入 AppID，</p>
<p>工具会根据 AppID 关联对应的小程序账号，区分<strong>测试号</strong>和<strong>正式号</strong>，加载对应的权限与配置</p>
</li>
<li>
<p><strong>微信生态唯一标识</strong>：小程序调用微信所有 API 如：扫码、定位、登录时，</p>
<p>必须携带 AppID，微信服务器通过 AppID 识别 “是哪个小程序在请求”</p>
</li>
</ul>
<p><strong>AppSecret 小程序密钥：</strong></p>
<p>AppSecret 是小程序的 <strong>私密鉴权密钥</strong>，相当于 “登录密码”，<strong>绝对不可暴露</strong></p>
<p>仅存储在，后端服务，核心作用是<strong>身份鉴权</strong>，生成：<strong>调用微信敏感 API 核心凭证 <code>access_token</code></strong></p>
<h3 data-id="heading-4">安装微信开发者工具：</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fdownload.html" target="_blank" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" ref="nofollow noopener noreferrer">下载|安装开发者工具：</a> <strong>官方推荐使用的小程序开发工具🪄🪄🪄</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e485169645184332ab58db057e05e217~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=J8g3DwH1kmXaXDxyHX%2F9U5lMMXY%3D" alt="PixPin_2026-01-29_16-29-31.gif" loading="lazy"/></p>
<p><strong>↗️点击右上角【设置】</strong> 可以对开发工具进行设置：样式、默认路径、服务代理等等，</p>
<p><strong>🌐代理设置：</strong> 建议使用：<code>不使用任何代理</code> 因为，不同人的电脑可能存在一些配置|魔法工具！！</p>
<p>而微信小程序，开发中有很多需要和微信进行通信的，勾选此配置，更能保证，微信API 通知稳定！</p>
<h3 data-id="heading-5">创建微信小程序项目：</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/590ba1700f804abeadd551f3aaef0eef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=zgfsdRirwB6i8ZpruKv7xqmvUWU%3D" alt="PixPin_2026-01-29_17-17-56.gif" loading="lazy"/></p>
<p><strong>AppID小程序唯一标识（如截图中的<code>wx5ed...29d6</code>）</strong></p>
<p><strong>后端服务 + 语言后端服务选 “不使用云服务”，语言选 <code>JavaScript</code></strong></p>
<ul>
<li>
<p><strong>不使用云服务</strong>：适合后端开发者，因为需要 <strong>自建后端服务</strong> 对接小程序，</p>
<p>云服务是微信提供的云端后端，无需自建服务器， <strong>适合纯前端开发者</strong></p>
</li>
<li>
<p><strong>JavaScript</strong>：小程序原生开发的默认语言，入门门槛低，适合新手；<strong>页面如此：</strong></p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89a888d55f524302b9779620ce4a2479~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=Q2UuMQwgAoBqWRBkus318KWpW7U%3D" alt="PixPin_2026-01-29_17-31-14.gif" loading="lazy"/>
<code>不详细介绍了，摸索着去体验吧！！！</code></p>
<h3 data-id="heading-6">小程序代码的构成：</h3>
<pre><code class="hljs language-tcl" lang="tcl">WSM01/
├── pages/                # 页面模块目录（核心），每个页面一个独立子文件夹
│   ├── index/            # 首页（默认页面），包含4个核心文件
│   │   ├── index.wxml    # 页面结构
│   │   ├── index.wxss    # 页面样式
│   │   ├── index.js      # 页面逻辑
│   │   └── index.json    # 页面配置
│   └── logs/             # 日志页面（默认生成，可删除/修改）
├── utils/                # 通用工具类目录（对应Java的utils包）
├── app.js                # 全局逻辑文件（对应Java的全局入口类）
├── app.json              # 全局配置文件（核心，对应Java的application.yml）
├── app.wxss              # 全局样式文件（对应Java的全局样式/公共CSS）
├── project.config.json   # 开发者工具项目配置（对应Java的pom.xml/gradle配置）
├── project.private.config.json # 私有配置（如个人开发偏好，无需关注）
└── sitemap.json          # 微信搜索索引配置（SEO相关）
</code></pre>
<h4 data-id="heading-7">全局核心文件</h4>
<p>全局文件位于项目根目录，<strong>作用于整个小程序</strong>，是项目启动和运行的基础，必须存在且命名固定；</p>
<p><strong>app.js</strong> 逻辑文件</p>
<ul>
<li>
<p>小程序<strong>全局入口</strong>，管理全局生命周期、全局数据、全局方法</p>
</li>
<li>
<p>通过<code>App({})</code>函数定义全局实例，包含</p>
<p><code>onLaunch</code>（小程序启动时执行，仅 1 次）<code>onShow</code>（小程序前台显示时执行）等生命周期；</p>
<p>存放全局数据，如后端接口基础地址 <code>globalData: { baseUrl: "https://xx.xx.x.xx:8080" }</code></p>
</li>
</ul>
<p><strong>app.json</strong> 配置文件</p>
<ul>
<li>小程序<strong>全局配置核心</strong>，决定页面路由、窗口样式、tabBar 等，<strong>严格 JSON 格式</strong></li>
<li><code>pages</code>：页面路由数组 <strong>第一个元素为默认首页</strong>，新增页面<code>必须在这里注册，工具会自动生成页面文件</code></li>
<li><code>window</code>：全局窗口样式：导航栏标题、背景色、文字颜色；</li>
<li><code>sitemapLocation：</code> 用来指明 <code>sitemap.json</code> 文件位置</li>
<li><code>tabBar</code>：底部导航栏：多页面切换时配置；</li>
</ul>
<p><strong>app.wxss</strong> 样式文件，全局样式表，所有页面均可继承使用；</p>
<ul>
<li>语法：基于 CSS，支持<code>rpx</code>适配单位，<strong>无作用域</strong>，所有页面生效；</li>
<li>存放公共样式，如按钮默认样式、全局字体、颜色变量，避免重复编写样式；</li>
</ul>
<h4 data-id="heading-8">页面模块目录</h4>
<p><strong><code>pages/</code></strong> 目录是小程序的<strong>页面容器</strong>，<strong>每个页面对应一个独立子文件夹</strong> <code>如: 截图中的index、logs</code></p>
<p>文件夹名称建议与页面功能一致 如：<code>home</code>、<code>order</code> <strong>每个页面必须包含 1-4 个核心文件</strong></p>
<p><strong>xxx.wxml</strong> 结构文件，页面视图层，定义页面结构 <code>对应HTML</code></p>
<p><strong>xxx.wxss</strong> 样式文件，页面视图层，定义页面专属样式 <code>对应 CSS</code></p>
<p><strong>xxx.js</strong> 逻辑文件，页面逻辑层，管理页面生命周期、数据、交互、响应；</p>
<p><strong>xxx.json</strong> 页面配置文件页面专属配置，覆盖全局配置 app.json，优先级最高！</p>
<h4 data-id="heading-9">通用工具 / 配置文件</h4>
<p><strong>工具封装、开发者工具配置、搜索优化</strong>，非核心业务文件，但能提升开发效率和项目规范性</p>
<p><strong>utils/</strong> 通用工具类目录</p>
<ul>
<li>存放可复用的 JS 工具函数</li>
<li>如：<code>日期格式化、接口请求封装、数据校验</code></li>
</ul>
<p><strong>sitemap.json</strong> 微信搜索索引配置，控制小程序是否允许：<code>被微信搜索收录</code></p>
<p><strong>project.config.json</strong> 开发者工具项目配置：保存，开发者工具的个性化设置🔧</p>
<ul>
<li>如 AppID、项目名称、编译模式，<strong>提交代码时建议保留</strong>，确保团队开发环境一致；</li>
</ul>
<p><strong>project.private.config.json</strong> 私有配置，存放个人开发偏好：<code>如编辑器主题、快捷键</code> <strong>无需提交代码</strong></p>
<h3 data-id="heading-10">小程序基本使用：</h3>
<h4 data-id="heading-11">app.json 操作：</h4>
<p><strong>app.json</strong> 基础操作，大致如此，不同版本可能会存在差异，影响不大！</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"pages"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"pages/index/index"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"pages/logs/logs"</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"window"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"navigationBarTextStyle"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"black"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"navigationBarTitleText"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Weixin"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"navigationBarBackgroundColor"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"#ffffff"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  
  <span class="hljs-attr">"style"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v2"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"componentFramework"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"glass-easel"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"sitemapLocation"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sitemap.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"lazyCodeLoading"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"requiredComponents"</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<ul>
<li><strong>style：</strong> 指定小程序的 <strong>样式版本</strong>，<code>v2</code>是微信推出的 <strong>新版样式标准</strong></li>
<li><strong>sitemapLocation：</strong> 指定小程序 <strong>搜索索引配置文件</strong> 路径，控制小程序页面允许被微信搜索收录；</li>
<li><strong>lazyCodeLoading：</strong> 小程序的 <strong>代码懒加载策略</strong>，<code>requiredComponents</code> <strong>仅在自定义组件时使用；</strong></li>
</ul>
<h5 data-id="heading-12">pages：</h5>
<p><strong>小程序的页面路由由<code>app.json</code>的<code>pages</code>数组自动管理</strong>，无需手动配置路由映射；</p>
<p><strong>默认首页</strong>：数组<strong>第一个元素</strong>（<code>pages/index/index</code>）是小程序启动时的默认首页；</p>
<p><strong>自动生成页面</strong>：若在<code>pages</code>中新增页面路径，微信开发者工具会 <strong>自动生成该页面的 4 个核心文件</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5d524a5708e443d8ce908f8cf1fbfe2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=40vKJmFVoOhfuZugQf4lOW2FDtE%3D" alt="PixPin_2026-01-29_21-06-29.gif" loading="lazy"/></p>
<h5 data-id="heading-13">window:</h5>
<p>控制小程序  <strong>顶部导航栏（窗口）</strong> 的全局样式，所有页面默认继承该配置，</p>
<p>若页面有单独的<code>xxx.json</code>配置，会覆盖此处的对应属性；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2343785272f14a0fb269452928cbcc9a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=g2Ktxotd4pn6r4pJb%2B%2F5RYDVWVk%3D" alt="PixPin_2026-01-29_21-52-24.gif" loading="lazy"/></p>
<h4 data-id="heading-14">project.config.json 操作：</h4>
<p><code>project.config.json</code> 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置；</p>
<p><strong>appid：</strong> 保存的是小程序的账号 ID，<code>如果导入的项目，需要到这边更换，自己小程序的ID！！</code></p>
<p><strong>projectname：</strong> 设置保存的是项目名称，注意项目名称，<code>并不是小程序名称！</code></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compileType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"miniprogram"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"libVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"trial"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"ignore"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"setting"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-comment">//...省略展示...</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"condition"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"editorSetting"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tabIndent"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"auto"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"tabSize"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"appid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"wx8407df8e55ebb60d"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"simulatorPluginLibVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h5 data-id="heading-15">setting：</h5>
<p><strong>setting 中保存了编译相关的配置：</strong> 开发者工具的个性化设置；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61e11befdad3477cad927c14add47f33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=CpGWt%2Bj0D5HfnhudSQtcgGbQH7o%3D" alt="PixPin_2026-01-29_22-03-25.gif" loading="lazy"/></p>
<h3 data-id="heading-16">小程序宿主环境：</h3>
<p><strong>宿主环境</strong>  <code>host environment</code> 指的是程序运行所<strong>必须的依赖环境</strong></p>
<p><code>Android系统</code> 和 <code>iOS系统</code>是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的；</p>
<p><strong>微信</strong>是小程序的宿主环境，小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e535c9d832aa42e882b67df899b73cf0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=3jDD9hLbvIub1pmIPKMbN915GYU%3D" alt="image-20260130010428829.png" loading="lazy"/></p>
<p><strong>小程序宿主环境包含的内容：</strong> <code>通信模型(了解)、运行机制(了解)、组件、API</code></p>
<h4 data-id="heading-17">通信模型</h4>
<p><strong>小程序中 <code>通信的主体</code> 是渲染层和逻辑层，</strong></p>
<p><strong>其中：</strong> WXML 模板和 WXSS 样式工作在渲染层、JS脚本工作在逻辑层</p>
<p><strong>小程序中的通信模型分为两部分：</strong> 渲染层和逻辑层之间的通信，由微信客户端进行转发；</p>
<p>逻辑层和第三方服务器之间的数据通信，由，微信客户端进行转发；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7387e7ce63246598a356cd926286bff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=SuvftzO12JUoGmSVQ1GV9MkyVKk%3D" alt="image-20260130015740435.png" loading="lazy"/></p>
<h4 data-id="heading-18">运行机制</h4>
<p><strong>小程序启动的过程</strong></p>
<pre><code class="hljs language-scss" lang="scss">把小程序的代码包下载到本地
解析 app<span class="hljs-selector-class">.json</span> 全局配置文件
执行 app<span class="hljs-selector-class">.js</span> 小程序入口文件，调用 <span class="hljs-built_in">App</span>() 创建小程序实例
渲染小程序首页
小程序启动完成
</code></pre>
<p><strong>页面渲染的过程</strong></p>
<pre><code class="hljs language-scss" lang="scss">加载解析页面的 <span class="hljs-selector-class">.json</span> 配置文件
加载页面的 <span class="hljs-selector-class">.wxml</span> 模板和 <span class="hljs-selector-class">.wxss</span> 样式
执行页面的 <span class="hljs-selector-class">.js</span> 文件，调用 <span class="hljs-built_in">Page</span>() 创建页面实例
页面渲染完成
</code></pre>
<h4 data-id="heading-19">组件</h4>
<p>小程序中的组件也是由 <strong>宿主环境提供</strong> 的，官方把小程序的组件分为了 <strong>9 大类</strong></p>
<p><code>视图容器、基础内容、表单组件、导航组件、</code> 媒体组件、map 地图组件</p>
<p>canvas 画布组件、开放能力、无障碍访问；</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fcover-image.html" target="_blank" title="https://developers.weixin.qq.com/miniprogram/dev/component/cover-image.html" ref="nofollow noopener noreferrer">小程序组件介绍！！！</a></p>
<h5 data-id="heading-20">视图容器：</h5>
<p><strong>view</strong> 普通视图区域，类似于 HTML 中的 div，是一个块级元素，常用来 <code>实现页面的布局效果</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa277ede91cd4bbd9b5035bf6c735b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=vhu1ZTZXOaH5uoN2l%2BanD44sulM%3D" alt="PixPin_2026-01-30_13-00-28.gif" loading="lazy"/></p>
<p><strong>scroll-view</strong>  可滚动的视图区域，常用来实现滚动列表效果，如：列表、菜单…………</p>
<p>支持<strong>横向 / 纵向滚动</strong>、滚动到底部 / 顶部触发事件，是实现 “上拉加载更多” 的核心组件</p>
<p><code>scroll-x</code> <code>true</code>/<code>false</code>是否允许横向滚动，<code>scroll-y</code> <code>true</code>/<code>false</code>是否允许纵向滚动；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee6c1fb8f4de455ea0b520fbb07c47cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=0BeZsnRMvhUvZSVlR2opqWJTe9A%3D" alt="PixPin_2026-01-30_13-05-35.gif" loading="lazy"/></p>
<p><strong>swiper 和 swiper-item</strong> 轮播图容器组件 和 轮播图 item 组件；</p>
<p><code>swiper</code>是<strong>轮播图容器</strong>，<code>swiper-item</code>是<strong>轮播项</strong>（必须作为<code>swiper</code>的直接子元素）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/455df2c49e734d7e9d7466468865c0fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=O07LBUQ4F34jzyVONW1aB5nxSxQ%3D" alt="image-20260130131238374.png" loading="lazy"/></p>
<h5 data-id="heading-21"><strong>基础组件：</strong></h5>
<p><strong>text 文本组件：</strong>  类似于 HTML 中的 span 标签，是一个行内元素；</p>
<p><strong>rich-text 富文本组件：</strong> 支持把 HTML 字符串渲染为 WXML 结构；</p>
<ul>
<li>通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构；</li>
</ul>
<p><strong>image 图片组件：</strong> image 组件默认宽度约 300px、高度约 240px</p>
<p><strong>button 按钮组件：</strong> 功能比 HTML 中的 button 按钮丰富；type 指定不同类型；</p>
<ul>
<li>通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d337ce35fcf64152b71143ddf1990f09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=dvabN4srSWk9mEUrH3B3rfzekeg%3D" alt="image-20260130132853264.png" loading="lazy"/></p>
<h4 data-id="heading-22">API</h4>
<p>小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便调用 <strong>微信能力</strong></p>
<p><strong>小程序官方把 API 分为了如下 3 大类：</strong> <code>事件监听API、同步API、异步API</code></p>
<p><strong>事件监听 API：</strong></p>
<ul>
<li>特点：以 on 开头，用来监听某些事件的触发</li>
<li>举例：<code>wx.onWindowResize(function callback)</code> 监听窗口尺寸变化的事件</li>
<li>类似于HTML中的，<code>windows.onclick()</code> 等函数，是组件和用户交互产生处理的操作；</li>
</ul>
<p><strong>同步 API：</strong></p>
<ul>
<li>特点1：以 <code>Sync 结尾的 API</code> 都是同步 API</li>
<li>同步 API 的执行结果，可以通过函数返回值直接获取，</li>
<li>如果执行出错会抛出异常，需用<code>try-catch</code>捕获，适合轻量、无 IO 阻塞的本地操作；</li>
<li>举例：<code>wx.setStorageSync('key', 'value')</code> 向本地存储中写入内容；</li>
<li><code>wx.clearStorageSync</code> 清空本地存储</li>
</ul>
<p><strong>异步 API：复杂能力的 “核心入口”</strong></p>
<ul>
<li>无固定后缀，<strong>异步执行</strong>，需通过<code>success</code>/<code>fail</code>回调、<code>Promise</code> 或<code>async/await</code>获取结果</li>
<li>举例：<code>wx.request()</code> 发起网络数据请求，通过 <code>success 回调函数</code> 接收数据；</li>
<li>类似于 jQuery 中的 <code>$.ajax(options)</code> 函数</li>
</ul>
<h2 data-id="heading-23"><strong>协同工作和发布</strong></h2>
<p>在中大型的公司里，人员的分工非常仔细：</p>
<p>同一个小程序项目，一般会有不同岗位、不同角色的员工同时参与设计与开发</p>
<p>此时出于管理需要，我们 <strong>迫切需要对</strong> 不同岗位、不同角色的 <strong>员工的权限进行边界的划分</strong></p>
<h3 data-id="heading-24"><strong>小程序成员管理</strong></h3>
<p><strong>小程序成员管理体现在<code>管理员</code>对小程序<code>项目成员</code>及<code>体验成员</code>的管理：</strong> 在添加成员时候可以进行分配；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe1825a6f3d3457cba2cafcade00ab00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=T0vRqomzWHm986qW8K%2BC%2F42J1M0%3D" alt="image-20260130142141197.png" loading="lazy"/></p>
<p>微信小程序后台的角色体系是 <strong>分级管控</strong> 的，不同角色对应不同的操作权限</p>
<p>核心分为<code>「管理员」</code> <code>「项目成员（运营者 / 开发者 / 数据分析者）」</code> <code>「体验者」</code>三大类；</p>
<p><strong>管理员 最高权限（超级管理员）全平台操作</strong></p>

























<table><thead><tr><th><strong>角色核心</strong></th><th><strong>权限等级</strong></th><th><strong>操作范围</strong></th></tr></thead><tbody><tr><td><strong>运营者</strong></td><td>运营级权限</td><td>提交审核、版本发布（需管理员授权）<br/>用户反馈处理、模板消息配置<br/>推广设置、小程序码生成</td></tr><tr><td><strong>开发者</strong></td><td>开发级权限</td><td>代码上传、版本管理、开发设置（域名 / 服务器配置）<br/>云开发管理、接口权限配置，体验版管理、开发者工具绑定</td></tr><tr><td><strong>数据分析者</strong></td><td>只读权限</td><td>仅数据查看操作，包括：用户访问统计、行为分析<br/>交易数据、留存率等核心指标，无任何修改 / 配置权限</td></tr></tbody></table>
<p><strong>体验者</strong> 最低权限（仅体验）仅能扫码体验「体验版」小程序，无任何后台操作权限</p>
<h3 data-id="heading-25"><strong>小程序的版本</strong></h3>
<p><strong>软件开发过程中，根据时间节点的不同，会产出不同的软件版本，例如</strong></p>





















<table><thead><tr><th>开发版本</th><th>使用开发者工具，可将代码上传到开发版本中。  <br/>开发版本只保留每人最新的一份上传的代码  点击提交审核，<br/>可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。</th></tr></thead><tbody><tr><td>体验版本</td><td>可以选择某个开发版本作为体验版，并且选取一份体验版。</td></tr><tr><td>审核中的版本</td><td>只能有一份代码处于审核中。<br/>有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本</td></tr><tr><td>线上版本</td><td>线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新</td></tr></tbody></table>
<p>一个小程序的发布上线，一般要经过 <code>上传代码 -&gt; 提交审核 -&gt; 发布</code> 这三个步骤</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d158a94c11d4ba3a2a4bd718ece6e15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=hX%2Bx3gCpZ0T%2FCXEg%2BXnACFpr5Yo%3D" alt="PixPin_2026-01-30_14-29-44.gif" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b09f66f9cc9144738e457b4a03f35d6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=3XecpW88PQXcIA%2FR0qCCxJ6vnng%3D" alt="image-20260130143024732.png" loading="lazy"/></p>
<p><strong>登录小程序管理后台 -&gt; 管理 -&gt; 版本管理 -&gt; 开发版本，即可查看刚才提交上传的版本了：</strong></p>
<p><strong>选择版本，提交申请：</strong> 第一次提交需要小程序进行备案，此处个人学习就不展示了；</p>
<p><strong>审核通过之后，管理员的微信中会收到小程序通过审核的通知，</strong></p>
<ul>
<li>此时在审核版本的列表中，点击 <code>发布</code> 按钮之后，</li>
<li>即可把“审核通过”的版本发布为<code>线上版本</code></li>
<li>供所有小程序用户访问和使用</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56c6efa7ce5344fdb9115e3ffb328130~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oWI5qeYeWE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770624503&amp;x-signature=AQOyeIp3brwcTxCz31qzLpT98ls%3D" alt="image-20260130143208905-1769756686277.png" loading="lazy"/></p>
<h3 data-id="heading-26">推广码：</h3>
<p><strong>发布上线之后，可以，选择设置打印出小程序推广码：</strong></p>
<p>登录小程序管理后台 -&gt; 设置 -&gt; 基本设置 -&gt; 基本信息 -&gt; 小程序码及线下物料下载；</p>
<p><strong>小程序运营数据</strong></p>
<ul>
<li>
<p><strong>方式一：</strong> 在<code>小程序后台</code> 查看，登录小程序管理后台，</p>
<p>点击侧边栏的“统计”点击相应的 tab 可以看到相关的数据</p>
</li>
<li>
<p><strong>方式二：</strong>  搜索 <code>小程序数据助手</code> ，查看已发布的小程序相关的数据；</p>
</li>
</ul>
<h2 data-id="heading-27">相关文档：</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1834y1676P%3Fspm_id_from%3D333.788.videopod.episodes%26vd_source%3D19e007a1660dfd5c8f1744e56d027bf4%26p%3D2" target="_blank" title="https://www.bilibili.com/video/BV1834y1676P?spm_id_from=333.788.videopod.episodes&amp;vd_source=19e007a1660dfd5c8f1744e56d027bf4&amp;p=2" ref="nofollow noopener noreferrer">黑马—小程序简介_哔哩哔哩_bilibili</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fm0_64875238%2Farticle%2Fdetails%2F127796691%3Fops_request_misc%3Delastic_search_misc%26request_id%3D4c6789a9299d3347e64d6c17839bce60%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127796691-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25BE%25AE%25E4%25BF%25A1%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/m0_64875238/article/details/127796691?ops_request_misc=elastic_search_misc&amp;request_id=4c6789a9299d3347e64d6c17839bce60&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127796691-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">微信小程序开发（超详细保姆式教程）-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_53812239%2Farticle%2Fdetails%2F139720191%3Fops_request_misc%3Delastic_search_misc%26request_id%3Dc1a5e738633bd1e7da34a5b28a8351d0%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139720191-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%25E6%25B5%258B%25E8%25AF%2595%25E5%258F%25B7%25E5%25A6%2582%25E4%25BD%2595%25E6%25B3%25A8%25E9%2594%2580%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/weixin_53812239/article/details/139720191?ops_request_misc=elastic_search_misc&amp;request_id=c1a5e738633bd1e7da34a5b28a8351d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139720191-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%8F%B7%E5%A6%82%E4%BD%95%E6%B3%A8%E9%94%80&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">关于小程序测试账号如何移除_小程序测试号怎么删除-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_43474701%2Farticle%2Fdetails%2F122213203%3Fops_request_misc%3Delastic_search_misc%26request_id%3Dc1a5e738633bd1e7da34a5b28a8351d0%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122213203-null-null.142%255Ev102%255Epc_search_result_base8%26utm_term%3D%25E5%25B0%258F%25E7%25A8%258B%25E5%25BA%258F%25E6%25B5%258B%25E8%25AF%2595%25E5%258F%25B7%25E5%25A6%2582%25E4%25BD%2595%25E6%25B3%25A8%25E9%2594%2580%26spm%3D1018.2226.3001.4187" target="_blank" title="https://blog.csdn.net/weixin_43474701/article/details/122213203?ops_request_misc=elastic_search_misc&amp;request_id=c1a5e738633bd1e7da34a5b28a8351d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122213203-null-null.142%5Ev102%5Epc_search_result_base8&amp;utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%8F%B7%E5%A6%82%E4%BD%95%E6%B3%A8%E9%94%80&amp;spm=1018.2226.3001.4187" ref="nofollow noopener noreferrer">微信注销时没有解除小程序运营者身份而不让注销：解除接口测试号_微信注销提示小程序接口-CSDN博客</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter-实现Tabs吸顶的PageView效果]]></title>    <link>https://juejin.cn/post/7601728622824095787</link>    <guid>https://juejin.cn/post/7601728622824095787</guid>    <pubDate>2026-02-02T02:51:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601728622824095787" data-draft-id="7601464318410014762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter-实现Tabs吸顶的PageView效果"/> <meta itemprop="keywords" content="前端,Flutter,Android"/> <meta itemprop="datePublished" content="2026-02-02T02:51:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏多多"/> <meta itemprop="url" content="https://juejin.cn/user/747323639737191"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter-实现Tabs吸顶的PageView效果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/747323639737191/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏多多
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:51:02.000Z" title="Mon Feb 02 2026 02:51:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="agate">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#333;color:#fff}.hljs-name,.hljs-strong{font-weight:700}.hljs-code,.hljs-emphasis{font-style:italic}.hljs-tag{color:#62c8f3}.hljs-selector-class,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#ade5fc}.hljs-bullet,.hljs-string{color:#a2fca2}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-title,.hljs-type{color:#ffa}.hljs-bullet,.hljs-number,.hljs-symbol{color:#d36363}.hljs-keyword,.hljs-literal,.hljs-selector-tag{color:#fcc28c}.hljs-code,.hljs-comment,.hljs-deletion{color:#888}.hljs-link,.hljs-regexp{color:#c6b4f0}.hljs-meta{color:#fc9b9b}.hljs-deletion{background-color:#fc9b9b;color:#333}.hljs-addition{background-color:#a2fca2;color:#333}.hljs a{color:inherit}.hljs a:focus,.hljs a:hover{color:inherit;text-decoration:underline}</style><h2 data-id="heading-0">1. 效果预览</h2>
<p>在 Flutter 开发中，创建具有吸顶 Tabs 的 PageView 效果可以极大地提升用户界面的交互性和用户体验。今天，我们就通过一段具体的代码来深入了解如何实现这一功能。效果预览如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e668bebeb3147a293aa730227c4e2dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bmP5aSa5aSa:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770605462&amp;x-signature=o%2FXaSEucD7rt17hi5dJSe3f%2BxEw%3D" alt="预览图" loading="lazy"/></p>
<h2 data-id="heading-1">2. 结构分析</h2>
<p>我们从整体上看这段代码，它定义了一个名为CeilingTabsPageView的有状态组件。这个组件的作用就是构建出一个带有吸顶 Tabs 的页面，用户可以通过滑动 PageView 在不同的页面内容间切换。</p>
<ol>
<li>引入必要的库</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:extended_nested_scroll_view/extended_nested_scroll_view.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
</code></pre>
<p>代码开头引入了两个重要的库。</p>
<ul>
<li>
<p>package:flutter/material.dart：Flutter 的核心 UI库，它提供了各种构建用户界面的基本组件和工具，比如我们后续会用到的Container、Row、Text等。</p>
</li>
<li>
<p>package:extended_nested_scroll_view/extended_nested_scroll_view.dart：为我们实现吸顶效果提供了关键支持，ExtendedNestedScrollView这个特殊的组件就来自于它。</p>
</li>
</ul>
<ol start="2">
<li>定义CeilingTabsPageView组件</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> CeilingTabsPageView({Key? key}) : <span class="hljs-keyword">super</span>(key: key);

  <span class="hljs-meta">@override</span>
  State&lt;CeilingTabsPageView&gt; createState() =&gt; CeilingTabsPageViewState();
}
</code></pre>
<p>这里定义了CeilingTabsPageView组件，它是一个有状态的组件。有状态组件意味着它在运行过程中可以根据用户操作或者其他事件改变自身状态。而createState方法返回了CeilingTabsPageViewState实例，这个实例负责管理组件的状态和构建具体的 UI。</p>
<ol start="3">
<li>CeilingTabsPageViewState类的详细解析</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CeilingTabsPageView</span>&gt; </span>{
<span class="hljs-comment">/// <span class="markdown">控制器</span></span>
<span class="hljs-keyword">late</span> PageController _pageController;

<span class="hljs-built_in">int</span> pageIndex = <span class="hljs-number">0</span>;

 <span class="hljs-comment">/// <span class="markdown">字体样式</span></span>
TextStyle myTextStyle = <span class="hljs-keyword">const</span> TextStyle(
      color: Colors.white, fontWeight: FontWeight.w600, fontSize: <span class="hljs-number">20</span>);

  <span class="hljs-comment">/// <span class="markdown">生命周期</span></span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _pageController = PageController(initialPage: pageIndex);
  }

 <span class="hljs-comment">/// <span class="markdown">页面滑动回调</span></span>
  <span class="hljs-keyword">void</span> handlePageChange(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
    });
  }
 
<span class="hljs-comment">/// <span class="markdown">Tabs点击</span></span>
  <span class="hljs-keyword">void</span> handleTabClick(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
      _pageController.jumpToPage(index); <span class="hljs-comment">// 直接跳转至指定页面</span>
    });
  }
</code></pre>
<ul>
<li>生命周期方法：initState方法在组件首次插入到 Widget 树时调用，在这里我们只是简单地调用了父类的initState方法，暂时没有额外的初始化操作，但它为我们后续可能需要的初始化工作提供了位置。</li>
<li>状态变量：pageIndex用于记录当前 PageView 显示的页面索引，初始值为 0，表示默认显示第一个页面。</li>
<li>控制器：_pageController是PageView的控制器</li>
<li>字体样式定义：myTextStyle定义了一种字体样式，包括白色字体颜色、中等加粗的字重和 20 的字体大小，后续在多个文本组件中会使用到这个样式。</li>
<li>页面滑动回调函数：当 PageView 发生滑动时，handlePageChange函数会被调用。它通过setState方法来更新pageIndex的值，setState方法会触发组件的重新构建，从而确保 UI 能够反映出页面索引的变化。</li>
<li>Tabs点击：点击Tabs的回调函数</li>
</ul>
<ol start="4">
<li>构建 UI 的核心方法</li>
</ol>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-meta">@override</span>
Widget build(BuildContext context) {
  <span class="hljs-comment">/// <span class="markdown">最大宽度</span></span>
  <span class="hljs-built_in">double</span> maxW = MediaQuery.of(context).size.width;

  <span class="hljs-comment">/// <span class="markdown">最大高度</span></span>
  <span class="hljs-built_in">double</span> maxH = MediaQuery.of(context).size.height;

  <span class="hljs-keyword">return</span> SizedBox(
    width: maxW,
    height: maxH,
    child: ExtendedNestedScrollView(
        headerSliverBuilder: (BuildContext context, <span class="hljs-built_in">bool</span> innerBoxIsScrolled) {
          <span class="hljs-keyword">return</span> [
            SliverToBoxAdapter(
                child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [bannerWidget(maxW), tabsWidget(maxW)]))
          ];
        },
        <span class="hljs-comment">// 需要固定吸顶的高度</span>
        pinnedHeaderSliverHeightBuilder: () {
          <span class="hljs-keyword">return</span> <span class="hljs-number">40</span>;
        },
        onlyOneScrollInBody: <span class="hljs-keyword">true</span>,
        body: SizedBox(
          width: maxW,
          height: maxH,
          child: pageViewWidget(maxW, maxH),
        )),
  );
}
</code></pre>
<ul>
<li>获取屏幕尺寸：通过MediaQuery.of(context).size.width和MediaQuery.of(context).size.height获取当前设备屏幕的宽度maxW和高度maxH，这两个值对于构建适配不同屏幕尺寸的 UI 非常重要。</li>
<li>使用ExtendedNestedScrollView：这是实现吸顶效果的关键组件。</li>
<li>headerSliverBuilder：这个回调函数用于构建顶部的内容。它返回一个包含SliverToBoxAdapter的列表，SliverToBoxAdapter又包含了一个Column，Column中依次排列着bannerWidget和tabsWidget。这就定义了顶部的布局结构，先显示一个 Banner，再显示 Tabs。</li>
<li>pinnedHeaderSliverHeightBuilder：这个回调函数指定了需要固定吸顶的高度为 40。也就是说，tabsWidget部分会在用户滚动页面时固定在顶部，不会随着页面内容一起滚动。</li>
<li>onlyOneScrollInBody：设置为true表示在页面主体部分只允许一个滚动行为，避免了滚动冲突。
body：这里设置页面的主体内容为pageViewWidget，也就是我们的 PageView 部分。</li>
</ul>
<ol start="5">
<li>各个部件的构建方法</li>
</ol>
<p><strong>bannerWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget bannerWidget(<span class="hljs-built_in">double</span> maxW) {
  <span class="hljs-keyword">return</span> Container(
      width: maxW,
      height: <span class="hljs-number">200</span>,
      alignment: Alignment.center,
      color: Colors.red.shade300,
      child: Text(<span class="hljs-string">'Banner'</span>, style: myTextStyle));
}
</code></pre>
<p>这个方法构建了一个Container作为 Banner。它的宽度为屏幕宽度maxW，高度为 200，背景颜色为浅红色（Colors.red.shade300），并且在容器中心显示了 “Banner” 字样，使用之前定义好的myTextStyle字体样式。</p>
<p><strong>tabsWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget tabsWidget(<span class="hljs-built_in">double</span> maxW) {
  <span class="hljs-keyword">return</span> Container(
    width: maxW,
    height: <span class="hljs-number">40</span>,
    color: Colors.blue.shade400,
    child: Row(
      children: [
        Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">0</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 1'</span>, style: myTextStyle),
              ),
            ),
          ),
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">1</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 2'</span>, style: myTextStyle),
              ),
            ),
          )
      ],
    ),
  );
}
</code></pre>
<p>tabsWidget构建了 Tabs 部分。同样是一个宽度为屏幕宽度maxW、高度为 40 的Container，背景颜色为浅蓝色（Colors.blue.shade400）。在这个容器内部，通过Row布局将空间分为两部分，每部分都包含一个Expanded包裹的Container，分别显示 “Tab 1” 和 “Tab 2”，同样使用myTextStyle字体样式。Expanded组件的作用是让两个 Tab 平分容器的宽度。并且添加了GestureDetector来处理点击事件。</p>
<p><strong>pageViewWidget</strong></p>
<pre><code class="hljs language-dart" lang="dart">Widget pageViewWidget(<span class="hljs-built_in">double</span> maxW, <span class="hljs-built_in">double</span> maxH) {
  <span class="hljs-keyword">return</span> SingleChildScrollView(
      primary: <span class="hljs-keyword">true</span>,
      physics: <span class="hljs-keyword">const</span> BouncingScrollPhysics(),
      child: SizedBox(
        width: maxW,
        height: maxH,
        child: PageView(
        controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                pageIndex = index;
              });
            },
          children: [
            Container(
                width: maxW,
                height: <span class="hljs-number">1000</span>,
                color: Colors.amberAccent,
                alignment: Alignment.topCenter,
                child: Text(<span class="hljs-string">'Page1'</span>, style: myTextStyle)),
            Container(
                width: maxW,
                height: <span class="hljs-number">1000</span>,
                color: Colors.deepPurpleAccent,
                alignment: Alignment.topCenter,
                child: Text(<span class="hljs-string">'Page2'</span>, style: myTextStyle))
          ],
        ),
      ));
}
</code></pre>
<p>pageViewWidget构建了 PageView。它被包裹在SingleChildScrollView中，设置primary为true表示这是主要的滚动视图，physics设置为BouncingScrollPhysics以实现类似于 iOS 的弹性滚动效果。在SizedBox内部是一个PageView，包含两个页面，每个页面都是一个宽度为屏幕宽度maxW、高度为 1000 的Container，分别显示 “Page1” 和 “Page2”，背景颜色也各不相同，同样使用myTextStyle字体样式。并且把控制器绑定上，添加了onPageChanged回调事件。</p>
<h2 data-id="heading-2">3. 完整代码</h2>
<ul>
<li>main.dart</li>
</ul>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">const</span> CeilingTabsPageView()
</code></pre>
<ul>
<li>ceilingTabsPageView.dart</li>
</ul>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:extended_nested_scroll_view/extended_nested_scroll_view.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-comment">/// <span class="markdown">吸顶Tabs的PageView</span></span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> CeilingTabsPageView({Key? key}) : <span class="hljs-keyword">super</span>(key: key);

  <span class="hljs-meta">@override</span>
  State&lt;CeilingTabsPageView&gt; createState() =&gt; CeilingTabsPageViewState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CeilingTabsPageViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CeilingTabsPageView</span>&gt; </span>{
  <span class="hljs-keyword">late</span> PageController _pageController;

  <span class="hljs-built_in">int</span> pageIndex = <span class="hljs-number">0</span>;

  <span class="hljs-comment">/// <span class="markdown">字体样式</span></span>
  TextStyle myTextStyle = <span class="hljs-keyword">const</span> TextStyle(
      color: Colors.white, fontWeight: FontWeight.w600, fontSize: <span class="hljs-number">20</span>);

  <span class="hljs-comment">/// <span class="markdown">生命周期</span></span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _pageController = PageController(initialPage: pageIndex);
  }

  <span class="hljs-comment">/// <span class="markdown">页面滑动回调</span></span>
  <span class="hljs-keyword">void</span> handlePageChange(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
    });
  }

  <span class="hljs-comment">/// <span class="markdown">Tabs点击</span></span>
  <span class="hljs-keyword">void</span> handleTabClick(<span class="hljs-built_in">int</span> index) {
    setState(() {
      pageIndex = index;
      _pageController.jumpToPage(index); <span class="hljs-comment">// 直接跳转至指定页面</span>
    });
  }

  <span class="hljs-comment">/// <span class="markdown">构建UI</span></span>
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">/// <span class="markdown">最大宽度</span></span>
    <span class="hljs-built_in">double</span> maxW = MediaQuery.of(context).size.width;

    <span class="hljs-comment">/// <span class="markdown">最大高度</span></span>
    <span class="hljs-built_in">double</span> maxH = MediaQuery.of(context).size.height;

    <span class="hljs-keyword">return</span> SizedBox(
      width: maxW,
      height: maxH,
      child: ExtendedNestedScrollView(
          headerSliverBuilder: (BuildContext context, <span class="hljs-built_in">bool</span> innerBoxIsScrolled) {
            <span class="hljs-keyword">return</span> [
              SliverToBoxAdapter(
                  child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [bannerWidget(maxW), tabsWidget(maxW)]))
            ];
          },
          <span class="hljs-comment">// 需要固定吸顶的高度</span>
          pinnedHeaderSliverHeightBuilder: () {
            <span class="hljs-keyword">return</span> <span class="hljs-number">40</span>;
          },
          onlyOneScrollInBody: <span class="hljs-keyword">true</span>,
          body: SizedBox(
            width: maxW,
            height: maxH,
            child: pageViewWidget(maxW, maxH),
          )),
    );
  }

  <span class="hljs-comment">/// <span class="markdown">Banner部件</span></span>
  Widget bannerWidget(<span class="hljs-built_in">double</span> maxW) {
    <span class="hljs-keyword">return</span> Container(
        width: maxW,
        height: <span class="hljs-number">200</span>,
        alignment: Alignment.center,
        color: Colors.red.shade300,
        child: Text(<span class="hljs-string">'Banner'</span>, style: myTextStyle));
  }

  <span class="hljs-comment">/// <span class="markdown">Tabs部件</span></span>
  Widget tabsWidget(<span class="hljs-built_in">double</span> maxW) {
    <span class="hljs-keyword">return</span> Container(
      width: maxW,
      height: <span class="hljs-number">40</span>,
      color: Colors.blue.shade400,
      child: Row(
        children: [
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">0</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 1'</span>, style: myTextStyle),
              ),
            ),
          ),
          Expanded(
            child: GestureDetector(
              onTap: () {
                handleTabClick(<span class="hljs-number">1</span>);
              },
              child: Container(
                alignment: Alignment.center,
                child: Text(<span class="hljs-string">'Tab 2'</span>, style: myTextStyle),
              ),
            ),
          )
        ],
      ),
    );
  }

  <span class="hljs-comment">/// <span class="markdown">pageView部件</span></span>
  Widget pageViewWidget(<span class="hljs-built_in">double</span> maxW, <span class="hljs-built_in">double</span> maxH) {
    <span class="hljs-keyword">return</span> SingleChildScrollView(
        primary: <span class="hljs-keyword">true</span>,
        physics: <span class="hljs-keyword">const</span> BouncingScrollPhysics(),
        child: SizedBox(
          width: maxW,
          height: maxH,
          child: PageView(
            controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                pageIndex = index;
              });
            },
            children: [
              Container(
                  width: maxW,
                  height: <span class="hljs-number">1000</span>,
                  color: Colors.amberAccent,
                  alignment: Alignment.topCenter,
                  child: Text(<span class="hljs-string">'Page1'</span>, style: myTextStyle)),
              Container(
                  width: maxW,
                  height: <span class="hljs-number">1000</span>,
                  color: Colors.deepPurpleAccent,
                  alignment: Alignment.topCenter,
                  child: Text(<span class="hljs-string">'Page2'</span>, style: myTextStyle))
            ],
          ),
        ));
  }
}
</code></pre>
<h2 data-id="heading-3">4. 总结</h2>
<p>通过这段代码，我们成功地在 Flutter 中实现了一个具有吸顶 Tabs 的 PageView 效果。从引入必要的库，到定义组件和管理状态，再到构建具体的 UI 部件，每一步都紧密配合。ExtendedNestedScrollView组件的使用是实现吸顶效果的核心，而各个部件的合理布局和样式设置则让整个页面看起来更加美观和易于交互。</p>
<p>希望这篇文章能帮助你理解并在自己的 Flutter 项目中运用类似的功能。</p>
<hr/>
<blockquote>
<p>本次分享就到这儿啦，我是鹏多多，深耕前端的技术创作者，如果您看了觉得有帮助，欢迎评论，关注，点赞，转发，我们下次见~</p>
</blockquote>
<p>PS：在本页按F12，在console中输入document.getElementsByClassName('panel-btn')[0].click();有惊喜哦~</p>
<p><code>往期文章</code></p>
<ul>
<li><a href="https://juejin.cn/post/7583910637958807571" target="_blank" title="https://juejin.cn/post/7583910637958807571">flutter使用package_info_plus库获取应用信息的教程</a></li>
<li><a href="https://juejin.cn/post/7588680081327259690" target="_blank" title="https://juejin.cn/post/7588680081327259690">Flutter下拉刷新上拉加载侧拉刷新插件：easy_refresh全面使用指南</a></li>
<li><a href="https://juejin.cn/post/7583226204036513833" target="_blank" title="https://juejin.cn/post/7583226204036513833">flutter-使用EventBus实现组件间数据通信</a></li>
<li><a href="https://juejin.cn/post/7582808491582619684" target="_blank" title="https://juejin.cn/post/7582808491582619684">Flutter输入框TextField的属性与实战用法全面解析+示例</a></li>
<li><a href="https://juejin.cn/post/7581693431740448831" target="_blank" title="https://juejin.cn/post/7581693431740448831">Flutter自定义日历table_calendar完全指南+案例</a></li>
<li><a href="https://juejin.cn/post/7580389111921786943" target="_blank" title="https://juejin.cn/post/7580389111921786943">flutter-屏幕自适应插件flutter_screenutil教程全指南</a></li>
<li><a href="https://juejin.cn/post/7579101504289882166" target="_blank" title="https://juejin.cn/post/7579101504289882166">flutter-使用url_launcher打开链接/应用/短信/邮件和评分跳转等</a></li>
<li><a href="https://juejin.cn/post/7570923924365230143" target="_blank" title="https://juejin.cn/post/7570923924365230143">flutter图片选择库multi_image_picker_plus和image_picker的对比和使用解析</a></li>
<li><a href="https://juejin.cn/post/7568136081302978623" target="_blank" title="https://juejin.cn/post/7568136081302978623">解锁flutter弹窗新姿势：dialog-flutter_smart_dialog插件解读+案例</a></li>
<li><a href="https://juejin.cn/post/7559089440901545999" target="_blank" title="https://juejin.cn/post/7559089440901545999">flutter-切换状态显示不同组件10种实现方案全解析</a></li>
<li><a href="https://juejin.cn/post/7555079970491318308" target="_blank" title="https://juejin.cn/post/7555079970491318308">flutter-详解控制组件显示的两种方式Offstage与Visibility</a></li>
<li><a href="https://juejin.cn/post/7535358416182788122" target="_blank" title="https://juejin.cn/post/7535358416182788122">flutter-使用AnimatedDefaultTextStyle实现文本动画</a></li>
<li><a href="https://juejin.cn/post/7537339432291434496" target="_blank" title="https://juejin.cn/post/7537339432291434496">flutter-使用SafeArea组件处理各机型的安全距离</a></li>
<li><a href="https://juejin.cn/spost/7537593417099149321" target="_blank" title="https://juejin.cn/spost/7537593417099149321">flutter-实现渐变色边框背景以及渐变色文字</a></li>
<li><a href="https://juejin.cn/post/7543474419240370185" target="_blank" title="https://juejin.cn/post/7543474419240370185">flutter-使用confetti制作炫酷纸屑爆炸粒子动画</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-性能优化利器：Keep-Alive]]></title>    <link>https://juejin.cn/post/7601486204174581810</link>    <guid>https://juejin.cn/post/7601486204174581810</guid>    <pubDate>2026-02-02T01:35:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174581810" data-draft-id="7601441797118853171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-性能优化利器：Keep-Alive"/> <meta itemprop="keywords" content="前端,面试,Vue.js"/> <meta itemprop="datePublished" content="2026-02-02T01:35:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-性能优化利器：Keep-Alive
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T01:35:22.000Z" title="Mon Feb 02 2026 01:35:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在后台管理系统或长列表页面中，我们经常遇到这样的需求：从列表进入详情页，返回时希望列表滚动位置、搜索条件都能完美保留。Vue 内置的 <code>&lt;KeepAlive&gt;</code> 正是为此而生。本文将带你从基础用法出发，直击其背后的缓存算法原理。</p>
<hr/>
<h2 data-id="heading-1">一、 什么是 Keep-Alive？</h2>
<p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，用于<strong>缓存不活动的组件实例</strong>，而不是销毁它们。</p>
<ul>
<li><strong>核心价值</strong>：保留组件状态、避免重复渲染 DOM、提升用户体验。</li>
<li><strong>应用场景</strong>：表单多步骤切换、列表页返回流、详情页页签切换。</li>
</ul>
<hr/>
<h2 data-id="heading-2">二、 基础实战：结合 Vue Router 实现按需缓存</h2>
<p>在 Vue 中，我们通常结合路由的 <code>meta</code> 字段和 <code>&lt;router-view&gt;</code> 的插槽语法来实现。</p>
<h3 data-id="heading-3">1. 路由配置</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/router/index.ts</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory, <span class="hljs-title class_">RouteRecordRaw</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteRecordRaw</span>&gt; = [
    {
      <span class="hljs-attr">path</span>: <span class="hljs-string">'/your-path'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'YourComponentName'</span>,
      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/YourComponent.vue'</span>),
      <span class="hljs-attr">meta</span>: {
        <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 设置需要缓存</span>
      }
    }
];
</code></pre>
<h3 data-id="heading-4">2. 宿主容器配置</h3>
<p>在 <code>App.vue</code> 或主布局文件中，接着在对应<code>&lt;router-view&gt;</code>的中插入<code>&lt;keep-alive&gt;</code>，并设置<code>include</code>属性来匹配需要缓存的组件</p>
<p>代码段</p>
<pre><code class="hljs language-vue" lang="vue">  // includeComponents为对应的组件文件名称
  &lt;router-view v-slot="{ Component }"&gt;
    &lt;KeepAlive :include="includeComponents"&gt;
      &lt;component :is="Component" /&gt;
    &lt;/KeepAlive&gt;
  &lt;/router-view&gt;
</code></pre>
<hr/>
<h2 data-id="heading-5">三、 特有的生命周期钩子</h2>
<p>一旦组件被缓存，其正常的销毁流程将被“冻结”，取而代之的是两个专属钩子：</p>
<ul>
<li><strong><code>activated</code></strong>：组件<strong>被激活</strong>（初始化渲染或从缓存中恢复）时调用。此时可重新获取数据或重置滚动位置。</li>
<li><strong><code>deactivated</code></strong>：组件<strong>被停用</strong>（离开当前路由）时调用。此时可清理定时器或取消未完成的请求。</li>
</ul>
<blockquote>
<p><strong>⚠️ 注意</strong>：由于组件被缓存，<code>onBeforeUnmount</code> 和 <code>onUnmounted</code>（Vue 2 中的 <code>beforeDestroy</code> 和 <code>destroyed</code>）<strong>不会</strong>被触发。</p>
</blockquote>
<hr/>
<h2 data-id="heading-6">四、 深度进阶：Keep-Alive 的底层原理</h2>
<p><code>&lt;KeepAlive&gt;</code> 本质上是一个“无渲染组件”，它不渲染多余的 DOM，而是直接操作组件的 VNode。</p>
<h3 data-id="heading-7">1. 内存中的 Map 缓存</h3>
<p><code>Keep-Alive</code> 内部维护了一个 <code>cache</code> 对象（Map 结构）和一个 <code>keys</code> 队列（Array 结构）：</p>
<ul>
<li><strong>Cache</strong>：键是组件的 <code>key</code>，值是组件的 <code>vnode</code> 实例。</li>
<li><strong>Keys</strong>：记录缓存组件的顺序。</li>
</ul>
<h3 data-id="heading-8">2. 渲染函数逻辑</h3>
<p>当 <code>render</code> 函数执行时：</p>
<ol>
<li>获取内部包裹的组件节点。</li>
<li>查找 <code>cache</code> 中是否存在该组件的实例。</li>
<li><strong>存在</strong>：直接从缓存中获取实例，并更新该 key 在 <code>keys</code> 队列中的位置（移到最后）。</li>
<li><strong>不存在</strong>：将其加入缓存。</li>
</ol>
<h3 data-id="heading-9">3. LRU 缓存策略</h3>
<p>如果缓存的组件过多，内存会爆炸吗？不会。 Vue 使用了 <strong>LRU (Least Recently Used) 最近最少使用</strong> 算法。当缓存数量超过 <code>max</code> 属性设定的阈值时，Vue 会自动销毁 <code>keys</code> 队列中最久没被访问过的那个组件实例。</p>
<hr/>
<h2 data-id="heading-10">五、 总结</h2>
<ol>
<li><strong>组件名称 (name)</strong> ：<code>include</code> 匹配的是组件定义的 <code>name</code> 选项。在 Vue 3 <code>&lt;script setup&gt;</code> 中，如果你没有显式定义 <code>name</code>，Vue 会根据文件名自动生成，建议显式定义以防匹配失效。</li>
<li><strong>多级嵌套路由</strong>：如果你的 <code>&lt;router-view&gt;</code> 层级很深，每一层都需要配置 <code>&lt;KeepAlive&gt;</code> 才能保证整条路径上的状态都被保留。</li>
<li><strong>Key 的重要性</strong>：在 <code>&lt;component :is&gt;</code> 上绑定正确的 <code>:key</code>，能有效防止在切换相同组件不同参数（如 <code>/detail/1</code> 到 <code>/detail/2</code>）时出现缓存混乱。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快]]></title>    <link>https://juejin.cn/post/7601606188618367014</link>    <guid>https://juejin.cn/post/7601606188618367014</guid>    <pubDate>2026-02-02T00:37:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601606188618367014" data-draft-id="7592622563546972195" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-02-02T00:37:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="destinying"/> <meta itemprop="url" content="https://juejin.cn/user/896842287549703"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            性能优化之⽹络层⾯优化--让你的⽹站跑得⽐快递员还快
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/896842287549703/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    destinying
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:37:32.000Z" title="Mon Feb 02 2026 00:37:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    44
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">⽹络层⾯优化：让你的⽹站跑得⽐快递员还快</h2>
<blockquote>
<p>前言：本⽂纯属真实经历，如有雷同，纯属你也踩过坑。</p>
</blockquote>
<h3 data-id="heading-1">1. 浏览器缓存：别让⽤户重复下载你的"祖传代码"</h3>
<p>兄弟们，有没有遇到过这种情况？你明明已经优化过代码了，⽤户还是说"⽹站怎么还是那个样⼦？"然后你⼀脸懵逼地发现：浏览器缓存还在使⽤你上个月写的"屎⼭代码"。</p>
<p><strong>浏览器缓存就像是那个记性超好的前女友</strong>，你改了什么她都记得，但就是不愿意承认你已经变了。</p>
<h4 data-id="heading-2">1.1 LocalStorage ⼀把梭？快住手！</h4>
<p>很多同学喜欢把什么东西都往 LocalStorage ⾥塞，恨不得把整个项⽬都存进去。听我⼀句劝，LocalStorage 就像你的钱包，别什么都往⾥塞，否则哪天爆了就尴尬了。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示范</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'整个项目'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(yourProject))

<span class="hljs-comment">// ✅ 正确姿势：封装一下，加上过期时间</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Storage</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value, expire = <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span></span>) {
    <span class="hljs-keyword">const</span> data = {
      value,
      <span class="hljs-attr">expire</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + expire
    }
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key))
    <span class="hljs-keyword">if</span> (!data) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt; data.<span class="hljs-property">expire</span>) {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">return</span> data.<span class="hljs-property">value</span>
  }
}

<span class="hljs-comment">// 使用起来更优雅</span>
<span class="hljs-title class_">Storage</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'userInfo'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> })
<span class="hljs-keyword">const</span> user = <span class="hljs-title class_">Storage</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'userInfo'</span>)
</code></pre>
<h4 data-id="heading-3">1.2 SessionStorage 是"露⽔情缘"</h4>
<p>关掉标签页就拜拜，不多废话。适合存那些"⽤完即弃"的数据，⽐如表单暂存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 表单暂存示例，防止用户误操作丢失数据</span>
<span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#myForm'</span>)

<span class="hljs-comment">// 输入时自动保存</span>
form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form)
  sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'formData'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(formData)))
})

<span class="hljs-comment">// 页面加载时恢复</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> saved = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'formData'</span>)
  <span class="hljs-keyword">if</span> (saved) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(saved)
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
      form.<span class="hljs-property">elements</span>[key].<span class="hljs-property">value</span> = data[key]
    })
  }
})

<span class="hljs-comment">// 提交后清除</span>
form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'submit'</span>, <span class="hljs-function">() =&gt;</span> {
  sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'formData'</span>)
})
</code></pre>
<h4 data-id="heading-4">1.3 IndexedDB？那是真的猛</h4>
<p>当你需要存点⼤东西的时候，⽐如离线缓存、图片啥的，IndexedDB 才是你的菜。虽然 API 设计得像迷宫，但好歹是个迷宫⾥有宝藏的那种。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ⼿写 IndexedDB 简直折磨，推荐⽤ idb 这个库</span>
<span class="hljs-keyword">import</span> { openDB } <span class="hljs-keyword">from</span> <span class="hljs-string">'idb'</span>

<span class="hljs-comment">// 初始化数据库</span>
<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">'myDB'</span>, <span class="hljs-number">1</span>, {
  <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">db</span>) {
    <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'images'</span>)) {
      db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">'images'</span>, { <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'id'</span> })
    }
  }
})

<span class="hljs-comment">// 存储图片</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">saveImage</span>(<span class="hljs-params">id, blob</span>) {
  <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">put</span>(<span class="hljs-string">'images'</span>, { id, blob, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() })
}

<span class="hljs-comment">// 读取图片</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getImage</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">get</span>(<span class="hljs-string">'images'</span>, id)
}
</code></pre>
<h4 data-id="heading-5">1.4 Cache API：PWA 的灵魂</h4>
<p>想做 PWA？Cache API 必须得会。它能让你在离线状态下也能访问⽹站，简直是⽹络开⼩差时的救命稻草。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// sw.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">'my-cache-v1'</span>
<span class="hljs-keyword">const</span> urlsToCache = [
  <span class="hljs-string">'/'</span>,
  <span class="hljs-string">'/styles/main.css'</span>,
  <span class="hljs-string">'/scripts/main.js'</span>,
  <span class="hljs-string">'/images/logo.png'</span>
]

<span class="hljs-comment">// 安装时缓存静态资源</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'install'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(
    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">cache</span>) =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache))
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())
  )
})

<span class="hljs-comment">// 拦截请求，优先从缓存读取</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'fetch'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">respondWith</span>(
    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-comment">// 缓存命中直接返回，否则⾛网络</span>
        <span class="hljs-keyword">return</span> response || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
          <span class="hljs-comment">// 把新资源缓存起来</span>
          <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
            cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, response.<span class="hljs-title function_">clone</span>())
            <span class="hljs-keyword">return</span> response
          })
        })
      })
  )
})

<span class="hljs-comment">// 更新缓存</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'activate'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> cacheWhitelist = [<span class="hljs-variable constant_">CACHE_NAME</span>]
  event.<span class="hljs-title function_">waitUntil</span>(
    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">cacheNames</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">cacheName</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (cacheWhitelist.<span class="hljs-title function_">indexOf</span>(cacheName) === -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName)
          }
        })
      )
    })
  )
})
</code></pre>
<h4 data-id="heading-6">1.5 小贴士</h4>
<ul>
<li>给缓存加点过期时间，别让⽤户的手机变成了你的"垃圾场"</li>
<li>敏感数据别存缓存，不然哪天被抓包了别怪我没提醒你</li>
<li>定期清理缓存，就像打扫房间⼀样重要</li>
</ul>
<h3 data-id="heading-7">2. 资源压缩：让体积缩⽔，让速度起飞</h3>
<p>说真的，资源压缩是最简单也最有效的优化手段。⽤好了，能减少 70%+ 的传输体积；⽤不好，⽤户加载时就像在等快递。</p>
<h4 data-id="heading-8">2.1 Gzip/Brotli 压缩</h4>
<p>这个主要是后端和运维配置的，但前端也要知道原理。Gzip 能压缩到原体积的 30-40%，Brotli 更强，能到 20-30%。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vite 开发环境也开启压缩</span>
<span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Encoding'</span>: <span class="hljs-string">'gzip'</span>
    }
  }
})
</code></pre>
<p><strong>告诉后端大佬：</strong></p>
<ul>
<li>HTML、CSS、JS、JSON 都要开启 Gzip/Brotli</li>
<li>图片、视频这类已经压缩过的文件就不用再压了</li>
<li>生产环境优先用 Brotli，兼容性用 Gzip</li>
</ul>
<h4 data-id="heading-9">2.2 代码压缩：Tree Shaking + 压缩工具</h4>
<p>现代构建工具（Vite、Webpack）都内置了这些功能，配置好就行。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],

  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 开启 CSS 代码分割</span>
    <span class="hljs-attr">cssCodeSplit</span>: <span class="hljs-literal">true</span>,

    <span class="hljs-comment">// 设置 chunk 大小警告阈值（kb）</span>
    <span class="hljs-attr">chunkSizeWarningLimit</span>: <span class="hljs-number">1000</span>,

    <span class="hljs-comment">// 压缩配置</span>
    <span class="hljs-attr">minify</span>: <span class="hljs-string">'terser'</span>,
    <span class="hljs-attr">terserOptions</span>: {
      <span class="hljs-attr">compress</span>: {
        <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生产环境去掉 console</span>
        <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 生产环境去掉 debugger</span>
      }
    },

    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-comment">// 开启 Tree Shaking</span>
        <span class="hljs-attr">treeshake</span>: <span class="hljs-literal">true</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-10">2.3 图片压缩：体积减半，体验翻倍</h4>
<p>很多同学直接把设计师给的原图放上去，一张图好几 MB，⽤户加载要等半天。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite-plugin-imagemin：自动压缩图片</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> viteImagemin <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-imagemin'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">viteImagemin</span>({
      <span class="hljs-attr">gifsicle</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">optipng</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">mozjpeg</span>: { <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span> },
      <span class="hljs-attr">pngquant</span>: { <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>] },
      <span class="hljs-attr">svgo</span>: {
        <span class="hljs-attr">plugins</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeViewBox'</span> },
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeEmptyAttrs'</span> }
        ]
      }
    })
  ]
})
</code></pre>
<p><strong>更简单的方法：用在线工具</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftinypng.com%2F" target="_blank" title="https://tinypng.com/" ref="nofollow noopener noreferrer">TinyPNG</a>：免费，压缩效果好</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsquoosh.app%2F" target="_blank" title="https://squoosh.app/" ref="nofollow noopener noreferrer">Squoosh</a>：Google 出品，功能强大</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fimageoptim.com%2F" target="_blank" title="https://imageoptim.com/" ref="nofollow noopener noreferrer">ImageOptim</a>：Mac 专用，拖进去就行</li>
</ul>
<h4 data-id="heading-11">2.4 WebP 格式：新时代的图片格式</h4>
<p>WebP 比传统格式（JPG、PNG）小 25-35%，质量还更好。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 传统写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 优化写法：支持 WebP 用 WebP，不支持降级到 JPG --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"image.webp"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/webp"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 自动转 WebP：vite-plugin-webp</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> webp <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-webp'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">webp</span>({
      <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span>,
      <span class="hljs-attr">enablePlugin</span>: <span class="hljs-literal">true</span>
    })
  ]
})
</code></pre>
<h4 data-id="heading-12">2.5 雪碧图 vs SVG Sprite</h4>
<p>过去常用雪碧图，现在更推荐 SVG Sprite。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite-plugin-svg-icons</span>
<span class="hljs-keyword">import</span> { createSvgIconsPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-svg-icons'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">createSvgIconsPlugin</span>({
      <span class="hljs-attr">iconDirs</span>: [path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">'src/assets/icons'</span>)],
      <span class="hljs-attr">symbolId</span>: <span class="hljs-string">'icon-[name]'</span>
    })
  ]
})
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 在组件中使用 --&gt;
&lt;svg&gt;
  &lt;use xlink:href="#icon-user" /&gt;
&lt;/svg&gt;
</code></pre>
<h4 data-id="heading-13">2.6 按需加载：只加载需要的</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 一次性加载所有组件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">Select</span>, <span class="hljs-title class_">Table</span>, <span class="hljs-title class_">Form</span>, ... } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>

<span class="hljs-comment">// ✅ 按需加载</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>

<span class="hljs-comment">// 或者用动态导入</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Table</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'element-ui/lib/table'</span>)

<span class="hljs-comment">// Vue 路由懒加载</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/Home.vue'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title function_">About</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/About.vue'</span>)

<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span> }
]
</code></pre>
<h3 data-id="heading-14">3. DNS 缓存：让你的⽹址解析⽐点外卖还快</h3>
<p>DNS 解析就像是查电话本，你每次访问⽹站都要先查⼀下 IP 地址。但如果每次都要查，那就太慢了。</p>
<h4 data-id="heading-15">3.1 DNS 预取（DNS Prefetching）</h4>
<p>提前告诉浏览器"嘿，等下⼉可能要去这个域名，先把电话查好"。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 在 HTML head 中添加 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://api.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://static.example.com"</span>&gt;</span>
</code></pre>
<p><strong>使用场景：</strong></p>
<ul>
<li>CDN 域名</li>
<li>第三方 API 域名</li>
<li>统计分析域名（如 Google Analytics）</li>
<li>字体服务域名（如 Google Fonts）</li>
</ul>
<h4 data-id="heading-16">3.2 预连接（Preconnect）</h4>
<p>预连接比 DNS 预取更进一步，它不仅解析 DNS，还会建立 TCP 连接和 TLS 握手。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 适用于必定会使用的域名 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://api.example.com"</span>&gt;</span>
</code></pre>
<p><strong>注意：</strong> 不要滥用，每个预连接都会消耗资源。只用于必定会加载的域名。</p>
<h4 data-id="heading-17">3.3 域名收敛</h4>
<p>一个网站用太多域名会降低性能。HTTP/1.1 时代需要域名分片来突破浏览器并发限制，现在 HTTP/2 多路复用反而收敛更好。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 太多域名</span>
&lt;img src=<span class="hljs-string">"https://cdn1.example.com/a.jpg"</span>&gt;
&lt;img src="https://cdn2.example.com/b.jpg"&gt;
&lt;img src="https://cdn3.example.com/c.jpg"&gt;

// ✅ 收敛到 1-2 个域名
&lt;img src="https://cdn.example.com/a.jpg"&gt;
&lt;img src="https://cdn.example.com/b.jpg"&gt;
&lt;img src="https://cdn.example.com/c.jpg"&gt;
</code></pre>
<p><strong>实战经验：</strong></p>
<ul>
<li>静态资源用 1 个 CDN 域名</li>
<li>API 用 1 个域名</li>
<li>总共不超过 2-3 个域名</li>
</ul>
<h3 data-id="heading-18">4. CDN：让你的⽹站遍布全球</h3>
<p>CDN 是什么？简单说，就是把你的⽹站复制到世界各地，让⽤户访问最近的节点。</p>
<h4 data-id="heading-19">4.1 CDN 的好处</h4>
<ul>
<li><strong>速度提升</strong>：⽤户访问就近节点，延迟降低</li>
<li><strong>减轻服务器压力</strong>：流量分摊到各个节点</li>
<li><strong>提升可用性</strong>：某个节点挂了，其他节点还能⽤</li>
</ul>
<h4 data-id="heading-20">4.2 前端资源文件名 hash 策略</h4>
<p>这是前端使用 CDN 的关键！只有文件名带了 hash，才能放心设置长期缓存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash:8].js'</span>,
    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'[name].[contenthash:8].chunk.js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">'asset/resource'</span>,
        <span class="hljs-attr">generator</span>: {
          <span class="hljs-attr">filename</span>: <span class="hljs-string">'images/[name].[contenthash:8][ext]'</span>
        }
      }
    ]
  }
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'assets/[name].[hash].[ext]'</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-21">4.3 Cloudflare Workers 前端实战</h4>
<p>现在的 CDN 不止是存静态资源，还能在边缘节点运⾏代码。Cloudflare Workers 咱们前端可以自己写。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Cloudflare Workers 示例：边缘图片压缩</span>
<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>))
})

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>)

  <span class="hljs-comment">// 检测是否是图片请求</span>
  <span class="hljs-keyword">if</span> (url.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\.(jpg|jpeg|png|webp)$/</span>)) {
    <span class="hljs-comment">// 检查 URL 参数</span>
    <span class="hljs-keyword">const</span> quality = <span class="hljs-built_in">parseInt</span>(url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'quality'</span>)) || <span class="hljs-number">80</span>
    <span class="hljs-keyword">const</span> format = url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'format'</span>) || <span class="hljs-string">'webp'</span>

    <span class="hljs-comment">// 从源站获取图片</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request)

    <span class="hljs-comment">// 转换图片格式和压缩（使用 WebAssembly 实现的图片处理库）</span>
    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>()
    <span class="hljs-keyword">const</span> compressed = <span class="hljs-keyword">await</span> <span class="hljs-title function_">compressImage</span>(image, { quality, format })

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(compressed, {
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">`image/<span class="hljs-subst">${format}</span>`</span>,
        <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'public, max-age=31536000'</span>
      }
    })
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(request)
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compressImage</span>(<span class="hljs-params">imageBuffer, options</span>) {
  <span class="hljs-comment">// 使用前端熟悉的库（如 sharp-wasm）</span>
  <span class="hljs-keyword">const</span> sharp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sharp-wasm'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">sharp</span>(imageBuffer)
    .<span class="hljs-title function_">webp</span>({ <span class="hljs-attr">quality</span>: options.<span class="hljs-property">quality</span> })
    .<span class="hljs-title function_">toBuffer</span>()
}
</code></pre>
<h4 data-id="heading-22">4.4 实战案例</h4>
<p>之前一个视频⽹站，⽤户遍布全球。没⽤ CDN 的时候，国外⽤户加载要 30 秒；⽤了 CDN 之后，⼤部分地区 3 秒内加载完成。这提升，⾹！</p>
<h4 data-id="heading-23">4.5 注意事项</h4>
<ul>
<li>CDN 节点的缓存要及时更新，不然你改了 bug ⽤户还是看旧版</li>
<li>HTTPS 证书要配好，CDN 和源站都要配</li>
<li>⽇志收集要考虑 CDN 的影响，不然统计数据会偏</li>
<li>告诉运维大佬：静态资源（带 hash 的）可以设置长期缓存，index.html 不要缓存</li>
</ul>
<h3 data-id="heading-24">5. 渲染层⾯优化：让页⾯流畅如丝</h3>
<p>网络层面的优化让资源加载更快，但渲染层面的优化让用户体验更好。</p>
<h4 data-id="heading-25">5.1 关键渲染路径优化</h4>
<p>浏览器渲染页面的流程：DOM → CSSOM → Render Tree → Layout → Paint</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- ❌ 阻塞渲染的写法 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"large.css"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-comment">&lt;!-- 阻塞后续内容 --&gt;</span>

<span class="hljs-comment">&lt;!-- ✅ 优化写法 --&gt;</span>
<span class="hljs-comment">&lt;!-- 内联关键 CSS --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-comment">/* 首屏必需的样式 */</span>
  <span class="hljs-selector-class">.header</span> { <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>; }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 非关键样式异步加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"non-critical.css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"this.onload=null;this.rel='stylesheet'"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"non-critical.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>

<span class="hljs-comment">&lt;!-- JS 放到底部或异步加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"analytics.js"</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 data-id="heading-26">5.2 图片懒加载：只加载用户能看到的</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Intersection Observer API（现代浏览器支持）</span>
<span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'img.lazy'</span>)

<span class="hljs-keyword">const</span> imageObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
      <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>
      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>
      img.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'lazy'</span>)
      observer.<span class="hljs-title function_">unobserve</span>(img)
    }
  })
})

lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> imageObserver.<span class="hljs-title function_">observe</span>(img))
</code></pre>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- HTML 使用方式 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy"</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">"image.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"示例图片"</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- Vue 懒加载组件 --&gt;
&lt;template&gt;
  &lt;img v-lazy="imageUrl" alt="示例图片"&gt;
&lt;/template&gt;

&lt;script&gt;
import { lazyLoad } from '@/directives/lazyLoad'

export default {
  directives: {
    lazy: lazyLoad
  },
  data() {
    return {
      imageUrl: 'https://example.com/image.jpg'
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-27">5.3 虚拟列表：长列表性能救星</h4>
<p>如果列表有几千条数据，全部渲染会让页面卡顿。虚拟列表只渲染可见区域的项目。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vue-virtual-scroller 示例</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RecycleScroller</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-virtual-scroller'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'vue-virtual-scroller/dist/vue-virtual-scroller.css'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">RecycleScroller</span>
  },
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">items</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
        <span class="hljs-attr">id</span>: i,
        <span class="hljs-attr">text</span>: <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
      }))
    }
  }
}
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;RecycleScroller
    class="scroller"
    :items="items"
    :item-size="50"
    key-field="id"
  &gt;
    &lt;template #default="{ item }"&gt;
      &lt;div class="item"&gt;{{ item.text }}&lt;/div&gt;
    &lt;/template&gt;
  &lt;/RecycleScroller&gt;
&lt;/template&gt;

&lt;style&gt;
.scroller {
  height: 400px;
}

.item {
  height: 50px;
  line-height: 50px;
  border-bottom: 1px solid #eee;
}
&lt;/style&gt;
</code></pre>
<h4 data-id="heading-28">5.4 防抖和节流：优化高频事件</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 防抖：只执行最后一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-keyword">let</span> timer
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-built_in">clearTimeout</span>(timer)
    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args), delay)
  }
}

<span class="hljs-comment">// 节流：固定时间执行一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) {
      lastTime = now
      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)
    }
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'search'</span>)

<span class="hljs-comment">// 搜索输入防抖</span>
searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'搜索:'</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
}, <span class="hljs-number">300</span>))

<span class="hljs-comment">// 滚动节流</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'滚动位置:'</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>)
}, <span class="hljs-number">100</span>))
</code></pre>
<h4 data-id="heading-29">5.5 代码分割：按需加载</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 路由懒加载</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/Home.vue'</span>)
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/About.vue'</span>)
  }
]

<span class="hljs-comment">// 组件懒加载</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-title class_">HeavyComponent</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/components/HeavyComponent.vue'</span>)
  }
}

<span class="hljs-comment">// 条件加载</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (needsFeature) {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/features/advanced'</span>)
    <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">doSomething</span>()
  }
}
</code></pre>
<h4 data-id="heading-30">5.6 减少 DOM 操作</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 频繁操作 DOM</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
  div.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div)
}

<span class="hljs-comment">// ✅ 使用 DocumentFragment</span>
<span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
  div.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>
  fragment.<span class="hljs-title function_">appendChild</span>(div)
}

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(fragment)

<span class="hljs-comment">// ✅ 或者使用 innerHTML 一次性插入</span>
<span class="hljs-keyword">let</span> html = <span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  html += <span class="hljs-string">`&lt;div&gt;Item <span class="hljs-subst">${i}</span>&lt;/div&gt;`</span>
}
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = html
</code></pre>
<h4 data-id="heading-31">5.7 使用 CSS3 动画代替 JS 动画</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* ❌ JS 动画（性能差） */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">transition</span>: none;
}

<span class="hljs-comment">/* ✅ CSS3 动画（性能好） */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> ease;
}

<span class="hljs-comment">/* 更好的：使用 will-change 提示浏览器优化 */</span>
<span class="hljs-selector-class">.element</span> {
  <span class="hljs-attribute">will-change</span>: transform;
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ JS 实现动画</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">let</span> position = <span class="hljs-number">0</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    position += <span class="hljs-number">10</span>
    element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = position + <span class="hljs-string">'px'</span>
  }, <span class="hljs-number">16</span>)
}

<span class="hljs-comment">// ✅ 使用 CSS3</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">element</span>) {
  element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'translateX(100px)'</span>
  element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">'transform 0.3s ease'</span>
}
</code></pre>
<h4 data-id="heading-32">5.8 Web Worker：把繁重计算放到后台线程</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'./worker.js'</span>)

worker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">data</span>: largeData })

worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'计算结果:'</span>, e.<span class="hljs-property">data</span>.<span class="hljs-property">result</span>)
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// worker.js</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">heavyCalculation</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>)
  self.<span class="hljs-title function_">postMessage</span>({ result })
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">heavyCalculation</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-comment">// 耗时计算</span>
  <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)
}
</code></pre>
<h3 data-id="heading-33">综合实战：打造一套完整的前端性能优化方案</h3>
<p>讲了这么多，怎么组合起来用？来个真实案例，纯前端操作：</p>
<h4 data-id="heading-34">项目结构</h4>
<pre><code class="hljs language-arduino" lang="arduino">my-project/
├── <span class="hljs-keyword">public</span>/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── assets/
│   │   ├── images/
│   │   └── styles/
│   ├── components/
│   ├── utils/
│   │   ├── cache.js
│   │   └── request.js
│   ├── sw.js
│   └── main.js
└── vite.config.js
</code></pre>
<h4 data-id="heading-35">完整配置（vite.config.js）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
<span class="hljs-keyword">import</span> viteImagemin <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-imagemin'</span>
<span class="hljs-keyword">import</span> webp <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-webp'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">vue</span>(),
    <span class="hljs-title function_">viteImagemin</span>({
      <span class="hljs-attr">gifsicle</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">optipng</span>: { <span class="hljs-attr">optimizationLevel</span>: <span class="hljs-number">7</span> },
      <span class="hljs-attr">mozjpeg</span>: { <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span> },
      <span class="hljs-attr">svgo</span>: {
        <span class="hljs-attr">plugins</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeViewBox'</span> },
          { <span class="hljs-attr">name</span>: <span class="hljs-string">'removeEmptyAttrs'</span> }
        ]
      }
    }),
    <span class="hljs-title function_">webp</span>({
      <span class="hljs-attr">quality</span>: <span class="hljs-number">80</span>
    })
  ],

  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'assets/[name].[hash].js'</span>,
        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'assets/[name].[hash].[ext]'</span>
      }
    },
    <span class="hljs-attr">cssCodeSplit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">minify</span>: <span class="hljs-string">'terser'</span>,
    <span class="hljs-attr">terserOptions</span>: {
      <span class="hljs-attr">compress</span>: {
        <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">drop_debugger</span>: <span class="hljs-literal">true</span>
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-36">HTML 优化（index.html）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- DNS 预取 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.example.com"</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 内联关键 CSS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-comment">/* 首屏必需的样式 */</span>
  <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: -apple-system, BlinkMacSystemFont, sans-serif; }
  <span class="hljs-selector-class">.header</span> { <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>; <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>; }
  <span class="hljs-selector-class">.loading</span> { <span class="hljs-attribute">position</span>: fixed; <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>; <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 非关键样式异步加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/assets/style.[hash].css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"this.onload=null;this.rel='stylesheet'"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/assets/style.[hash].css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading"</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 脚本异步加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/main.[hash].js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-37">性能监控（utils/performance.js）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trackPerformance</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-string">'PerformanceObserver'</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
    <span class="hljs-comment">// 监控资源加载</span>
    <span class="hljs-keyword">const</span> resourceObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">transferSize</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✓ 缓存命中: <span class="hljs-subst">${entry.name}</span>`</span>)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✗ 网络加载: <span class="hljs-subst">${entry.name}</span> (<span class="hljs-subst">${(entry.transferSize / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>)}</span>KB)`</span>)
        }
      }
    })
    resourceObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'resource'</span>] })

    <span class="hljs-comment">// 监控长任务</span>
    <span class="hljs-keyword">const</span> longTaskObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️ 长任务: <span class="hljs-subst">${entry.name}</span> (<span class="hljs-subst">${entry.duration}</span>ms)`</span>)
      }
    })
    longTaskObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'longtask'</span>] })
  }
}

<span class="hljs-comment">// 在 main.js 中调用</span>
<span class="hljs-title function_">trackPerformance</span>()
</code></pre>
<h3 data-id="heading-38">总结</h3>
<p>性能优化不是⼀蹴⽽就的，需要持续迭代。记住⼏个原则：</p>
<ol>
<li><strong>能缓存的尽量缓存</strong>，让⽤户少等⼏秒</li>
<li><strong>能压缩的尽量压缩</strong>，体积小了传输就快</li>
<li><strong>DNS 预取和预连接</strong>，提前做好准备</li>
<li><strong>CDN 是神器</strong>，让全球用户都能快速访问</li>
<li><strong>渲染优化很重要</strong>，加载快不等于体验好</li>
<li><strong>懒加载和按需加载</strong>，只加载用户需要的</li>
<li><strong>监控要跟上</strong>，不然你都不知道优化有没有⽤</li>
</ol>
<p>最后，如果你觉得这篇⽂章对你有帮助，<strong>点个赞呗</strong>！如果觉得有问题，<strong>评论区喷我</strong>，我抗揍。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小伙伴们心心念念的倒水解谜游戏实战，终于来了...]]></title>    <link>https://juejin.cn/post/7601313474720153635</link>    <guid>https://juejin.cn/post/7601313474720153635</guid>    <pubDate>2026-02-02T00:48:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601313474720153635" data-draft-id="7601313474720137251" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小伙伴们心心念念的倒水解谜游戏实战，终于来了..."/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-02T00:48:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="亿元程序员"/> <meta itemprop="url" content="https://juejin.cn/user/1972988307323236"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小伙伴们心心念念的倒水解谜游戏实战，终于来了...
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972988307323236/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    亿元程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:48:34.000Z" title="Mon Feb 02 2026 00:48:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29de9e6a984a4a4aa4df459288678379~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=G%2FXNaaGLi4TdRAs8FfKrk0gG4GI%3D" alt="我倒我倒我倒倒倒" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p><strong>哈喽大家好</strong>，我是亿元程序员。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf088b4ce51345908d692577786c920c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=PnIKqmnheiGfbJyT7VvFI9iaTDs%3D" alt="亿元Cocos小游戏实战合集" loading="lazy"/></p>
<p><strong>笔者的</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">《亿元Cocos小游戏实战合集》</a>，从更新的第一天开始，就有许多小伙伴问到，什么时候更新一期倒水解谜的游戏实战？</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab9e7c3d6748450fa7490c5ffb4454cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=hKLeTWubroIfDcCYpjau81otyMo%3D" alt="快更新，别逼我催你" loading="lazy"/></p>
<p><strong>其实</strong>笔者早有计划，再加上小伙伴们的强烈需求，这一期，<strong>小伙伴们心心念念的倒水解谜游戏实战，终于来了...</strong></p>
<p><strong>言归正传</strong>，本期带大家一起来看看，在<code>Cocos</code>游戏开发中，<strong>倒水解谜游戏的核心部分</strong>，并加入到我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">《亿元Cocos小游戏实战合集》</a>中去。</p>
<p><strong>本文源工程可在文末获取，小伙伴们自行前往。</strong></p>
<h2 data-id="heading-1">什么是倒水解谜游戏？</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f0be8ff2226494b8fa12c8dc1dfb1aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=ODNeeAjVtQJarPM5ApbihZKQ2Lc%3D" alt="简单易上手，看了就想玩" loading="lazy"/></p>
<p><strong>可能</strong>有很多小伙伴还不知道这类游戏，简单介绍一下:</p>
<blockquote>
<p><strong>倒水解谜游戏</strong>是一类以 “倒水 / 液体转移” 为核心玩法的休闲益智游戏。</p>
<p><strong>玩家</strong>需通过容器间的倾倒操作达成特定目标（如液体颜色统一、精确容量分配），核心考验逻辑推理与步骤规划能力。</p>
</blockquote>
<p><strong>通俗</strong>的理解，和我们在学校时，通过水杯倒来倒去得到指定毫升数的水相类似(<strong>瞎掰的</strong>)。</p>
<p><strong>既然是倒水游戏，水是重要的一个游戏元素，那它是怎么实现的呢？</strong></p>
<h2 data-id="heading-2">水的效果</h2>
<p><strong>关于</strong>水的效果，其实有比较多的实现方法，既可以通过美术妹子实现，也可以通过<code>Shader</code>实现，甚至还能用<code>Graphics</code>组件画！</p>
<blockquote>
<p><strong>美术妹子:</strong> “一边凉快去。”</p>
</blockquote>
<p><strong>既然</strong>上面的方法行不通，我们只能通过<code>Shader</code>来实现了，至于<code>Graphics</code>，小伙伴们可以自行挑战一下。</p>
<p><strong>1. 资源准备</strong></p>
<p><strong>简单准备</strong>一张杯子形状的图片和对应杯子形状纯白<code>Mask</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf71a45c8ac64d048d31b17177d08ba4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=CDO4xmo1DmheVfBf6HE5B1oALYY%3D" alt="铁粉友情助攻" loading="lazy"/></p>
<p><strong>简单</strong>拼一下<code>UI</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa6d2bff3d1a4af5844bc33ae90ebab4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=pL%2B8RNzG3FL4ZXL2lZDaFU%2B5sz8%3D" alt="最喜欢拼UI了，没有之一" loading="lazy"/></p>
<p><strong>通过</strong>资源管理器通过<code>右键-&gt;创建-&gt;传统无光照着色器(Effect)</code>创建一个<code>Shader</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03680798a0fd4b14ad594d52a0f49c5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=tNcoUZQbyFJdUKZM%2FJTT0Lrjazw%3D" alt="手把手" loading="lazy"/></p>
<p><strong>和上面一样</strong>创建一个材质，将对应的<code>Effect</code>改成我们自己创建的并且勾选<code>USE_TEXTURE</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e23eb2a414ea4f4980dcb44325ccc9ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=7%2FVEsals2pdHg6fl%2FDN2mKyJr9w%3D" alt="脚把脚" loading="lazy"/></p>
<p><strong>然后</strong>把材质拖到我们杯子的<code>Mask</code>的<code>Sprite</code>上，实际要在代码中动态创建，不然会共用同一个材质。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e376e6f4dccd4daf99923ed0e00f58b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=lWBqdDcx6qz07mCY%2BnjSlIEZW00%3D" alt="演示用" loading="lazy"/></p>
<p><strong>2. 水的颜色</strong></p>
<p><strong>搜索</strong><code>sprite</code>找到<code>builtin-sprite</code>，双击打开把内容复制到我们创建的<code>Shader</code>中去当做模板。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e71416a7877e4116a6f69e2b2b0e2ac2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=u8UpHItdjW3riX77udfCOfbTv0c%3D" alt="" loading="lazy"/></p>
<p><strong>想要修改</strong>水的颜色，我们可以找到最下面的片段着色器，将<code>color</code>改成红色<code>vec4(1,0,0,1);</code>，分别对应<code>RGBA</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/367df1ec96394ccfb82a6760e4cc8b4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=BvNTWo8kiKf30hP8culPvtrlrOk%3D" alt="硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/295c29b774e648e6a829aa683040c3b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=O6Q%2F1vQyutTWAlgWwqw2TRv%2FOpY%3D" alt="火红的烧杯" loading="lazy"/></p>
<p><strong>3. 水的分层</strong></p>
<p><strong>想要实现</strong>水的分层，我们可以通过简单<code>UV</code>划分，下半部分为蓝色，上半部分为红色，实际项目可以通过实际水的高度去划分。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0238e81c8e8d4e0c9673093ee235a6d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=68cFqdwS2etEZs3ewyihOhoViHM%3D" alt="还是硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/925c4eb260814533b72413501194dbaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=wgp2S%2FCssA04nH45Ky5hhOTGktE%3D" alt="自古红蓝出CP" loading="lazy"/></p>
<p><strong>4. 水的波纹</strong></p>
<p><strong>水倒下时</strong>，会在杯子中形成波纹，我们可以通过下面的公式来实现。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50f60e03f62140e0b31544c2eb4996a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=%2BdYMAjEHuFnB6qremfz6cZt%2BNBw%3D" alt="非必要情况下别记" loading="lazy"/></p>
<p><strong>测试Shader</strong>如下，当<code>UV</code>高于指定高度时，形成波纹。使用<code>cc_time</code>时，需要在片段开始时引入<code>#include &lt;cc-global&gt;</code>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4a575f1f74f41cdadb3155d90130059~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=x9aGLPekg1KQ6zDMjYH582kAs88%3D" alt="依旧是硬编码" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc3e7ceea1eb4ee58554b22e2782a64b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=IhjzVt09G2FF0HSolUqJ63mDDrk%3D" alt="火辣辣的波纹" loading="lazy"/></p>
<p><strong>5. 水的倾斜</strong></p>
<p><strong>水的倾斜</strong>可以通过下面的函数进行。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/48606754b5364293a23a049aed96f7c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=aRBZDVlrw6oqdSMoPT2wXnD8vqs%3D" alt="AI一个接一个不吱声" loading="lazy"/></p>
<p><strong>效果如下：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b637f2323bee4affb877df0d24d7489a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=yeMrkQHCZrTtixGIT4upXUYxlJQ%3D" alt="还真有效果" loading="lazy"/></p>
<p><strong>相信</strong>通过上面的内容，大家都已经学会了如何在<code>Shader</code>中模拟水的效果。</p>
<p><strong>那我们要怎么样在实际游戏中进行通过代码控制动态结合呢？</strong></p>
<h2 data-id="heading-3">动态传值到Shader</h2>
<p><strong>想要</strong>通过代码动态传值到<code>Shader</code>，我们通常要通过以下几个步骤。</p>
<p><strong>1.Properties</strong></p>
<blockquote>
<p><strong>properties</strong>用于将<code>Shader</code>中定义的<code>uniform</code>进行别名映射。</p>
<p><strong>这个映射</strong>可以是某个<code>uniform</code>的完整映射，也可以是具体某个分量的映射（使用<code>target</code>参数）。</p>
</blockquote>
<p><strong>代码示例如下，</strong><code>colors</code>和<code>heights</code>可以传<code>vec4</code>数组，<code>iResult</code>是<code>vec2</code>，其余是数值。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/848fcd802eac4d1c995752d86dd5a4cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=LANbMk6hm3pO99gyHjGXmSR7%2FD0%3D" alt="很简单的" loading="lazy"/></p>
<p><strong>2.uniform</strong></p>
<p><strong>uniform</strong>是<code>GLSL</code>中的关键字，声明的变量表示全局统一变量:</p>
<ul>
<li>
<p><strong>它的值</strong>在一次绘制调用中保持不变（对所有像素 / 顶点都相同）。</p>
</li>
<li>
<p><strong>可以从</strong><code>CPU</code>端（游戏逻辑代码）直接赋值，<code>GPU</code>端（着色器）只读。</p>
</li>
<li>
<p><strong>常用于</strong>传递动态参数（如颜色、角度、纹理等）。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9226353ddc3048c3b8b196069663c573~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=IMwen5uFDf0ULJ0AqRoRtPqaKAM%3D" alt="一一对应" loading="lazy"/></p>
<p><strong>3.setProperty</strong></p>
<p><strong>在TypeScript中</strong>可以使用<code>Material</code>类的<code>setProperty</code>方法进行设置，代码示例如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbdd1e18e2a74f7e83e89bf901d04467~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=Isf3Ov3nozgDzXcWSY4fZKSOXP4%3D" alt="这应该是很熟悉了吧" loading="lazy"/></p>
<p><strong>4.使用</strong></p>
<p><strong>完成</strong>上述步骤后，可以直接使用，非常简单。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e93b8a3929543e694f2c3f65ee6cbbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=cdLdOMskN3LirW0MogtyuDrUOdg%3D" alt="使用很简单" loading="lazy"/></p>
<p><strong>以上</strong>就是倒水解谜游戏的核心部分，其余简单的代码逻辑由于篇幅问题就不再赘述，可以通过源码查看。</p>
<p><strong>相信小伙伴们学废之后，可以完成到下面的效果。</strong></p>
<h2 data-id="heading-4">效果演示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e9221acb85744e0991287e295114077~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lq_5YWD56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770598115&amp;x-signature=5poLf1I0EM4Ui2PnlvZCFr1qbzY%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">结语</h2>
<p>**那么问题来了，**倒水解谜类游戏已经过去了这么久，其变种依旧非常火爆。</p>
<p><strong>小伙伴们知道为什么吗？</strong></p>
<p>本文<strong>实战完整源码</strong>已集成到<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">亿元Cocos小游戏实战合集（6/10）</a>，内含体验链接，有疑问笔者手把手讲解。</p>
<hr/>
<p><strong>我是"亿元程序员"，一位有着8年游戏行业经验的主程。在游戏开发中，希望能给到您帮助, 也希望通过您能帮助到大家。</strong></p>
<p>AD:笔者线上的小游戏《打螺丝闯关》《贪吃蛇掌机经典》《重力迷宫球》《填色之旅》《方块掌机经典》大家可以自行点击搜索体验。</p>
<p>实不相瞒，想要个<strong>赞</strong>和<strong>爱心</strong>！请把该文章<strong>分享</strong>给你觉得有需要的其他小伙伴。谢谢！</p>
<p>推荐文章：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFOi5gCiGzF3LnT03DpPMXA" target="_blank" title="https://mp.weixin.qq.com/s/FOi5gCiGzF3LnT03DpPMXA" ref="nofollow noopener noreferrer">亿元Cocos小游戏实战合集</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXLCknL3fJDubec2GW6KLFA" target="_blank" title="https://mp.weixin.qq.com/s/XLCknL3fJDubec2GW6KLFA" ref="nofollow noopener noreferrer">Cocos游戏如何接入安卓穿山甲广告变现？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3_VrSld4KnDKY_7hxjSoKg" target="_blank" title="https://mp.weixin.qq.com/s/3_VrSld4KnDKY_7hxjSoKg" ref="nofollow noopener noreferrer">你知道和不知道的微信小游戏常用API整理，赶紧收藏用起来~</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Lj24VHJ-pL8z82hHqQLiA" target="_blank" title="https://mp.weixin.qq.com/s/0Lj24VHJ-pL8z82hHqQLiA" ref="nofollow noopener noreferrer">Cocos游戏如何快速接入抖音小游戏广告变现？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZ7DusUJA2v1IFZDFtBsueg" target="_blank" title="https://mp.weixin.qq.com/s/Z7DusUJA2v1IFZDFtBsueg" ref="nofollow noopener noreferrer">如何在CocosCreator3.8中实现割绳子游戏效果</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3BzzFBzeVAO-a6LPTeFTrA" target="_blank" title="https://mp.weixin.qq.com/s/3BzzFBzeVAO-a6LPTeFTrA" ref="nofollow noopener noreferrer">如何在CocosCreator3.8中实现动态切割模型？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZIph332u_r24OTY4r6_jow" target="_blank" title="https://mp.weixin.qq.com/s/ZIph332u_r24OTY4r6_jow" ref="nofollow noopener noreferrer">Cocos游戏开发中的贴花效果</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JFR：Spring Boot 应用的性能诊断利器]]></title>    <link>https://juejin.cn/post/7601486204174139442</link>    <guid>https://juejin.cn/post/7601486204174139442</guid>    <pubDate>2026-02-02T00:12:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601486204174139442" data-draft-id="7601374668961546290" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JFR：Spring Boot 应用的性能诊断利器"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-02T00:12:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风象南"/> <meta itemprop="url" content="https://juejin.cn/user/2524134428655159"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JFR：Spring Boot 应用的性能诊断利器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2524134428655159/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风象南
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T00:12:33.000Z" title="Mon Feb 02 2026 00:12:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    33
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>GC 停顿、内存泄漏、接口响应变慢——线上服务出问题的时候，你是否也曾对着监控面板发呆，不知道根因在哪？</p>
<p>今天聊聊 Java 自带的性能诊断神器 JFR（Java Flight Recorder），配合 Spring Boot 使用，效果翻倍。</p>
<h2 data-id="heading-0">JFR 是什么</h2>
<p>JFR 是 JDK 内置的性能采集工具，知道的人不多，但用过的人都说是「真香」。</p>
<p>几个核心优势：</p>
<ul>
<li><strong>开销可控</strong>：通过事件开关控制采集粒度，精准场景下开销可压到极低</li>
<li><strong>事件丰富</strong>：GC、线程、IO、锁、CPU、异常……100+ 种事件类型</li>
<li><strong>历史回溯</strong>：录制文件可以离线分析，事后定位没问题</li>
<li><strong>持续录制</strong>：支持后台常驻，出问题随时有数据兜底</li>
</ul>
<blockquote>
<p>JDK 8 及之前 JFR 是商业特性，JDK 9+ 免费开源。</p>
</blockquote>
<p>生产环境启用前建议确认：磁盘空间充足、开启了 JFR 权限控制、采集的事件范围符合需求。</p>
<h2 data-id="heading-1">Spring Boot 启用 JFR</h2>
<h4 data-id="heading-2">方式一：启动参数（最简单）</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording:filename=recording.jfr,duration=60s -jar app.jar
</code></pre>
<p>更多参数配置：</p>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording=\
    filename=app-recording.jfr,\
    dumponexit=<span class="hljs-literal">true</span>,\
    maxsize=500M,\
    maxage=1d,\
    settings=profile -jar app.jar
</code></pre>
<p>参数说明：</p>





























<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>filename</code></td><td>录制文件保存路径</td></tr><tr><td><code>dumponexit</code></td><td>JVM 退出时自动 dump</td></tr><tr><td><code>maxsize</code></td><td>单文件最大 size</td></tr><tr><td><code>maxage</code></td><td>最老数据的保留时间</td></tr><tr><td><code>settings</code></td><td>模板（production/profile）</td></tr></tbody></table>
<h4 data-id="heading-3">方式二：API 动态控制</h4>
<p>Spring Boot 可以通过 JMX 远程控制 JFR 开始/停止：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JfrController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MBeanServer</span> <span class="hljs-variable">mBeanServer</span> <span class="hljs-operator">=</span> ManagementFactory.getPlatformMBeanServer();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">JFR_BEAN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"com.oracle.jdk:jfrType=FlightRecorder"</span>;

    <span class="hljs-meta">@PostMapping("/jfr/start")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String filename)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ObjectName</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectName</span>(JFR_BEAN_NAME);
        Map&lt;String, String&gt; settings = Map.of(
            <span class="hljs-string">"jdk.JavaMonitorEnter#enabled"</span>, <span class="hljs-string">"true"</span>,
            <span class="hljs-string">"jdk.SocketRead#enabled"</span>, <span class="hljs-string">"true"</span>
        );
        mBeanServer.invoke(name, <span class="hljs-string">"startRecording"</span>,
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{filename, settings},
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{String.class.getName(), Map.class.getName()}
        );
        <span class="hljs-keyword">return</span> <span class="hljs-string">"started: "</span> + filename;
    }

    <span class="hljs-meta">@PostMapping("/jfr/stop")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ObjectName</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectName</span>(JFR_BEAN_NAME);
        mBeanServer.invoke(name, <span class="hljs-string">"stopRecording"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{}, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{});
        <span class="hljs-keyword">return</span> <span class="hljs-string">"stopped"</span>;
    }
}
</code></pre>
<h4 data-id="heading-4">方式三：Actuator 集成</h4>
<p>Spring Boot Actuator 也能暴露 JFR 端点：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">health,info,jfr</span>
  <span class="hljs-attr">jfr:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">directory:</span> <span class="hljs-string">/var/log/jfr</span>
</code></pre>
<hr/>
<h2 data-id="heading-5">录制文件怎么分析</h2>
<h4 data-id="heading-6">JDK Mission Control (JMC)</h4>
<p>这是官方提供的 GUI 分析工具，JDK 11+ 自带。</p>
<pre><code class="hljs language-bash" lang="bash">jmc
</code></pre>
<p>打开录制文件后，重点看这几个视图：</p>
<p><strong>1. Recording View</strong> - 事件列表和分布
<strong>2. Code Path</strong> - 热点方法调用链
<strong>3. Memory</strong> - GC 和对象分配
<strong>4. Threads</strong> - 锁竞争、线程状态
<strong>5. I/O</strong> - 文件和网络延迟</p>
<h4 data-id="heading-7">命令行快速分析</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 概览</span>
jfr summary recording.jfr

<span class="hljs-comment"># 只看某类事件</span>
jfr <span class="hljs-built_in">print</span> --events <span class="hljs-string">"jdk.GC*,jdk.JavaMonitorEnter"</span> recording.jfr

<span class="hljs-comment"># 找出耗时最长的调用</span>
jfr <span class="hljs-built_in">print</span> --events <span class="hljs-string">"jdk.ExecutionSample"</span> recording.jfr | <span class="hljs-built_in">head</span> -30
</code></pre>
<h4 data-id="heading-8">代码分析脚本</h4>
<p>写个脚本批量处理多个录制文件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JfrAnalyzer</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">var</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(args[<span class="hljs-number">0</span>]);
        Map&lt;String, Long&gt; durations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        Map&lt;String, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> RecordingFile.open(file)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> event : rs) {
                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> event.getEventType().getName();
                counts.merge(name, <span class="hljs-number">1</span>, Integer::sum);
                <span class="hljs-keyword">if</span> (event.hasValue(<span class="hljs-string">"duration"</span>)) {
                    <span class="hljs-type">long</span> <span class="hljs-variable">ns</span> <span class="hljs-operator">=</span> event.getDuration(<span class="hljs-string">"duration"</span>).toNanos();
                    durations.merge(name, ns, Long::sum);
                }
            }
        }

        <span class="hljs-comment">// 打印结果</span>
        System.out.println(<span class="hljs-string">"=== Most Frequent ==="</span>);
        counts.entrySet().stream()
            .sorted((a, b) -&gt; b.getValue() - a.getValue())
            .limit(<span class="hljs-number">10</span>).forEach(e -&gt;
                System.out.printf(<span class="hljs-string">"  %s: %d%n"</span>, e.getKey(), e.getValue()));

        System.out.println(<span class="hljs-string">"=== Slowest ==="</span>);
        durations.entrySet().stream()
            .sorted((a, b) -&gt; (<span class="hljs-type">int</span>)(b.getValue() - a.getValue()))
            .limit(<span class="hljs-number">10</span>).forEach(e -&gt;
                System.out.printf(<span class="hljs-string">"  %s: %d ms%n"</span>, e.getKey(), e.getValue() / <span class="hljs-number">1_000_000</span>));
    }
}
</code></pre>
<h2 data-id="heading-9">实战场景</h2>
<h4 data-id="heading-10">GC 停顿排查</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording:\
    filename=gc.jfr,\
    events=<span class="hljs-string">"jdk.GC*,jdk.YoungGarbageCollection,jdk.OldGarbageCollection"</span> -jar app.jar
</code></pre>
<p>JMC 里重点看：</p>
<ul>
<li>GC Pause 总时长和频率</li>
<li>Young GC 频率是否过高</li>
<li>对象晋升（Promotion）是否频繁</li>
</ul>
<h4 data-id="heading-11">接口慢请求定位</h4>
<p>先写个简单的耗时日志 AOP：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimingAspect</span> {

    <span class="hljs-meta">@Around("@annotation(GetMapping)")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">trace</span><span class="hljs-params">(ProceedingJoinPoint p)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">var</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> p.proceed();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-type">var</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
            <span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">1000</span>) {
                System.out.printf(<span class="hljs-string">"[SLOW] %s: %d ms%n"</span>, p.getSignature(), cost);
            }
        }
    }
}
</code></pre>
<p>慢请求出现后，配合 JFR 定位具体瓶颈：</p>

























<table><thead><tr><th>JFR 事件</th><th>对应问题</th></tr></thead><tbody><tr><td><code>jdk.ExecutionSample</code></td><td>CPU 热点</td></tr><tr><td><code>jdk.FileRead/Write</code></td><td>磁盘 IO 慢</td></tr><tr><td><code>jdk.SocketRead/Write</code></td><td>网络 IO 慢</td></tr><tr><td><code>jdk.JavaMonitorEnter</code></td><td>锁等待</td></tr></tbody></table>
<h4 data-id="heading-12">内存泄漏</h4>
<p>开启对象分配事件：</p>
<pre><code class="hljs">jdk.ObjectAllocationInNewTLAB
jdk.ObjectAllocationOutsideTLAB
jdk.OldGarbageCollection
</code></pre>
<p>老年代回收频率异常升高 + 堆大小持续增长，基本就是泄漏了。配合 <code>jfr print --events "jdk.OldGarbageCollection"</code> 看回收模式，再导出堆 dump 定位泄漏对象。</p>
<h2 data-id="heading-13">生产环境注意事项</h2>
<h4 data-id="heading-14">1. 资源限制</h4>
<pre><code class="hljs language-bash" lang="bash">-XX:FlightRecorderOptions=maxchunksize=100M,memorysize=50M
</code></pre>
<h4 data-id="heading-15">2. 持续录制 + 轮转</h4>
<pre><code class="hljs language-bash" lang="bash">java -XX:StartFlightRecording=\
    filename=/opt/jfr/app.jfr,\
    dumponexit=<span class="hljs-literal">true</span>,\
    maxage=7d,\
    maxsize=1G,\
    settings=production -jar app.jar
</code></pre>
<h4 data-id="heading-16">3. 权限控制</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">export</span> <span class="hljs-string">COM_SUN_JDK_JFR_OPTIONS="security-manager=true"</span>
</code></pre>
<h4 data-id="heading-17">4. 告警联动</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Scheduled(fixedRate = 60000)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alertIfNeeded</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 读取 JFR 事件，异常时推送到告警平台</span>
}
</code></pre>
<h2 data-id="heading-18">总结</h2>
<p>JFR 不是什么新东西，但确实是「平时用不上，出事能救命」的工具。</p>
<p>Spring Boot 集成后，启用成本不高。生产环境按需开启，配合资源限制和轮转策略，遇到问题直接看录制文件，比猜日志高效得多。</p>
<p>几个建议：</p>
<ul>
<li>先记几个常用 JFR 事件名，用到再查文档</li>
<li>持续录制 + 7 天轮转，出问题有数据可查</li>
<li>配合 JMC 可视化，分析效率更高</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[@empjs/valtio - 让你像写 Vue 响应式一样写 React 状态]]></title>    <link>https://juejin.cn/post/7601445395478593570</link>    <guid>https://juejin.cn/post/7601445395478593570</guid>    <pubDate>2026-02-02T02:18:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601445395478593570" data-draft-id="7601477334933192710" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="@empjs/valtio - 让你像写 Vue 响应式一样写 React 状态"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-02T02:18:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="KenXu"/> <meta itemprop="url" content="https://juejin.cn/user/483440843559406"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            @empjs/valtio - 让你像写 Vue 响应式一样写 React 状态
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/483440843559406/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    KenXu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-02T02:18:18.000Z" title="Mon Feb 02 2026 02:18:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-02
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>如果你正在经历：</strong> Zustand 替代了 Redux 的繁琐，但还是觉得不够"直觉"？从 Vue 转 React 后，怀念 <code>data.count++</code> 这种自然的写法？ <strong>@empjs/valtio</strong> 可能是你的答案。它让 React 状态管理回归"改变数据就自动更新"的本能，同时把常用功能（撤销/重做、计算属性、本地存储）从 <strong>4~5 个安装步骤简化为 1 行配置</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">📖 目录</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%231-%25E4%25B8%2589%25E5%2588%2586%25E9%2592%259F%25E7%2590%2586%25E8%25A7%25A3" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#1-%E4%B8%89%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3" ref="nofollow noopener noreferrer">三分钟理解：Redux → Zustand → Valtio 的演变</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%232-%25E6%25A0%25B8%25E5%25BF%2583%25E4%25BD%2593%25E9%25AA%258C" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#2-%E6%A0%B8%E5%BF%83%E4%BD%93%E9%AA%8C" ref="nofollow noopener noreferrer">核心体验：一个计数器的三种写法</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%233-%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E9%259C%2580%25E8%25A6%2581%25E5%25A2%259E%25E5%25BC%25BA%25E7%2589%2588" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A2%9E%E5%BC%BA%E7%89%88" ref="nofollow noopener noreferrer">为什么需要增强版？原版 Valtio 的"最后一公里"</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%234-%25E5%25AE%259E%25E6%2588%2598%25E5%25AF%25B9%25E6%25AF%2594" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#4-%E5%AE%9E%E6%88%98%E5%AF%B9%E6%AF%94" ref="nofollow noopener noreferrer">实战对比：同一个功能，代码量差多少？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%235-%25E8%25AF%25BB%25E5%2586%2599%25E9%2593%2581%25E5%25BE%258B" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#5-%E8%AF%BB%E5%86%99%E9%93%81%E5%BE%8B" ref="nofollow noopener noreferrer">读写铁律：snap 和 store 不能混用</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%236-%25E5%2586%2585%25E5%25BB%25BA%25E6%25AD%25A6%25E5%2599%25A8%25E5%25BA%2593" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#6-%E5%86%85%E5%BB%BA%E6%AD%A6%E5%99%A8%E5%BA%93" ref="nofollow noopener noreferrer">内建武器库：17 个方法全解析</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%237-%25E5%2585%25A8%25E5%25B1%2580-vs-%25E5%25B1%2580%25E9%2583%25A8" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#7-%E5%85%A8%E5%B1%80-vs-%E5%B1%80%E9%83%A8" ref="nofollow noopener noreferrer">全局 vs 局部：什么时候用哪个？</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%238-%25E5%25BE%25AE%25E5%2589%258D%25E7%25AB%25AF%25E5%259C%25BA%25E6%2599%25AF" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#8-%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9C%BA%E6%99%AF" ref="nofollow noopener noreferrer">微前端场景：像传普通 props 一样传 store</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%239-%25E9%2581%25BF%25E5%259D%2591%25E6%258C%2587%25E5%258D%2597" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#9-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97" ref="nofollow noopener noreferrer">避坑指南：5 个新手常犯错误</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fchat%2Fb05d6238-e287-40bb-b349-6f17a24857a9%2310-%25E5%25BF%25AB%25E9%2580%259F%25E5%2586%25B3%25E7%25AD%2596%25E8%25A1%25A8" target="_blank" title="https://claude.ai/chat/b05d6238-e287-40bb-b349-6f17a24857a9#10-%E5%BF%AB%E9%80%9F%E5%86%B3%E7%AD%96%E8%A1%A8" ref="nofollow noopener noreferrer">快速决策表：30 秒选对方案</a></li>
</ol>
<hr/>
<h2 data-id="heading-1">1. 三分钟理解</h2>
<h3 data-id="heading-2">React 状态管理的三代演变</h3>
<p>想象你在管理一家奶茶店的库存：</p>
<p><strong>Redux（第一代）—— 严格的仓库管理制度</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 每次改库存都要填表、盖章、走流程</span>
<span class="hljs-title function_ invoke__">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'UPDATE_MILK_TEA'</span>, <span class="hljs-attr">payload</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">10</span> } })
<span class="hljs-comment">// 优点：流程清晰，适合大团队协作</span>
<span class="hljs-comment">// 缺点：改个数字要写三个文件（action、reducer、connect）</span>
</code></pre>
<p><strong>Zustand（第二代）—— 简化的库存本子</strong></p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 把表格简化成一个记账本</span>
<span class="hljs-keyword">const</span> useStore = create(<span class="hljs-keyword">set</span> =&gt; ({
  count: <span class="hljs-number">0</span>,
  increase: () =&gt; <span class="hljs-keyword">set</span>(state =&gt; ({ count: state.count + <span class="hljs-number">1</span> }))
}))
<span class="hljs-comment">// 优点：只要一个文件，API 很少</span>
<span class="hljs-comment">// 缺点：还是要定义"动作函数"，不能直接改数字</span>
</code></pre>
<p><strong>Valtio（第三代）—— 像改普通变量一样</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 就像在白板上直接擦掉旧数字写新数字</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.count++  <span class="hljs-comment">// 就这么简单！UI 自动更新</span>
<span class="hljs-comment">// 优点：最接近 Vue 的 reactive，零学习成本</span>
<span class="hljs-comment">// 缺点：太"自由"了，缺少统一管理</span>
</code></pre>
<h3 data-id="heading-3">为什么 Vue 开发者会爱上它？</h3>
<p>如果你熟悉 Vue 3 的 <code>reactive</code>，那么 Valtio 的 <code>proxy</code> 几乎是同一个概念：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Vue 3 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.<span class="hljs-property">count</span>++  <span class="hljs-comment">// 直接改，视图自动更新</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// Valtio (React)</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
state.count++  <span class="hljs-comment">// 同样直接改，组件自动重渲染</span>
</code></pre>
<p>两者底层都用了 JavaScript 的 <code>Proxy</code> 机制来追踪变化，这就是为什么 Valtio 常被称为"React 世界的 Vue 响应式"。</p>
<hr/>
<h2 data-id="heading-4">2. 核心体验</h2>
<h3 data-id="heading-5">同一个计数器，三种库的写法</h3>
<p><strong>Redux Toolkit（约 20 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store.ts</span>
<span class="hljs-keyword">import</span> { createSlice } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>
<span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'counter'</span>,
  <span class="hljs-attr">initialState</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },
  <span class="hljs-attr">reducers</span>: { <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> { state.<span class="hljs-property">count</span> += <span class="hljs-number">1</span> } }
})

<span class="hljs-comment">// 组件</span>
<span class="hljs-keyword">import</span> { useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counter</span>.<span class="hljs-property">count</span>)
  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(increment())}&gt;
    {count}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p><strong>Zustand（约 12 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">'zustand'</span>
<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function"><span class="hljs-params">set</span> =&gt;</span> ({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }))
}))

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { count, increment } = <span class="hljs-title function_">useStore</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p><strong>@empjs/valtio（约 7 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
    {snap.count}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<h3 data-id="heading-6">量化对比</h3>



































<table><thead><tr><th>指标</th><th align="center">Redux Toolkit</th><th align="center">Zustand</th><th align="center">@empjs/valtio</th></tr></thead><tbody><tr><td><strong>代码行数</strong></td><td align="center">~20 行</td><td align="center">~12 行</td><td align="center"><strong>~7 行</strong></td></tr><tr><td><strong>需要定义"动作"</strong></td><td align="center">是（reducer）</td><td align="center">是（函数）</td><td align="center"><strong>否</strong></td></tr><tr><td><strong>TypeScript 类型推断</strong></td><td align="center">需手写 RootState</td><td align="center">需手写泛型</td><td align="center"><strong>自动推导</strong></td></tr><tr><td><strong>添加撤销/重做</strong></td><td align="center">装 redux-undo</td><td align="center">自己实现</td><td align="center"><strong>1 行配置</strong></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-7">3. 为什么需要增强版？</h2>
<h3 data-id="heading-8">原版 Valtio 的优势与边界</h3>
<p>原版 Valtio 只有两个核心 API：</p>
<ul>
<li><code>proxy(data)</code> — 创建响应式对象</li>
<li><code>useSnapshot(state)</code> — 在组件里读取数据</li>
</ul>
<p>这种极简主义是优点也是局限：</p>
<p><strong>优点：</strong> 学习成本几乎为零，写起来最自然<br/>
<strong>局限：</strong> 生产环境需要的"工程化能力"都要自己加</p>
<h3 data-id="heading-9">原版缺失的"最后一公里"</h3>



































<table><thead><tr><th>缺失的能力</th><th>原版方案</th><th>@empjs/valtio 方案</th></tr></thead><tbody><tr><td><strong>统一写入口</strong></td><td>自己封装 <code>set</code>/<code>update</code> 函数</td><td><code>createStore</code> 内建 17 个方法</td></tr><tr><td><strong>撤销/重做</strong></td><td>装 <code>valtio-history</code> 并手动接入</td><td><code>createStore({ history })</code> 一行开启</td></tr><tr><td><strong>计算属性</strong></td><td>装 <code>derive-valtio</code> 并配置</td><td><code>createStore({ derive })</code> 自动计算</td></tr><tr><td><strong>本地存储</strong></td><td>自己写 <code>localStorage</code> 逻辑</td><td><code>store.persist('key')</code> 一行搞定</td></tr><tr><td><strong>多实例隔离</strong></td><td><code>useRef(proxy(...))</code> + 手动清理</td><td><code>useStore(init)</code> 自动管理生命周期</td></tr></tbody></table>
<h3 data-id="heading-10">典型痛点场景</h3>
<p><strong>场景 1：想加个"撤销"功能</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 原版：需要安装新包 + 多处改造</span>
npm install valtio-history
import { proxyWithHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio-history'</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">state</span> = <span class="hljs-title function_ invoke__">proxyWithHistory</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
<span class="hljs-comment">// 然后在组件里手动调 state.value.count、state.undo()</span>

<span class="hljs-comment">// 增强版：配置一下就行</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store</span> = <span class="hljs-title function_ invoke__">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }, { <span class="hljs-attr">history</span>: <span class="hljs-literal">true</span> })
snap.<span class="hljs-title function_ invoke__">undo</span>()  <span class="hljs-comment">// 直接用</span>
</code></pre>
<p><strong>场景 2：表单需要"全名"自动拼接</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原版：需要装 derive-valtio + 单独维护派生逻辑</span>
npm install derive-valtio
<span class="hljs-keyword">import</span> { derive } <span class="hljs-keyword">from</span> <span class="hljs-string">'derive-valtio'</span>
<span class="hljs-keyword">const</span> derived = <span class="hljs-title function_">derive</span>({ <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-params">get</span> =&gt;</span> ... })

<span class="hljs-comment">// 增强版：写在配置里</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> },
  {
    <span class="hljs-attr">derive</span>: <span class="hljs-function">(<span class="hljs-params">get, p</span>) =&gt;</span> ({
      <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">${get(p).firstName}</span> <span class="hljs-subst">${get(p).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
    })
  }
)
</code></pre>
<hr/>
<h2 data-id="heading-11">4. 实战对比</h2>
<h3 data-id="heading-12">案例：用户信息表单（带撤销、计算属性、持久化）</h3>
<p><strong>原版 Valtio（约 35 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ① 安装依赖</span>
<span class="hljs-comment">// npm install valtio valtio-history derive-valtio</span>

<span class="hljs-comment">// ② 创建状态</span>
<span class="hljs-keyword">import</span> { proxy } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio'</span>
<span class="hljs-keyword">import</span> { proxyWithHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'valtio-history'</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">proxyWithHistory</span>({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> })

<span class="hljs-comment">// ③ 手写派生逻辑</span>
<span class="hljs-keyword">import</span> { derive } <span class="hljs-keyword">from</span> <span class="hljs-string">'derive-valtio'</span>
<span class="hljs-keyword">const</span> derived = <span class="hljs-title function_">derive</span>({
  <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-params">get</span> =&gt;</span> 
    <span class="hljs-string">`<span class="hljs-subst">${get(state.value).firstName}</span> <span class="hljs-subst">${get(state.value).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
})

<span class="hljs-comment">// ④ 手写持久化</span>
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> saved = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'user'</span>)
  <span class="hljs-keyword">if</span> (saved) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(state.<span class="hljs-property">value</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(saved))
  <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">subscribe</span>(state, <span class="hljs-function">() =&gt;</span> 
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'user'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state.<span class="hljs-property">value</span>))
  )
  <span class="hljs-keyword">return</span> unsub
}, [])

<span class="hljs-comment">// ⑤ 组件使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = <span class="hljs-title function_">useSnapshot</span>(state)
  <span class="hljs-keyword">const</span> derivedSnap = <span class="hljs-title function_">useSnapshot</span>(derived)
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{snap.value.firstName}</span> 
             <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> state.value.firstName = e.target.value} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全名：{derivedSnap.fullName}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> snap.undo()}&gt;撤销<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<p><strong>@empjs/valtio（约 18 行）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ① 一次性配置</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> },
  {
    <span class="hljs-attr">history</span>: { <span class="hljs-attr">limit</span>: <span class="hljs-number">50</span> },  <span class="hljs-comment">// 撤销功能</span>
    <span class="hljs-attr">derive</span>: <span class="hljs-function">(<span class="hljs-params">get, p</span>) =&gt;</span> ({    <span class="hljs-comment">// 计算属性</span>
      <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">${get(p).firstName}</span> <span class="hljs-subst">${get(p).lastName}</span>`</span>.<span class="hljs-title function_">trim</span>()
    })
  }
)
store.<span class="hljs-title function_">persist</span>(<span class="hljs-string">'user-form'</span>)   <span class="hljs-comment">// 持久化</span>

<span class="hljs-comment">// ② 直接用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">const</span> derived = store.<span class="hljs-property">derived</span>.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{snap.value.firstName}</span>
             <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> store.value.firstName = e.target.value} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>全名：{derived.fullName}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> snap.undo()}&gt;撤销<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-13">代码量对比</h3>





























<table><thead><tr><th>维度</th><th align="center">原版</th><th align="center">增强版</th><th align="center">减少</th></tr></thead><tbody><tr><td><strong>总行数</strong></td><td align="center">~35 行</td><td align="center">~18 行</td><td align="center"><strong>48%</strong></td></tr><tr><td><strong>需要安装的包</strong></td><td align="center">3 个</td><td align="center">1 个</td><td align="center"><strong>66%</strong></td></tr><tr><td><strong>接入步骤</strong></td><td align="center">5 步</td><td align="center">1 步</td><td align="center"><strong>80%</strong></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-14">5. 读写铁律</h2>
<blockquote>
<p><strong>记住一句话：读用 snap，写用 store。</strong> 这不是代码风格，是响应式系统的硬性要求。</p>
</blockquote>
<h3 data-id="heading-15">为什么有这个规则？</h3>
<p>Valtio 的响应式依赖 React 的 <code>useSnapshot</code> 来收集"谁用了哪些字段"。直接读 <code>store.xxx</code> 不会触发这个收集机制，组件就不会在数据变化时重新渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误：读 store 不会触发重渲染</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bad</span>(<span class="hljs-params"/>) {
  store.<span class="hljs-title function_">useSnapshot</span>()  <span class="hljs-comment">// 虽然调了 hook，但没用返回值</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{store.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>  <span class="hljs-comment">// 读的是 proxy，不是 snap</span>
  <span class="hljs-comment">// 结果：count 变了，页面不更新</span>
}

<span class="hljs-comment">// ✅ 正确：读 snap，写 store</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Good</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  {/* 读 snap */}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;  {/* 写 store */}
        +1
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-16">带历史功能时的规则</h3>
<p>如果开启了 <code>history</code> 配置，状态会被包在 <code>.value</code> 里：</p>

























<table><thead><tr><th>操作</th><th>写法</th></tr></thead><tbody><tr><td><strong>读当前值</strong></td><td><code>snap.value.firstName</code></td></tr><tr><td><strong>写入新值</strong></td><td><code>store.value.firstName = 'Alice'</code></td></tr><tr><td><strong>撤销</strong></td><td><code>snap.undo()</code></td></tr><tr><td><strong>重做</strong></td><td><code>snap.redo()</code></td></tr></tbody></table>
<h3 data-id="heading-17">用类型保证不犯错</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmpStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">''</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">State</span> = <span class="hljs-keyword">typeof</span> initialState

<span class="hljs-comment">// 子组件只依赖这个类型，TypeScript 会强制你用 store 的方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Store</span> = <span class="hljs-title class_">EmpStore</span>&lt;<span class="hljs-title class_">State</span>&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">{ store }: { store: Store }</span>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-comment">// snap.count = 1  // ❌ TypeScript 报错：snap 是只读的</span>
  store.<span class="hljs-title function_">set</span>(<span class="hljs-string">'count'</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// ✅ 必须通过 store 的方法</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-18">6. 内建武器库</h2>
<p><code>createStore</code> / <code>useStore</code> 返回的对象有 <strong>17 个方法</strong>，分四大类：</p>
<h3 data-id="heading-19">📖 读取类（3 个）</h3>

























<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>useSnapshot()</code></td><td>组件内读取数据（Hook）</td><td><code>const snap = store.useSnapshot()</code></td></tr><tr><td><code>getSnapshot()</code></td><td>非组件场景读取（如回调）</td><td><code>console.log(store.getSnapshot())</code></td></tr><tr><td><code>toJSON()</code></td><td>序列化为纯对象</td><td><code>const data = store.toJSON()</code></td></tr></tbody></table>
<h3 data-id="heading-20">✏️ 写入类（6 个）</h3>








































<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>set(key, value)</code></td><td>改单个字段</td><td><code>store.set('count', 10)</code></td></tr><tr><td><code>update(partial)</code></td><td>批量改多个字段</td><td><code>store.update({ count: 10, name: 'Alice' })</code></td></tr><tr><td><code>setNested(path, value)</code></td><td>改深层路径</td><td><code>store.setNested('user.address.city', '北京')</code></td></tr><tr><td><code>delete(key)</code></td><td>删除某个字段</td><td><code>store.delete('tempData')</code></td></tr><tr><td><code>reset(state?)</code></td><td>重置为初始状态</td><td><code>store.reset()</code></td></tr><tr><td><code>fromJSON(json)</code></td><td>从对象恢复状态</td><td><code>store.fromJSON(savedData)</code></td></tr></tbody></table>
<h3 data-id="heading-21">👂 订阅类（3 个）</h3>

























<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>subscribe(fn)</code></td><td>监听所有变化</td><td><code>store.subscribe(() =&gt; console.log('变了'))</code></td></tr><tr><td><code>subscribeKey(key, fn)</code></td><td>只监听某个字段</td><td><code>store.subscribeKey('count', val =&gt; ...)</code></td></tr><tr><td><code>subscribeKeys(keys, fn)</code></td><td>监听多个字段</td><td><code>store.subscribeKeys(['a', 'b'], ...)</code></td></tr></tbody></table>
<h3 data-id="heading-22">🔧 工具类（5 个）</h3>



































<table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>ref(value)</code></td><td>标记为非响应式（如 DOM）</td><td><code>store.set('dom', store.ref(divElement))</code></td></tr><tr><td><code>batch(fn)</code></td><td>批量更新，只触发一次渲染</td><td><code>store.batch(() =&gt; { ... })</code></td></tr><tr><td><code>clone()</code></td><td>深拷贝当前状态</td><td><code>const copy = store.clone()</code></td></tr><tr><td><code>persist(key)</code></td><td>开启 localStorage 持久化</td><td><code>store.persist('my-data')</code></td></tr><tr><td><code>debug()</code></td><td>在控制台打印每次变更</td><td><code>store.debug()</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-23">7. 全局 vs 局部</h2>
<h3 data-id="heading-24">什么时候用 <code>createStore</code>（全局单例）？</h3>
<p><strong>特征：</strong> 数据需要跨组件共享，整个应用生命周期内只有一份</p>
<p><strong>典型场景：</strong></p>
<ul>
<li>当前登录用户信息</li>
<li>主题配置（深色/浅色模式）</li>
<li>全局加载状态</li>
<li>购物车数据</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在单独文件里创建</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> themeStore = <span class="hljs-title function_">createStore</span>({
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'light'</span>,
  <span class="hljs-attr">primaryColor</span>: <span class="hljs-string">'#1890ff'</span>
})

<span class="hljs-comment">// 任何组件都可以用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = themeStore.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">snap.primaryColor</span> }}&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
</code></pre>
<h3 data-id="heading-25">什么时候用 <code>useStore</code>（每实例独立）？</h3>
<p><strong>特征：</strong> 每个组件实例需要自己的独立状态，互不干扰</p>
<p><strong>典型场景：</strong></p>
<ul>
<li>表单（页面上可能有多个表单）</li>
<li>代码编辑器（每个 Tab 一个编辑器）</li>
<li>画板工具（多画布场景）</li>
<li>计数器组件（同页面多个实例）</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">FormBlock</span>(<span class="hljs-params">{ initialLabel }: { initialLabel: string }</span>) {
  <span class="hljs-comment">// 每个 &lt;FormBlock&gt; 实例都有自己的 store</span>
  <span class="hljs-keyword">const</span> [snap, store] = <span class="hljs-title function_">useStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">label</span>: initialLabel })
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{snap.label}: {snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
        +1
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.reset()}&gt;重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-comment">// 两个实例，状态完全隔离</span>
&lt;<span class="hljs-title class_">FormBlock</span> initialLabel=<span class="hljs-string">"表单 A"</span> /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FormBlock</span> <span class="hljs-attr">initialLabel</span>=<span class="hljs-string">"表单 B"</span> /&gt;</span></span>
</code></pre>
<h3 data-id="heading-26">惰性初始化（适合昂贵计算）</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 传函数而不是对象，只有第一次渲染时才执行</span>
<span class="hljs-selector-tag">const</span> <span class="hljs-selector-attr">[snap, store]</span> = <span class="hljs-selector-tag">useStore</span>(() =&gt; ({
  <span class="hljs-attribute">data</span>: <span class="hljs-built_in">expensiveComputation</span>(),  <span class="hljs-comment">// 只在组件挂载时算一次</span>
  <span class="hljs-attribute">timestamp</span>: Date.<span class="hljs-built_in">now</span>()
}))
</code></pre>
<hr/>
<h2 data-id="heading-27">8. 微前端场景</h2>
<h3 data-id="heading-28">传统方案的问题</h3>





















<table><thead><tr><th>方案</th><th>问题</th></tr></thead><tbody><tr><td><strong>全局单例</strong></td><td>子应用和主应用版本不一致就炸，构建顺序有依赖</td></tr><tr><td><strong>事件总线</strong></td><td>类型弱，调试困难，边界不清晰</td></tr><tr><td><strong>postMessage</strong></td><td>只能传序列化数据，丢失类型和方法</td></tr></tbody></table>
<h3 data-id="heading-29">@empjs/valtio 的方案：当普通 prop 传</h3>
<p><strong>核心思想：</strong> store 本身就是一个普通对象，可以像任何 React props 一样传递</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ===== 共享类型定义（放在独立的 npm 包里） =====</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmpStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'shared'</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">State</span> = <span class="hljs-keyword">typeof</span> initialState
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> = <span class="hljs-title class_">EmpStore</span>&lt;<span class="hljs-title class_">State</span>&gt;

<span class="hljs-comment">// ===== 主应用（主机） =====</span>
<span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@empjs/valtio'</span>
<span class="hljs-keyword">import</span> { initialState, <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@my-company/shared-types'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">RemoteChild</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'remote-app/Child'</span>  <span class="hljs-comment">// Module Federation</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Host</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [snap, store] = useStore&lt;<span class="hljs-title class_">State</span>&gt;(initialState)
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主应用的计数：{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      
      {/* 像普通 prop 一样传给子应用 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">RemoteChild</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-comment">// ===== 子应用（独立构建，独立部署） =====</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">SharedStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@my-company/shared-types'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">RemoteChild</span>(<span class="hljs-params">{ store }: { store: SharedStore }</span>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子应用<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>看到的主应用数据：{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> store.set('count', snap.count + 1)}&gt;
        子应用也能改
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-30">为什么这样好？</h3>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>零耦合</strong></td><td>子应用不需要知道主应用的运行时，只依赖类型定义</td></tr><tr><td><strong>类型安全</strong></td><td>TypeScript 全程保护，改了类型定义，双方都能感知</td></tr><tr><td><strong>调试简单</strong></td><td>就是普通的 props，React DevTools 直接能看</td></tr><tr><td><strong>版本独立</strong></td><td>主应用升级不影响子应用，子应用可以独立发版</td></tr></tbody></table>
<h3 data-id="heading-31">状态层次示意图</h3>
<pre><code class="hljs language-css" lang="css">主应用
├── 全局 store（createStore）
│   ├── 用户信息
│   └── 主题配置
│       └── 通过 props 传给子应用 ──┐
│                                   ↓
└── 子应用 <span class="hljs-selector-tag">A</span>                     接收 store
    ├── 使用主应用的 store（共享状态）
    └── 自己的 store（useStore）
        ├── 表单数据（局部）
        └── 编辑器状态（局部）
</code></pre>
<hr/>
<h2 data-id="heading-32">9. 避坑指南</h2>
<h3 data-id="heading-33">❌ 错误 1：读 store 而不是 snap</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bad</span>(<span class="hljs-params"/>) {
  store.<span class="hljs-title function_">useSnapshot</span>()  <span class="hljs-comment">// 虽然调了，但没用返回值</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{store.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>  <span class="hljs-comment">// 不会触发重渲染</span>
}

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Good</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snap = store.<span class="hljs-title function_">useSnapshot</span>()
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
}
</code></pre>
<p><strong>为什么错：</strong> Valtio 的响应式机制依赖 <code>useSnapshot</code> 的返回值来追踪"谁读了哪些字段"，直接读 <code>store</code> 不会被追踪。</p>
<h3 data-id="heading-34">❌ 错误 2：键名和方法重名</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 错误：键名叫 set，和 store.set() 冲突</span>
<span class="hljs-keyword">const</span> store = createStore({
  <span class="hljs-keyword">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),  <span class="hljs-comment">// ❌ 冲突！</span>
  update: <span class="hljs-number">123</span>      <span class="hljs-comment">// ❌ 也冲突！</span>
})

<span class="hljs-comment">// 正确：换个名字</span>
<span class="hljs-keyword">const</span> store = createStore({
  tagSet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),  <span class="hljs-comment">// ✅</span>
  version: <span class="hljs-number">123</span>        <span class="hljs-comment">// ✅</span>
})
</code></pre>
<p><strong>为什么错：</strong> <code>store.set</code> / <code>store.update</code> 是内建方法，用同名键会被覆盖。</p>
<h3 data-id="heading-35">❌ 错误 3：传非 proxy 对象给 useSnapshot</h3>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">plainObj</span> = { count: <span class="hljs-number">0</span> }
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">snap</span> = <span class="hljs-title function_ invoke__">useSnapshot</span>(plainObj)  <span class="hljs-comment">// ❌ 报错</span>

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">store</span> = <span class="hljs-title function_ invoke__">createStore</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">snap</span> = store.<span class="hljs-title function_ invoke__">useSnapshot</span>()  <span class="hljs-comment">// ✅</span>
</code></pre>
<p><strong>报错信息：</strong> "Please use proxy object"</p>
<h3 data-id="heading-36">❌ 错误 4：在 derive 里写副作用</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> store = createStore(
  { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> },
  {
    derive: (<span class="hljs-keyword">get</span>, p) =&gt; {
      console.log(<span class="hljs-string">'计算中'</span>)  <span class="hljs-comment">// ❌ 副作用</span>
      fetch(<span class="hljs-string">'/api'</span>)          <span class="hljs-comment">// ❌ 异步请求</span>
      <span class="hljs-keyword">return</span> { sum: <span class="hljs-keyword">get</span>(p).a + <span class="hljs-keyword">get</span>(p).b }
    }
  }
)

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> store = createStore(
  { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> },
  {
    derive: (<span class="hljs-keyword">get</span>, p) =&gt; ({
      sum: <span class="hljs-keyword">get</span>(p).a + <span class="hljs-keyword">get</span>(p).b  <span class="hljs-comment">// ✅ 纯计算</span>
    })
  }
)
</code></pre>
<p><strong>为什么错：</strong> <code>derive</code> 会被频繁调用（每次依赖变化都调），副作用会重复执行且难以控制。</p>
<h3 data-id="heading-37">❌ 错误 5：忘记 .value（开启历史功能时）</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 开启历史后，状态被包在 .value 里</span>
<span class="hljs-type">const</span> store = <span class="hljs-built_in">createStore</span>({ count: <span class="hljs-number">0</span> }, { history: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// 错误</span>
<span class="hljs-type">const</span> snap = store.<span class="hljs-built_in">useSnapshot</span>()
console.<span class="hljs-built_in">log</span>(snap.count)  <span class="hljs-comment">// ❌ undefined</span>

<span class="hljs-comment">// 正确</span>
<span class="hljs-type">const</span> snap = store.<span class="hljs-built_in">useSnapshot</span>()
console.<span class="hljs-built_in">log</span>(snap.value.count)  <span class="hljs-comment">// ✅</span>
store.value.count++             <span class="hljs-comment">// ✅ 写入也要加 .value</span>
</code></pre>
<hr/>
<h2 data-id="heading-38">10. 快速决策表</h2>























































<table><thead><tr><th>你的场景</th><th>推荐方案</th><th>示例代码</th></tr></thead><tbody><tr><td><strong>全局配置（主题/语言/用户）</strong></td><td><code>createStore</code></td><td><code>const themeStore = createStore({ mode: 'light' })</code></td></tr><tr><td><strong>多个独立表单</strong></td><td><code>useStore</code></td><td><code>const [snap, store] = useStore({ name: '' })</code></td></tr><tr><td><strong>需要撤销/重做</strong></td><td><code>createStore</code> + <code>history</code></td><td><code>createStore(init, { history: { limit: 50 } })</code></td></tr><tr><td><strong>需要计算属性（如全名）</strong></td><td><code>createStore</code> + <code>derive</code></td><td><code>createStore(init, { derive: (get, p) =&gt; ({ ... }) })</code></td></tr><tr><td><strong>需要本地持久化</strong></td><td>任意 store + <code>.persist()</code></td><td><code>store.persist('my-data-key')</code></td></tr><tr><td><strong>微前端：主应用 → 子应用</strong></td><td>主应用 <code>useStore</code>，props 传入</td><td><code>&lt;RemoteChild store={store} /&gt;</code></td></tr><tr><td><strong>微前端：子应用内部</strong></td><td>子应用自行 <code>useStore</code></td><td>与主应用完全隔离</td></tr><tr><td><strong>批量更新避免多次渲染</strong></td><td><code>store.batch()</code></td><td><code>store.batch(() =&gt; { store.set(...); store.set(...) })</code></td></tr><tr><td><strong>表单多次改值卡顿</strong></td><td><code>store.batch()</code></td><td>输入框 onChange 里包一层 batch</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-39">总结：三句话记住 @empjs/valtio</h2>
<ol>
<li><strong>像 Vue 一样写 React 状态</strong> —— <code>state.count++</code> 就能自动更新 UI</li>
<li><strong>从 4~5 步简化到 1 步</strong> —— 历史、计算属性、持久化都是一行配置</li>
<li><strong>微前端友好</strong> —— store 当普通 props 传，无需全局单例和事件总线</li>
</ol>
<hr/>
<p><strong>参考资料：</strong></p>
<ul>
<li>📚 官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvaltio.empjs.dev%2F" target="_blank" title="https://valtio.empjs.dev/" ref="nofollow noopener noreferrer">valtio.empjs.dev</a></li>
<li>🔧 API 手册：<a href="https://link.juejin.cn?target=https%3A%2F%2Fvaltio.empjs.dev%2Fmanual" target="_blank" title="https://valtio.empjs.dev/manual" ref="nofollow noopener noreferrer">valtio.empjs.dev/manual</a></li>
<li>🐙 GitHub：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FefoxTeam%2Femp%2Ftree%2Fmain%2Fpackages%2Fvaltio" target="_blank" title="https://github.com/efoxTeam/emp/tree/main/packages/valtio" ref="nofollow noopener noreferrer">@empjs/valtio</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布]]></title>    <link>https://juejin.cn/post/7601843004958359598</link>    <guid>https://juejin.cn/post/7601843004958359598</guid>    <pubDate>2026-02-01T23:46:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7601843004958359598" data-draft-id="7601444617695608842" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2026-02-01T23:46:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-01T23:46:49.000Z" title="Sun Feb 01 2026 23:46:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-01
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布</h2>
<p>NativePHP for Mobile 从 v3 版本开始，核心框架采用 MIT 协议免费开源。Laravel/PHP 开发者现在可以零成本构建原生 iOS 和 Android 应用。</p>
<p>如果使用 nativePHP 开发移动应用的话，可以看<a href="https://link.juejin.cn?target=https%3A%2F%2Fnativephp-doc.catchadmin.com" target="_blank" title="https://nativephp-doc.catchadmin.com" ref="nofollow noopener noreferrer">nativephp mobile v3 中文文档</a></p>
<h3 data-id="heading-1">插件化架构</h3>
<p>v3 版本最大的变化是引入了模块化插件系统。此前版本中集成在核心包里的原生功能，现在被拆分成独立的插件。</p>
<p>每个插件都是一个独立的 Composer 包，包含 Swift 和 Kotlin 代码、权限清单以及原生依赖。开发者只需安装实际用到的插件，这些插件会在构建过程中直接编译进应用。</p>
<p>插件安装非常简单，通过 <code>composer require</code> 安装包后，在 <code>NativeServiceProvider</code> 中注册即可。只有注册的插件才会被编译进最终的二进制文件，这样可以保持应用体积精简，也有助于通过应用商店审核。</p>
<h4 data-id="heading-2">创建插件</h4>
<p>插件本质上就是 Composer 包，只是多了一些额外配置。通过添加 <code>nativephp.json</code> 文件，开发者可以定义 PHP 类、视图文件、桥接函数、原生依赖（CocoaPods、Swift Packages、Gradle）、权限声明、JavaScript 文件等。</p>
<p>NativePHP 核心提供了构建钩子、生命周期钩子、服务提供者注册等机制，让插件开发体验更加顺畅。</p>
<p>插件可以发布到 Packagist，也可以作为项目内部代码使用，无需发布到公共仓库。这意味着应用的 Laravel 代码库可以包含构建原生应用所需的一切。</p>
<h3 data-id="heading-3">免费核心</h3>
<p>新架构将核心包精简到最小化，应用只需包含实际使用的功能。这让应用默认就更小、更高效，也避免了应用商店审核时因包含未使用功能而被拒的问题。</p>
<p>NativePHP 团队将 v3 版本命名为 NativePHP Air，并将其转为 MIT 开源协议。v3 之前的版本仍然遵循原有的 Business Source License。</p>
<p>核心框架开源后，社区可以参与贡献，团队欢迎针对 iOS 和 Android 核心应用的 PR。</p>
<h4 data-id="heading-4">免费插件</h4>
<p>以下插件完全免费开源（MIT 协议）：</p>
<ul>
<li><strong>Browser</strong> - 浏览器功能</li>
<li><strong>Camera</strong> - 相机调用</li>
<li><strong>Device</strong> - 设备信息获取</li>
<li><strong>Dialog</strong> - 原生对话框</li>
<li><strong>File</strong> - 文件操作</li>
<li><strong>Microphone</strong> - 麦克风调用</li>
<li><strong>Network</strong> - 网络状态检测</li>
<li><strong>Share</strong> - 系统分享功能</li>
<li><strong>System</strong> - 系统信息</li>
</ul>
<h4 data-id="heading-5">付费插件</h4>
<p>以下功能需要单独购买插件（一次性付费，可用于无限项目）：</p>
<ul>
<li><strong>Biometrics</strong> - 生物识别（Face ID、指纹）</li>
<li><strong>Geolocation</strong> - 地理位置</li>
<li><strong>Push Notifications</strong> - 推送通知（基于 Firebase）</li>
<li><strong>Scanner</strong> - 扫描器</li>
<li><strong>Secure Storage</strong> - 安全存储</li>
</ul>
<h3 data-id="heading-6">插件市场</h3>
<p>插件市场（Plugin Marketplace）将所有 NativePHP 插件集中展示，开发者可以发现免费和付费插件。</p>
<p>未来几周，市场将向第三方开发者开放，届时开发者可以在 nativephp.com 上架自己的插件，甚至可以销售自己开发的插件。例如相机滤镜插件、支付网关集成、社交登录包等。</p>
<h3 data-id="heading-7">Jump：即时设备测试</h3>
<p>在真机上测试应用通常是一个缓慢且繁琐的过程，需要安装数 GB 的软件、模拟器和框架。而且，没有 Mac 就无法为 iPhone 构建和测试应用。</p>
<p>Jump 改变了这一切。</p>
<p>Jump 是一个安装在手机上的应用（支持 Android 和 iOS），可以在真机上测试 NativePHP 应用，无需编译任何东西，也不需要开启开发者模式。</p>
<p>只需运行 <code>native:jump</code> Artisan 命令，打开手机上的 Jump 应用扫描二维码，Laravel 应用就会直接加载到设备上，连接到本地开发服务器。</p>
<pre><code class="hljs language-shell" lang="shell">php artisan native:jump
<span class="hljs-meta prompt_">
# </span><span class="bash">或者</span>

./native jump
</code></pre>
<p>NativePHP 构建速度很快，本地开发环境的改动几乎可以实时反映到设备上。未来还计划支持完整的 HMR（热模块替换）。</p>
<p>Jump 应用完全免费，<code>nativephp/mobile</code> v3 已包含运行 Jump 所需的一切。</p>
<p>Jump 包含所有官方 NativePHP 插件（包括付费插件），开发者可以免费试用和学习所有功能。唯一的限制是 Jump 无法测试第三方插件。</p>
<h3 data-id="heading-8">Mimi：AI 辅助编码</h3>
<p>Mimi（取自北欧智慧之神 Mimir）是 NativePHP 提供的 AI 辅助编码功能，可以让 AI 模型帮助编写 NativePHP 应用：</p>
<ul>
<li>直接在浏览器中创建新的 NativePHP 项目（移动端也可以）</li>
<li>用自然语言描述想要构建的内容，支持语音输入</li>
<li>直接在 Jump 中测试应用</li>
<li>连接 GitHub 仓库，立即获取所有应用代码</li>
</ul>
<p>这是从想法到可运行移动应用的最快路径，完全基于 Laravel。</p>
<h3 data-id="heading-9">升级指南</h3>
<p>如果已经安装了 <code>nativephp/mobile</code>，升级到 v3 的步骤如下：</p>
<ol>
<li>从 <code>composer.json</code> 中移除 NativePHP 仓库（<code>https://nativephp.composer.sh</code>）</li>
<li>运行 <code>composer remove nativephp/mobile</code> 卸载旧版本</li>
<li>运行 <code>composer require nativephp/mobile</code> 从 Packagist 安装 v3</li>
<li>安装应用中使用的功能对应的插件</li>
</ol>
<p>除了注册新插件外，应用代码基本不需要修改。安装插件后可以使用以下命令注册：</p>
<pre><code class="hljs language-shell" lang="shell">php artisan native:plugin:register vendor/plugin
<span class="hljs-meta prompt_">
# </span><span class="bash">或者</span>

./native plugin:register vendor/plugin
</code></pre>
<h3 data-id="heading-10">快速开始</h3>
<p>NativePHP for Mobile v3 现已发布。在手机上安装 Jump，然后在开发环境中运行以下命令：</p>
<pre><code class="hljs language-shell" lang="shell">laravel new my-mobile-app
cd my-mobile-app
composer require nativephp/mobile
php artisan native:jump
</code></pre>
<p>这里面有几个小坑</p>
<ul>
<li>PHP 要求 <code>&gt;=8.3</code></li>
<li>在 windows 上测试，需要先安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.7-zip.org%2F" target="_blank" title="https://www.7-zip.org/" ref="nofollow noopener noreferrer">7-zip</a></li>
<li>我在 IOS 手机测试得，使用 <code>php artisan native:jump</code> 之后会弹出一个二维码，用手机上的 Jump 扫描即可。这个 Jump 目前只能在 <code>TestFlight</code> 上安装，打开这个<a href="https://link.juejin.cn?target=https%3A%2F%2Ftestflight.apple.com%2Fjoin%2FRuzFs4rJ" target="_blank" title="https://testflight.apple.com/join/RuzFs4rJ" ref="nofollow noopener noreferrer">安装链接</a>即可。</li>
</ul>
<p>很完美，至少从安装上到测试效果都很快了。效果图如下：</p>
<p><img src="https://image.catchadmin.com/202602011330904.png" alt="Laravel 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2026-02%2Fnativephp-mobile-free" target="_blank" title="https://catchadmin.com/post/2026-02/nativephp-mobile-free" ref="nofollow noopener noreferrer">原文 PHP 现在可以零成本构建原生 iOS 和 Android 应用 NativePHP for Mobile v3 发布</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>