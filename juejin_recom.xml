<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式]]></title>    <link>https://juejin.cn/post/7587336857538527241</link>    <guid>https://juejin.cn/post/7587336857538527241</guid>    <pubDate>2025-12-25T04:05:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587336857538527241" data-draft-id="7587336857538478089" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2025-12-25T04:05:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="伍华聪"/> <meta itemprop="url" content="https://juejin.cn/user/122769398839592"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/122769398839592/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    伍华聪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T04:05:48.000Z" title="Thu Dec 25 2025 04:05:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在Python+FastAPI的后端项目中，我们往往很多时候需要对数据进行相关的处理，本篇随笔介绍在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式。</p>
<p>使用 FastAPI, SQLAlchemy, Pydantic构建后端项目的时候，其中数据库访问采用SQLAlchemy 的异步方式处理。一般我们在操作数据库操作的时候，采用基类继承的方式减少重复代码，提高代码复用性。不过我们在分析SQLAlchemy的时候，我们可以简单的方式来剖析几种常见的数据库操作方式，来介绍SQLAlchemy的具体使用。</p>
<h3 data-id="heading-0">1、SQLAlchemy介绍</h3>
<p><strong>SQLAlchemy</strong> 是一个功能强大且灵活的 Python SQL 工具包和对象关系映射（ORM）库。它被广泛用于在 Python 项目中处理关系型数据库的场景，既提供了高级的 ORM 功能，又保留了对底层 SQL 语句的强大控制力。<code>SQLAlchemy</code> 允许开发者通过 Python 代码与数据库进行交互，而无需直接编写 SQL 语句，同时也支持直接使用原生 SQL 进行复杂查询。下面是<strong>SQLAlchemy</strong>和我们常规数据库对象的对应关系说明。</p>
<p>Engine  　　连接对象         驱动引擎</p>
<p>Session 　　连接池           事务  由此开始查询</p>
<p>Model   　　表                   类定义</p>
<p>Column  　  列  </p>
<p>Query   　　若干行         可以链式添加多个条件</p>
<p>在使用SQLAlchemy时，通常会将其与数据库对象对应起来。</p>
<p><strong>SQLAlchemy</strong>: 使用 <code>Table</code> 对象或 <code>Declarative Base</code> 中的类来表示。</p>
<p><strong>对应关系</strong>: 数据库中的每一个表对应于SQLAlchemy中的一个类，该类继承自 <code>declarative_base()</code>。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.ext.declarative import declarative_base

<span class="hljs-attr">Base</span> = declarative_base()

class User(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">'users'</span>  <span class="hljs-comment"># 数据库表名</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)
    <span class="hljs-attr">name</span> = Column(String)
    <span class="hljs-attr">email</span> = Column(String)
</code></pre>
<p><strong>数据库列 (Database Column)：</strong> 使用 <code>Column</code> 对象来表示。每个数据库表中的列在SQLAlchemy中表示为 <code>Column</code> 对象，并作为类的属性定义。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)
<span class="hljs-attr">name</span> = Column(String(<span class="hljs-number">50</span>))
</code></pre>
<p><strong>数据库行 (Database Row)：</strong> 每个数据库表的一个实例（对象）代表数据库表中的一行。在SQLAlchemy中，通过实例化模型类来表示数据库表中的一行。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">new_user</span> = User(id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'John Doe'</span>, email=<span class="hljs-string">'john@example.com'</span>)
</code></pre>
<p><strong>主键 (Primary Key)</strong> ：使用 <code>primary_key=True</code> 参数定义主键。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)
</code></pre>
<p><strong>外键 (Foreign Key):</strong> 使用 <code>ForeignKey</code> 对象来表示。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class Address(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">'addresses'</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)
    <span class="hljs-attr">user_id</span> = Column(Integer, ForeignKey(<span class="hljs-string">'users.id'</span>))
    <span class="hljs-attr">user</span> = relationship(<span class="hljs-string">'User'</span>)
</code></pre>
<p><strong>关系 (Relationships):</strong> 使用 <code>relationship</code> 对象来表示。数据库中表与表之间的关系在SQLAlchemy中通过 <code>relationship</code> 来定义。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">addresses</span> = relationship(<span class="hljs-string">"Address"</span>, back_populates=<span class="hljs-string">"user"</span>)
</code></pre>
<h3 data-id="heading-1">2、常规的单表处理</h3>
<p>下面我们通过异步处理的方式，介绍如何在单表中操作相关的数据库数据。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, db: AsyncSession, <span class="hljs-built_in">id</span>: <span class="hljs-type">Any</span></span>) -&gt; <span class="hljs-type">Any</span>:
    <span class="hljs-string">"""根据主键获取一个对象"""</span>

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">id</span>, <span class="hljs-built_in">str</span>):
        query = select(self.model).<span class="hljs-built_in">filter</span>(func.lower(self.model.<span class="hljs-built_in">id</span>) == <span class="hljs-built_in">id</span>.lower())
    <span class="hljs-keyword">else</span>:
        query = select(self.model).<span class="hljs-built_in">filter</span>(self.model.<span class="hljs-built_in">id</span> == <span class="hljs-built_in">id</span>)

    result = <span class="hljs-keyword">await</span> db.execute(query)
    item = result.scalars().first()

    <span class="hljs-keyword">return</span> item
</code></pre>
<p>如果我们需要强制对外键的类型进行匹配（如对于Postgresql的严格要求，数据比较的类型必须一致），那么我们需要在基类或者CRUD类初始化的时候，获得对应的主键类型。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseCrud</span>(<span class="hljs-type">Generic</span>[ModelType, PrimaryKeyType, PageDtoType, DtoType]):
    <span class="hljs-string">"""
    基础CRUD操作类，传入参数说明：
    * `ModelType`: SQLAlchemy 模型类
    * `PrimaryKeyType`: 限定主键的类型
    * `PageDtoType`: 分页查询输入类
    * `DtoType`: 数据传输对象类，如新增、更新的单个对象DTO
    """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model: <span class="hljs-type">Type</span>[ModelType]</span>):
        <span class="hljs-string">"""
        数据库访问操作的基类对象(CRUD).
        * `model`: A SQLAlchemy model class
        """</span>
        
        self.model = model  <span class="hljs-comment"># 模型类型</span>

        <span class="hljs-comment"># 运行期获取主键字段类型</span>
        pk_column = inspect(model).primary_key[<span class="hljs-number">0</span>]
        self._pk_type = pk_column.<span class="hljs-built_in">type</span>.python_type  <span class="hljs-comment"># int / str</span>
</code></pre>
<p>因此对于单表的Get方法，我们修改下，让他匹配主键的类型进行比较，这样过对于严格类型判断的Postgresql也正常匹配了。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, db: AsyncSession, <span class="hljs-built_in">id</span>: PrimaryKeyType</span>) -&gt; <span class="hljs-type">Optional</span>[ModelType]:
        <span class="hljs-string">"""根据主键获取一个对象"""</span>
        
        <span class="hljs-comment">#对id的主键进行类型转换，self._pk_type在构造函数的初始化中获取</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-built_in">id</span> = self._pk_type(<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">except</span> Exception:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Invalid primary key type: <span class="hljs-subst">{<span class="hljs-built_in">id</span>}</span>"</span>)
        
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">id</span>, <span class="hljs-built_in">str</span>):
            query = select(self.model).<span class="hljs-built_in">filter</span>(func.lower(self.model.<span class="hljs-built_in">id</span>) == <span class="hljs-built_in">id</span>.lower())
        <span class="hljs-keyword">else</span>:
            query = select(self.model).<span class="hljs-built_in">filter</span>(self.model.<span class="hljs-built_in">id</span> == <span class="hljs-built_in">id</span>)

        result = <span class="hljs-keyword">await</span> db.execute(query)
        item = result.scalars().first()

        <span class="hljs-keyword">return</span> item
</code></pre>
<p>对于删除的数据，我们也可以类似的处理对比进行了。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session, Query
<span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> AsyncSession
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> delete <span class="hljs-keyword">as</span> sa_delete, update <span class="hljs-keyword">as</span> sa_update

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_byid</span>(<span class="hljs-params">self, db: AsyncSession, <span class="hljs-built_in">id</span>: PrimaryKeyType</span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">"""根据主键删除一个对象
    
    :param id: 主键值
    """</span>
    
    <span class="hljs-comment">#对id的主键进行类型转换，self._pk_type在构造函数的初始化中获取</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-built_in">id</span> = self._pk_type(<span class="hljs-built_in">id</span>)
    <span class="hljs-keyword">except</span> Exception:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Invalid primary key type: <span class="hljs-subst">{<span class="hljs-built_in">id</span>}</span>"</span>)
    
    del_query: sa_delete
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">id</span>, <span class="hljs-built_in">str</span>):
        del_query = sa_delete(self.model).where(
            func.lower(self.model.<span class="hljs-built_in">id</span>) == <span class="hljs-built_in">id</span>.lower()
        )
    <span class="hljs-keyword">else</span>:
        del_query = sa_delete(self.model).where(self.model.<span class="hljs-built_in">id</span> == <span class="hljs-built_in">id</span>)

    result = <span class="hljs-keyword">await</span> db.execute(del_query)

    <span class="hljs-keyword">await</span> db.commit()
    <span class="hljs-keyword">return</span> result.rowcount &gt; <span class="hljs-number">0</span>
</code></pre>
<p>对于提供多条件的查询或者过滤，我们可以使用<strong>where</strong>函数或者<strong>filter</strong>函数，在 SQLAlchemy 中，<code>select(...).where(...)</code> 和 <code>select(...).filter(...)</code> 都用于构造查询条件，如下所示等效。</p>
<pre><code class="hljs language-python" lang="python">query = select(self.model).where(self.model.<span class="hljs-built_in">id</span> == <span class="hljs-built_in">id</span>)

query = select(self.model).<span class="hljs-built_in">filter</span>(self.model.<span class="hljs-built_in">id</span> == <span class="hljs-built_in">id</span>)
</code></pre>
<p>我们可以通过sqlAlchemy的and_和or_函数来进行组合多个条件。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">from</span> sqlalchemy import ( <span class="hljs-keyword">Table</span>,<span class="hljs-keyword">Column</span>,and_,or_,<span class="hljs-keyword">asc</span>,<span class="hljs-keyword">desc</span>,<span class="hljs-keyword">select</span>,func,<span class="hljs-keyword">distinct</span>,text, <span class="hljs-type">Integer</span>)

....
    <span class="hljs-keyword">match</span> expression:
        <span class="hljs-keyword">case</span> "and":
            query <span class="hljs-operator">=</span> await db.execute(
                <span class="hljs-keyword">select</span>(self.model)
                .<span class="hljs-keyword">filter</span>(and_(  <span class="hljs-operator">*</span> where_list)) 
                .order_by(<span class="hljs-operator">*</span>order_by_list)
            )
        <span class="hljs-keyword">case</span> "or":
            query <span class="hljs-operator">=</span> await db.execute(
                <span class="hljs-keyword">select</span>(self.model).<span class="hljs-keyword">filter</span>(or_(  <span class="hljs-operator">*</span>where_list)) .order_by(<span class="hljs-operator">*</span>order_by_list)
            )
</code></pre>
<p>Python的SqlAlchemy提供 InstrumentedAttribute 对象来操作多个条件，如我们对于一些多条件的处理，可以利用它来传递多个参数。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_all_by_attributes</span>(<span class="hljs-params">
        self, db: AsyncSession, *attributes: InstrumentedAttribute, sorting: <span class="hljs-built_in">str</span> = <span class="hljs-string">""</span>
    </span>) -&gt; <span class="hljs-type">List</span>[ModelType] | <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""根据列名称和值获取相关的对象列表

        :param sorting: 格式：name asc 或 name asc,age desc
        :param attributes: SQLAlchemy InstrumentedAttribute objects，可以输入多个条件
        例子：User.id != 1 或者 User.username == "JohnDoe"
        """</span>

        order_by_list = parse_sort_string(sorting, self.model)
        query = select(self.model).<span class="hljs-built_in">filter</span>(and_(*attributes)).order_by(*order_by_list)
        
        result = <span class="hljs-keyword">await</span> db.execute(query)
        <span class="hljs-keyword">return</span> result.scalars().<span class="hljs-built_in">all</span>()
</code></pre>
<p>例如，对于 模型 Material 对象，我们对它进行多个条件的查询处理，如下所示，红色部分为 *attributes: InstrumentedAttribute 参数。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">items</span> = await super().get_all_by_attributes(
    db,
 <span class="hljs-attr">Material.id</span> == vercol.id,
    <span class="hljs-attr">Material.vercol</span> == vercol.vercol,
    <span class="hljs-attr">Material.ischecked</span> == <span class="hljs-number">0</span>,
    <span class="hljs-attr">Material.status</span> == <span class="hljs-number">0</span>, 
)
</code></pre>
<p>同样我们可以利用它来获取数量，或者判断多条件的记录是否存在。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/757682ba154a422caaa6813152a5e890~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LyN5Y2O6IGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767240347&amp;x-signature=TJaMmqNVSsmbwb%2FVQgrgL%2B05Ezk%3D" alt="image" loading="lazy"/></p>
<p> 在数据插入或者更新的操作中，我们可以接受对象类型或者字典类型的参数对象，因此方法如下所示。</p>
<pre><code class="hljs language-python" lang="python">   <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, db: AsyncSession, obj_in: DtoType | <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""更新对象
        
        :param obj_in: 对象输入数据,可以是 DTO 对象或字典
        """</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj_in, <span class="hljs-built_in">dict</span>):
                obj_id = obj_in.get(<span class="hljs-string">"id"</span>)
                <span class="hljs-keyword">if</span> obj_id <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"id is required for update"</span>)
                update_data = obj_in
            <span class="hljs-keyword">else</span>:
                obj_id = obj_in.<span class="hljs-built_in">id</span>
                <span class="hljs-comment"># update_data = vars(obj_in)  </span>
                update_data = obj_in.model_dump(exclude_unset=<span class="hljs-literal">True</span>)

            query = select(self.model).<span class="hljs-built_in">filter</span>(self.model.<span class="hljs-built_in">id</span> == obj_id)
            result = <span class="hljs-keyword">await</span> db.execute(query)
            db_obj = result.scalars().first()

            <span class="hljs-keyword">if</span> db_obj:
                <span class="hljs-comment"># 更新对象字段</span>
                <span class="hljs-keyword">for</span> field, value <span class="hljs-keyword">in</span> update_data.items():
                    <span class="hljs-comment"># 跳过以 "_" 开头的私有属性</span>
                    <span class="hljs-keyword">if</span> field.startswith(<span class="hljs-string">"_"</span>):
                        <span class="hljs-keyword">continue</span>
                    <span class="hljs-built_in">setattr</span>(db_obj, field, value)

                <span class="hljs-comment"># 处理更新前的回调处理</span>
 self.on_before_update(update_data, db_obj) <span class="hljs-comment"># 提交事务</span>
                <span class="hljs-keyword">await</span> db.commit()
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">except</span> SQLAlchemyError <span class="hljs-keyword">as</span> e:
            self.logger.error(<span class="hljs-string">f"update 操作出现错误: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">await</span> db.rollback()  <span class="hljs-comment"># 确保在出错时回滚事务</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<p>我们在插入或者更新数据的时候，一般会默认更新一些字段，如创建人，创建日期、编辑人，编辑日期等信息，我们可以把它单独作为一个可以给子类重写的函数，基类做一些默认的处理。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_before_update</span>(<span class="hljs-params">self, update_data: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>], db_obj: ModelType</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""更新对象前的回调函数，子类可以重写此方法

        可通过 setattr(db_obj, field, value) 设置字段值
        """</span>
        
        <span class="hljs-built_in">setattr</span>(db_obj, <span class="hljs-string">"edittime"</span>, datetime.now())
        user :CurrentUserIns  = get_current_user()
        <span class="hljs-keyword">if</span> user:
            <span class="hljs-built_in">setattr</span>(db_obj, <span class="hljs-string">"editor"</span>, user.fullname)
            <span class="hljs-built_in">setattr</span>(db_obj, <span class="hljs-string">"editor_id"</span>, user.<span class="hljs-built_in">id</span>)

            <span class="hljs-built_in">setattr</span>(db_obj, <span class="hljs-string">"company_id"</span>, user.company_id)
            <span class="hljs-built_in">setattr</span>(db_obj, <span class="hljs-string">"companyname"</span>, user.companyname)
</code></pre>
<p>有时候，如果我们需要获取某个字段非重复的列表，用来做为动态下拉列表的数据，那么我们可以通过下面函数封装下。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_field_list</span>(<span class="hljs-params">self, db: AsyncSession, field_name: <span class="hljs-built_in">str</span></span>) -&gt; Iterable[<span class="hljs-built_in">str</span>]:
        <span class="hljs-string">"""获取指定字段值的唯一列表

        :param field_name: 字段名称
        """</span>

        field = <span class="hljs-built_in">getattr</span>(self.model, field_name)
        query = select(distinct(field))
        result = <span class="hljs-keyword">await</span> db.execute(query)
        <span class="hljs-keyword">return</span> result.scalars().<span class="hljs-built_in">all</span>()
</code></pre>
<h3 data-id="heading-2">3、多表联合的处理操作 </h3>
<p>多表操作，也是我们经常碰到的处理方式，如对于字典类型和字典项目，他们是两个表，需要联合起来获取数据，那么就需要多表的联合操作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcde1deeeecb42ee9bf077f276e466df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LyN5Y2O6IGq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767240347&amp;x-signature=gqBb0Bk5oM2cfSPVZPjahlYledk%3D" alt="image" loading="lazy"/></p>
<p> 如下是字典CRUD类中，联合字典类型获取数据的记录处理。</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_dict_by_typename</span>(<span class="hljs-params">self, db: AsyncSession, dicttype_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>:
        <span class="hljs-string">"""根据字典类型名称获取所有该类型的字典列表集合"""</span>
        result = <span class="hljs-keyword">await</span> db.execute(
            select(self.model)
             .join(DictType, DictType.<span class="hljs-built_in">id</span> == self.model.dicttype_id)   <span class="hljs-comment"># 关联字典类型表</span>
            .<span class="hljs-built_in">filter</span>(DictType.name == dicttype_name) <span class="hljs-comment"># 过滤字典类型名称</span>
            .order_by(DictData.seq)  <span class="hljs-comment"># 排序</span>
        )
        items = result.scalars().<span class="hljs-built_in">all</span>()

        <span class="hljs-built_in">dict</span> = {}
        <span class="hljs-keyword">for</span> info <span class="hljs-keyword">in</span> items:
            <span class="hljs-keyword">if</span> info.name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:
                <span class="hljs-built_in">dict</span>[info.name] = info.value

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>
</code></pre>
<p>如果我们需要对某个表的递归获取树列表，可以如下处理</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tree</span>(<span class="hljs-params">self, db: AsyncSession, pid: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[DictType]:
        <span class="hljs-string">"""获取字典类型一级列表及其下面的内容"""</span>

        <span class="hljs-comment"># 使用三元运算符将 pid 设为 "-1"（如果 pid 是 null 或空白）或保持原值</span>
        pid = <span class="hljs-string">"-1"</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pid <span class="hljs-keyword">or</span> pid.strip() == <span class="hljs-string">""</span> <span class="hljs-keyword">else</span> pid
        result = <span class="hljs-keyword">await</span> db.execute(
            select(self.model)
            .<span class="hljs-built_in">filter</span>(self.model.pid == pid)
            .options(selectinload(DictType.children))
        )
        nodes = result.scalars().<span class="hljs-built_in">all</span>()
        <span class="hljs-keyword">return</span> nodes
</code></pre>
<p>我们来假设用户和文章的示例表结构（ORM 模型，如下所示。</p>
<pre><code class="hljs language-ini" lang="ini">class User(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"users"</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)
    <span class="hljs-attr">name</span> = Column(String)
    <span class="hljs-attr">email</span> = Column(String)
    <span class="hljs-attr">articles</span> = relationship(<span class="hljs-string">"Article"</span>, back_populates=<span class="hljs-string">"author"</span>)


class Article(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"articles"</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)
    <span class="hljs-attr">title</span> = Column(String)
    <span class="hljs-attr">content</span> = Column(Text)
    <span class="hljs-attr">user_id</span> = Column(Integer, ForeignKey(<span class="hljs-string">"users.id"</span>))
    <span class="hljs-attr">author</span> = relationship(<span class="hljs-string">"User"</span>, back_populates=<span class="hljs-string">"articles"</span>)
</code></pre>
<p>我们可以通过下面函数处理获得相关的记录集合。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_articles</span>(<span class="hljs-params">db: AsyncSession</span>):
    stmt = (
        select(User, Article)
        .join(Article, Article.user_id == User.<span class="hljs-built_in">id</span>)
    )
    result = <span class="hljs-keyword">await</span> db.execute(stmt)
    <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">all</span>()   <span class="hljs-comment"># [ (User(), Article()), . ..]</span>
</code></pre>
<p>如果需要可以使用outer_join函数处理</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users_with_articles</span>(<span class="hljs-params">db: AsyncSession</span>):
    stmt = (
        select(User, Article)
        .outerjoin(Article, Article.user_id == User.<span class="hljs-built_in">id</span>)
    )
    result = <span class="hljs-keyword">await</span> db.execute(stmt)
    <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">all</span>()  <span class="hljs-comment"># 用户即便没有文章也会出现</span>
</code></pre>
<p>如果我们需要获取有文章的所有用户，如下所示。</p>
<pre><code class="hljs language-scss" lang="scss">async def <span class="hljs-built_in">get_users_with_articles</span>(db: AsyncSession):
    stmt = <span class="hljs-built_in">select</span>(User).<span class="hljs-built_in">options</span>(<span class="hljs-built_in">selectinload</span>(User.articles))  # 自动 load 关联
    result = await db.<span class="hljs-built_in">execute</span>(stmt)
    return result.<span class="hljs-built_in">scalars</span>().<span class="hljs-built_in">all</span>()
</code></pre>
<p><code>selectinload</code> 会执行两次 SQL，但效率高，不会产生笛卡尔积，非常适合集合查询。</p>
<p>多表链式 Join的处理，可以获得两个表的不同信息进行组合。</p>
<pre><code class="hljs language-css" lang="css">async def get_articles_with_author(db: AsyncSession):
    stmt = (
        <span class="hljs-built_in">select</span>(Article.title, User.name.<span class="hljs-built_in">label</span>(<span class="hljs-string">"author"</span>))
        .<span class="hljs-built_in">join</span>(User, Article.user_id == User.id)
    )
    rows = await db.<span class="hljs-built_in">execute</span>(stmt)
    return rows.<span class="hljs-built_in">mappings</span>().<span class="hljs-built_in">all</span>()   # 以 dict 形式返回 [{'title':..., <span class="hljs-string">'author'</span>:...}]
</code></pre>
<p>带筛选条件与分页的处理实现，如下所示</p>
<pre><code class="hljs language-scss" lang="scss">async def <span class="hljs-built_in">search_articles</span>(db: AsyncSession, keyword: str, page: int = <span class="hljs-number">1</span>, size: int = <span class="hljs-number">10</span>):
    stmt = (
        <span class="hljs-built_in">select</span>(Article, User.name.<span class="hljs-built_in">label</span>(<span class="hljs-string">"author"</span>))
        .<span class="hljs-built_in">join</span>(User)
        .<span class="hljs-built_in">filter</span>(Article.title.<span class="hljs-built_in">contains</span>(keyword))
        .<span class="hljs-built_in">offset</span>((page - <span class="hljs-number">1</span>) * size)
        .<span class="hljs-built_in">limit</span>(size)
    )
    result = await db.<span class="hljs-built_in">execute</span>(stmt)
    return result.<span class="hljs-built_in">mappings</span>().<span class="hljs-built_in">all</span>()
</code></pre>
<p> 
对于权限管理系统来说，一般有用户、角色，以及用户角色的中间表，我们来看看这个在SQLAlchemy最佳实践是如何的操作。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import Table, Column, Integer, ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column
from database import Base

<span class="hljs-comment"># --- 中间表写法 ---</span>
<span class="hljs-attr">role_user</span> = Table(
    "role_user",
    Base.metadata,
    Column("user_id", ForeignKey("users.id"), <span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>),
    Column("role_id", ForeignKey("roles.id"), <span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>)
)

class User(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"users"</span>
    id: Mapped<span class="hljs-section">[int]</span> = mapped_column(<span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>)
    username: Mapped<span class="hljs-section">[str]</span> = mapped_column()

    roles: Mapped<span class="hljs-section">[list["Role"]]</span> = relationship(
        <span class="hljs-attr">secondary</span>=role_user,
        <span class="hljs-attr">back_populates</span>=<span class="hljs-string">"users"</span>,
        <span class="hljs-attr">lazy</span>=<span class="hljs-string">"selectin"</span>
    )

class Role(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"roles"</span>
    id: Mapped<span class="hljs-section">[int]</span> = mapped_column(<span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>)
    name: Mapped<span class="hljs-section">[str]</span> = mapped_column()

    users: Mapped<span class="hljs-section">[list[User]]</span> = relationship(
        <span class="hljs-attr">secondary</span>=role_user,
        <span class="hljs-attr">back_populates</span>=<span class="hljs-string">"roles"</span>,
        <span class="hljs-attr">lazy</span>=<span class="hljs-string">"selectin"</span>
    )
</code></pre>
<p>在 SQLAlchemy 声明多对多关系时，<code>secondary</code> 参数既可以填 <strong>字符串形式的表名</strong>，也可以填 <strong>已经定义好的中间表对象（Table 对象）。</strong></p>
<p><strong>① econdary="role_user" —— 使用字符串表名</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">roles</span> = relationship(<span class="hljs-string">"Role"</span>, secondary=<span class="hljs-string">"role_user"</span>, back_populates=<span class="hljs-string">"users"</span>)
</code></pre>
<p><strong>② secondary=role_user —— 传入中间表对象（推荐方式）</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">role_user</span> = Table(
    "role_user",
    Base.metadata,
    Column("user_id", ForeignKey("users.id"), <span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>),
    Column("role_id", ForeignKey("roles.id"), <span class="hljs-attr">primary_key</span>=<span class="hljs-literal">True</span>)
)

<span class="hljs-attr">roles</span> = relationship(<span class="hljs-string">"Role"</span>, secondary=role_user, back_populates=<span class="hljs-string">"users"</span>)
</code></pre>
<p>对于如果获取对应角色的用户记录，我们可以通过下面方式获取（通过连接中间表的方式）</p>
<pre><code class="hljs language-ini" lang="ini">async def get_users_by_role(db: AsyncSession, role_id: int) -&gt; list<span class="hljs-section">[User]</span>:
    <span class="hljs-attr">stmt</span> = (
        select(User)
        .join(role_user, <span class="hljs-attr">role_user.c.user_id</span> == User.id)
        .where(<span class="hljs-attr">role_user.c.role_id</span> == role_id)
    )
    <span class="hljs-attr">result</span> = await db.execute(stmt)
    return result.scalars().all()
</code></pre>
<p>也可以下面的方式进行处理（使用 relationship any()），效果是一样的。</p>
<pre><code class="hljs language-python" lang="python">select(User).<span class="hljs-built_in">filter</span>(User.roles.<span class="hljs-built_in">any</span>(<span class="hljs-built_in">id</span>=role_id))
</code></pre>
<p>如果需要写入用户、角色的关联关系，我们可以使用下面方法来通过中间表进行判断并写入记录。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import select, insert

async def add_users_to_role(db: AsyncSession, role_id: int, user_ids: list<span class="hljs-section">[int]</span>):
    <span class="hljs-comment"># 1️⃣ 查询已有关联 user_id</span>
    <span class="hljs-attr">stmt</span> = select(role_user.c.user_id).where(role_user.c.role_id == role_id)
    <span class="hljs-attr">res</span> = await db.execute(stmt)
    <span class="hljs-attr">existing_user_ids</span> = {row[<span class="hljs-number">0</span>] for row in res.fetchall()}

    <span class="hljs-comment"># 2️⃣ 过滤出新的 user_id</span>
    <span class="hljs-attr">new_user_ids</span> = [uid for uid in user_ids if uid not in existing_user_ids]
    if not new_user_ids:
        return 0  <span class="hljs-comment"># 没有新增</span>

    <span class="hljs-comment"># 3️⃣ 批量插入</span>
    <span class="hljs-attr">values</span> = [{<span class="hljs-string">"user_id"</span>: uid, <span class="hljs-string">"role_id"</span>: role_id} for uid in new_user_ids]
    <span class="hljs-attr">stmt</span> = insert(role_user).values(values)
    await db.execute(stmt)
    await db.commit()

    return len(new_user_ids)
</code></pre>
<p>如果只是单个记录的插入，可以利用下面的方式处理。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> select, insert

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_user_to_role</span>(<span class="hljs-params">db: AsyncSession, role_id: <span class="hljs-built_in">int</span>, user_id: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-comment"># 1️⃣ 检查是否已存在关联</span>
    stmt = select(role_user).where(
        role_user.c.role_id == role_id,
        role_user.c.user_id == user_id
    )
    res = <span class="hljs-keyword">await</span> db.execute(stmt)
    exists = res.first()

    <span class="hljs-keyword">if</span> exists:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 已存在，不再插入</span>

    <span class="hljs-comment"># 2️⃣ 插入记录</span>
    stmt = insert(role_user).values(user_id=user_id, role_id=role_id)
    <span class="hljs-keyword">await</span> db.execute(stmt)
    <span class="hljs-keyword">await</span> db.commit()

    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>以上就是对于在Python+FastAPI的后端项目中使用SqlAlchemy操作数据的几种常见方式，包括单表处理，多表关联、中间表的数据维护和定义等内容，是我们在操作常规数据的时候，经常碰到的几种方式。</p>
<p>希望上文对你有所启发和帮助，感谢阅读。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python性能翻倍的5个隐藏技巧：让你的代码跑得比同事快50%]]></title>    <link>https://juejin.cn/post/7587322796825870376</link>    <guid>https://juejin.cn/post/7587322796825870376</guid>    <pubDate>2025-12-25T04:16:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587322796825870376" data-draft-id="7587327550872895488" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python性能翻倍的5个隐藏技巧：让你的代码跑得比同事快50%"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2025-12-25T04:16:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python性能翻倍的5个隐藏技巧：让你的代码跑得比同事快50%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T04:16:48.000Z" title="Thu Dec 25 2025 04:16:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Python性能翻倍的5个隐藏技巧：让你的代码跑得比同事快50%</strong></h2>
<h3 data-id="heading-1">引言</h3>
<p>Python因其简洁易读的语法和强大的生态系统而广受欢迎，但在性能方面却常常被人诟病。然而，Python的性能问题并非无解——通过一些鲜为人知的优化技巧，你可以显著提升代码的执行效率。本文将深入探讨5个经过验证的隐藏技巧，帮助你轻松实现性能翻倍，甚至在某些场景下比同事的代码快50%以上。这些技巧涵盖了从数据结构选择到底层优化的多个层面，适合中高级开发者进一步提升代码效率。</p>
<hr/>
<h3 data-id="heading-2">1. 使用内置函数和库替代手动实现</h3>
<h4 data-id="heading-3">为什么有效？</h4>
<p>Python的内置函数（如<code>map()</code>、<code>filter()</code>、<code>sum()</code>）和标准库（如<code>collections</code>、<code>itertools</code>）是用C实现的，执行速度远高于纯Python代码。许多开发者习惯手动实现这些功能，却忽略了内置函数的性能优势。</p>
<h4 data-id="heading-4">示例对比</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 手动求和</span>
total = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> large_list:
    total += num

<span class="hljs-comment"># 使用sum()内置函数</span>
total = <span class="hljs-built_in">sum</span>(large_list)
</code></pre>
<p>后者不仅更简洁，而且在处理大规模数据时速度可能快2-3倍。类似的优化还包括：</p>
<ul>
<li>用<code>collections.defaultdict</code>替代字典的手动初始化</li>
<li>用<code>itertools.chain</code>合并多个迭代器而非嵌套循环</li>
</ul>
<h4 data-id="heading-5">实测数据</h4>
<p>在1000万次加法测试中，<code>sum()</code>比手动循环快约60%。</p>
<hr/>
<h3 data-id="heading-6">2. 利用局部变量加速访问</h3>
<h4 data-id="heading-7">原理分析</h4>
<p>Python的变量查找遵循LEGB规则（Local → Enclosing → Global → Built-in），局部变量的访问速度最快。将频繁使用的全局变量或类属性赋值给局部变量，可以减少查找时间。</p>
<h4 data-id="heading-8">优化示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 未优化版本</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">data</span>):
    result = []
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:
        result.append(math.sqrt(item) * config.factor)  <span class="hljs-comment"># config.factor是全局变量</span>

<span class="hljs-comment"># 优化后版本</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">data</span>):
    factor = config.factor  <span class="hljs-comment"># 局部化全局变量</span>
    sqrt_func = math.sqrt   <span class="hljs-comment"># 避免多次属性查找</span>
    result = []
    append = result.append  <span class="hljs-comment"># 方法也转为局部变量</span>
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:
        append(sqrt_func(item) * factor)
</code></pre>
<p>这种优化在循环次数超过10万次时可能带来20%-30%的性能提升。</p>
<hr/>
<h3 data-id="heading-9">3. <strong><strong>slots</strong></strong>魔法：减少内存占用与加速属性访问</h3>
<h4 data-id="heading-10"><strong>slots</strong>的作用</h4>
<p>默认情况下，Python类的实例使用字典（<code>__dict__</code>）存储属性，这带来了灵活性但也增加了内存和访问开销。通过定义<code>__slots__</code>，可以固定类的属性列表，节省内存并提升访问速度。</p>
<h4 data-id="heading-11"><strong>示例代码</strong></h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegularUser</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, uid</span>):
        self.name = name
        self.uid = uid

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SlotUser</span>:
    __slots__ = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'uid'</span>]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, uid</span>):
        self.name = name
        self.uid = uid
</code></pre>
<h4 data-id="heading-12"><strong>性能对比</strong></h4>
<ul>
<li><strong>内存占用</strong>：在100万个实例的测试中，使用<code>__slots__</code>可减少40%-50%的内存。</li>
<li><strong>访问速度</strong>：属性读取速度快约20%。</li>
</ul>
<p>注意：仅适用于属性固定的类，且会牺牲动态添加属性的能力。</p>
<hr/>
<h3 data-id="heading-13">4. NumPy/Pandas向量化操作替代循环</h3>
<h4 data-id="heading-14"><strong>向量化的力量</strong></h4>
<p>对于数值计算任务（如矩阵运算、统计聚合），NumPy和Pandas的底层C/Fortran实现比Python循环高效几个数量级。关键在于避免逐元素操作，转而使用内置的向量化函数。</p>
<h4 data-id="heading-15"><strong>典型案例</strong></h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 低效的逐元素平方</span>
squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> big_list]

<span class="hljs-comment"># NumPy向量化版本</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
arr = np.array(big_list)
squares = arr ** <span class="hljs-number">2</span>  <span class="hljs-comment"># Speedup: ~100x for large arrays</span>
</code></pre>
<h4 data-id="heading-16"><strong>进阶技巧</strong></h4>
<ul>
<li>Pandas的<code>.apply()</code>仍然较慢，优先使用<code>.map()</code>或<code>.transform()</code></li>
<li>NumPy的广播机制（Broadcasting）可避免显式循环</li>
</ul>
<hr/>
<h3 data-id="heading-17">5. JIT编译：用Numba突破解释器限制</h3>
<h4 data-id="heading-18"><strong>Numba简介</strong></h4>
<p>Numba是一个JIT（Just-In-Time）编译器，能将Python函数编译为机器码。特别适合数值计算密集型任务（如科学计算、算法核心逻辑）。无需重写代码——只需添加一个装饰器即可获得C级别的速度。</p>
<h4 data-id="heading-19"><strong>使用方法</strong></h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> njit

<span class="hljs-meta">@njit(<span class="hljs-params">fastmath=<span class="hljs-literal">True</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">monte_carlo_pi</span>(<span class="hljs-params">n_samples</span>): 
    acc = <span class="hljs-number">0</span> 
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_samples): 
        x, y = np.random.random(), np.random.random() 
        <span class="hljs-keyword">if</span> (x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>) &lt; <span class="hljs-number">1.0</span>: 
            acc +=<span class="hljs-number">1</span> 
    return4 * acc / n_samples 

<span class="hljs-comment"># First run includes compilation time </span>
pi_estimate=monte_carlo_pi(<span class="hljs-number">1000000</span>)<span class="hljs-comment"># Subsequent calls are极速执行!</span>
</code></pre>
<h4 data-id="heading-20"><strong>性能收益</strong></h4>
<p>在蒙特卡洛模拟等场景下,Numba可提速100倍以上(对比纯Python实现)。</p>
<hr/>
<p>###总结</p>
<p>这五个技巧覆盖了从语言特性(<code>slots</code>,局部变量)到工具链(Numba,NumPy)的多维度优化手段:</p>
<p>1.<strong>优先使用内置函数/库</strong>
2.<strong>局部化频繁访问的变量</strong>
3.<strong>对固定属性类启用slots</strong>
4.<strong>数值计算务必向量化</strong>
5.<strong>关键路径考虑JIT编译</strong></p>
<p>需要强调的是:优化前务必先用cProfile定位瓶颈!盲目应用这些技术可能导致代码可读性下降却收效甚微。</p>
<p>当你将这些方法组合使用时,完全可能在保持Python开发效率的同时,让关键代码段的性能匹敌C/Java实现—这才是真正的"全栈Python"高手之道!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【节点】[ChannelMask节点]原理解析与实际应用]]></title>    <link>https://juejin.cn/post/7587336857538658313</link>    <guid>https://juejin.cn/post/7587336857538658313</guid>    <pubDate>2025-12-25T04:38:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587336857538658313" data-draft-id="7587325326046429193" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【节点】[ChannelMask节点]原理解析与实际应用"/> <meta itemprop="keywords" content="游戏开发,图形学,Unity3D"/> <meta itemprop="datePublished" content="2025-12-25T04:38:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SmalBox"/> <meta itemprop="url" content="https://juejin.cn/user/2218166695237532"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【节点】[ChannelMask节点]原理解析与实际应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2218166695237532/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SmalBox
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T04:38:50.000Z" title="Thu Dec 25 2025 04:38:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></p>
</blockquote>
<h2 data-id="heading-0">节点功能概述</h2>
<p>ChannelMask节点是Unity通用渲染管线（URP）中Shader Graph的重要组成部分，专门用于实现通道级的颜色操作。该节点通过动态通道选择机制，能够对输入向量进行选择性屏蔽，其核心优势在于非破坏性编辑——仅调整指定通道，而不会影响其他数据。这一特性在材质编辑、特效合成以及性能优化等场景中具有关键作用。</p>
<p>在URP渲染管线中，ChannelMask节点与SRP Batcher深度兼容，通过批量处理通道操作有效减少Draw Call。节点具备动态维度适配能力，可自动处理Vector2/Vector3/Vector4等不同类型的输入。例如，当连接纹理采样节点时，系统会根据RGBA通道自动生成相应选项，从而显著降低Shader开发的复杂度，使开发者能够更专注于视觉效果的实现。</p>
<h2 data-id="heading-1">端口配置详解</h2>
<p><img src="https://docs.unity.cn/cn/Packages-cn/com.unity.shadergraph@14.0/manual/images/ChannelMaskNodeThumb.png" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">输入端口（In）</h3>
<ul>
<li><strong>类型</strong>：动态矢量（Dynamic Vector）</li>
<li><strong>绑定</strong>：无</li>
<li><strong>特性</strong>：
<ul>
<li>支持自动类型推导，可连接任意输出矢量型节点</li>
<li>输入维度决定可选通道范围（例如，Vector3输入仅显示R、G、B选项）</li>
<li>在URP管线中，该端口与StandardLit材质中的基础色通道完全兼容</li>
</ul>
</li>
</ul>
<h3 data-id="heading-3">输出端口（Out）</h3>
<ul>
<li><strong>类型</strong>：动态矢量</li>
<li><strong>绑定</strong>：无</li>
<li><strong>特性</strong>：
<ul>
<li>输出维度与输入保持一致，确保数据流完整性</li>
<li>支持多节点串联输出，便于构建复杂通道处理流水线</li>
<li>在URP渲染过程中，输出结果可直接应用于Albedo、Metallic等材质通道</li>
</ul>
</li>
</ul>
<h2 data-id="heading-4">控件参数分析</h2>
<h3 data-id="heading-5">Channels控件</h3>
<ul>
<li><strong>类型</strong>：动态掩码下拉选单</li>
<li><strong>行为逻辑</strong>：
<ul>
<li>当输入为Vector4时，显示R、G、B、A四个选项</li>
<li>支持多选操作（例如同时屏蔽R和G通道）</li>
<li>选项命名与URP材质通道规范保持一致</li>
</ul>
</li>
<li><strong>特殊场景</strong>：
<ul>
<li>连接法线贴图时，自动转换为X、Y、Z通道选项</li>
<li>处理HDR颜色时，通道值会依据URP线性空间规则重新计算</li>
</ul>
</li>
</ul>
<h2 data-id="heading-6">数学原理与代码实现</h2>
<h3 data-id="heading-7">HLSL核心逻辑</h3>
<p><code>// 示例：屏蔽红色通道的Vector4处理 void Unity_ChannelMask_Red_float4(float4 In, out float4 Out) {     Out = float4(0, In.g, In.b, In.a); }</code></p>
<h3 data-id="heading-8">URP适配特性</h3>
<ol>
<li><strong>线性空间处理</strong>：在URP的线性颜色空间下，通道屏蔽操作自动应用Gamma校正</li>
<li><strong>HDR支持</strong>：处理HDR颜色时，屏蔽操作会保留高动态范围数据</li>
<li><strong>批处理优化</strong>：在SRP Batcher中，相同通道掩码的节点会被合并为单个Draw Call</li>
</ol>
<h2 data-id="heading-9">实际应用场景</h2>
<h3 data-id="heading-10">材质编辑</h3>
<ul>
<li><strong>金属度控制</strong>：通过屏蔽红色通道分离金属反射信息</li>
<li><strong>法线贴图处理</strong>：屏蔽Alpha通道以实现法线压缩</li>
<li><strong>次表面散射</strong>：单独处理绿色通道以模拟皮肤透光效果</li>
</ul>
<h3 data-id="heading-11">特效制作</h3>
<ul>
<li><strong>发光效果</strong>：屏蔽所有通道仅保留亮度通道</li>
<li><strong>颜色渐变</strong>：动态切换通道实现实时颜色过渡</li>
<li><strong>故障特效</strong>：随机屏蔽通道以模拟数字失真效果</li>
</ul>
<h3 data-id="heading-12">性能优化</h3>
<ul>
<li><strong>通道压缩</strong>：屏蔽无用通道以减少纹理采样量</li>
<li><strong>LOD适配</strong>：根据距离动态调整通道精度</li>
<li><strong>移动端优化</strong>：在低端设备上屏蔽非必要通道</li>
</ul>
<h2 data-id="heading-13">性能优化策略</h2>
<h3 data-id="heading-14">URP专属优化</h3>
<ol>
<li><strong>SRP Batcher兼容</strong>：确保通道掩码操作在相同材质实例中进行</li>
<li><strong>动态分辨率适配</strong>：根据屏幕分辨率调整通道精度</li>
<li><strong>GPU Instancing支持</strong>：对使用相同通道掩码的物体进行批处理</li>
</ol>
<h3 data-id="heading-15">通用优化技巧</h3>
<ul>
<li>避免在片段着色器中频繁修改通道掩码</li>
<li>使用通道预计算节点减少实时计算量</li>
<li>利用URP的Shader Variants系统创建不同通道配置的变体</li>
</ul>
<h2 data-id="heading-16">常见问题解决方案</h2>
<h3 data-id="heading-17">URP特有问题</h3>
<ol>
<li><strong>通道不显示</strong>：检查是否启用了URP的线性颜色空间</li>
<li><strong>性能下降</strong>：确认在移动端是否启用了不必要的通道</li>
<li><strong>渲染异常</strong>：验证通道掩码是否与URP材质属性冲突</li>
</ol>
<h3 data-id="heading-18">通用解决方案</h3>
<ul>
<li>使用URP的Shader Graph预览功能实时验证通道效果</li>
<li>通过Frame Debugger分析通道操作对渲染管线的影响</li>
<li>在URP的Quality设置中启用通道操作优化选项</li>
</ul>
<h2 data-id="heading-19">高级应用技巧</h2>
<h3 data-id="heading-20">URP管线集成</h3>
<ol>
<li><strong>与Volume系统结合</strong>：通过通道掩码实现动态材质修改</li>
<li><strong>与Lit Shader配合</strong>：控制URP标准材质的不同通道</li>
<li><strong>与Post Processing集成</strong>：在后期处理中应用通道操作</li>
</ol>
<h3 data-id="heading-21">动态通道控制</h3>
<ul>
<li>通过URP的MaterialPropertyBlock实现运行时通道修改</li>
<li>结合URP的Render Feature创建自定义通道处理流程</li>
<li>利用URP的Shader Variants系统创建多通道配置</li>
</ul>
<h2 data-id="heading-22">与其他节点的配合使用</h2>
<h3 data-id="heading-23">URP核心节点</h3>
<ol>
<li><strong>Sample Texture 2D</strong>：在纹理采样后应用通道掩码</li>
<li><strong>URP Lit Shader</strong>：控制标准材质的通道输出</li>
<li><strong>URP Render Features</strong>：在渲染管线中插入通道处理</li>
</ol>
<h3 data-id="heading-24">通用节点组合</h3>
<ul>
<li>与Math节点配合实现通道值计算</li>
<li>与Condition节点结合创建动态通道切换</li>
<li>与Texture Sample节点连接实现基于纹理的通道控制</li>
</ul>
<h2 data-id="heading-25">最佳实践指南</h2>
<h3 data-id="heading-26">URP开发规范</h3>
<ol>
<li>在URP项目中优先使用通道掩码而非颜色混合</li>
<li>为移动端创建简化通道配置的变体</li>
<li>利用URP的Shader Variants系统管理多通道配置</li>
</ol>
<h3 data-id="heading-27">通用实践建议</h3>
<ul>
<li>为复杂通道操作创建注释节点</li>
<li>使用URP的Shader Graph预览功能验证效果</li>
<li>定期检查通道操作对性能的影响</li>
</ul>
<hr/>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fchenghai37%2Fcategory_13074589.html%3Ffromshare%3Dblogcolumn%26sharetype%3Dblogcolumn%26sharerId%3D13074589%26sharerefer%3DPC%26sharesource%3Dchenghai37%26sharefrom%3Dfrom_link" target="_blank" title="https://blog.csdn.net/chenghai37/category_13074589.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13074589&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" ref="nofollow noopener noreferrer">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong>
（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS 全局样式污染问题复盘]]></title>    <link>https://juejin.cn/post/7587284708947771407</link>    <guid>https://juejin.cn/post/7587284708947771407</guid>    <pubDate>2025-12-25T02:22:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587284708947771407" data-draft-id="7587261253912969231" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS 全局样式污染问题复盘"/> <meta itemprop="keywords" content="CSS"/> <meta itemprop="datePublished" content="2025-12-25T02:22:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大象的鼻子那么长"/> <meta itemprop="url" content="https://juejin.cn/user/2277843821926871"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS 全局样式污染问题复盘
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2277843821926871/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大象的鼻子那么长
  </span> <!----> <!----> <div class="vip-level" data-v-cd7d0a50="" data-v-292f6e48=""><span class="tooltip" data-v-cd7d0a50=""><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        VIP.4 融会贯通
      </div><span class="byte-tooltip__wrapper"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="VIP.4 融会贯通" title="VIP.4 融会贯通" class="lazy" style="aspect-ratio:NaN;" data-v-5244ef91="" data-v-cd7d0a50=""/></span></span></div> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:22:34.000Z" title="Thu Dec 25 2025 02:22:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、问题现象</h2>
<h3 data-id="heading-1">1.1 问题描述</h3>
<p>VGM 编辑弹窗（使用 <code>CmcDialog</code> 组件）出现异常的内边距，导致弹窗内容布局错乱，表单元素间距过大。</p>
<h3 data-id="heading-2">1.2 问题截图</h3>
<p>弹窗内容区域出现了不应有的 <code>padding: 52px 50px</code> 样式，导致：</p>
<ul>
<li>表单内容被压缩</li>
<li>布局与设计稿不符</li>
<li>视觉效果异常</li>
</ul>
<h3 data-id="heading-3">1.3 影响范围</h3>
<p>所有使用 <code>el-dialog</code> 或基于 <code>el-dialog</code> 封装的组件（如 <code>CmcDialog</code>）都受到影响。</p>
<hr/>
<h2 data-id="heading-4">二、问题定位</h2>
<h3 data-id="heading-5">2.1 排查过程</h3>
<ol>
<li><strong>检查组件自身样式</strong> - <code>CmcDialog</code> 组件样式正常</li>
<li><strong>检查父组件样式</strong> - 使用 <code>CmcDialog</code> 的页面无异常样式</li>
<li><strong>使用 DevTools 检查</strong> - 发现 <code>.el-dialog</code> 被注入了全局样式</li>
<li><strong>全局搜索污染源</strong> - 搜索 <code>padding: 52px 50px</code> 定位到问题文件</li>
</ol>
<h3 data-id="heading-6">2.2 问题根源</h3>
<p>在 <code>src/views/search_service/ship-schedules/components/Subscribe.vue</code> 中发现以下代码：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;style scoped lang="scss"&gt;
.subscriber-dialog {
  :global(.el-dialog) {
    padding: 52px 50px;
  }
}
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-7">2.3 为什么会造成全局污染？</h3>
<p>这里涉及到 Vue Scoped CSS 和 <code>:global()</code> 的工作原理：</p>
<h4 data-id="heading-8">Vue Scoped CSS 原理</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 编译前 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.subscriber-dialog</span> {
    <span class="hljs-attribute">color</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 编译后 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.subscriber-dialog</span><span class="hljs-selector-attr">[data-v-xxxxx]</span> {
    <span class="hljs-attribute">color</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

</code></pre>
<p>Vue 会为 scoped 样式添加唯一的 <code>data-v-xxxxx</code> 属性选择器，确保样式只作用于当前组件。</p>
<h4 data-id="heading-9">:global() 的作用</h4>
<p><code>:global()</code> 是 CSS Modules 和 Vue 的一个特性，用于<strong>跳过 scoped 限制</strong>，生成全局样式：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 编译前</span>
<span class="hljs-selector-class">.subscriber-dialog</span> {
  :<span class="hljs-built_in">global</span>(.el-dialog) {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
  }
}

<span class="hljs-comment">// 编译后（注意：.el-dialog 没有 data-v 属性！）</span>
<span class="hljs-selector-class">.subscriber-dialog</span><span class="hljs-selector-attr">[data-v-xxxxx]</span> <span class="hljs-selector-class">.el-dialog</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
}

</code></pre>
<h4 data-id="heading-10">关键问题：el-dialog 的 DOM 结构</h4>
<p>Element Plus 的 <code>el-dialog</code> 默认会通过 <code>append-to-body</code> 将 DOM 挂载到 <code>&lt;body&gt;</code> 下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"subscriber-dialog"</span> <span class="hljs-attr">data-v-xxxxx</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 触发按钮 --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Dialog 被 teleport 到 body 下 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el-overlay subscriber-dialog"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- modal-class 应用在这里 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el-dialog"</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 实际的 dialog --&gt;</span>
      ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

</code></pre>
<p>由于 <code>modal-class="subscriber-dialog"</code> 应用到了 <code>el-overlay</code> 上，而 <code>.el-dialog</code> 是其子元素，所以选择器 <code>.subscriber-dialog .el-dialog</code> 能够匹配到！</p>
<p><strong>但问题在于</strong>：<code>:global(.el-dialog)</code> 生成的样式<strong>没有足够的特异性限制</strong>，当其他页面的 dialog 也被挂载到 body 时，如果 CSS 加载顺序导致这个样式后加载，就会覆盖其他 dialog 的样式。</p>
<hr/>
<h2 data-id="heading-11">三、深度原理剖析</h2>
<h3 data-id="heading-12">3.1 CSS 特异性（Specificity）</h3>
<p>CSS 特异性决定了当多个规则应用于同一元素时，哪个规则优先：</p>

























<table><thead><tr><th>选择器类型</th><th>特异性值</th></tr></thead><tbody><tr><td>内联样式</td><td>1000</td></tr><tr><td>ID 选择器</td><td>100</td></tr><tr><td>类/属性/伪类</td><td>10</td></tr><tr><td>元素/伪元素</td><td>1</td></tr></tbody></table>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 特异性：20（两个类选择器）</span>
<span class="hljs-selector-class">.subscriber-dialog</span> <span class="hljs-selector-class">.el-dialog</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
}

<span class="hljs-comment">// 特异性：20（两个类选择器）</span>
<span class="hljs-selector-class">.cmc-dialog</span><span class="hljs-selector-class">.el-dialog</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
}

</code></pre>
<p>当特异性相同时，<strong>后加载的样式会覆盖先加载的样式</strong>。</p>
<h3 data-id="heading-13">3.2 样式加载顺序问题</h3>
<p>在 SPA 应用中，组件样式是按需加载的：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 用户访问首页 → 加载首页组件样式
<span class="hljs-bullet">2.</span> 用户访问船期页面 → 加载 Subscribe.vue 样式（包含全局污染）
<span class="hljs-bullet">3.</span> 用户访问 VGM 页面 → CmcDialog 样式被污染样式覆盖
</code></pre>
<h3 data-id="heading-14">3.3 Teleport/Portal 的影响</h3>
<p>Element Plus Dialog 使用 Vue 3 的 Teleport 特性：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;Teleport to="body"&gt;
  &lt;div class="el-overlay"&gt;
    &lt;div class="el-dialog"&gt;...&lt;/div&gt;
  &lt;/div&gt;
&lt;/Teleport&gt;
</code></pre>
<p>这导致：</p>
<ol>
<li>Dialog DOM 脱离了组件的 DOM 树</li>
<li>Scoped 样式的 <code>data-v-xxxxx</code> 属性无法正确应用</li>
<li>必须使用 <code>:global()</code> 或 <code>:deep()</code> 才能样式化 dialog</li>
</ol>
<hr/>
<h2 data-id="heading-15">四、修复方案</h2>
<h3 data-id="heading-16">4.1 修复污染源（治本）</h3>
<p><strong>修改前（错误写法）：</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;el-dialog modal-class="subscriber-dialog"&gt;
  ...
&lt;/el-dialog&gt;

&lt;style scoped lang="scss"&gt;
.subscriber-dialog {
  :global(.el-dialog) {
    padding: 52px 50px;
  }
}
&lt;/style&gt;
</code></pre>
<p><strong>修改后（正确写法）：</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;el-dialog class="subscriber-dialog-box" modal-class="subscriber-dialog"&gt;
  ...
&lt;/el-dialog&gt;

&lt;style scoped lang="scss"&gt;
// 使用 class 属性直接应用到 el-dialog 上
// 组合选择器确保只影响特定的 dialog
:global(.subscriber-dialog-box) {
  padding: 52px 50px;

  .el-dialog__header {
    display: none;
  }
}
&lt;/style&gt;
</code></pre>
<p><strong>关键改动：</strong></p>
<ol>
<li>使用 <code>class</code> 而非仅依赖 <code>modal-class</code></li>
<li>使用<strong>组合选择器</strong> <code>.subscriber-dialog-box</code> 确保唯一性</li>
<li>样式只作用于带有该特定类名的 dialog</li>
</ol>
<h3 data-id="heading-17">4.2 加固组件库（治标 + 防御）</h3>
<p>在 <code>CmcDialog</code> 组件中添加高优先级样式重置：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-class">.cmc-dialog</span> {
  &amp;<span class="hljs-selector-class">.el-dialog</span> {
    <span class="hljs-comment">// 使用 !important 确保不被外部样式覆盖</span>
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
  }

  <span class="hljs-selector-class">.el-dialog__header</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
  }

  <span class="hljs-selector-class">.el-dialog__body</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
  }

  <span class="hljs-selector-class">.el-dialog__footer</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;
  }
}

</code></pre>
<hr/>
<h2 data-id="heading-18">五、同类问题预防指南</h2>
<h3 data-id="heading-19">5.1 ❌ 错误写法示例</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 错误1：直接使用 :global 修改 Element Plus 组件</span>
:<span class="hljs-built_in">global</span>(.el-dialog) { ... }
:<span class="hljs-built_in">global</span>(.el-table) { ... }
:<span class="hljs-built_in">global</span>(.el-form) { ... }

<span class="hljs-comment">// 错误2：在 scoped 样式中使用过于宽泛的选择器</span>
<span class="hljs-selector-class">.my-page</span> {
  :<span class="hljs-built_in">global</span>(.el-button) {
    <span class="hljs-attribute">background</span>: red;
  }
}

<span class="hljs-comment">// 错误3：在全局样式文件中直接修改组件样式</span>
<span class="hljs-comment">// src/assets/styles/index.scss</span>
<span class="hljs-selector-class">.el-dialog</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
}
</code></pre>
<h3 data-id="heading-20">5.2 ✅ 正确写法示例</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 正确1：使用组合选择器，确保唯一性</span>
:<span class="hljs-built_in">global</span>(.my-specific-dialog.el-dialog) {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
}

<span class="hljs-comment">// 正确2：使用 BEM 命名 + 组合选择器</span>
:<span class="hljs-built_in">global</span>(.page-name__dialog.el-dialog) {
  <span class="hljs-comment">// 样式</span>
}

<span class="hljs-comment">// 正确3：在组件上使用 class 属性</span>
&lt;el-dialog class="my-unique-dialog"&gt;

<span class="hljs-comment">// 正确4：使用 CSS 变量进行定制</span>
<span class="hljs-selector-class">.my-dialog</span> {
  <span class="hljs-attr">--el-dialog-padding-primary</span>: <span class="hljs-number">52px</span> <span class="hljs-number">50px</span>;
}

</code></pre>
<h3 data-id="heading-21">5.3 代码审查检查清单</h3>
<p>在 Code Review 时，检查以下内容：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否使用了 <code>:global(.el-xxx)</code> 直接修改 Element Plus 组件？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 全局样式文件中是否有直接修改组件库样式的代码？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 使用 <code>:global()</code> 时是否添加了足够特异性的父选择器？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> Dialog/Drawer 等 Teleport 组件是否使用了 <code>class</code> 属性？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 样式是否可能影响其他页面的同类组件？</li>
</ul>
<h3 data-id="heading-22">5.4 ESLint/Stylelint 规则建议</h3>
<p>可以配置 Stylelint 规则来检测潜在的全局污染：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// stylelint.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-comment">// 禁止直接使用 Element Plus 类名作为选择器</span>
    <span class="hljs-string">'selector-disallowed-list'</span>: [
      <span class="hljs-string">'/^\\.el-(?!.*\\.)/'</span>, <span class="hljs-comment">// 匹配单独的 .el-xxx 选择器</span>
      {
        <span class="hljs-attr">message</span>: <span class="hljs-string">'请使用组合选择器避免全局污染，如 .my-class.el-dialog'</span>
      }
    ]
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-23">六、总结</h2>
<h3 data-id="heading-24">6.1 问题本质</h3>
<p>这是一个典型的 <strong>CSS 作用域泄漏</strong> 问题，由以下因素共同导致：</p>
<ol>
<li><strong>Teleport 机制</strong> - Dialog DOM 脱离组件树</li>
<li><strong>:global() 滥用</strong> - 跳过 scoped 限制</li>
<li><strong>选择器特异性不足</strong> - 没有使用组合选择器</li>
<li><strong>样式加载顺序</strong> - 后加载的样式覆盖先加载的</li>
</ol>
<h3 data-id="heading-25">6.2 核心教训</h3>
<ol>
<li><strong>永远不要直接 <code>:global(.el-xxx)</code></strong> - 必须添加特定的父选择器或组合选择器</li>
<li><strong>组件库封装要有防御性</strong> - 使用 <code>!important</code> 重置关键样式</li>
<li><strong>使用 <code>class</code> 而非仅 <code>modal-class</code></strong> - 确保样式能正确应用</li>
<li><strong>命名要有唯一性</strong> - 使用 BEM 或页面前缀避免冲突</li>
</ol>
<h3 data-id="heading-26">6.3 推荐的 Dialog 样式定制模式</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;el-dialog
    class="feature-name__dialog"
    modal-class="feature-name__overlay"
  &gt;
    ...
  &lt;/el-dialog&gt;
&lt;/template&gt;

&lt;style scoped lang="scss"&gt;
// 使用组合选择器，确保只影响当前组件的 dialog
:global(.feature-name__dialog.el-dialog) {
  // 自定义样式
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-27">七、相关资源</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2Fapi%2Fsfc-css-features.html%23scoped-css" target="_blank" title="https://vuejs.org/api/sfc-css-features.html#scoped-css" ref="nofollow noopener noreferrer">Vue Scoped CSS 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FSpecificity" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" ref="nofollow noopener noreferrer">CSS Specificity MDN</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Felement-plus.org%2Fzh-CN%2Fcomponent%2Fdialog.html" target="_blank" title="https://element-plus.org/zh-CN/component/dialog.html" ref="nofollow noopener noreferrer">Element Plus Dialog 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fbuilt-ins%2Fteleport.html" target="_blank" title="https://vuejs.org/guide/built-ins/teleport.html" ref="nofollow noopener noreferrer">Vue Teleport 文档</a></li>
</ul>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 调用 Coze 工作流：从上传宠物照到生成冰球明星的完整技术解析]]></title>    <link>https://juejin.cn/post/7587263750250086451</link>    <guid>https://juejin.cn/post/7587263750250086451</guid>    <pubDate>2025-12-25T03:00:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587263750250086451" data-draft-id="7587238733503545387" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 调用 Coze 工作流：从上传宠物照到生成冰球明星的完整技术解析"/> <meta itemprop="keywords" content="前端,Vue.js,Coze"/> <meta itemprop="datePublished" content="2025-12-25T03:00:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 调用 Coze 工作流：从上传宠物照到生成冰球明星的完整技术解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:00:11.000Z" title="Thu Dec 25 2025 03:00:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"> 引言</h2>
<blockquote>
<p><strong>“你家的猫，也能打冰球？”</strong><br/>
不是玩笑——这是一次前端与 AI 工作流的完美邂逅。</p>
</blockquote>
<p>在当今 AI 应用爆发的时代，开发者不再满足于调用单一模型 API，而是通过 <strong>工作流（Workflow）</strong> 编排多个能力节点，实现复杂业务逻辑。而前端作为用户交互的第一线，如何优雅地集成这些 AI 能力，成为现代 Web 开发的重要课题。</p>
<p>本文将带你深入剖析一个真实项目：<strong>使用 Vue3 前端调用 Coze 平台的工作流 API，上传一张宠物照片，生成穿着定制队服、手持冰球杆的运动员形象图</strong>。我们将逐行解读 <code>App.vue</code> 源码，解释每一个 API 调用、每一段逻辑设计，并结合完整的 Coze 工作流图解，还原整个数据流转过程。文章内容严格引用原始代码（一字不变），确保技术细节 100% 准确。</p>
<hr/>
<h2 data-id="heading-1">一、项目背景与目标</h2>
<blockquote>
<p>AI 应用之冰球前端应用 vue3：冰球协会，上传宠物照片，生成运动员的形象照片。</p>
</blockquote>
<p>这个应用的核心功能非常明确：</p>
<ul>
<li>用户上传一张宠物（或人物）照片；</li>
<li>选择冰球队服编号、颜色、场上位置、持杆手、艺术风格等参数；</li>
<li>点击“生成”，系统调用 AI 工作流；</li>
<li>返回一张合成后的“冰球运动员”图像。</li>
</ul>
<p>而这一切的实现，完全依赖于 <strong>Coze 平台提供的工作流 API</strong>。前端负责收集输入、上传文件、发起请求、展示结果——典型的“轻前端 + 重 AI 后端”架构。</p>
<hr/>
<h2 data-id="heading-2">二、App.vue 整体结构概览</h2>
<p><code>App.vue</code> 是一个标准的 Vue3 单文件组件（SFC），采用 <code>&lt;script setup&gt;</code> 语法糖，结合 Composition API 实现响应式逻辑。整体分为三部分：</p>
<ol>
<li><strong><code>&lt;template&gt;</code></strong> ：用户界面（UI）</li>
<li><strong><code>&lt;script setup&gt;</code></strong> ：业务逻辑（JS）</li>
<li><strong><code>&lt;style scoped&gt;</code></strong> ：样式（CSS）</li>
</ol>
<p>我们先从模板入手，理解用户看到什么、能做什么。</p>
<hr/>
<h2 data-id="heading-3">三、模板（Template）详解：用户交互层</h2>
<h3 data-id="heading-4">3.1 文件上传与预览</h3>
<pre><code class="hljs language-ini" lang="ini">&lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"file-input"</span>&gt;
  &lt;input 
    <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> 
    <span class="hljs-attr">ref</span>=<span class="hljs-string">"uploadImage"</span> 
    <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> 
    @<span class="hljs-attr">change</span>=<span class="hljs-string">"updateImageData"</span> required /&gt;
&lt;/div&gt;
&lt;img :<span class="hljs-attr">src</span>=<span class="hljs-string">"imgPreview"</span> alt=<span class="hljs-string">""</span> v-if=<span class="hljs-string">"imgPreview"</span>/&gt;
</code></pre>
<ul>
<li><code>&lt;input type="file"&gt;</code>：原生文件选择器，限制只接受图片（<code>accept="image/*"</code>）。</li>
<li><code>ref="uploadImage"</code>：通过 <code>ref</code> 获取该 DOM 元素，便于 JS 中读取文件。</li>
<li><code>@change="updateImageData"</code>：当用户选择文件后，立即触发 <code>updateImageData</code> 方法，生成本地预览。</li>
<li><code>imgPreview</code> 是一个响应式变量，用于显示 Data URL 格式的预览图，无需上传即可看到效果。</li>
</ul>
<blockquote>
<p>✅ <strong>用户体验亮点</strong>：即使图片很大、上传很慢，用户也能立刻确认自己选对了图。</p>
</blockquote>
<h3 data-id="heading-5">3.2 表单参数设置</h3>
<p>接下来是两组设置项，全部使用 <code>v-model</code> 双向绑定：</p>
<h4 data-id="heading-6">第一组：队服信息</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"settings"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selection"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>队服编号:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"uniform_number"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selection"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>队服颜色:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"uniform_color"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"红"</span>&gt;</span>红<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"蓝"</span>&gt;</span>蓝<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"绿"</span>&gt;</span>绿<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"白"</span>&gt;</span>白<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"黑"</span>&gt;</span>黑<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<ul>
<li><code>uniform_number</code>：默认值为 <code>10</code>（见 script 部分），支持任意数字。</li>
<li><code>uniform_color</code>：限定五种颜色，值为中文字符串（如 <code>"红"</code>）。</li>
</ul>
<h4 data-id="heading-7">第二组：角色与风格</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"settings"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selection"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>位置：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"position"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span>&gt;</span>守门员<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>前锋<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>&gt;</span>后卫<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selection"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>持杆：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"shooting_hand"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span>&gt;</span>左手<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>右手<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selection"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>风格：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"style"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"写实"</span>&gt;</span>写实<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"乐高"</span>&gt;</span>乐高<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"国漫"</span>&gt;</span>国漫<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"日漫"</span>&gt;</span>日漫<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"油画"</span>&gt;</span>油画<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"涂鸦"</span>&gt;</span>涂鸦<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"素描"</span>&gt;</span>素描<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<ul>
<li><code>position</code> 和 <code>shooting_hand</code> 的值虽然是数字字符串（<code>"0"</code>/<code>"1"</code>/<code>"2"</code>），但前端显示为中文，兼顾可读性与后端兼容性。</li>
<li><code>style</code> 提供 7 种艺术风格，极大增强趣味性和分享欲。</li>
</ul>
<h3 data-id="heading-8">3.3 生成按钮与输出区域</h3>
<pre><code class="hljs language-ini" lang="ini">&lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"generate"</span>&gt;
  &lt;button @<span class="hljs-attr">click</span>=<span class="hljs-string">"generate"</span>&gt;生成&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>点击后触发 <code>generate()</code> 函数，启动整个 AI 生成流程。</p>
<p>输出区域：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"output"</span>&gt;
  &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"generated"</span>&gt;
    &lt;img :<span class="hljs-attr">src</span>=<span class="hljs-string">"imgUrl"</span> alt=<span class="hljs-string">""</span> v-if=<span class="hljs-string">"imgUrl"</span>/&gt;
    &lt;div <span class="hljs-attr">v-if</span>=<span class="hljs-string">"status"</span>&gt;{{ status }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li><code>imgUrl</code>：存储 Coze 返回的生成图 URL。</li>
<li><code>status</code>：动态显示当前状态（如“上传中…”、“生成失败”等），避免用户焦虑。</li>
</ul>
<blockquote>
<p>💡 <strong>设计哲学</strong>：状态反馈是良好 UX 的核心。没有反馈的“生成”按钮，等于黑盒。</p>
</blockquote>
<hr/>
<h2 data-id="heading-9">四、脚本逻辑（Script Setup）深度解析</h2>
<p>现在进入最核心的部分——JavaScript 逻辑。</p>
<h3 data-id="heading-10">4.1 环境配置与常量定义</h3>
<pre><code class="hljs language-ini" lang="ini">import { ref, onMounted } from 'vue'

const <span class="hljs-attr">patToken</span> = import.meta.env.VITE_PAT_TOKEN<span class="hljs-comment">;</span>
const <span class="hljs-attr">uploadUrl</span> = <span class="hljs-string">'https://api.coze.cn/v1/files/upload'</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">workflowUrl</span> = <span class="hljs-string">'https://api.coze.cn/v1/workflow/run'</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">workflow_id</span> = <span class="hljs-string">'7584046136391630898'</span><span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>
<p><code>import.meta.env.VITE_PAT_TOKEN</code>：Vite 提供的环境变量注入机制。<code>.env</code> 文件中应包含：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_PAT_TOKEN</span>=cztei_lvNwngHgch9rxNlx4KiXuky3UjfW9iqCZRe17KDXjh22RLL8sPLsb8Vl10R3IHJsW
</code></pre>
</li>
<li>
<p><code>uploadUrl</code>：Coze 官方文件上传接口（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.coze.com%2Freference%2Fupload_file" title="https://docs.coze.com/reference/upload_file" target="_blank" ref="nofollow noopener noreferrer">文档</a>）。</p>
</li>
<li>
<p><code>workflowUrl</code>：触发工作流的入口（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.coze.com%2Freference%2Frun_workflow" title="https://docs.coze.com/reference/run_workflow" target="_blank" ref="nofollow noopener noreferrer">文档</a>）。</p>
</li>
<li>
<p><code>workflow_id</code>：在 Coze 控制台创建的工作流唯一 ID，内部已配置好图像生成逻辑（如调用文生图模型、叠加队服等）。</p>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>安全警告</strong>：将 PAT Token 放在前端仅适用于演示或内部工具。生产环境应通过后端代理 API，避免 Token 泄露。</p>
</blockquote>
<h3 data-id="heading-11">4.2 响应式状态声明</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">uniform_number</span> = ref(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">uniform_color</span> = ref(<span class="hljs-string">'红'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">position</span> = ref(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">shooting_hand</span> = ref(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">style</span> = ref(<span class="hljs-string">'写实'</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">status</span> = ref(<span class="hljs-string">''</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">imageUrl</span> = ref(<span class="hljs-string">''</span>)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>所有表单字段均为 <code>ref</code> 响应式对象，确保视图自动更新。</li>
<li><code>status</code> 初始为空，后续将显示：“图片上传中...” → “图片上传成功, 正在生成...” → 成功清空 或 错误信息。</li>
<li><code>imageUrl</code> 初始为空，生成成功后赋值为图片 URL。</li>
</ul>
<h3 data-id="heading-12">4.3 核心函数 1：图片预览（updateImageData）</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">uploadImage</span> = ref(null)<span class="hljs-comment">;</span>
const <span class="hljs-attr">imgPreview</span> = ref(<span class="hljs-string">''</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">updateImageData</span> = () =&gt; {
  const <span class="hljs-attr">input</span> = uploadImage.value<span class="hljs-comment">;</span>
  if (!input.files || <span class="hljs-attr">input.files.length</span> === <span class="hljs-number">0</span>) {
    return<span class="hljs-comment">;</span>
  }
  const <span class="hljs-attr">file</span> = input.files[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
  const <span class="hljs-attr">reader</span> = new FileReader()<span class="hljs-comment">;</span>
  reader.readAsDataURL(file)<span class="hljs-comment">;</span>
  <span class="hljs-attr">reader.onload</span> = (e) =&gt; {
    <span class="hljs-attr">imgPreview.value</span> = e.target.result<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>
}
</code></pre>
<ul>
<li><code>uploadImage</code> 是对 <code>&lt;input&gt;</code> 元素的引用。</li>
<li>使用 <code>FileReader</code> 的 <code>readAsDataURL</code> 方法，将文件转为 Base64 编码的 Data URL。</li>
<li><code>onload</code> 回调中，将结果赋给 <code>imgPreview</code>，触发 <code>&lt;img&gt;</code> 标签渲染。</li>
</ul>
<blockquote>
<p>✅ <strong>优势</strong>：纯前端实现，零网络请求，秒级响应。</p>
</blockquote>
<h3 data-id="heading-13">4.4 核心函数 2：文件上传（uploadFile）</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">uploadFile</span> = async () =&gt; {
  const <span class="hljs-attr">formData</span> = new FormData()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">input</span> = uploadImage.value<span class="hljs-comment">;</span>
  if (!input.files || input.files.length &lt;= 0) return<span class="hljs-comment">;</span>
  formData.append('file', input.files<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">res</span> = await fetch(uploadUrl, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${patToken}`
    },
    body: formData
  })<span class="hljs-comment">;</span>

  const <span class="hljs-attr">ret</span> = await res.json()<span class="hljs-comment">;</span>
  console.log(ret)<span class="hljs-comment">;</span>
  if (ret.code !== 0) {
    <span class="hljs-attr">status.value</span> = ret.msg<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;</span>
  }
  return ret.data.id<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-14">逐行解析：</h4>
<ol>
<li>
<p><strong>构造 FormData</strong>：</p>
<ul>
<li><code>new FormData()</code> 是浏览器原生 API，用于构建 multipart/form-data 请求体，专为文件上传设计。</li>
<li><code>formData.append('file', file)</code>：Coze 要求字段名为 <code>file</code>。</li>
</ul>
</li>
<li>
<p><strong>发送 POST 请求</strong>：</p>
<ul>
<li>
<p>URL：<code>https://api.coze.cn/v1/files/upload</code></p>
</li>
<li>
<p>Headers：</p>
<ul>
<li><code>Authorization: Bearer &lt;token&gt;</code>：Coze 使用 Bearer Token 认证。</li>
</ul>
</li>
<li>
<p>Body：<code>formData</code> 自动设置正确 Content-Type（含 boundary）。</p>
</li>
</ul>
</li>
<li>
<p><strong>处理响应</strong>：</p>
<ul>
<li>
<p>成功时返回：</p>
<pre><code class="hljs language-css" lang="css">{ "<span class="hljs-selector-tag">code</span>": <span class="hljs-number">0</span>, <span class="hljs-string">"msg"</span>: <span class="hljs-string">"success"</span>, <span class="hljs-string">"data"</span>: { "id": <span class="hljs-string">"file_xxx"</span>, ... } }
</code></pre>
</li>
<li>
<p>失败时 <code>code !== 0</code>，<code>msg</code> 包含错误原因（如 Token 无效、文件过大等）。</p>
</li>
<li>
<p>函数返回 <code>file_id</code>（如 <code>"file_abc123"</code>），供下一步使用。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>关键点</strong>：Coze 的文件上传是独立步骤，必须先上传获取 <code>file_id</code>，才能在工作流中引用。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">五、核心函数 3：调用工作流（generate）</h2>
<p>这是整个应用的“大脑”。我们结合 Coze 工作流图，深入分析其逻辑与数据流。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">generate</span> = async () =&gt; {
  <span class="hljs-attr">status.value</span> = <span class="hljs-string">"图片上传中..."</span><span class="hljs-comment">;</span>
  const <span class="hljs-attr">file_id</span> = await uploadFile()<span class="hljs-comment">;</span>
  if (!file_id) return<span class="hljs-comment">;</span>

  <span class="hljs-attr">status.value</span> = <span class="hljs-string">"图片上传成功, 正在生成..."</span><span class="hljs-comment">;</span>

  const <span class="hljs-attr">parameters</span> = {
    picture: JSON.stringify({ file_id }),
    style: style.value,
    uniform_color: uniform_color.value,
    uniform_number: uniform_number.value,
    position: position.value,
    shooting_hand: shooting_hand.value,
  }<span class="hljs-comment">;</span>

  try {
    const <span class="hljs-attr">res</span> = await fetch(workflowUrl, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${patToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ workflow_id, parameters })
    })<span class="hljs-comment">;</span>

    const <span class="hljs-attr">ret</span> = await res.json()<span class="hljs-comment">;</span>
    console.log("Workflow API response:", ret)<span class="hljs-comment">;</span>
    if (ret.code !== 0) {
      <span class="hljs-attr">status.value</span> = ret.msg<span class="hljs-comment">;</span>
      return<span class="hljs-comment">;</span>
    }

    // 检查返回数据结构
    console.log("Return data:", ret.data)<span class="hljs-comment">;</span>
    console.log("Return data type:", typeof ret.data)<span class="hljs-comment">;</span>

    // 尝试解析数据
    let data<span class="hljs-comment">;</span>
    if (typeof <span class="hljs-attr">ret.data</span> === <span class="hljs-string">'string'</span>) {
      try {
        <span class="hljs-attr">data</span> = JSON.parse(ret.data)<span class="hljs-comment">;</span>
        console.log("Parsed data:", data)<span class="hljs-comment">;</span>
      } catch (e) {
        console.error("JSON parse error:", e)<span class="hljs-comment">;</span>
        <span class="hljs-attr">status.value</span> = <span class="hljs-string">"数据解析错误"</span><span class="hljs-comment">;</span>
        return<span class="hljs-comment">;</span>
      }
    } else {
      <span class="hljs-attr">data</span> = ret.data<span class="hljs-comment">;</span>
    }

    // 检查data.data是否存在
    if (data &amp;&amp; data.data) {
      console.log("Generated image URL:", data.data)<span class="hljs-comment">;</span>
      <span class="hljs-attr">status.value</span> = <span class="hljs-string">''</span><span class="hljs-comment">;</span>
      <span class="hljs-attr">imageUrl.value</span> = data.data<span class="hljs-comment">;</span>
    } else {
      console.error("Invalid data structure, missing 'data' field:", data)<span class="hljs-comment">;</span>
      <span class="hljs-attr">status.value</span> = <span class="hljs-string">"返回数据结构错误"</span><span class="hljs-comment">;</span>
    }
  } catch (error) {
    console.error("Generate error:", error)<span class="hljs-comment">;</span>
    <span class="hljs-attr">status.value</span> = <span class="hljs-string">"生成失败，请检查网络连接"</span><span class="hljs-comment">;</span>
  }
}
</code></pre>
<h3 data-id="heading-16">逻辑拆解（结合 Coze 工作流图）</h3>
<h4 data-id="heading-17">Coze 工作流结构（图解说明）</h4>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df867d224be54ad6abb69d515547f3d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236411&amp;x-signature=w82B316O2BMsmkUpKIegCC%2BsVOY%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p><strong>图注</strong>：</p>
<ol>
<li><strong>开始节点</strong>：接收 <code>picture</code>, <code>style</code>, <code>uniform_number</code>, <code>position</code>, <code>shooting_hand</code>, <code>uniform_color</code> 等参数。</li>
<li><strong>分支一</strong>：<code>imgUnderstand_1</code>（图像理解）→ 分析上传图片内容（如动物种类、姿态）。</li>
<li><strong>分支二</strong>：<code>代码</code> 节点 → 根据 <code>position</code>, <code>shooting_hand</code>, <code>style</code> 等生成描述文本（如“一只狗，右手持杆，身穿红色10号队服，站在冰球场上”）。</li>
<li><strong>大模型节点</strong>：将图像理解结果与描述文本合并，生成最终提示词（prompt）。</li>
<li><strong>图像生成节点</strong>：调用文生图模型（如豆包·1.5·Pro·32k），生成新图像。</li>
<li><strong>结束节点</strong>：输出生成图的 URL。</li>
</ol>
</blockquote>
<hr/>
<h4 data-id="heading-18">前端代码的对应关系</h4>








































<table><thead><tr><th>前端参数</th><th>Coze 输入字段</th><th>用途</th></tr></thead><tbody><tr><td><code>picture</code></td><td><code>picture</code></td><td>图片文件 ID，传入 <code>imgUnderstand_1</code> 和 <code>图像生成</code> 节点</td></tr><tr><td><code>style</code></td><td><code>style</code></td><td>传递给 <code>代码</code> 节点，决定艺术风格</td></tr><tr><td><code>uniform_number</code></td><td><code>uniform_number</code></td><td>用于生成描述</td></tr><tr><td><code>position</code></td><td><code>position</code></td><td>决定角色动作（如守门员蹲姿）</td></tr><tr><td><code>shooting_hand</code></td><td><code>shooting_hand</code></td><td>决定持杆手</td></tr><tr><td><code>uniform_color</code></td><td><code>uniform_color</code></td><td>用于生成队服颜色</td></tr></tbody></table>
<blockquote>
<p>💡 <strong>关键点</strong>：前端只需提供原始参数，Coze 工作流内部完成所有逻辑编排。</p>
</blockquote>
<hr/>
<h3 data-id="heading-19">数据流全过程</h3>
<ol>
<li>
<p><strong>前端上传文件</strong> → 得到 <code>file_id</code></p>
</li>
<li>
<p><strong>前端组装参数</strong> → 发送至 <code>/workflow/run</code></p>
</li>
<li>
<p><strong>Coze 工作流执行</strong>：</p>
<ul>
<li><code>imgUnderstand_1</code>：分析图片内容 → 输出 <code>text</code>, <code>url</code>, <code>content</code></li>
<li><code>代码</code> 节点：根据参数生成描述 → 如 <code>"一只猫，身穿蓝色10号队服，右手持杆，站在冰球场上，风格为乐高"</code></li>
<li><code>大模型</code> 节点：合并图像理解结果与描述 → 生成最终 prompt</li>
<li><code>图像生成</code> 节点：调用模型生成图像 → 返回 <code>data</code> 字段（URL）</li>
</ul>
</li>
<li>
<p><strong>前端接收响应</strong>：</p>
<ul>
<li>若 <code>ret.data</code> 是字符串 → 尝试 <code>JSON.parse</code></li>
<li>若是对象 → 直接取 <code>data.data</code></li>
<li>最终赋值给 <code>imageUrl</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ <strong>为什么需要双重解析？</strong><br/>
因为 Coze 的“图像生成”节点可能直接返回 URL 字符串，也可能返回 <code>{ data: "url" }</code> 结构。前端必须兼容两种情况。</p>
</blockquote>
<hr/>
<h2 data-id="heading-20">六、样式（Style）简析</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: row;
  <span class="hljs-attribute">align-items</span>: start;
  <span class="hljs-attribute">justify-content</span>: start;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">font-size</span>: .<span class="hljs-number">85rem</span>;
}
<span class="hljs-selector-class">.generated</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> black;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
}
<span class="hljs-selector-class">.output</span> <span class="hljs-selector-tag">img</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<ul>
<li>使用 Flex 布局，左右分栏（输入区固定宽度，输出区自适应）。</li>
<li><code>.generated</code> 容器固定 400x400，图片居中显示，无论原始比例如何都不变形。</li>
<li><code>scoped</code> 确保样式仅作用于当前组件，避免污染全局。</li>
</ul>
<hr/>
<h2 data-id="heading-21">七、项目运行</h2>
<p>在项目终端运行命令 ：npm run dev</p>
<p>运行界面如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c0b4ffcc9074875ac79d19c6dd039b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236411&amp;x-signature=0TGAd4aYtt0gXusNweelNBbN%2BUM%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>选择图片及风格等内容后，点击开始生成，运行结果如图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae9a4d82c5964599b8b4c648a2a02684~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236411&amp;x-signature=kyiJS9z4Mjupkb9D9Ov3fs%2BNkj8%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-22">总结：为什么这个项目值得学习？</h2>
<ol>
<li>
<p><strong>真实场景</strong>：不是 Hello World，而是完整产品逻辑。</p>
</li>
<li>
<p><strong>技术全面</strong>：</p>
<ul>
<li>Vue3 Composition API</li>
<li>文件上传与预览</li>
<li>Fetch API 与错误处理</li>
<li>环境变量管理</li>
<li>响应式状态驱动 UI</li>
</ul>
</li>
<li>
<p><strong>AI 集成范式</strong>：展示了如何将复杂 AI 能力封装为简单 API，前端只需“填参数 + 拿结果”。</p>
</li>
<li>
<p><strong>用户体验优先</strong>：状态提示、本地预览、错误反馈一应俱全。</p>
</li>
</ol>
<p><strong>安全与部署建议</strong>：</p>
<ul>
<li>
<p><strong>后端代理所有 Coze API 调用</strong>：</p>
<ul>
<li>前端 → 自己的后端（/api/generate）</li>
<li>后端 → Coze（携带安全存储的 Token）</li>
</ul>
</li>
<li>
<p><strong>限制工作流权限</strong>：Coze 的 PAT Token 应仅授予必要权限。</p>
</li>
<li>
<p><strong>添加速率限制</strong>：防止滥用。</p>
</li>
</ul>
<blockquote>
<p>最终，技术的意义在于创造快乐。<br/>
当你上传一张狗子的照片，看到它穿上红色10号球衣、右手持杆、以“乐高”风格站在冰场上——<br/>
你会笑，会分享，会说：“AI 真酷！”</p>
</blockquote>
<p>而这，正是我们写代码的初心。</p>
<p>完整项目源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2FgiaoZou%2Flesson_zp%2Ftree%2Fmaster%2Fai%2Fapp%2Ficeball" title="https://gitee.com/giaoZou/lesson_zp/tree/master/ai/app/iceball" target="_blank" ref="nofollow noopener noreferrer">lesson_zp/ai/app/iceball: AI + 全栈学习仓库 - Gitee.com</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Linux pinctrl 子系统]]></title>    <link>https://juejin.cn/post/7587299670641737734</link>    <guid>https://juejin.cn/post/7587299670641737734</guid>    <pubDate>2025-12-24T16:53:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587299670641737734" data-draft-id="7587299443643924543" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Linux pinctrl 子系统"/> <meta itemprop="keywords" content="Linux"/> <meta itemprop="datePublished" content="2025-12-24T16:53:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lolo_fi"/> <meta itemprop="url" content="https://juejin.cn/user/414934077803401"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Linux pinctrl 子系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/414934077803401/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lolo_fi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T16:53:24.000Z" title="Wed Dec 24 2025 16:53:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Linux pinctrl 子系统</h2>
<h3 data-id="heading-1">一、Pinctrl的使用</h3>
<p>大多数 SOC 的 pin 都是支持复用的，例如某个SOC的GPIO3_D4 既可以作为普通的 GPIO 使用，也可以作为 PWM1_M0 引脚、GPU_AVS 引脚、UART0_RX 引脚。此外我们还需要配置 pin 的电气特性，比如上/下拉、驱动能力等等。传统的配置 pin 的方式就是直接操作相应的寄存器，但是这种配置方式比较繁琐、而且容易出问题(比如 pin 功能冲突)。pinctrl 子系统就是为了解决这个问题而引入的，pinctrl 子系统主要工作内容如下：</p>
<ul>
<li>获取设备树中 pin 信息。</li>
<li>根据获取到的 pin 信息来设置 pin 的复用功能</li>
<li>根据获取到的 pin 信息来设置 pin 的电气特性，如驱动能力。</li>
</ul>
<p>对于我们使用者来讲，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成，pinctrl 子系统源码目录为 drivers/pinctrl。</p>
<h4 data-id="heading-2">1.PIN 配置信息详解</h4>
<p>要使用 pinctrl 子系统，我们需要在设备树里面设置 PIN 的配置信息，毕竟 pinctrl 子系统要根据你提供的信息来配置 PIN 功能，一般会在设备树里面创建一个节点来描述 PIN 的配置信息。</p>
<pre><code class="hljs language-C" lang="C"><span class="hljs-comment">//imx6ull.dtsi</span>
iomuxc: iomuxc@<span class="hljs-number">020e0000</span> {
				compatible = <span class="hljs-string">"fsl,imx6ul-iomuxc"</span>;
				reg = &lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;;
			};
<span class="hljs-comment">//imx6ull-14x14-evk.dts</span>
&amp;iomuxc {
	pinctrl-names = <span class="hljs-string">"default"</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;; <span class="hljs-comment">//hog pin是系统默认的状态，在 pinctrl 初始化阶段立即生效</span>
	pinctrl_hog_1: hoggrp<span class="hljs-number">-1</span> {
		fsl,pins = &lt;
			MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 CD */</span>
			MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	<span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 VSELECT */</span>
			MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="hljs-number">0x17059</span> <span class="hljs-comment">/* SD1 RESET */</span>
		&gt;;
	};

	pinctrl_csi1: csi1grp {
		fsl,pins = &lt;
			MX6UL_PAD_CSI_MCLK__CSI_MCLK		<span class="hljs-number">0x1b088</span>
			MX6UL_PAD_CSI_PIXCLK__CSI_PIXCLK	<span class="hljs-number">0x1b088</span>
			...
		&gt;;
	};
    ...
}
</code></pre>
<ul>
<li><code>iomuxc</code> 是 IOMUX 控制器，负责 pin 的复用和 pad 控制</li>
<li><code>compatible</code> 决定使用哪个 pinctrl 驱动（<code>drivers/pinctrl/freescale/</code>）</li>
<li><code>reg</code> 指向 IOMUXC 寄存器基地址</li>
</ul>
<p>所有 pin 的复用和电气配置，最终都会通过该控制器完成。</p>
<p>这里要说明一下，PAD、Pin、GPIO是三个东西：</p>
<ul>
<li>
<p>PAD  				SoC 内部  			负责复用、电气特性、信号缓冲</p>
</li>
<li>
<p>Pin / Ball  		芯片封装  				焊球 / 引脚编号</p>
</li>
<li>
<p>GPIO  				逻辑功能  			数字输入输出控制器</p>
</li>
</ul>
<p><strong>PAD 是 pinctrl / IOMUX 直接操作的对象，多个内部信号共享同一个 PAD，通过复用选择其一。</strong></p>
<p>通常在 <code>&amp;iomuxc</code> 节点下定义多个 pinctrl 子节点，每个子节点描述一组功能相关的 pin，例如上面的<code>pinctrl_hog_1</code>、<code>pinctrl_csi1</code>。</p>
<pre><code class="hljs language-c" lang="c">pinctrl_xxx: xxxgrp {
	fsl,pins = &lt;
		PAD_MUX_CONFIG  PAD_CTRL_CONFIG
		...
	&gt;;
};

</code></pre>
<p><code>pinctrl_xxx</code>：label，用于被其他设备节点引用</p>
<p><code>xxxgrp</code>：节点名，无实际功能意义，仅用于区分</p>
<p><code>fsl,pins</code>：平台私有属性，描述具体 pin 配置</p>
<p><strong>fsl,pins 属性格式说明</strong></p>
<p>该属性由 若干组 <code>&lt;PAD MUX + PAD CTRL&gt;</code> 组成，每一组代表一个 pin 的配置。举例：</p>
<pre><code class="hljs language-C" lang="C">fsl,pins = &lt;
	MX6UL_PAD_UART1_RTS_B__GPIO1_IO19   <span class="hljs-number">0x17059</span>
&gt;;

</code></pre>
<p><strong>PAD MUX</strong>：宏<code>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</code>包含三部分信息，<code>MX6UL_PAD_UART1_RTS_B</code>表示物理 PAD 名称，<code>__</code>表示分隔符，<code>GPIO1_IO19</code>表示复用后的功能，表示将 <code>UART1_RTS_B</code> 这个 PAD 复用为 <code>GPIO1_IO19</code> 功能。这些宏定义位于<code>arch/arm/boot/dts/imx6ull-pinfunc.h</code>。</p>
<p><strong>PAD CTRL</strong>：<code>0x17059</code>用于配置 pin 的电气特性，对应 <code>IOMUXC_PAD</code> 控制寄存器。常见控制项包括：上拉 / 下拉、驱动能力、速率、施密特触发、推挽开漏。</p>
<h4 data-id="heading-3">2.设备节点中引用 pinctrl</h4>
<p>pinctrl 配置并不会自动生效，必须被设备节点引用。</p>
<p><strong>基本引用方式</strong></p>
<pre><code class="hljs language-c" lang="c">uart1: serial@<span class="hljs-number">02020000</span> {
	compatible = <span class="hljs-string">"fsl,imx6ul-uart"</span>;
	reg = &lt;<span class="hljs-number">0x02020000</span> <span class="hljs-number">0x4000</span>&gt;;
	interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;

	pinctrl-names = <span class="hljs-string">"default"</span>;
	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_uart1&gt;; <span class="hljs-comment">//引用pinctrl_uart1</span>

	status = <span class="hljs-string">"okay"</span>;
};
<span class="hljs-comment">//对应的pinctrl定义</span>
pinctrl_uart1: uart1grp {
	fsl,pins = &lt;
		MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX  <span class="hljs-number">0x1b0b1</span>
		MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX  <span class="hljs-number">0x1b0b1</span>
	&gt;;
};
</code></pre>
<p><strong>多状态 pinctrl</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">pinctrl-names</span> = <span class="hljs-string">"default"</span>, <span class="hljs-string">"sleep"</span><span class="hljs-comment">;</span>
<span class="hljs-attr">pinctrl-0</span> = &lt;&amp;pinctrl_uart1_default&gt;<span class="hljs-comment">;</span>
<span class="hljs-attr">pinctrl-1</span> = &lt;&amp;pinctrl_uart1_sleep&gt;<span class="hljs-comment">;</span>
</code></pre>
<p>这里有两个状态：</p>
<p><code>default</code>：工作状态</p>
<p><code>sleep</code>：低功耗状态（关闭上下拉、降低驱动）</p>
<p>是否切换由驱动调用：<code>pinctrl_select_state();</code></p>
<h3 data-id="heading-4">二、内部原理</h3>
<p><strong>核心思路</strong> （方便回忆）
pinctrl 是 Linux 内核中负责管理引脚复用与引脚配置的子系统。<br/>
它通过Pin Controller 驱动和 设备驱动两层模型，实现了从设备树引脚定义到硬件寄存器配置的完整映射。</p>
<p>简单流程版：</p>
<ul>
<li>pinctrl 子系统的工作流程从 Pin Controller 驱动开始。首先，内核通过设备树中的 <strong>compatible</strong> 属性匹配到对应的 pinctrl 驱动，当匹配成功后，会调用该驱动的 <strong>probe</strong> 函数。在 probe 阶段，驱动会根据 SoC 的特性填充一个 <strong>pinctrl_desc</strong> 结构体，其中包含引脚描述信息（pins/npins）、操作函数（pctlops、pmxops、confops）等内容，并通过 <strong>devm_pinctrl_register()</strong> 将该 pin controller 注册到内核中，完成引脚控制器的初始化与功能注册。</li>
<li>当具体使用pinctrl的设备驱动在 probe 阶段加载时，内核会根据设备树中定义的引脚配置调用 <strong>pinctrl_bind_pins()</strong> 函数，为该设备建立引脚控制上下文。该函数首先为设备创建一个 <strong>dev_pin_info</strong> 结构体，用于保存设备的引脚控制信息。其中，函数会调用 <strong>devm_pinctrl_get()</strong> 创建一个新的 <strong>pinctrl</strong> 结构体，并将其赋值给 <code>dev_pin_info</code> 的 <code>p</code> 成员。</li>
<li>随后，内核通过 <strong>pinctrl_dt_to_map()</strong> 从设备树中读取该设备的引脚配置，并调用 pinctrl 驱动提供的 <strong>imx_dt_node_to_map()</strong> 等函数来解析 <code>pinctrl-0</code>、<code>pinctrl-1</code> 等节点。解析过程会生成一系列 <strong>pinctrl_map</strong> 结构体，每个 map 对应一组引脚功能或配置。这些 map 会被进一步转换为 <strong>pinctrl_setting</strong>，并挂入对应状态的 <strong>pinctrl_state.settings</strong> 链表中，同时所有 map 信息也会保存在 <code>pinctrl</code> 的 <code>dt_maps</code> 链表中。</li>
<li>在此基础上，内核根据不同的 pinctrl 节点（如 default、sleep 等）创建多个 <strong>pinctrl_state</strong>，每个状态对应设备树中定义的一个引脚状态。这些状态被添加到 <code>pinctrl</code> 的 <code>states</code> 链表中，而 <code>dev_pin_info</code> 结构中的 <code>default_state</code>、<code>sleep_state</code> 等指针则会被设置为指向这些状态结构。</li>
<li>当设备运行过程中需要切换引脚配置（例如进入睡眠或恢复默认状态）时，驱动可调用 <strong>pinctrl_select_state()</strong> 函数来切换到对应的状态。该函数会遍历当前状态下的所有 <strong>pinctrl_setting</strong>，并根据每个 setting 的类型（复用或配置）调用 pin controller 驱动提供的操作接口（ops），最终通过底层寄存器配置完成硬件引脚功能与电气属性的切换。</li>
</ul>
<p>这一整套机制实现了从设备树定义到硬件引脚配置的完整自动化映射流程。</p>
<hr/>
<h4 data-id="heading-5">1.Provider 端</h4>
<p><strong>Pin Controller 驱动注册流程</strong></p>
<h5 data-id="heading-6">(1)设备树匹配</h5>
<p>在设备树中定义一个 pin controller 节点：</p>
<pre><code class="hljs language-ini" lang="ini">iomuxc: iomuxc@020e0000 {
    <span class="hljs-attr">compatible</span> = <span class="hljs-string">"fsl,imx6ul-iomuxc"</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">reg</span> = &lt;<span class="hljs-number">0</span>x020e0000 <span class="hljs-number">0</span>x4000&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>对应驱动中的匹配表：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> imx6ul_pinctrl_of_match[] = {
    { .compatible = <span class="hljs-string">"fsl,imx6ul-iomuxc"</span>, .data = &amp;imx6ul_pinctrl_info },
    { <span class="hljs-comment">/* sentinel */</span> }
};
</code></pre>
<p>当 compatible 匹配成功后，调用：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">imx6ul_pinctrl_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">imx_pinctrl_probe</span>(pdev, pinctrl_info);
}
</code></pre>
<hr/>
<h5 data-id="heading-7">(2)probe 阶段</h5>
<p><strong>构造并注册 pinctrl_desc</strong></p>
<p>核心函数 <code>imx_pinctrl_probe()</code>：</p>
<pre><code class="hljs language-ini" lang="ini">int imx_pinctrl_probe(struct platform_device *pdev,
                      struct imx_pinctrl_soc_info *info)
{
    struct pinctrl_desc *desc<span class="hljs-comment">;</span>

    desc-&gt;<span class="hljs-attr">name</span> = dev_name(&amp;pdev-&gt;dev)<span class="hljs-comment">;</span>
    desc-&gt;<span class="hljs-attr">pins</span> = info-&gt;pins<span class="hljs-comment">;           // 引脚数组</span>
    desc-&gt;<span class="hljs-attr">npins</span> = info-&gt;npins<span class="hljs-comment">;         // 引脚数量</span>
    desc-&gt;<span class="hljs-attr">pctlops</span> = &amp;imx_pctrl_ops<span class="hljs-comment">;    // 分组操作</span>
    desc-&gt;<span class="hljs-attr">pmxops</span> = &amp;imx_pmx_ops<span class="hljs-comment">;       // 复用操作</span>
    desc-&gt;<span class="hljs-attr">confops</span> = &amp;imx_pinconf_ops<span class="hljs-comment">;  // 引脚配置操作</span>
    desc-&gt;<span class="hljs-attr">owner</span> = THIS_MODULE<span class="hljs-comment">;</span>

    // 注册 pin controller
    ipctl-&gt;<span class="hljs-attr">pctl</span> = devm_pinctrl_register(&amp;pdev-&gt;dev, desc, ipctl)<span class="hljs-comment">;</span>
}
</code></pre>
<p><code>devm_pinctrl_register()</code> 会在内核中注册一个 <code>pinctrl_dev</code> 实例：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_dev</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_desc</span> *desc;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *dev;
    <span class="hljs-type">void</span> *driver_data;
};
</code></pre>
<hr/>
<h5 data-id="heading-8">(3)三大操作函数</h5>
<p>pinctrl 框架通过以下三类 ops 完成抽象：</p>

























<table><thead><tr><th>操作集</th><th>功能</th><th>示例函数</th></tr></thead><tbody><tr><td><strong>pinctrl_ops</strong></td><td>引脚组管理与设备树解析</td><td><code>dt_node_to_map()</code></td></tr><tr><td><strong>pinmux_ops</strong></td><td>控制引脚复用</td><td><code>set_mux()</code></td></tr><tr><td><strong>pinconf_ops</strong></td><td>控制引脚电气属性</td><td><code>pin_config_set()</code></td></tr></tbody></table>
<p>示例：</p>
<pre><code class="hljs language-ini" lang="ini">static const struct pinctrl_ops <span class="hljs-attr">imx_pctrl_ops</span> = {
    .<span class="hljs-attr">get_groups_count</span> = imx_get_groups_count,
    .<span class="hljs-attr">get_group_name</span> = imx_get_group_name,
    .<span class="hljs-attr">dt_node_to_map</span> = imx_dt_node_to_map, // 关键：设备树转 pinctrl_map
}<span class="hljs-comment">;</span>
</code></pre>
<hr/>
<h3 data-id="heading-9">2.Consumer 端</h3>
<p><strong>设备驱动的引脚绑定与状态创建</strong></p>
<h5 data-id="heading-10">(1)设备树中定义引脚配置</h5>
<pre><code class="hljs language-ini" lang="ini">&amp;iomuxc {
    imx6ul-evk {
        pinctrl_i2c1: i2c1grp {
            fsl,<span class="hljs-attr">pins</span> = &lt;
                MX6UL_PAD_UART1_TX_DATA__I2C1_SCL 0x4001b8b0
                MX6UL_PAD_UART1_RX_DATA__I2C1_SDA 0x4001b8b0
            &gt;<span class="hljs-comment">;</span>
        }<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

i2c1: i2c@021a0000 {
    <span class="hljs-attr">compatible</span> = <span class="hljs-string">"fsl,imx6ul-i2c"</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">pinctrl-names</span> = <span class="hljs-string">"default"</span>, <span class="hljs-string">"sleep"</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">pinctrl-0</span> = &lt;&amp;pinctrl_i2c1&gt;<span class="hljs-comment">;</span>
    <span class="hljs-attr">pinctrl-1</span> = &lt;&amp;pinctrl_i2c1_sleep&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><code>pinctrl-names</code> 与 <code>pinctrl-0</code>, <code>pinctrl-1</code> 等属性定义了设备的多种引脚状态。</p>
<hr/>
<h5 data-id="heading-11">(2)pinctrl_bind_pins()</h5>
<p><strong>设备 probe 时的引脚绑定入口：<code>pinctrl_bind_pins()</code></strong></p>
<p>当设备驱动被加载时，<code>really_probe()</code> 调用：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">pinctrl_bind_pins</span>(dev);
</code></pre>
<p>该函数负责为设备创建引脚控制信息，是 Consumer 端的核心入口。</p>
<hr/>
<h5 data-id="heading-12">(3)<code>pinctrl_bind_pins</code></h5>
<p><strong><code>pinctrl_bind_pins</code> 内部关键步骤</strong></p>
<p><strong>step1.创建 <code>dev_pin_info</code> 结构</strong></p>
<pre><code class="hljs language-ini" lang="ini">dev-&gt;<span class="hljs-attr">pins</span> = devm_kzalloc(dev, sizeof(*(dev-&gt;pins)), GFP_KERNEL)<span class="hljs-comment">;</span>
</code></pre>
<p><code>struct dev_pin_info</code> 用于描述设备与 pinctrl 子系统的绑定关系：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dev_pin_info</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl</span> *p;                    <span class="hljs-comment">// 指向该设备的 pinctrl 句柄</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_state</span> *default_state;  <span class="hljs-comment">// 默认状态</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_state</span> *init_state;     <span class="hljs-comment">// 初始化状态</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_state</span> *sleep_state;    <span class="hljs-comment">// 睡眠状态</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_state</span> *idle_state;     <span class="hljs-comment">// 空闲状态</span>
};
</code></pre>
<p><code>dev_pin_info</code> 是设备和 pinctrl 框架之间的“桥梁”：</p>
<ul>
<li><code>p</code>：指向设备对应的 <code>struct pinctrl</code></li>
<li>其他成员指向不同命名状态的 <code>pinctrl_state</code></li>
</ul>
<hr/>
<p><strong>step2.创建 <code>pinctrl</code> 结构</strong></p>
<pre><code class="hljs language-ini" lang="ini">dev-&gt;pins-&gt;<span class="hljs-attr">p</span> = devm_pinctrl_get(dev)<span class="hljs-comment">;</span>
</code></pre>
<p><code>devm_pinctrl_get()</code> 内部执行：</p>
<ol>
<li>创建 <code>struct pinctrl</code>；</li>
<li>调用 <code>pinctrl_dt_to_map()</code> 解析设备树；</li>
<li>将解析结果保存到 <code>pinctrl-&gt;dt_maps</code>；</li>
<li>为每个状态创建 <code>pinctrl_state</code> 并加入 <code>pinctrl-&gt;states</code> 链表。</li>
</ol>
<hr/>
<p><strong>step3.设备树解析 → <code>pinctrl_map</code> 构建</strong></p>
<p><code>pinctrl_dt_to_map()</code> 通过 pinctrl 驱动提供的 <code>dt_node_to_map()</code> 来解析：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">imx_dt_node_to_map</span>(np_config, &amp;map, &amp;num_maps);
</code></pre>
<p>每个节点（如 <code>pinctrl-0</code>）会生成若干个 <code>pinctrl_map</code>：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pinctrl_map</span> {
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">pinctrl_map_type</span> type;
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">struct</span> { <span class="hljs-type">const</span> <span class="hljs-type">char</span> *group; <span class="hljs-type">const</span> <span class="hljs-type">char</span> *function; } mux;
        <span class="hljs-keyword">struct</span> { <span class="hljs-type">const</span> <span class="hljs-type">char</span> *group_or_pin; <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *configs; <span class="hljs-type">unsigned</span> num_configs; } configs;
    } data;
};
</code></pre>
<p>这些 <code>pinctrl_map</code> 描述了设备、组、功能与配置之间的对应关系，并被挂入：</p>
<pre><code class="hljs language-rust" lang="rust">pinctrl<span class="hljs-punctuation">-&gt;</span>dt_maps
</code></pre>
<hr/>
<p><strong>step4.<code>pinctrl_map</code> → <code>pinctrl_setting</code> → <code>pinctrl_state</code></strong></p>
<p>每个 <code>pinctrl_map</code> 会被转换为 <code>pinctrl_setting</code>，挂入对应的 <code>pinctrl_state.settings</code> 链表。</p>
<p>结构关系如下：</p>
<pre><code class="hljs language-scss" lang="scss">dev_pin_info
   └── pinctrl
        ├── states (链表)
        │     ├── <span class="hljs-built_in">pinctrl_state</span>("default")
        │     │       └── settings → <span class="hljs-built_in">pinctrl_setting</span>(多个)
        │     └── <span class="hljs-built_in">pinctrl_state</span>("sleep")
        └── dt_maps (映射链表)
</code></pre>
<p>此时，<code>dev_pin_info</code> 中的：</p>
<pre><code class="hljs language-arduino" lang="arduino">default_state → 指向 states 中名为 “<span class="hljs-keyword">default</span>” 的状态
sleep_state   → 指向 states 中名为 “sleep” 的状态
</code></pre>
<hr/>
<h3 data-id="heading-13">3.状态切换</h3>
<p>当驱动需要切换引脚状态时（如进入休眠），会调用：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">pinctrl_select_state</span>(pinctrl, sleep_state);
</code></pre>
<p>执行过程：</p>
<ol>
<li>遍历该状态下所有的 <code>pinctrl_setting</code></li>
<li>判断 setting 类型并调用相应 ops：</li>
</ol>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">switch</span> (setting-&gt;<span class="hljs-keyword">type</span>) {
<span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:
    pinmux_enable_setting(setting);
    <span class="hljs-comment">// 实际调用 -&gt; ops-&gt;set_mux()</span>
    <span class="hljs-keyword">break</span>;

<span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:
<span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:
    pinconf_apply_setting(setting);
    <span class="hljs-comment">// 实际调用 -&gt; ops-&gt;pin_config_group_set()</span>
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>最终由 pin controller 驱动的底层函数（<code>imx_pmx_ops</code>、<code>imx_pinconf_ops</code>）将配置写入寄存器，完成硬件层设置。</p>
<hr/>
<h3 data-id="heading-14">4.调试</h3>
<p>在 <code>/sys/kernel/debug/pinctrl/&lt;controller&gt;/</code> 下可以查看 pinctrl 的内部状态：</p>

































<table><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td><code>pins</code></td><td>已注册引脚信息</td></tr><tr><td><code>pingroups</code></td><td>引脚组信息</td></tr><tr><td><code>pinmux-pins</code></td><td>每个引脚的复用状态</td></tr><tr><td><code>pinmux-functions</code></td><td>功能与组的对应</td></tr><tr><td><code>pinconf-pins</code></td><td>引脚配置参数</td></tr><tr><td><code>pinconf-config</code></td><td>可动态修改配置</td></tr></tbody></table>
<p>示例：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cat</span> /sys/kernel/debug/pinctrl/20e0000.iomuxc/pingroups
<span class="hljs-built_in">cat</span> /sys/kernel/debug/pinctrl/20e0000.iomuxc/pinmux-functions
</code></pre>
<hr/>
<h3 data-id="heading-15">5.执行链总结</h3>





















































<table><thead><tr><th>阶段</th><th>主体</th><th>操作</th><th>核心结构 / 函数</th></tr></thead><tbody><tr><td><strong>1. 匹配驱动</strong></td><td>内核 → pinctrl 驱动</td><td>匹配 compatible</td><td><code>of_match_table</code></td></tr><tr><td><strong>2. 控制器注册</strong></td><td>pinctrl 驱动</td><td>注册 pin controller</td><td><code>devm_pinctrl_register</code></td></tr><tr><td><strong>3. 设备树解析</strong></td><td>内核框架</td><td>解析 pinctrl-0 节点</td><td><code>pinctrl_dt_to_map</code> / <code>dt_node_to_map</code></td></tr><tr><td><strong>4. 状态建立</strong></td><td>内核框架</td><td>创建 map → setting → state</td><td><code>pinctrl_add_setting</code></td></tr><tr><td><strong>5. 设备绑定</strong></td><td>内核框架</td><td>创建 <code>dev_pin_info</code> 与 <code>pinctrl</code></td><td><code>pinctrl_bind_pins</code></td></tr><tr><td><strong>6. 状态切换</strong></td><td>设备驱动</td><td>应用状态</td><td><code>pinctrl_select_state</code></td></tr><tr><td><strong>7. 硬件配置</strong></td><td>pinctrl 驱动</td><td>调用 ops 写寄存器</td><td><code>set_mux</code> / <code>pin_config_set</code></td></tr></tbody></table>
<hr/>
<h3 data-id="heading-16">6.总结</h3>
<p>pinctrl 驱动：描述并注册硬件引脚能力；</p>
<p>pinctrl 核心：提供统一的数据结构与调用机制；</p>
<p>设备驱动：声明状态，动态切换引脚配置；</p>
<p>dev_pin_info：连接设备与 pinctrl 框架的中枢，管理状态切换。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android暗黑模式适配全攻略：从入门到精通，告别"阴间配色"]]></title>    <link>https://juejin.cn/post/7587264707285106698</link>    <guid>https://juejin.cn/post/7587264707285106698</guid>    <pubDate>2025-12-25T01:49:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587264707285106698" data-draft-id="7587264707285041162" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android暗黑模式适配全攻略：从入门到精通，告别&quot;阴间配色&quot;"/> <meta itemprop="keywords" content="面试,Android,性能优化"/> <meta itemprop="datePublished" content="2025-12-25T01:49:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="顾林海"/> <meta itemprop="url" content="https://juejin.cn/user/2365804752153911"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android暗黑模式适配全攻略：从入门到精通，告别"阴间配色"
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2365804752153911/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    顾林海
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:49:19.000Z" title="Thu Dec 25 2025 01:49:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>如今打开手机，不少人都会下意识切换到暗黑模式——毕竟在深夜刷手机时，惨白的屏幕堪比"电子强光手电"，晃得人眼睛发酸。作为Android开发者，给应用做好暗黑模式适配早已不是"加分项"，而是关乎用户体验的"必做题"。</p>
<p>但适配暗黑模式可不是简单地把背景改成黑色、文字改成白色就完事了。不少新手踩坑后做出的暗黑模式，要么文字和背景对比度不够看得费劲，要么控件颜色混乱像"调色盘打翻"，要么切换时闪屏卡顿让用户抓狂。今天这篇全攻略，就从基础原理到进阶技巧，把Android暗黑模式适配讲得明明白白，还附上可直接复用的代码，让你少走99%的弯路。</p>
<h2 data-id="heading-1">一、先搞懂：暗黑模式适配的核心逻辑</h2>
<p>在动手写代码前，我们得先明白Android系统是怎么管理暗黑模式的。简单来说，核心逻辑就是 <strong>"资源匹配"</strong> ——系统会根据当前的主题模式（浅色/暗黑），自动加载对应的资源文件。</p>
<p>Android 10（API 29）是个关键节点，从这个版本开始，系统正式支持全局暗黑模式。而通过AndroidX的AppCompat库，我们可以把适配范围向下兼容到API 14，基本覆盖市面上绝大多数设备。</p>
<p>这里有个重要概念：<strong>DayNight主题</strong>。这是Android提供的"日夜切换"基础主题，我们的应用主题只要继承它，就能自动响应系统的主题切换指令。后续的所有适配工作，都是围绕这个主题展开的资源定制。</p>
<p>另外，暗黑模式的开启方式有三种（用户可自行切换）：</p>
<ul>
<li>系统设置：设置 &gt; 显示 &gt; 主题，手动切换浅色/暗黑；</li>
<li>快捷设置：下拉通知栏，点击"暗黑模式"快捷开关；</li>
<li>省电模式：部分设备（如Pixel）开启省电模式后，会自动切换到暗黑模式。</li>
</ul>
<p>我们的适配目标，就是让应用在这三种场景下，都能流畅、美观地切换主题，且所有UI元素都符合暗黑模式的视觉规范。</p>
<h2 data-id="heading-2">二、基础操作：3步搞定暗黑模式适配入门</h2>
<p>入门级的暗黑模式适配，核心就3个步骤：继承DayNight主题、创建暗黑模式资源目录、使用主题属性而非硬编码颜色。跟着做，就能快速实现基础的明暗切换效果。</p>
<h3 data-id="heading-3">步骤1：让应用主题继承DayNight主题</h3>
<p>首先找到应用的主题配置文件（通常在res/values/styles.xml），把主题的parent设置为DayNight相关主题。这里推荐使用Material Components库的主题，兼容性更好，还能直接复用Material Design的配色规范。</p>
<p>先确保在build.gradle中引入了Material Components依赖（如果还没引入的话）：</p>
<pre><code class="hljs language-groovy" lang="groovy">// Module级别的build.gradle
 dependencies {
     implementation 'com.google.android.material:material:1.12.0'
 }
 
</code></pre>
<p>然后修改styles.xml中的主题配置：</p>
<pre><code class="hljs language-xml" lang="xml">// res/values/styles.xml

     <span class="hljs-comment">&lt;!-- 基础主题：继承Material的DayNight主题 --&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"AppTheme"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&amp;<span class="hljs-attr">gt</span>;
         &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">主题属性配置</span>：<span class="hljs-attr">不要硬编码颜色</span>！ <span class="hljs-attr">--</span>&gt;</span><span class="xml">
         <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorPrimary"</span>&gt;</span>?attr/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorPrimaryDark"</span>&gt;</span>?attr/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorAccent"</span>&gt;</span>?attr/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:windowBackground"</span>&gt;</span>?android:attr/colorBackground<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
     </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

 
</code></pre>
<p>这里要重点提醒：<strong>绝对不要在主题中硬编码颜色</strong>（比如直接写#FFFFFF、#000000）。上面的?attr/xxx是主题属性引用，系统会根据当前模式自动匹配对应的颜色值，这是适配的核心前提。</p>
<h3 data-id="heading-4">步骤2：创建暗黑模式专属资源目录</h3>
<p>Android通过"资源限定符"来区分不同模式的资源。对于暗黑模式，我们需要创建带有**-night**后缀的资源目录，把暗黑模式下的资源放在里面。</p>
<p>常见的需要适配的资源包括：颜色（colors.xml）、图片（drawable）、布局（layout，一般不需要，除非布局结构有差异）、字符串（strings.xml，极少数场景需要）。</p>
<p>创建目录的规则很简单：在res目录下，复制原有的资源目录，添加-night后缀。比如：</p>
<ul>
<li>浅色模式颜色：res/values/colors.xml</li>
<li>暗黑模式颜色：res/values-night/colors.xml</li>
<li>浅色模式图片：res/drawable/icon_home.xml</li>
<li>暗黑模式图片：res/drawable-night/icon_home.xml</li>
</ul>
<p>注意：两个目录下的资源文件名必须完全一致，系统才能正确匹配。比如在values/colors.xml中定义了color_bg_main，在values-night/colors.xml中也必须定义同名的color_bg_main，只是颜色值不同。</p>
<h3 data-id="heading-5">步骤3：在布局中使用主题属性或资源引用</h3>
<p>创建好资源后，在布局文件中引用这些资源，而不是直接写死颜色。这样系统切换模式时，会自动加载对应目录下的资源。</p>
<pre><code class="hljs language-xml" lang="xml">// 正确示例：引用资源或主题属性
 <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
     <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@color/color_bg_main"</span>  &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">引用颜色资源</span> <span class="hljs-attr">--</span>&gt;</span>
     android:orientation="vertical"&gt;
 
     <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
         <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@string/app_name"</span>
         <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"?attr/textColorPrimary"</span>  &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">引用主题属性</span> <span class="hljs-attr">--</span>&gt;</span>
         android:textSize="20sp"/&gt;
 
 <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
 
</code></pre>
<p>对应的颜色资源文件示例：</p>
<pre><code class="hljs language-xml" lang="xml">// res/values/colors.xml（浅色模式）
 <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color_bg_main"</span>&amp;<span class="hljs-attr">gt</span>;#<span class="hljs-attr">FFFFFF</span>&amp;<span class="hljs-attr">lt</span>;/<span class="hljs-attr">color</span>&amp;<span class="hljs-attr">gt</span>;  &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">白色背景</span> <span class="hljs-attr">--</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color_text_main"</span>&amp;<span class="hljs-attr">gt</span>;#<span class="hljs-attr">333333</span>&amp;<span class="hljs-attr">lt</span>;/<span class="hljs-attr">color</span>&amp;<span class="hljs-attr">gt</span>;  &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">深灰色文字</span> <span class="hljs-attr">--</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
 
 // res/values-night/colors.xml（暗黑模式）
 <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color_bg_main"</span>&gt;</span>#121212<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 深黑色背景 --&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color_text_main"</span>&gt;</span>#E0E0E0<span class="hljs-symbol">&amp;lt;</span>/color<span class="hljs-symbol">&amp;gt;</span>  <span class="hljs-comment">&lt;!-- 浅灰色文字 --&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
</code></pre>
<p>到这里，基础的暗黑模式适配就完成了。运行应用后切换系统主题，你会发现界面会自动跟着切换明暗颜色。是不是很简单？但这只是入门，真正的难点在后面的细节优化。</p>
<h2 data-id="heading-6">三、进阶优化：从"能用"到"好用"的关键细节</h2>
<p>不少开发者做到上面三步就觉得完事了，但用户用起来还是吐槽不断。问题就出在细节上。下面这些进阶技巧，能让你的暗黑模式体验飙升一个档次。</p>
<h3 data-id="heading-7">1. 颜色适配：遵循"对比度优先"原则</h3>
<p>暗黑模式不是"黑色背景+白色文字"的简单组合，关键是要保证文字和背景的<strong>对比度足够高</strong>，否则用户会看得很费劲。根据WCAG（Web内容无障碍指南），正文文字与背景的对比度至少要达到4.5:1，标题文字至少要达到3:1。</p>
<p>这里推荐几个实用的颜色搭配方案（亲测不会踩坑）：</p>
<ul>
<li>背景色：#121212（深黑）、#1E1E1E（浅黑），避免用纯黑#000000，会让文字显得过于刺眼；</li>
<li>正文文字：#E0E0E0（浅灰）、#FFFFFF（白色），对比度足够且不刺眼；</li>
<li>辅助文字：#9E9E9E（中灰），用于提示性文字，对比度适中；</li>
<li>强调色：保持和浅色模式一致的强调色（如蓝色#2196F3），既能突出重点，又能保证视觉一致性。</li>
</ul>
<p>另外，Material Design 3提供了一套完整的暗黑模式配色系统，推荐直接复用：通过?attr/colorSurface（表面色）、?attr/colorOnSurface（表面文字色）等属性，能快速实现符合规范的配色。示例如下：</p>
<pre><code class="hljs language-xml" lang="xml">// 在主题中自定义Material 3配色
 <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"AppTheme"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span><span class="xml">
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorSurface"</span>&gt;</span>@color/surface<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorOnSurface"</span>&gt;</span>@color/on_surface<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorPrimary"</span>&gt;</span>@color/primary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"colorOnPrimary"</span>&gt;</span>@color/on_primary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
 </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
 
 // res/values/colors.xml
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"surface"</span>&gt;</span>#FFFFFF<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"on_surface"</span>&gt;</span>#121212<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"primary"</span>&gt;</span>#2196F3<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"on_primary"</span>&gt;</span>#FFFFFF<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 
 // res/values-night/colors.xml
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"surface"</span>&gt;</span>#121212<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"on_surface"</span>&gt;</span>#E0E0E0<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 <span class="hljs-symbol">&amp;lt;</span>color name="primary"<span class="hljs-symbol">&amp;gt;</span>#64B5F6<span class="hljs-symbol">&amp;lt;</span>/color<span class="hljs-symbol">&amp;gt;</span>  <span class="hljs-comment">&lt;!-- 暗黑模式下可稍微调亮强调色 --&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"on_primary"</span>&gt;</span>#000000<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>
 
</code></pre>
<h3 data-id="heading-8">2. 图片与图标适配：避免"白图标变黑底"的尴尬</h3>
<p>很多应用在浅色模式下用的是黑色图标，切换到暗黑模式后，图标就和黑色背景"融为一体"，用户根本看不见。这时候就需要为暗黑模式准备专属的图标资源。</p>
<p>推荐两种适配方案，根据场景选择：</p>
<h4 data-id="heading-9">方案1：使用矢量图（SVG）+ tint着色</h4>
<p>这是最推荐的方案，矢量图体积小、不失真，还能通过tint属性动态着色。我们只需要准备一份矢量图，然后在布局中通过?attr/colorControlNormal属性给图标着色，系统会自动根据主题切换颜色。</p>
<pre><code class="hljs language-xml" lang="xml">// 布局中的ImageView配置
 <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span>
     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"24dp"</span>
     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"24dp"</span>
     <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/ic_home"</span>  &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">矢量图资源</span> <span class="hljs-attr">--</span>&gt;</span>
     android:tint="?attr/colorControlNormal"/<span class="hljs-symbol">&amp;gt;</span>  <span class="hljs-comment">&lt;!-- 主题色着色 --&gt;</span>
 
</code></pre>
<p>这样一来，浅色模式下图标是黑色，暗黑模式下是白色，无需准备两份图标资源，省心又高效。</p>
<h4 data-id="heading-10">方案2：创建drawable-night目录存放专属图标</h4>
<p>如果是位图（PNG/JPG），就需要创建res/drawable-night目录，把暗黑模式下的图标放进去。注意图标文件名要和drawable目录下的一致，系统会自动匹配。</p>
<p>比如：</p>
<ul>
<li>浅色模式图标：res/drawable/ic_setting.png（黑色）</li>
<li>暗黑模式图标：res/drawable-night/ic_setting.png（白色）</li>
</ul>
<p>提示：尽量使用矢量图，减少APK体积，也避免多套位图资源的维护成本。</p>
<h3 data-id="heading-11">3. 应用内主题切换：给用户自主选择的权利</h3>
<p>除了跟随系统主题，很多应用还会提供"浅色/暗黑/跟随系统"的自主切换选项（比如微信、知乎）。这需要我们在应用内实现主题切换逻辑，还得把用户的选择持久化存储（比如SharedPreferences），下次启动时恢复用户的设置。</p>
<p>实现步骤如下：</p>
<h4 data-id="heading-12">第一步：定义主题切换选项对应的模式</h4>
<p>AppCompat提供了四种夜间模式，对应我们的切换选项：</p>
<ul>
<li>MODE_NIGHT_NO：强制浅色模式；</li>
<li>MODE_NIGHT_YES：强制深色模式；</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM：跟随系统（默认）；</li>
<li>MODE_NIGHT_AUTO_BATTERY：低电量时自动开启暗黑模式。</li>
</ul>
<h4 data-id="heading-13">第二步：实现切换逻辑与持久化存储</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 主题工具类：处理切换和持久化</span>
 <span class="hljs-keyword">object</span> ThemeUtils {
     <span class="hljs-comment">// 存储用户选择的主题模式，key为"night_mode"</span>
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> KEY_NIGHT_MODE = <span class="hljs-string">"night_mode"</span>
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sharedPreferences <span class="hljs-keyword">by</span> lazy {
         AppContext.context.getSharedPreferences(<span class="hljs-string">"app_settings"</span>, Context.MODE_PRIVATE)
     }
 
     <span class="hljs-comment">// 初始化主题：启动应用时调用</span>
     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initTheme</span><span class="hljs-params">()</span></span> {
         <span class="hljs-keyword">val</span> mode = sharedPreferences.getInt(KEY_NIGHT_MODE, AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
         AppCompatDelegate.setDefaultNightMode(mode)
     }
 
     <span class="hljs-comment">// 切换主题</span>
     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">switchTheme</span><span class="hljs-params">(mode: <span class="hljs-type">Int</span>)</span></span> {
         <span class="hljs-comment">// 保存主题模式到SP</span>
         sharedPreferences.edit().putInt(KEY_NIGHT_MODE, mode).apply()
         <span class="hljs-comment">// 设置主题模式</span>
         AppCompatDelegate.setDefaultNightMode(mode)
         <span class="hljs-comment">// 重启Activity以应用主题（可选，根据需求调整）</span>
         AppContext.context.startActivity(
             Intent(AppContext.context, MainActivity::<span class="hljs-keyword">class</span>.java).apply {
                 addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
             }
         )
     }
 }
 
</code></pre>
<h4 data-id="heading-14">第三步：在Activity中调用切换方法</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 示例：设置页面的切换按钮点击事件</span>
 btnLight.setOnClickListener {
     ThemeUtils.switchTheme(AppCompatDelegate.MODE_NIGHT_NO)
 }
 
 btnDark.setOnClickListener {
     ThemeUtils.switchTheme(AppCompatDelegate.MODE_NIGHT_YES)
 }
 
 btnFollowSystem.setOnClickListener {
     ThemeUtils.switchTheme(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
 }
 
</code></pre>
<p>注意：从AppCompat v1.1.0开始，setDefaultNightMode()会自动重建已启动的Activity，所以有时候不需要手动重启。但如果有特殊需求（比如保存页面状态），可以手动处理重启逻辑，并通过onSaveInstanceState()保存数据。</p>
<h2 data-id="heading-15">四、特殊场景适配：这些坑千万别踩</h2>
<p>除了常规的界面适配，还有几个特殊场景容易被忽略，一旦踩坑就会严重影响用户体验。下面逐个讲解解决方案。</p>
<h3 data-id="heading-16">1. 启动页（Splash）适配：避免"白屏闪一下"</h3>
<p>很多应用的启动页是通过WindowBackground设置的图片或颜色。如果启动页的颜色是硬编码的白色，那么在暗黑模式下启动应用时，会先闪一下白色的启动页，再切换到暗黑模式的界面，非常突兀。</p>
<p>解决方案：启动页的背景不要硬编码，使用主题属性?android:attr/colorBackground。</p>
<pre><code class="hljs language-xml" lang="xml">// 启动页的主题（在styles.xml中定义）
 <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SplashTheme"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span><span class="xml">
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:windowBackground"</span>&gt;</span>?android:attr/colorBackground<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 使用主题背景色 --&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:windowFullscreen"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
 </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
 
 // 在AndroidManifest.xml中给启动Activity设置主题
 <span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
     <span class="hljs-attr">android:name</span>=<span class="hljs-string">".SplashActivity"</span>
     <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/SplashTheme"</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span>/&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
 
</code></pre>
<p>如果启动页用的是图片，就需要创建drawable-night目录，放置暗黑模式下的启动页图片，确保启动页和应用主题保持一致。</p>
<h3 data-id="heading-17">2. WebView适配：让网页也能跟着变暗</h3>
<p>如果应用中有WebView加载网页，默认情况下网页不会跟随系统主题变暗，会出现"应用是暗黑模式，网页是浅色模式"的割裂感。解决方案有两种：</p>
<h4 data-id="heading-18">方案1：使用WebView的forceDark功能（Android 10+）</h4>
<p>Android 10及以上版本，WebView支持forceDark功能，能自动把浅色网页转换成暗黑模式。只需在代码中开启即可：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
     webView.settings.forceDark = WebSettings.FORCE_DARK_ON
     <span class="hljs-comment">// 可选：设置暗黑模式的对比度</span>
     webView.settings.forceDarkStrategy = WebSettings.DARK_STRATEGY_WEB_THEME_DARKEN
 }
 
</code></pre>
<h4 data-id="heading-19">方案2：自定义暗黑模式CSS</h4>
<p>如果需要兼容更低版本，或者想让网页暗黑模式更美观，可以在网页中添加暗黑模式的CSS，然后通过Android代码判断当前主题，注入对应的CSS样式。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 判断当前是否为暗黑模式</span>
 <span class="hljs-keyword">val</span> isDarkMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
 
 <span class="hljs-comment">// 加载网页时注入CSS</span>
 webView.webViewClient = <span class="hljs-keyword">object</span> : WebViewClient() {
     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPageFinished</span><span class="hljs-params">(view: <span class="hljs-type">WebView</span>?, url: <span class="hljs-type">String</span>?)</span></span> {
         <span class="hljs-keyword">super</span>.onPageFinished(view, url)
         <span class="hljs-keyword">val</span> css = <span class="hljs-keyword">if</span> (isDarkMode) {
             <span class="hljs-comment">// 暗黑模式CSS：设置背景色和文字色</span>
             <span class="hljs-string">"javascript:(function() { "</span> +
                     <span class="hljs-string">"document.body.style.backgroundColor = '#121212'; "</span> +
                     <span class="hljs-string">"document.body.style.color = '#E0E0E0'; "</span> +
                     <span class="hljs-string">"})()"</span>
         } <span class="hljs-keyword">else</span> {
             <span class="hljs-comment">// 浅色模式CSS</span>
             <span class="hljs-string">"javascript:(function() { "</span> +
                     <span class="hljs-string">"document.body.style.backgroundColor = '#FFFFFF'; "</span> +
                     <span class="hljs-string">"document.body.style.color = '#333333'; "</span> +
                     <span class="hljs-string">"})()"</span>
         }
         webView.evaluateJavascript(css, <span class="hljs-literal">null</span>)
     }
 }
 
</code></pre>
<h3 data-id="heading-20">3. 通知与Widget适配：别让通知成为"视觉异类"</h3>
<p>通知和桌面Widget是在应用外部显示的，也需要适配暗黑模式，否则在暗黑模式下会出现"白色通知框+黑色文字"的刺眼组合。</p>
<p>解决方案：</p>
<ul>
<li>通知：尽量使用系统提供的通知模板（如MessagingStyle、BigTextStyle），系统会自动适配暗黑模式。避免自定义通知布局，如果必须自定义，要使用主题属性设置颜色，不要硬编码。</li>
<li>Widget：在Widget的布局中使用主题属性（如?attr/textColorPrimary、?attr/colorBackground），确保文字和背景颜色能跟随主题切换。</li>
</ul>
<pre><code class="hljs language-xml" lang="xml">// Widget布局示例（使用主题属性）
 <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>
     <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
     <span class="hljs-attr">android:background</span>=<span class="hljs-string">"?attr/colorBackground"</span>
     <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>&gt;</span>
 
     <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
         <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/widget_title"</span>
         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
         <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"?attr/textColorPrimary"</span>
         <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"16sp"</span>/&gt;</span>
 
 <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
 
</code></pre>
<h2 data-id="heading-21">五、常见问题排查：解决适配中的"疑难杂症"</h2>
<p>适配过程中难免会遇到各种问题，下面列举几个最常见的坑，以及对应的解决方案。</p>
<h3 data-id="heading-22">1. 切换主题时闪黑/闪白</h3>
<p>问题原因：切换主题时系统会重建Activity，重建过程中会短暂显示Window的背景色，如果背景色和当前主题不匹配，就会出现闪屏。</p>
<p>解决方案：</p>
<ul>
<li>确保所有Activity的主题都继承自DayNight主题，且WindowBackground使用主题属性；</li>
<li>在AndroidManifest.xml中给Activity添加android:configChanges="uiMode"，避免系统自动重建，然后在Activity中重写onConfigurationChanged()方法，手动更新UI；</li>
</ul>
<h3 data-id="heading-23">2. 部分视图没有跟随主题切换</h3>
<p>问题原因：大概率是在代码中硬编码了颜色，或者没有使用主题属性/资源引用。</p>
<p>解决方案：</p>
<ul>
<li>全局搜索代码中的硬编码颜色（如#FFFFFF、#000000），全部替换为主题属性或资源引用；</li>
<li>检查是否所有资源都在values-night目录下有对应的暗黑模式版本；</li>
<li>如果是动态创建的视图，确保在创建时使用主题属性获取颜色：</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 正确示例：从主题中获取颜色</span>
 <span class="hljs-keyword">val</span> textColor = ThemeUtils.getColor(context, android.R.attr.textColorPrimary)
 textView.setTextColor(textColor)
 
 <span class="hljs-comment">// 工具类方法</span>
 <span class="hljs-keyword">object</span> ThemeUtils {
     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getColor</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, attr: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
         <span class="hljs-keyword">val</span> typedValue = TypedValue()
         context.theme.resolveAttribute(attr, typedValue, <span class="hljs-literal">true</span>)
         <span class="hljs-keyword">return</span> typedValue.<span class="hljs-keyword">data</span>
     }
 }
 
</code></pre>
<h3 data-id="heading-24">3. Force Dark功能不生效</h3>
<p>问题原因：Force Dark是Android 10提供的"一键暗黑"功能，适用于没有适配DayNight主题的应用，但有几个前提条件：</p>
<ul>
<li>应用主题必须是浅色主题（如Theme.Material.Light）；</li>
<li>必须在主题中设置android:forceDarkAllowed="true"；</li>
<li>如果应用已经继承了DayNight主题，Force Dark会自动失效（因为DayNight已经实现了暗黑模式）。</li>
</ul>
<p>解决方案：如果需要使用Force Dark，确保主题是浅色且开启了forceDarkAllowed；如果已经适配了DayNight主题，就不需要再使用Force Dark了。</p>
<h2 data-id="heading-25">六、进阶优化：让暗黑模式更极致的小技巧</h2>
<p>如果想让你的暗黑模式体验更上一层楼，可以试试下面这些小技巧：</p>
<h3 data-id="heading-26">1. 动态调整图片亮度</h3>
<p>对于一些没有适配暗黑模式的图片（比如用户头像、网络图片），可以在暗黑模式下适当降低图片亮度，避免图片过亮刺眼。可以通过ColorMatrix调整图片的亮度：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">adjustImageBrightness</span><span class="hljs-params">(imageView: <span class="hljs-type">ImageView</span>, isDarkMode: <span class="hljs-type">Boolean</span>)</span></span> {
     <span class="hljs-keyword">if</span> (isDarkMode) {
         <span class="hljs-keyword">val</span> matrix = ColorMatrix()
         matrix.setSaturation(<span class="hljs-number">0.8f</span>)  <span class="hljs-comment">// 降低饱和度</span>
         matrix.setScale(<span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">1f</span>)  <span class="hljs-comment">// 降低亮度</span>
         imageView.colorFilter = ColorMatrixColorFilter(matrix)
     } <span class="hljs-keyword">else</span> {
         imageView.colorFilter = <span class="hljs-literal">null</span>  <span class="hljs-comment">// 恢复正常</span>
     }
 }
 
</code></pre>
<h3 data-id="heading-27">2. 适配深色模式下的状态栏</h3>
<p>在暗黑模式下，状态栏的颜色也应该跟着调整，避免出现"白色状态栏+黑色文字"的割裂感。可以通过代码动态设置状态栏颜色和文字颜色：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setStatusBarTheme</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, isDarkMode: <span class="hljs-type">Boolean</span>)</span></span> {
     <span class="hljs-keyword">val</span> window = activity.window
     <span class="hljs-comment">// 设置状态栏背景色</span>
     window.statusBarColor = ThemeUtils.getColor(activity, android.R.attr.colorBackground)
     <span class="hljs-comment">// 设置状态栏文字颜色（true：黑色文字；false：白色文字）</span>
     ViewCompat.getWindowInsetsController(window.decorView)?.apply {
         isAppearanceLightStatusBars = !isDarkMode
     }
 }
 
</code></pre>
<h3 data-id="heading-28">3. 测试工具推荐</h3>
<p>适配完成后，一定要做好测试。推荐两个实用的测试工具：</p>
<ul>
<li>Android Studio的Layout Inspector：可以实时查看视图的颜色、资源引用，快速定位硬编码问题；</li>
<li>Accessibility Scanner（无障碍扫描器）：可以检测文字对比度是否达标，帮助优化无障碍体验。</li>
</ul>
<h2 data-id="heading-29">七、总结：暗黑模式适配的核心要点</h2>
<p>其实暗黑模式适配的核心就三件事：<strong>不硬编码颜色、用对主题属性、做好资源匹配</strong>。从基础的继承DayNight主题，到进阶的应用内切换和特殊场景适配，只要一步步跟着做，就能做出体验优秀的暗黑模式。</p>
<p>最后再强调几个关键点：</p>
<ul>
<li>优先使用Material Design的主题属性，减少自定义颜色的成本；</li>
<li>所有资源都要做好"浅色/暗黑"双版本准备，尤其是颜色和图标；</li>
<li>切换主题时要处理好Activity重建和状态保存，避免闪屏和数据丢失；</li>
<li>一定要测试特殊场景（启动页、WebView、通知、Widget），避免出现"视觉异类"。</li>
</ul>
<p>做好暗黑模式适配，不仅能提升用户体验，还能体现开发者的细节把控能力。希望这篇全攻略能帮你顺利搞定适配工作，让你的应用在深夜也能给用户带来舒适的使用体验～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 新并发框架之 async/await]]></title>    <link>https://juejin.cn/post/7587349016221810729</link>    <guid>https://juejin.cn/post/7587349016221810729</guid>    <pubDate>2025-12-25T02:26:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587349016221810729" data-draft-id="7587368168621834246" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 新并发框架之 async/await"/> <meta itemprop="keywords" content="iOS"/> <meta itemprop="datePublished" content="2025-12-25T02:26:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="皇上o_O"/> <meta itemprop="url" content="https://juejin.cn/user/4177799913409303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 新并发框架之 async/await
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4177799913409303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    皇上o_O
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:26:46.000Z" title="Thu Dec 25 2025 02:26:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 为什么需要 async/await</h2>
<p>在移动开发里，“并发/异步”几乎无处不在：网络请求、图片下载、文件读写、数据库操作……它们都有一个共同特点：</p>
<ul>
<li><strong>耗时</strong>（如果你在主线程里死等，会卡 UI）</li>
<li><strong>结果稍后才回来</strong>（你必须用某种方式“拿到结果”）</li>
</ul>
<p>传统的并发模型大多是“回调式”的：用 <code>completion</code>、delegate、通知等在未来某个时间点把结果交还给你。
这套方案能跑，但会带来两个典型挑战（你参考资料里也点出来了）：</p>
<ol>
<li><strong>代码维护性差</strong>：异步回调让代码阅读“跳来跳去”，不线性</li>
<li><strong>容易出现数据竞争（Data Races）</strong>：共享可变状态在并发下很容易出 Bug，而且难复现、难排查</li>
</ol>
<p>Swift 从 <strong>5.5</strong> 开始引入新并发框架，<code>async/await</code> 先解决第一个核心痛点：<strong>让异步代码看起来像同步代码一样顺畅</strong>，并且把错误处理变得更自然。</p>
<hr/>
<h2 data-id="heading-1">2. 先复习 4 个基础概念</h2>
<h3 data-id="heading-2">2.1 同步 vs 异步（描述“函数怎么返回”）</h3>
<ul>
<li><strong>同步（Synchronous）</strong>：函数执行完才返回
例子：<code>let x = add(1, 2)</code>，拿到结果才能往下走</li>
<li><strong>异步（Asynchronous）</strong>：函数把任务“丢出去”，<strong>结果以后再给你</strong>
所以你必须用 <code>completion</code> / delegate / async/await 等方式拿结果</li>
</ul>
<h3 data-id="heading-3">2.2 串行 vs 并行/并发（描述“一组任务怎么跑”）</h3>
<ul>
<li><strong>串行（Serial）</strong>：一次只执行一个任务，完成一个再下一个</li>
<li><strong>并发/并行（Concurrent/Parallel）</strong>：同一段时间内可能执行多个任务
（本文不严格区分并发与并行；你只要知道：会“同时处理多个任务”就行）</li>
</ul>
<hr/>
<h2 data-id="heading-4">3. 回调式异步的典型痛点：回调地狱 + 错误处理难看</h2>
<p>用“头像加载”来说明：
步骤：拿 URL → 下载数据（加密）→ 解密 → 解码成图片</p>
<h3 data-id="heading-5">3.1 回调地狱（Callback Hell）</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AvatarLoader</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadAvatar</span>(<span class="hljs-params">token</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>) -&gt; <span class="hljs-type">Void</span>) {
        fetchAvatarURL(token: token) { url <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>.fetchAvatar(url: url) { data <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">self</span>.decryptAvatar(data: data) { data <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">self</span>.decodeImage(data: data) { image <span class="hljs-keyword">in</span>
                        completion(image)
                    }
                }
            }
        }
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchAvatarURL</span>(<span class="hljs-params">token</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span>) { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchAvatar</span>(<span class="hljs-params">url</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Data</span>) -&gt; <span class="hljs-type">Void</span>) { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">decryptAvatar</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Data</span>) -&gt; <span class="hljs-type">Void</span>) { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">decodeImage</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>) -&gt; <span class="hljs-type">Void</span>) { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<p>阅读体验像在“走迷宫”：你要不停地进回调、出回调，脑子要同时记住很多上下文。</p>
<h3 data-id="heading-6">3.2 错误处理会让代码更糟</h3>
<p>异步回调常见的写法是 <code>completion(value, error)</code> 或者 <code>Result</code>。
但在多层嵌套里，错误传递会越来越啰嗦，漏掉某个分支的 <code>completion</code> 也很常见。</p>
<hr/>
<h2 data-id="heading-7">4. async/await 的核心：把“异步代码”写成“线性代码”</h2>
<h3 data-id="heading-8">4.1 先看效果：一眼就能读懂</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AvatarLoader</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadAvatar</span>(<span class="hljs-params">token</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">UIImage</span> {
        <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> fetchAvatarURL(token: token)
        <span class="hljs-keyword">let</span> encryptedData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> fetchAvatar(url: url)
        <span class="hljs-keyword">let</span> decryptedData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> decryptAvatar(data: encryptedData)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> decodeImage(data: decryptedData)
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchAvatarURL</span>(<span class="hljs-params">token</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchAvatar</span>(<span class="hljs-params">url</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Data</span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">decryptAvatar</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Data</span> { <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">decodeImage</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">UIImage</span> { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<p>你会发现：</p>
<ul>
<li>代码像同步一样从上到下执行（“直线式”）</li>
<li>错误处理回到了熟悉的 <code>throws + try + do/catch</code></li>
<li>逻辑清晰、可维护性大幅提升</li>
</ul>
<hr/>
<h2 data-id="heading-9">5. 语法规则：你只需要掌握这 3 条</h2>
<h3 data-id="heading-10">5.1 <code>async</code>：声明“这个函数可能会挂起”</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>() <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">Int</span> { <span class="hljs-number">42</span> }
</code></pre>
<p>含义：它是“异步函数”，执行过程中<strong>可能暂停</strong>（挂起），等待某些事情完成（比如网络返回、IO 完成）。</p>
<h3 data-id="heading-11">5.2 <code>await</code>：调用 async 函数时必须写</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> fetch()
</code></pre>
<p><code>await</code> 表示：这里是一个<strong>潜在挂起点</strong>（potential suspension point）。
意思是：运行到这里，可能会“先停一下”，等结果准备好再继续往下走。</p>
<h3 data-id="heading-12">5.3 <code>await</code> 只能出现在“异步上下文”里</h3>
<p>异步上下文主要有两类：</p>
<ol>
<li><strong>async 函数体内部</strong></li>
<li><strong>Task 闭包内部</strong></li>
</ol>
<hr/>
<h2 data-id="heading-13">6. 一个关键认知：挂起的是“函数”，不是“线程”</h2>
<p>这是很多新手最容易误解的地方：</p>
<ul>
<li><code>await</code> <strong>不是</strong>“把当前线程卡住等待”</li>
<li>它是“把当前函数挂起”，让出执行权</li>
<li>等条件满足后，再恢复执行（恢复时<strong>可能换了线程</strong>）</li>
</ul>
<p>你可以把它想象成：</p>
<blockquote>
<p>你在排队取号（await），你人可以先离开去做别的（线程去执行别的任务），等叫到你号了你再回来继续办理（函数恢复执行）。</p>
</blockquote>
<p><strong>结论</strong>：在 async/await 的世界里，别强依赖“我现在一定在某个线程上”。</p>
<hr/>
<h2 data-id="heading-14">7. 为什么“锁 + await”容易出事：一个经典坑</h2>
<p>一个很典型的示例：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> lock <span class="hljs-operator">=</span> <span class="hljs-type">NSLock</span>()

<span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>() <span class="hljs-keyword">async</span> {
    lock.lock()
    <span class="hljs-keyword">try?</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
    lock.unlock()
}

<span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">10</span> {
    <span class="hljs-type">Task</span> { <span class="hljs-keyword">await</span> test() }
}
</code></pre>
<p>问题在哪里？</p>
<ul>
<li>在 <code>lock.lock()</code> 后遇到了 <code>await</code></li>
<li>函数可能挂起并发生线程切换</li>
<li>其他任务也想拿锁，但锁可能被“拿着不放”</li>
<li>结果就是：很容易出现<strong>死锁/饥饿</strong>等难排查问题</li>
</ul>
<p><strong>经验法则：</strong></p>
<blockquote>
<p>不要在持有锁的期间跨过 <code>await</code>。
如果你需要保护共享可变状态，优先考虑 <code>actor</code>或让状态只在单一执行上下文里修改。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">8. 真正能上手的代码：用 URLSession 写一个 async 网络请求</h2>
<p>iOS 15+（Swift 5.5+）开始，<code>URLSession</code> 已经提供了 async API，例如：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> (data, response) <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">URLSession</span>.shared.data(from: url)
</code></pre>
<p>我们做一个“获取用户信息”的示例（包含错误处理）：</p>
<h3 data-id="heading-16">8.1 定义模型与错误</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> Foundation

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Decodable</span> {
    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
}

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">NetworkError</span>: <span class="hljs-title class_">Error</span> {
    <span class="hljs-keyword">case</span> invalidURL
    <span class="hljs-keyword">case</span> invalidResponse
    <span class="hljs-keyword">case</span> httpStatus(<span class="hljs-type">Int</span>)
}
</code></pre>
<h3 data-id="heading-17">8.2 写一个 async 网络层</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APIClient</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>: <span class="hljs-type">Int</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">User</span> {
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://example.com/users/<span class="hljs-subst">\(id)</span>"</span>) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.invalidURL
        }

        <span class="hljs-keyword">let</span> (data, response) <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">URLSession</span>.shared.data(from: url)

        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> http <span class="hljs-operator">=</span> response <span class="hljs-keyword">as?</span> <span class="hljs-type">HTTPURLResponse</span> <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.invalidResponse
        }
        <span class="hljs-keyword">guard</span> (<span class="hljs-number">200</span><span class="hljs-operator">...</span><span class="hljs-number">299</span>).contains(http.statusCode) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.httpStatus(http.statusCode)
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>, from: data)
    }
}
</code></pre>
<p>这一段代码的阅读体验就是“同步式”的：构建 URL → await 拿数据 → 校验 → decode。</p>
<hr/>
<h2 data-id="heading-18">9. 在 UIViewController 里怎么调用 async 并更新 UI？</h2>
<p>这是 iOS 开发里最常见的落地问题：</p>
<blockquote>
<p>async 方法不能直接在普通函数里 <code>await</code>，那我怎么从按钮点击里发请求？</p>
</blockquote>
<p>答案：用 <code>Task { }</code> 把它放进异步上下文里。</p>
<h3 data-id="heading-19">9.1 示例：点击按钮加载用户并刷新 label</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> UIKit

<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewController</span>: <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> api <span class="hljs-operator">=</span> <span class="hljs-type">APIClient</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> label <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
        <span class="hljs-keyword">super</span>.viewDidLoad()
        view.backgroundColor <span class="hljs-operator">=</span> .white

        label.numberOfLines <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
        label.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">20</span>, y: <span class="hljs-number">100</span>, width: <span class="hljs-number">320</span>, height: <span class="hljs-number">200</span>)
        view.addSubview(label)

        loadUser()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadUser</span>() {
        <span class="hljs-comment">// 进入异步上下文</span>
        <span class="hljs-type">Task</span> { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }

            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">let</span> user <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> api.fetchUser(id: <span class="hljs-number">1</span>)

                <span class="hljs-comment">// 更新 UI：回到主线程（MainActor）</span>
                <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {
                    <span class="hljs-keyword">self</span>.label.text <span class="hljs-operator">=</span> <span class="hljs-string">"用户：<span class="hljs-subst">\(user.name)</span><span class="hljs-subst">\n</span>ID：<span class="hljs-subst">\(user.id)</span>"</span>
                }

            } <span class="hljs-keyword">catch</span> {
                <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {
                    <span class="hljs-keyword">self</span>.label.text <span class="hljs-operator">=</span> <span class="hljs-string">"加载失败：<span class="hljs-subst">\(error)</span>"</span>
                }
            }
        }
    }
}
</code></pre>
<p>你只要记住一句话就够了：</p>
<ul>
<li><strong>耗时工作</strong>放在 <code>Task</code> 里 <code>await</code></li>
<li><strong>UI 更新</strong>放在 <code>MainActor</code>（主线程语义）里做</li>
</ul>
<hr/>
<h2 data-id="heading-20">10. 从旧代码迁移：把 completion 回调包装成 async</h2>
<p>很多项目里已经有大量回调式 API，你不可能一夜之间全改掉。Swift 提供了“续体（Continuation）”做桥接。</p>
<h3 data-id="heading-21">10.1 假设你有旧接口</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LegacyService</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchText</span>(<span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) {
        <span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: .now() <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) {
            completion(.success(<span class="hljs-string">"hello async/await"</span>))
        }
    }
}
</code></pre>
<h3 data-id="heading-22">10.2 用 withCheckedThrowingContinuation 包装</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">LegacyService</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchText</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> withCheckedThrowingContinuation { continuation <span class="hljs-keyword">in</span>
            fetchText { result <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">switch</span> result {
                <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> text):
                    continuation.resume(returning: text)
                <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-23">10.3 使用方式</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-type">Task</span> {
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> text <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">LegacyService</span>().fetchText()
        <span class="hljs-built_in">print</span>(text)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"error:"</span>, error)
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-24">11. 入门阶段的最佳实践清单</h2>
<ol>
<li><strong>不要在持锁期间跨 <code>await</code></strong>（容易死锁/逻辑卡住）</li>
<li><strong>UI 更新统一回到 <code>MainActor</code></strong>（避免主线程问题）</li>
<li><strong>能用 <code>throws</code> 就别用 Optional+error 乱传</strong>：错误路径更清晰</li>
<li><strong>从入口处就结构化</strong>：<code>async</code> 函数调用 <code>async</code> 函数，别层层回调</li>
<li><strong>迁移旧代码用 Continuation</strong>：逐步改，不要一次性重构到崩</li>
</ol>
<hr/>
<h2 data-id="heading-25">12. 小结</h2>
<p>到这里，你已经具备了 async/await 的“可用级理解”：</p>
<ul>
<li><code>async</code>：这个函数可能挂起</li>
<li><code>await</code>：潜在挂起点，只能在异步上下文使用</li>
<li>async/await 让异步代码“线性可读”，错误处理回到 <code>throws</code></li>
<li>挂起的是函数，不是线程；<code>await</code> 前后可能换线程</li>
<li>iOS 里用 <code>Task {}</code> 进入异步上下文，用 <code>MainActor</code> 更新 UI</li>
<li>旧回调接口可以用 <code>withCheckedThrowingContinuation</code> 平滑迁移</li>
</ul>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nextcloud Docker 容器化部署指南]]></title>    <link>https://juejin.cn/post/7587299670642704390</link>    <guid>https://juejin.cn/post/7587299670642704390</guid>    <pubDate>2025-12-25T02:06:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587299670642704390" data-draft-id="7587329107303415871" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nextcloud Docker 容器化部署指南"/> <meta itemprop="keywords" content="Docker,数据可视化,数据分析"/> <meta itemprop="datePublished" content="2025-12-25T02:06:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员老赵"/> <meta itemprop="url" content="https://juejin.cn/user/3208848015890347"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nextcloud Docker 容器化部署指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3208848015890347/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员老赵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:06:29.000Z" title="Thu Dec 25 2025 02:06:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">概述</h3>
<p>Nextcloud 是一款开源的容器化应用，为用户提供安全的数据存储与管理解决方案，支持文件访问与共享、日历、联系人、邮件等多种功能，可从任何设备访问，完全由用户自主掌控。该Docker镜像由Nextcloud社区开发维护，旨在提供轻量级、可扩展的部署方式。</p>
<p>本文档将详细介绍如何通过Docker容器化方式部署 Nextcloud ，包括环境准备、镜像拉取、容器配置、功能测试及生产环境优化建议，帮助用户快速搭建稳定可靠的NEXTCLOUD服务。</p>
<h3 data-id="heading-1">环境准备</h3>
<h4 data-id="heading-2">Docker环境安装</h4>
<p>部署 Nextcloud 容器前，需先确保服务器已安装Docker环境。推荐使用以下一键安装脚本，适用于主流Linux发行版：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">bash</span> &lt;(wget -qO- <span class="hljs-attribute">https</span>:<span class="hljs-comment">//xuanyuan.cloud/docker.sh)</span>
</code></pre>
<p>脚本执行过程中需根据提示完成必要配置，安装完成后可通过<code>docker --version</code>命令验证Docker是否正常安装。</p>
<h3 data-id="heading-3">镜像准备</h3>
<h4 data-id="heading-4">拉取 Nextcloud 镜像</h4>
<p>使用以下命令通过轩辕镜像访问支持地址拉取最新版本的 Nextcloud 镜像：</p>
<pre><code class="hljs language-arduino" lang="arduino">docker pull xxx.xuanyuan.run/library/nextcloud:latest
</code></pre>
<p>如需查看所有可用版本标签，可访问 Nextcloud 镜像标签列表 <code>https://xuanyuan.cloud/r/library/nextcloud/tags</code>。</p>
<h3 data-id="heading-5">容器部署</h3>
<h4 data-id="heading-6">基础部署（适用于测试环境）</h4>
<p>以下命令将创建一个基础的 Nextcloud 容器，使用默认配置和SQLite数据库，适合快速测试：</p>
<pre><code class="hljs language-arduino" lang="arduino">docker run -d \  --name nextcloud \  -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \  -v nextcloud_data:/var/www/html \  xxx.xuanyuan.run/library/nextcloud:latest
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li>• <code>-d</code>：后台运行容器</li>
<li>• <code>--name nextcloud</code>：指定容器名称为nextcloud</li>
<li>• <code>-p 80:80</code>：将容器80端口映射到主机80端口（端口配置请参考 NEXTCLOUD镜像文档（轩辕） <code>https://xuanyuan.cloud/r/library/nextcloud</code>）</li>
<li>• <code>-v nextcloud_data:/var/www/html</code>：创建命名卷<code>nextcloud_data</code>挂载到容器内<code>/var/www/html</code>目录，用于持久化存储数据</li>
</ul>
<h4 data-id="heading-7">自定义配置部署（适用于开发环境）</h4>
<p>如需自定义管理员账户、数据库配置等，可通过环境变量实现自动配置：</p>
<pre><code class="hljs language-javascript" lang="javascript">docker run -d \  --name nextcloud \  -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \  -v <span class="hljs-attr">nextcloud_data</span>:<span class="hljs-regexp">/var/</span>www/html \  -v <span class="hljs-attr">nextcloud_config</span>:<span class="hljs-regexp">/var/</span>www/html/config \  -v <span class="hljs-attr">nextcloud_apps</span>:<span class="hljs-regexp">/var/</span>www/html/custom_apps \  -e <span class="hljs-variable constant_">NEXTCLOUD_ADMIN_USER</span>=admin \  -e <span class="hljs-variable constant_">NEXTCLOUD_ADMIN_PASSWORD</span>=your_secure_password \  -e <span class="hljs-variable constant_">NEXTCLOUD_TRUSTED_DOMAINS</span>=<span class="hljs-string">"localhost 192.168.1.100"</span> \  xxx.<span class="hljs-property">xuanyuan</span>.<span class="hljs-property">run</span>/library/<span class="hljs-attr">nextcloud</span>:latest
</code></pre>
<p><strong>新增参数说明</strong>：</p>
<ul>
<li>• 额外挂载<code>nextcloud_config</code>和<code>nextcloud_apps</code>卷，分别用于持久化配置文件和自定义应用</li>
<li>• <code>NEXTCLOUD_ADMIN_USER</code>：设置管理员用户名</li>
<li>• <code>NEXTCLOUD_ADMIN_PASSWORD</code>：设置管理员密码（请替换为安全密码）</li>
<li>• <code>NEXTCLOUD_TRUSTED_DOMAINS</code>：设置可访问NEXTCLOUD的可信域名，多个域名用空格分隔</li>
</ul>
<h4 data-id="heading-8">外部数据库部署（推荐配置）</h4>
<p>NEXTCLOUD默认使用SQLite数据库，适合测试环境。生产环境建议使用MySQL/MariaDB或PostgreSQL数据库以提升性能和可靠性。以下是使用MariaDB的示例：</p>
<ol>
<li>
<p>1. <strong>启动MariaDB容器</strong>：</p>
<p>docker run -d \  --name nextcloud_db \  -v nextcloud_db:/var/lib/mysql \  -e MYSQL_ROOT_PASSWORD=root_password \  -e MYSQL_DATABASE=nextcloud \  -e MYSQL_USER=nextcloud_user \  -e MYSQL_PASSWORD=db_user_password \  mariadb:10.6</p>
</li>
<li>
<p>2. <strong>启动NEXTCLOUD容器并连接数据库</strong>：</p>
<p>docker run -d \  --name nextcloud \  --link nextcloud_db:db \  -p 80:80 \  -v nextcloud_data:/var/www/html \  -e MYSQL_HOST=db \  -e MYSQL_DATABASE=nextcloud \  -e MYSQL_USER=nextcloud_user \  -e MYSQL_PASSWORD=db_user_password \  -e NEXTCLOUD_ADMIN_USER=admin \  -e NEXTCLOUD_ADMIN_PASSWORD=your_secure_password \  xxx.xuanyuan.run/library/nextcloud:latest</p>
</li>
</ol>
<p><strong>说明</strong>：<code>--link nextcloud_db:db</code>参数将MariaDB容器链接到NEXTCLOUD容器，使NEXTCLOUD可通过<code>db</code>主机名访问数据库。</p>
<h3 data-id="heading-9">功能测试</h3>
<h4 data-id="heading-10">服务访问测试</h4>
<p>容器启动后，可通过以下方式验证服务是否正常运行：</p>
<ol>
<li>
<p>1. <strong>浏览器访问</strong>：在浏览器中输入<code>http://服务器IP</code>，首次访问将显示NEXTCLOUD设置页面（如未通过环境变量预设管理员账户）或直接进入登录界面。</p>
</li>
<li>
<p>2. <strong>命令行访问</strong>：使用<code>curl</code>命令测试端口连通性：</p>
<p>curl -I <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost" target="_blank" title="http://localhost" ref="nofollow noopener noreferrer">http://localhost</a></p>
</li>
</ol>
<p>若返回<code>HTTP/1.1 200 OK</code>或<code>HTTP/1.1 302 Found</code>，表示服务基本正常。</p>
<h4 data-id="heading-11">容器状态检查</h4>
<p>通过以下命令查看容器运行状态：</p>
<pre><code class="hljs language-python" lang="python">docker ps --<span class="hljs-built_in">filter</span> <span class="hljs-string">"name=nextcloud"</span>
</code></pre>
<p>正常情况下，容器状态应为<code>Up</code>。</p>
<h4 data-id="heading-12">日志查看</h4>
<p>查看容器日志以排查潜在问题：</p>
<pre><code class="hljs">docker logs nextcloud
</code></pre>
<p>首次启动时，日志将显示初始化过程，包括数据库连接、文件权限配置等信息。若出现错误，可根据日志提示进行排查。</p>
<h4 data-id="heading-13">基础功能测试</h4>
<ol>
<li>1. <strong>登录测试</strong>：使用预设的管理员账户登录系统，验证认证功能。</li>
<li>2. <strong>文件上传测试</strong>：上传一个小型测试文件，验证存储功能是否正常。</li>
<li>3. <strong>应用访问测试</strong>：访问内置应用（如“文件”、“相册”），确认应用加载正常。</li>
</ol>
<h3 data-id="heading-14">生产环境建议</h3>
<h4 data-id="heading-15">数据持久化优化</h4>
<p>生产环境中，建议对NEXTCLOUD的数据目录进行精细化挂载，确保数据安全和升级兼容性：</p>
<pre><code class="hljs language-javascript" lang="javascript">docker run -d \  --name nextcloud \  -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \  -v <span class="hljs-attr">nextcloud_html</span>:<span class="hljs-regexp">/var/</span>www/html \  -v <span class="hljs-attr">nextcloud_data</span>:<span class="hljs-regexp">/var/</span>www/html/data \  -v <span class="hljs-attr">nextcloud_config</span>:<span class="hljs-regexp">/var/</span>www/html/config \  -v <span class="hljs-attr">nextcloud_apps</span>:<span class="hljs-regexp">/var/</span>www/html/custom_apps \  -v <span class="hljs-attr">nextcloud_themes</span>:<span class="hljs-regexp">/var/</span>www/html/themes \  xxx.<span class="hljs-property">xuanyuan</span>.<span class="hljs-property">run</span>/library/<span class="hljs-attr">nextcloud</span>:latest
</code></pre>
<p><strong>挂载说明</strong>：</p>
<ul>
<li>• <code>/var/www/html/data</code>：用户上传文件存储目录</li>
<li>• <code>/var/www/html/config</code>：配置文件目录</li>
<li>• <code>/var/www/html/custom_apps</code>：自定义应用目录</li>
<li>• <code>/var/www/html/themes</code>：主题文件目录</li>
</ul>
<h4 data-id="heading-16">安全加固</h4>
<ol>
<li>
<p>1. <strong>启用HTTPS</strong>：生产环境必须配置HTTPS，可通过反向代理（如Nginx、Traefik）实现。示例Nginx配置可参考 NEXTCLOUD官方文档 <code>https://docs.nextcloud.com/server/latest/admin_manual/installation/nginx.html</code>。</p>
</li>
<li>
<p>2. <strong>限制容器权限</strong>：使用非root用户运行容器，减少安全风险：</p>
<p>docker run -d \  --name nextcloud \  --user 33:33 \  # www-data用户ID和组ID  -p 80:80 \  -v nextcloud_data:/var/www/html \  xxx.xuanyuan.run/library/nextcloud:latest</p>
</li>
<li>
<p>3. <strong>设置防火墙</strong>：只开放必要端口（如80/443），限制访问来源。</p>
</li>
</ol>
<h4 data-id="heading-17">性能优化</h4>
<ol>
<li>
<p>1. <strong>使用Redis缓存</strong>：配置Redis用于文件锁定和缓存，提升并发性能：</p>
<h2 data-id="heading-18">启动Redis容器docker run -d --name nextcloud_redis redis:alpine# 启动NEXTCLOUD并配置Redisdocker run -d \  --name nextcloud \  --link nextcloud_db:db \  --link nextcloud_redis:redis \  -p 80:80 \  -e REDIS_HOST=redis \  -e REDIS_HOST_PASSWORD=your_redis_password \  -v nextcloud_data:/var/www/html \  xxx.xuanyuan.run/library/nextcloud:latest</h2>
</li>
<li>
<p>2. <strong>调整PHP参数</strong>：根据服务器配置调整PHP内存限制和上传限制：</p>
<p>docker run -d \  --name nextcloud \  -e PHP_MEMORY_LIMIT=1G \  # 调整PHP内存限制为1GB  -e PHP_UPLOAD_LIMIT=10G \  # 调整上传限制为10GB  -v nextcloud_data:/var/www/html \  xxx.xuanyuan.run/library/nextcloud:latest</p>
</li>
<li>
<p>3. <strong>数据库优化</strong>：对MariaDB/MySQL进行性能调优，如调整连接数、缓存大小等，具体配置可参考数据库官方文档。</p>
</li>
</ol>
<h4 data-id="heading-19">备份策略</h4>
<p>定期备份NEXTCLOUD数据和数据库，建议使用以下策略：</p>
<ol>
<li>
<p>1. <strong>数据卷备份</strong>：使用<code>docker volume inspect</code>找到卷的实际路径，然后通过<code>rsync</code>或<code>tar</code>进行备份。</p>
</li>
<li>
<p>2. <strong>数据库备份</strong>：对MariaDB容器执行数据库导出：</p>
<p>docker exec nextcloud_db mysqldump -u root -p'root_password' nextcloud &gt; nextcloud_db_backup_$(date +%Y%m%d).sql</p>
</li>
<li>
<p>3. <strong>自动化备份</strong>：使用crontab设置定时任务，自动执行备份脚本，并将备份文件存储到外部存储或云存储服务。</p>
</li>
</ol>
<h3 data-id="heading-20">故障排查</h3>
<h4 data-id="heading-21">常见问题及解决方法</h4>
<ol>
<li>1. <strong>服务无法访问</strong></li>
</ol>
<ul>
<li>• 检查容器状态：<code>docker ps --filter "name=nextcloud"</code>，若未运行，使用<code>docker start nextcloud</code>启动</li>
<li>• 检查端口映射：<code>netstat -tulpn | grep 80</code>，确认端口未被占用</li>
<li>• 检查防火墙规则：确保服务器防火墙允许80/443端口访问</li>
</ul>
<ol start="3">
<li>2. <strong>数据库连接失败</strong></li>
</ol>
<ul>
<li>• 查看容器日志：<code>docker logs nextcloud</code>，检查数据库连接错误信息</li>
<li>• 验证数据库容器状态：<code>docker ps --filter "name=nextcloud_db"</code></li>
<li>• 检查数据库环境变量：确认<code>MYSQL_HOST</code>、<code>MYSQL_USER</code>、<code>MYSQL_PASSWORD</code>等参数正确</li>
</ul>
<ol start="5">
<li>3. <strong>文件上传失败</strong></li>
</ol>
<ul>
<li>• 检查目录权限：容器内<code>/var/www/html/data</code>目录权限应为www-data用户（ID 33）所有</li>
<li>• 检查PHP上传限制：通过环境变量<code>PHP_UPLOAD_LIMIT</code>调整上传大小限制</li>
<li>• 检查磁盘空间：使用<code>df -h</code>确认主机磁盘空间充足</li>
</ul>
<ol start="7">
<li>4. <strong>升级后功能异常</strong></li>
</ol>
<ul>
<li>
<p>• 查看升级日志：<code>docker logs nextcloud</code>，检查升级过程中的错误</p>
</li>
<li>
<p>• 禁用第三方应用：通过<code>occ</code>命令禁用可能不兼容的自定义应用：</p>
<pre><code class="hljs language-sql" lang="sql">docker <span class="hljs-keyword">exec</span> <span class="hljs-comment">--user www-data nextcloud php occ app:disable problematic_app</span>
</code></pre>
</li>
<li>
<p>• 恢复备份：若升级失败，可使用之前的备份恢复数据和配置</p>
</li>
</ul>
<h4 data-id="heading-22">日志排查工具</h4>
<ol>
<li>
<p>1. <strong>容器日志</strong>：<code>docker logs -f nextcloud</code>（<code>-f</code>参数可实时查看日志）</p>
</li>
<li>
<p>2. <strong>应用日志</strong>：Nextcloud 应用日志位于<code>/var/www/html/data/nextcloud.log</code>，可通过以下命令查看：</p>
<pre><code class="hljs language-bash" lang="bash">docker <span class="hljs-built_in">exec</span> nextcloud <span class="hljs-built_in">cat</span> /var/www/html/data/nextcloud.log
</code></pre>
</li>
<li>
<p>3. <strong>数据库日志</strong>：查看MariaDB容器日志以排查数据库问题：</p>
<pre><code class="hljs">docker logs nextcloud_db
</code></pre>
</li>
</ol>
<h3 data-id="heading-23">参考资源</h3>
<ol>
<li>1. Nextcloud 镜像文档（轩辕） <code>https://xuanyuan.cloud/r/library/nextcloud</code> - 轩辕镜像提供的NEXTCLOUD镜像详细说明</li>
<li>2. Nextcloud 镜像标签列表 <code>https://xuanyuan.cloud/r/library/nextcloud/tags</code> - 所有可用镜像版本标签</li>
<li>3. Nextcloud官方文档 <code>https://docs.nextcloud.com</code> - Nextcloud项目官方文档，包含详细的配置和管理指南</li>
<li>4. Docker官方文档 <code>https://docs.docker.com</code> - Docker容器技术官方文档，包含容器管理、网络、存储等基础内容</li>
<li>5. MariaDB官方文档 <code>https://mariadb.com/kb/en</code> - MariaDB数据库官方文档，包含性能优化、备份恢复等内容</li>
</ol>
<h3 data-id="heading-24">总结</h3>
<p>本文详细介绍了 Nextcloud 的Docker容器化部署方案，从环境准备、镜像拉取、基础部署到生产环境优化，提供了一套完整的部署流程。通过容器化部署，用户可快速搭建 Nextcloud 服务，并根据实际需求进行灵活配置。</p>
<p><strong>关键要点</strong>：</p>
<ul>
<li>• 使用轩辕镜像访问支持可提升 Nextcloud 镜像下载访问表现，简化部署流程</li>
<li>• 测试环境可使用基础部署命令快速启动，生产环境需配置外部数据库和HTTPS</li>
<li>• 数据持久化需通过Docker卷实现，建议精细化挂载关键目录以确保数据安全</li>
<li>• 定期备份数据和数据库是生产环境稳定运行的重要保障</li>
<li>• 遇到问题时，可通过容器日志、应用日志和数据库日志进行排查</li>
</ul>
<p><strong>后续建议</strong>：</p>
<ul>
<li>• 深入学习 Nextcloud 的高级特性，如外部存储集成、LDAP认证、联邦共享等，扩展服务功能</li>
<li>• 根据业务需求调整性能参数，如PHP内存限制、数据库连接数、缓存策略等，优化系统性能</li>
<li>• 关注 Nextcloud 镜像标签列表 <code>https://xuanyuan.cloud/r/library/nextcloud/tags</code>，及时更新镜像版本以获取安全补丁和新功能</li>
<li>• 建立完善的监控体系，对 Nextcloud 服务的运行状态、资源使用率进行实时监控，确保服务稳定运行</li>
</ul>
<p>通过本文档的指导，用户可在各种环境中高效部署和管理 Nextcloud 服务，充分利用其数据管理和协作功能，满足个人或企业的需求。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[微前端从入门到精通：Vue开发者的大型应用架构演进指南]]></title>    <link>https://juejin.cn/post/7587412021709225990</link>    <guid>https://juejin.cn/post/7587412021709225990</guid>    <pubDate>2025-12-25T03:26:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587412021709225990" data-draft-id="7587349016222302249" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="微前端从入门到精通：Vue开发者的大型应用架构演进指南"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2025-12-25T03:26:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Mr_chiu"/> <meta itemprop="url" content="https://juejin.cn/user/1644525124592974"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            微前端从入门到精通：Vue开发者的大型应用架构演进指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1644525124592974/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Mr_chiu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:26:07.000Z" title="Thu Dec 25 2025 03:26:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">开篇：当Vue应用从“小别墅”变成“摩天大楼”</h2>
<p>作为Vue开发者，你是否经历过这样的技术焦虑？</p>
<ul>
<li>项目代码量突破10万行，<code>npm run build</code> 时间超过5分钟</li>
<li>15个团队在同一个代码库中并行开发，每天产生数十个合并冲突</li>
<li>每次功能上线都需要全量回归测试，发布窗口越来越小</li>
<li>想用Vue 3的Composition API重构老代码，却无从下手</li>
</ul>
<p>这正是微前端架构要解决的核心问题。本文将为你呈现一套完整的Vue微前端实战指南，从基础概念到生产级架构设计，助你掌握大型Vue应用的拆分艺术。</p>
<h2 data-id="heading-1">第一章：重新认识微前端——不只是代码拆分</h2>
<h3 data-id="heading-2">1.1 微前端的本质：技术架构与组织架构的融合</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 微前端解决的不仅是技术问题</span>
<span class="hljs-keyword">const</span> microFrontendBenefits = {
  <span class="hljs-attr">technical</span>: [
    <span class="hljs-string">'独立开发、部署'</span>,
    <span class="hljs-string">'技术栈异构（Vue 2/3、React并行）'</span>,
    <span class="hljs-string">'渐进式升级'</span>,
    <span class="hljs-string">'增量更新'</span>
  ],
  <span class="hljs-attr">organizational</span>: [
    <span class="hljs-string">'团队自治'</span>,
    <span class="hljs-string">'并行开发流'</span>,
    <span class="hljs-string">'按业务领域划分职责'</span>,
    <span class="hljs-string">'降低协作成本'</span>
  ]
};
</code></pre>
<h3 data-id="heading-3">1.2 Vue开发者的微前端思维转变</h3>
<p><strong>传统思维：</strong></p>
<pre><code class="hljs">单仓库 → 集中路由 → 全局状态 → 统一构建 → 全量部署
</code></pre>
<p><strong>微前端思维：</strong></p>
<pre><code class="hljs">多仓库 → 路由聚合 → 状态隔离 → 独立构建 → 增量部署
</code></pre>
<h2 data-id="heading-4">第二章：Vue微前端核心技术选型深度解析</h2>
<h3 data-id="heading-5">2.1 主流方案横向对比</h3>








































<table><thead><tr><th>方案</th><th>核心原理</th><th>Vue支持度</th><th>生产就绪度</th><th>学习成本</th></tr></thead><tbody><tr><td><strong>qiankun</strong></td><td>运行时加载 + JS沙箱</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>中</td></tr><tr><td><strong>Module Federation</strong></td><td>编译时依赖共享</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>高</td></tr><tr><td><strong>Single-SPA</strong></td><td>生命周期调度</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>中</td></tr><tr><td><strong>无界</strong></td><td>iframe沙箱</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>低</td></tr></tbody></table>
<h3 data-id="heading-6">2.2 我们的选择：qiankun + Vue 3生态体系</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 技术栈全景图</span>
<span class="hljs-keyword">const</span> techStack = {
  <span class="hljs-attr">baseFramework</span>: <span class="hljs-string">'Vue 3 + TypeScript + Vite'</span>,
  <span class="hljs-attr">microFramework</span>: {
    <span class="hljs-attr">host</span>: <span class="hljs-string">'Vue 3 + qiankun'</span>,
    <span class="hljs-attr">microApps</span>: [
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'auth-center'</span>, <span class="hljs-attr">stack</span>: <span class="hljs-string">'Vue 3 + Pinia'</span> },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'dashboard'</span>, <span class="hljs-attr">stack</span>: <span class="hljs-string">'Vue 3 + Composition API'</span> },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'legacy-module'</span>, <span class="hljs-attr">stack</span>: <span class="hljs-string">'Vue 2 + Vuex'</span> },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'experimental'</span>, <span class="hljs-attr">stack</span>: <span class="hljs-string">'React 18'</span> } <span class="hljs-comment">// 技术栈自由！</span>
    ]
  },
  <span class="hljs-attr">stateManagement</span>: <span class="hljs-string">'Pinia (主应用) + 自定义通信协议'</span>,
  <span class="hljs-attr">buildSystem</span>: <span class="hljs-string">'Vite (微应用) + Webpack (主应用)'</span>
};
</code></pre>
<h2 data-id="heading-7">第三章：实战演练——从零构建生产级Vue微前端架构</h2>
<h3 data-id="heading-8">3.1 主应用：微前端的“航空母舰”</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// main-app/src/micro/registry.ts - 微应用注册中心</span>
<span class="hljs-keyword">import</span> { registerMicroApps, start, initGlobalState } <span class="hljs-keyword">from</span> <span class="hljs-string">'qiankun'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">MicroApp</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/types/micro'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">microApps</span>: <span class="hljs-title class_">MicroApp</span>[] = [
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vue3-auth'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_AUTH_APP_URL</span>,
    <span class="hljs-attr">container</span>: <span class="hljs-string">'#micro-container'</span>,
    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">'/auth'</span>,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">routerBase</span>: <span class="hljs-string">'/auth'</span>,
      <span class="hljs-attr">sharedStore</span>: <span class="hljs-title function_">initGlobalState</span>({ <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span> }),
      <span class="hljs-attr">onAuthSuccess</span>: <span class="hljs-function">(<span class="hljs-params">token: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'token'</span>, token);
      }
    }
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vue2-legacy'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_LEGACY_APP_URL</span>,
    <span class="hljs-attr">container</span>: <span class="hljs-string">'#micro-container'</span>,
    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">'/legacy'</span>,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-comment">// Vue 2兼容性适配器</span>
      <span class="hljs-attr">vue2Adapter</span>: <span class="hljs-literal">true</span>
    }
  }
];

<span class="hljs-comment">// 智能预加载策略</span>
<span class="hljs-keyword">const</span> prefetchApps = microApps
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> app.<span class="hljs-property">priority</span> === <span class="hljs-string">'high'</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> app.<span class="hljs-property">name</span>);

<span class="hljs-title function_">registerMicroApps</span>(microApps, {
  <span class="hljs-attr">beforeLoad</span>: [<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`加载 <span class="hljs-subst">${app.name}</span>`</span>)],
  <span class="hljs-attr">beforeMount</span>: [<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`挂载 <span class="hljs-subst">${app.name}</span>`</span>)],
  <span class="hljs-attr">afterUnmount</span>: [<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`卸载 <span class="hljs-subst">${app.name}</span>`</span>)]
});

<span class="hljs-title function_">start</span>({
  <span class="hljs-attr">prefetch</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sandbox</span>: {
    <span class="hljs-attr">experimentalStyleIsolation</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// CSS隔离</span>
  },
  <span class="hljs-attr">singular</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 允许同时运行多个微应用</span>
});
</code></pre>
<h3 data-id="heading-9">3.2 Vue 3微应用：现代化配置</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// micro-auth/src/entry.ts - 微应用入口文件</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>;
<span class="hljs-keyword">import</span> { createPinia } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> createApp&gt; | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">props: <span class="hljs-built_in">any</span> = {}</span>) {
  <span class="hljs-keyword">const</span> { container, routerBase } = props;
  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);
  
  <span class="hljs-comment">// 独立运行时与嵌入运行时路由差异化</span>
  <span class="hljs-keyword">const</span> baseRouter = routerBase || <span class="hljs-string">'/'</span>;
  
  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">router</span>(baseRouter));
  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">createPinia</span>());
  
  <span class="hljs-comment">// 挂载到指定容器或默认#app</span>
  <span class="hljs-keyword">const</span> target = container 
    ? container.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#auth-app'</span>) 
    : <span class="hljs-string">'#auth-app'</span>;
  
  instance = app.<span class="hljs-title function_">mount</span>(target);
  <span class="hljs-keyword">return</span> instance;
}

<span class="hljs-comment">// 独立运行</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) {
  <span class="hljs-title function_">render</span>();
}

<span class="hljs-comment">// qiankun生命周期协议</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'[Auth] 微应用启动'</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'[Auth] 接收主应用参数'</span>, props);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">render</span>(props);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (instance &amp;&amp; instance.<span class="hljs-property">$destroy</span>) {
    instance.$destroy();
  }
  instance = <span class="hljs-literal">null</span>;
}
</code></pre>
<h3 data-id="heading-10">3.3 Vue 2微应用：兼容性适配方案</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// micro-legacy/src/public-path.js</span>
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) {
  <span class="hljs-comment">// 动态设置webpack publicPath</span>
  __webpack_public_path__ = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span>;
}

<span class="hljs-comment">// micro-legacy/src/main.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;

<span class="hljs-keyword">let</span> vueInstance = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">{ container, routerBase } = {}</span>) {
  <span class="hljs-keyword">const</span> target = container 
    ? container.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#legacy-app'</span>) 
    : <span class="hljs-string">'#legacy-app'</span>;
  
  vueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    store,
    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)
  }).$mount(target);
  
  <span class="hljs-keyword">return</span> vueInstance;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'[Legacy] Vue 2应用启动'</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'[Legacy] 挂载'</span>, props);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">render</span>(props);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (vueInstance) {
    vueInstance.$destroy();
    vueInstance.<span class="hljs-property">$el</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
  }
  vueInstance = <span class="hljs-literal">null</span>;
}
</code></pre>
<h2 data-id="heading-11">第四章：高级特性实现——突破微前端核心难题</h2>
<h3 data-id="heading-12">4.1 跨应用状态管理：不只是Pinia/Vuex</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// shared/src/stores/global-store.ts - 跨应用状态总线</span>
<span class="hljs-keyword">import</span> { reactive, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> { initGlobalState, <span class="hljs-title class_">MicroAppStateActions</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'qiankun'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalStore</span> {
  <span class="hljs-keyword">private</span> state = <span class="hljs-title function_">reactive</span>({
    <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>,
    <span class="hljs-attr">permissions</span>: [] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[],
    <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span> <span class="hljs-keyword">as</span> <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span>
  });
  
  <span class="hljs-keyword">private</span> <span class="hljs-attr">actions</span>: <span class="hljs-title class_">MicroAppStateActions</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-title function_">init</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span> = <span class="hljs-title function_">initGlobalState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>);
    
    <span class="hljs-comment">// 监听状态变化</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-title function_">onGlobalStateChange</span>(<span class="hljs-function">(<span class="hljs-params">newState, prevState</span>) =&gt;</span> {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, newState);
    });
  }
  
  <span class="hljs-comment">// 更新状态并同步到所有微应用</span>
  <span class="hljs-title function_">setUser</span>(<span class="hljs-params">user: User</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">user</span> = user;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>?.<span class="hljs-title function_">setGlobalState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>);
  }
  
  <span class="hljs-comment">// 仅本地更新，不广播</span>
  <span class="hljs-title function_">setThemeLocal</span>(<span class="hljs-params">theme: <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">theme</span> = theme;
  }
  
  <span class="hljs-title function_">getState</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalStore</span>();

<span class="hljs-comment">// 在Vue组件中使用</span>
<span class="hljs-keyword">import</span> { globalStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@shared/store'</span>;
<span class="hljs-keyword">import</span> { storeToRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> { user, theme } = <span class="hljs-title function_">storeToRefs</span>(globalStore.<span class="hljs-title function_">getState</span>());
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateUser</span> = (<span class="hljs-params"/>) =&gt; {
      globalStore.<span class="hljs-title function_">setUser</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> });
    };
    
    <span class="hljs-keyword">return</span> { user, theme, updateUser };
  }
};
</code></pre>
<h3 data-id="heading-13">4.2 CSS隔离的终极方案</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 方案一：CSS Modules + 命名空间（推荐）</span>
<span class="hljs-selector-class">.auth-app</span> {
  <span class="hljs-comment">// 所有样式都在命名空间下</span>
  :global {
    <span class="hljs-selector-class">.button</span> {
      <span class="hljs-comment">// 覆盖全局样式</span>
    }
  }
}

<span class="hljs-comment">// 方案二：动态样式表加载/卸载</span>
class ScopedCSSManager {
  private styleCache = new Map&lt;string, HTMLStyleElement&gt;();
  
  <span class="hljs-built_in">load</span>(appName: string, css: string) {
    const style = document<span class="hljs-selector-class">.createElement</span>('style');
    style<span class="hljs-selector-class">.setAttribute</span>('data-app', appName);
    style<span class="hljs-selector-class">.textContent</span> = this<span class="hljs-selector-class">.scopeCSS</span>(css, appName);
    document<span class="hljs-selector-class">.head</span><span class="hljs-selector-class">.appendChild</span>(style);
    this<span class="hljs-selector-class">.styleCache</span><span class="hljs-selector-class">.set</span>(appName, style);
  }
  
  <span class="hljs-built_in">unload</span>(appName: string) {
    const style = this<span class="hljs-selector-class">.styleCache</span><span class="hljs-selector-class">.get</span>(appName);
    if (style &amp;&amp; document.head.contains(style)) {
      document<span class="hljs-selector-class">.head</span><span class="hljs-selector-class">.removeChild</span>(style);
    }
    this<span class="hljs-selector-class">.styleCache</span><span class="hljs-selector-class">.delete</span>(appName);
  }
  
  private <span class="hljs-built_in">scopeCSS</span>(css: string, appName: string): string {
    <span class="hljs-comment">// 将选择器转换为 [data-app="auth"] .button 形式</span>
    return css<span class="hljs-selector-class">.replace</span>(/([^{]+)\{/g, `<span class="hljs-selector-attr">[data-app=<span class="hljs-string">"${appName}"</span>]</span> $<span class="hljs-number">1</span>{`);
  }
}
</code></pre>
<h3 data-id="heading-14">4.3 智能路由与导航守卫</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// main-app/src/router/micro-router.ts</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;

<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/layouts/MainLayout.vue'</span>),
    <span class="hljs-attr">children</span>: [
      <span class="hljs-comment">// 主应用路由</span>
      { <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">HomePage</span> },
      <span class="hljs-comment">// 微前端路由 - 动态匹配</span>
      { 
        <span class="hljs-attr">path</span>: <span class="hljs-string">'/auth/:pathMatch(.*)*'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-title class_">MicroContainer</span>,
        <span class="hljs-attr">meta</span>: { <span class="hljs-attr">microApp</span>: <span class="hljs-string">'vue3-auth'</span> }
      },
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">'/legacy/:pathMatch(.*)*'</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-title class_">MicroContainer</span>,
        <span class="hljs-attr">meta</span>: { <span class="hljs-attr">microApp</span>: <span class="hljs-string">'vue2-legacy'</span> }
      }
    ]
  }
];

<span class="hljs-comment">// 导航守卫 - 微应用权限控制</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> microApp = to.<span class="hljs-property">meta</span>.<span class="hljs-property">microApp</span>;
  
  <span class="hljs-keyword">if</span> (microApp) {
    <span class="hljs-comment">// 检查微应用是否就绪</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isMicroAppLoaded</span>(microApp)) {
      <span class="hljs-title function_">loadMicroApp</span>(microApp).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">next</span>();
      }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">next</span>(<span class="hljs-string">'/error/micro-app-unavailable'</span>);
      });
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 检查微应用访问权限</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasPermissionForMicroApp</span>(microApp)) {
      <span class="hljs-title function_">next</span>(<span class="hljs-string">'/forbidden'</span>);
      <span class="hljs-keyword">return</span>;
    }
  }
  
  <span class="hljs-title function_">next</span>();
});
</code></pre>
<h2 data-id="heading-15">第五章：性能优化实战手册</h2>
<h3 data-id="heading-16">5.1 微应用懒加载与预加载策略</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// main-app/src/utils/preload-strategy.ts</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MicroAppPreloader</span> {
  <span class="hljs-keyword">private</span> loadedApps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();
  <span class="hljs-keyword">private</span> <span class="hljs-attr">prefetchQueue</span>: <span class="hljs-built_in">string</span>[] = [];
  
  <span class="hljs-comment">// 基于用户行为预测的预加载</span>
  <span class="hljs-title function_">setupUserBehaviorPrediction</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 1. 监听路由变化</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> nextApps = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">predictNextApps</span>(to);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">prefetch</span>(nextApps);
    });
    
    <span class="hljs-comment">// 2. 监听鼠标悬停</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseover'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> link = e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
      <span class="hljs-keyword">if</span> (link.<span class="hljs-property">dataset</span>.<span class="hljs-property">microApp</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">prefetch</span>([link.<span class="hljs-property">dataset</span>.<span class="hljs-property">microApp</span>]);
      }
    }, { <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> });
  }
  
  <span class="hljs-comment">// 智能预加载算法</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">prefetch</span>(<span class="hljs-params">appNames: <span class="hljs-built_in">string</span>[]</span>) {
    <span class="hljs-keyword">const</span> toLoad = appNames.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> 
      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">loadedApps</span>.<span class="hljs-title function_">has</span>(name) &amp;&amp; 
      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">prefetchQueue</span>.<span class="hljs-title function_">includes</span>(name)
    );
    
    <span class="hljs-comment">// 空闲时加载</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'requestIdleCallback'</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
      <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> app <span class="hljs-keyword">of</span> toLoad) {
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadAppResources</span>(app);
        }
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 降级方案：延迟加载</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        toLoad.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadAppResources</span>(app));
      }, <span class="hljs-number">1000</span>);
    }
  }
  
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">predictNextApps</span>(currentRoute): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-comment">// 基于路由配置的简单预测</span>
    <span class="hljs-keyword">const</span> routeMap = {
      <span class="hljs-string">'/dashboard'</span>: [<span class="hljs-string">'vue3-auth'</span>, <span class="hljs-string">'vue3-analytics'</span>],
      <span class="hljs-string">'/user/profile'</span>: [<span class="hljs-string">'vue3-auth'</span>],
      <span class="hljs-comment">// ...更多路由映射</span>
    };
    
    <span class="hljs-keyword">return</span> routeMap[currentRoute.<span class="hljs-property">path</span>] || [];
  }
}
</code></pre>
<h3 data-id="heading-17">5.2 构建优化：Vite + qiankun的最佳实践</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// micro-app/vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">target</span>: <span class="hljs-string">'es2015'</span>,
    <span class="hljs-attr">lib</span>: {
      <span class="hljs-attr">entry</span>: <span class="hljs-string">'src/entry.ts'</span>,
      <span class="hljs-attr">formats</span>: [<span class="hljs-string">'umd'</span>],
      <span class="hljs-attr">name</span>: <span class="hljs-string">'vue3AuthApp'</span>
    },
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">external</span>: [<span class="hljs-string">'vue'</span>, <span class="hljs-string">'vue-router'</span>, <span class="hljs-string">'pinia'</span>],
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">globals</span>: {
          <span class="hljs-attr">vue</span>: <span class="hljs-string">'Vue'</span>,
          <span class="hljs-string">'vue-router'</span>: <span class="hljs-string">'VueRouter'</span>,
          <span class="hljs-attr">pinia</span>: <span class="hljs-string">'Pinia'</span>
        },
        <span class="hljs-comment">// 确保qiankun能正确加载</span>
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'[name].js'</span>,
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'[name].[hash].js'</span>
      }
    }
  },
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3001</span>,
    <span class="hljs-attr">cors</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Access-Control-Allow-Origin'</span>: <span class="hljs-string">'*'</span>
    }
  }
});
</code></pre>
<h2 data-id="heading-18">第六章：生产环境部署与DevOps流水线</h2>
<h3 data-id="heading-19">6.1 微前端CI/CD架构</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># .github/workflows/deploy-micro-apps.yml</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Micro</span> <span class="hljs-string">Frontends</span>

<span class="hljs-attr">on:</span>
  <span class="hljs-attr">push:</span>
    <span class="hljs-attr">paths:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">'micro-apps/**'</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">'main-app/**'</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">deploy-micro-apps:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">strategy:</span>
      <span class="hljs-attr">matrix:</span>
        <span class="hljs-attr">app:</span> [<span class="hljs-string">auth</span>, <span class="hljs-string">dashboard</span>, <span class="hljs-string">legacy</span>]
    
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span>
      
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">node-version:</span> <span class="hljs-string">'18'</span>
          
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          cd micro-apps/${{ matrix.app }}
          npm ci
</span>          
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">Micro</span> <span class="hljs-string">App</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          cd micro-apps/${{ matrix.app }}
          npm run build
</span>          
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">CDN</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">aws-actions/configure-aws-credentials@v1</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">aws-access-key-id:</span> <span class="hljs-string">${{</span> <span class="hljs-string">secrets.AWS_ACCESS_KEY</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">aws-secret-access-key:</span> <span class="hljs-string">${{</span> <span class="hljs-string">secrets.AWS_SECRET_KEY</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">aws-region:</span> <span class="hljs-string">us-east-1</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          aws s3 sync ./dist s3://my-cdn/micro-apps/${{ matrix.app }}/${{ github.sha }}/
</span>          
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Update</span> <span class="hljs-string">Version</span> <span class="hljs-string">Registry</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          # 更新微应用版本清单
          curl -X POST https://api.myapp.com/versions \
            -H "Authorization: Bearer ${{ secrets.DEPLOY_TOKEN }}" \
            -d '{"app":"${{ matrix.app }}","version":"${{ github.sha }}"}'
</span></code></pre>
<h3 data-id="heading-20">6.2 版本管理与灰度发布</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// version-manager.ts - 微应用版本控制</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VersionManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">versionManifest</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = {};
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">versionManifest</span> = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchManifest</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupVersionPolling</span>();
  }
  
  <span class="hljs-comment">// 获取指定应用的最佳版本</span>
  <span class="hljs-title function_">getAppVersion</span>(<span class="hljs-attr">appName</span>: <span class="hljs-built_in">string</span>, userId?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">const</span> defaultVersion = <span class="hljs-variable language_">this</span>.<span class="hljs-property">versionManifest</span>[appName];
    
    <span class="hljs-comment">// 灰度发布逻辑</span>
    <span class="hljs-keyword">if</span> (userId &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isInGrayScale</span>(userId, appName)) {
      <span class="hljs-keyword">const</span> grayVersion = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getGrayVersion</span>(appName);
      <span class="hljs-keyword">return</span> grayVersion || defaultVersion;
    }
    
    <span class="hljs-keyword">return</span> defaultVersion;
  }
  
  <span class="hljs-comment">// 自动降级机制</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">loadWithFallback</span>(<span class="hljs-params">appName: <span class="hljs-built_in">string</span>, version: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadVersion</span>(appName, version);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`版本 <span class="hljs-subst">${version}</span> 加载失败，尝试回退`</span>);
      
      <span class="hljs-comment">// 尝试上一个稳定版本</span>
      <span class="hljs-keyword">const</span> stableVersion = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getStableVersion</span>(appName);
      <span class="hljs-keyword">if</span> (stableVersion !== version) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadVersion</span>(appName, stableVersion);
      }
      
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`微应用 <span class="hljs-subst">${appName}</span> 加载失败`</span>);
    }
  }
}
</code></pre>
<h2 data-id="heading-21">第七章：从Monolith到微前端——真实迁移案例</h2>
<h3 data-id="heading-22">迁移前后的量化对比</h3>
<p><strong>某电商平台Vue项目迁移数据：</strong></p>









































<table><thead><tr><th>指标</th><th>迁移前（单体）</th><th>迁移后（微前端）</th><th>改进</th></tr></thead><tbody><tr><td>构建时间</td><td>8分30秒</td><td>平均1分20秒</td><td>⬇️ 84%</td></tr><tr><td>首屏加载</td><td>3.2秒</td><td>1.8秒</td><td>⬇️ 44%</td></tr><tr><td>发布频率</td><td>每周1次</td><td>每日多次</td><td>⬆️ 500%+</td></tr><tr><td>团队独立部署率</td><td>0%</td><td>85%</td><td>⬆️ 85%</td></tr><tr><td>生产事故影响范围</td><td>全局</td><td>单个微应用</td><td>⬇️ 90%</td></tr></tbody></table>
<h3 data-id="heading-23">渐进式迁移策略示例</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 迁移路线图</span>
<span class="hljs-keyword">const</span> migrationRoadmap = [
  {
    <span class="hljs-attr">phase</span>: <span class="hljs-string">'准备阶段'</span>,
    <span class="hljs-attr">tasks</span>: [
      <span class="hljs-string">'搭建微前端基座'</span>,
      <span class="hljs-string">'配置构建流水线'</span>,
      <span class="hljs-string">'制定通信协议'</span>,
      <span class="hljs-string">'培训开发团队'</span>
    ],
    <span class="hljs-attr">duration</span>: <span class="hljs-string">'2周'</span>
  },
  {
    <span class="hljs-attr">phase</span>: <span class="hljs-string">'第一期迁移'</span>,
    <span class="hljs-attr">tasks</span>: [
      <span class="hljs-string">'抽离用户中心（低风险）'</span>,
      <span class="hljs-string">'独立部署认证模块'</span>,
      <span class="hljs-string">'验证技术方案可行性'</span>
    ],
    <span class="hljs-attr">duration</span>: <span class="hljs-string">'3周'</span>
  },
  {
    <span class="hljs-attr">phase</span>: <span class="hljs-string">'核心业务迁移'</span>,
    <span class="hljs-attr">tasks</span>: [
      <span class="hljs-string">'拆解商品详情页'</span>,
      <span class="hljs-string">'迁移订单流程'</span>,
      <span class="hljs-string">'实现购物车微应用'</span>
    ],
    <span class="hljs-attr">duration</span>: <span class="hljs-string">'6周'</span>
  },
  {
    <span class="hljs-attr">phase</span>: <span class="hljs-string">'收尾与优化'</span>,
    <span class="hljs-attr">tasks</span>: [
      <span class="hljs-string">'迁移剩余模块'</span>,
      <span class="hljs-string">'性能调优'</span>,
      <span class="hljs-string">'监控体系完善'</span>,
      <span class="hljs-string">'文档整理'</span>
    ],
    <span class="hljs-attr">duration</span>: <span class="hljs-string">'3周'</span>
  }
];
</code></pre>
<h2 data-id="heading-24">第八章：避坑指南与最佳实践</h2>
<h3 data-id="heading-25">8.1 常见问题与解决方案</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 🐛 问题1：微应用样式污染</span>
<span class="hljs-strong">**症状**</span>：微应用的CSS影响了其他应用
<span class="hljs-strong">**解决方案**</span>：
<span class="hljs-bullet">1.</span> 启用qiankun的experimentalStyleIsolation
<span class="hljs-bullet">2.</span> 使用CSS Modules + 命名空间前缀
<span class="hljs-bullet">3.</span> 动态样式表加载/卸载

<span class="hljs-section">## 🐛 问题2：全局变量冲突</span>
<span class="hljs-strong">**症状**</span>：多个Vue实例或Vuex store冲突
<span class="hljs-strong">**解决方案**</span>：
<span class="hljs-bullet">1.</span> 使用沙箱模式运行微应用
<span class="hljs-bullet">2.</span> 避免修改window全局对象
<span class="hljs-bullet">3.</span> 通过props传递共享依赖

<span class="hljs-section">## 🐛 问题3：路由跳转异常</span>
<span class="hljs-strong">**症状**</span>：微应用内跳转导致主应用路由混乱
<span class="hljs-strong">**解决方案**</span>：
<span class="hljs-bullet">1.</span> 统一使用主应用路由控制
<span class="hljs-bullet">2.</span> 微应用使用相对路径
<span class="hljs-bullet">3.</span> 实现路由事件代理机制

<span class="hljs-section">## 🐛 问题4：通信复杂度高</span>
<span class="hljs-strong">**症状**</span>：微应用间通信代码混乱
<span class="hljs-strong">**解决方案**</span>：
<span class="hljs-bullet">1.</span> 定义清晰的事件通信协议
<span class="hljs-bullet">2.</span> 使用状态管理库（Pinia）作为中心化store
<span class="hljs-bullet">3.</span> 限制直接通信，通过主应用中转
</code></pre>
<h3 data-id="heading-26">8.2 Vue微前端黄金法则</h3>
<ol>
<li><strong>单一职责原则</strong>：每个微应用只负责一个业务领域</li>
<li><strong>技术栈自由但有限制</strong>：允许异构，但要制定标准</li>
<li><strong>独立可部署</strong>：每个微应用都能独立运行和测试</li>
<li><strong>向后兼容</strong>：确保API和通信协议向后兼容</li>
<li><strong>监控全覆盖</strong>：每个微应用都需要独立的监控和日志</li>
</ol>
<h2 data-id="heading-27">结语：微前端不是银弹，而是架构演进的必经之路</h2>
<p>微前端并不是要取代Vue的单页面应用架构，而是为其提供一种可扩展的解决方案。当你的Vue应用从“小别墅”成长为“摩天大楼”时，微前端提供了必要的结构支撑。</p>
<p>记住，技术选型的核心不是追求最新最酷，而是找到最适合团队和业务场景的平衡点。微前端带来的不仅是技术上的解耦，更是组织架构和开发流程的优化。</p>
<p><strong>Vue 3 + qiankun的微前端方案，已经证明是生产可行的。现在，是时候将你的大型Vue应用带入微前端时代了。</strong></p>
<hr/>
<p><strong>资源推荐</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fqiankun.umijs.org%2F" target="_blank" title="https://qiankun.umijs.org/" ref="nofollow noopener noreferrer">qiankun官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvue-microfrontends" target="_blank" title="https://github.com/vue-microfrontends" ref="nofollow noopener noreferrer">Vue 3微前端实战代码库</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmodule-federation.io%2F" target="_blank" title="https://module-federation.io/" ref="nofollow noopener noreferrer">Module Federation with Vue</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmicro-frontends.org%2F" target="_blank" title="https://micro-frontends.org/" ref="nofollow noopener noreferrer">微前端设计模式</a></li>
</ul>
<p><em>本文首发于掘金技术社区，转载请注明出处。如果你在Vue微前端实践中遇到问题，欢迎在评论区交流讨论。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误]]></title>    <link>https://juejin.cn/post/7586901995429871625</link>    <guid>https://juejin.cn/post/7586901995429871625</guid>    <pubDate>2025-12-24T00:57:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7586901995429871625" data-draft-id="7586703355646492699" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误"/> <meta itemprop="keywords" content="MySQL,后端,SQL"/> <meta itemprop="datePublished" content="2025-12-24T00:57:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="青石路"/> <meta itemprop="url" content="https://juejin.cn/user/1999357021005580"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1999357021005580/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    青石路
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T00:57:04.000Z" title="Wed Dec 24 2025 00:57:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">开心一刻</h2>
<p>一天，老婆笑容满面的冲到我面前<br/>
老婆：你娶我到底是图我啥<br/>
我：便宜<br/>
老婆笑容瞬间消失，气呼呼的道：你会不会说话？<br/>
并且强调：我爸当年那是可怜你，没跟你多要<br/>
我：不是，你爸不是这么说的<br/>
老婆：那怎么说的<br/>
我开始学着老丈人的口吻：不许退，给你便宜点<br/></p>
<div align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/145c7b4e26194e5e81243a259cb88af9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S55-z6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767142624&amp;x-signature=XbcCvm3PTHFLzDz7MaVUbMmh9IY%3D" alt="开心一刻" loading="lazy"/></div>
<h2 data-id="heading-1">INSERT ON DUPLICATE KEY UPDATE</h2>
<p>关于 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>，相信大家都有所了解，是 <code>MySQL</code> 针对</p>
<blockquote>
<p>不存在则插入，存在则更新</p>
</blockquote>
<p>的一种方言实现；<code>存不存在</code> 该如何判定呢，基于表的 <code>唯一索引</code> 或 <code>主键</code></p>
<p>举个例子，如果列 <code>a</code> 被声明为 <code>唯一</code> 且表中已经存在 <code>a=1</code> 的记录，则以下两条语句具有类似的效果</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 (a,b,c) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
  <span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span>;

<span class="hljs-keyword">UPDATE</span> t1 <span class="hljs-keyword">SET</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span>;
</code></pre>
<p>假设我们有表</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tbl_insert_on_update` (
  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `uk_column1` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `uk_column2` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `remark` text,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),
  <span class="hljs-keyword">UNIQUE</span> KEY `name` (`name`)
) ENGINE<span class="hljs-operator">=</span>InnoDB
</code></pre>
<p>一开始表中没有数据，那么</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101002'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男二号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'狂风一样的男子'</span>;
</code></pre>
<p>的作用，相信大家都知道，与</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>);
</code></pre>
<p>作用一样，会往表中插入一条新的记录；如果再执行一次</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101002'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男二号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'狂风一样的男子'</span>;
</code></pre>
<p>呢，会是怎么样的结果？相信大家都知道</p>
<div align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a67391724fdd49c49a4b8c777679d035~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S55-z6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767142624&amp;x-signature=und9tkxAabtRGe70a0t6Ow2CfWo%3D" alt="insert_on_update_再执行一次" loading="lazy"/></div>
<p>与</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">UPDATE</span> tbl_insert_on_update <span class="hljs-keyword">SET</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101002'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男二号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'狂风一样的男子'</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
</code></pre>
<p>的效果一样。我们接着做个简单调整，拿掉 <code>name</code></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;
</code></pre>
<p>或者拿掉 <code>id</code></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;
</code></pre>
<p>会是怎么样的一个结果，你们可以大胆猜一下。这两个 SQL 的执行结果是一样的</p>
<div align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcc56051e4c24b888d7ccb70fed7bba3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S55-z6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767142624&amp;x-signature=W%2BDJ5QTi1N%2BUfCrqrtRoX2vn0ik%3D" alt="男三浩" loading="lazy"/></div>
<p>此时你们是不是有疑问呢</p>
<blockquote>
<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>
</blockquote>
<p>这个问题先放一放，我们先录入女一号的数据</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'婉儿'</span>, <span class="hljs-string">'20050101001X'</span>, <span class="hljs-string">'女一号'</span>, <span class="hljs-string">'花一样的女子'</span>);
</code></pre>
<p>假设我们要修改女一号的信息，包括 <code>姓名</code>，是不是可以这么实现</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'婉儿'</span>, <span class="hljs-string">'20050101001X'</span>, <span class="hljs-string">'女一号'</span>, <span class="hljs-string">'花一样的女子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span>, name<span class="hljs-operator">=</span><span class="hljs-string">'张三'</span>, uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101002X'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'女二号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'牵牛花一样的女子'</span>;
</code></pre>
<p>有什么问题吗，执行下就知道了嘛</p>
<div align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80d7289949da4d01b4e54029844f72f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S55-z6Lev:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767142624&amp;x-signature=%2BaD5b68%2Fb3%2FAFjXpF2yQROcxhfU%3D" alt="唯一索引冲突" width="90%" loading="lazy"/></div>
<p>执行报错了，提示</p>
<blockquote>
<p>1062 - Duplicate entry '张三' for key 'tbl_insert_on_update.name'</p>
</blockquote>
<p>这个错误信息我们是不是很熟悉？不就是唯一索引冲突吗？那么问题又来了</p>
<blockquote>
<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，为什么还会唯一索引冲突？</p>
</blockquote>
<h2 data-id="heading-2">如何判断是否存在</h2>
<p>我们写 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 语句时，并未指定用哪个 <code>主键</code> 或者 <code>唯一索引</code> 来判定记录是否存在</p>
<blockquote>
<p>Oracle、SQL Server、PostgreSQL 的 <code>MERGE</code> 有类似作用</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">MERGE</span> <span class="hljs-keyword">INTO</span> TBL_INSERT_ON_UPDATE t
<span class="hljs-keyword">USING</span> (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> ID, <span class="hljs-string">'张三'</span> <span class="hljs-keyword">AS</span> NAME, <span class="hljs-string">'20050101001'</span> <span class="hljs-keyword">AS</span> UK_COLUMN1, <span class="hljs-string">'男一号'</span> <span class="hljs-keyword">AS</span> UK_COLUMN2, <span class="hljs-string">'风一样的男子'</span> <span class="hljs-keyword">AS</span> REMARK <span class="hljs-keyword">FROM</span> dual
) s
<span class="hljs-keyword">ON</span> (t.NAME <span class="hljs-operator">=</span> s.NAME)  <span class="hljs-comment">-- 基于 NAME 字段匹配</span>
<span class="hljs-keyword">WHEN</span> MATCHED <span class="hljs-keyword">THEN</span>
    <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SET</span>
        t.ID <span class="hljs-operator">=</span> s.ID,
        t.UK_COLUMN1 <span class="hljs-operator">=</span> s.UK_COLUMN1,
        t.UK_COLUMN2 <span class="hljs-operator">=</span> s.UK_COLUMN2,
        t.REMARK <span class="hljs-operator">=</span> s.REMARK
<span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">NOT</span> MATCHED <span class="hljs-keyword">THEN</span>
    <span class="hljs-keyword">INSERT</span> (ID, NAME, UK_COLUMN1, UK_COLUMN2, REMARK)
    <span class="hljs-keyword">VALUES</span> (s.ID, s.NAME, s.UK_COLUMN1, s.UK_COLUMN2, s.REMARK);
</code></pre>
<p>其中的 <code>ON</code>  明确指定匹配字段（根据哪些字段判断记录是否存在），一般是指定 <code>主键</code>字段或 <code>唯一索引</code>字段</p>
</blockquote>
<p>那 MySQL 是如何判定记录是否存在的呢？我们可以翻阅下官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Finsert-on-duplicate.html" target="_blank" title="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" ref="nofollow noopener noreferrer">INSERT ... ON DUPLICATE KEY UPDATE Statement</a>。一开头有如下一段描述</p>
<blockquote>
<p>If you specify an <code>ON DUPLICATE KEY UPDATE</code> clause and a row to be inserted would cause a duplicate value in a <code>UNIQUE</code> index or <code>PRIMARY KEY</code>, an <a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Fupdate.html" target="_blank" title="https://dev.mysql.com/doc/refman/8.0/en/update.html" ref="nofollow noopener noreferrer"><code>UPDATE</code></a> of the old row occurs</p>
<p>当我们使用 <code>ON DUPLICATE KEY UPDATE</code>  子句时，插入的行导致 <code>唯一</code> 索引或者 <code>主键</code> 重复时，会更新旧的行</p>
</blockquote>
<p>通过这段话，我们只知道 MySQL 是根据唯一索引或主键来判定行是否存在，并不知道</p>
<ol>
<li>先根据主键判定，不冲突之后再根据唯一索引判定？</li>
<li>有多个唯一索引时，这些唯一索引的判定优先级是怎样的？</li>
</ol>
<p>官方文档里面并未明确说明这些问题，只是在结尾进行了如下说明</p>
<blockquote>
<p>An <a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Finsert-on-duplicate.html" target="_blank" title="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" ref="nofollow noopener noreferrer"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a> statement against a table having more than one unique or primary key is also marked as unsafe. (Bug #11765650, Bug #58637)</p>
<p>当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全</p>
</blockquote>
<p>不安全代表执行结果不固定，会出现我们预期之外的结果</p>
<h2 data-id="heading-3">工作原理</h2>
<p>如果让你们来实现 <code>不存在则插入，存在则更新</code>，你们会怎么实现？</p>
<p>逐个查询主键以及所有唯一索引，判断该行数据是否存在，一旦存在则根据重复的主键或者唯一索引进行 <code>UPDATE</code>，都不存在则进行 <code>INSERT</code>；这不仅是你们最容易想到的实现方式，也是我最容易想到的方式。</p>
<p>但 MySQL 并未采用这种方式，而是采用了另外一种更高效的方式，先尝试插入，存储引擎会向<strong>所有相关的唯一索引（包括主键）</strong> 中插入对应的索引条目，如果都插入成功，说明数据行不存在，那么 <code>INSERT</code> 数据行；一旦存储引擎尝试插入某个唯一索引时，发现该数据行已经存在，会立即停止插入动作，并向MySQL服务层抛出 <code>重复键</code> 错误，服务层收到重复键错误后，并不会让整个语句失败（因为使用了 ON DUPLICATE KEY UPDATE 子句），而是转换执行模式，会先回滚之前的插入，然后根据重复的那个唯一索引找到数据行对应的 <code>旧行</code> 数据，最后 <code>UPDATE</code> 数据行；总结下来分三步</p>
<ol>
<li>
<p>尝试插入</p>
<p>所有唯一索引（包括主键）都插入成功，则插入数据行，相当于完成普通的 <code>INSERT</code></p>
<p>一旦某个唯一索引插入失败，则立即停止插入，存储引擎会向上层抛出一个 <code>重复键</code> 错误</p>
</li>
<li>
<p>模式转换</p>
<p>MySQL服务器收到重复键后，发现执行语句中有 <code>ON DUPLICATE KEY UPDATE</code> 子句，不会直接让整个语句失败，而是先回滚之前的那部分唯一索引的插入，然后根据插入失败的唯一索引找到已经存在的 <code>旧行</code></p>
</li>
<li>
<p>执行更新</p>
<p>根据插入失败的唯一索引，对旧行执行更新操作，相当于完成普通的 <code>UPDATE</code></p>
</li>
</ol>
<p>整个 <code>尝试-失败-转换-更新</code> 过程时一个原子操作，那么完全成功，要么完全失败；相比于 <code>先查询后判断</code> 的传统实现，这种实现方式效率更高。</p>
<h2 data-id="heading-4">问题答疑</h2>
<p>前面涉及到两个问题，现在我们来解惑下</p>
<ol>
<li>
<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 拿掉name</span>
<span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;

<span class="hljs-comment">-- 拿掉id</span>
<span class="hljs-keyword">INSERT</span> tbl_insert_on_update(name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;
</code></pre>
<p>这个问题是不是很简单，我们一起来分析下</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(id, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;
</code></pre>
<p>INSERT 的字段中没有 <code>name</code>，但有 <code>id</code>，可想而知判断数据行是否存在，用到的是 <code>主键</code>，因为 <code>id=1</code> 的记录已经存在，所以根据 id 去更新其他字段值；那么执行结果与如下 SQL 一致</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">UPDATE</span> tbl_insert_on_update <span class="hljs-keyword">SET</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
</code></pre>
<p>同理</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> tbl_insert_on_update(name, uk_column1, uk_column2, remark)
<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-string">'20050101001'</span>, <span class="hljs-string">'男一号'</span>, <span class="hljs-string">'风一样的男子'</span>)
<span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span>;
</code></pre>
<p>INSERT 的字段中没有 <code>id</code>，但有 <code>name</code>，可想而知判断数据行是否存在，用到的是 <code>唯一索引</code>，因为 <code>name=张三</code> 的记录已经存在，所以根据 name 去更新其他字段值；那么执行结果与如下 SQL 一致</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">UPDATE</span> tbl_insert_on_update <span class="hljs-keyword">SET</span> uk_column1<span class="hljs-operator">=</span><span class="hljs-string">'20050101003'</span>, uk_column2<span class="hljs-operator">=</span><span class="hljs-string">'男三号'</span>, remark<span class="hljs-operator">=</span><span class="hljs-string">'暴风一样的男子'</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">'张三'</span>;
</code></pre>
<p><code>id = 1</code> 与 <code>name = '张三'</code> 指向的本来就是同一行数据，更新的列与列值都一致，那么执行结果自然就一样了</p>
</li>
<li>
<p>存在多个唯一索引（包含主键）时，判断数据行是否存在，这些唯一索引的优先级顺序是怎样的？</p>
<p>MySQL 官方文档并未明确说明这个优先级顺序，但在 MySQL 的实现中肯定有这个优先级顺序的实现算法，可能跟版本、存储引擎有关</p>
<p>基于 <code>8.0.31</code> 版本，简单测试出以下优先级</p>
<blockquote>
<p>主键 &gt; 唯一索引</p>
<p>唯一索引之间按创建顺序，先创建的优先级高</p>
</blockquote>
<p>官方文档已经明确说明：当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全，所以如上的测试结果并不具备确定性，不能作为使用准则</p>
</li>
<li>
<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误</p>
<p>MySQL是基于尝试插入的第一个冲突的唯一索引来执行更新的，更新的字段完全有可能触发其他唯一索引（包括主键）冲突</p>
<p>这个问题根本不成立！</p>
</li>
</ol>
<h2 data-id="heading-5">总结</h2>
<ol>
<li>
<p>不管是 MySQL，还是 Oracle、SQL Server、PostgreSQL，针对 <code>不存在则插入，存在则更新</code> 判断数据是否存在的逻辑都是一样的，只是 MySQL 不需要显示指定 <code>判存</code> 的唯一索引（包括主键），由 MySQL 引擎内部自动实现</p>
</li>
<li>
<p>关于判断数据行是否存在，多个唯一索引的优先级，看似能测出 MySQL 中的优先级，但并不具备确定性，不能作为使用准则</p>
<p>类似不确定的排序问题还有：<a href="https://juejin.cn/post/7290017749715632168" target="_blank" title="https://juejin.cn/post/7290017749715632168">我试图扯掉这条 SQL 的底裤</a></p>
</li>
<li>
<p>INSERT ... ON DUPLICATE KEY UPDATE 使用过程中有一些需要注意的点，需要结合自己的业务来分析是否可以忽略这些点</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fyouzhibing%2Fp%2F15248758.html" target="_blank" title="https://www.cnblogs.com/youzhibing/p/15248758.html" ref="nofollow noopener noreferrer">记录不存在则插入，存在则更新 → MySQL 的实现方式有哪些？</a></p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[给前端明星开源项目Biome提 PR，被 Snapshot 测试坑了一把]]></title>    <link>https://juejin.cn/post/7586983243925782566</link>    <guid>https://juejin.cn/post/7586983243925782566</guid>    <pubDate>2025-12-24T05:27:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7586983243925782566" data-draft-id="7586983243925766182" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="给前端明星开源项目Biome提 PR，被 Snapshot 测试坑了一把"/> <meta itemprop="keywords" content="前端,后端,测试"/> <meta itemprop="datePublished" content="2025-12-24T05:27:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            给前端明星开源项目Biome提 PR，被 Snapshot 测试坑了一把
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T05:27:55.000Z" title="Wed Dec 24 2025 05:27:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Snapshot 测试：从一次 CI 失败说起</h2>
<p>最近给 Biome 提了个 PR，改了几个文件，本地测试跑过了，push 上去，CI 挂了。</p>
<p>报错信息是这样的：</p>
<pre><code class="hljs language-arduino" lang="arduino">---- specs::nursery::no_undeclared_env_vars::invalid_js stdout ----
thread <span class="hljs-string">'specs::nursery::no_undeclared_env_vars::invalid_js'</span> panicked at
crates/biome_js_analyze/tests/spec_tests.rs:<span class="hljs-number">19</span>:<span class="hljs-number">5</span>:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Snapshot file: crates/biome_js_analyze/tests/specs/nursery/noUndeclaredEnvVars/invalid.js.snap
Snapshot: invalid_js
Source: crates/biome_js_analyze/tests/spec_tests.rs:<span class="hljs-number">19</span>

-old snapshot
+<span class="hljs-keyword">new</span> results
────────────────────────────────────────────────────────────────────────────────
</code></pre>
<p>一脸懵。我改的是 <code>--stdin-file-path</code> 的逻辑，跟 <code>noUndeclaredEnvVars</code> 这个 lint 规则有什么关系？</p>
<p>后来搞明白了：我的分支落后于 main，rebase 之后把上游的改动合进来了。上游给这个规则加了一行提示信息，但快照文件还是旧的，所以测试失败。</p>
<p>这就是 snapshot 测试。</p>
<h3 data-id="heading-1">什么是 snapshot 测试</h3>
<p>Snapshot，直译就是"快照"。生活中的快照是某个时刻的照片，代码里的 snapshot 是某个时刻程序输出的"照片"。</p>
<p>传统测试是这样写的：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 你得手动写出期望的输出</span>
<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">format</span>(<span class="hljs-string">"let x=1"</span>), <span class="hljs-string">"let x = 1;\n"</span>);
</code></pre>
<p>Snapshot 测试换了个思路：<strong>你不用写期望值，让程序自己记录。</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">第一次跑测试：
  输入 → 程序 → 输出 → 自动保存成 .snap 文件（这就是<span class="hljs-string">"快照"</span>）

后续跑测试：
  输入 → 程序 → 输出 → 跟 .snap 文件比对
                         │
                         ├── 一样 → 通过
                         └── 不一样 → 失败，显示 diff
</code></pre>
<p>第一次运行时，测试框架会问你："这个输出对吗？"你确认后，它就把输出存成 <code>.snap</code> 文件。之后每次运行，都拿新输出跟这个文件比。</p>
<p><strong>为什么叫"快照"？</strong></p>
<p>因为它记录的是某个时间点的状态。就像你给代码的输出拍了张照片，以后每次都拿新输出跟照片对比，看有没有变化。</p>
<p><strong>Snapshot 文件存什么？</strong></p>
<p>就是纯文本，记录程序的输出。比如格式化工具的 snapshot 存的是格式化后的代码，CLI 工具的 snapshot 存的是命令行输出，React 组件的 snapshot 存的是渲染出来的 DOM 结构。</p>
<p>我遇到的情况就是：上游改了规则的输出（多了一行 "This rule belongs to the nursery group"），但 <code>.snap</code> 文件还是旧的，新输出跟旧快照不一样，所以测试失败。</p>
<h3 data-id="heading-2">怎么修</h3>
<p>Biome 用的是 Rust 生态的 <code>insta</code> 库做 snapshot 测试。修起来很简单：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 先本地跑一遍测试，确认是 snapshot 的问题</span>
cargo <span class="hljs-built_in">test</span>

<span class="hljs-comment"># 接受新的 snapshot</span>
cargo insta accept

<span class="hljs-comment"># 或者用交互模式，逐个确认</span>
cargo insta review
</code></pre>
<p>跑完 <code>cargo insta accept</code>，它会自动更新 <code>.snap</code> 文件。commit 进去，push，CI 就过了。</p>
<h3 data-id="heading-3">快照文件长什么样</h3>
<p>看一眼 Biome 里的快照文件：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">source:</span> <span class="hljs-string">crates/biome_cli/tests/snap_test.rs</span>
<span class="hljs-attr">expression:</span> <span class="hljs-string">content</span>
<span class="hljs-meta">---</span>
<span class="hljs-comment">## `biome.json`</span>

<span class="hljs-string">```json</span>
{ <span class="hljs-attr">"files":</span> { <span class="hljs-attr">"includes":</span> [<span class="hljs-string">"apps/**"</span>] } }
</code></pre>
<h2 data-id="heading-4">Emitted Messages</h2>
<pre><code class="hljs language-block" lang="block">function f() {
	return {};
}
</code></pre>
<pre><code class="hljs language-csharp" lang="csharp">
就是把测试的输入（配置文件）和输出（格式化结果）都记下来。下次跑测试，输出变了就能发现。

<span class="hljs-meta">## 为什么 Biome 要用 snapshot 测试</span>

先想一个问题：Biome 是做什么的？

代码格式化和 lint。输入一段代码，输出格式化后的代码，或者输出一堆 lint 警告。

这类工具有个特点：**输出又长又复杂，而且经常变。**

比如格式化 `<span class="hljs-function">function <span class="hljs-title">f</span>()</span>{<span class="hljs-keyword">return</span>{}}` 这段代码，输出是：

```<span class="hljs-function">javascript
function <span class="hljs-title">f</span>()</span> {
	<span class="hljs-keyword">return</span> {};
}
</code></pre>
<p>如果用传统测试，你得这样写：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-built_in">assert_eq!</span>(
    <span class="hljs-title function_ invoke__">format_code</span>(<span class="hljs-string">"function f(){return{}}"</span>),
    <span class="hljs-string">"function f() {\n\treturn {};\n}\n"</span>
);
</code></pre>
<p>问题来了：</p>
<ol>
<li><strong>输出太长</strong>：这还是最简单的例子，真实场景可能是几十上百行代码</li>
<li><strong>转义字符地狱</strong>：<code>\n</code>、<code>\t</code> 一多，根本没法读</li>
<li><strong>改动频繁</strong>：格式化规则经常调整，比如"函数前要不要空行"，一改就得手动更新几百个测试</li>
</ol>
<p>Biome 有几千个测试用例，如果每个都手写期望值，维护成本太高了。</p>
<p>Snapshot 测试解决了这个问题：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// 不用写期望值，框架自动存</span>
assert_snapshot!(<span class="hljs-title function_ invoke__">format_code</span>(<span class="hljs-string">"function f(){return{}}"</span>));
</code></pre>
<p>输出自动存到 <code>.snap</code> 文件里，下次运行自动比对。改了格式化规则？跑一遍 <code>cargo insta accept</code>，几千个快照一起更新。</p>
<h3 data-id="heading-5">哪些项目在用</h3>
<p>不只是 Biome，很多知名项目都重度依赖 snapshot 测试：</p>













































<table><thead><tr><th>项目</th><th>类型</th><th>为什么用 snapshot</th></tr></thead><tbody><tr><td><strong>Prettier</strong></td><td>代码格式化</td><td>输出是格式化后的代码，手写太累</td></tr><tr><td><strong>Babel</strong></td><td>JS 编译器</td><td>输出是转换后的代码</td></tr><tr><td><strong>TypeScript</strong></td><td>类型检查</td><td>错误信息、类型推断结果</td></tr><tr><td><strong>Rome/Biome</strong></td><td>格式化+Lint</td><td>格式化结果、诊断信息</td></tr><tr><td><strong>Jest</strong></td><td>测试框架</td><td>React 组件渲染结果</td></tr><tr><td><strong>Rust Analyzer</strong></td><td>IDE 支持</td><td>代码补全、悬停提示</td></tr><tr><td><strong>SWC</strong></td><td>JS/TS 编译器</td><td>AST、转换结果</td></tr></tbody></table>
<p>这些项目有个共同点：<strong>输出是结构化的文本，而且量大</strong>。</p>
<p>用 snapshot 测试的好处：</p>
<ol>
<li><strong>防止回归</strong>：改了一行代码，所有相关输出的变化都能看到</li>
<li><strong>代码审查友好</strong>：PR 里能直接看到输出变化的 diff</li>
<li><strong>文档作用</strong>：快照文件本身就是"这个输入应该产生什么输出"的文档</li>
<li><strong>维护成本低</strong>：输出变了，一条命令更新，不用手动改几百个测试</li>
</ol>
<h3 data-id="heading-6">一个真实的例子</h3>
<p>我这次改的 PR 加了一个测试用例，测试 stdin 输入能不能正常格式化。</p>
<p>测试代码很简单：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">format_stdin_formats_virtual_path_outside_includes</span>() {
    <span class="hljs-comment">// 准备输入</span>
    console.in_buffer.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">"function f() {return{}}"</span>.<span class="hljs-title function_ invoke__">to_string</span>());

    <span class="hljs-comment">// 运行格式化</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">run_cli</span>(
        Args::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-string">"format"</span>, <span class="hljs-string">"--stdin-file-path"</span>, <span class="hljs-string">"mock.js"</span>]),
    );

    <span class="hljs-comment">// 快照测试</span>
    assert_cli_snapshot!(...);
}
</code></pre>
<p>生成的快照文件：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">source:</span> <span class="hljs-string">crates/biome_cli/tests/snap_test.rs</span>
<span class="hljs-attr">expression:</span> <span class="hljs-string">content</span>
<span class="hljs-meta">---</span>
<span class="hljs-comment">## `biome.json`</span>

{ <span class="hljs-attr">"files":</span> { <span class="hljs-attr">"includes":</span> [<span class="hljs-string">"apps/**"</span>] } }

<span class="hljs-comment"># Emitted Messages</span>

<span class="hljs-string">function</span> <span class="hljs-string">f()</span> {
	<span class="hljs-string">return</span> {}<span class="hljs-string">;</span>
}
</code></pre>
<p>以后如果有人改了格式化逻辑，导致输出变了，测试就会失败，提醒你检查这个变化是不是预期的。</p>
<h3 data-id="heading-7">什么时候用</h3>
<p>适合的场景：</p>

























<table><thead><tr><th>场景</th><th>例子</th></tr></thead><tbody><tr><td>CLI 工具</td><td>帮助信息、错误消息、格式化输出</td></tr><tr><td>编译器/格式化器</td><td>代码转换结果、AST 输出</td></tr><tr><td>UI 组件</td><td>React/Vue 组件的渲染结果</td></tr><tr><td>序列化</td><td>JSON、YAML 的输出</td></tr></tbody></table>
<p>不太适合的场景：</p>
<ul>
<li>简单断言（<code>1 + 1 == 2</code>）</li>
<li>随机/时间相关的输出</li>
<li>业务逻辑验证（snapshot 只能告诉你"变了"，不能告诉你"对不对"）</li>
</ul>
<h3 data-id="heading-8">容易踩的坑</h3>
<p><strong>1. 无脑 accept</strong></p>
<p>测试挂了，看都不看直接 <code>cargo insta accept</code>。这样 snapshot 测试就失去意义了——万一是真的 bug 呢？</p>
<p>我这次的情况比较明确，是 rebase 带进来的改动，所以直接 accept 没问题。但平时还是要看一眼 diff。</p>
<p><strong>2. 忘了提交快照文件</strong></p>
<p>本地跑测试没问题，CI 挂了。因为 <code>.snap</code> 文件没 commit。</p>
<p><strong>3. 快照太大</strong></p>
<p>有些项目喜欢把整个页面的渲染结果存成快照，几千行。每次 review 都是折磨，最后大家都无脑 accept 了。</p>
<p>建议拆小一点，每个快照保持在几十行内。</p>
<h3 data-id="heading-9">JavaScript 生态</h3>
<p>JS 这边常用的是 Jest 的 snapshot 功能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">test</span>(<span class="hljs-string">'Button 渲染正确'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> tree = renderer.<span class="hljs-title function_">create</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"点击"</span> /&gt;</span></span>).<span class="hljs-title function_">toJSON</span>();
  <span class="hljs-title function_">expect</span>(tree).<span class="hljs-title function_">toMatchSnapshot</span>();
});
</code></pre>
<p>更新快照：</p>
<pre><code class="hljs language-bash" lang="bash">jest --updateSnapshot
<span class="hljs-comment"># 或者</span>
jest -u
</code></pre>
<p>原理一样，就是 API 不同。</p>
<h3 data-id="heading-10">小结</h3>
<p>Snapshot 测试本质上是把"写期望值"这件事自动化了。对于输出复杂的场景（CLI、格式化器、UI 组件），能省不少事。</p>
<p>但记住：更新快照前要看一眼 diff，确认变化是你想要的。不然就跟我一样，rebase 完无脑 push，CI 一样会挂。</p>
<hr/>
<p>如果你觉得这篇文章有帮助，欢迎关注我的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i" target="_blank" title="https://github.com/tt-a1i" ref="nofollow noopener noreferrer">GitHub</a>，下面是我的一些开源项目：</p>
<p><strong>Claude Code Skills</strong>（按需加载，意图自动识别，不浪费 token，<a href="https://juejin.cn/post/7578714735307735066" target="_blank" title="https://juejin.cn/post/7578714735307735066">介绍文章</a>）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">code-review-skill</a> - 代码审查技能，覆盖 React 19、Vue 3、TypeScript、Rust 等约 9000 行规则（<a href="https://juejin.cn/post/7578709098255908902" target="_blank" title="https://juejin.cn/post/7578709098255908902">详细介绍</a>）</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2F5-whys-skill" target="_blank" title="https://github.com/tt-a1i/5-whys-skill" ref="nofollow noopener noreferrer">5-whys-skill</a> - 5 Whys 根因分析，说"找根因"自动激活</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Ffirst-principles-skill" target="_blank" title="https://github.com/tt-a1i/first-principles-skill" ref="nofollow noopener noreferrer">first-principles-skill</a> - 第一性原理思考，适合架构设计和技术选型</li>
</ul>
<p><strong>全栈项目</strong>（适合学习现代技术栈）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fprompt-vault" target="_blank" title="https://github.com/tt-a1i/prompt-vault" ref="nofollow noopener noreferrer">prompt-vault</a> - Prompt 管理器，用的都是最新的技术栈，适合用来学习了解最新的前端全栈开发范式：Next.js 15 + React 19 + tRPC 11 + Supabase 全栈示例，clone 下来配个免费 Supabase 就能跑</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fchat_edit" target="_blank" title="https://github.com/tt-a1i/chat_edit" ref="nofollow noopener noreferrer">chat_edit</a> - 双模式 AI 应用（聊天+富文本编辑），Vue 3.5 + TypeScript + Vite 5 + Quill 2.0 + IndexedDB</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大模型LLM入门篇：小白入门一文快速了解大模型（附教程）]]></title>    <link>https://juejin.cn/post/7586957587077103666</link>    <guid>https://juejin.cn/post/7586957587077103666</guid>    <pubDate>2025-12-24T06:03:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7586957587077103666" data-draft-id="7586957587077038130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大模型LLM入门篇：小白入门一文快速了解大模型（附教程）"/> <meta itemprop="keywords" content="LLM,Agent,LangChain"/> <meta itemprop="datePublished" content="2025-12-24T06:03:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型教程"/> <meta itemprop="url" content="https://juejin.cn/user/1145012233707299"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大模型LLM入门篇：小白入门一文快速了解大模型（附教程）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1145012233707299/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型教程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T06:03:21.000Z" title="Wed Dec 24 2025 06:03:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote>
<p>大模型席卷全球，彷佛得模型者得天下。对于IT行业来说，以后可能没有各种软件了，只有各种各样的智体（Agent）调用各种各样的API。在这种大势下，笔者也阅读了很多大模型相关的资料，和很多新手一样，开始脑子里都是一团乱麻，随着相关文章越读越多，再进行内容梳理，终于理清了一条清晰的脉络。</p>
<p>笔者希望通过三篇文章总结（入门篇、原理篇和应用篇）将思路写下来，以便跟我一样的新手读者快速了解大模型的方方面面。在这里，笔者先强调一下，本系列文章的深度有限，只是个人对大模型知识脉络的梳理，同时也会借鉴一下同行的博客内容充实本文，文末将会注明参考来源。</p>
<p>在开始阅读文章之前，有几个问题读者可以先思考一下：</p>
<ul>
<li>什么是大模型？</li>
<li>大模型最终要解决的问题是什么？</li>
</ul>
<h4 data-id="heading-0"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>大模型LLM与人工智能AI</h4>
<p>提到大模型（全名，大语言模型，LLM，Large Language Model），绕不开人工智能（AI，Artificial Intelligence）这个概念。</p>
<p>目前业界对于AI的定义有很多，但有一个令我印象深刻的说法：<strong>让机器像人一样阅读、写作和交流</strong>。通过最近几年AGI的高速发展，AI不仅仅能写作了，还能进行各种各样的创作了。所以，笔者认为这个说明可以进一步完善：<strong>人工智能就是要让机器像人一样阅读、创作和交流</strong>。</p>
<ul>
<li>阅读：机器能够像人一样接收各种各样的输入，并能够理解这些输入；</li>
<li>创作：机器能够像人一样进行创作输出，不仅仅只是写作，还包括：绘画、视频创作等等；</li>
<li>交流：在上述理解输入和创作输出的基础上，就自然而然可以实现机器像人一样交流，并且在创作输出能力上，可能比自然人更加优势。</li>
</ul>
<p>要实现上述描述的人工智能，首先就需要让机器理解人类的输入，人类的输入方式比较多，语言和文字首当其冲。要让机器理解语言和文字，就需要进行语言建模，语言建模的输出就是语言模型LM（Language Model）。</p>
<p>机器通过分析学习大量人类语言和文字，最终获得一个语言模型。通过该模型，机器好像<strong>听懂</strong>了用户输入一样，对用户的输入进行对应的输出。而用户通过得到的机器输出，也感觉机器<strong>理解</strong>了自己的意思。<strong>但实际这里的听懂和理解都是机器的运算。</strong></p>
<p>那么，这么厉害的模型是怎么来的呢？</p>
<h4 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>大模型LLM的发展与定义</h4>
<p>和很多有故事的人的名字一样，大模型一开始并不叫大模型。</p>
<p>大模型的发展经历了4个阶段：</p>
<ul>
<li>统计语言模型 SLM，Statistical Language Model，统计语言模型，基于统计学习方法开发，其基本思想是基于马尔可夫假设建立词预测模型。这种模型常见于我们的全文检索和推荐系统中，通过统计词频等信息来做统计预测，这种模型通常受到维数灾难的困扰。</li>
<li>神经语言模型 NLM，Neutral Language Model，通过神经网络，如循环神经网络（RNN），来描述单词序列的概率。该模型引入了词的分布式表示这一概念，并在聚合上下文特征（即分布式词向量）的条件下构建词预测函数。word2vec提出了构建简化的浅层神经网络来学习分布式单词表示的方法，这些表示在各种NLP任务中被证明非常有效。</li>
<li>预训练语言模型 PLM，Pre-training Language Model，基于自注意力机制的高度并行化Transformer架构，在大规模无标签语料库上使用专门设计的预训练任务。该模型确立了“预训练和微调”学习范式。在这个范式下，通常需要对PLM进行微调以适配不同的下游任务。</li>
<li>大语言模型 LLM，Large Language Model。研究人员发现，扩展PLM（扩展模型大小或数据大小）通常会提高下游任务的模型性能，许多研究通过训练越来越大的PLM来探索性能极限。随后发现，当模型参数达到某一极限之后，模型在解决一系列复杂任务中展示了惊人的能力，这种能力被称为【<strong>涌现能力</strong>】。 关于涌现能力，业界目前还有很多问题待研究解决。比如：模型参数具体达到多少涌现能力会出现？大模型为什么会突然出现涌现能力等。</li>
</ul>
<p>通过大模型的发展阶段描述，本节最后总结一下大模型LLM的定义。 <strong>大模型是一种采用Transformer架构，模型参数达到百亿或千亿级的预训练模型。</strong></p>
<h4 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>大模型LLM的分类</h4>
<p>目前业界涌现了非常多的大模型，也看了网上一些关于对大模型分类归纳的文章，都非常不错，本节主要是对网上的分类信息进行总结。</p>
<p>本节将从以下三个方面来对大模型进行分类：</p>
<h5 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>根据算法原理分类</h5>
<p>大模型的架构基本都是Transformer，而Transformer详细的结构在google发布的论文《Attention Is All You Need》中进行了描述，Transformer结构中有两个非常重要的部件：Encoder和Decoder，如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af58ee3a7a574c46b61eecce34429b8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767161000&amp;x-signature=onWZHqmLkTo6OqMMs5oE5e8xBS8%3D" alt="transformer架构.webp" loading="lazy"/></p>
<p>根据对Transformer结构的裁剪，可以将目前的大模型分为三类：</p>
<ul>
<li>Encoder-Only：裁剪了Decoder部件，代表模型BERT，到了2020年之后，这类技术基本已经不再发展。</li>
<li>Encoder-Decoder：没有裁剪任何部件，代表模型T5。</li>
<li>Decoder-Only：裁剪了Encoder部件，代表模型GPT，目前主导LLM领域的发展。</li>
</ul>
<p>下面是一张结合了大模型出现时间以及所属架构分类的图片，分别详细阐述了各个分类有哪些代表模型，以及模型出现的时间。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/baa636f5d459496cae65718a99af5797~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767161000&amp;x-signature=yfsxTDv6Iw7Np4cWN1g5DpyyjDo%3D" alt="llm-evolutionary-tree.png" loading="lazy"/></p>
<h5 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>根据输入内容分类</h5>
<p>根据输入内容不同，可以分为以下三类：</p>
<ul>
<li>语言大模型</li>
</ul>
<p>指在自然语言处理（Natural Language Processing，NLP）领域中的一类大模型，通常用于处理文本数据和理解自然语言。 这类大模型的主要特点是它们在大规模语料库上进行了训练，以学习自然语言的各种语法、语义和语境规则。 例如：GPT 系列（OpenAI）、Bard（Google）、文心一言（百度）。</p>
<ul>
<li>视觉大模型</li>
</ul>
<p>指在计算机视觉（Computer Vision，CV）领域中使用的大模型，通常用于图像处理和分析。 这类模型通过在大规模图像数据上进行训练，可以实现各种视觉任务，如图像分类、目标检测、图像分割、姿态估计、人脸识别等。 例如：VIT 系列（Google）、文心UFO、华为盘古 CV、INTERN（商汤）。</p>
<ul>
<li>多模态大模型</li>
</ul>
<p>指能够处理多种不同类型数据的大模型，例如文本、图像、音频等多模态数据。 这类模型结合了 NLP 和 CV 的能力，以实现对多模态信息的综合理解和分析，从而能够更全面地理解和处理复杂的数据。 例如：DingoDB 多模向量数据库（九章云极 DataCanvas）、DALL-E(OpenAI)、悟空画画（华为）、midjourney。</p>
<h5 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FDEVELOPERAA%2Farticle%2Fdetails%2F146979848%3Fops_request_misc%3D%25257B%252522request%25255Fid%252522%25253A%252522b89c918c549e0aaad7cb340126a05c42%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D%26request_id%3Db89c918c549e0aaad7cb340126a05c42%26biz_id%3D0%26utm_medium%3Ddistribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase%26utm_term%3D%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25B7%25AF%25E7%25BA%25BF%26spm%3D1018.2226.3001.4450" target="_blank" title="https://blog.csdn.net/DEVELOPERAA/article/details/146979848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b89c918c549e0aaad7cb340126a05c42%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=b89c918c549e0aaad7cb340126a05c42&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-28-146979848-null-null.nonecase&amp;utm_term=%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4450" ref="nofollow noopener noreferrer"/>根据应用领域分类</h5>
<p>按照应用领域，大模型主要可以分为 L0、L1、L2 三个层级：</p>
<ul>
<li>通用大模型 L0： 是指可以在多个领域和任务上通用的大模型。 它们利用大算力、使用海量的开放数据与具有巨量参数的深度学习算法，在大规模无标注数据上进行训练，以寻找特征并发现规律，进而形成可“举一反三”的强大泛化能力，可在不进行微调或少量微调的情况下完成多场景任务，相当于 AI 完成了“通识教育”。</li>
<li>行业大模型 L1： 是指那些针对特定行业或领域的大模型。 它们通常使用行业相关的数据进行预训练或微调，以提高在该领域的性能和准确度，相当于 AI 成为“行业专家”。</li>
<li>垂直大模型 L2： 是指那些针对特定任务或场景的大模型。 它们通常使用任务相关的数据进行预训练或微调，以提高在该任务上的性能和效果。</li>
</ul>
<h2 data-id="heading-6">学习资源推荐</h2>
<p>如果你想更深入地学习大模型，以下是一些非常有价值的学习资源，这些资源将帮助你从不同角度学习大模型，提升你的实践能力。</p>
<blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TRAE 2025 年度报告🥳：隐藏人格大揭秘！晒报告赢定制年终奖]]></title>    <link>https://juejin.cn/post/7587349016222367785</link>    <guid>https://juejin.cn/post/7587349016222367785</guid>    <pubDate>2025-12-25T03:31:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587349016222367785" data-draft-id="7587062584164810790" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TRAE 2025 年度报告🥳：隐藏人格大揭秘！晒报告赢定制年终奖"/> <meta itemprop="keywords" content="Trae,AI编程,VibeCoding"/> <meta itemprop="datePublished" content="2025-12-25T03:31:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金酱"/> <meta itemprop="url" content="https://juejin.cn/user/1556564194374926"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TRAE 2025 年度报告🥳：隐藏人格大揭秘！晒报告赢定制年终奖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1556564194374926/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:31:02.000Z" title="Thu Dec 25 2025 03:31:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cc3df41b00e4a0e8fef7414eb0d2af8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238262&amp;x-signature=qdeddRoXvXh%2FD0Ec2pxjZ8v%2FE6E%3D" alt="20251225-111403.png" loading="lazy"/></p>
<p><strong>年末收官，TRAE 年度报告正式上线啦</strong></p>
<p>这一年里，每一次和 AI 协作 Coding、每一段被优化的代码、每一个攻克的需求，都在 TRAE 留下了你的专属印记。通过这份报告，还能解锁你的隐藏编码人格～</p>
<p>COME ON ！晒出报告分享真实感受，来冲一波 TRAE 周边年终大礼！</p>
<p>用一条沸点，来给这一年的 Coding 时光完美收尾吧～</p>
<h3 data-id="heading-0">活动时间</h3>
<p>12月25日12:00-12月30日23:59</p>
<h3 data-id="heading-1">活动方式</h3>
<ul>
<li><strong>生成报告</strong>：点击链接<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.trae.cn%2Fevents%2Fannual-2025" target="_blank" title="https://www.trae.cn/events/annual-2025" ref="nofollow noopener noreferrer">www.trae.cn/events/annu…</a> 或扫描二维码，生成并保存你的 2025 年度报告。</li>
</ul>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da9dc97b2362442684f7a26ddecc7dd8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238262&amp;x-signature=80piVKiEsvvVoExfvD9fSpkkgOk%3D" alt="img_v3_02ta_eecdce34-bda4-4470-a0fe-86a5fbae943g.png" loading="lazy"/></p>
<ul>
<li>
<p><strong>发布沸点</strong>：在掘金社区内发布沸点，<strong>分享2025最具成就感的「数据面板」或「角色形象」</strong>，文案内容包括但不限于：体验感想、玩法攻略、反馈建议……</p>
</li>
<li>
<p><strong>添加话题</strong>：带上 <strong>#<a href="https://juejin.cn/pin/topic/7587524867952476206" target="_blank" title="https://juejin.cn/pin/topic/7587524867952476206">TRAELAND</a></strong> 话题标签。</p>
</li>
</ul>
<h3 data-id="heading-2">活动激励</h3>
<p>活动期间，综合统计所有符合要求的参赛沸点，按「点赞数 + 评论数」总和排名，前 100 名掘友可获得专属 TRAE 定制周边年终大礼～</p>
<p>💡 100 个获奖名额全覆盖，只要跻身前 100，即可将定制福利收入囊中！</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/325702089b7640c99f88fc5d580a2fc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238262&amp;x-signature=sFxKgaNzADS92g2wZDcfOJnVAhs%3D" alt="img_v3_02ta_9413d7eb-e69d-4fd2-b7db-0d74589504dg.jpg" loading="lazy"/></p>
<h3 data-id="heading-3">注意事项</h3>
<ul>
<li>
<p><strong>话题正确</strong>：参赛沸点必须添加 #<a href="https://juejin.cn/pin/topic/7587524867952476206" target="_blank" title="https://juejin.cn/pin/topic/7587524867952476206">TRAELAND</a> 话题标签，错加、漏加均视为无效参与；</p>
</li>
<li>
<p><strong>内容真实</strong>：分享的年度报告截图、数据信息需真实有效，严禁伪造、盗用他人内容，一经发现取消资格；</p>
</li>
<li>
<p><strong>形式合规</strong>：发布内容需清晰展示「角色形象」或「数据面板」之一，无遮挡、无模糊，确保审核人员可清晰辨识；</p>
</li>
<li>
<p><strong>公开可见</strong>：参赛沸点需设置为「公开」状态，私密或仅好友可见的内容无法参与审核与排名；</p>
</li>
<li>
<p><strong>合规创作</strong>：内容需积极向上，不得包含违规、低俗、攻击性言论，否则取消参与资格。</p>
</li>
<li>
<p>本次活动面向TRAE中国版用户。</p>
</li>
</ul>
<h3 data-id="heading-4">活动Q&amp;A</h3>
<p><strong>Q1: 有效沸点判定标准是什么？</strong></p>
<p>A1: 需同时满足以下条件：</p>
<p>① 内容积极向上，围绕 TRAELAND 年度报告展开真实分享，可含体验感想、玩法攻略、反馈建议等；</p>
<p>② 正确添加 <strong>#<a href="https://juejin.cn/pin/topic/7587524867952476206" target="_blank" title="https://juejin.cn/pin/topic/7587524867952476206">TRAELAND</a></strong> 话题标签；</p>
<p>③ 沸点设置为公开可见状态；</p>
<p>④ 清晰展示你的 TRAE LAND 角色形象或数据面板截图；内容真实，无伪造、盗用行为。</p>
<p><strong>Q2: 排名如何计算与截止时间？</strong></p>
<p>A2: 参赛沸点排名按「点赞数 + 评论数」总和核算，同一用户发布多条参赛内容，仅取数据最优一条参与排名；无意义水评论不计入有效评论数。；</p>
<p>数据统计截止时间为 2025 年 12 月 30 日 23:59，逾期新增的点赞、评论不再计入。获奖名单将于活动结束后 7 个工作日内，在掘金沸点圈子公布，敬请关注。</p>
<p><strong>Q3: 同一用户可以发布多条沸点参赛吗？</strong></p>
<p>A3: 可以，但同一用户仅能以数据最优的一条沸点参与排名，不可重复获奖。建议大家精心打磨一条内容，提升获奖概率哦～</p>
<p><strong>Q4: 是否必须发布截图？</strong></p>
<p>A4: 是的，请分享 TRAE LAND 年度报告中的“角色形象”或“数据面板”截图之一，并确保内容清晰可见。</p>
<p><strong>Q5: 违规或抄袭如何处理？</strong></p>
<p>A5: 一经核实存在刷量、抄袭、盗用等违规行为，将取消参与资格。</p>
<p><strong>Q6: 奖品如何发放？</strong></p>
<p>A6: 获奖名单公布后，官方将通过掘金社区「私信」功能联系获奖用户，核实身份信息与收货地址。请获奖用户在收到私信后 3 个工作日内回复确认，逾期未回复视为自动放弃福利。实物奖品将在信息确认后 10 个工作日内安排寄送。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin Flow 的 emit 和 tryEmit 有什么区别 ？]]></title>    <link>https://juejin.cn/post/7587342120021999667</link>    <guid>https://juejin.cn/post/7587342120021999667</guid>    <pubDate>2025-12-25T03:45:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587342120021999667" data-draft-id="7580815599351595023" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin Flow 的 emit 和 tryEmit 有什么区别 ？"/> <meta itemprop="keywords" content="Kotlin,Android,Android Jetpack"/> <meta itemprop="datePublished" content="2025-12-25T03:45:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="QING618"/> <meta itemprop="url" content="https://juejin.cn/user/339115460529117"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin Flow 的 emit 和 tryEmit 有什么区别 ？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/339115460529117/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    QING618
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:45:45.000Z" title="Thu Dec 25 2025 03:45:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Kotlin Flow 中，<code>emit()</code> 和 <code>tryEmit()</code> 都用于向 Flow 发送值，但它们的关键区别在于<strong>背压处理</strong>和<strong>协程上下文</strong>。</p>
<h2 data-id="heading-0">一、主要区别</h2>
<h4 data-id="heading-1">1. emit()</h4>
<ul>
<li><strong>挂起函数</strong>：会挂起直到有空间接收值（处理背压）</li>
<li><strong>协程安全</strong>：只能在协程作用域中调用</li>
<li><strong>推荐使用</strong>：在 <code>collect</code> 或 <code>callbackFlow</code> 中优先使用</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin">flow {
    <span class="hljs-comment">// 会挂起直到接收方准备好</span>
    emit(<span class="hljs-number">1</span>)
    emit(<span class="hljs-number">2</span>)
}
</code></pre>
<h4 data-id="heading-2">2. tryEmit()</h4>
<ul>
<li><strong>非挂起函数</strong>：尝试立即发射值，如果接收方未准备好则返回 <code>false</code></li>
<li><strong>可能丢数据</strong>：返回 <code>false</code> 时值会被丢弃</li>
<li><strong>有限场景</strong>：主要在 MutableStateFlow 和 MutableSharedFlow 中使用</li>
</ul>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> _state = MutableStateFlow(<span class="hljs-number">0</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateValue</span><span class="hljs-params">(newValue: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-comment">// 尝试发射，如果失败则丢弃</span>
    <span class="hljs-keyword">val</span> success = _state.tryEmit(newValue)
    <span class="hljs-keyword">if</span> (!success) {
        <span class="hljs-comment">// 处理发射失败的情况</span>
    }
}
</code></pre>
<h2 data-id="heading-3">二、使用场景对比</h2>
<h4 data-id="heading-4">1. 使用 emit() 的场景</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 在 flow {} 构建器中</span>
flow {
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) {
        delay(<span class="hljs-number">100</span>)
        emit(i)  <span class="hljs-comment">// ✅ 正确</span>
    }
}

<span class="hljs-comment">// 2. 在 callbackFlow 中</span>
callbackFlow {
    callback.setOnData { <span class="hljs-keyword">data</span> -&gt;
        trySend(<span class="hljs-keyword">data</span>)  <span class="hljs-comment">// callbackFlow 特殊方法</span>
    }
    awaitClose { callback.removeListener() }
}
</code></pre>
<h4 data-id="heading-5">2. 使用 tryEmit() 的场景</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 主要在 MutableStateFlow/MutableSharedFlow 中</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow&lt;UiState&gt;(Loading)
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;UiState&gt; = _uiState
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 非挂起函数中尝试更新状态</span>
        <span class="hljs-keyword">if</span> (!_uiState.tryEmit(Success(<span class="hljs-keyword">data</span>))) {
            <span class="hljs-comment">// 处理背压（通常日志记录）</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-6">3. 下面是一个小表格，可以帮助快速了解何时使用 <code>emit</code> 和 <code>tryEmit</code>：</h4>



































<table><thead><tr><th>场景</th><th>使用 emit</th><th>使用 tryEmit</th></tr></thead><tbody><tr><td>在挂起函数内部</td><td>是</td><td>避免使用（除非非常紧急）</td></tr><tr><td>UI 点击或生命周期事件</td><td>是</td><td>可能（如果需要快速更新）</td></tr><tr><td>回调、监听器或后台线程</td><td>避免使用（不能挂起）</td><td>是</td></tr><tr><td>需要保证数据送达</td><td>是</td><td>否（需自行处理失败情况）</td></tr><tr><td>发送即忘（fire-and-forget）场景</td><td>否</td><td>是</td></tr></tbody></table>
<p>两句话概括就是：</p>
<ul>
<li>当你需要可靠的、对协程友好的发送方式时，使用 <code>emit</code>。</li>
<li>当你希望实现无阻塞、快速触发且不暂停的操作时，使用 <code>tryEmit</code>。</li>
</ul>
<h2 data-id="heading-7">三、重要注意事项</h2>
<ol>
<li>
<p><strong>callbackFlow 的特殊情况</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin">callbackFlow {
    callback { <span class="hljs-keyword">data</span> -&gt;
        <span class="hljs-comment">// 这里必须用 trySend，因为 callback 不是挂起上下文</span>
        trySend(<span class="hljs-keyword">data</span>)
    }
}
</code></pre>
</li>
<li>
<p><strong>MutableSharedFlow 的配置影响</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> flow = MutableSharedFlow&lt;<span class="hljs-built_in">Int</span>&gt;(
    replay = <span class="hljs-number">0</span>,
    extraBufferCapacity = <span class="hljs-number">10</span>  <span class="hljs-comment">// 缓冲区大小影响 tryEmit 成功率</span>
)
</code></pre>
</li>
<li>
<p><strong>性能考虑</strong></p>
<ul>
<li><code>emit()</code>：更安全，保证数据不丢失</li>
<li><code>tryEmit()</code>：性能更好，但可能丢失数据</li>
</ul>
</li>
</ol>
<p>总结一下二者的区别：</p>



































<table><thead><tr><th>特性</th><th>emit()</th><th>tryEmit()</th></tr></thead><tbody><tr><td>挂起函数</td><td>是</td><td>否</td></tr><tr><td>等待收集者</td><td>是（如果缓冲区已满）</td><td>否</td></tr><tr><td>返回类型</td><td>Unit</td><td>Boolean</td></tr><tr><td>是否立即发射？</td><td>否（可能会挂起）</td><td>是（如果缓冲区允许）</td></tr><tr><td>是否可在协程中使用？</td><td>必须</td><td>不需要</td></tr></tbody></table>
<h2 data-id="heading-8">四、最佳实践建议</h2>
<ul>
<li><strong>优先使用 <code>emit()</code></strong> ，除非有特殊性能需求</li>
<li>在 <code>flow {}</code> 构建器中<strong>总是使用 <code>emit()</code></strong></li>
<li>在回调接口中（如 callbackFlow）使用 <code>trySend()</code>/<code>tryEmit()</code></li>
<li>对于状态更新，如果无法确保在协程上下文中，使用 <code>tryEmit()</code> 但要有失败处理</li>
<li>明确处理 <code>tryEmit()</code> 返回的 <code>false</code> 情况</li>
</ul>
<p>简单总结：<strong><code>emit()</code> 是安全的阻塞版本，<code>tryEmit()</code> 是非阻塞的尝试版本，可能失败丢数据。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[女友怒骂国内不能用Claude Code，于是我给她做了一个]]></title>    <link>https://juejin.cn/post/7587336857538265097</link>    <guid>https://juejin.cn/post/7587336857538265097</guid>    <pubDate>2025-12-25T03:28:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587336857538265097" data-draft-id="7587325326046101513" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="女友怒骂国内不能用Claude Code，于是我给她做了一个"/> <meta itemprop="keywords" content="AI编程,程序员,AIGC"/> <meta itemprop="datePublished" content="2025-12-25T03:28:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员鱼皮"/> <meta itemprop="url" content="https://juejin.cn/user/2444938365386621"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            女友怒骂国内不能用Claude Code，于是我给她做了一个
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2444938365386621/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员鱼皮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:28:51.000Z" title="Thu Dec 25 2025 03:28:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是程序员鱼皮。最近女友开始学习 AI 编程了（被我带的），她听说 Claude Code 这个 AI 编程工具很牛掰，结果试了下发现得要国外的 Claude 账号才能登陆。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/403e1821707e4762967e3d515d740be8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=142pPF4tMBCB37dNtQLUvGGqy78%3D" alt="" loading="lazy"/></p>
<p>然后她就骂骂咧咧地跟我吐槽。</p>
<p>展现男友力的时候到了，于是我开玩笑地说：别难过了，要不我给你做一个 Claude Code 算了？</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adf061f039274e61876a4ce4cdf86dd4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=i80pz0R2lyKiysoFzkkclox%2FUM4%3D" alt="" loading="lazy"/></p>
<p>结果，她当真了！</p>
<p>我 ↓</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9529994248f845b199f00a498f1d5727~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=9KfDHzcrv8SE8KQts25xz53RkV8%3D" alt="" loading="lazy"/></p>
<p>没办法，只能试一试了，毕竟谁希望圣诞节这两天让自家人难过呢？</p>
<p>正好这两天国产 AI 大模型 GLM-4.7 发布了，我看网上很多博主都在吹什么 “国内最强的编程模型”、“最强的开源模型”、“Claude 的最佳平替”，甚至说是超过了 GPT-5.2 和 Claude Sonnet 4.5。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f8a2302900ee4a4fa02364e504f918ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=5mp3WwdA1IWIcL6Rq%2BTtR4NZnt0%3D" alt="" loading="lazy"/></p>
<p>你说国产最强也就算了，超过 Claude 这我能信么？</p>
<p>那正好，我就尝试用 GLM-4.7 来做个自己的 AI 编程工具吧，对标 Claude Code 那种的，看看 GLM-4.7 到底几斤几两。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f10f802e5a74d7a84c2353ba62fc969~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=wfTHRwJNN3DN0tfRa9C7DY9Ei%2B8%3D" alt="" loading="lazy"/></p>
<p>接下来，就让我们一起 <strong>用 GLM-4.7 + Claude Code</strong> 开发一个 <strong>基于 GLM-4.7 的仿 Claude Code</strong> 的 AI 编程工具。</p>
<p>项目开始前，先起一个响当当的名字，就叫 <code>Yupi Code</code> 吧！</p>
<p>接下来，我们将遵循这套《鱼皮 AI Vibe Coding 开发仿 Claude Code 的 Yupi Code》流程，不写一行代码，一步一步把 “Claude Code” 做出来！</p>
<ul>
<li>环境准备 =&gt; 安装工具和配置环境，能够 Vibe Coding</li>
<li>技术调研 =&gt; 确认满足生成需求</li>
<li>设计开发 =&gt; 包括方案设计、生成代码、修复 Bug，得到 MVP 最小可行产品</li>
<li>版本控制 =&gt; 防止后续改动出问题</li>
<li>优化能力 =&gt; 支持更多对标 Claude Code 的功能，比如联网搜索、流式输出、深度思考等</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6a826d4ccfb407aad98f9405decbf85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=Ly9atXzS1TPpayL2tqYModXoNM0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">环境准备</h2>
<p>智谱的 GLM-4.7 兼容多款编码工具，除 Claude Code 外，还支持 Cursor、Cline 等主流编码工具，灵活适配多种开发场景。</p>
<p>给 Claude Code 接入 GLM 也很简单，1 分钟搞定。</p>
<p>首先打开终端，输入一行命令安装 Claude Code：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g @anthropic-ai/claude-code
</code></pre>
<p>然后执行 <code>claude</code> 命令打开程序，默认是需要登录 Claude 账号的，否则无法使用：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d06c5da11e93450f84658eac4d31893f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=MCG8of9Fpaj0T6WUH%2FlTzFsATWg%3D" alt="" loading="lazy"/></p>
<p>不过没关系，让我们把它背后的 AI 大模型换成国内的 GLM-4.7。首先进入 <code>{用户目录}/.claude</code> 目录，创建一个 <code>settings.json</code> 配置文件：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/825961b0404b47c2bc0cd35a903ce335~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=psFY%2B6a46y6z9LIX8EsidwhWUKo%3D" alt="" loading="lazy"/></p>
<p>然后修改配置文件中的内容如下，记得替换成你自己的 API Key：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2627396010d6428a86ad42adf5991b38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=wFKPnhz4mgQtmkGdxB0nwvSU9cw%3D" alt="" loading="lazy"/></p>
<p>API Key 直接到智谱开发平台获取即可：</p>
<p>指路：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbigmodel.cn%2F" target="_blank" title="https://bigmodel.cn/" ref="nofollow noopener noreferrer">bigmodel.cn/</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a92e06b01e07470f96b417848e982268~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=hMM5G18HFhJwn55HmwTBaH1oVgs%3D" alt="" loading="lazy"/></p>
<p>接下来就可以愉快地使用了~</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7db86ed5fd7414f8bfb223bcbefc1d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=QJcDsb4g4y%2BzGHu4lvXHFyYqyFE%3D" alt="" loading="lazy"/></p>
<p>除了这种方式外，官方文档还提供了更简单的方式，直接使用自动化助手，按照指引就能完成环境配置：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02eac37fcb40438e8020d6c53700aade~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=bHtgVZpPdSpjFhqk6GbxDP7gmKA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">技术调研</h2>
<p>如果要完全利用 AI 开发项目，有几个难点：</p>
<ol start="0">
<li>项目需要包含完整前后端，需要大模型有较强的 <strong>编码能力</strong></li>
<li>需要让后端项目对接 AI 大模型，每个大模型的接入和开发方式不同，需要让 AI <strong>读取文档</strong> 理解最新的开发方式</li>
<li>如果想要优化界面效果，还需要 <strong>图片理解能力</strong>，给 AI 一张图片就能让它还原</li>
</ol>
<p>在正式开发前，我们要确认 GLM-4.7 和 Claude Code 的配合能够满足这些能力要求。</p>
<p>根据智谱官方介绍，Claude Code 中内置了智谱专属的 MCP 工具，不需要开发者自己安装。包括 <strong>搜索和网页读取</strong> 能力、能够直接解析截图/设计稿/报错图的 <strong>视觉理解能力</strong>。</p>
<p>让我们依次测试一下，首先是网页搜索能力，紧跟时事：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe66c77d48954f97bb12fafc2d158935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=CaoeWTfnhznaEvonN%2F6exCh4KqU%3D" alt="" loading="lazy"/></p>
<p>测试网页读取能力，让它来读取我们编程导航网站的信息：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28ca33e0dc8b40e9a083248ec3800ccd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=49oPG8yaroiE418rKFqVXYDkAyk%3D" alt="" loading="lazy"/></p>
<p>测试图片理解能力，我给 AI 传了一张 “从夯到拉排行榜的背景图”：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db773f9bc7cf486b88e0064c459903ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=U3UdvPDR2MdmNUdNu9izviDTXDw%3D" alt="" loading="lazy"/></p>
<p>AI 的理解还是很准确的，具体文字也读取出来了。</p>
<p>OK，几个能力都满足要求，下面让我们进入方案设计和开发阶段。</p>
<h2 data-id="heading-2">设计开发</h2>
<p>先创建一个干净的项目目录 <code>yupi-code</code>，打开终端并进入该目录：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f071d1bea8194b3caf2e0ce84dbb466e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=D6rBBQ5Hn%2Baskiiy9mUjuAbEas0%3D" alt="" loading="lazy"/></p>
<p>然后输入提示词：</p>
<pre><code class="hljs language-css" lang="css">帮我开发一个类似 Claude <span class="hljs-selector-tag">Code</span> 的终端 AI 编程工具，能够使用 GLM-<span class="hljs-number">4.7</span> 模型帮用户回答问题和生成代码
</code></pre>
<p>一般来说，整个项目的第一句提示词是最重要的，如果我要开发一个复杂的商业项目，肯定会好好打磨一下这句提示词，少说写个几百字（之前看过我 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fcd7K9WQiOkP7AJglZ1b1Ng" target="_blank" title="https://mp.weixin.qq.com/s/cd7K9WQiOkP7AJglZ1b1Ng" ref="nofollow noopener noreferrer">AI 程序员技术练兵场项目</a> 的同学应该知道）。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfc0a92952c84b67ad80fe3dd9314865~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=jlCtPh7i0X1ztT6SXgwArnvlwPU%3D" alt="" loading="lazy"/></p>
<p>但测试 AI 模型时，我喜欢反其道而行之，站在大多数用户的角度，故意输入一句简单的提示词，看看 AI 能不能引导我来生成满足需求的项目。</p>
<p>果然，AI 判断这是一个复杂的项目，想要进入 <strong>计划模式</strong> —— 先明确需求、设计方案再开发。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2da1b2d39d284971a233f96b44acf68a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=%2BXyoQoUDsQ18%2BigLGMuNSZj4JZg%3D" alt="" loading="lazy"/></p>
<p>然后我们需要通过选择来明确需求，并让 AI 生成方案。</p>
<p>Claude Code 的交互做的还是不错的，先选择编程语言，建议老老实实选 AI 推荐的第一个：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ddd1677b3df64d878cccd4d89935d679~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=1U%2BHfya3WfkUJjkwG%2BLKCDaOkmU%3D" alt="" loading="lazy"/></p>
<p>接下来是选择项目要具有的功能。如果是以前，我可能会先让 AI 只开发基础对话功能，跑通流程后再添加其他功能。</p>
<p>但现在我对 AI 有了更多的信心，<strong>咱就把所有功能全都选上，干就完了！</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e7b05807f9746a38dc3a53980af0cc5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=3OXjv7QT%2B5GB9OVldBcblxOBu7M%3D" alt="" loading="lazy"/></p>
<p>其他设置就不多说了：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a3c3b32960d42ba9acc128d56e94b0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=S%2FRT54Tjuojd88ChByegRiOjE%2Bk%3D" alt="" loading="lazy"/></p>
<p>选择完成后，AI 给出了详细的实现计划，一定要仔细阅读：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7b291fa1a434c97a85bf5b3c2d26345~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=hiuUw8T9Q8laCoRXe93t4ngNenw%3D" alt="" loading="lazy"/></p>
<p>你可以直接执行，或者给 AI 进一步的指导。比如我让 AI 生成的应用去调用智谱 Coding Plan 套餐的 BASE URL，能节约一些成本，并且给 AI 提供了一个官方的 API 文档，便于 AI 生成准确的代码。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/247cdbdecdca405eb8571bc0e57d41b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=PykJSYiGIdYGRAZfEwqDTIsSEok%3D" alt="" loading="lazy"/></p>
<p>确认后开始执行，AI 会先调用内置的工具来搜索和解析文档：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb3066f442394b24b61c22b8cc4a15e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=z1KYOzo648KfGsa8YgB0jJk11po%3D" alt="" loading="lazy"/></p>
<p>然后 AI 列出了一个 Todo List，并且一步步生成代码和文档：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce264a6c600f4f33ab4cb0f73d9b10d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=eiKA2Df03v1Tu2PkD%2FU2UhH2%2F8k%3D" alt="" loading="lazy"/></p>
<p>这期间如果你发现有严重的问题，比如发现 AI 生成的代码已经完全偏离预期了，那么就尽早暂停或者人工输入提示词来引导 AI。如果发现 AI 只是有一小块代码生成的不对，我的建议是先忍着，反正最后 AI 大概率会自己发现问题并修复。</p>
<p>过了大概十几分钟后，AI 生成完成，还告诉了我使用方法：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a20a424d82e4a36be03dedd2ce0686f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=P8G0s6Wb88WyLOJ9J8a3UR0VMFM%3D" alt="" loading="lazy"/></p>
<p>可惜我根本懒得看，我直接把 API Key 交给 AI 帮我运行不就好了？</p>
<p>Vibe Coding 开发模式下，我多自己做一件事，都是对 AI 的不尊重。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94d4953816fe478ba863363c0623a784~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=U0UbiM8faK2xr%2F%2BFND%2FJTgbClWI%3D" alt="" loading="lazy"/></p>
<p>输入提示词：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">我的 API <span class="hljs-keyword">key</span> 是 xxxxxxx，请你帮我运行
</code></pre>
<p>然后，翻车了。。。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d58b4e956ff47d0b41931fb8a497d1d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=8w7AXXzQVBcPGClgWGXsT%2Fm%2FLYA%3D" alt="" loading="lazy"/></p>
<p>不慌，直接让 AI 自己检查并修复错误。而且为了使用方便，应该提供一个快速启动脚本，能够让我像运行 Claude Code 一样，一行命令启动 AI 编程工具。</p>
<p>提示词：</p>
<pre><code class="hljs language-arduino" lang="arduino">帮我检查并修复项目中的错误，并创建一个可以像 Claude 一样让用户在命令行输入 <span class="hljs-string">"yupicode"</span> 就能启动程序的快捷脚本
</code></pre>
<p>几分钟后，AI 修复完成，并且提供了一个 <code>yupicode</code> 脚本：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/480880fba25d4b11b9d5bc9a9fca89a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=PUC5MnBEvAhkfQa1L9gEhLQ89zI%3D" alt="" loading="lazy"/></p>
<p>我打开一个新的终端，然后运行 <code>yupicode</code> 脚本，尝试和 AI 对话：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6734c65be73442bb8d25c4d0867fac7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=BQ8Yoj8E%2F6nRemSiaBcVN5P4amg%3D" alt="" loading="lazy"/></p>
<p>你别说，效果还不错啊！</p>
<p>还像 Claude Code 一样提供了一些命令，比如清空对话历史、查看帮助之类的：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64b3f341f448478e9dcae2a69fe85bb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=2aliH3bIwtDVaM7QGZN8d0MMjtc%3D" alt="" loading="lazy"/></p>
<p>看到这里，我感觉项目已经基本可用了。建议给项目上个 Git 来版本控制，防止后面的改动出问题。</p>
<p>什么？你不知道 Git 是什么？</p>
<p>没关系，直接交给 AI 吧：</p>
<pre><code class="hljs">现在项目已经基本可用了，帮我提交一个 git 版本，防止后续改动出问题
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b742e95a06de4c049177651a571930d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=HxyrhXHiVxWtLYmThDFw5W%2B1uPE%3D" alt="" loading="lazy"/></p>
<p>测试下来，目前的 Yupi Code 还有一些不足之处，比如不支持搜索：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/607af21913214a658fd6f05a95226a5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=tJi8xegWNomYSZZDIYJv0NLsIhg%3D" alt="" loading="lazy"/></p>
<p>接下来就让我们优化项目，增加更多 Claude Code 支持的能力。</p>
<h2 data-id="heading-3">优化能力</h2>
<p>1）先来添加网络搜索能力，直接把智谱的官方文档给它丢进去。提示词如下：</p>
<pre><code class="hljs language-perl" lang="perl">现在好像不支持网络搜索，请参考
https:<span class="hljs-regexp">//d</span>ocs.bigmodel.cn/api-reference/%E5%B7%A5%E5%85%B7-api/%E7%BD%91%E7%BB%<span class="hljs-number">9</span>C%E6%9<span class="hljs-number">0</span>%<span class="hljs-number">9</span>C%E7%B4%A2
文档，增加网络搜索工具调用能力
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/157b1318bf014959bb29eaedb0a49ec8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=aHEfQHHG1HVHbspyJvfG%2Bhoc1AI%3D" alt="" loading="lazy"/></p>
<p>很快 AI 就添加了新功能，重新打开 yupicode 来验证下，正常生效了：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0365d092903c4922919a7d37ba32fea0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=yrBbqL84y0kPCz%2BFGZuIr%2F9fx60%3D" alt="" loading="lazy"/></p>
<p>2）下面再优化下 AI 回复的效果，目前是卡一会儿然后直接输出完整回答，需要调整为流式输出的打字机效果。</p>
<p>提示词：</p>
<pre><code class="hljs">我希望在等待 AI 回复时，有一个转圈的小图标；并且 AI 的回复可以实时流式输出
</code></pre>
<p>AI 很快就搞定了：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a6a4a2946224f09a95fef4a631afe98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=2%2B3IadOTnv%2FzD5yyrh%2FEJ8KVCQE%3D" alt="" loading="lazy"/></p>
<p>3）GLM-4.7 进一步强化了交错式思考能力，引入 <strong>保留式思考</strong> 和 <strong>轮级思考</strong>，让复杂任务执行更稳、更可控。我们也应该让 Yupi Code 输出模型的思考信息、工具调用信息等等，帮助用户了解情况。</p>
<p>输入提示词：</p>
<pre><code class="hljs">帮我输出模型思考的信息、以及工具调用信息，你可以通过官方文档来了解如何开发
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/109d59f5f3c64055b095e35f9a80d9a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=LZ2%2FdZoz08%2FM%2BpI1ItpRmTOra4U%3D" alt="" loading="lazy"/></p>
<p>测试一下优化后的效果，比如 “介绍一下鱼皮的 AI 导航网站”，能很清晰地看到思考过程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe75a74675804c92969459a845ca6d20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=3PBybmOrnPkMvFfsGCdQjrnyvu0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">大功告成</h2>
<p>到这里，仿照 Claude Code 开发的 Yupi Code 就已经完成了，让我们用它来开发个小网站试试。</p>
<p>比如来个动画学算法的 Demo，提示词：</p>
<pre><code class="hljs language-css" lang="css">帮我开发一个学习冒泡排序算法的动画网站，使用 <span class="hljs-selector-tag">Q</span> 版动漫的风格和吉伊卡哇感觉的配色
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/437bbf742d6f41219e59bc0fb6a08367~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=53gcwbKEuwuzeJ%2BtSgCoO8tfKjw%3D" alt="" loading="lazy"/></p>
<p>效果如图，画风还是不错的，但要是之后大模型能自动生成图片插画并添加到网站中，就更好了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f900c67f69945ca8f6e735dfc46ce0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=MRTDO1oSa8Jev58yaSsTAZG0X%2FI%3D" alt="" loading="lazy"/></p>
<p>再来开发个仿真的电子黑板，提示词：</p>
<pre><code class="hljs">帮我开发一个仿真的电子黑板，用户可以在上面画画并导出为图片
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cabbb5bd0144931bd80081cb1eca121~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=mBzflbJDACoMTUS794IWQJZYCHk%3D" alt="" loading="lazy"/></p>
<p>圣诞节了，鱼皮给大家画颗圣诞树，还附赠一个小礼物，这怎么能不算是程序员的浪漫呢~</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d97835113ac64d2a8be69f36e3113826~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=QDbR3VcuDBPqBtHDgOygIVOyBwo%3D" alt="" loading="lazy"/></p>
<hr/>
<p>OK，这就是我 <strong>利用国产的 AI 大模型 GLM-4.7 + Claude Code</strong> 开发出一个 <strong>基于 GLM-4.7 的 Yupi Code</strong> 的全过程了。</p>
<p>我自己体验下来，GLM-4.7 相比于之前的国内大模型，在处理复杂任务的稳定性上有进步，即使遇到问题也会自动修复，让最终生成的代码可运行。</p>
<p>而且 GLM-4.7 调用工具的能力也强化了，和 Claude Code 等 AI 编程工具打配合，直接内置了联网搜索、网页读取、解释图片等 AI 编程常用的能力，不需要自己再去找 MCP 来增强了。</p>
<p>不得不说，作为一直关注智谱 AI 的忠实开发者，真的很能感受到他们这几个月来在 AI 编程方向的努力，我相信大家也是有目共睹。</p>
<p>不过毕竟现在的 Yupi Code 是 AI 一把梭的，还有很多能优化完善的地方。如果后面有时间，大家也感兴趣的话，说不定我会好好打磨打磨这个工具把它开源出来。我的终极目标是，让基于 <strong>AI 大模型 GLM-4.7 + Claude Code</strong> 开发的基于 <strong>GLM-4.7 的 Yupi Code</strong> 编程工具，能够开发出一个基于 <strong>GLM-4.7 的</strong> 编程工具，比如 Yupi Son Code。我认为好的 AI 工具就是要能做到无限套娃，疯狂自举！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e176b292a14411e9c8943984cd0e455~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bG855qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767238131&amp;x-signature=uciHH69IM8Olfil1Xzso0twtUsg%3D" alt="" loading="lazy"/></p>
<p>听懂掌声~</p>
<h2 data-id="heading-5">更多</h2>
<p>💻 编程学习交流：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliyupi%2Fcode-nav" target="_blank" title="https://github.com/liyupi/code-nav" ref="nofollow noopener noreferrer">编程导航</a> 📃 简历快速制作：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliyupi%2Flaoyujianli" target="_blank" title="https://github.com/liyupi/laoyujianli" ref="nofollow noopener noreferrer">老鱼简历</a> ✏️ 面试刷题神器：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliyupi%2Fmianshiya" target="_blank" title="https://github.com/liyupi/mianshiya" ref="nofollow noopener noreferrer">面试鸭</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建 AI-Ready 软件：三层接口模型与智能调度架构]]></title>    <link>https://juejin.cn/post/7587342120021917747</link>    <guid>https://juejin.cn/post/7587342120021917747</guid>    <pubDate>2025-12-25T03:31:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587342120021917747" data-draft-id="7587325326046232585" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建 AI-Ready 软件：三层接口模型与智能调度架构"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2025-12-25T03:31:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="自由生长2024"/> <meta itemprop="url" content="https://juejin.cn/user/1591748569862670"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建 AI-Ready 软件：三层接口模型与智能调度架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748569862670/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    自由生长2024
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:31:48.000Z" title="Thu Dec 25 2025 03:31:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>摘要：本文提出了一个AI-READY的控制软件的模型，基于三层架构，语音或者文本接口，CoreAPI和GUI同步API，以低成本精准的操作方式去构建AI智能软件，而非全部基于图像识别识别去从操作软件。</p>
<h2 data-id="heading-0"><strong>构建 AI-Ready 软件：三位一体接口模型与智能调度架构</strong></h2>
<h3 data-id="heading-1">引言：当软件需要“听懂人话”</h3>
<p>在大模型（LLM）能力日益成熟的今天，“让 AI 操作软件”已不再是实验室里的奇想，而成为提升人机协同效率的关键路径。然而，许多尝试仍停留在两个极端：要么用计算机视觉模拟人类点击（脆弱且低效），要么直接暴露底层命令行（黑盒且难用）。</p>
<p>真正实用的方案，必须回答三个核心问题：</p>
<ol>
<li><strong>如何理解用户的自然语言指令？</strong></li>
<li><strong>如何可靠、高效地执行操作？</strong></li>
<li><strong>如何让用户“看得见、信得过”？</strong></li>
</ol>
<p>本文提出一种<strong>三位一体的智能软件接口模型</strong>，并在此基础上构建<strong>以调度中枢为核心的协同架构</strong>，为开发者提供一条清晰、可落地的“AI-Ready 软件”改造路径。</p>
<p>何谓AI-Ready？ <strong>AI-Ready</strong>这个术语，是近年来在软件工程、产品设计和企业数字化转型中逐渐流行起来的一个关键概念。它并不是一个随意的营销词汇，而是对一类<strong>具备与人工智能系统（尤其是大语言模型和智能体）高效、安全、可靠协同能力</strong>的软件或系统的精准描述。</p>
<p>技术史上，我们早已习惯用 “-Ready” 来描述系统是否适配新范式：</p>
<ul>
<li><strong>Mobile-Ready（移动就绪）</strong> ：指网站或应用能自适应手机屏幕、触控操作、低带宽等移动环境。</li>
<li><strong>Cloud-Ready（云就绪）</strong> ：指软件能弹性伸缩、无状态部署、通过 API 对接云服务。</li>
</ul>
<p>同理，<strong>AI-Ready = 软件已做好与 AI 智能体协同工作的准备。</strong></p>
<p>它意味着：<strong>软件不再只是一个孤立的工具，而是一个可被 AI 理解、调用、组合的“能力单元”</strong> 。类似于MCP工具，但是超越MCP作为获得信息的接口，而是直接上AI控制传统的软件。</p>
<p>一个 AI-Ready 的软件，必须满足以下至少三项基本条件：</p>
<ul>
<li><strong>可编程接口（Programmable）</strong>，提供清晰、稳定的 API 或脚本接口，允许外部程序（如 AI Agent）调用其功能。反例如只有图形界面，无任何命令行或 API 支持。</li>
<li><strong>语义可理解（Semantically Describable）</strong>，功能可通过自然语言描述（如“保存文件”“导出PDF”），且有对应的结构化元数据（如 OpenAPI）。反例如功能隐藏在多层菜单中，无法用一句话说清。</li>
<li><strong>状态可观测（Observable）</strong> 操作结果可被外部感知（如返回成功/失败、触发事件、更新状态），便于 AI 判断下一步。</li>
<li><strong>安全可控（Controllable）</strong> 支持权限控制、操作审计、用户授权，防止 AI 滥用。而过往的设计，一旦开放接口，就等于完全放权，无细粒度控制。</li>
</ul>
<hr/>
<h3 data-id="heading-2">一、三位一体接口模型：语音入口 + 核心操作 API + GUI 同步 API</h3>
<p>我们主张，任何一个希望支持 AI 控制的现代软件，都应同时提供以下三类接口，形成闭环：</p>
<h4 data-id="heading-3">1. 语音/自然语言入口（Voice/NL Gateway）</h4>
<p>这是用户与 AI 的交互起点。它不执行业务逻辑，只负责将模糊的人类语言转化为结构化指令。</p>
<ul>
<li><strong>输入</strong>：语音或文本（如“把这张图发给李工，并加个水印”）。</li>
<li><strong>处理</strong>：通过本地或云端大模型进行意图识别与参数抽取。</li>
<li><strong>输出</strong>：标准化的操作请求对象，例如：
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"action"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"send_with_watermark"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"li.gong@company.com"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"image_path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/tmp/photo.png"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
</ul>
<blockquote>
<p>✅ 关键原则：<strong>解耦理解与执行</strong>。NL 入口只做“翻译”，不做“决策”。</p>
</blockquote>
<h4 data-id="heading-4">2. 核心操作 API（Core Action API）</h4>
<p>这是软件真正的“肌肉”——所有业务逻辑的程序化入口。</p>
<ul>
<li>
<p><strong>设计要求</strong>：</p>
<ul>
<li><strong>原子性</strong>：每个 API 对应单一、明确的操作；</li>
<li><strong>无 GUI 依赖</strong>：即使界面未启动，也能运行（支持 headless 模式）；</li>
<li><strong>幂等性与错误反馈</strong>：便于 AI 进行重试或回滚。</li>
</ul>
</li>
<li>
<p><strong>接口形式灵活</strong>：</p>
<ul>
<li>函数调用（<code>save_project(path)</code>）</li>
<li>REST/gRPC（跨进程）</li>
<li>CLI（<code>myapp --save --path=xxx</code>）</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 这是系统<strong>可靠性与性能的基石</strong>。AI 应直接调用此层，而非模拟鼠标点击。</p>
</blockquote>
<h4 data-id="heading-5">3. GUI 同步 API（GUI Sync API）</h4>
<p>这是面向人类的“信任层”。它在核心操作完成后，主动触发界面更新，让用户感知到 AI 已完成任务。</p>
<ul>
<li><strong>典型行为</strong>：
<ul>
<li>仿人类的多步骤点击和页面切换动画，向用户清晰同步展示核心API操作过程</li>
<li>更新状态栏：“已保存至 ~/Documents”</li>
<li>高亮相关菜单项</li>
<li>播放微动效（如成功打钩动画）</li>
</ul>
</li>
<li><strong>关键特性</strong>：
<ul>
<li><strong>非阻塞</strong>：不影响核心逻辑执行；</li>
<li><strong>事件驱动</strong>：由 Core API 触发回调，而非轮询；</li>
<li><strong>可关闭</strong>：支持无头运行模式。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ GUI 同步不是为了 AI 看，而是为了<strong>人看</strong>——这是人机协同中不可忽视的心理契约。</p>
</blockquote>
<hr/>
<h3 data-id="heading-6">二、执行流程：从语音到反馈的完整闭环</h3>
<p>整个交互过程可分为三个阶段：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant User as 用户（语音）
    participant NL_Gateway as 语音/NL入口
    participant Core_API as 核心操作API
    participant GUI_Sync as GUI同步API
    participant Model as 大模型

    User-&gt;&gt;NL_Gateway: “导出当前图表为PDF”
    NL_Gateway-&gt;&gt;Model: 发送文本
    Model--&gt;&gt;NL_Gateway: 返回 {action: &amp;#34;export_pdf&amp;#34;, format: &amp;#34;A4&amp;#34;}
    NL_Gateway-&gt;&gt;Core_API: 调用 export_pdf(&amp;#34;A4&amp;#34;)
    Core_API-&gt;&gt;Core_API: 执行渲染与文件写入
    Core_API-&gt;&gt;GUI_Sync: 触发 on_export_success(path)
    GUI_Sync-&gt;&gt;GUI: 显示“PDF已生成”通知 + 自动打开文件夹
</code></pre>
<p>这一流程确保了：</p>
<ul>
<li><strong>高效</strong>：绕过 GUI 直接操作数据；</li>
<li><strong>可靠</strong>：核心逻辑可测试、可审计；</li>
<li><strong>可信</strong>：用户获得即时、直观的反馈。</li>
</ul>
<hr/>
<h3 data-id="heading-7">三、进阶架构：引入调度中枢（Orchestrator）</h3>
<p>当单应用的时候，我们直接把三层架构封装在同一个应用内，而当系统涉及多个应用（如导航 + 通讯 + 医疗影像）时，需引入<strong>核心调度软件</strong>作为统一协调者。</p>
<h4 data-id="heading-8">架构组成</h4>
<ul>
<li>
<p><strong>调度中枢（Orchestrator）</strong>：</p>
<ul>
<li>统一接收用户指令；</li>
<li>利用大模型进行任务规划；</li>
<li>维护应用注册表，动态路由 API 调用；</li>
<li>实现权限控制与操作审计。</li>
</ul>
</li>
<li>
<p><strong>应用软件（Agents）</strong>：</p>
<ul>
<li>向调度中枢注册自身能力（类似 OpenAPI）；</li>
<li>提供标准化 Core API 与 GUI Sync 接口；</li>
<li>可独立升级，不影响整体系统。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-9">架构优势</h4>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>解耦</strong></td><td>新增应用无需修改调度器</td></tr><tr><td><strong>安全</strong></td><td>所有操作经中枢授权，避免越权</td></tr><tr><td><strong>跨平台</strong></td><td>可调度桌面、Web、IoT 设备</td></tr><tr><td><strong>可观测</strong></td><td>全链路日志支持调试与回放</td></tr></tbody></table>
<blockquote>
<p>这一架构类似于操作系统的内核（调度中枢）与用户态程序（应用软件）的关系，是构建<strong>个人智能体操作系统</strong>的雏形。</p>
</blockquote>
<hr/>
<h3 data-id="heading-10">四、典型应用场景：当“手”不可用时，AI 成为延伸</h3>
<p>该模型的价值在以下高专注度、高风险场景中尤为突出：</p>
<ul>
<li><strong>智能驾驶</strong>：语音指令 → 调用导航 API → 中控屏同步刷新路线；</li>
<li><strong>外科手术</strong>：医生说“调出昨日 MRI” → AI 调用 PACS 系统 → 手术室大屏即时显示；</li>
<li><strong>深空探索</strong>：宇航员骨传导语音 → 控制机械臂采样 → HUD 显示操作状态。</li>
<li><strong>伴随监控</strong>：语音/动作指令 → 调用记录 API → 增加记录日志；</li>
</ul>
<blockquote>
<p>在这些场景中，<strong>手是稀缺资源，眼需专注主任务，嘴成为最自然的输入通道</strong>。三位一体模型完美契合这一需求。</p>
</blockquote>
<hr/>
<h3 data-id="heading-11">五、实践建议</h3>
<ol>
<li>
<p><strong>先重构 Core API</strong><br/>
将现有功能封装为无 GUI 依赖的函数，确保可脚本化调用。</p>
</li>
<li>
<p><strong>添加 GUI Sync 钩子</strong><br/>
在关键操作后触发事件（如 <code>on_save_complete</code>），由界面层监听并更新。</p>
</li>
<li>
<p><strong>接入 NL 入口</strong><br/>
使用 LangChain、Ollama 或自研 Agent 框架，将 Core API 注册为工具（Tools）。</p>
</li>
<li>
<p><strong>提供开关与日志</strong><br/>
允许用户关闭 AI 控制，并记录所有操作用于审计。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-12">结语：走向人机协同的新范式</h3>
<p>未来的软件，不应只是被动响应点击的工具，而应成为能理解意图、主动协作的智能伙伴。</p>
<p>通过<strong>三位一体接口模型</strong>（语音入口 + 核心 API + GUI 同步）与<strong>调度中枢架构</strong>，我们可以在不牺牲稳定性与安全性的前提下，赋予软件真正的“可对话性”与“可操作性”。</p>
<p>这不仅是技术升级，更是一次交互范式的跃迁：</p>
<blockquote>
<p><strong>AI 负责干活，GUI 负责沟通，人负责决策。</strong></p>
</blockquote>
<p>在驾驶舱、手术室、空间站——乃至每个人的日常工作中，这样的系统将成为人机共生的新基础设施。</p>
<hr/>
<p>如果你正在开发一款桌面或 Web 应用，并希望支持 AI 控制，不妨为你的软件加上这三层接口。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[淡泊名利与生活焦虑：写给 IT 人的一点个人思考]]></title>    <link>https://juejin.cn/post/7587334152870297640</link>    <guid>https://juejin.cn/post/7587334152870297640</guid>    <pubDate>2025-12-25T03:49:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587334152870297640" data-draft-id="7587342664077688847" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="淡泊名利与生活焦虑：写给 IT 人的一点个人思考"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2025-12-25T03:49:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程干货铺"/> <meta itemprop="url" content="https://juejin.cn/user/52383084474680"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            淡泊名利与生活焦虑：写给 IT 人的一点个人思考
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52383084474680/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程干货铺
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:49:48.000Z" title="Thu Dec 25 2025 03:49:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/62192a1cac294ea7b30f87a44c9c042c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767239388&amp;x-signature=QfZeayrE22VO7nSVUNnOlb2Pyek%3D" alt="ChatGPT Image 2025年12月25日 11_38_42.png" loading="lazy"/></p>
<p>这两年我经常会听到两句话。</p>
<p>一句是“要淡泊名利”，好像只要心态稳一点，生活就能轻很多。另一句是“别矫情，先把钱挣了”，好像只要足够努力，焦虑自然会消失。</p>
<p>但作为一个长期和 IT 圈节奏打交道的人，我越来越觉得：<strong>很多焦虑不是你想不开，而是你一直处在一个“随时会被淘汰”的叙事里。</strong><br/>
在这种叙事里谈“淡泊名利”，很容易变成一句站着说话不腰疼的安慰。</p>
<p>所以我想把“淡泊名利”换一种更接地气的说法：<br/>
<strong>不是不想要，而是别把人生全部押在一个指标上。</strong><br/>
这篇文章就当是我自己的整理，写给同样在 IT 行业里努力的人看。</p>
<hr/>
<h2 data-id="heading-0">1）IT 人的焦虑，很多时候不是“贪”，是“怕”</h2>
<p>我见过的多数工程师并不贪。他们要的很朴素：</p>
<ul>
<li>工资别太离谱地低</li>
<li>工作别随时裁员</li>
<li>房贷、家庭开销能覆盖</li>
<li>手里有点余钱，能面对突发情况</li>
<li>未来两三年不要完全黑箱</li>
</ul>
<p>这些都算不上名利心重，更多是<strong>安全感需求</strong>。</p>
<p>但 IT 行业有个很特别的地方：它会不断提醒你“你随时可能不值钱”。</p>
<ul>
<li>技术更新快，你的栈可能突然过时</li>
<li>公司业务说没就没，组织调整比你加班还快</li>
<li>你稍微松一点，身边的人就开始“卷新东西”</li>
<li>年龄、职级、绩效，会把你推到某个不得不追的轨道上</li>
</ul>
<p>所以很多人的焦虑并不是“我想赢”，而是“我不敢输”。<br/>
你不是想当人上人，你只是害怕自己突然失去选择权。</p>
<hr/>
<h2 data-id="heading-1">2）“淡泊名利”对 IT 人来说，更像是一种“降权”</h2>
<p>我以前也会对“淡泊名利”这个词有抵触。因为听起来像是：</p>
<ul>
<li>你不应该在乎工资</li>
<li>你不应该在乎晋升</li>
<li>你不应该在乎房子</li>
<li>你不应该在乎比较</li>
</ul>
<p>但你真在这个社会里生活，怎么可能不在乎？</p>
<p>后来我慢慢理解，“淡泊”最可行的版本，其实不是“清零”，而是<strong>降权</strong>：</p>
<ul>
<li>工资重要，但不是唯一的自我证明</li>
<li>晋升重要，但不代表我必须牺牲健康、关系、人格</li>
<li>买房重要，但不意味着我之后只能当一个“还贷机器”</li>
<li>外界评价重要，但不能成为我每天醒来的唯一驱动力</li>
</ul>
<p>更像是你在做系统设计：<br/>
名利是一个信号，但不能让它变成“单点故障”。<br/>
如果你的人生只靠一个指标驱动，那一旦指标崩了，你整个人也会崩。</p>
<hr/>
<h2 data-id="heading-2">3）IT 行业的“生活焦虑”，有个隐蔽的来源：比较机制</h2>
<p>IT 人特别容易掉进一种局面：<br/>
<strong>你永远知道有人比你更强、更快、更有钱。</strong></p>
<p>以前比较只发生在公司内部，现在比较发生在全网：</p>
<ul>
<li>别人 30 岁上架构师、年包翻倍</li>
<li>别人做副业、做课程、做开源、做自媒体</li>
<li>别人跳槽涨薪、拿期权、移民、买房</li>
<li>别人用 AI 生产力起飞，你还在写重复 CRUD</li>
</ul>
<p>你会发现比较是无穷无尽的，它不像一个项目能验收。<br/>
你今天赢一次，明天会看到更夸张的例子。<br/>
于是焦虑变成一种常态背景音：不是发生了什么，而是你一直觉得“会发生什么”。</p>
<p>这就是“生活焦虑”的核心：<strong>不是你现在过得差，而是你不确定你能不能一直稳下去。</strong></p>
<hr/>
<h2 data-id="heading-3">4）我觉得最难的点是：我们把“自我价值”外包给了结果</h2>
<p>很多 IT 人的自我价值感，来自可量化的东西：</p>
<ul>
<li>代码写得快、bug 少</li>
<li>绩效好、晋升快</li>
<li>工资高、title 大</li>
<li>项目上线、指标增长</li>
</ul>
<p>这些东西当然重要。但危险在于：<br/>
当你把自我价值完全绑定在这些结果上，你会变得越来越脆。</p>
<p>因为结果不完全由你控制：</p>
<ul>
<li>项目成败有运气和组织因素</li>
<li>晋升有名额、有政治、有时机</li>
<li>行业周期有起有落</li>
<li>你再强也可能遇到“业务不行”</li>
</ul>
<p>一旦你把价值交给外界裁决，你就会一直紧张：<br/>
我是不是还够用？我是不是还值钱？我是不是快被替代？</p>
<p>这就是为什么很多人“赚到了钱”依旧焦虑。<br/>
焦虑不是钱不够，而是你没有建立一个更稳定的价值来源。</p>
<hr/>
<h2 data-id="heading-4">5）那怎么做才不空洞？我觉得是做几件“小而稳”的事</h2>
<p>我不太信那种一把梭哈的“人生翻盘”。<br/>
IT 行业已经够高波动了，再把生活变成赌博，反而更耗。</p>
<p>我更认可一种“工程化”的思路：<br/>
<strong>不追求一次性改变命运，而是持续给系统加稳定性。</strong></p>
<h3 data-id="heading-5">（1）把成功定义成多指标，而不是年包一个数字</h3>
<p>除了薪资，你可以给自己加几个指标：</p>
<ul>
<li>身体状态是否可持续（睡眠、体力、精神）</li>
<li>现金流是否更稳（储蓄、负债结构）</li>
<li>技能是否更可迁移（换公司也能用）</li>
<li>时间是否有回收（不被无意义加班吞掉）</li>
<li>关系是否不崩（家庭、朋友、伴侣）</li>
</ul>
<p>你会发现一旦指标变多，你的心会更稳。<br/>
因为你不会被“单点失败”击穿。</p>
<h3 data-id="heading-6">（2）建立“最小安全垫”，它比心理安慰有用</h3>
<p>很多焦虑来自“怕突然出事”。</p>
<ul>
<li>手里有 3–6 个月的生活费储备（哪怕慢慢攒）</li>
<li>避免高息负债和冲动消费</li>
<li>给自己留一个随时能回到市场的“基础技能包”</li>
</ul>
<p>安全垫不是为了让你躺平，是为了让你在关键时刻不被迫做选择。</p>
<h3 data-id="heading-7">（3）技能上优先投“可迁移能力”</h3>
<p>我个人的排序大概是：</p>
<ul>
<li>表达与写作：能把问题讲清楚、把方案说明白</li>
<li>结构化思维：能拆解问题、复盘、沉淀</li>
<li>工程能力：能把东西做出来、跑起来、稳定起来</li>
<li>协作推进：能把事情推过去，而不是只写代码</li>
</ul>
<p>这些东西不会因为某个框架退潮而失效。</p>
<h3 data-id="heading-8">（4）减少“比较输入”，不是远离世界，是管理注意力</h3>
<p>我见过太多人不是被现实打垮，是被信息打垮。</p>
<p>你可以试试：</p>
<ul>
<li>把社媒当工具，不当生活</li>
<li>规定输入时间，别让信息随时插队</li>
<li>少刷成功学，多看可复用方法论</li>
</ul>
<p>注意力就是你的“能量预算”，IT 人尤其需要把它守住。</p>
<h3 data-id="heading-9">（5）每天留一点“最小自我空间”</h3>
<p>我觉得这件事特别关键。</p>
<p>哪怕每天 15 分钟：</p>
<ul>
<li>读一点</li>
<li>写几句</li>
<li>运动一下</li>
<li>学一个小点</li>
<li>做一件纯粹属于自己的事</li>
</ul>
<p>它的意义不是提升效率，而是告诉自己：<br/>
<strong>我不是一个只为绩效和账单活着的工具。</strong></p>
<hr/>
<h2 data-id="heading-10">6）最后：淡泊名利，不是躺平，而是别被牵着走</h2>
<p>我现在越来越觉得，淡泊名利对 IT 人来说，不是一种道德姿态，而是一种生存策略。</p>
<p>你可以努力、可以上进、可以追求更好。<br/>
但你不必把人生的全部意义押在“更高的工资、更大的 title、更强的比较”上。</p>
<p>行业会波动，技术会更新，组织会变动。<br/>
真正能让你不那么焦虑的，往往不是某次成功，而是你给自己搭了一个更稳定的系统：</p>
<ul>
<li>有一点安全垫</li>
<li>有一点可迁移能力</li>
<li>有一点生活的掌控感</li>
<li>有一点属于自己的空间</li>
</ul>
<p>如果你也正被焦虑追着跑，我想说一句更现实的话：<br/>
<strong>你不是“看不开”，你只是背负了太多不确定。</strong><br/>
而你能做的，是一点点把不确定变成可控，把名利从“主宰”变成“参考”。</p>
<p>这就已经很不容易了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一种基于 SQLite3 的半自动 C++ ORM 实现]]></title>    <link>https://juejin.cn/post/7587299443644645439</link>    <guid>https://juejin.cn/post/7587299443644645439</guid>    <pubDate>2025-12-25T00:59:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587299443644645439" data-draft-id="7587299443644629055" data-original-type="2" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一种基于 SQLite3 的半自动 C++ ORM 实现"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2025-12-25T00:59:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="charlee44"/> <meta itemprop="url" content="https://juejin.cn/user/1117549770846872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一种基于 SQLite3 的半自动 C++ ORM 实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1117549770846872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    charlee44
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T00:59:29.000Z" title="Thu Dec 25 2025 00:59:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 引言</h2>
<p>在现代软件开发中，尤其是在后端系统与数据库交互的场景下，对象关系映射（Object-Relational Mapping, ORM）已成为一种主流的设计范式。ORM 的核心思想是将程序中的对象模型与关系型数据库中的表结构进行映射，使开发者能够以面向对象的方式操作数据，而无需直接编写繁琐且易错的 SQL 语句。这种抽象不仅显著提升了开发效率，也增强了代码的可维护性与可移植性。</p>
<p>尽管在对性能或控制力要求极高的场景中原生 SQL 仍不可替代，但在大多数常规业务系统中，一个设计良好的 ORM 层能有效简化数据持久化的实现。</p>
<p>然而，由于 C/C++ 是底层系统级语言，缺乏运行时反射、泛型擦除等高级特性，要实现一个全自动、功能完备的 ORM 框架（如 Java 的 Hibernate 或 Python 的 SQLAlchemy）极为复杂，甚至得不偿失。因此，本文提出一种半自动的 ORM 风格封装：它借鉴一些典型 ORM 的设计思想，但不追求完全自动化，而是通过合理的模板、枚举和工具函数，在保持轻量与可控的前提下，提供接近 ORM 的开发体验。</p>
<h2 data-id="heading-1">2. 实现</h2>
<p>不必被 ORM 等看似复杂的概念所吓退。从底层视角出发，我们会发现：许多高级设计范式本质上是对底层重复、分散或冗余代码的封装与抽象——比如为了解决 SQL 模板重复、数据映射逻辑不内聚等问题。</p>
<p>以常见的业务开发为例，我们经常需要对数据库执行 CRUD 操作（即 Create 创建、Retrieve 查询、Update 更新、Delete 删除）。这些操作在不同数据表上反复出现，代码结构高度相似，却往往被一遍遍手写。那么，是否有可能将这些重复逻辑提炼出来，仅通过统一的四个接口，就能满足所有实体的 CRUD 需求？这正是轻量级 ORM 尝试回答的问题。</p>
<h3 data-id="heading-2">2.1 字段值</h3>
<p>先来看看以下代码封装的四个 CRUD 接口：<code>InsertRow</code>、<code>DeleteRow</code>、<code>UpdateRow</code> 以及 <code>QueryRows</code>。</p>
<p><strong>Sqlite3Crud.h</strong>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"TableName.h"</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Util/Statement.hpp"</span></span>&#13;
&#13;
<span class="hljs-keyword">namespace</span> Persistence {&#13;
&#13;
<span class="hljs-comment">/// @brief Sqlite3数据库封装类</span>&#13;
<span class="hljs-keyword">namespace</span> Sqlite3Crud {&#13;
&#13;
<span class="hljs-keyword">using</span> TableValue = std::variant&lt;std::monostate, std::string, <span class="hljs-type">int64_t</span>&gt;;  <span class="hljs-comment">//表的值</span>&#13;
&#13;
<span class="hljs-comment">//数据库表插入记录的抽象方法</span>&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;params)</span></span>;&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt; &amp;fieldNames,&#13;
            <span class="hljs-type">const</span> std::vector&lt;Sqlite3Crud::TableValue&gt; &amp;fieldValues)</span> </span>{&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">InsertRow</span>(Util::Statement::<span class="hljs-built_in">Insert</span>(tableName, fieldNames).<span class="hljs-built_in">c_str</span>(),&#13;
                   fieldValues);&#13;
}&#13;
&#13;
<span class="hljs-comment">//数据库表删除记录的抽象方法</span>&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeleteRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> TableValue &amp;bindParam)</span></span>;&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Delete</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> Field &amp;fieldName,&#13;
            <span class="hljs-type">const</span> TableValue &amp;bindParam)</span> </span>{&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeleteRow</span>(Util::Statement::<span class="hljs-built_in">Delete</span>(tableName, fieldName).<span class="hljs-built_in">c_str</span>(),&#13;
                   bindParam);&#13;
}&#13;
&#13;
<span class="hljs-comment">//数据库表更新记录的抽象方法</span>&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpdateRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams)</span></span>;&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt; &amp;fieldNames,&#13;
            <span class="hljs-type">const</span> std::vector&lt;Sqlite3Crud::TableValue&gt; &amp;fieldValues)</span> </span>{&#13;
  <span class="hljs-keyword">return</span> Sqlite3Crud::<span class="hljs-built_in">UpdateRow</span>(&#13;
      Util::Statement::<span class="hljs-built_in">Update</span>(tableName, fieldNames).<span class="hljs-built_in">c_str</span>(), fieldValues);&#13;
}&#13;
&#13;
<span class="hljs-comment">//数据库表查询记录的抽象方法</span>&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueryRows</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, std::vector&lt;TableValue&gt; &amp;result,&#13;
               <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams = {})</span></span>;&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Query</span><span class="hljs-params">(&#13;
    TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt; &amp;fieldNames,&#13;
    std::vector&lt;TableValue&gt; &amp;result, <span class="hljs-type">const</span> std::vector&lt;Field&gt; &amp;whereFields = {},&#13;
    <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;whereBindParams = {},&#13;
    std::optional&lt;Field&gt; orderByField = std::<span class="hljs-literal">nullopt</span>,&#13;
    std::optional&lt;Util::Statement::OrderByValue&gt; orderByValue = std::<span class="hljs-literal">nullopt</span>)</span> </span>{&#13;
  <span class="hljs-keyword">if</span> (whereFields.<span class="hljs-built_in">size</span>() != whereBindParams.<span class="hljs-built_in">size</span>()) {&#13;
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"whereFields 和 whereBindParams 数量不匹配！"</span>);&#13;
  }&#13;
  <span class="hljs-type">const</span> std::string &amp;statement = Util::Statement::<span class="hljs-built_in">Query</span>(&#13;
      tableName, fieldNames, whereFields, orderByField, orderByValue);&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">QueryRows</span>(statement.<span class="hljs-built_in">c_str</span>(), result, whereBindParams);&#13;
}&#13;
&#13;
};  <span class="hljs-comment">// namespace Sqlite3Crud</span>&#13;
&#13;
}  <span class="hljs-comment">// namespace Persistence</span>
</code></pre>
<p><strong>Sqlite3Crud.cpp</strong>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Sqlite3Crud.h"</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sqlite3.h&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Bootstrap/App.h"</span></span>&#13;
&#13;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;&#13;
&#13;
<span class="hljs-keyword">namespace</span> Persistence {&#13;
&#13;
<span class="hljs-keyword">namespace</span> Sqlite3Crud {&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;params)</span> </span>{&#13;
  sqlite3 *db = App::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Db</span>();&#13;
&#13;
  <span class="hljs-comment">// 准备 SQL 语句</span>&#13;
  sqlite3_stmt *stmt;&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sql, <span class="hljs-number">-1</span>, &amp;stmt, <span class="hljs-literal">nullptr</span>) != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"SQL准备语句失败："</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 绑定参数</span>&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> si = <span class="hljs-number">0</span>; si &lt; params.<span class="hljs-built_in">size</span>(); ++si) {&#13;
    <span class="hljs-type">int</span> bindId = (<span class="hljs-type">int</span>)(si + <span class="hljs-number">1</span>);&#13;
&#13;
    <span class="hljs-comment">// 使用 std::holds_alternative 检查当前是否存储了指定类型的值</span>&#13;
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::string&gt;(params[si])) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(params[si]);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_text</span>(stmt, bindId, param.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">-1</span>, SQLITE_STATIC) !=&#13;
          SQLITE_OK) {&#13;
        std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"绑定错误: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
                  &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int64_t</span>&gt;(params[si])) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int64_t</span>&gt;(params[si]);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_int64</span>(stmt, bindId, param) != SQLITE_OK) {&#13;
        std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"绑定错误: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
                  &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 执行插入语句</span>&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_step</span>(stmt) != SQLITE_DONE) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"执行失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmt);  <span class="hljs-comment">// 释放SQL语句对象</span>&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeleteRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> TableValue &amp;bindParam)</span> </span>{&#13;
  sqlite3 *db = App::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Db</span>();&#13;
&#13;
  <span class="hljs-comment">// 准备 SQL 语句</span>&#13;
  sqlite3_stmt *stmt;&#13;
  <span class="hljs-type">int</span> exit = <span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sql, <span class="hljs-number">-1</span>, &amp;stmt, <span class="hljs-literal">nullptr</span>);&#13;
  <span class="hljs-keyword">if</span> (exit != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"SQL准备语句失败："</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 绑定参数</span>&#13;
  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::string&gt;(bindParam)) {&#13;
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(bindParam);&#13;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_text</span>(stmt, <span class="hljs-number">1</span>, param.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">-1</span>, SQLITE_STATIC) !=&#13;
        SQLITE_OK) {&#13;
      std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"绑定错误: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
                &lt;&lt; std::endl;&#13;
      <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
    }&#13;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam)) {&#13;
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam);&#13;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_int64</span>(stmt, <span class="hljs-number">1</span>, param) != SQLITE_OK) {&#13;
      std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"绑定错误: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
                &lt;&lt; std::endl;&#13;
      <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 执行语句</span>&#13;
  exit = <span class="hljs-built_in">sqlite3_step</span>(stmt);&#13;
  <span class="hljs-keyword">if</span> (exit != SQLITE_DONE) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"执行失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmt);  <span class="hljs-comment">// 释放SQL语句对象</span>&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}&#13;
&#13;
<span class="hljs-comment">// 从 bindParams 绑定所有参数</span>&#13;
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">BindParams2Stmt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams,&#13;
                            sqlite3_stmt *stmt, sqlite3 *db)</span> </span>{&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> si = <span class="hljs-number">0</span>; si &lt; bindParams.<span class="hljs-built_in">size</span>(); ++si) {&#13;
    <span class="hljs-type">int</span> bindIndex = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(si + <span class="hljs-number">1</span>);  <span class="hljs-comment">// SQLite 参数从 1 开始</span>&#13;
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;bindParam = bindParams[si];&#13;
&#13;
    <span class="hljs-comment">// 使用 std::holds_alternative 检查当前是否存储了指定类型的值</span>&#13;
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::string&gt;(bindParam)) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(bindParam);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_text</span>(stmt, bindIndex, param.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">-1</span>,&#13;
                            SQLITE_STATIC) != SQLITE_OK) {&#13;
        std::cerr &lt;&lt; <span class="hljs-string">"绑定错误: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam)) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_int64</span>(stmt, bindIndex, param) != SQLITE_OK) {&#13;
        std::cerr &lt;&lt; <span class="hljs-string">"绑定错误: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      std::cerr &lt;&lt; <span class="hljs-string">"不支持的绑定参数类型"</span> &lt;&lt; std::endl;&#13;
      <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpdateRow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams)</span> </span>{&#13;
  sqlite3 *db = App::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Db</span>();&#13;
&#13;
  <span class="hljs-comment">// 准备SQL语句</span>&#13;
  sqlite3_stmt *stmt;&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sql, <span class="hljs-number">-1</span>, &amp;stmt, <span class="hljs-literal">nullptr</span>) != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"SQL准备语句失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">BindParams2Stmt</span>(bindParams, stmt, db)) {&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 执行语句</span>&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_step</span>(stmt) != SQLITE_DONE) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"执行失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 清理</span>&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueryRows</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sql, std::vector&lt;TableValue&gt; &amp;result,&#13;
               <span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams)</span> </span>{&#13;
  sqlite3 *db = App::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">Db</span>();&#13;
&#13;
  <span class="hljs-comment">// 准备SQL语句</span>&#13;
  sqlite3_stmt *stmt;&#13;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sql, <span class="hljs-number">-1</span>, &amp;stmt, <span class="hljs-literal">nullptr</span>) != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"SQL准备语句失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
              &lt;&lt; std::endl;&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">BindParams2Stmt</span>(bindParams, stmt, db)) {&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 执行SQL语句并存储结果</span>&#13;
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sqlite3_step</span>(stmt) == SQLITE_ROW) {&#13;
    <span class="hljs-type">int</span> colCount = <span class="hljs-built_in">sqlite3_column_count</span>(stmt);&#13;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; colCount; ++i) {&#13;
      <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">sqlite3_column_type</span>(stmt, i)) {&#13;
        <span class="hljs-keyword">case</span> SQLITE_TEXT: {&#13;
          result.<span class="hljs-built_in">emplace_back</span>(&#13;
              <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(<span class="hljs-built_in">sqlite3_column_text</span>(stmt, i)));&#13;
          <span class="hljs-keyword">break</span>;&#13;
        }&#13;
        <span class="hljs-keyword">case</span> SQLITE_INTEGER: {&#13;
          result.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">sqlite3_column_int64</span>(stmt, i));&#13;
          <span class="hljs-keyword">break</span>;&#13;
        }&#13;
        <span class="hljs-keyword">case</span> SQLITE_NULL: {&#13;
          result.<span class="hljs-built_in">emplace_back</span>(std::monostate{});&#13;
          <span class="hljs-keyword">break</span>;&#13;
        }&#13;
        <span class="hljs-keyword">case</span> SQLITE_FLOAT:&#13;
        <span class="hljs-keyword">case</span> SQLITE_BLOB:&#13;
        <span class="hljs-keyword">default</span>: {&#13;
          std::cerr &lt;&lt; (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(<span class="hljs-string">u8"执行失败: "</span>) &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db)&#13;
                    &lt;&lt; std::endl;&#13;
          <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmt);  <span class="hljs-comment">// 释放SQL语句对象</span>&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}&#13;
&#13;
}  <span class="hljs-comment">// namespace Sqlite3Crud</span>&#13;
&#13;
}  <span class="hljs-comment">// namespace Persistence</span>
</code></pre>
<p>Sqlite3 的 CURD 的操作都差不多，都是编译 statement ，然后绑定参数，最后执行。但是要实现统一的 CURD 接口的封装，一个关键的地方就在于传参表格字段值类型。如果是 JavaScript、Python 这样的编程语言好办，它们是弱类型语言，完全可以支持。作为强类型语言，C++也有办法，那就是使用 C++17 提供的 <code>std::variant</code>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">using</span> TableValue = std::variant&lt;std::monostate, std::string, <span class="hljs-type">int64_t</span>&gt;;  <span class="hljs-comment">//表的值</span>
</code></pre>
<p>这里定义了一个类型别名 <code>TableValue</code>，它是一个 std::variant 类型，可以持有以下三种类型的值：<code>std::monostate</code> 、<code>std::string</code> 和 <code>int64_t</code> 。其中 <code>std::monostate</code> 是一个空类型（empty struct），常用于 std::variant 中表示“无值”或“空状态”。当需要绑定参数到 SQL 语句时，再将 <code>TableValue</code> 拆箱成具体的值：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 从 bindParams 绑定所有参数</span>&#13;
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">BindParams2Stmt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;TableValue&gt; &amp;bindParams,&#13;
                            sqlite3_stmt *stmt, sqlite3 *db)</span> </span>{&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> si = <span class="hljs-number">0</span>; si &lt; bindParams.<span class="hljs-built_in">size</span>(); ++si) {&#13;
    <span class="hljs-type">int</span> bindIndex = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(si + <span class="hljs-number">1</span>);  <span class="hljs-comment">// SQLite 参数从 1 开始</span>&#13;
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;bindParam = bindParams[si];&#13;
&#13;
    <span class="hljs-comment">// 使用 std::holds_alternative 检查当前是否存储了指定类型的值</span>&#13;
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::string&gt;(bindParam)) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(bindParam);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_text</span>(stmt, bindIndex, param.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">-1</span>,&#13;
                            SQLITE_STATIC) != SQLITE_OK) {&#13;
        std::cerr &lt;&lt; <span class="hljs-string">"绑定错误: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam)) {&#13;
      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;param = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int64_t</span>&gt;(bindParam);&#13;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqlite3_bind_int64</span>(stmt, bindIndex, param) != SQLITE_OK) {&#13;
        std::cerr &lt;&lt; <span class="hljs-string">"绑定错误: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;&#13;
        <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
      }&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      std::cerr &lt;&lt; <span class="hljs-string">"不支持的绑定参数类型"</span> &lt;&lt; std::endl;&#13;
      <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#13;
}
</code></pre>
<h3 data-id="heading-3">2.2 字段名</h3>
<p>仔细观察 <code>InsertRow</code>、<code>DeleteRow</code>、<code>UpdateRow</code> 以及 <code>QueryRows</code> 的实现，虽然它们通过 <code>TableValue</code> 解决了字段值类型多样的传参问题，但仍然要求调用者传入完整的 SQL 字符串。这意味着业务代码仍需手动拼接表名、字段名和占位符，不仅重复繁琐，还容易引入语法错误或 SQL 注入风险（尽管使用参数绑定可缓解后者）。</p>
<p>更重要的是，表结构本身是静态的、已知的：比如一篇博客文章对应 posts 表，包含 id、title、content 等字段。如果每次插入都要写 "INSERT INTO posts (title, content) VALUES (?, ?)"，那么当表结构变更时，所有相关 SQL 字符串都需同步修改，违反了“一处修改，处处生效”的工程原则。</p>
<p>因此，理想的做法是：让 CRUD 接口接受高层语义信息（如表名、字段名列表），由底层自动构造对应的 SQL 语句。这样，业务层只需关注“我要插入哪些字段”，而无需关心具体的 SQL 语法细节。这不仅提升了开发效率，也增强了系统的内聚性与可维护性。</p>
<p>基于 ORM 的思想，一个简单的想法是可以将数据库表映射成类/结构体对象，通过反射特性获取类/结构体对象的成员信息，进而知道数据库表名和字段名，实现自动构造语句。如果是 Java 或者 C# 这样的高级托管语言就没有问题，因为它们支持反射（Reflection）特性。对于 C++ ，可以引入 magic_enum 库，将枚举值（enum）转换为对应的字符串名称。参看工具接口Util::Statement 的实现：</p>
<p><strong>Statement.hpp</strong>:</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;format&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;magic_enum/magic_enum.hpp&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Persistence/TableName.h"</span></span>&#13;
&#13;
<span class="hljs-keyword">namespace</span> Util {&#13;
&#13;
<span class="hljs-keyword">namespace</span> Statement {&#13;
&#13;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Persistence;&#13;
&#13;
<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">OrderByValue</span> { ASC, DESC };&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function">std::string <span class="hljs-title">Insert</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt;&amp; fieldNames)</span> </span>{&#13;
  <span class="hljs-type">size_t</span> num = fieldNames.<span class="hljs-built_in">size</span>();&#13;
  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) {&#13;
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"插入数据缺少插入项！"</span>);&#13;
  }&#13;
&#13;
  std::string columnList = <span class="hljs-string">"("</span>;           <span class="hljs-comment">//列列表</span>&#13;
  std::string valuesClause = <span class="hljs-string">"VALUES ("</span>;  <span class="hljs-comment">// values子句</span>&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) {&#13;
    columnList += magic_enum::<span class="hljs-built_in">enum_name</span>(fieldNames.<span class="hljs-built_in">at</span>(i));&#13;
    valuesClause += <span class="hljs-string">"?"</span>;&#13;
    <span class="hljs-keyword">if</span> (i != num - <span class="hljs-number">1</span>) {&#13;
      columnList += <span class="hljs-string">", "</span>;&#13;
      valuesClause += <span class="hljs-string">", "</span>;&#13;
    }&#13;
  }&#13;
  columnList += <span class="hljs-string">")"</span>;&#13;
  valuesClause += <span class="hljs-string">")"</span>;&#13;
&#13;
  <span class="hljs-comment">//插入子句</span>&#13;
  std::string insertClause = std::format(&#13;
      <span class="hljs-string">"INSERT INTO {} {}"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(tableName), columnList);&#13;
&#13;
  <span class="hljs-keyword">return</span> std::format(<span class="hljs-string">"{} {};"</span>, insertClause, valuesClause);&#13;
}&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function">std::string <span class="hljs-title">Delete</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> Field&amp; fieldName)</span> </span>{&#13;
  std::string deleteClause = <span class="hljs-string">"DELETE"</span>;&#13;
&#13;
  std::string fromClause =&#13;
      std::format(<span class="hljs-string">"FROM {}"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(tableName));&#13;
&#13;
  std::string whereClause =&#13;
      std::format(<span class="hljs-string">"WHERE {} = ?"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(fieldName));&#13;
&#13;
  <span class="hljs-keyword">return</span> std::format(<span class="hljs-string">"{} {} {};"</span>, deleteClause, fromClause, whereClause);&#13;
}&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function">std::string <span class="hljs-title">Update</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt;&amp; fieldNames)</span> </span>{&#13;
  <span class="hljs-type">size_t</span> num = fieldNames.<span class="hljs-built_in">size</span>();&#13;
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {&#13;
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"更新数据至少要两列值！"</span>);&#13;
  }&#13;
&#13;
  std::string updateClause =&#13;
      std::format(<span class="hljs-string">"UPDATE {}"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(tableName));&#13;
&#13;
  std::string setClause = <span class="hljs-string">"SET "</span>;&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num - <span class="hljs-number">1</span>; ++i) {&#13;
    setClause += magic_enum::<span class="hljs-built_in">enum_name</span>(fieldNames[i]);&#13;
    setClause += <span class="hljs-string">" = ?"</span>;&#13;
    <span class="hljs-keyword">if</span> (i != num - <span class="hljs-number">2</span>) {&#13;
      setClause += <span class="hljs-string">", "</span>;&#13;
    }&#13;
  }&#13;
&#13;
  std::string whereClause =&#13;
      std::format(<span class="hljs-string">"WHERE {} = ?"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(fieldNames[num - <span class="hljs-number">1</span>]));&#13;
&#13;
  <span class="hljs-keyword">return</span> std::format(<span class="hljs-string">"{} {} {};"</span>, updateClause, setClause, whereClause);&#13;
}&#13;
&#13;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Field&gt;&#13;
<span class="hljs-function">std::string <span class="hljs-title">Query</span><span class="hljs-params">(TableName tableName, <span class="hljs-type">const</span> std::vector&lt;Field&gt;&amp; fieldNames,&#13;
                  <span class="hljs-type">const</span> std::vector&lt;Field&gt;&amp; whereFields = {},&#13;
                  std::optional&lt;Field&gt; orderByField = std::<span class="hljs-literal">nullopt</span>,&#13;
                  std::optional&lt;OrderByValue&gt; orderByValue = std::<span class="hljs-literal">nullopt</span>)</span> </span>{&#13;
  <span class="hljs-keyword">if</span> (fieldNames.<span class="hljs-built_in">empty</span>()) {&#13;
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"query sql fieldNames must not be empty"</span>);&#13;
  }&#13;
&#13;
  <span class="hljs-type">size_t</span> num = fieldNames.<span class="hljs-built_in">size</span>();&#13;
&#13;
  <span class="hljs-comment">//</span>&#13;
  std::string columnList;  <span class="hljs-comment">//列列表</span>&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) {&#13;
    columnList += magic_enum::<span class="hljs-built_in">enum_name</span>(fieldNames.<span class="hljs-built_in">at</span>(i));&#13;
    <span class="hljs-keyword">if</span> (i != num - <span class="hljs-number">1</span>) {&#13;
      columnList += <span class="hljs-string">", "</span>;&#13;
    }&#13;
  }&#13;
  std::string selectClause = std::format(<span class="hljs-string">"SELECT {}"</span>, columnList);&#13;
&#13;
  std::string fromClause =&#13;
      std::format(<span class="hljs-string">"FROM {}"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(tableName));&#13;
  std::string statement = std::format(<span class="hljs-string">"{} {}"</span>, selectClause, fromClause);&#13;
&#13;
  <span class="hljs-comment">// 添加 WHERE 子句（支持多个条件）</span>&#13;
  <span class="hljs-keyword">if</span> (!whereFields.<span class="hljs-built_in">empty</span>()) {&#13;
    std::string whereClause = <span class="hljs-string">"WHERE "</span>;&#13;
&#13;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; whereFields.<span class="hljs-built_in">size</span>(); ++i) {&#13;
      whereClause += magic_enum::<span class="hljs-built_in">enum_name</span>(whereFields[i]);&#13;
      whereClause += <span class="hljs-string">" = ?"</span>;&#13;
      <span class="hljs-keyword">if</span> (i != whereFields.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {&#13;
        whereClause += <span class="hljs-string">" AND "</span>;&#13;
      }&#13;
    }&#13;
    statement = std::format(<span class="hljs-string">"{} {}"</span>, statement, whereClause);&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">if</span> (orderByField.<span class="hljs-built_in">has_value</span>() &amp;&amp; orderByValue.<span class="hljs-built_in">has_value</span>()) {&#13;
    std::string orderByClause = std::format(&#13;
        <span class="hljs-string">"ORDER BY {} {}"</span>, magic_enum::<span class="hljs-built_in">enum_name</span>(orderByField.<span class="hljs-built_in">value</span>()),&#13;
        magic_enum::<span class="hljs-built_in">enum_name</span>(orderByValue.<span class="hljs-built_in">value</span>()));&#13;
    statement = std::format(<span class="hljs-string">"{} {}"</span>, statement, orderByClause);&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">return</span> std::format(<span class="hljs-string">"{};"</span>, statement);&#13;
}&#13;
&#13;
}  <span class="hljs-comment">// namespace Statement</span>&#13;
&#13;
}  <span class="hljs-comment">// namespace Util</span>
</code></pre>
<p>利用模板特性，接口<code>Insert</code>、<code>Delete</code>、<code>Update</code>、<code>Query</code>可以接受不同的数据库表的枚举类映射对象。例如博文表<code>TableBlogsField.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>&#13;
&#13;
<span class="hljs-keyword">namespace</span> Persistence {&#13;
&#13;
<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">TableBlogsField</span> {&#13;
  id,&#13;
  title,&#13;
  content,&#13;
  summary,&#13;
  cover_image_url,&#13;
  created_at,&#13;
  updated_at,&#13;
  is_draft&#13;
};&#13;
&#13;
}
</code></pre>
<p>分类专栏表<code>TableCategoriesField.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>&#13;
&#13;
<span class="hljs-keyword">namespace</span> Persistence {&#13;
&#13;
<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">TableCategoriesField</span> {&#13;
  id,&#13;
  title,&#13;
  description,&#13;
  image_url,&#13;
  parent_id,&#13;
  created_at&#13;
};&#13;
&#13;
}
</code></pre>
<p><code>TableBlogsField</code> 、<code>TableCategoriesField</code> 会在 <code>Insert</code>、<code>Delete</code>、<code>Update</code>、<code>Query</code> 的模板 <code>template &lt;typename Field&gt;</code> 中展开成字符串，实现 SQL 字符串的拼接；并被 <code>Sqlite3Crud</code> 的 <code>Insert</code>、<code>Delete</code>、<code>Update</code>、<code>Query</code> 所调用，形成更加通用的接口。这样，业务代码只需操作语义清晰的枚举字段，而无需硬编码任何 SQL 字符串。这种基于枚举与模板的“编译期反射”机制，在 C++ 缺乏原生反射能力的前提下，提供了一种轻量、类型安全且易于维护的 ORM 风格接口。</p>
<h3 data-id="heading-4">2.3 调用</h3>
<p>当然，在 <code>Sqlite3Crud</code> 的 <code>Insert</code>、<code>Delete</code>、<code>Update</code>、<code>Query</code> 接口中，还需要知道数据库名，这也是枚举类<code>TableName.h</code>：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>&#13;
&#13;
<span class="hljs-keyword">namespace</span> Persistence {&#13;
&#13;
<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">TableName</span> {&#13;
  users,&#13;
  tags,&#13;
  blog_tags,&#13;
  categories,&#13;
  category_blog,&#13;
  blog_views,&#13;
  blog_likes,&#13;
  friend_links,&#13;
  blogs&#13;
};&#13;
&#13;
}
</code></pre>
<p>如果是从博文表中查询数据：</p>
<pre><code class="hljs language-cpp" lang="cpp">vector&lt;Sqlite3Crud::TableValue&gt; result;&#13;
<span class="hljs-keyword">if</span> (!Sqlite3Crud::<span class="hljs-built_in">Query</span>&lt;TableBlogsField&gt;(&#13;
        TableName::blogs,&#13;
        {TableBlogsField::title, TableBlogsField::content,&#13;
        TableBlogsField::summary, TableBlogsField::created_at,&#13;
        TableBlogsField::updated_at},&#13;
        result, {TableBlogsField::is_draft, TableBlogsField::id},&#13;
        {isDraft, blogId})) {&#13;
<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
}&#13;
&#13;
<span class="hljs-keyword">auto</span> &amp;blogMeta = blogData.blogMeta;&#13;
blogMeta.id = blogId;&#13;
blogMeta.title = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(result.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)));&#13;
blogData.content = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(result.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>)));&#13;
blogMeta.summary = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(result.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>)));&#13;
blogMeta.createdTime = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(result.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>)));&#13;
blogMeta.updatedTime = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(result.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>)));
</code></pre>
<p>创建博文插入到博文表中：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> &amp;blogMeta = blogData.blogMeta;&#13;
blogMeta.updatedTime = blogMeta.createdTime;&#13;
&#13;
<span class="hljs-comment">// 插入博文表</span>&#13;
Sqlite3Crud::<span class="hljs-built_in">Insert</span>&lt;TableBlogsField&gt;(&#13;
    TableName::blogs,&#13;
    {TableBlogsField::id, TableBlogsField::title, TableBlogsField::content,&#13;
    TableBlogsField::summary, TableBlogsField::created_at,&#13;
    TableBlogsField::updated_at, TableBlogsField::cover_image_url,&#13;
    TableBlogsField::is_draft},&#13;
    {blogId, std::<span class="hljs-built_in">move</span>(blogMeta.title), std::<span class="hljs-built_in">move</span>(blogData.content),&#13;
    std::<span class="hljs-built_in">move</span>(blogMeta.summary), std::<span class="hljs-built_in">move</span>(blogMeta.createdTime),&#13;
    std::<span class="hljs-built_in">move</span>(blogMeta.updatedTime), std::<span class="hljs-built_in">move</span>(blogMeta.coverAddress),&#13;
    std::<span class="hljs-built_in">move</span>(blogMeta.isDraft)});
</code></pre>
<p>更新某篇博文数据：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;blogId = blogData.blogMeta.id;&#13;
<span class="hljs-keyword">auto</span> &amp;blogMeta = blogData.blogMeta;&#13;
&#13;
<span class="hljs-keyword">if</span> (!Sqlite3Crud::<span class="hljs-built_in">Update</span>&lt;TableBlogsField&gt;(&#13;
        TableName::blogs,&#13;
        {TableBlogsField::title, TableBlogsField::content,&#13;
        TableBlogsField::summary, TableBlogsField::created_at,&#13;
        TableBlogsField::updated_at, TableBlogsField::cover_image_url,&#13;
        TableBlogsField::is_draft, TableBlogsField::id},&#13;
        {std::<span class="hljs-built_in">move</span>(blogMeta.title), std::<span class="hljs-built_in">move</span>(blogData.content),&#13;
        std::<span class="hljs-built_in">move</span>(blogMeta.summary), std::<span class="hljs-built_in">move</span>(blogMeta.createdTime),&#13;
        std::<span class="hljs-built_in">move</span>(blogMeta.updatedTime), std::<span class="hljs-built_in">move</span>(blogMeta.coverAddress),&#13;
        std::<span class="hljs-built_in">move</span>(blogMeta.isDraft), blogId})) {&#13;
<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#13;
}
</code></pre>
<p>删除某篇博文：</p>
<pre><code class="hljs language-cpp" lang="cpp">Sqlite3Crud::<span class="hljs-built_in">Delete</span>&lt;TableBlogsField&gt;(&#13;
      TableName::blogs, TableBlogsField::id, {std::<span class="hljs-built_in">move</span>(blogId)});
</code></pre>
<p>这种调用方式将数据库操作完全解耦于原始 SQL 字符串，不仅避免了手写 SQL 带来的拼写错误与注入风险，还使得表结构变更只需修改对应的枚举定义即可自动同步到所有相关操作中，显著提升了代码的安全性、可读性与可维护性。</p>
<h2 data-id="heading-5">3. 优化</h2>
<h3 data-id="heading-6">3.1 编译期生成</h3>
<p>虽然这样做已经非常自动化了，但是数据库表映射的枚举类对象可能并不能跟 SQLite3 数据库同步——因为这些枚举是在编译期静态定义的，而数据库表结构可能在运行时被外部工具（如迁移脚本、手动 ALTER TABLE 操作或不同版本的部署）动态修改。一旦实际数据库中的字段增删改与 C++ 枚举中定义的字段不一致，就会导致生成的 SQL 语句引用不存在的列、遗漏新增列，甚至因类型不匹配而引发运行时错误或数据丢失。</p>
<p>此外，这种“代码即 Schema”的方式缺乏对数据库真实状态的验证机制，无法在程序启动时自动检测表结构是否与枚举定义一致，从而埋下潜在的兼容性隐患。因此，在追求开发效率的同时，仍需辅以数据库版本管理（如迁移脚本）、启动时结构校验或构建阶段的代码生成工具（如从数据库 schema 自动生成枚举），才能真正实现类型安全与结构一致性的双重保障。</p>
<p>对 C++ 来说，比较好的方法就是在构建程序的时候通过代码生成工具从数据库 schema 自动生成枚举类。笔者的实现代码是：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// Script/DbSchemaGenerator.cpp</span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sqlite3.h&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>&#13;
&#13;
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span>&#13;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#13;
&#13;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;&#13;
&#13;
<span class="hljs-comment">//转换成帕斯卡命名</span>&#13;
<span class="hljs-function">std::string <span class="hljs-title">ToPascalCase</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>{&#13;
  <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">empty</span>()) {&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;&#13;
  }&#13;
&#13;
  std::string result;&#13;
  <span class="hljs-type">bool</span> nextUpper = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 下一个有效字符应大写</span>&#13;
&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) {&#13;
    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'_'</span>) {&#13;
      <span class="hljs-comment">// 遇到下划线，下一个非下划线字母要大写</span>&#13;
      nextUpper = <span class="hljs-literal">true</span>;&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      <span class="hljs-keyword">if</span> (nextUpper) {&#13;
        result +=&#13;
            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(std::<span class="hljs-built_in">toupper</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(c)));&#13;
        nextUpper = <span class="hljs-literal">false</span>;&#13;
      } <span class="hljs-keyword">else</span> {&#13;
        result +=&#13;
            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(std::<span class="hljs-built_in">tolower</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(c)));&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-comment">// 如果结果为空（比如输入全是下划线），返回空串</span>&#13;
  <span class="hljs-keyword">return</span> result;&#13;
}&#13;
&#13;
<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">QueryTableName</span><span class="hljs-params">(sqlite3* db)</span> </span>{&#13;
  vector&lt;string&gt; tableNames;&#13;
&#13;
  <span class="hljs-comment">// 获取所有用户表</span>&#13;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sqlTables =&#13;
      <span class="hljs-string">"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE "</span>&#13;
      <span class="hljs-string">"'sqlite_%';"</span>;&#13;
&#13;
  sqlite3_stmt* stmtTables;&#13;
  <span class="hljs-type">int</span> rc = <span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sqlTables, <span class="hljs-number">-1</span>, &amp;stmtTables, <span class="hljs-literal">nullptr</span>);&#13;
&#13;
  <span class="hljs-keyword">if</span> (rc != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Failed to fetch tables: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
    <span class="hljs-keyword">return</span> tableNames;&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sqlite3_step</span>(stmtTables) == SQLITE_ROW) {&#13;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tableNameCstr =&#13;
        <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-built_in">sqlite3_column_text</span>(stmtTables, <span class="hljs-number">0</span>));&#13;
&#13;
    <span class="hljs-keyword">if</span> (!tableNameCstr) <span class="hljs-keyword">continue</span>;&#13;
&#13;
    tableNames.<span class="hljs-built_in">emplace_back</span>(tableNameCstr);&#13;
  }&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmtTables);&#13;
&#13;
  <span class="hljs-keyword">return</span> tableNames;&#13;
}&#13;
&#13;
<span class="hljs-function">string <span class="hljs-title">Read2String</span><span class="hljs-params">(filesystem::path&amp; filePath)</span> </span>{&#13;
  <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(filePath)</span></span>;&#13;
  <span class="hljs-keyword">if</span> (!infile) {&#13;
    <span class="hljs-keyword">return</span> {};&#13;
  }&#13;
  <span class="hljs-keyword">return</span> {(std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;(infile)),&#13;
          std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;()};&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteTableName</span><span class="hljs-params">(filesystem::path&amp; tableNameFile,&#13;
                    <span class="hljs-type">const</span> vector&lt;string&gt;&amp; tableNames)</span> </span>{&#13;
  std::ostringstream memStream;&#13;
&#13;
  memStream &lt;&lt; <span class="hljs-string">"#pragma once\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"namespace Persistence {\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"enum class TableName {\n"</span>;&#13;
&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; tableNames.<span class="hljs-built_in">size</span>(); ++i) {&#13;
    string line;&#13;
    <span class="hljs-keyword">if</span> (i == tableNames.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {&#13;
      line = std::format(<span class="hljs-string">"  {}\n"</span>, tableNames[i]);&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      line = std::format(<span class="hljs-string">"  {},\n"</span>, tableNames[i]);&#13;
    }&#13;
    memStream &lt;&lt; line;&#13;
  }&#13;
  memStream &lt;&lt; <span class="hljs-string">"};\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"}"</span>;&#13;
&#13;
  <span class="hljs-keyword">if</span> (memStream.<span class="hljs-built_in">str</span>() == <span class="hljs-built_in">Read2String</span>(tableNameFile)) {&#13;
    <span class="hljs-keyword">return</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(tableNameFile)</span></span>;&#13;
  <span class="hljs-keyword">if</span> (!file) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Failed to open file '"</span> &lt;&lt; tableNameFile.<span class="hljs-built_in">generic_string</span>()&#13;
              &lt;&lt; <span class="hljs-string">"' for writing.\n"</span>;&#13;
    <span class="hljs-keyword">return</span>;&#13;
  }&#13;
&#13;
  file &lt;&lt; memStream.<span class="hljs-built_in">str</span>();&#13;
}&#13;
&#13;
<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">QueryFiledName</span><span class="hljs-params">(sqlite3* db, <span class="hljs-type">const</span> string&amp; tableName)</span> </span>{&#13;
  vector&lt;string&gt; filedNames;&#13;
&#13;
  <span class="hljs-type">const</span> string&amp; sql = <span class="hljs-string">"PRAGMA table_info("</span> + tableName + <span class="hljs-string">");"</span>;&#13;
  sqlite3_stmt* stmt;&#13;
  <span class="hljs-type">int</span> rc = <span class="hljs-built_in">sqlite3_prepare_v2</span>(db, sql.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">-1</span>, &amp;stmt, <span class="hljs-literal">nullptr</span>);&#13;
  <span class="hljs-keyword">if</span> (rc != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Failed to get schema for table '"</span> &lt;&lt; tableName.<span class="hljs-built_in">c_str</span>()&#13;
              &lt;&lt; <span class="hljs-string">"': "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
    <span class="hljs-keyword">return</span> filedNames;&#13;
  }&#13;
&#13;
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sqlite3_step</span>(stmt) == SQLITE_ROW) {&#13;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* col_name = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(&#13;
        <span class="hljs-built_in">sqlite3_column_text</span>(stmt, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 第1列是name</span>&#13;
&#13;
    <span class="hljs-keyword">if</span> (col_name) {&#13;
      filedNames.<span class="hljs-built_in">emplace_back</span>(col_name);&#13;
    }&#13;
  }&#13;
&#13;
  <span class="hljs-built_in">sqlite3_finalize</span>(stmt);&#13;
&#13;
  <span class="hljs-keyword">return</span> filedNames;&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteFiledName</span><span class="hljs-params">(filesystem::path&amp; outSourceDir, <span class="hljs-type">const</span> string&amp; fileName,&#13;
                    <span class="hljs-type">const</span> vector&lt;string&gt;&amp; filedNames)</span> </span>{&#13;
  std::ostringstream memStream;&#13;
&#13;
  memStream &lt;&lt; <span class="hljs-string">"#pragma once\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"namespace Persistence {\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; std::format(<span class="hljs-string">"enum class {} {{\n"</span>, fileName);&#13;
&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; filedNames.<span class="hljs-built_in">size</span>(); ++i) {&#13;
    string line;&#13;
    <span class="hljs-keyword">if</span> (i == filedNames.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {&#13;
      line = std::format(<span class="hljs-string">"  {}\n"</span>, filedNames[i]);&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      line = std::format(<span class="hljs-string">"  {},\n"</span>, filedNames[i]);&#13;
    }&#13;
    memStream &lt;&lt; line;&#13;
  }&#13;
  memStream &lt;&lt; <span class="hljs-string">"};\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  memStream &lt;&lt; <span class="hljs-string">"}"</span>;&#13;
&#13;
  filesystem::path filedNameFile = outSourceDir / (fileName + <span class="hljs-string">".h"</span>);&#13;
  <span class="hljs-keyword">if</span> (memStream.<span class="hljs-built_in">str</span>() == <span class="hljs-built_in">Read2String</span>(filedNameFile)) {&#13;
    <span class="hljs-keyword">return</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-function">ofstream <span class="hljs-title">file</span><span class="hljs-params">(filedNameFile)</span></span>;&#13;
  <span class="hljs-keyword">if</span> (!file) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Failed to open file '"</span> &lt;&lt; filedNameFile.<span class="hljs-built_in">generic_string</span>()&#13;
              &lt;&lt; <span class="hljs-string">"' for writing.\n"</span>;&#13;
    <span class="hljs-keyword">return</span>;&#13;
  }&#13;
&#13;
  file &lt;&lt; memStream.<span class="hljs-built_in">str</span>();&#13;
}&#13;
&#13;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{&#13;
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span>&#13;
  <span class="hljs-built_in">SetConsoleOutputCP</span>(<span class="hljs-number">65001</span>);&#13;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#13;
&#13;
  <span class="hljs-comment">//</span>&#13;
  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>]&#13;
              &lt;&lt; <span class="hljs-string">" &lt;database_path&gt; &lt;output_directory&gt;\n"</span>;&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#13;
  }&#13;
&#13;
  <span class="hljs-comment">//</span>&#13;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbPath = argv[<span class="hljs-number">1</span>];&#13;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* outputDir = argv[<span class="hljs-number">2</span>];&#13;
  std::cout &lt;&lt; <span class="hljs-string">"Generating DB schema enums...\n"</span>;&#13;
  std::cout &lt;&lt; <span class="hljs-string">"  DB Path: "</span> &lt;&lt; dbPath &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  std::cout &lt;&lt; <span class="hljs-string">"  Output : "</span> &lt;&lt; outputDir &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
  filesystem::path outSourceDir{outputDir};&#13;
&#13;
  sqlite3* db;&#13;
  <span class="hljs-type">int</span> rc = <span class="hljs-built_in">sqlite3_open</span>(dbPath, &amp;db);&#13;
&#13;
  <span class="hljs-keyword">if</span> (rc != SQLITE_OK) {&#13;
    std::cerr &lt;&lt; <span class="hljs-string">"Cannot open database: "</span> &lt;&lt; <span class="hljs-built_in">sqlite3_errmsg</span>(db) &lt;&lt; <span class="hljs-string">"\n"</span>;&#13;
    <span class="hljs-built_in">sqlite3_close</span>(db);&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#13;
  }&#13;
&#13;
  vector&lt;string&gt; tableNames = <span class="hljs-built_in">QueryTableName</span>(db);&#13;
  filesystem::path tableNameFile = outSourceDir / <span class="hljs-string">"TableName.h"</span>;&#13;
  <span class="hljs-built_in">WriteTableName</span>(tableNameFile, tableNames);&#13;
&#13;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> tableName : tableNames) {&#13;
    string fileName = <span class="hljs-string">"Table"</span> + <span class="hljs-built_in">ToPascalCase</span>(tableName) + <span class="hljs-string">"Field"</span>;&#13;
    <span class="hljs-built_in">WriteFiledName</span>(outSourceDir, fileName, <span class="hljs-built_in">QueryFiledName</span>(db, tableName));&#13;
  }&#13;
&#13;
  <span class="hljs-built_in">sqlite3_close</span>(db);&#13;
&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#13;
}
</code></pre>
<p>代码虽然很长，但是实现思路很简单：既然要保证 SQLite3 数据库中的表格数据与映射的枚举类一致，那就让这些枚举类代码在构建之前通过这个 <code>Script/DbSchemaGenerator.cpp</code> 工具生成就可以了，数据库表的名称和字段名都可以通过调用相应的 SQL 语句来实现。当然，这需要借助于构建系统，可参照<a href="https://link.juejin.cn?target=https%3A%2F%2Fcharlee44.com%2Fpost.html%3Fid%3D421b07cc6a3146b0852d6b7d42ffba6c" target="_blank" title="https://charlee44.com/post.html?id=421b07cc6a3146b0852d6b7d42ffba6c" ref="nofollow noopener noreferrer">《CMake 构建学习笔记 31-构建前执行可执行程序》</a>。</p>
<h3 data-id="heading-7">3.2 JOIN 查询</h3>
<p>当前 <code>Util::Statement::Query</code> 只支持 单表查询（FROM table），那么复杂的 JOIN 查询如何实现呢？一般来说， JOIN 涉及多表、别名、复杂 SELECT 列等，无法直接用“字段枚举列表”简单表达，也很难用一个函数生成所有 JOIN SQL 。最好的办法是两种方案并行：</p>
<ol>
<li>简单单表 CRUD : 继续用现有的实现。</li>
<li>复杂查询（含 JOIN / 子查询 / 聚合）：允许手写 SQL 字符串，但复用你已有的 QueryRows 执行引擎。</li>
</ol>
<p>在主流 Java 后端框架（Spring Data JPA、MyBatis）中，这种“简单操作用 ORM 自动生成，复杂查询允许手写 SQL”的混合策略是一种广泛采纳的最佳实践。其核心思想是：在开发效率与控制力之间取得平衡——既享受 ORM 带来的类型安全、代码简洁和快速开发优势，又不牺牲对复杂 SQL 场景的完全掌控能力。</p>
<h2 data-id="heading-8">4. 补充</h2>
<p>笔者的这段实现只能算是半自动的 ORM 风格封装，没有实现全自动的对象与数据库表的映射（比如不能直接传一个 <code>User</code> 对象就自动插入），但它确实体现了一些 ORM 的典型设计思路：</p>








































<table><thead><tr><th>ORM 特性</th><th>是否体现</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>隐藏原始 SQL 字符串拼接</strong></td><td>✔️</td><td>使用 <code>Util::Statement</code> 自动生成带占位符的 SQL</td></tr><tr><td>✅ <strong>参数绑定防注入</strong></td><td>✔️</td><td>全部使用 <code>sqlite3_bind_*</code>，安全</td></tr><tr><td>✅ <strong>字段名类型安全</strong></td><td>✔️</td><td>用枚举 + <code>magic_enum</code> 代替字符串 <code>"name"</code>，避免拼错</td></tr><tr><td>✅ <strong>CRUD 抽象为函数</strong></td><td>✔️</td><td><code>InsertRow</code>, <code>QueryRows</code> 等提供统一接口</td></tr><tr><td>❌ <strong>对象自动映射</strong></td><td>✖️</td><td>仍需手动构造 <code>vector</code>，不能直接传对象</td></tr><tr><td>❌ <strong>自动生成 SQL（基于对象）</strong></td><td>✖️</td><td>SQL 由工具函数生成，但需显式指定字段列表</td></tr></tbody></table>
<p>不同的编程语言有着各自适用的编程范式，盲目照搬其他生态的全自动 ORM 模式并不可取——它不仅可能引入不必要的性能开销，还可能与语言特性格格不入。归根结底，只要能以合理、安全且可维护的方式解决问题，就是好的设计。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[RxJava：响应式编程]]></title>    <link>https://juejin.cn/post/7587254134401810441</link>    <guid>https://juejin.cn/post/7587254134401810441</guid>    <pubDate>2025-12-25T00:58:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587254134401810441" data-draft-id="7587246055457357851" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="RxJava：响应式编程"/> <meta itemprop="keywords" content="RxJava"/> <meta itemprop="datePublished" content="2025-12-25T00:58:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            RxJava：响应式编程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T00:58:36.000Z" title="Thu Dec 25 2025 00:58:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文深入讲解ReactiveX旗下的RxJava框架，从核心概念到实战应用，帮助你掌握响应式编程的精髓。</p>
</blockquote>
<h2 data-id="heading-0">一、引言：为什么选择RxJava</h2>
<p>在现代软件开发中,异步编程已成为必不可少的技能。传统的回调、线程管理复杂等问题一直困扰着开发者。<strong>RxJava</strong>(Reactive Extensions for Java)提供了一种优雅的解决方案,让异步编程变得简单而强大。</p>
<h2 data-id="heading-1">RxJava的核心优势</h2>
<pre><code class="hljs">声明式编程 - 以数据流的方式描述业务逻辑
链式调用 - 操作符组合,代码简洁易读
强大的操作符 - 100+操作符满足各种场景
线程调度灵活 - 轻松切换执行线程
错误处理优雅 - 统一的异常处理机制
背压支持 - Flowable处理数据流速控制
</code></pre>
<h2 data-id="heading-2">二、核心架构解析</h2>
<p>RxJava基于观察者模式,采用响应式编程思想,核心由四大组件构成。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41543a16fd8d41d89e952a4f3d5bbb60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=BP9x7etaZ9DWyREWCQtxUXXoVZA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">核心组件详解</h2>
<p><strong>Observable(被观察者)</strong></p>
<p>数据源,负责发射数据流。Observable是整个响应式流的起点,它负责产生数据并发送给订阅者。</p>
<pre><code class="hljs language-scss" lang="scss">publicabstractclassObservable&lt;T&gt; 
    implementsObservableSource&lt;T&gt; {

    <span class="hljs-built_in">publicfinalvoidsubscribe</span>(
        Observer&lt;? super T&gt; observer) {
        <span class="hljs-built_in">subscribeActual</span>(observer);
    }
    <span class="hljs-built_in">protectedabstractvoidsubscribeActual</span>(
        Observer&lt;? super T&gt; observer);
}
</code></pre>
<p><strong>Observer(观察者)</strong></p>
<p>数据消费者,接收并处理数据。Observer定义了四个核心方法来处理数据流的不同状态。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">T</span>&gt; {
    <span class="hljs-comment">// 订阅开始</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span>;

    <span class="hljs-comment">// 接收数据</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span>(<span class="hljs-params">T t</span>)</span>;

    <span class="hljs-comment">// 发生错误</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span>;

    <span class="hljs-comment">// 完成</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span>()</span>;
}
</code></pre>
<p><strong>Operators(操作符)</strong></p>
<p>用于转换、过滤、组合数据流的中间操作。操作符是RxJava的精髓,提供了丰富的数据处理能力。</p>
<p><strong>Schedulers(调度器)</strong></p>
<p>控制Observable和Observer在哪个线程执行,实现灵活的线程调度。</p>
<h2 data-id="heading-4">数据流类型</h2>
<p>RxJava 3提供了5种主要的数据流类型,每种类型适用于不同的场景：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">Observable - 发射<span class="hljs-number">0</span>到N个数据项,不支持背压,适用于通用场景
Flowable - 发射<span class="hljs-number">0</span>到N个数据项,支持背压,适用于大数据量场景
<span class="hljs-type">Single</span> - 只发射<span class="hljs-number">1</span>个数据项,适用于单一结果场景如网络请求
Maybe - 发射<span class="hljs-number">0</span>或<span class="hljs-number">1</span>个数据项,适用于可能有结果的场景
Completable - 不发射数据,只关心完成状态
</code></pre>
<h2 data-id="heading-5">三、快速上手：基础用法</h2>
<h2 data-id="heading-6">创建Observable的多种方式</h2>
<p><strong>方式1：just - 发射固定的数据项</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">Observable&lt;<span class="hljs-type">String</span>&gt; observable1 = 
    Observable.<span class="hljs-built_in">just</span>(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"RxJava"</span>);
</code></pre>
<p><strong>方式2：from - 从数组或集合创建</strong></p>
<pre><code class="hljs language-ini" lang="ini">List&lt;Integer&gt; <span class="hljs-attr">numbers</span> = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
Observable&lt;Integer&gt; <span class="hljs-attr">observable2</span> = 
    Observable.fromIterable(numbers)<span class="hljs-comment">;</span>
</code></pre>
<p><strong>方式3：create - 自定义发射逻辑</strong></p>
<pre><code class="hljs language-ini" lang="ini">Observable&lt;String&gt; <span class="hljs-attr">observable3</span> = 
    Observable.create(emitter -&gt; {
        emitter.onNext("Data 1")<span class="hljs-comment">;</span>
        emitter.onNext("Data 2")<span class="hljs-comment">;</span>
        emitter.onComplete()<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
</code></pre>
<p><strong>方式4：interval - 定时发射</strong></p>
<pre><code class="hljs language-ini" lang="ini">Observable&lt;Long&gt; <span class="hljs-attr">observable4</span> = 
    Observable.interval(1, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
</code></pre>
<p><strong>方式5：range - 发射一系列整数</strong></p>
<pre><code class="hljs language-ini" lang="ini">Observable&lt;Integer&gt; <span class="hljs-attr">observable5</span> = 
    Observable.range(1, 10)<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-7">订阅Observable</h2>
<p>完整的订阅示例：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">just</span>(<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>)
    .<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-title class_">String</span>&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSubscribe</span>(<span class="hljs-params">Disposable d</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"开始订阅"</span>);
        }
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> item</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"收到数据: "</span> + item);
        }
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">err</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"发生错误: "</span> 
                + e.<span class="hljs-title function_">getMessage</span>());
        }
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onComplete</span>(<span class="hljs-params"/>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"完成"</span>);
        }
    });
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">开始订阅收到数据: Apple收到数据: Banana收到数据: Orange完成</span>
</code></pre>
<h2 data-id="heading-8">简化的订阅方式</h2>
<p>实际开发中,我们经常使用Lambda表达式简化订阅代码：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 只处理onNext</span>
Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    .subscribe(item -&gt; System.out.<span class="hljs-built_in">println</span>(item));
<span class="hljs-comment">// 处理onNext和onError</span>
Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    .subscribe(
        item -&gt; System.out.<span class="hljs-built_in">println</span>(item),
        <span class="hljs-type">error</span> -&gt; System.err.<span class="hljs-built_in">println</span>(<span class="hljs-type">error</span>)
    );
<span class="hljs-comment">// 处理onNext、onError和onComplete</span>
Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    .subscribe(
        item -&gt; System.out.<span class="hljs-built_in">println</span>(item),
        <span class="hljs-type">error</span> -&gt; System.err.<span class="hljs-built_in">println</span>(<span class="hljs-type">error</span>),
        () -&gt; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"完成"</span>)
    );
</code></pre>
<h2 data-id="heading-9">四、操作符详解：数据变换的艺术</h2>
<p>操作符是RxJava的核心,掌握常用操作符是使用RxJava的关键。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b1e3e59377d45e9b282f665f77832e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=tI9WOEJpRy2LU%2FuLGhsutJhtTXM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">创建操作符</h2>
<p>创建操作符用于生成Observable数据源：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// just - 发射预定义的数据项</span>
Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// fromArray - 从数组创建</span>
Integer<span class="hljs-selector-attr">[]</span> array = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
Observable<span class="hljs-selector-class">.fromArray</span>(array);
<span class="hljs-comment">// fromCallable - 延迟执行</span>
Observable<span class="hljs-selector-class">.fromCallable</span>(() -&gt; {
    <span class="hljs-comment">// 只有订阅时才执行</span>
    return <span class="hljs-built_in">expensiveOperation</span>();
});
<span class="hljs-comment">// defer - 为每个订阅者创建新的Observable</span>
Observable<span class="hljs-selector-class">.defer</span>(() -&gt; 
    Observable<span class="hljs-selector-class">.just</span>(System.currentTimeMillis()));
</code></pre>
<h2 data-id="heading-11">转换操作符</h2>
<p><strong>map - 一对一转换</strong></p>
<p>最常用的转换操作符,将每个数据项转换为另一种形式：</p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
    <span class="hljs-selector-class">.map</span>(number -&gt; number * <span class="hljs-number">2</span>)
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出: 2, 4, 6, 8, 10</span>
</code></pre>
<p><strong>flatMap - 一对多转换并合并</strong></p>
<p>适用于需要为每个数据项发起异步操作的场景：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 场景：搜索用户并获取每个用户的订单</span>
Observable.just(<span class="hljs-string">"user1"</span>, <span class="hljs-string">"user2"</span>, <span class="hljs-string">"user3"</span>)
    .flatMap(userId -&gt; {
        <span class="hljs-comment">// 为每个用户发起网络请求</span>
        <span class="hljs-keyword">return</span> getUserOrders(userId);
    })
    .subscribe(order -&gt; 
        System.<span class="hljs-keyword">out</span>.println(order));
</code></pre>
<p><strong>concatMap - 顺序的flatMap</strong></p>
<p>当需要保证执行顺序时使用concatMap：</p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    <span class="hljs-selector-class">.concatMap</span>(i -&gt; Observable.just(i * <span class="hljs-number">10</span>)
        <span class="hljs-selector-class">.delay</span>(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS))
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出严格按顺序: 10, 20, 30</span>
</code></pre>
<h2 data-id="heading-12">过滤操作符</h2>
<p>过滤操作符用于筛选数据流中的数据：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// filter - 过滤数据</span>
Observable<span class="hljs-selector-class">.range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
    <span class="hljs-selector-class">.filter</span>(number -&gt; number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出: 2, 4, 6, 8, 10</span>
<span class="hljs-comment">// take - 只取前N个</span>
Observable<span class="hljs-selector-class">.range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)
    <span class="hljs-selector-class">.take</span>(<span class="hljs-number">5</span>)
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出: 1, 2, 3, 4, 5</span>
<span class="hljs-comment">// skip - 跳过前N个</span>
Observable<span class="hljs-selector-class">.range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
    <span class="hljs-selector-class">.skip</span>(<span class="hljs-number">5</span>)
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出: 6, 7, 8, 9, 10</span>
<span class="hljs-comment">// distinct - 去重</span>
Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
    <span class="hljs-selector-class">.distinct</span>()
    <span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 输出: 1, 2, 3, 4</span>
</code></pre>
<p><strong>debounce - 防抖(搜索框常用)</strong></p>
<p>在用户停止输入一段时间后才触发搜索,避免频繁请求：</p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.create</span>(emitter -&gt; {
    emitter.onNext("a");
    Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">100</span>);
    emitter<span class="hljs-selector-class">.onNext</span>("ab");
    Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">100</span>);
    emitter<span class="hljs-selector-class">.onNext</span>("abc");
    Thread<span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">500</span>); <span class="hljs-comment">// 停顿超过300ms</span>
    emitter<span class="hljs-selector-class">.onComplete</span>();
})
<span class="hljs-selector-class">.debounce</span>(<span class="hljs-number">300</span>, TimeUnit.MILLISECONDS)
<span class="hljs-selector-class">.subscribe</span>(System.out::println);
<span class="hljs-comment">// 只输出: abc</span>
</code></pre>
<h2 data-id="heading-13">组合操作符</h2>
<p>组合操作符用于合并多个数据源：</p>
<pre><code class="hljs language-ini" lang="ini">// merge - 合并多个Observable
Observable&lt;String&gt; <span class="hljs-attr">obs1</span> = Observable.just(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>)<span class="hljs-comment">;</span>
Observable&lt;String&gt; <span class="hljs-attr">obs2</span> = Observable.just(<span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>)<span class="hljs-comment">;</span>
Observable.merge(obs1, obs2)
    .subscribe(System.out::println)<span class="hljs-comment">;</span>
// 输出: A, B, C, D(顺序不保证)
// zip - 组合对应位置的数据
Observable&lt;Integer&gt; <span class="hljs-attr">numbers</span> = 
    Observable.just(1, 2, 3)<span class="hljs-comment">;</span>
Observable&lt;String&gt; <span class="hljs-attr">letters</span> = 
    Observable.just("A", "B", "C")<span class="hljs-comment">;</span>
Observable.zip(numbers, letters,
    (number, letter) -&gt; number + letter)
    .subscribe(System.out::println)<span class="hljs-comment">;</span>
// 输出: 1A, 2B, 3C
// combineLatest - 任一数据源变化时组合最新值
Observable&lt;Long&gt; <span class="hljs-attr">timer1</span> = 
    Observable.interval(1, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
Observable&lt;Long&gt; <span class="hljs-attr">timer2</span> = 
    Observable.interval(2, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
Observable.combineLatest(timer1, timer2,
    (t1, t2) -&gt; "T1:" + t1 + " T2:" + t2)
    .subscribe(System.out::println)<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-14">错误处理操作符</h2>
<p>优雅的错误处理是RxJava的一大优势：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// onErrorReturn - 错误时返回默认值</span>
Observable.<span class="hljs-title function_ invoke__">create</span>(emitter -&gt; {
    emitter.<span class="hljs-title function_ invoke__">onNext</span>(<span class="hljs-number">1</span>);
    emitter.<span class="hljs-title function_ invoke__">onNext</span>(<span class="hljs-number">2</span>);
    emitter.<span class="hljs-title function_ invoke__">onError</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">"出错了"</span>));
})
.<span class="hljs-title function_ invoke__">onErrorReturn</span>(throwable -&gt; -<span class="hljs-number">1</span>)
.<span class="hljs-title function_ invoke__">subscribe</span>(System.out::<span class="hljs-variable constant_">println</span>);
<span class="hljs-comment">// 输出: 1, 2, -1</span>
<span class="hljs-comment">// onErrorResumeNext - 错误时切换到另一个Observable</span>
Observable.<span class="hljs-title function_ invoke__">create</span>(emitter -&gt; {
    emitter.<span class="hljs-title function_ invoke__">onNext</span>(<span class="hljs-string">"A"</span>);
    emitter.<span class="hljs-title function_ invoke__">onError</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">"出错"</span>));
})
.<span class="hljs-title function_ invoke__">onErrorResumeNext</span>(Observable.<span class="hljs-title function_ invoke__">just</span>(<span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>))
.<span class="hljs-title function_ invoke__">subscribe</span>(System.out::<span class="hljs-variable constant_">println</span>);
<span class="hljs-comment">// 输出: A, B, C</span>
<span class="hljs-comment">// retry - 重试</span>
AtomicInteger count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);
Observable.<span class="hljs-title function_ invoke__">create</span>(emitter -&gt; {
    <span class="hljs-keyword">int</span> attempt = count.<span class="hljs-title function_ invoke__">incrementAndGet</span>();
    System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">"尝试次数: "</span> + attempt);
    <span class="hljs-keyword">if</span> (attempt &lt; <span class="hljs-number">3</span>) {
        emitter.<span class="hljs-title function_ invoke__">onError</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">"失败"</span>));
    } <span class="hljs-keyword">else</span> {
        emitter.<span class="hljs-title function_ invoke__">onNext</span>(<span class="hljs-string">"成功"</span>);
        emitter.<span class="hljs-title function_ invoke__">onComplete</span>();
    }
})
.<span class="hljs-title function_ invoke__">retry</span>(<span class="hljs-number">3</span>)
.<span class="hljs-title function_ invoke__">subscribe</span>(System.out::<span class="hljs-variable constant_">println</span>);
</code></pre>
<h2 data-id="heading-15">五、线程调度：掌控异步执行</h2>
<p>合理的线程调度是保证应用性能的关键。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb071d1ad42248888b67dd88baf8f96b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=sBUfoH7pYnz0CowPVfnDVTGCG3E%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-16">Schedulers类型</h2>
<p>RxJava提供了多种调度器,每种适用于不同的场景：</p>
<p><strong>Schedulers.io() - IO密集型任务</strong></p>
<p>适用于网络请求、文件读写等IO操作：</p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.fromCallable</span>(() -&gt; {
    <span class="hljs-comment">// 网络请求、文件读写</span>
    return <span class="hljs-built_in">downloadFile</span>();
})
<span class="hljs-selector-class">.subscribeOn</span>(Schedulers.io())
<span class="hljs-selector-class">.subscribe</span>(result -&gt; System.out.println(result));
</code></pre>
<p><strong>Schedulers.computation() - 计算密集型</strong></p>
<p>适用于CPU密集型计算：</p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>)
    <span class="hljs-selector-class">.map</span>(i -&gt; i * i)
    <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.computation())
    <span class="hljs-selector-class">.subscribe</span>();
</code></pre>
<p><strong>Schedulers.newThread() - 每次创建新线程</strong></p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>)
    <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.newThread())
    <span class="hljs-selector-class">.subscribe</span>();
</code></pre>
<p><strong>Schedulers.single() - 单线程执行</strong></p>
<pre><code class="hljs language-scss" lang="scss">Observable<span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.single())
    <span class="hljs-selector-class">.subscribe</span>();
</code></pre>
<p><strong>AndroidSchedulers.mainThread() - Android主线程</strong></p>
<p>在Android开发中更新UI时使用：</p>
<pre><code class="hljs language-arduino" lang="arduino">Observable.<span class="hljs-built_in">just</span>(<span class="hljs-string">"更新UI"</span>)
    .<span class="hljs-built_in">observeOn</span>(AndroidSchedulers.<span class="hljs-built_in">mainThread</span>())
    .<span class="hljs-built_in">subscribe</span>(text -&gt; textView.<span class="hljs-built_in">setText</span>(text));
</code></pre>
<h2 data-id="heading-17">subscribeOn vs observeOn</h2>
<p>理解这两个方法的区别是掌握线程调度的关键：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.<span class="hljs-built_in">io</span>())        
    <span class="hljs-comment">// 指定数据源在IO线程</span>
    <span class="hljs-selector-class">.map</span>(number -&gt; {
        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"map线程: "</span> +
            Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>());
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">number</span> * <span class="hljs-number">2</span>;
    })
    <span class="hljs-selector-class">.observeOn</span>(Schedulers.<span class="hljs-built_in">computation</span>()) 
    <span class="hljs-comment">// 切换到计算线程</span>
    <span class="hljs-selector-class">.filter</span>(number -&gt; {
        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"filter线程: "</span> +
            Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>());
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">number</span> &gt; <span class="hljs-number">2</span>;
    })
    <span class="hljs-selector-class">.observeOn</span>(Schedulers.<span class="hljs-built_in">newThread</span>())   
    <span class="hljs-comment">// 再次切换线程</span>
    <span class="hljs-selector-class">.subscribe</span>(number -&gt; {
        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"subscribe线程: "</span> +
            Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>());
        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"结果: "</span> + number);
    });
</code></pre>
<p><strong>关键区别：</strong></p>
<pre><code class="hljs language-scss" lang="scss">subscribeOn - 指定Observable自身在哪个线程执行(只有第一次有效)
observeOn - 指定后续操作在哪个线程执行(可多次使用)
</code></pre>
<h2 data-id="heading-18">六、实战应用：结合Retrofit</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b4add11d9ab44a3eb8267a80702bf922~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=o8%2FzQhx%2BtYLJNOZXpZug75R063o%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-19">网络请求 - 结合Retrofit</h2>
<p><strong>API接口定义：</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">ApiService</span> {
    <span class="hljs-variable">@GET</span>(<span class="hljs-string">"users/{id}"</span>)
    Single&lt;User&gt; <span class="hljs-built_in">getUser</span>(<span class="hljs-variable">@Path</span>(<span class="hljs-string">"id"</span>) int userId);
    <span class="hljs-variable">@GET</span>(<span class="hljs-string">"users/{id}/posts"</span>)
    Observable&lt;List&lt;Post&gt;&gt; <span class="hljs-built_in">getUserPosts</span>(
        <span class="hljs-variable">@Path</span>(<span class="hljs-string">"id"</span>) int userId);
}
</code></pre>
<p><strong>Retrofit配置：</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NetworkModule</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApiService apiService;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApiService <span class="hljs-title">getApiService</span>()</span> {
        <span class="hljs-keyword">if</span> (apiService == <span class="hljs-literal">null</span>) {
            Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()
                .baseUrl(<span class="hljs-string">"https://api.example.com/"</span>)
                .addConverterFactory(
                    GsonConverterFactory.create())
                .addCallAdapterFactory(
                    RxJava3CallAdapterFactory.create())
                .build();
            apiService = retrofit.create(ApiService.<span class="hljs-keyword">class</span>);
        }
        <span class="hljs-keyword">return</span> apiService;
    }
}
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApiService apiService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CompositeDisposable</span> <span class="hljs-variable">disposables</span> <span class="hljs-operator">=</span> 
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompositeDisposable</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserRepository</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>.apiService = NetworkModule.getApiService();
    }
    <span class="hljs-comment">// 获取用户信息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadUser</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, 
                         Consumer&lt;User&gt; onSuccess,
                         Consumer&lt;Throwable&gt; onError)</span> {
        <span class="hljs-type">Disposable</span> <span class="hljs-variable">disposable</span> <span class="hljs-operator">=</span> apiService.getUser(userId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(onSuccess, onError);
        disposables.add(disposable);
    }
    <span class="hljs-comment">// 清理订阅</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
        disposables.clear();
    }
}
</code></pre>
<h2 data-id="heading-20">搜索防抖</h2>
<p>实现智能搜索,避免频繁请求：</p>
<pre><code class="hljs language-scss" lang="scss">public class SearchActivity extends AppCompatActivity {
    private EditText searchEditText;
    private final CompositeDisposable disposables = 
        new <span class="hljs-built_in">CompositeDisposable</span>();
    <span class="hljs-keyword">@Override</span>
    protected void onCreate(Bundle savedInstanceState) {
        super<span class="hljs-selector-class">.onCreate</span>(savedInstanceState);
        <span class="hljs-built_in">setContentView</span>(R.layout.activity_search);
        searchEditText = 
            <span class="hljs-built_in">findViewById</span>(R.id.search_edit_text);
        <span class="hljs-comment">// 监听搜索框输入</span>
        Disposable disposable = 
            RxTextView<span class="hljs-selector-class">.textChanges</span>(searchEditText)
            <span class="hljs-selector-class">.debounce</span>(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS)  
            <span class="hljs-comment">// 防抖500ms</span>
            <span class="hljs-selector-class">.filter</span>(text -&gt; text.length() &gt;= <span class="hljs-number">2</span>)     
            <span class="hljs-comment">// 至少2个字符</span>
            <span class="hljs-selector-class">.distinctUntilChanged</span>()                 
            <span class="hljs-comment">// 内容变化才触发</span>
            <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.io())
            <span class="hljs-selector-class">.observeOn</span>(AndroidSchedulers.mainThread())
            <span class="hljs-selector-class">.subscribe</span>(text -&gt; {
                // 执行搜索
                performSearch(text.toString());
            });
        disposables<span class="hljs-selector-class">.add</span>(disposable);
    }
    private void <span class="hljs-built_in">performSearch</span>(String keyword) {
        apiService<span class="hljs-selector-class">.search</span>(keyword)
            <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.io())
            <span class="hljs-selector-class">.observeOn</span>(AndroidSchedulers.mainThread())
            <span class="hljs-selector-class">.subscribe</span>(
                results -&gt; updateSearchResults(results),
                error -&gt; <span class="hljs-built_in">showError</span>(error)
            );
    }
    <span class="hljs-keyword">@Override</span>
    protected void onDestroy() {
        super<span class="hljs-selector-class">.onDestroy</span>();
        disposables<span class="hljs-selector-class">.clear</span>();  <span class="hljs-comment">// 防止内存泄漏</span>
    }
}
</code></pre>
<h2 data-id="heading-21">多数据源合并</h2>
<p>同时加载多个数据源,等待全部完成后统一处理：</p>
<pre><code class="hljs language-scss" lang="scss">public class HomeRepository {
    <span class="hljs-comment">// 同时加载多个数据源</span>
    public Single&lt;HomeData&gt; <span class="hljs-built_in">loadHomeData</span>() {
        Single&lt;User&gt; userSingle = 
            apiService<span class="hljs-selector-class">.getCurrentUser</span>();
        Single&lt;List&lt;Post&gt;&gt; postsSingle = 
            apiService<span class="hljs-selector-class">.getLatestPosts</span>();
        Single&lt;List&lt;Notification&gt;&gt; notificationsSingle =
            apiService<span class="hljs-selector-class">.getNotifications</span>();
        return Single<span class="hljs-selector-class">.zip</span>(userSingle, 
                         postsSingle, 
                         notificationsSingle,
            (user, posts, notifications) -&gt;
                new <span class="hljs-built_in">HomeData</span>(user, posts, notifications))
            <span class="hljs-selector-class">.subscribeOn</span>(Schedulers.io())
            <span class="hljs-selector-class">.observeOn</span>(AndroidSchedulers.mainThread());
    }
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a441ea846544883a9e57a4e46cbac8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=BAyWDYAFKXqmoCPzq%2B%2FU2z6r8GM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-22">定时刷新</h2>
<p>实现自动刷新功能：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshManager</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Disposable</span> refreshDisposable;
    <span class="hljs-comment">// 每30秒自动刷新</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">startAutoRefresh</span>(<span class="hljs-params">Runnable refreshAction</span>) {
        refreshDisposable = 
            <span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">interval</span>(<span class="hljs-number">30</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>)
            .<span class="hljs-title function_">subscribeOn</span>(<span class="hljs-title class_">Schedulers</span>.<span class="hljs-title function_">io</span>())
            .<span class="hljs-title function_">observeOn</span>(<span class="hljs-title class_">AndroidSchedulers</span>.<span class="hljs-title function_">mainThread</span>())
            .<span class="hljs-title function_">subscribe</span>(tick -&gt; refreshAction.<span class="hljs-title function_">run</span>());
    }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">stopAutoRefresh</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (refreshDisposable != <span class="hljs-literal">null</span> &amp;&amp; 
            !refreshDisposable.<span class="hljs-title function_">isDisposed</span>()) {
            refreshDisposable.<span class="hljs-title function_">dispose</span>();
        }
    }
}
</code></pre>
<h2 data-id="heading-23">七、最佳实践：避坑指南</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/774cc09f9f5a4438bfdddd2c764f83d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229115&amp;x-signature=jwyY7IuxWFoR8erZqe9YfjMGdow%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-24">管理订阅 - 使用CompositeDisposable</h2>
<p><strong>正确做法：</strong></p>
<pre><code class="hljs language-scala" lang="scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CompositeDisposable</span> disposables = 
        <span class="hljs-keyword">new</span> <span class="hljs-type">CompositeDisposable</span>();
    <span class="hljs-keyword">private</span> void loadData() {
        <span class="hljs-type">Disposable</span> disposable = observable
            .subscribe(data -&gt; process(data));
        disposables.add(disposable);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onDestroy() {
        <span class="hljs-keyword">super</span>.onDestroy();
        disposables.clear();  <span class="hljs-comment">// 清理所有订阅</span>
    }
}
</code></pre>
<h2 data-id="heading-25">统一的错误处理</h2>
<p>创建一个统一的错误处理器：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RxErrorHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Consumer&lt;Throwable&gt; <span class="hljs-title function_">handleError</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> throwable -&gt; {
            <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> IOException) {
                <span class="hljs-comment">// 网络错误</span>
                showToast(<span class="hljs-string">"网络连接失败"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> HttpException) {
                <span class="hljs-comment">// HTTP错误</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> 
                    ((HttpException) throwable).code();
                showToast(<span class="hljs-string">"服务器错误: "</span> + code);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 其他错误</span>
                showToast(<span class="hljs-string">"发生未知错误"</span>);
            }
            <span class="hljs-comment">// 记录日志</span>
            Log.e(<span class="hljs-string">"RxError"</span>, <span class="hljs-string">"Error occurred"</span>, throwable);
        };
    }
}
<span class="hljs-comment">// 使用</span>
observable.subscribe(
    data -&gt; process(data),
    RxErrorHandler.handleError()
);
</code></pre>
<h2 data-id="heading-26">操作符选择</h2>
<p>根据场景选择合适的操作符：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// flatMap - 不保证顺序,适合并发</span>
<span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.just</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>)
    <span class="hljs-selector-class">.flatMap</span>(item -&gt; <span class="hljs-built_in">processAsync</span>(item))
    <span class="hljs-selector-class">.subscribe</span>();
<span class="hljs-comment">// concatMap - 保证顺序,适合顺序执行</span>
<span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.just</span>(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>)
    <span class="hljs-selector-class">.concatMap</span>(item -&gt; <span class="hljs-built_in">processAsync</span>(item))
    <span class="hljs-selector-class">.subscribe</span>();
<span class="hljs-comment">// switchMap - 只保留最新的,适合搜索</span>
<span class="hljs-selector-tag">searchObservable</span>
    <span class="hljs-selector-class">.switchMap</span>(keyword -&gt; apiService.<span class="hljs-built_in">search</span>(keyword))
    <span class="hljs-selector-class">.subscribe</span>();
</code></pre>
<h2 data-id="heading-27">背压处理</h2>
<p>处理大数据量时使用Flowable：</p>
<pre><code class="hljs language-scss" lang="scss">Flowable<span class="hljs-selector-class">.range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>)
    <span class="hljs-selector-class">.onBackpressureBuffer</span>(<span class="hljs-number">100</span>)  <span class="hljs-comment">// 缓冲区</span>
    <span class="hljs-selector-class">.observeOn</span>(Schedulers.computation(), false, <span class="hljs-number">10</span>)
    <span class="hljs-selector-class">.subscribe</span>(
        data -&gt; process(data),
        error -&gt; <span class="hljs-built_in">handleError</span>(error)
    );
<span class="hljs-comment">// 背压策略</span>
Flowable<span class="hljs-selector-class">.create</span>(emitter -&gt; {
    for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        emitter<span class="hljs-selector-class">.onNext</span>(i);
    }
    emitter<span class="hljs-selector-class">.onComplete</span>();
}, BackpressureStrategy<span class="hljs-selector-class">.DROP</span>)  <span class="hljs-comment">// 丢弃策略</span>
<span class="hljs-selector-class">.subscribe</span>();
</code></pre>
<h2 data-id="heading-28">八、总结</h2>
<p>RxJava核心要点</p>
<pre><code class="hljs">响应式思维 - 以数据流的方式思考问题
操作符链 - 灵活组合操作符完成复杂逻辑
线程调度 - 合理使用subscribeOn和observeOn
订阅管理 - 及时dispose避免内存泄漏
错误处理 - 使用专门的错误处理操作符
背压控制 - 大数据量场景使用Flowable
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[异常的 “隐藏传递”：finally 中的 return 会吞噬异常？]]></title>    <link>https://juejin.cn/post/7587245616755163187</link>    <guid>https://juejin.cn/post/7587245616755163187</guid>    <pubDate>2025-12-25T01:08:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587245616755163187" data-draft-id="7585206549305884735" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="异常的 “隐藏传递”：finally 中的 return 会吞噬异常？"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-12-25T01:08:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="uup"/> <meta itemprop="url" content="https://juejin.cn/user/4378706456356627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            异常的 “隐藏传递”：finally 中的 return 会吞噬异常？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4378706456356627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    uup
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:08:45.000Z" title="Thu Dec 25 2025 01:08:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、Bug 场景</h2>
<p>在一个 Java 程序中，开发人员在 <code>try - catch - finally</code> 块中编写了业务逻辑。原本期望 <code>try</code> 块中抛出的异常能够被正确捕获并处理，但在实际运行时，发现 <code>finally</code> 块中的 <code>return</code> 语句导致异常似乎被 “吞噬”，程序没有按照预期处理异常，这使得排查和解决问题变得困难，也影响了程序的稳定性和可靠性。</p>
<h2 data-id="heading-1">二、代码示例</h2>
<h3 data-id="heading-2">异常处理类（有缺陷）</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHidingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> a / b;
        } <span class="hljs-keyword">catch</span> (ArithmeticException e) {
            System.out.println(<span class="hljs-string">"捕获到算术异常: "</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"处理算术异常时抛出新异常"</span>, e);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 这里的return语句会隐藏try或catch块中抛出的异常</span>
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; 
        }
    }
}
</code></pre>
<h3 data-id="heading-3">测试代码</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHidingBugExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ExceptionHidingExample.divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
            System.out.println(<span class="hljs-string">"结果: "</span> + result);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"外部捕获到异常: "</span> + e.getMessage());
        }
    }
}
</code></pre>
<h2 data-id="heading-4">三、问题描述</h2>
<ol>
<li><strong>预期行为</strong>：当 <code>divide</code> 方法执行 <code>a / b</code> 出现 <code>ArithmeticException</code> 时，<code>catch</code> 块捕获并处理该异常，然后抛出一个新的 <code>RuntimeException</code>，这个新异常应该被外部的 <code>try - catch</code> 块捕获并处理，输出相应的错误信息。</li>
<li><strong>实际行为</strong>：<code>finally</code> 块中的 <code>return</code> 语句使得 <code>try</code> 或 <code>catch</code> 块中抛出的异常被 “隐藏”。尽管 <code>catch</code> 块捕获了 <code>ArithmeticException</code> 并抛出了新的 <code>RuntimeException</code>，但由于 <code>finally</code> 块中的 <code>return -1</code> 语句，这个新的 <code>RuntimeException</code> 没有被传递到外部的 <code>try - catch</code> 块，导致外部捕获不到异常，程序输出的结果是 <code>结果: -1</code>。这是因为在执行 <code>finally</code> 块中的 <code>return</code> 语句时，<code>try</code> 或 <code>catch</code> 块中抛出的异常信息会被丢弃，最终返回的是 <code>finally</code> 块中的 <code>return</code> 值，从而隐藏了异常。</li>
</ol>
<h2 data-id="heading-5">四、解决方案</h2>
<ol>
<li><strong>避免在 <code>finally</code> 中使用 <code>return</code></strong>：将 <code>return</code> 语句放在 <code>try</code> 或 <code>catch</code> 块中合适的位置，确保异常能够正常传递。</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHidingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> a / b;
        } <span class="hljs-keyword">catch</span> (ArithmeticException e) {
            System.out.println(<span class="hljs-string">"捕获到算术异常: "</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"处理算术异常时抛出新异常"</span>, e);
        }
    }
}
</code></pre>
<h3 data-id="heading-6">修改后的测试代码</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHidingBugExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ExceptionHidingExample.divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
            System.out.println(<span class="hljs-string">"结果: "</span> + result);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"外部捕获到异常: "</span> + e.getMessage());
        }
    }
}
</code></pre>
<ol start="2">
<li><strong>使用辅助变量</strong>：在 <code>try</code> 或 <code>catch</code> 块中设置一个辅助变量来存储结果，<code>finally</code> 块中不使用 <code>return</code>，而是对辅助变量进行操作，这样可以保证异常的正常传递。</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHidingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> {
            result = a / b;
        } <span class="hljs-keyword">catch</span> (ArithmeticException e) {
            System.out.println(<span class="hljs-string">"捕获到算术异常: "</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"处理算术异常时抛出新异常"</span>, e);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 这里可以对result进行其他非return的操作</span>
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[超越 SpringBoot 4.0了吗？OpenSolon v3.8, v3.7.4, v3.6.7 发布]]></title>    <link>https://juejin.cn/post/7587245616755294259</link>    <guid>https://juejin.cn/post/7587245616755294259</guid>    <pubDate>2025-12-25T01:24:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587245616755294259" data-draft-id="7587263750249316403" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="超越 SpringBoot 4.0了吗？OpenSolon v3.8, v3.7.4, v3.6.7 发布"/> <meta itemprop="keywords" content="Java,Spring Boot"/> <meta itemprop="datePublished" content="2025-12-25T01:24:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掉鱼的猫"/> <meta itemprop="url" content="https://juejin.cn/user/409464125003639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            超越 SpringBoot 4.0了吗？OpenSolon v3.8, v3.7.4, v3.6.7 发布
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/409464125003639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掉鱼的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:24:32.000Z" title="Thu Dec 25 2025 01:24:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">导引</h2>
<p>（听说隔壁的 Spring 7 和 SpringBoot 4 最近出了几个大 Bug了？！）历时 8 年磨砺，1.7 万次代码提交，9个分仓库，几百个模块，20多万代码量， 1200 万次半年下载量 —— OpenSolon（即 Solon）正在重新定义 Java 企业级应用开发的性价比。</p>
<p>今日，我们正式发布 OpenSolon v3.8 及其 LTS 维护版本。是一次架构级的跨越：从 AI 领域的 MCP 无状态集群支持，到 Flow 流程引擎的回归通用化，再到对 Java 新版本（v25）的超前布局，OpenSolon 持续践行“快速、小巧、简洁”的克制美学。</p>
<p>无论你是追求算力性价比的极致主义者，还是正在寻找安全可靠的国产基座，这次更新都值得你关注。</p>
<ul>
<li>【超前适配】 率先适配 Java 25，新增 ScopedValue 适配支持</li>
<li>【AI 增强】 solon-ai 深度支持 MCP 无状态会话集群与异步工具</li>
<li>【架构重构】 solon-flow 回归通用流程引擎，推出全新的 WorkflowService 封装；</li>
<li>【性能优化】 全面优化表达式引擎（SnEL）与缓存性能，持续保持高并发、省内存的领先优势。</li>
</ul>
<h2 data-id="heading-1">OpenSolon 开源框架！（也称：Solon）</h2>
<p>OpenSolon 是新一代，Java 企业级应用开发框架。<strong>从零开始构建（No Java-EE），有灵活的接口规范与开放生态</strong>。采用商用友好的 Apache  2.0 开源协议，是“杭州无耳科技有限公司”开源的根级项目，是 Java 应用开发的生态基座（可替换美国博通公司的 Spring 生态）。</p>
<ul>
<li>追求： 快速、小巧、简洁</li>
<li>提倡： 克制、高效、开放</li>
</ul>
<p>7年开源时间，累计代码提交1.6万次 ，近半年下载量1200万次。</p>
<ul>
<li>有透明可预期的<a href="https://link.juejin.cn?target=https%3A%2F%2Fsolon.noear.org%2Farticle%2F687" target="_blank" title="https://solon.noear.org/article/687" ref="nofollow noopener noreferrer">《版本发布与长期支持计划（LTS）》</a></li>
<li>有“<a href="https://link.juejin.cn?target=https%3A%2F%2Fsolon.noear.org%2Farticle%2Fsupport" target="_blank" title="https://solon.noear.org/article/support" ref="nofollow noopener noreferrer">【社区交流】</a>”和“<a href="https://link.juejin.cn?target=https%3A%2F%2Fsolon.noear.org%2Farticle%2Fservices" target="_blank" title="https://solon.noear.org/article/services" ref="nofollow noopener noreferrer">【企业服务】</a>”双重技术支持</li>
</ul>
<p>同时支持运行时环境（不基于 java-ee 构建，所以可以同时兼容）：</p>
<ul>
<li>java8, java11, java17, java21, java25</li>
</ul>
<p>目前有几个主要的项目仓库：</p>





































































<table><thead><tr><th>代码仓库</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon" target="_blank" title="https://gitee.com/opensolon/solon" ref="nofollow noopener noreferrer">/opensolon/solon</a></td><td>Solon ,主代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-examples" target="_blank" title="https://gitee.com/opensolon/solon-examples" ref="nofollow noopener noreferrer">/opensolon/solon-examples</a></td><td>Solon ,官网配套示例代码仓库</td></tr><tr><td/><td/></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-expression" target="_blank" title="https://gitee.com/opensolon/solon-expression" ref="nofollow noopener noreferrer">/opensolon/solon-expression</a></td><td>Solon Expression ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-flow" target="_blank" title="https://gitee.com/opensolon/solon-flow" ref="nofollow noopener noreferrer">/opensolon/solon-flow</a></td><td>Solon Flow ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-ai" target="_blank" title="https://gitee.com/opensolon/solon-ai" ref="nofollow noopener noreferrer">/opensolon/solon-ai</a></td><td>Solon Ai ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-cloud" target="_blank" title="https://gitee.com/opensolon/solon-cloud" ref="nofollow noopener noreferrer">/opensolon/solon-cloud</a></td><td>Solon Cloud ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-admin" target="_blank" title="https://gitee.com/opensolon/solon-admin" ref="nofollow noopener noreferrer">/opensolon/solon-admin</a></td><td>Solon Admin ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-integration" target="_blank" title="https://gitee.com/opensolon/solon-integration" ref="nofollow noopener noreferrer">/opensolon/solon-integration</a></td><td>Solon Integration ,代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-java17" target="_blank" title="https://gitee.com/opensolon/solon-java17" ref="nofollow noopener noreferrer">/opensolon/solon-java17</a></td><td>Solon Java17 适配仓库（base java17）</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-java25" target="_blank" title="https://gitee.com/opensolon/solon-java25" ref="nofollow noopener noreferrer">/opensolon/solon-java25</a></td><td>Solon Java25 适配仓库（base java25）</td></tr><tr><td/><td/></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-gradle-plugin" target="_blank" title="https://gitee.com/opensolon/solon-gradle-plugin" ref="nofollow noopener noreferrer">/opensolon/solon-gradle-plugin</a></td><td>Solon Gradle ,插件代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-idea-plugin" target="_blank" title="https://gitee.com/opensolon/solon-idea-plugin" ref="nofollow noopener noreferrer">/opensolon/solon-idea-plugin</a></td><td>Solon Idea ,插件代码仓库</td></tr><tr><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fopensolon%2Fsolon-vscode-plugin" target="_blank" title="https://gitee.com/opensolon/solon-vscode-plugin" ref="nofollow noopener noreferrer">/opensolon/solon-vscode-plugin</a></td><td>Solon VsCode ,插件代码仓库</td></tr></tbody></table>
<h2 data-id="heading-2">有什么特点（相对 Java Spring 方案）？</h2>
<p>OpenSolon 对国产算力非常友好，对 cpu 和 memory 的需求远低于同类方案。</p>

























<table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td>更高的计算性价比</td><td>并发高 700%；内存省 50%</td></tr><tr><td>更快的开发效率</td><td>代码少；入门简单；启动（或调试重启）快 10倍</td></tr><tr><td>更好的生产与部署体验</td><td>打包小 90%</td></tr><tr><td>更大的兼容范围</td><td>非 java-ee 架构；同时支持 java8 ～ java25，graalvm native image</td></tr></tbody></table>
<p>最新的 techempower （第三方知名测试平台）测试数据：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.techempower.com%2Fbenchmarks%2F%23hw%3Dph%26test%3Djson%25C2%25A7ion%3Ddata-r23" target="_blank" title="https://www.techempower.com/benchmarks/#hw=ph&amp;test=json%C2%A7ion=data-r23" ref="nofollow noopener noreferrer">www.techempower.com/benchmarks/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.techempower.com%2Fbenchmarks%2F%23hw%3Dph%26test%3Dplaintext%25C2%25A7ion%3Ddata-r23" target="_blank" title="https://www.techempower.com/benchmarks/#hw=ph&amp;test=plaintext%C2%A7ion=data-r23" ref="nofollow noopener noreferrer">www.techempower.com/benchmarks/…</a></li>
</ul>
<h2 data-id="heading-3">项目架构示意图（全场景应用开发支持）</h2>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ffec7fd062a4dcca42da8b415d223d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6J6bG855qE54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767230729&amp;x-signature=l1uv4ZJiw5NatU48qCWqYKkCSGk%3D" width="700" loading="lazy"/>
<h2 data-id="heading-4">v3.8.0 更新说明</h2>
<ul>
<li>插件 <code>solon-flow</code> 第六次预览</li>
<li>新增 <code>solon-flow-workflow</code> 插件（替代 FlowStatefulService）</li>
<li>新增 <code>solon-java25</code> 仓库（提供 ScopedValue 适配）</li>
<li>添加 <code>solon</code> ScopeLocal 接口（用于 ThreadLocal 到 ScopedValue 兼容）</li>
<li>添加 <code>solon</code> Solon.start(Class, MultiMap) 方法</li>
<li>添加 <code>solon</code> ThreadsUtil:newVirtualThreadFactory 方法</li>
<li>添加 <code>solon</code> ContextHolder:currentWith 方法，替代 currentSet（标为弃用）</li>
<li>添加 <code>solon</code> Controller:remoting 属性（可替代 @Remoting 注解）</li>
<li>添加 <code>solon</code> 非依赖关系的 bean 异步初始化（<code>@Init(async=true)</code>）</li>
<li>添加 <code>solon</code> Stringable 接口</li>
<li>添加 <code>solon</code> 'env.use' 配置支持（相对 'env'，它与 'env.on' 协作时不会冲突）</li>
<li>添加 <code>solon</code> 'server.session.cookieHttpOnly' 配置支持（默认为 true）</li>
<li>添加 <code>solon</code> Context.cookieSet(...,httpOnly) 方法</li>
<li>添加 <code>solon-test</code> HttpTester protocol 参数支持（方便 https 或 http 切换测试）</li>
<li>添加 <code>solon-serialization</code> JsonPropsUtil2.dateAsFormat 添加 java.sql.Timestamp 类型支持</li>
<li>添加 <code>solon-config-yaml</code> 依赖 solon-config-snack4 避免单个引入时忘掉</li>
<li>添加 <code>solon-net-httputils</code> HttpSslSupplierAny（方便无限制的 ssl 使用，但不建议）</li>
<li>添加 <code>solon-web-rx</code> RxEntity 类（方便对接 mcp-sdk）</li>
<li>添加 <code>solon-server</code> 会话状态的 cookie httpOnly 配置（默认为 false）</li>
<li>添加 <code>solon-server-tomcat</code> ssl 适配支持</li>
<li>添加 <code>solon-security-validation</code> ValidatorFailureHandlerI18n 支持验证注解的国际化处理
添加 <code>solon-expression</code> SnelParser 类，为 TemplateParser 和 EvaluateParser 提供出入口和占位符配置</li>
<li>添加 <code>solon-flow</code> FlowContext:lastNode() 方法（最后一个运行的节点）</li>
<li>添加 <code>solon-flow</code> FlowContext:lastNodeId() 方法（最后一个运行的节点Id）</li>
<li>添加 <code>solon-flow</code> Node.getMetaAs, Link.getMetaAs 方法</li>
<li>添加 <code>solon-flow</code> NodeSpec:linkRemove 方法（增强修改能力）</li>
<li>添加 <code>solon-flow</code> Graph:create(id,title,consumer) 方法</li>
<li>添加 <code>solon-flow</code> Graph:copy(graph,consumer) 方法（方便复制后修改）</li>
<li>添加 <code>solon-flow</code> GraphSpec:getNode(id) 方法</li>
<li>添加 <code>solon-flow</code> GraphSpec:addLoop(id) 方法替代 addLooping（后者标为弃用）</li>
<li>添加 <code>solon-flow</code> FlowEngine:eval(Graph, ..) 系列方法</li>
<li>添加 <code>solon-ai</code> FunctionPrompt:handleAsync（用于 mcp-server 异步支持）</li>
<li>添加 <code>solon-ai</code> FunctionResource:handleAsync（用于 mcp-server 异步支持）</li>
<li>添加 <code>solon-ai</code> FunctionTool:handleAsync（用于 mcp-server 异步支持）</li>
<li>添加 <code>solon-ai-core</code> ChatMessage:toNdjson,fromNdjson 方法（替代 ChatSession:toNdjson, loadNdjson），新方法机制上更自由</li>
<li>添加 <code>solon-ai-core</code> ToolSchemaUtil.jsonSchema Publisher 泛型支持</li>
<li>添加 <code>solon-ai-mcp</code> mcp-java-sdk v0.17 适配（支持 2025-06-18 版本协议）</li>
<li>添加 <code>solon-ai-mcp</code> mcp-server 异步支持</li>
<li>添加 <code>solon-ai-mcp</code> mcp-server streamable_stateless 支持</li>
<li>添加 <code>solon-ai-mcp</code> Tool,Resource,Prompt 对 org.reactivestreams.Publisher 异步返回支持</li>
<li>添加 <code>solon-ai-mcp</code> McpServerHost 服务宿主接口，用于隔离有状态与无状态服务</li>
<li>添加 <code>solon-ai-mcp</code> McpChannel.STREAMABLE_STATELESS （服务端）无状态会话</li>
<li>添加 <code>solon-ai-mcp</code> McpClientProvider:customize 方法（用于扩展 roots, sampling 等）</li>
<li>添加 <code>solon-ai-mcp</code> mcpServer McpAsyncServerExchange 注入支持（用于扩展 roots, sampling 等）</li>
<li>优化 <code>solon</code> api-version 版本匹配</li>
<li>优化 <code>solon</code> SnelUtil snel 表达式缺参数时异常提示（避免配错名字）</li>
<li>优化 <code>solon</code> ParamWrap:getName 改用 ParamSpec.getAlias。加 '@Param(name=xxx)' 注解可生效</li>
<li>优化 <code>solon-cache</code> CacheService 适配没有 _cacheKeyHead 配置时，则不加前缀</li>
<li>优化 <code>solon-net-httputils</code> SslContextBuilder</li>
<li>优化 <code>solon-expression</code> EvaluateParser 支持定义占位符（可支持 <code>{xxx}</code> 表达式）</li>
<li>优化 <code>solon-expression</code> TemplateParser 支持定义占位符（可支持 <code>{xxx}</code> 表达式）</li>
<li>优化 <code>solon-expression</code> LRUCache 性能（提高缓存性能）</li>
<li>优化 <code>solon-ai-dialect-openai</code> claude 兼容性</li>
<li>优化 <code>solon-ai-mcp mcp</code> StreamableHttp 模式下 服务端正常返回时 客户端异常日志打印的情况* 优化 <code>solon-flow</code> eval(Node startNode) 处理，改为从 root 开始恢复到 start 再开始执行（恢复过程中，不会执行任务）</li>
<li>优化 <code>solon-flow</code> FlowEngine:eval(Node startNode) 处理，改为从 root 开始恢复到 start 再开始执行（恢复过程中，不会执行任务）</li>
<li>调整 <code>nami</code> NamiAttachment 切换为 ScopeLocal 接口实现</li>
<li>调整 <code>solon</code> ContextHolder 切换为 ScopeLocal 接口实现</li>
<li>调整 <code>solon</code> RunHolder：parallelExecutor 改为 newFixedThreadPool</li>
<li>调整 <code>solon-data</code> TranExecutorDefault 切换为 ScopeLocal 接口实现</li>
<li>调整 <code>local-solon-cloud-plugin</code> 的 config 和 i18n 服务，如果没有 group 配置，则文件不带 group 前缀（之前默认给了 DEFAULT_GROUP 组名，显得复杂）</li>
<li>调整 <code>rocketmq-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）</li>
<li>调整 <code>aliyun-ons-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）</li>
<li>调整 <code>rocketmq5-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）。添加 sql92 过滤支持</li>
<li>调整 <code>solon-flow</code> 移除 Activity 节点预览属性 "<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">"</mi><mtext>和</mtext><mi mathvariant="normal">"</mi></mrow><annotation encoding="application/x-tex">imode" 和 "</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">im</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">"</span><span class="mord cjk_fallback">和</span><span class="mord">"</span></span></span></span></span>omode"</li>
<li>调整 <code>solon-flow</code> Activity 节点流出改为自由模式（可以多线流出：无条件直接流出，有条件检测后流出）</li>
<li>调整 <code>solon-flow</code> Node.getMeta 方法返回改为 Object 类型（并新增 getMetaAs）</li>
<li>调整 <code>solon-flow</code> Evaluation:runTest 改为 runCondition</li>
<li>调整 <code>solon-flow</code> FlowContext:incrAdd,incrGet 标为弃用（上下文数据为型只能由输入侧决定）</li>
<li>调整 <code>solon-flow</code> Condition 更名为 ConditionDesc</li>
<li>调整 <code>solon-flow</code> Task 更名为 ConditionDesc</li>
<li>调整 <code>solon-flow</code> XxxDecl 命名风格改为 XxxSpec</li>
<li>调整 <code>solon-flow</code> GraphDecl.parseByXxx 命名风格改为 GraphSpec.fromXxx</li>
<li>调整 <code>solon-flow</code> Graph.parseByXxx 命名风格改为 Graph.fromXxx</li>
<li>调整 <code>solon-ai-mcp</code> getResourceTemplates、getResources 不再共享注册</li>
<li>调整 <code>solon-ai-mcp</code> McpServerManager 内部接口更名为 McpPrimitivesRegistry （MCP 原语注册器）</li>
<li>调整 <code>solon-ai-mcp</code> McpClientProvider 默认不启用心跳机制（随着 mcp-sdk 的成熟，server 都有心跳机制了）</li>
<li>修复 <code>solon</code> IndexFiles 路径表达式的兼容问题（添加转换 <code>*-&gt;@</code>、<code>:-&gt;!</code>）</li>
<li>修复 <code>solon</code> ParamWrap:getName 加 '@Param(name=xxx)' 注解时没有生效的问题（v3.7.0 出现）。对 solon-cache 会有影响</li>
<li>修复 <code>solon-web-vertx</code> VxWebContext._requestBody 如果为 null 文件上传时会出错的问题</li>
<li>修复 <code>solon-docs-openapi2</code> 返回类型中泛型失效的问题（v3.7.0 出现）</li>
<li>snack4 升为 4.0.20</li>
<li>jackson 升为 2.19.2</li>
<li>liquor 升为 1.6.6</li>
<li>asm 升为 9.9</li>
</ul>
<h4 data-id="heading-5">solon 仓库补充说明</h4>
<p>新特性：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
   <span class="hljs-keyword">static</span> ScopeLocal&lt;String&gt; LOCAL = ScopeLocal.newInstance();

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>{
       LOCAL.with(<span class="hljs-string">"test"</span>, ()-&gt;{
           System.out.println(LOCAL.get());
       });
   }
}
</code></pre>
<h4 data-id="heading-6">solon-ai 仓库补充说明</h4>
<p>新特性展示：1.MCP 无状态会话（STREAMABLE_STATELESS）和 2.CompletableFuture 异步MCP工具</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = "/mcp1")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpServerTool</span> {
    <span class="hljs-meta">@ToolMapping(description = "查询天气预报", returnDirect = true)</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">getWeather</span><span class="hljs-params">(<span class="hljs-meta">@Param(description = "城市位置")</span> String location)</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">"晴，14度"</span>);
    }
}
</code></pre>
<p>传输方式对应表：（服务端与客户端，须使用对应的传输方式才可通讯）</p>






























<table><thead><tr><th>服务端</th><th>客户端</th><th>备注</th></tr></thead><tbody><tr><td>STDIO</td><td>STDIO</td><td/></tr><tr><td>SSE</td><td>SSE</td><td/></tr><tr><td>STREAMABLE</td><td>STREAMABLE</td><td/></tr><tr><td>STREAMABLE_STATELESS</td><td>STREAMABLE</td><td>对 server 集群很友好</td></tr></tbody></table>
<ul>
<li>STREAMABLE_STATELESS 集群，不需要 ip_hash，但“原语”变化后无法通知 client</li>
</ul>
<h4 data-id="heading-7">solon-flow 仓库补充说明</h4>
<p>重要变化：</p>
<ul>
<li>取消“有状态”、“无状态”概念。</li>
<li>solon-flow 回归通用流程引擎（分离“有状态”的概念）。</li>
<li>新增 solon-flow-workflow 为工作流性质的封装（未来可能会有 dataflow 等）。</li>
</ul>
<p>兼容变化对照表：</p>






































































<table><thead><tr><th>旧名称</th><th>新名称</th><th>说明</th></tr></thead><tbody><tr><td><code>GraphDecl</code></td><td><code>GraphSpec</code></td><td>图定义</td></tr><tr><td><code>GraphDecl.parseByXxx</code></td><td><code>GraphSpec.fromXxx</code></td><td>图定义加载</td></tr><tr><td><code>Graph.parseByXxx</code></td><td><code>Graph.fromXxx</code></td><td>图加载</td></tr><tr><td><code>LinkDecl</code></td><td><code>LinkSpec</code></td><td>连接定义</td></tr><tr><td><code>NodeDecl</code></td><td><code>NodeSpec</code></td><td>节点定义</td></tr><tr><td><code>Condition</code></td><td><code>ConditionDesc</code></td><td>条件描述</td></tr><tr><td><code>Task</code></td><td><code>TaskDesc</code></td><td>任务描述（避免与 workflow 的概念冲突）</td></tr><tr><td/><td/><td/></tr><tr><td><code>FlowStatefulService</code></td><td><code>WorkflowService</code></td><td>工作流服务</td></tr><tr><td><code>StatefulTask</code></td><td><code>Task</code></td><td>任务</td></tr><tr><td><code>Operation</code></td><td><code>TaskAction</code></td><td>任动工作</td></tr><tr><td><code>TaskType</code></td><td><code>TaskState</code></td><td>任务状态</td></tr></tbody></table>
<p>FlowStatefulService 到 WorkflowService 的接口变化对照表：</p>


















































<table><thead><tr><th>旧名称</th><th>新名称</th><th>说明</th></tr></thead><tbody><tr><td><code>postOperation(..)</code></td><td><code>postTask(..)</code></td><td>提交任务</td></tr><tr><td><code>postOperationIfWaiting(..)</code></td><td><code>postTaskIfWaiting(..)</code></td><td>提交任务</td></tr><tr><td/><td/><td/></tr><tr><td><code>evel(..)</code></td><td>/</td><td>执行</td></tr><tr><td><code>stepForward(..)</code></td><td>/</td><td>单步前进</td></tr><tr><td><code>stepBack(..)</code></td><td>/</td><td>单步后退</td></tr><tr><td/><td/><td/></tr><tr><td>/</td><td><code>getState(..)</code></td><td>获取状态</td></tr></tbody></table>
<p>新特性预览：Graph 硬编码方式（及修改能力增强）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//硬编码</span>
<span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=</span> Graph.create(<span class="hljs-string">"demo1"</span>, <span class="hljs-string">"示例"</span>, spec -&gt; {
    spec.addStart(<span class="hljs-string">"start"</span>).title(<span class="hljs-string">"开始"</span>).linkAdd(<span class="hljs-string">"01"</span>);
    spec.addActivity(<span class="hljs-string">"n1"</span>).task(<span class="hljs-string">"@AaMetaProcessCom"</span>).linkAdd(<span class="hljs-string">"end"</span>);
    spec.addEnd(<span class="hljs-string">"end"</span>).title(<span class="hljs-string">"结束"</span>);
});

<span class="hljs-comment">//修改</span>
<span class="hljs-type">Graph</span> <span class="hljs-variable">graphNew</span> <span class="hljs-operator">=</span> Graph.copy(graph, spec -&gt; {
    spec.getNode(<span class="hljs-string">"n1"</span>).linkRemove(<span class="hljs-string">"end"</span>).linkAdd(<span class="hljs-string">"n2"</span>); <span class="hljs-comment">//移掉 n1 连接；改为 n2 连接</span>
    spec.addActivity(<span class="hljs-string">"n2"</span>).linkAdd(<span class="hljs-string">"end"</span>);
});
</code></pre>
<p>新特性预览：FlowContext:lastNodeId （计算的中断与恢复）。参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsolon.noear.org%2Farticle%2F1246" target="_blank" title="https://solon.noear.org/article/1246" ref="nofollow noopener noreferrer">solon.noear.org/article/124…</a></p>
<pre><code class="hljs language-java" lang="java">flowEngine.eval(graph, context.lastNodeId(), context);
<span class="hljs-comment">//...（从上一个节点开始执行）</span>
flowEngine.eval(graph, context.lastNodeId(), context);
</code></pre>
<p>新特性预览：WorkflowService（替代 FlowStatefulService）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">WorkflowService</span> <span class="hljs-variable">workflow</span> <span class="hljs-operator">=</span> WorkflowService.of(engine, WorkflowDriver.builder()
        .stateController(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActorStateController</span>()) 
        .stateRepository(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryStateRepository</span>()) 
        .build());


<span class="hljs-comment">//1. 取出任务</span>
<span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> workflow.getTask(graph, context);

<span class="hljs-comment">//2. 提交任务</span>
workflow.postTask(task.getNode(), TaskAction.FORWARD, context);
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[知识库-向量化功能-流式分片]]></title>    <link>https://juejin.cn/post/7587264707285024778</link>    <guid>https://juejin.cn/post/7587264707285024778</guid>    <pubDate>2025-12-25T01:40:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587264707285024778" data-draft-id="7586614240531857434" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="知识库-向量化功能-流式分片"/> <meta itemprop="keywords" content="后端,Elasticsearch"/> <meta itemprop="datePublished" content="2025-12-25T01:40:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="造轮子的猪"/> <meta itemprop="url" content="https://juejin.cn/user/497453720940158"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            知识库-向量化功能-流式分片
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/497453720940158/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    造轮子的猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:40:14.000Z" title="Thu Dec 25 2025 01:40:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">知识库-向量化功能-流式分片</h2>
<h3 data-id="heading-1">一、设计背景</h3>
<p>针对超大文本（如100MB以上纯文本文件），传统“一次性加载全部文本到内存再分片”的方式易导致内存溢出、方法卡死等问题。因此采用<strong>流式分片策略</strong>：逐批次读取文本到缓冲区，按需生成分片，全程不加载完整文本到内存，大幅降低内存占用。</p>
<h3 data-id="heading-2">二、核心逻辑</h3>
<ol>
<li><strong>流式读取</strong>：通过<code>Reader</code>逐缓冲区读取文本，避免一次性加载全量内容；</li>
<li><strong>批次分片</strong>：对每批次读取的文本按句子结束符分割，保证分片语义完整性；</li>
<li><strong>兜底机制</strong>：设置最小递增步长、最大循环次数，避免死循环；</li>
<li><strong>重叠处理</strong>：分片间保留重叠字符，防止跨批次句子语义断裂；</li>
<li><strong>剩余文本处理</strong>：合并未处理完的文本到下一批次，保证分片完整性。</li>
</ol>
<h3 data-id="heading-3">三、核心实现代码</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.Reader;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.regex.Pattern;

<span class="hljs-comment">/**
 * 超大文本流式分片工具类
 * 核心：按需读取、按需分片，避免一次性加载全量文本到内存
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamTextSplitter</span> {
    <span class="hljs-comment">// 句子结束符正则（覆盖中英文结束符）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">SENTENCE_END_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">"[。！？；\\n\\.!?;]"</span>);
    <span class="hljs-comment">// 单分片最大字符数（可根据模型上下文调整）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_CHUNK_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
    <span class="hljs-comment">// 分片重叠字符数（避免跨分片语义断裂）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHUNK_OVERLAP</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;
    <span class="hljs-comment">// 最小递增步长（防止死循环）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_STEP</span> <span class="hljs-operator">=</span> MAX_CHUNK_LENGTH / <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 最大循环次数（兜底，避免无限循环）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOOP_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;

    <span class="hljs-comment">/**
     * 流式分片：核心方法，按需生成文本分片
     * <span class="hljs-doctag">@param</span> textReader 文本流式读取器（支持FileReader/InputStreamReader等）
     * <span class="hljs-doctag">@param</span> bufferSize 缓冲区大小（建议8192/16384字符，平衡IO次数与内存占用）
     * <span class="hljs-doctag">@return</span> 分片迭代器（按需遍历，不一次性加载所有分片到内存）
     * <span class="hljs-doctag">@throws</span> IOException 文本读取异常
     */</span>
    <span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title function_">streamSplitText</span><span class="hljs-params">(Reader textReader, <span class="hljs-type">int</span> bufferSize)</span> <span class="hljs-keyword">throws</span> IOException {
        List&lt;String&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        List&lt;String&gt; currentBatchChunks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[bufferSize];
        <span class="hljs-type">int</span> readLen;
        <span class="hljs-comment">// 上一批次未处理完的文本（合并到下一批）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">remainingText</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;

        <span class="hljs-comment">// 逐缓冲区读取文本</span>
        <span class="hljs-keyword">while</span> ((readLen = textReader.read(buffer)) != -<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 拼接：剩余文本 + 新读取的文本</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">batchText</span> <span class="hljs-operator">=</span> remainingText + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, readLen);
            <span class="hljs-comment">// 对当前批次文本进行分片</span>
            List&lt;String&gt; batchChunks = splitBatchText(batchText);

            <span class="hljs-keyword">if</span> (!batchChunks.isEmpty()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">lastChunk</span> <span class="hljs-operator">=</span> batchChunks.get(batchChunks.size() - <span class="hljs-number">1</span>);
                <span class="hljs-comment">// 判断最后一个分片是否为“不完整分片”（长度&lt;最大长度的1/2）</span>
                <span class="hljs-keyword">if</span> (lastChunk.length() &lt; MAX_CHUNK_LENGTH / <span class="hljs-number">2</span>) {
                    <span class="hljs-comment">// 不完整分片：保留到下一批次处理</span>
                    remainingText = lastChunk;
                    <span class="hljs-comment">// 完整分片：加入结果集</span>
                    currentBatchChunks.addAll(batchChunks.subList(<span class="hljs-number">0</span>, batchChunks.size() - <span class="hljs-number">1</span>));
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 最后一个分片完整：清空剩余文本，全部加入</span>
                    remainingText = <span class="hljs-string">""</span>;
                    currentBatchChunks.addAll(batchChunks);
                }
            }

            <span class="hljs-comment">// 批量添加到结果集，减少内存波动</span>
            results.addAll(currentBatchChunks);
            currentBatchChunks.clear();
        }

        <span class="hljs-comment">// 处理最后剩余的文本（非空则作为最后一个分片）</span>
        <span class="hljs-keyword">if</span> (!remainingText.isEmpty()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">lastChunk</span> <span class="hljs-operator">=</span> remainingText.trim();
            <span class="hljs-keyword">if</span> (!lastChunk.isEmpty()) {
                results.add(lastChunk);
            }
        }

        <span class="hljs-comment">// 返回迭代器，支持按需遍历</span>
        <span class="hljs-keyword">return</span> results.iterator();
    }

    <span class="hljs-comment">/**
     * 批次文本分片：对单批次文本按句子结束符分割，保证语义完整
     * <span class="hljs-doctag">@param</span> text 单批次读取的文本
     * <span class="hljs-doctag">@return</span> 该批次的文本分片列表
     */</span>
    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">splitBatchText</span><span class="hljs-params">(String text)</span> {
        List&lt;String&gt; chunks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-type">int</span> <span class="hljs-variable">textLength</span> <span class="hljs-operator">=</span> text.length();
        <span class="hljs-keyword">if</span> (textLength == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> chunks;
        }

        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">loopCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

        <span class="hljs-comment">// 循环分片，直到处理完当前批次文本或达到最大循环次数</span>
        <span class="hljs-keyword">while</span> (start &lt; textLength &amp;&amp; loopCount &lt; MAX_LOOP_COUNT) {
            loopCount++;
            <span class="hljs-comment">// 1. 基础结束位置（不超过最大分片长度）</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.min(start + MAX_CHUNK_LENGTH, textLength);
            <span class="hljs-comment">// 2. 调整结束位置到最近的句子结束符（保证语义完整）</span>
            end = adjustToSentenceEnd(text, start, end);
            <span class="hljs-comment">// 3. 截取分片并去空</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">chunk</span> <span class="hljs-operator">=</span> text.substring(start, end).trim();
            <span class="hljs-keyword">if</span> (!chunk.isEmpty()) {
                chunks.add(chunk);
            }

            <span class="hljs-comment">// 4. 计算下一个分片的起始位置（核心：避免死循环）</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">nextStart</span> <span class="hljs-operator">=</span> end - CHUNK_OVERLAP;
            nextStart = Math.max(nextStart, start + MIN_STEP); <span class="hljs-comment">// 至少递增最小步长</span>
            nextStart = Math.min(nextStart, textLength);       <span class="hljs-comment">// 不超过文本长度</span>

            <span class="hljs-comment">// 5. 终止条件：起始位置不再递增（防止死循环）</span>
            <span class="hljs-keyword">if</span> (nextStart &lt;= start) {
                <span class="hljs-keyword">break</span>;
            }
            start = nextStart;
        }

        <span class="hljs-comment">// 兜底：处理最后剩余的文本（循环终止后仍有未处理内容）</span>
        <span class="hljs-keyword">if</span> (start &lt; textLength) {
            <span class="hljs-type">String</span> <span class="hljs-variable">lastChunk</span> <span class="hljs-operator">=</span> text.substring(start).trim();
            <span class="hljs-keyword">if</span> (!lastChunk.isEmpty()) {
                chunks.add(lastChunk);
            }
        }

        <span class="hljs-comment">// 日志提示：循环次数达上限（需排查文本格式问题）</span>
        <span class="hljs-keyword">if</span> (loopCount &gt;= MAX_LOOP_COUNT) {
            System.err.printf(<span class="hljs-string">"批次文本分片循环次数达上限（%d次），可能存在异常文本格式！文本长度：%d%n"</span>, MAX_LOOP_COUNT, textLength);
        }

        <span class="hljs-keyword">return</span> chunks;
    }

    <span class="hljs-comment">/**
     * 调整分片结束位置到句子末尾（优化：避免过度回溯）
     * <span class="hljs-doctag">@param</span> text 待分片文本
     * <span class="hljs-doctag">@param</span> start 分片起始位置
     * <span class="hljs-doctag">@param</span> end 基础结束位置
     * <span class="hljs-doctag">@return</span> 调整后的结束位置（保证语义完整）
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjustToSentenceEnd</span><span class="hljs-params">(String text, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
        <span class="hljs-comment">// 已到文本末尾，直接返回</span>
        <span class="hljs-keyword">if</span> (end &gt;= text.length()) {
            <span class="hljs-keyword">return</span> end;
        }

        <span class="hljs-comment">// 截取当前分片范围的文本</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">subText</span> <span class="hljs-operator">=</span> text.substring(start, end);
        <span class="hljs-comment">// 查找最后一个句子结束符的位置</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">lastEndPos</span> <span class="hljs-operator">=</span> findLastSentenceEnd(subText);

        <span class="hljs-comment">// 仅当回溯后分片长度≥最小有效长度时，才调整（避免过短分片）</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">minValidLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;
        <span class="hljs-keyword">if</span> (lastEndPos != -<span class="hljs-number">1</span>) {
            <span class="hljs-type">int</span> <span class="hljs-variable">adjustedEnd</span> <span class="hljs-operator">=</span> start + lastEndPos + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (adjustedEnd - start &gt;= minValidLength) {
                <span class="hljs-keyword">return</span> adjustedEnd;
            }
        }

        <span class="hljs-comment">// 无有效句子结束符，返回基础结束位置</span>
        <span class="hljs-keyword">return</span> end;
    }

    <span class="hljs-comment">/**
     * 查找文本中最后一个句子结束符的位置
     * <span class="hljs-doctag">@param</span> text 待查找文本
     * <span class="hljs-doctag">@return</span> 最后一个结束符的索引（无则返回-1）
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLastSentenceEnd</span><span class="hljs-params">(String text)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> text.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> (SENTENCE_END_PATTERN.matcher(String.valueOf(text.charAt(i))).matches()) {
                <span class="hljs-keyword">return</span> i;
            }
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<h3 data-id="heading-4">四、使用方法</h3>
<h4 data-id="heading-5">4.1 基础使用（读取本地超大文本文件）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.io.FileReader;
<span class="hljs-keyword">import</span> java.io.Reader;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamSplitterDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 1. 初始化流式分片工具</span>
        <span class="hljs-type">StreamTextSplitter</span> <span class="hljs-variable">splitter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTextSplitter</span>();
        <span class="hljs-comment">// 2. 定义文件路径和缓冲区大小（建议8192字符）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">"D:/large_text.txt"</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;

        <span class="hljs-keyword">try</span> (<span class="hljs-type">Reader</span> <span class="hljs-variable">textReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath)) {
            <span class="hljs-comment">// 3. 执行流式分片，获取迭代器</span>
            Iterator&lt;String&gt; chunkIterator = splitter.streamSplitText(textReader, bufferSize);

            <span class="hljs-comment">// 4. 按需遍历分片（逐一分片处理，不加载全量到内存）</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">chunkIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (chunkIterator.hasNext()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">chunk</span> <span class="hljs-operator">=</span> chunkIterator.next();
                chunkIndex++;
                <span class="hljs-comment">// 业务处理：如向量化、存储到ES等</span>
                System.out.printf(<span class="hljs-string">"分片%d：长度=%d，内容预览：%s%n"</span>,
                        chunkIndex,
                        chunk.length(),
                        chunk.substring(<span class="hljs-number">0</span>, Math.min(chunk.length(), <span class="hljs-number">50</span>))); <span class="hljs-comment">// 预览前50字符</span>
            }

            System.out.printf(<span class="hljs-string">"分片完成，共生成%d个分片%n"</span>, chunkIndex);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.err.println(<span class="hljs-string">"流式分片失败："</span> + e.getMessage());
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 data-id="heading-6">4.2 结合文件上传场景（InputStreamReader）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;
<span class="hljs-keyword">import</span> java.io.InputStreamReader;
<span class="hljs-keyword">import</span> java.io.Reader;
<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;

<span class="hljs-comment">/**
 * 处理上传的超大文本文件（如TXT/CSV）
 * <span class="hljs-doctag">@param</span> file 上传的文件
 * <span class="hljs-doctag">@throws</span> Exception 处理异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processUploadedLargeFile</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-type">StreamTextSplitter</span> <span class="hljs-variable">splitter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTextSplitter</span>();
    <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">16384</span>; <span class="hljs-comment">// 大文件建议增大缓冲区</span>

    <span class="hljs-comment">// 基于文件输入流创建Reader（指定UTF-8编码避免乱码）</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(file.getInputStream(), StandardCharsets.UTF_8)) {
        Iterator&lt;String&gt; chunkIterator = splitter.streamSplitText(reader, bufferSize);

        <span class="hljs-comment">// 遍历分片，逐个向量化并存储</span>
        <span class="hljs-keyword">while</span> (chunkIterator.hasNext()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">chunk</span> <span class="hljs-operator">=</span> chunkIterator.next();
            <span class="hljs-comment">// 调用向量化方法</span>
            <span class="hljs-comment">// float[] vector = embeddingModel.embed(chunk);</span>
            <span class="hljs-comment">// 存储到ES</span>
            <span class="hljs-comment">// esService.saveChunk(chunk, vector);</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-7">4.3 结合PDF/Word解析（流式处理解析结果）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 流式处理PDF解析后的超大文本
 * <span class="hljs-doctag">@param</span> pdfFilePath PDF文件路径
 * <span class="hljs-doctag">@throws</span> Exception 处理异常
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">streamProcessPdf</span><span class="hljs-params">(String pdfFilePath)</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// 1. 解析PDF获取文本（参考PDF解析文档）</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">pdfText</span> <span class="hljs-operator">=</span> PdfTextExtractor.getContent(pdfFilePath);
    <span class="hljs-comment">// 2. 将字符串转为Reader（模拟流式读取）</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StringReader(pdfText)) {
        <span class="hljs-type">StreamTextSplitter</span> <span class="hljs-variable">splitter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTextSplitter</span>();
        Iterator&lt;String&gt; chunkIterator = splitter.streamSplitText(reader, <span class="hljs-number">8192</span>);

        <span class="hljs-comment">// 3. 逐分片处理</span>
        <span class="hljs-keyword">while</span> (chunkIterator.hasNext()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">chunk</span> <span class="hljs-operator">=</span> chunkIterator.next();
            <span class="hljs-comment">// 向量化+存储逻辑</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-8">五、核心设计说明</h3>
<h4 data-id="heading-9">5.1 关键参数说明</h4>



































<table><thead><tr><th>参数名</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>MAX_CHUNK_LENGTH</td><td>1000</td><td>单分片最大字符数，需匹配嵌入模型上下文窗口（如num_ctx=1024）</td></tr><tr><td>CHUNK_OVERLAP</td><td>100</td><td>分片间重叠字符数，避免跨分片句子语义断裂（如“我是一个测试文本”被截断为“我是一个”和“测试文本”）</td></tr><tr><td>MIN_STEP</td><td>500</td><td>最小递增步长，防止因重叠导致start位置不递增，触发死循环</td></tr><tr><td>MAX_LOOP_COUNT</td><td>100</td><td>最大循环次数，兜底处理异常文本（如无句子结束符的超长文本）</td></tr><tr><td>bufferSize</td><td>8192/16384</td><td>缓冲区大小，建议为2的幂次，平衡IO次数与内存占用</td></tr></tbody></table>
<h4 data-id="heading-10">5.2 核心优势</h4>





























<table><thead><tr><th>优势</th><th>解决的问题</th></tr></thead><tbody><tr><td>流式读取</td><td>避免一次性加载超大文本到内存，防止OOM/方法卡死</td></tr><tr><td>句子结束符分割</td><td>保证分片语义完整性，避免生硬截断导致的向量化误差</td></tr><tr><td>剩余文本合并</td><td>防止跨批次文本丢失，保证分片完整性</td></tr><tr><td>多重兜底机制</td><td>最小步长+最大循环次数，彻底避免死循环</td></tr><tr><td>迭代器返回</td><td>支持按需遍历，分片处理完成后立即释放内存</td></tr></tbody></table>
<h3 data-id="heading-11">六、注意事项</h3>
<ol>
<li><strong>编码一致性</strong>：创建<code>Reader</code>时需指定编码（如UTF-8），避免不同编码导致的字符解析错误；</li>
<li><strong>缓冲区大小调整</strong>：小文件（&lt;1MB）建议用8192，超大文件（&gt;100MB）建议用16384/32768，减少IO次数；</li>
<li><strong>异常文本处理</strong>：若文本无任何句子结束符（如纯数字/乱码），会触发兜底按最大长度分割，需在日志中监控此类情况；</li>
<li><strong>资源释放</strong>：必须通过<code>try-with-resources</code>关闭<code>Reader</code>，避免文件句柄泄漏；</li>
<li><strong>性能优化</strong>：分片处理（向量化/存储）建议结合线程池异步执行，提升整体效率；</li>
<li><strong>内存监控</strong>：处理GB级文本时，建议监控JVM堆内存，避免缓冲区+分片结果集占用过多内存；</li>
<li><strong>特殊字符处理</strong>：若文本包含大量特殊符号（如\t/\r），需在分片前先格式化清理。</li>
</ol>
<h3 data-id="heading-12">七、扩展建议</h3>
<ol>
<li><strong>自定义结束符</strong>：开放<code>SENTENCE_END_PATTERN</code>配置，支持业务自定义句子结束符；</li>
<li><strong>分片过滤</strong>：增加空分片/短分片过滤逻辑（如过滤长度&lt;50的分片）；</li>
<li><strong>进度回调</strong>：增加分片进度回调函数，便于前端展示处理进度；</li>
<li><strong>批量写入</strong>：结合ES的bulk写入，积累一定数量分片后批量存储，减少网络请求；</li>
<li><strong>超时控制</strong>：为分片处理增加超时机制，避免单个分片处理耗时过长；</li>
<li><strong>监控指标</strong>：统计分片总数、平均分片长度、处理耗时，便于性能调优；</li>
<li><strong>自适应缓冲区</strong>：根据文本读取速度动态调整缓冲区大小，平衡性能与内存。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PyTorch 2.0 核心技术深度解析torch.compile 从原理到实践]]></title>    <link>https://juejin.cn/post/7587325326045675529</link>    <guid>https://juejin.cn/post/7587325326045675529</guid>    <pubDate>2025-12-25T01:55:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587325326045675529" data-draft-id="7587336857537658889" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PyTorch 2.0 核心技术深度解析torch.compile 从原理到实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-25T01:55:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="故旧"/> <meta itemprop="url" content="https://juejin.cn/user/3006493596857081"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PyTorch 2.0 核心技术深度解析torch.compile 从原理到实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3006493596857081/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    故旧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:55:51.000Z" title="Thu Dec 25 2025 01:55:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>PyTorch 2.0 核心技术深度解析torch.compile 从原理到实践</strong></h2>
<h3 data-id="heading-1"><strong>引言</strong></h3>
<p>随着深度学习模型复杂度的不断提升，模型推理和训练的性能优化成为了业界关注的焦点。PyTorch 2.0 引入的 torch.compile 功能，通过即时编译（JIT）技术实现了显著的性能提升。本文将从技术原理、架构设计到实际应用，全面解析这一革命性特性。</p>
<h3 data-id="heading-2"><strong>1. 技术背景与定位</strong></h3>
<h4 data-id="heading-3"><strong>1.1 从 Eager 到 Graph 模式的演进</strong></h4>
<p>传统的 PyTorch 采用 <strong>Eager 执行模式</strong>，每个操作都会立即执行，这种方式虽然调试友好，但存在以下性能瓶颈：</p>
<p>● <strong>Python 解释器开销</strong>：频繁的 Python 函数调用</p>
<p>● <strong>内存访问效率低</strong>：无法进行全局内存优化</p>
<p>● <strong>算子融合困难</strong>：缺乏全局视图进行优化</p>
<p>torch.compile 作为 <strong>Graph 模式</strong> 的新实现，与 TorchScript 和 FX Tracing 并列，通过以下方式解决性能问题：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 传统 Eager 模式</span>
def traditional_forward(x, y):    
    <span class="hljs-attr">a</span> = torch.sin(x)      <span class="hljs-comment"># 立即执行    </span>
    <span class="hljs-attr">b</span> = torch.cos(y)      <span class="hljs-comment"># 立即执行      </span>
    return a + b          <span class="hljs-comment"># 立即执行</span>
<span class="hljs-comment"># torch.compile 优化后@</span>
torch.compiledef optimized_forward(x, y):    
    <span class="hljs-attr">a</span> = torch.sin(x)      <span class="hljs-comment"># 图捕获   </span>
    <span class="hljs-attr">b</span> = torch.cos(y)      <span class="hljs-comment"># 图捕获    </span>
    return a + b          <span class="hljs-comment"># 生成融合kernel</span>
</code></pre>
<h4 data-id="heading-4"><strong>1.2 核心优势</strong></h4>
<p>● <strong>零代码修改</strong>：仅需添加装饰器或函数调用</p>
<p>● <strong>动态图支持</strong>：保持 PyTorch 的灵活性</p>
<p>● <strong>显著性能提升</strong>：典型场景下 1.3-2x 加速比</p>
<h3 data-id="heading-5"><strong>2. 使用方式与最佳实践</strong></h3>
<h4 data-id="heading-6"><strong>2.1 基础用法</strong></h4>
<pre><code class="hljs language-ini" lang="ini">import torch
<span class="hljs-comment"># 方式1：函数调用</span>
def model_forward(x, y):    
    <span class="hljs-attr">a</span> = torch.sin(x)    
    <span class="hljs-attr">b</span> = torch.cos(y)    
    return a + <span class="hljs-attr">bcompiled_model</span> = torch.compile(model_forward)
    <span class="hljs-attr">result</span> = compiled_model(torch.randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>), torch.randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>))
<span class="hljs-comment"># 方式2：装饰器（推荐）</span>
@torch.compiledef optimized_model(x, y):    
    <span class="hljs-attr">a</span> = torch.sin(x)    
    <span class="hljs-attr">b</span> = torch.cos(y)    
    return a + <span class="hljs-attr">bresult</span> = optimized_model(torch.randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>), torch.randn(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>))
</code></pre>
<h4 data-id="heading-7"><strong>2.2 高级配置</strong></h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 自定义编译选项</span>
@torch.compile(    
    <span class="hljs-attr">mode</span>=<span class="hljs-string">"max-autotune"</span>,    <span class="hljs-comment"># 最大优化模式    </span>
    <span class="hljs-attr">backend</span>=<span class="hljs-string">"inductor"</span>,     <span class="hljs-comment"># 指定后端    </span>
    <span class="hljs-attr">dynamic</span>=<span class="hljs-literal">True</span>           <span class="hljs-comment"># 支持动态shape</span>
)
def advanced_model(x):    
    return torch.nn.functional.relu(x @ x.T)
</code></pre>
<h3 data-id="heading-8"><strong>3. 核心架构深度解析</strong></h3>
<h4 data-id="heading-9"><strong>3.1 整体流程概览</strong></h4>
<p>torch.compile 的工作流程可以分为三个核心阶段：</p>
<p>[MISSING IMAGE: , ]</p>
<p>null</p>
<ol>
<li><strong>图捕获（TorchDynamo）</strong> ：将 Python 代码转换为 FX 图</li>
<li><strong>图优化（AOT Autograd）</strong> ：进行算子融合和内存优化</li>
<li><strong>代码生成（TorchInductor）</strong> ：生成高性能的底层代码</li>
</ol>
<h4 data-id="heading-10"><strong>3.2 TorchDynamo：Python 字节码的魔法师</strong></h4>
<p>TorchDynamo 是整个系统的核心，它通过 <strong>CPython Frame Evaluation Hook</strong> 实现了对 Python 字节码的动态重写。</p>
<p>[MISSING IMAGE: , ]</p>
<p>null</p>
<h5 data-id="heading-11"><strong>3.2.1 CPython Frame Evaluation Hook 机制</strong></h5>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 简化的工作流程</span>
def custom_eval_frame(frame, exc):    
    <span class="hljs-comment"># 1. 检查是否需要跳过编译    </span>
    if should_skip_frame(frame):        
        return default_eval_frame(frame, exc)        
    
    <span class="hljs-comment"># 2. 检查缓存    </span>
    <span class="hljs-attr">cached_code</span> = check_cache(frame.f_code)    
    if cached_code and guards_check_passed():        
        return execute_compiled_code(cached_code)        
    
    <span class="hljs-comment"># 3. 符号执行和图捕获    </span>
    fx_graph, <span class="hljs-attr">guards</span> = symbolic_evaluation(frame.f_code)        
    
    <span class="hljs-comment"># 4. 后端编译    </span>
    <span class="hljs-attr">compiled_fn</span> = backend_compile(fx_graph)        
    <span class="hljs-comment"># 5. 生成新字节码并缓存    </span>
    <span class="hljs-attr">new_bytecode</span> = generate_wrapper_code(compiled_fn)    
    cache_result(frame.f_code, new_bytecode, guards)        
    return execute_compiled_code(new_bytecode)
</code></pre>
<h5 data-id="heading-12"><strong>3.2.2 Guards 机制：动态属性的守护者</strong></h5>
<p>Guards 是 TorchDynamo 确保编译结果正确性的关键机制：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 示例：tensor shape guard</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">shape_guard</span>(<span class="hljs-params">tensor, expected_shape</span>):    
    <span class="hljs-keyword">return</span> tensor.shape == expected_shape
<span class="hljs-comment"># 示例：数据类型 guard  </span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">dtype_guard</span>(<span class="hljs-params">tensor, expected_dtype</span>):    
    <span class="hljs-keyword">return</span> tensor.dtype == expected_dtype
</code></pre>
<p>当 guards 检查失败时，会触发：</p>
<ul>
<li><strong>Graph Break</strong>：回退到 eager 模式</li>
<li><strong>Recompilation</strong>：重新编译生成新的优化代码</li>
</ul>
<h4 data-id="heading-13"><strong>3.3 TorchInductor：高性能代码的生成器</strong></h4>
<p>TorchInductor 作为默认后端，负责将 FX 图转换为高效的底层代码。</p>
<p>[MISSING IMAGE: , ]</p>
<p>null</p>
<h5 data-id="heading-14"><strong>3.3.1 算子分解（Operator Decomposition）</strong></h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 复杂算子分解为基础算子</span>
<span class="hljs-meta">@register_decomposition(<span class="hljs-params">torch.ops.aten.log2</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">log2_decomposition</span>(<span class="hljs-params">x</span>):    
    log2_scale = <span class="hljs-number">1</span> / math.log(<span class="hljs-number">2</span>)    
    <span class="hljs-keyword">return</span> torch.log(x) * log2_scale
​
<span class="hljs-meta">@register_decomposition(<span class="hljs-params">torch.ops.aten.gelu</span>)  </span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">gelu_decomposition</span>(<span class="hljs-params">x</span>):    
    <span class="hljs-keyword">return</span> x * <span class="hljs-number">0.5</span> * (<span class="hljs-number">1.0</span> + torch.erf(x / math.sqrt(<span class="hljs-number">2.0</span>)))
</code></pre>
<h5 data-id="heading-15"><strong>3.3.2 IR 降级：从 FX 图到 Loop-level IR</strong></h5>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># TorchInductor 的 define-by-run IR 示例</span>
def pointwise_kernel(index):    
    i0, <span class="hljs-attr">i1</span> = index    
    <span class="hljs-comment"># 加载输入数据    </span>
    <span class="hljs-attr">tmp0</span> = ops.load(<span class="hljs-string">"input"</span>, i0 * stride0 + i1 * stride1)    
    <span class="hljs-comment"># 执行计算    </span>
    <span class="hljs-attr">tmp1</span> = ops.log(tmp0)    
    <span class="hljs-attr">tmp2</span> = ops.mul(tmp1, <span class="hljs-number">1.4426950408889634</span>)  <span class="hljs-comment"># log2 scale    </span>
    <span class="hljs-comment"># 存储结果    </span>
    return tmp2
    
<span class="hljs-comment"># 生成的 Triton kernel 结构</span>
<span class="hljs-attr">buf0</span> = TensorBox(StorageBox(ComputedBuffer(    
    <span class="hljs-attr">name</span>=<span class="hljs-string">'buf0'</span>,    
    <span class="hljs-attr">layout</span>=FixedLayout(<span class="hljs-string">'cuda'</span>, torch.float32, size=[M, N]),    
    <span class="hljs-attr">data</span>=Pointwise(inner_fn=pointwise_kernel, ranges=[M, N])
)))
</code></pre>
<h5 data-id="heading-16"><strong>3.3.3 代码生成：Triton 与 C++ 后端</strong></h5>
<p>最终生成的代码示例：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 生成的 Triton kernel 代码片段</span>
@triton.jit
def triton_poi_fused_add_div_mul_0(in_ptr0, in_ptr1, in_ptr2, out_ptr0, xnumel, XBLOCK : tl.constexpr):    
    <span class="hljs-attr">xnumel</span> = <span class="hljs-number">1000000</span>    
    <span class="hljs-attr">xoffset</span> = tl.program_id(<span class="hljs-number">0</span>) * XBLOCK    
    <span class="hljs-attr">xindex</span> = x<span class="hljs-literal">off</span>set + tl.arange(<span class="hljs-number">0</span>, XBLOCK)[:]    
    <span class="hljs-attr">xmask</span> = xindex &lt; xnumel    
    <span class="hljs-attr">x0</span> = xindex    
    <span class="hljs-attr">tmp0</span> = tl.load(in_ptr0 + (x0), xmask)    
    <span class="hljs-attr">tmp1</span> = tl.load(in_ptr1 + (x0), xmask)    
    <span class="hljs-attr">tmp2</span> = tmp0 / tmp1  <span class="hljs-comment"># div operation    </span>
    <span class="hljs-attr">tmp3</span> = tmp2 * <span class="hljs-number">0.1</span>   <span class="hljs-comment"># mul operation      </span>
    <span class="hljs-attr">tmp4</span> = tl.load(in_ptr2 + (x0), xmask)    
    <span class="hljs-attr">tmp5</span> = tmp4 + tmp3  <span class="hljs-comment"># add operation    tl.store(out_ptr0 + (x0), tmp5, xmask)</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6c4447a39824e24a52a4ecc8fc93322~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWF5pen:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232551&amp;x-signature=6sBaqjBayq%2BxAb%2BqJ%2BJYyQ3ojzs%3D" alt="image-20251225094250899" loading="lazy"/></p>
<p>从代码可以看到，TorchInductor 生成了高度优化的 Triton kernel，包括：</p>
<ul>
<li><strong>算子融合</strong>：将 div、mul、add 操作融合为单个 kernel</li>
<li><strong>内存优化</strong>：减少中间结果的内存读写</li>
<li><strong>并行化</strong>：充分利用 GPU 的并行计算能力</li>
</ul>
<h3 data-id="heading-17"><strong>4. 性能优化与调试实践</strong></h3>
<h4 data-id="heading-18"><strong>4.1 性能分析工具</strong></h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 启用详细日志</span>
import os
os.environ<span class="hljs-section">['TORCH_COMPILE_DEBUG']</span> = '1'
<span class="hljs-comment"># 性能对比测试</span>
def benchmark_model():    
    <span class="hljs-attr">model</span> = MyModel()    
    <span class="hljs-attr">compiled_model</span> = torch.compile(model)        
    
    <span class="hljs-comment"># 预热    </span>
    for _ in range(10):        
        <span class="hljs-attr">_</span> = compiled_model(sample_input)        
    
    <span class="hljs-comment"># 性能测试   </span>
    <span class="hljs-attr">start_time</span> = time.time()    
    for _ in range(100):        
        <span class="hljs-attr">result</span> = compiled_model(sample_input)    
    <span class="hljs-attr">end_time</span> = time.time()        
    
    print(f"Average time: {(end_time - start_time) / 100:.4f}s")
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad7ac638151e473e8e39bac666f3e4af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWF5pen:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232551&amp;x-signature=1ctSx%2BQIs79Lx1qKTaqtn7qc280%3D" alt="image-20251225093838985" loading="lazy"/></p>
<h4 data-id="heading-19"><strong>4.2 常见问题排查</strong></h4>
<h5 data-id="heading-20"><strong>4.2.1 编译失败诊断</strong></h5>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 开启调试模式</span>
<span class="hljs-built_in">export</span> TORCH_COMPILE_DEBUG=1
<span class="hljs-built_in">export</span> TORCH_LOGS=<span class="hljs-string">"+dynamo,+inductor"</span>
​
<span class="hljs-comment"># 运行程序后检查生成的调试文件</span>
<span class="hljs-built_in">ls</span> /tmp/torchinductor_*/
<span class="hljs-comment"># - output_code.py      # 生成的代码</span>
<span class="hljs-comment"># - fx_graph_readable.py # 可读的FX图</span>
<span class="hljs-comment"># - run_*_benchmark.py   # 性能测试脚本</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/767b63a752904e919036ddac1d46abbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWF5pen:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232551&amp;x-signature=n8y2Rn9NisyXCR%2BEVmcXUFBBYZM%3D" alt="image-20251225093725089" loading="lazy"/></p>
<h5 data-id="heading-21"><strong>4.2.2 性能回归分析</strong></h5>
<p>通过调试输出可以看到完整的编译栈信息，包括：</p>
<ul>
<li><strong>模块调用链</strong>：从用户代码到底层算子的完整路径</li>
<li><strong>图捕获过程</strong>：TorchDynamo 的符号执行过程</li>
<li><strong>代码生成结果</strong>：最终生成的优化代码</li>
</ul>
<h4 data-id="heading-22"><strong>4.3 最佳实践建议</strong></h4>
<ol>
<li><strong>模型预热</strong>：首次编译有开销，建议进行预热</li>
<li><strong>批量处理</strong>：编译对大batch更友好</li>
<li><strong>避免动态控制流</strong>：减少 graph break</li>
<li><strong>合理使用 dynamic=True</strong>：平衡灵活性和性能</li>
</ol>
<h3 data-id="heading-23"><strong>5. 实际应用案例</strong></h3>
<h4 data-id="heading-24"><strong>5.1 Transformer 模型优化</strong></h4>
<pre><code class="hljs language-ini" lang="ini">class OptimizedTransformer(nn.Module):    
    def __init__(self, config):        
        super().__init__()        
        <span class="hljs-attr">self.attention</span> = MultiHeadAttention(config)        
        <span class="hljs-attr">self.feed_forward</span> = FeedForward(config)        
        <span class="hljs-attr">self.layer_norm1</span> = nn.LayerNorm(config.hidden_size)        
        <span class="hljs-attr">self.layer_norm2</span> = nn.LayerNorm(config.hidden_size)        
    @torch.compile    
    def forward(self, x, <span class="hljs-attr">attention_mask</span>=None):        
    <span class="hljs-comment"># Self-attention        </span>
    <span class="hljs-attr">attn_output</span> = self.attention(x, attention_mask)        
    <span class="hljs-attr">x</span> = self.layer_norm1(x + attn_output)                
    
    <span class="hljs-comment"># Feed-forward        </span>
    <span class="hljs-attr">ff_output</span> = self.feed_forward(x)        
    <span class="hljs-attr">x</span> = self.layer_norm2(x + ff_output)                
    
    return x
<span class="hljs-comment"># 性能提升：1.5-2x 加速比</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cfbfdf870f94f88b6e98fea7125098f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWF5pen:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232551&amp;x-signature=OO5%2FsFZkcoNLskao5eLVH03WWjc%3D" alt="image-20251225093546096" loading="lazy"/></p>
<h3 data-id="heading-25"><strong>结论</strong></h3>
<p>torch.compile 代表了 PyTorch 在性能优化方面的重大突破。通过 TorchDynamo 的字节码重写、AOT Autograd 的图优化和 TorchInductor 的代码生成，实现了在保持 PyTorch 灵活性的同时获得接近静态图的性能。</p>
<p>对于开发者而言，torch.compile 提供了一个几乎零成本的性能提升方案。只需要添加一个装饰器，就能获得显著的加速效果。随着技术的不断成熟，torch.compile 必将成为 PyTorch 生态系统中不可或缺的核心组件。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[今天一个新的知识点 C语言的 “函数”]]></title>    <link>https://juejin.cn/post/7587261253912838159</link>    <guid>https://juejin.cn/post/7587261253912838159</guid>    <pubDate>2025-12-25T02:03:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587261253912838159" data-draft-id="7582077175002218539" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="今天一个新的知识点 C语言的 “函数”"/> <meta itemprop="keywords" content="C"/> <meta itemprop="datePublished" content="2025-12-25T02:03:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小张心绪烂尾"/> <meta itemprop="url" content="https://juejin.cn/user/4135731991953737"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            今天一个新的知识点 C语言的 “函数”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4135731991953737/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小张心绪烂尾
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:03:10.000Z" title="Thu Dec 25 2025 02:03:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-light">.hljs-comment,.hljs-quote{color:#696969}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d91e18}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#aa5d00}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:green}.hljs-section,.hljs-title{color:#007faa}.hljs-keyword,.hljs-selector-tag{color:#7928a1}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fefefe;color:#545454}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">**<strong>函数：实现特定功能的代码</strong></h2>
<p>通俗的话：我给它什么，它就给我做什么事，还给我什么</p>
<p>两个步骤：
1.先定义函数：
格式</p>
<pre><code class="hljs">返回值类型 函数名（参数列表）{

函数具体的代码
}
</code></pre>
<p>2.	调用函数：</p>
<pre><code class="hljs">格式

返回值 = 函数名（参数）   
</code></pre>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span></span>

<span class="hljs-comment">// 实现特定功能的代码段</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">printAge</span><span class="hljs-params">()</span>{
	<span class="hljs-type">int</span> age = <span class="hljs-number">18</span>;
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;------------------\n&amp;#<span class="hljs-number">34</span>;);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;年龄是:%d\n&amp;#<span class="hljs-number">34</span>;,age);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;-------------------\n&amp;#<span class="hljs-number">34</span>;);
} 
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
	<span class="hljs-comment">// 函数</span>
	printAge();	<span class="hljs-comment">// 调用函数 </span>
		
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} 
</code></pre>
<p>运行结果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b2cf65f76314021a3337841a61993fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5byg5b-D57uq54OC5bC-:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232990&amp;x-signature=2b%2Bm%2Bt5UCLM62uwm4hHBScy1xUg%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-1"><strong>进阶知识点：</strong></h3>
<p>如何让它又能输出18,19</p>
<p>就是把int age，移到printMyAge()的这个括号里面，再在下面的"调用函数"里面输入想要输出的数字。</p>
<p>如下展示：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">printMyAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>{
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;------------------\n&amp;#<span class="hljs-number">34</span>;);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;年龄是:%d\n&amp;#<span class="hljs-number">34</span>;,age);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;-------------------\n&amp;#<span class="hljs-number">34</span>;);
} 
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
	<span class="hljs-comment">// 函数</span>
	printMyAge(<span class="hljs-number">18</span>);	<span class="hljs-comment">// 调用函数 </span>
	printMyAge(<span class="hljs-number">19</span>);	<span class="hljs-comment">// 调用函数 </span>

		
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} 
</code></pre>
<p>运行结果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7f64e9f4d894ef788414852b2e6fa8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5byg5b-D57uq54OC5bC-:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232990&amp;x-signature=sLeHP%2FLwCBqAHpER434Sdh7PSK8%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-2">再进阶一下</h4>
<p>添加一个身高在里面，我们应该怎样改写一下代码：</p>
<p>很简单就是在(int age),括号里面加一个定义符"double"，就是这样(int age,double sg)，下面"调用函数加个身高的数值就完成了。</p>
<p>展示如下：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span></span>

<span class="hljs-comment">// 实现特定功能的代码段</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">printMyInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> age,<span class="hljs-type">double</span> sg)</span>{
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;------------------\n&amp;#<span class="hljs-number">34</span>;);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;年龄是:%d\n&amp;#<span class="hljs-number">34</span>;,age);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;身高是:%<span class="hljs-number">.2</span>f\n&amp;#<span class="hljs-number">34</span>;,sg);
	<span class="hljs-built_in">printf</span>(&amp;#<span class="hljs-number">34</span>;-------------------\n&amp;#<span class="hljs-number">34</span>;);
} 
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
	<span class="hljs-comment">// 函数</span>
	printMyInfo(<span class="hljs-number">18</span>, <span class="hljs-number">1.78</span>);	<span class="hljs-comment">// 调用函数 </span>
	printMyInfo(<span class="hljs-number">19</span>, <span class="hljs-number">1.88</span>);	<span class="hljs-comment">// 调用函数 </span>

		
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} 
</code></pre>
<p>运行结果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3350ab9c92145ddbbca018d9d360fa8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5byg5b-D57uq54OC5bC-:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767232990&amp;x-signature=jOZrFhTCjKsZ%2BEyUJpEjgHBtKcw%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度学习驱动的视频异常检测（VAD），AI如何让监控更智能？]]></title>    <link>https://juejin.cn/post/7587322796825444392</link>    <guid>https://juejin.cn/post/7587322796825444392</guid>    <pubDate>2025-12-25T02:51:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587322796825444392" data-draft-id="7587277503947554816" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度学习驱动的视频异常检测（VAD），AI如何让监控更智能？"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2025-12-25T02:51:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度学习驱动的视频异常检测（VAD），AI如何让监控更智能？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:51:27.000Z" title="Thu Dec 25 2025 02:51:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你是否曾想过，在成千上万的监控视频中，如何让计算机自动识别出打架、闯入、徘徊等异常事件？这正是视频异常检测（Video Anomaly Detection, VAD） 所要解决的核心问题。随着深度学习技术的飞速发展，VAD 已成为计算机视觉领域的热点研究方向，并在智能安防、自动驾驶、内容审核等领域展现出巨大应用潜力。</p>
<p>今天，我们就基于深度学习的 VAD 方法进行了全面梳理与总结，看看 AI 如何让视频监控变得更智能。</p>
<h2 data-id="heading-0"><strong>什么是视频异常检测？</strong></h2>
<p>异常，指的是偏离正常、标准或预期的事物。在视频中，异常可能表现为异常行为（如突然奔跑、打架）或异常事件（如车辆逆行、物品遗留）。VAD 的目标就是自动识别出这些“不寻常”的画面。</p>
<p>传统的 VAD 方法通常分为两步：先提取手工设计的特征，再设计分类器进行判断。但这种方式依赖专家经验，难以应对复杂多变的真实场景。</p>
<p>随着深度学习的兴起，VAD 进入了新的发展阶段。如图1所示，近十年来相关论文数量持续快速增长，尤其是在 IEEE Xplore 和 Google Scholar 中，VAD 相关研究呈现出爆发式增长。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0397084242ec494ba4ba1ceea73482cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767235887&amp;x-signature=37V0crXT%2BOLCZzZqFr6C%2FCqHFW4%3D" alt="screenshot_2025-12-24_16-22-49.png" loading="lazy"/></p>
<p>同时，检测性能也在不断提升。如图2所示，在半监督和弱监督设置下，各数据集的检测性能（AUC 指标）呈稳步上升趋势，表明算法在不断进步。</p>
<h2 data-id="heading-1"><strong>五种监督模式：你知道几种？</strong></h2>
<p>根据训练时使用的标注信息不同，VAD 可分为以下五种模式：</p>

<ul>
<li><strong>半监督 VAD</strong></li>
</ul>
<p>特点：仅使用正常样本进行训练。</p>
<p>优点：无需收集罕见的异常样本。</p>
<p>缺点：容易将未见过但正常的样本误判为异常。</p>
<ul>
<li><strong>弱监督 VAD</strong></li>
</ul>
<p>特点：训练视频只有视频级标签（正常/异常），没有具体发生时间。</p>
<p>优点：标注成本低。</p>
<p>缺点：算法设计复杂，容易“盲猜”。</p>
<ul>
<li><strong>全监督 VAD</strong></li>
</ul>
<p>特点：每个异常都有精确的时间段标注。</p>
<p>优点：检测性能高。</p>
<p>缺点：标注成本极高，现实中难以大规模应用。</p>
<ul>
<li><strong>无监督 VAD</strong></li>
</ul>
<p>特点：完全无需标注，直接从未标注视频中检测异常。</p>
<p>优点：无需标注，适用性广。</p>
<p>缺点：检测准确率相对较低。</p>
<ul>
<li><strong>开放集监督 VAD</strong></li>
</ul>
<p>特点：训练时已知部分异常类型，但测试时可能出现从未见过的异常。</p>
<p>优点：更贴近真实开放环境。</p>
<p>缺点：需要设计专门机制来识别未知异常。</p>
<p>图3直观对比了这五种任务的区别。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca8cf3f061e544f3abc7090ad718b0eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767235887&amp;x-signature=tI%2BtW6Jk8iekwVVf%2BFqrdq0nobQ%3D" alt="screenshot_2025-12-24_16-24-26.png" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>方法体系：AI 是如何“看”视频的？</strong></h2>
<ul>
<li><strong>半监督 VAD：学习“正常”的样子</strong></li>
</ul>
<p>由于只有正常样本，模型通常通过自监督学习来构建“正常模式”。常见方法包括：</p>
<p>重建：训练一个自编码器，让其学会重构正常视频。异常视频通常难以被良好重构。</p>
<p>预测：让模型预测未来帧，正常事件通常可预测，异常事件则难以预测。</p>
<p>视觉完形填空：随机遮挡部分帧，让模型补全，以此学习时空上下文。</p>
<p>图4展示了半监督 VAD 的系统化分类体系。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b1c977e58b54e39935e5bf46eb142c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767235887&amp;x-signature=juWIGRj6deU747tsaqEvCU1xQ5M%3D" alt="screenshot_2025-12-24_16-24-50.png" loading="lazy"/></p>
<ul>
<li><strong>弱监督 VAD：从“视频级标签”中定位异常</strong></li>
</ul>
<p>弱监督方法通常借助多示例学习（MIL） 机制，从长视频中挖掘出最可能是异常的片段。近年来，一些方法还引入两阶段自训练、时序建模、时空建模等策略提升性能。</p>
<ul>
<li><strong>无监督 VAD：完全“自力更生”</strong></li>
</ul>
<p>无监督方法不依赖任何标注，常见思路包括：</p>
<p>伪标签法：先通过某种方式生成伪标签，再迭代优化。</p>
<p>变化检测：检测视频中是否出现分布变化。</p>
<p>因果推断：从因果角度建模正常与异常的关系。</p>
<ul>
<li><strong>开放集与少样本 VAD：应对未知异常</strong></li>
</ul>
<p>这类方法旨在识别训练中未出现的异常。常见技术包括：</p>
<p>边际学习：在特征空间中拉开正常与异常的距离。</p>
<p>基于大模型的方法：利用视觉-语言模型（如 CLIP）进行零样本或开放词汇检测。</p>
<p>少样本适应：仅用少量样本快速适应新场景。</p>
<p>图10展示了六种典型的开放集监督 VAD 方法流程。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6043b8a1ca6408ba0d2019a900d5507~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767235887&amp;x-signature=vK%2FeuWta76JW8pjWfc%2B%2ByPy8VZg%3D" alt="screenshot_2025-12-24_16-25-23.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>未来方向：VAD 将走向何方？</strong></h2>
<ul>
<li><strong>构建更全面的基准数据集</strong></li>
</ul>
<p>当前数据集规模小、模态单一。未来需要：</p>
<ul>
<li><strong>大规模数据：</strong> 更长、更丰富的视频内容。</li>
<li><strong>多模态融合：</strong> 结合视觉、音频、红外等多模态信息。</li>
<li><strong>多视角与第一视角：</strong> 支持多摄像头、第一人称视角等更真实场景。</li>
</ul>

<ul>
<li><strong>迈向开放世界</strong></li>
</ul>
<p>现实世界异常层出不穷，模型需具备：</p>
<ul>
<li><strong>开放词汇检测：</strong> 能理解并检测未知类别的异常。</li>
<li><strong>增量学习：</strong> 持续学习新异常而不遗忘旧知识。</li>
</ul>

<ul>
<li><strong>拥抱大模型</strong></li>
</ul>
<p>预训练大模型（如 CLIP、LLM）为 VAD 带来新机遇：</p>
<ul>
<li><strong>语义理解：</strong> 结合文本描述提升异常解释能力。</li>
<li><strong>零样本检测：</strong> 无需训练即可检测新异常。</li>
</ul>

<ul>
<li><strong>可解释性 VAD</strong></li>
</ul>
<p>让 AI 不仅检测异常，还能“说”出为什么：</p>
<ul>
<li><strong>规则推理：</strong> 结合知识图谱、大语言模型进行逻辑推理。</li>
<li><strong>可视化定位：</strong> 在像素级标注异常区域，提升可解释性。</li>
</ul>
<h2 data-id="heading-4"><strong>结语</strong></h2>
<p>视频异常检测正朝着更智能、更开放、更可解释的方向发展。从仅使用正常样本的半监督学习，到应对未知异常的开放集检测，再到结合大模型的多模态理解，VAD 的技术演进不断拓展其应用边界。</p>
<p>未来，随着数据规模的扩大、算法能力的提升以及多模态融合的深入，VAD 将在安防、交通、医疗等领域发挥更加关键的作用，真正实现“让监控更智能”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[vue3这些常见指令你封装了吗]]></title>    <link>https://juejin.cn/post/7587349016222122025</link>    <guid>https://juejin.cn/post/7587349016222122025</guid>    <pubDate>2025-12-25T02:53:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587349016222122025" data-draft-id="7587329107303907391" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="vue3这些常见指令你封装了吗"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-25T02:53:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="林太白"/> <meta itemprop="url" content="https://juejin.cn/user/1874034273300919"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            vue3这些常见指令你封装了吗
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1874034273300919/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    林太白
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:53:33.000Z" title="Thu Dec 25 2025 02:53:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">vue3这些常见指令你封装了吗</h2>
<h3 data-id="heading-1">👉指令搭建</h3>
<p>vue3之中会有一些常见的指令操作，接下来我们就写一下,之前我们写了权限按钮，其实是类似的</p>
<p>指令的最主要文件如下，我们主要是主模块之中使用，其他的模块之中分割写好方法即可</p>
<h4 data-id="heading-2">指令主要文件</h4>
<pre><code class="hljs language-javascript" lang="javascript">src\utils\directive\index.<span class="hljs-property">ts</span>

<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">App</span>, <span class="hljs-title class_">Directive</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> directives={};
<span class="hljs-comment">// 导出插件对象</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> registerDirectives = {
  <span class="hljs-title function_">install</span>(<span class="hljs-params">app: App</span>) {
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(directives).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
      app.<span class="hljs-title function_">directive</span>(key, directives[key])
    })
  }
}
</code></pre>
<h4 data-id="heading-3">指令使用</h4>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-comment">// 指令使用</span>
<span class="hljs-keyword">import</span> {registerDirectives} <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/directive'</span><span class="hljs-comment">// 导入全局指令</span>
app.<span class="hljs-title function_">use</span>(registerDirectives);<span class="hljs-comment">//全局指令注册</span>
</code></pre>
<h3 data-id="heading-4">👉指令编写</h3>
<h4 data-id="heading-5">复制指令</h4>
<h5 data-id="heading-6">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 扩展 HTMLElement 接口</span>
declare <span class="hljs-variable language_">global</span> {
  interface <span class="hljs-title class_">HTMLElement</span> {
    copyData?: string
  }
}

<span class="hljs-comment">// 定义指令值的类型</span>
interface <span class="hljs-title class_">CopyBinding</span> {
  <span class="hljs-attr">value</span>: string
}

<span class="hljs-comment">// 复制指令配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">copy</span>: <span class="hljs-title class_">Directive</span>&lt;<span class="hljs-title class_">HTMLElement</span>, string&gt; = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: HTMLElement, binding: CopyBinding</span>) {
    <span class="hljs-comment">// 保存要复制的值</span>
    el.<span class="hljs-property">copyData</span> = binding.<span class="hljs-property">value</span>
    <span class="hljs-comment">// 添加点击事件监听</span>
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleClick)
  },
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el: HTMLElement, binding: CopyBinding</span>) {
    <span class="hljs-comment">// 更新要复制的值</span>
    el.<span class="hljs-property">copyData</span> = binding.<span class="hljs-property">value</span>
  },
  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params">el: HTMLElement</span>) {
    <span class="hljs-comment">// 移除事件监听</span>
    el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, handleClick)
  }
}

<span class="hljs-comment">// 处理复制功能</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">event: Event</span>) =&gt; {
  <span class="hljs-keyword">const</span> el = event.<span class="hljs-property">currentTarget</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>
  <span class="hljs-keyword">if</span> (!el.<span class="hljs-property">copyData</span>) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 使用现代的 Clipboard API</span>
    <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">clipboard</span>.<span class="hljs-title function_">writeText</span>(el.<span class="hljs-property">copyData</span>)
    <span class="hljs-comment">// 可以在这里添加成功提示</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'复制成功'</span>)
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// 降级方案：使用传统方法</span>
    <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'input'</span>)
    input.<span class="hljs-property">value</span> = el.<span class="hljs-property">copyData</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(input)
    input.<span class="hljs-title function_">select</span>()
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">execCommand</span>(<span class="hljs-string">'Copy'</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'复制成功'</span>)
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'复制失败:'</span>, err)
    }
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(input)
  }
}
<span class="hljs-comment">// 导出指令对象</span>
<span class="hljs-keyword">export</span> { copy }

</code></pre>
<h5 data-id="heading-7">引入指令</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 复制指令</span>
<span class="hljs-keyword">import</span> {copy} <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/copy'</span>

<span class="hljs-comment">// 定义所有指令</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">directives</span>: <span class="hljs-title class_">Record</span>&lt;string, <span class="hljs-title class_">Directive</span>&gt; = {

  <span class="hljs-comment">// 复制指令</span>
  copy,
}
</code></pre>
<h5 data-id="heading-8">使用指令</h5>
<p>接下来演示一下在项目之中进行使用指令</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex gap-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
      <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-1 px-4 py-2 bg-gray-50 border-0 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200"</span> 
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入要复制的内容"</span> 
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"data"</span>
    &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> 
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200"</span>
      <span class="hljs-attr">v-copy</span>=<span class="hljs-string">"data"</span>
    &gt;</span>
      复制
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'我是被复制的内容 🍒 🍉 🍊'</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</code></pre>
<h4 data-id="heading-9">水印指令</h4>
<p>接下来写一个水印指令，我们设置的是采取canvas实现的水印效果，接下来我们就编写一下</p>
<h5 data-id="heading-10">引入指令</h5>
<p>接下来我们就在这里编写水印</p>
<pre><code class="hljs language-javascript" lang="javascript">src\utils\directive\modules\watermark .<span class="hljs-property">ts</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 水印指令</span>
<span class="hljs-keyword">import</span> {watermark} <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/watermark'</span>

<span class="hljs-comment">// 定义所有指令</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">directives</span>: <span class="hljs-title class_">Record</span>&lt;string, <span class="hljs-title class_">Directive</span>&gt; = {
  <span class="hljs-comment">// 水印指令</span>
  watermark,
}
</code></pre>
<h5 data-id="heading-11">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// modules/watermark.ts</span>

<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">WatermarkConfig</span> {
  text?: string
  color?: string
  fontSize?: number
  fontFamily?: string
  width?: number
  height?: number
  rotate?: number
  zIndex?: number
}

interface <span class="hljs-title class_">HTMLElementWithWatermark</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HTMLElement</span> {
  _watermarkElement?: <span class="hljs-title class_">HTMLDivElement</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">defaultConfig</span>: <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">WatermarkConfig</span>&gt; = {
  <span class="hljs-attr">text</span>: <span class="hljs-string">'Watermark'</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'rgba(0, 0, 0, 0.15)'</span>,
  <span class="hljs-attr">fontSize</span>: <span class="hljs-number">16</span>,
  <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'Arial'</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">rotate</span>: -<span class="hljs-number">20</span>,
  <span class="hljs-attr">zIndex</span>: <span class="hljs-number">9999</span>
}

<span class="hljs-keyword">const</span> createWatermark = (<span class="hljs-attr">config</span>: <span class="hljs-title class_">WatermarkConfig</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> finalConfig = { ...defaultConfig, ...config }
  
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>)
  canvas.<span class="hljs-property">width</span> = finalConfig.<span class="hljs-property">width</span>
  canvas.<span class="hljs-property">height</span> = finalConfig.<span class="hljs-property">height</span>
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>)!

  <span class="hljs-comment">// 设置画布样式</span>
  ctx.<span class="hljs-title function_">rotate</span>((finalConfig.<span class="hljs-property">rotate</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>)
  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">${finalConfig.fontSize}</span>px <span class="hljs-subst">${finalConfig.fontFamily}</span>`</span>
  ctx.<span class="hljs-property">fillStyle</span> = finalConfig.<span class="hljs-property">color</span>
  ctx.<span class="hljs-property">textAlign</span> = <span class="hljs-string">'center'</span>
  ctx.<span class="hljs-property">textBaseline</span> = <span class="hljs-string">'middle'</span>
  
  <span class="hljs-comment">// 绘制水印文本</span>
  ctx.<span class="hljs-title function_">fillText</span>(finalConfig.<span class="hljs-property">text</span>, finalConfig.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, finalConfig.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>)

  <span class="hljs-keyword">return</span> canvas.<span class="hljs-title function_">toDataURL</span>()
}

<span class="hljs-keyword">const</span> watermark = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: HTMLElementWithWatermark, binding: { value: WatermarkConfig }</span>) {
    <span class="hljs-keyword">const</span> config = binding.<span class="hljs-property">value</span> || {}
    <span class="hljs-keyword">const</span> dataURL = <span class="hljs-title function_">createWatermark</span>(config)

    <span class="hljs-comment">// 创建水印层</span>
    <span class="hljs-keyword">const</span> watermarkDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'absolute'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">'0'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">'0'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">'100%'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">'100%'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">pointerEvents</span> = <span class="hljs-string">'none'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">`url(<span class="hljs-subst">${dataURL}</span>)`</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundRepeat</span> = <span class="hljs-string">'repeat'</span>
    watermarkDiv.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = <span class="hljs-title class_">String</span>(config.<span class="hljs-property">zIndex</span> || defaultConfig.<span class="hljs-property">zIndex</span>)

    <span class="hljs-comment">// 设置父元素为相对定位</span>
    el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'relative'</span>
    <span class="hljs-comment">// 添加水印层</span>
    el.<span class="hljs-title function_">appendChild</span>(watermarkDiv)

    <span class="hljs-comment">// 保存水印元素引用</span>
    el.<span class="hljs-property">_watermarkElement</span> = watermarkDiv
  },

  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el: HTMLElementWithWatermark, binding: { value: WatermarkConfig; oldValue: WatermarkConfig }</span>) {
    <span class="hljs-comment">// 如果配置发生变化，重新渲染水印</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(binding.<span class="hljs-property">value</span>) !== <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(binding.<span class="hljs-property">oldValue</span>)) {
      <span class="hljs-comment">// 移除旧水印</span>
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_watermarkElement</span>) {
        el.<span class="hljs-title function_">removeChild</span>(el.<span class="hljs-property">_watermarkElement</span>)
      }
      <span class="hljs-comment">// 创建新水印</span>
      watermark.<span class="hljs-title function_">mounted</span>(el, binding)
    }
  },

  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el: HTMLElementWithWatermark</span>) {
    <span class="hljs-comment">// 组件卸载时移除水印</span>
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_watermarkElement</span>) {
      el.<span class="hljs-title function_">removeChild</span>(el.<span class="hljs-property">_watermarkElement</span>)
      <span class="hljs-keyword">delete</span> el.<span class="hljs-property">_watermarkElement</span>
    }
  }
}
<span class="hljs-keyword">export</span> { watermark }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> watermark;

</code></pre>
<h5 data-id="heading-12">指令使用</h5>
<p>这个时候使用我们的指令，可以看到我们的效果</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex gap-3 content"</span> <span class="hljs-attr">v-watermark</span>=<span class="hljs-string">"watermarkConfig"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-lg font-semibold mb-4 text-gray-800"</span>&gt;</span>水印指令<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
      <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-1 px-4 py-2  border-0 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200"</span> 
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入要复制的内容"</span> 
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"data"</span>
    &gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref,computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-comment">// 将原来的 compute 方法改为计算属性</span>
<span class="hljs-keyword">const</span> watermarkText = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> data.<span class="hljs-property">value</span>)

<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'水印内容🍒 🍉 🍊'</span>)

<span class="hljs-comment">// 然后在 watermarkConfig 中使用这个计算属性</span>
<span class="hljs-keyword">const</span> watermarkConfig = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> ({
  <span class="hljs-attr">text</span>: watermarkText.<span class="hljs-property">value</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'rgba(0, 0, 0, 0.15)'</span>,
  <span class="hljs-attr">fontSize</span>: <span class="hljs-number">16</span>,
  <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'Arial'</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">rotate</span>: -<span class="hljs-number">20</span>,
  <span class="hljs-attr">zIndex</span>: <span class="hljs-number">9999</span>,
}))
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.content</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-13">拖拽指令</h4>
<h5 data-id="heading-14">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript">src\utils\directive\modules\draggable.<span class="hljs-property">ts</span>
</code></pre>
<p>指令内容,这里需要注意一个部分，指令的位置是相对于我们父元素位置，而不是相对于我们视口的位置</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 记录初始位置</span>
<span class="hljs-keyword">const</span> rect = el.<span class="hljs-title function_">getBoundingClientRect</span>()
dragData.<span class="hljs-property">initialLeft</span> = rect.<span class="hljs-property">left</span>
dragData.<span class="hljs-property">initialTop</span> = rect.<span class="hljs-property">top</span>

=&gt;更改为

<span class="hljs-comment">// 获取当前位置，如果没有设置则默认为0</span>
dragData.<span class="hljs-property">initialLeft</span> = <span class="hljs-built_in">parseInt</span>(el.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>) || <span class="hljs-number">0</span>
dragData.<span class="hljs-property">initialTop</span> = <span class="hljs-built_in">parseInt</span>(el.<span class="hljs-property">style</span>.<span class="hljs-property">top</span>) || <span class="hljs-number">0</span>
</code></pre>
<p>完整修改以后我们的版本如下</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">DirectiveBinding</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

interface <span class="hljs-title class_">DraggableElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HTMLElement</span> {
  _dragData?: {
    <span class="hljs-attr">isDragging</span>: boolean
    <span class="hljs-attr">startX</span>: number
    <span class="hljs-attr">startY</span>: number
    <span class="hljs-attr">initialLeft</span>: number
    <span class="hljs-attr">initialTop</span>: number
    <span class="hljs-attr">initialPosition</span>: string
    <span class="hljs-attr">zIndex</span>: string
  }
  _cleanup?: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>  <span class="hljs-comment">// 添加这一行</span>
}


<span class="hljs-keyword">const</span> <span class="hljs-attr">draggable</span>: <span class="hljs-title class_">Directive</span>&lt;<span class="hljs-title class_">DraggableElement</span>, boolean&gt; = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: DraggableElement, binding: DirectiveBinding&lt;boolean&gt;</span>) {
    <span class="hljs-keyword">if</span> (binding.<span class="hljs-property">value</span> === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">const</span> dragData = {
      <span class="hljs-attr">isDragging</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">startX</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">startY</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">initialLeft</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">initialTop</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">initialPosition</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">zIndex</span>: <span class="hljs-string">''</span>
    }
    el.<span class="hljs-property">_dragData</span> = dragData

    <span class="hljs-comment">// 设置初始样式</span>
    el.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'move'</span>
    el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> || <span class="hljs-string">'absolute'</span>

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMouseDown</span> = (<span class="hljs-params">e: MouseEvent</span>) =&gt; {
      dragData.<span class="hljs-property">isDragging</span> = <span class="hljs-literal">true</span>
      dragData.<span class="hljs-property">startX</span> = e.<span class="hljs-property">clientX</span>
      dragData.<span class="hljs-property">startY</span> = e.<span class="hljs-property">clientY</span>
      dragData.<span class="hljs-property">initialPosition</span> = el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span>
      dragData.<span class="hljs-property">zIndex</span> = el.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span>
      
      <span class="hljs-comment">// 获取当前位置，如果没有设置则默认为0</span>
      dragData.<span class="hljs-property">initialLeft</span> = <span class="hljs-built_in">parseInt</span>(el.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>) || <span class="hljs-number">0</span>
      dragData.<span class="hljs-property">initialTop</span> = <span class="hljs-built_in">parseInt</span>(el.<span class="hljs-property">style</span>.<span class="hljs-property">top</span>) || <span class="hljs-number">0</span>

      <span class="hljs-comment">// 提高层级</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = <span class="hljs-string">'9999'</span>
      
      <span class="hljs-comment">// 添加移动时的样式</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">'none'</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">userSelect</span> = <span class="hljs-string">'none'</span>
    }

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMouseMove</span> = (<span class="hljs-params">e: MouseEvent</span>) =&gt; {
      <span class="hljs-keyword">if</span> (!dragData.<span class="hljs-property">isDragging</span>) <span class="hljs-keyword">return</span>

      <span class="hljs-keyword">const</span> deltaX = e.<span class="hljs-property">clientX</span> - dragData.<span class="hljs-property">startX</span>
      <span class="hljs-keyword">const</span> deltaY = e.<span class="hljs-property">clientY</span> - dragData.<span class="hljs-property">startY</span>

      el.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">`<span class="hljs-subst">${dragData.initialLeft + deltaX}</span>px`</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">`<span class="hljs-subst">${dragData.initialTop + deltaY}</span>px`</span>
    }

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMouseUp</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (!dragData.<span class="hljs-property">isDragging</span>) <span class="hljs-keyword">return</span>
      
      dragData.<span class="hljs-property">isDragging</span> = <span class="hljs-literal">false</span>
      
      <span class="hljs-comment">// 恢复样式</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = dragData.<span class="hljs-property">zIndex</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">userSelect</span> = <span class="hljs-string">''</span>
      el.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">''</span>
    }

    <span class="hljs-comment">// 添加事件监听</span>
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousedown'</span>, handleMouseDown)
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove)
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseup'</span>, handleMouseUp)

    <span class="hljs-comment">// 保存清理函数</span>
    el.<span class="hljs-property">_cleanup</span> = <span class="hljs-function">() =&gt;</span> {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousedown'</span>, handleMouseDown)
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousemove'</span>, handleMouseMove)
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseup'</span>, handleMouseUp)
    }
  },

  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el: DraggableElement</span>) {
    <span class="hljs-comment">// 清理事件监听</span>
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_cleanup</span>) {
      el.<span class="hljs-title function_">_cleanup</span>()
    }
    <span class="hljs-keyword">delete</span> el.<span class="hljs-property">_dragData</span>
  },

  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el: DraggableElement, binding: DirectiveBinding&lt;boolean&gt;</span>) {
    <span class="hljs-comment">// 如果指令值改变，更新状态</span>
    <span class="hljs-keyword">if</span> (binding.<span class="hljs-property">value</span> === <span class="hljs-literal">false</span> &amp;&amp; el.<span class="hljs-property">_dragData</span>) {
      el.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">''</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (binding.<span class="hljs-property">value</span> === <span class="hljs-literal">true</span>) {
      el.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">'move'</span>
    }
  }
}

<span class="hljs-keyword">export</span> {draggable}

</code></pre>
<h5 data-id="heading-15">指令使用</h5>
<p>我们在指令之中进行使用，效果ok</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"relative"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-draggable</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"draggable-box"</span>&gt;</span>
      可拖拽的内容
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 也可以动态控制是否可拖拽 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-draggable</span>=<span class="hljs-string">"isDraggable"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"draggable-box"</span>&gt;</span>
      条件拖拽的内容
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">const</span> isDraggable = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.draggable-box</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#409EFF</span>;
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">position</span>: absolute;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-16">防抖指令</h4>
<h5 data-id="heading-17">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// modules/debounce.ts</span>
<span class="hljs-comment">/**
 * 防抖函数
 * <span class="hljs-doctag">@param</span> fn 需要防抖的函数
 * <span class="hljs-doctag">@param</span> delay 延迟时间，单位毫秒，默认300ms
 * <span class="hljs-doctag">@param</span> immediate 是否立即执行，默认false
 * <span class="hljs-doctag">@returns</span> 返回防抖处理后的函数
 */</span>
interface <span class="hljs-title class_">DebounceBinding</span> {
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>;
  arg?: string; <span class="hljs-comment">// 延迟时间参数</span>
}

<span class="hljs-comment">// 防抖函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounceFn</span>(<span class="hljs-params">func: <span class="hljs-built_in">Function</span>, wait: number</span>) {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">timeout</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: any, ...args: any[]</span>) {
    <span class="hljs-built_in">clearTimeout</span>(timeout);
    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    }, wait);
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> debounce = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: HTMLElement, binding: DebounceBinding</span>) {
    <span class="hljs-comment">// 获取延迟时间，默认为 500ms</span>
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Number</span>(binding.<span class="hljs-property">arg</span>) || <span class="hljs-number">500</span>;
    
    <span class="hljs-comment">// 创建防抖函数</span>
    <span class="hljs-keyword">const</span> debouncedFn = <span class="hljs-title function_">debounceFn</span>(binding.<span class="hljs-property">value</span>, delay);
    
    <span class="hljs-comment">// 保存原始函数和防抖函数到元素的 dataset 中</span>
    el.<span class="hljs-property">dataset</span>.<span class="hljs-property">debounceFn</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">original</span>: binding.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>(),
      <span class="hljs-attr">debounced</span>: debouncedFn.<span class="hljs-title function_">toString</span>()
    });
    
    <span class="hljs-comment">// 添加事件监听器</span>
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, debouncedFn);
  },
  
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el: HTMLElement, binding: DebounceBinding</span>) {
    <span class="hljs-comment">// 如果值发生变化，更新防抖函数</span>
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Number</span>(binding.<span class="hljs-property">arg</span>) || <span class="hljs-number">500</span>;
    <span class="hljs-keyword">const</span> debouncedFn = <span class="hljs-title function_">debounceFn</span>(binding.<span class="hljs-property">value</span>, delay);
    
    <span class="hljs-comment">// 移除旧的事件监听器</span>
    <span class="hljs-keyword">const</span> oldFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'return '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(el.<span class="hljs-property">dataset</span>.<span class="hljs-property">debounceFn</span> || <span class="hljs-string">'{}'</span>).<span class="hljs-property">debounced</span>)();
    el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, oldFn);
    
    <span class="hljs-comment">// 更新 dataset</span>
    el.<span class="hljs-property">dataset</span>.<span class="hljs-property">debounceFn</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">original</span>: binding.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>(),
      <span class="hljs-attr">debounced</span>: debouncedFn.<span class="hljs-title function_">toString</span>()
    });
    
    <span class="hljs-comment">// 添加新的事件监听器</span>
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, debouncedFn);
  },
  
  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el: HTMLElement</span>) {
    <span class="hljs-comment">// 组件卸载时移除事件监听器</span>
    <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'return '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(el.<span class="hljs-property">dataset</span>.<span class="hljs-property">debounceFn</span> || <span class="hljs-string">'{}'</span>).<span class="hljs-property">debounced</span>)();
    el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, fn);
    <span class="hljs-keyword">delete</span> el.<span class="hljs-property">dataset</span>.<span class="hljs-property">debounceFn</span>;
  }
};

<span class="hljs-comment">// 导出防抖函数供其他地方使用</span>
<span class="hljs-keyword">export</span> { debounceFn };

</code></pre>
<h5 data-id="heading-18">指令使用</h5>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex flex-wrap gap-4 p-6"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 基础防抖按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-debounce</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-blue-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-blue-700 hover:shadow-lg focus:bg-blue-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-blue-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      防抖按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 500ms防抖按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-debounce:500</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-green-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-green-700 hover:shadow-lg focus:bg-green-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-green-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      500ms防抖按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 立即执行防抖按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-debounce.immediate</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-purple-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-purple-700 hover:shadow-lg focus:bg-purple-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-purple-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      立即执行防抖按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'防抖按钮点击'</span>);
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</code></pre>
<h4 data-id="heading-19">节流指令</h4>
<h5 data-id="heading-20">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * v-throttle 指令
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} fn 需要节流的函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} delay 延迟时间
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Boolean</span>} immediate 是否立即执行
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 返回一个节流后的函数
 */</span>

<span class="hljs-comment">// modules/throttle.ts</span>

interface <span class="hljs-title class_">ThrottleBinding</span> {
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>;
  arg?: string | number; <span class="hljs-comment">// 延迟时间参数</span>
  modifiers?: {
    immediate?: boolean;
  };
}

<span class="hljs-comment">// 节流函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttleFn</span>(<span class="hljs-params">
  func: <span class="hljs-built_in">Function</span>,
  wait: number,
  immediate: boolean = <span class="hljs-literal">false</span>
</span>) {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">timeout</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: any, ...args: any[]</span>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> remaining = wait - (now - previous);

    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) {
      <span class="hljs-keyword">if</span> (timeout) {
        <span class="hljs-built_in">clearTimeout</span>(timeout);
        timeout = <span class="hljs-literal">null</span>;
      }
      previous = now;
      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeout &amp;&amp; !immediate) {
      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        previous = immediate ? <span class="hljs-number">0</span> : <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        timeout = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (!immediate) {
          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        }
      }, remaining);
    }

    <span class="hljs-keyword">if</span> (immediate &amp;&amp; !timeout) {
      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      previous = now;
    }
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> throttle = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: HTMLElement, binding: ThrottleBinding</span>) {
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Number</span>(binding.<span class="hljs-property">arg</span>) || <span class="hljs-number">500</span>;
    <span class="hljs-keyword">const</span> immediate = binding.<span class="hljs-property">modifiers</span>?.<span class="hljs-property">immediate</span> || <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">const</span> throttledFn = <span class="hljs-title function_">throttleFn</span>(binding.<span class="hljs-property">value</span>, delay, immediate);
    
    el.<span class="hljs-property">dataset</span>.<span class="hljs-property">throttleFn</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">original</span>: binding.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>(),
      <span class="hljs-attr">throttled</span>: throttledFn.<span class="hljs-title function_">toString</span>()
    });
    
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, throttledFn);
  },
  
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el: HTMLElement, binding: ThrottleBinding</span>) {
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Number</span>(binding.<span class="hljs-property">arg</span>) || <span class="hljs-number">500</span>;
    <span class="hljs-keyword">const</span> immediate = binding.<span class="hljs-property">modifiers</span>?.<span class="hljs-property">immediate</span> || <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> throttledFn = <span class="hljs-title function_">throttleFn</span>(binding.<span class="hljs-property">value</span>, delay, immediate);
    
    <span class="hljs-keyword">const</span> oldFn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'return '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(el.<span class="hljs-property">dataset</span>.<span class="hljs-property">throttleFn</span> || <span class="hljs-string">'{}'</span>).<span class="hljs-property">throttled</span>)();
    el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, oldFn);
    
    el.<span class="hljs-property">dataset</span>.<span class="hljs-property">throttleFn</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">original</span>: binding.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>(),
      <span class="hljs-attr">throttled</span>: throttledFn.<span class="hljs-title function_">toString</span>()
    });
    
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, throttledFn);
  },
  
  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el: HTMLElement</span>) {
    <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'return '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(el.<span class="hljs-property">dataset</span>.<span class="hljs-property">throttleFn</span> || <span class="hljs-string">'{}'</span>).<span class="hljs-property">throttled</span>)();
    el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, fn);
    <span class="hljs-keyword">delete</span> el.<span class="hljs-property">dataset</span>.<span class="hljs-property">throttleFn</span>;
  }
};

<span class="hljs-keyword">export</span> { throttleFn };

</code></pre>
<h5 data-id="heading-21">指令使用</h5>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex flex-wrap gap-4 p-6"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 基础节流按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-throttle</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-blue-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-blue-700 hover:shadow-lg focus:bg-blue-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-blue-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      节流按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 500ms节流按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-throttle:500</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-green-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-green-700 hover:shadow-lg focus:bg-green-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-green-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      500ms节流按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 立即执行节流按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-throttle.immediate</span>=<span class="hljs-string">"handleClick"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-6 py-2.5 bg-purple-600 text-white font-medium text-sm leading-tight uppercase rounded shadow-md hover:bg-purple-700 hover:shadow-lg focus:bg-purple-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-purple-800 active:shadow-lg transition duration-150 ease-in-out"</span>
    &gt;</span>
      立即执行节流按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'按钮被点击'</span>);
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-22">长按指令</h4>
<h5 data-id="heading-23">指令编写</h5>
<pre><code class="hljs language-javascript" lang="javascript">src\utils\directive\modules\longPress.<span class="hljs-property">ts</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// modules/longPress.ts</span>

interface <span class="hljs-title class_">LongPressBinding</span> {
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>;
  arg?: number; <span class="hljs-comment">// 长按时间，单位毫秒，默认500ms</span>
  modifiers?: {
    stop?: boolean; <span class="hljs-comment">// 是否阻止事件冒泡</span>
    prevent?: boolean; <span class="hljs-comment">// 是否阻止默认事件</span>
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> longPress = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el: HTMLElement, binding: LongPressBinding</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> binding.<span class="hljs-property">value</span> !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'v-longPress 指令需要一个函数作为值'</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">let</span> <span class="hljs-attr">pressTimer</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">startTime</span>: number = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Number</span>(binding.<span class="hljs-property">arg</span>) || <span class="hljs-number">500</span>;
    <span class="hljs-keyword">const</span> isStop = binding.<span class="hljs-property">modifiers</span>?.<span class="hljs-property">stop</span> || <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> isPrevent = binding.<span class="hljs-property">modifiers</span>?.<span class="hljs-property">prevent</span> || <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">start</span> = (<span class="hljs-params">e: MouseEvent | TouchEvent</span>) =&gt; {
      <span class="hljs-keyword">if</span> (isPrevent) {
        e.<span class="hljs-title function_">preventDefault</span>();
      }
      <span class="hljs-keyword">if</span> (isStop) {
        e.<span class="hljs-title function_">stopPropagation</span>();
      }

      startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      
      pressTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        binding.<span class="hljs-title function_">value</span>(e);
      }, duration);
    };

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">cancel</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (pressTimer) {
        <span class="hljs-built_in">clearTimeout</span>(pressTimer);
        pressTimer = <span class="hljs-literal">null</span>;
      }
    };

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">end</span> = (<span class="hljs-params">e: MouseEvent | TouchEvent</span>) =&gt; {
      <span class="hljs-keyword">const</span> endTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      <span class="hljs-keyword">const</span> timeDiff = endTime - startTime;
      
      <span class="hljs-comment">// 如果按住时间小于设定时间，则视为普通点击</span>
      <span class="hljs-keyword">if</span> (timeDiff &lt; duration &amp;&amp; pressTimer) {
        <span class="hljs-title function_">cancel</span>();
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-title function_">cancel</span>();
    };

    <span class="hljs-comment">// 添加事件监听器</span>
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mousedown'</span>, start);
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'touchstart'</span>, start);
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseup'</span>, end);
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'touchend'</span>, end);
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseleave'</span>, cancel);
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'touchcancel'</span>, cancel);

    <span class="hljs-comment">// 保存清理函数到元素上</span>
    (el <span class="hljs-keyword">as</span> any).<span class="hljs-property">_longPressCleanup</span> = <span class="hljs-function">() =&gt;</span> {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mousedown'</span>, start);
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'touchstart'</span>, start);
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseup'</span>, end);
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'touchend'</span>, end);
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseleave'</span>, cancel);
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'touchcancel'</span>, cancel);
      <span class="hljs-title function_">cancel</span>();
    };
  },

  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el: HTMLElement</span>) {
    <span class="hljs-comment">// 清理事件监听器</span>
    <span class="hljs-keyword">if</span> ((el <span class="hljs-keyword">as</span> any).<span class="hljs-property">_longPressCleanup</span>) {
      (el <span class="hljs-keyword">as</span> any).<span class="hljs-title function_">_longPressCleanup</span>();
    }
  }
};

</code></pre>
<h5 data-id="heading-24">指令使用</h5>
<p>测试一下我们的按钮指令，效果ok</p>
<pre><code class="hljs language-javascript" lang="javascript">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-6 space-y-4"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 基础用法，默认500ms --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-longPress</span>=<span class="hljs-string">"handleLongPress"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"</span>
    &gt;</span>
      长按按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 自定义长按时间 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-longPress:1000</span>=<span class="hljs-string">"handleLongPress"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"</span>
    &gt;</span>
      1秒长按按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 阻止事件冒泡 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-longPress.stop</span>=<span class="hljs-string">"handleLongPress"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600"</span>
    &gt;</span>
      阻止冒泡长按按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 阻止默认事件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
      <span class="hljs-attr">v-longPress.prevent</span>=<span class="hljs-string">"handleLongPress"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"</span>
    &gt;</span>
      阻止默认事件长按按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLongPress</span> = (<span class="hljs-params">event: MouseEvent | TouchEvent</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'长按触发'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>());
  <span class="hljs-comment">// 这里可以添加你的长按处理逻辑</span>
  <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MouseEvent</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'鼠标事件'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'触摸事件'</span>);
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从人力推车到智能引擎：QA 智绘项目的测试用例自动生成术]]></title>    <link>https://juejin.cn/post/7587335187073024026</link>    <guid>https://juejin.cn/post/7587335187073024026</guid>    <pubDate>2025-12-25T02:54:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587335187073024026" data-draft-id="7587336857538002953" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从人力推车到智能引擎：QA 智绘项目的测试用例自动生成术"/> <meta itemprop="keywords" content="测试,AI编程"/> <meta itemprop="datePublished" content="2025-12-25T02:54:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雪球工程师团队"/> <meta itemprop="url" content="https://juejin.cn/user/2664871914644525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从人力推车到智能引擎：QA 智绘项目的测试用例自动生成术
            <!----> <!----></h1> <div class="container team-follow" data-v-d326b38e="" data-v-61fb5e44=""><div class="left" data-v-d326b38e=""><a href="/team/6942370795716870178/posts" data-v-d326b38e=""><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962ff7fb0a7e485e8a67c02675746756~tplv-k3u1fbpfcp-watermark.image" class="icon" data-v-d326b38e=""/></a> <div class="content" data-v-d326b38e=""><div style="display: flex" data-v-d326b38e=""><a href="/team/6942370795716870178/posts" data-v-d326b38e=""><p class="title-line" data-v-d326b38e=""><span title="雪球工程师团队" class="title" data-v-d326b38e="">雪球工程师团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-d326b38e=""/></p></a></div> <div class="meta-box team" data-v-d326b38e="" data-v-61fb5e44=""><time datetime="2025-12-25T02:54:44.000Z" title="Thu Dec 25 2025 02:54:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-d326b38e="" data-v-61fb5e44="">
                2025-12-25
              </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-d326b38e="" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/></svg> <span class="views-count" style="display:none;" data-v-d326b38e="" data-v-61fb5e44="">
                0
              </span> <span class="read-time" data-v-d326b38e="" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-d326b38e="" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-d326b38e="" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-d326b38e="" data-v-61fb5e44=""/></svg>
                阅读14分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-b60b2868="" data-v-d326b38e=""><span data-v-b60b2868="" data-v-d326b38e=""><i class="byte-icon byte-icon--plus" data-v-d326b38e=""><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"/><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"/></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-61fb5e44=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-61fb5e44=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""/> </div> <!----> <span class="position ellipsis" data-v-61fb5e44="">
              @雪球财经
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ed90e7850674bf1aa57b637b17c36e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=Qbc%2B8feZFyze7wXII84hlJ%2BSHq8%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>导读：</p>
<h4 data-id="heading-0">构建一台“测试用例生成引擎”——驱动质量左移的智能飞轮</h4>
<p>软件质量不是终点，而是一个持续加速的飞轮。</p>
<p>传统测试像靠人力推车，缓慢且迟滞；而 AI 辅助的用例开发，则是为这个飞轮装上一台智能引擎。</p>
<p>这台引擎由七大核心组件驱动：专属数据输入、智能需求解析、测试场景建模、用例迭代生成、变更动态感知、标准化输出适配、自动化执行集成。</p>
<p>当七者协同运转，引擎轰鸣启动——用例自动生成、风险提前暴露、反馈闭环加速，真正实现“质量内建，左移落地”。</p>
</blockquote>
<h2 data-id="heading-1">一、背景</h2>
<p>QA同学一定懂这个痛点：长期使用固定测试用例集或同一测试方法，软件会像生物抗药性一样产生“测试免疫力”，缺陷发现效率越来越低——这就是测试领域的“杀虫剂悖论”。</p>
<p>为了应对这个问题，我们一直靠持续迭代用例、动态扩充数据、组合交叉测试等方法维持有效性。但随着项目快速迭代，业务场景和功能模块越来越多，新的难题又冒了出来：</p>
<ul>
<li>
<p>需求分析、用例开发维护复杂度飙升：既要精准对齐新增功能细节，又要兼顾回归用例兼容性，有限时间里得反复梳理新旧场景关联；</p>
</li>
<li>
<p>用例库累积成负担：日常维护要耗费大量精力更新适配，需求紧急时还容易陷入“旧用例覆盖不到新场景、新用例兼顾不到老逻辑”的被动；</p>
</li>
<li>
<p>“测试免疫力”问题放大：高频迭代下，传统方法的局限性越来越明显，拖慢测试节奏的同时，缺陷漏测风险也在增加。</p>
</li>
</ul>
<p>在AI技术爆发的当下，我们决定跳出传统框架，打造**「QA智绘」**项目，用智能破解“抗药性”，从根本上杜绝“雪球测试”中的杀虫剂效应。</p>
<h2 data-id="heading-2">二、「QA智绘」之Feature测试用例生成：三层架构搞定自动化</h2>
<p>传统测试用例开发，QA要走完“需求分析→用例设计→评审优化→管理维护”全流程。考虑到用例评审是产研测三方对齐逻辑的关键节点，因此我们优先聚焦另外三个环节，结合大模型能力搭建了“输入-生成-输出”三层AI自动生成架构，再依托Dify基建能力做全链路支撑。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39a5676132024be7bfaedd1e790b5004~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=y7oy%2Bf2KW%2Fj7b9VzwJDfmRn8B9U%3D" alt="" loading="lazy"/></p>
<ul>
<li>
<p><strong>输入层</strong>完成对数据源的自动集成与智能关联，从根源消弭需求传递中的歧义；</p>
</li>
<li>
<p><strong>生成层</strong>以 Dify 提供的工作流引擎、多模型调度、Prompt+思维链架构为底座，搭配接入的工具适配能力，驱动核心模块完成从需求分析、需求点分解到用例生成与优化的全流程自动化；</p>
</li>
<li>
<p><strong>输出层</strong>通过人机协同机制，实现测试用例的持续迭代与标准化闭环交付。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/711e04cb11124b2a811a710d1566a2fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=U%2FFR%2FwXoJHqU9sGJZ4DfwSti5Es%3D" alt="" loading="lazy"/></p>
<div align="center">Feature用例生成的三层架构</div>
<p>简单说，这个体系的核心就是一套智能增强决策系统：接收需求后，会按严密的“思考链”做任务分解、逻辑推理和结果验证，最终实现用例的自动化生成与标准化交付。下面我们逐层拆解核心逻辑：</p>
<h4 data-id="heading-3">1. 输入层：智能化的数据整合分析</h4>
<p>高质量用例的前提是完整的需求分析，但人工分析很容易出问题：对业务逻辑理解不到位、需求变更跟进滞后、个人经验局限导致风险判断不足……为了解决这些痛点，我们整合了四大数据源，搭配Prompt工程+思维链，打造了一个“会思考”的测试数据中枢。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/745e69d1a74f454ba609eff1fce2e378~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=f665%2BJWc3NEoV4V1%2FC%2BbYBJD6Jw%3D" alt="" loading="lazy"/></p>
<p>这个中枢的核心能力有4个：</p>
<ul>
<li>
<p><strong>语义深度推理与风险预判</strong>：利用LLM（大语言模型）深度解析业务逻辑、用户旅程与复杂规则（如“支付流程中手续费计算规则”）；自动标识<strong>高风险功能点</strong>（如资损相关操作）；</p>
</li>
<li>
<p><strong>视觉化上下文理解</strong>：集成<strong>VLM（视觉大模型）与OCR技术</strong>，让AI“看懂”UI界面，识别元素状态与设计冲突，为交互测试与视觉兼容性测试构建像素级判定基线；</p>
</li>
<li>
<p><strong>历史经验的知识化复用</strong>：通过用<strong>RAG（检索增强生成）技术</strong>检索雪球知识库与历史用例，补全业务背景、映射功能模块关联，为AI装配上“资深测试专家的记忆库”；</p>
</li>
<li>
<p>**Prompt +思维链：**以 “需求分析→业务拆解→用例生成” 为核心框架，按业务特征差异化定制各模块的核心侧重点、输入输出规范及 Prompt 逻辑。通过模块化降低模型认知负担，精准适配业务风险，避免用例覆盖不全或冗余。</p>
</li>
</ul>
<p>输入层作为一个智能化的**数据整合分析中心，**将原本孤立、静态的数据资产，转化为动态可推理的“活化知识图谱”，使测试设计从源头就立足于全面精准的数据支撑；并将分散的需求信息、技术背景与历史经验，转化为可落地、可量化的测试策略，从根源上化解需求歧义、打破数据孤岛、填补覆盖盲区，为后续用例生成筑牢基础。</p>
<h4 data-id="heading-4">2. 生成层：AI驱动的用例智能生产链</h4>
<p>完成上游多源信息的智能融合后，流程即进入核心的测试用例生成阶段。该阶段将系统性落地 “需求分析→需求点分析与分组→用例初步生成→用例评分→用例优化” 全流程，确保每一步衔接有序、闭环可控。</p>
<p>以其中的用例生成环节为例：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18c0c70d26c14362ad43ab1ad6792a63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=4pnHPlJ8NrUZiFOIA3kLeqXnZww%3D" alt="" loading="lazy"/></p>
<ul>
<li>
<p><strong>需求点预分组，规避输入过载与输出截断</strong>：用DAG分析把复杂需求拆分成多个高内聚的“需求点包”，再序列化输入，解决大模型上下文过载问题，避免逻辑遗漏与输出截断；</p>
</li>
<li>
<p>**多模型协同，提升用例思维的深度与广度：**结合不同模型优势，生成覆盖正常、异常、探索性场景的多样化用例，避免单一模型遗漏深层隐匿的缺陷；</p>
</li>
<li>
<p>**标注模板约束，确保用例产出的标准化：**以JSON Schema定义数据模型，确保用例包含“前置条件→操作步骤→预期结果”等要素，再借助 Jinja 模板转换为标准格式，提升后续评审、执行、维护效率；</p>
</li>
<li>
<p>**反思(Reflection)模式，驱动用例循环强化：**内置多维度质量量化评分算法，从完整性、准确性、可执行性、覆盖度等维度打分，低于阈值自动打回重生成，形成“评估-反馈-优化”闭环，保障用例质量。</p>
</li>
</ul>
<h4 data-id="heading-5">3. 输出层：标准化闭环交付</h4>
<p>经过生成层的拆解、评估、优化，用例最终在输出层完成交付。输出层的核心目标是确保AI生成的测试用例能够<strong>安全、可靠地融入现有工具链</strong>，实现从生成到可用的“最后一公里”闭环。其运作依赖于两大关键机制：</p>
<ul>
<li>
<p><strong>人机协同审核</strong>：建立“AI初筛-人工复核”的协作模式。人工重点校验上下文一致性（确保用例对应需求节点）和业务规则准确性，规避AI“幻觉”风险，给用例质量兜底；</p>
</li>
<li>
<p><strong>结构化分发</strong>：审核通过的用例会被自动赋予丰富的<strong>结构化标签</strong>（如关联需求ID、测试类型、优先级P0-P2），完成“资产化”封装。随后，通过预定义的API接口，将用例同步到飞书、MeterSphere、雪峰后台等目标平台，实现测试资产的<strong>无缝集成</strong>与<strong>端到端可追溯。</strong></p>
</li>
</ul>
<p>至此，Feature测试用例自动生成系统已正式落地交付。在社区平台业务的实际应用中，自动生成用例的有效率达70%以上，显著节省了人工投入、提升了测试效率。后续我们将持续精进这一能力，并逐步拓展至更多业务场景。</p>
<blockquote>
<p>搞定功能级用例生成后，我们把目光投向了前后端协作的核心纽带——接口层。毕竟接口的稳定性直接关系业务流程可靠性，「QA智绘」的智能生成能力也随之延伸到了接口测试领域。</p>
</blockquote>
<h2 data-id="heading-6">三、 「QA智绘」之接口用例自动化：双核思路破解测试痛点</h2>
<p>做接口测试，最头疼的两件事：一是用例容易覆盖不全、分支漏测；二是用例维护难，代码迭代一次就要维护半天。这正是我们设计「QA智绘」之接口用例自动化系统的直接原因。为了彻底解决这些痛点，我们带来了一套可落地的完整方案：通过深挖调用链吃透接口代码，实现用例的代码级全覆盖；再借助AI闭环自优化，让用例越用越精准，从而真正摆脱重复低效的手动操作。该设计已在系统的四层架构中全面落地，形成从问题识别到自主优化的完整闭环。如图所示：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/242ab04b30744577a0aa8947d8b64daf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=ifl1fWbTSWdY1aZkThXdsbMkSlA%3D" alt="" loading="lazy"/></p>
<p>整个系统采用清晰的分层设计，各层各司其职又紧密协同：</p>
<ul>
<li>
<p>**基建支撑层：打下坚实的“地基” ，**包含调用链工程、AI模型配置与MCP服务、MySQL与系统配置，为上层能力提供核心支撑；</p>
</li>
<li>
<p>**核心业务层：承载核心解决方案，**这是系统的“大脑”和“中枢”。包含AI用例生成模块、用例执行模块、结果分析模块、用例质量评估模块，让用例库“越用越精准”，从而解决“维护难”的挑战；</p>
</li>
<li>
<p>**应用层：统一治理与可视化平台，**通过雪峰系统，我们将核心能力转化为用户可便捷操作的产品界面，包含接口管理、用例管理、结果展示，让技术能力适用所有QA和研发同学；</p>
</li>
<li>
<p>**接入层：接入研发生态，**通过对接Git、YAPI、雪峰等现有研发工具链，系统能够自动获取接口定义、代码变更等关键信息，实现流程的无缝集成，让测试左移和持续测试成为自然流程。</p>
</li>
</ul>
<p>基于以上对系统架构的分层解析，我们可以看到，整个系统并非简单的功能堆砌，而是为彻底解决文章开头提出的痛点，所精心构建的一条技术实现路径，这条路径在架构中清晰可见，并最终凝结为支撑「QA智绘」高效运行的三个核心议题。</p>
<h4 data-id="heading-7">1. 用例全覆盖：代码+调用链双驱动</h4>
<p>很多时候需求文档里只有接口的表面规则，那些隐性校验、异常分支、模块依赖，根本无从知晓。而“代码+调用链”的双驱动模式，就能把这些隐藏的逻辑全挖出来。核心目标很简单：<strong>让每一行核心代码都有对应的测试用例，每一个分支逻辑都被覆盖</strong>。</p>
<p>之前我们在《代码"蝴蝶效应"终结者:Al Review+AST联展,构建智能测试防御新体系》一文中，已经搭建好了代码导航系统，能清晰梳理出每个方法之间的调用关系。基于这个系统，我们就能获取接口从上到下的完整调用链代码，再让AI按规则<strong>一键生成代码全覆盖用例</strong>。如图所示：「QA智绘」之接口用例自动化项目系统性地通过 “多源数据整合→ 多模型独立探索 → 智能融合仲裁” 三步法，来最大化逼近测试用例的全覆盖。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97abf730c9f845ac9978e14ef412b7ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=WfybljbBEIwQIUVW%2BhHR%2BR5Aa%2B4%3D" alt="" loading="lazy"/></p>
<ul>
<li>
<p><strong>多源数据整合，构建全景认知（数据驱动）</strong>：流程始于对接口的360度深度透视。自动化地从多个关键数据源同步获取信息，形成一份整合的Prompt，从源头确保生成用例的输入信息是全面、立体且准确的；</p>
</li>
<li>
<p><strong>多模型独立探索，激发思维多样性（智能驱动）</strong>：这是确保覆盖范围、避免单一模型思维局限的关键设计。系统并行发起三次异步调用，从不同视角独立构思测试方案，从而汇集多样化的测试想法，有效避免了因单一AI思路固化导致的覆盖盲区；</p>
</li>
<li>
<p><strong>智能融合仲裁，生成最优集（闭环优化）</strong>：并行探索产出了三份各有侧重、可能存在冗余或冲突的用例草案。系统引入了关键的第四次模型调用，扮演“首席测试架构师”的角色，确保最终入库的用例集是“1+1+1 &gt; 3”的高质量、高可信度成果。</p>
</li>
</ul>
<h4 data-id="heading-8">2. 覆盖率可视化：代码染色直观验证</h4>
<p>AI生成用例后，怎么确认是不是真的全覆盖了？答案是「<strong>代码染色</strong>」。</p>
<p>通过可视化界面，被覆盖的代码会标注一种颜色，未覆盖的标注另一种颜色，哪些地方没测到、哪些地方已达标，一目了然。不用再手动核对，效率直接拉满！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ae0dd53846d48ada8d1140a42d50cff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=V3AaDsMz98KkXvNjxqZwjsCQMAE%3D" alt="" loading="lazy"/></p>
<p>这正是我们“代码+调用链”双驱动模式价值的直观体现。通过调用链分析，AI能够精准生成触及深层逻辑的用例；而通过代码染色的可视化验证，覆盖结果变得一目了然。让质量保障从生成到验证，形成一个完整、可信的闭环。</p>
<h4 data-id="heading-9">3. AI用例自优化：闭环驱动，告别手动维护</h4>
<p>解决了漏测问题，再来看用例维护难的痛点。核心思路是搭建「生成→执行→反馈→优化」的闭环，靠MCP模型协作、人工审核、调试结果反哺，让用例越用越精准，彻底告别手动修改。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4417f7fe5c04c6db3c191d7075624f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=ngxyuJsQbU3Oh5yyPvcN41RJMKY%3D" alt="" loading="lazy"/></p>
<ul>
<li>
<p><strong>MCP服务：贴合业务，生成高质量初始用例</strong>。初始用例的质量很关键，直接影响后续优化效率。我们结合MCP服务，让AI能精准匹配业务场景，生成的初始用例不仅覆盖全面，还能贴合实际业务逻辑，不用再从零开始打磨。</p>
</li>
<li>
<p><strong>调试结果反哺：自动修正，用例“自我迭代”</strong>。用例生成后会自动执行，系统会对比实际执行结果与预期结果。如果出现偏差，就会自动分析原因，修正用例中的参数、断言等内容——相当于用例在“自我迭代”，不用人工逐个修改。</p>
</li>
<li>
<p><strong>人工审核迭代：精准打磨，查漏补缺</strong>。当然，AI优化也需要人工辅助把关。我们可以对用例进行审核打标签，比如“有效”“无效”“重复”等。这些标签会反哺给AI，后续生成用例时，就能针对性地查漏补缺，让用例质量越来越高。</p>
</li>
</ul>
<h2 data-id="heading-10">四、小结</h2>
<p>随着「QA智绘」-AI Case Generation 的正式落地，叠加持续建设的 AI TestExec、AI Code Review 能力，再依托雪峰系统和全域 AST 代码调用链的底层技术支撑，雪球 AI Quality 项目已初步搭建起质量域的智能闭环体系。</p>
<p>在核心的智能质量环节，实现 “<strong>用例自动生成-测试自动执行-代码自动检测</strong>” 的全流程自动化：</p>
<p>✅ AI Case Generation：可基于业务需求智能拆解测试点，自动生成 Feature 用例与接口用例并直接执行；</p>
<p>✅ AI TestExec：承接用例执行任务，完成回归测试的自动调度、智能断言与结果分析；</p>
<p>✅ AI Code Review：依托 AST 调用链感知代码变更，自动评估影响范围并将分析结果精准推送至对应负责人；</p>
<p>这一系列能力的联动，已推动雪球的质量保障模式从 “人工主导的重复劳动” 向 “智能驱动的精准保障” 完成了初步转型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ab5d987828a432e8f0a99a2de6c4d39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=FXxiEPb7yhdwXYNdAv0MHZXzJbY%3D" alt="" loading="lazy"/></p>
<p>未来，雪球 AI Quality 将围绕 “能力深化+流程打通+生态协同” 三个方向持续迭代：</p>
<p>一方面，细化三大核心能力的精度，夯实智能化基础；</p>
<p>另一方面，打通各模块数据流转链路，构建 “业务需求-测试用例-执行结果-代码风险” 的联动反馈机制 —— 用例迭代反哺需求分析完整性，执行失败自动关联代码变更，代码风险同步更新用例补充清单，实现双向闭环；</p>
<p>同时，推动三大能力与研发协作工具深度对接，融入产研全流程，形成 “智能质量保障+研发协作” 的一体化生态。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a51df5c9281344db93c0cef9040e43dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuq55CD5bel56iL5biI5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236084&amp;x-signature=qAUTt0EMHf5xSCygaFCaXDjN%2Fac%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零到一搭建SpringCloud微服务，一场代码世界的“分家”大戏]]></title>    <link>https://juejin.cn/post/7587284708947836943</link>    <guid>https://juejin.cn/post/7587284708947836943</guid>    <pubDate>2025-12-25T02:29:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587284708947836943" data-draft-id="7587277503947407360" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零到一搭建SpringCloud微服务，一场代码世界的“分家”大戏"/> <meta itemprop="keywords" content="后端,Java,Spring Cloud"/> <meta itemprop="datePublished" content="2025-12-25T02:29:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="悟空码字"/> <meta itemprop="url" content="https://juejin.cn/user/3139860942296830"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零到一搭建SpringCloud微服务，一场代码世界的“分家”大戏
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860942296830/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    悟空码字
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:29:28.000Z" title="Thu Dec 25 2025 02:29:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是小悟。</p>
<h2 data-id="heading-0">第一部分：微服务是什么？一场“分家过日子”的哲学</h2>
<p>你开了一家超级火爆的“程序猿餐厅”，一开始所有菜都在一个大厨房做：</p>
<ul>
<li><strong>单体架构</strong>：一个厨子（服务器）包揽所有菜，点单、炒菜、煲汤、洗碗全管</li>
<li>客人点个蛋炒饭，整个厨房都得动起来</li>
<li>想升级蛋炒饭配方？得关店装修（停机部署）</li>
<li>厨子感冒了？全店停业（单点故障）</li>
</ul>
<p><strong>微服务就像把大厨房拆了</strong>：</p>
<ul>
<li>蛋炒饭部、火锅部、奶茶部各自独立</li>
<li>每个部门有自己的小厨房（服务实例）</li>
<li>通过传菜机器人（服务通信）协作</li>
<li>奶茶部炸了？没事，蛋炒饭照常供应（故障隔离）</li>
</ul>
<h2 data-id="heading-1">第二部分：开干！八步搭建SpringCloud全家桶</h2>
<h3 data-id="heading-2">先拜码头（环境准备）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 必备三件套</span>
Java 11+（别用Java 8了，它都退休了）
Maven 3.6+（Java界的包工头）
IDE（IntelliJ IDEA - 程序员的法拉利）
</code></pre>
<h3 data-id="heading-3">第1步：创建父工程 - 家族的“族谱”</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pom.xml - 家族总章程 --&gt;</span>
<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.coder.micro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-family<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 声明SpringCloud版本 - 家族用的家规版本 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.version</span>&gt;</span>2021.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">spring.boot.version</span>&gt;</span>2.7.14<span class="hljs-tag">&lt;/<span class="hljs-name">spring.boot.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 依赖管理 - 所有子孙该用什么版本 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.cloud.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>gateway<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>order-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">第2步：Eureka服务注册中心 - 家族的“户口本”</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 想象成家族微信群：</span>
<span class="hljs-comment"># 谁在（服务上线）@所有人</span>
<span class="hljs-comment"># 谁睡了（服务下线）改备注</span>
<span class="hljs-comment"># 谁失联了（心跳检测）踢出群</span>
</code></pre>

<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// EurekaServerApplication.java - 户口本管理员</span>
@SpringBootApplication
@EnableEurekaServer  <span class="hljs-comment">// 开启户口本功能</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerApplication</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {
        SpringApplication.run(EurekaServerApplication.<span class="hljs-keyword">class</span>, args);
    }
}

<span class="hljs-comment">// application.yml - 户口本配置</span>
server:
  port: <span class="hljs-number">8761</span>  <span class="hljs-meta"># 户口本办公室门牌号</span>

eureka:
  client:
    register-<span class="hljs-keyword">with</span>-eureka: <span class="hljs-literal">false</span>  <span class="hljs-meta"># 户口本不用自己登记自己</span>
    fetch-registry: <span class="hljs-literal">false</span>  <span class="hljs-meta"># 不用拉取别人的信息</span>
  server:
    eviction-interval-timer-<span class="hljs-keyword">in</span>-ms: <span class="hljs-number">30000</span>  <span class="hljs-meta"># 30秒检查一次谁失联了</span>
</code></pre>
<h3 data-id="heading-5">第3步：API网关 - 家族的“前台小姐姐”</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">//</span> <span class="hljs-string">GatewayApplication.java</span>
<span class="hljs-string">@SpringBootApplication</span>
<span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">GatewayApplication</span> {
    <span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(String</span>[] <span class="hljs-string">args)</span> {
        <span class="hljs-string">SpringApplication.run(GatewayApplication.class</span>, <span class="hljs-string">args);</span>
    }
}

<span class="hljs-string">//</span> <span class="hljs-string">Gateway配置</span> <span class="hljs-bullet">-</span> <span class="hljs-string">前台路由规则</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-service</span>  <span class="hljs-comment"># 找点单部的路</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://ORDER-SERVICE</span>  <span class="hljs-comment"># lb=负载均衡，像电梯分流入流</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/orders/**</span>  <span class="hljs-comment"># 所有/orders开头的请求</span>
            
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span>  <span class="hljs-comment"># 找会员部的路</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://USER-SERVICE</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/users/**</span>
            
        <span class="hljs-comment"># 全局过滤器 - 前台的小本本</span>
      <span class="hljs-attr">default-filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-From,</span> <span class="hljs-string">gateway</span>  <span class="hljs-comment"># 给每个请求盖个章</span>
</code></pre>
<h3 data-id="heading-6">第4步：订单服务 - 家族的“点单部”</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// OrderServiceApplication.java</span>
<span class="hljs-variable">@SpringBootApplication</span>
<span class="hljs-variable">@EnableEurekaClient</span>  <span class="hljs-comment">// 大喊一声：我上线了！</span>
<span class="hljs-variable">@EnableFeignClients</span>  <span class="hljs-comment">// 开启“打电话”功能</span>
public class OrderServiceApplication {
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) {
        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(OrderServiceApplication.class, args);
    }
}

<span class="hljs-comment">// OrderController.java - 点单部接待处</span>
@<span class="hljs-selector-tag">RestController</span>
@<span class="hljs-selector-tag">RequestMapping</span>(<span class="hljs-string">"/orders"</span>)
@<span class="hljs-selector-tag">Slf4j</span>
<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">OrderController</span> {
    
    <span class="hljs-variable">@Autowired</span>
    private UserServiceClient userServiceClient;  <span class="hljs-comment">// 用户部的联系电话</span>
    
    <span class="hljs-variable">@PostMapping</span>
    public OrderDTO <span class="hljs-built_in">createOrder</span>(<span class="hljs-variable">@RequestBody</span> OrderRequest request) {
        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"接到新订单：{}"</span>, request);
        
        <span class="hljs-comment">// 打个电话问用户部：这人是不是VIP？</span>
        <span class="hljs-selector-tag">UserDTO</span> <span class="hljs-selector-tag">user</span> = <span class="hljs-selector-tag">userServiceClient</span><span class="hljs-selector-class">.getUser</span>(request.<span class="hljs-built_in">getUserId</span>());
        
        <span class="hljs-selector-tag">if</span> (user.<span class="hljs-built_in">isVip</span>()) {
            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"VIP用户，加急处理！"</span>);
            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">processVipOrder</span>(request);
        }
        
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">processNormalOrder</span>(request);
    }
    
    <span class="hljs-comment">// 假装这里有很多业务逻辑...</span>
    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">OrderDTO</span> <span class="hljs-selector-tag">processVipOrder</span>(OrderRequest request) {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">OrderDTO</span><span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.orderId</span>(UUID.<span class="hljs-built_in">randomUUID</span>().<span class="hljs-built_in">toString</span>())
                <span class="hljs-selector-class">.status</span>(<span class="hljs-string">"VIP_优先处理"</span>)
                <span class="hljs-selector-class">.message</span>(<span class="hljs-string">"老板，您的订单已插队！"</span>)
                <span class="hljs-selector-class">.build</span>();
    }
}
</code></pre>
<h3 data-id="heading-7">第5步：用户服务 - 家族的“会员部”</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// UserController.java</span>
<span class="hljs-variable">@RestController</span>
<span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/users"</span>)
<span class="hljs-variable">@Slf4j</span>
public class UserController {
    
    <span class="hljs-comment">// 用户部的VIP名单</span>
    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>, <span class="hljs-selector-tag">UserDTO</span>&gt; <span class="hljs-selector-tag">userDatabase</span> = <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HashMap</span>&lt;&gt;();
    
    @<span class="hljs-selector-tag">PostConstruct</span>
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">init</span>() {
        <span class="hljs-selector-tag">userDatabase</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"1001"</span>, new <span class="hljs-built_in">UserDTO</span>(<span class="hljs-string">"1001"</span>, <span class="hljs-string">"张大款"</span>, true));
        <span class="hljs-selector-tag">userDatabase</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"1002"</span>, new <span class="hljs-built_in">UserDTO</span>(<span class="hljs-string">"1002"</span>, <span class="hljs-string">"李铁柱"</span>, false));
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/{userId}"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">UserDTO</span> <span class="hljs-selector-tag">getUser</span>(<span class="hljs-variable">@PathVariable</span> String userId) {
        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"查询用户：{}"</span>, userId);
        
        <span class="hljs-comment">// 模拟网络延迟</span>
        <span class="hljs-selector-tag">try</span> {
            <span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.sleep</span>(<span class="hljs-number">100</span>);
        } <span class="hljs-selector-tag">catch</span> (InterruptedException e) {
            <span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.currentThread</span>()<span class="hljs-selector-class">.interrupt</span>();
        }
        
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userDatabase</span><span class="hljs-selector-class">.getOrDefault</span>(userId, 
                new <span class="hljs-built_in">UserDTO</span>(userId, <span class="hljs-string">"未知用户"</span>, false));
    }
}
</code></pre>
<h3 data-id="heading-8">第6步：服务间通信 - 家族的“内部电话系统”</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// UserServiceClient.java - 订单部用来呼叫用户部的电话</span>
<span class="hljs-variable">@FeignClient</span>(name = <span class="hljs-string">"USER-SERVICE"</span>)  <span class="hljs-comment">// 声明要呼叫的服务名</span>
public interface UserServiceClient {
    
    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/users/{userId}"</span>)  <span class="hljs-comment">// 电话号码和拨号方式</span>
    UserDTO <span class="hljs-built_in">getUser</span>(<span class="hljs-variable">@PathVariable</span> String userId);
    
    <span class="hljs-comment">// 这就是SpringCloud的魔法：</span>
    <span class="hljs-comment">// 看起来像本地调用，实际上是HTTP请求</span>
    <span class="hljs-comment">// 像极了微信语音，看似在身边，实际可能隔了个太平洋</span>
}
</code></pre>
<h3 data-id="heading-9">第7步：配置中心 - 家族的“公告栏”</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">//</span> <span class="hljs-string">每个服务都要有这个配置</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span> <span class="hljs-string">optional:configserver:http://localhost:8888</span>  <span class="hljs-comment"># 看公告栏地址</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">fail-fast:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 公告栏坏了也不影响营业</span>
      
<span class="hljs-comment"># 公告栏上写着：</span>
<span class="hljs-comment"># order-service.yml:</span>
<span class="hljs-comment">#   优惠活动：双十一打五折</span>
<span class="hljs-comment">#   超时时间：30秒</span>
<span class="hljs-comment">#   </span>
<span class="hljs-comment"># user-service.yml:</span>
<span class="hljs-comment">#   VIP门槛：消费满10000</span>
<span class="hljs-comment">#   签到积分：10分/天</span>
</code></pre>
<h3 data-id="heading-10">第8步：熔断降级 - 家族的“应急方案”</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// OrderService中调用用户服务时</span>
<span class="hljs-variable">@FeignClient</span>(name = <span class="hljs-string">"USER-SERVICE"</span>, 
             fallback = UserServiceFallback.class)  <span class="hljs-comment">// 备胎方案</span>
public interface UserServiceClient {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 用户部失联时的备胎方案</span>
<span class="hljs-variable">@Component</span>
<span class="hljs-variable">@Slf4j</span>
public class UserServiceFallback implements UserServiceClient {
    
    <span class="hljs-variable">@Override</span>
    public UserDTO <span class="hljs-built_in">getUser</span>(String userId) {
        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.warn</span>(<span class="hljs-string">"用户服务失联，启用默认用户信息"</span>);
        
        <span class="hljs-comment">// 返回兜底数据，保证订单服务不崩溃</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">UserDTO</span><span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.userId</span>(userId)
                <span class="hljs-selector-class">.username</span>(<span class="hljs-string">"默认用户"</span>)
                <span class="hljs-selector-class">.vip</span>(false)
                <span class="hljs-selector-class">.fromFallback</span>(true)  <span class="hljs-comment">// 标记这是备胎数据</span>
                <span class="hljs-selector-class">.build</span>();
    }
}
</code></pre>
<h2 data-id="heading-11">第三部分：启动全家桶的“开机仪式”</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启动顺序很重要，像玩多米诺骨牌：</span>
1. 启动户口本（Eureka Server）
   <span class="hljs-built_in">cd</span> eureka-server &amp;&amp; mvn spring-boot:run
   <span class="hljs-comment"># 访问 http://localhost:8761 看谁在线</span>

2. 启动会员部（User Service）
   <span class="hljs-built_in">cd</span> user-service &amp;&amp; mvn spring-boot:run
   <span class="hljs-comment"># 在Eureka页面应该能看到USER-SERVICE</span>

3. 启动点单部（Order Service）
   <span class="hljs-built_in">cd</span> order-service &amp;&amp; mvn spring-boot:run

4. 启动前台（Gateway）
   <span class="hljs-built_in">cd</span> gateway &amp;&amp; mvn spring-boot:run

<span class="hljs-comment"># 测试一下：</span>
curl http://localhost:8080/api/orders \
  -X POST \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-string">'{"userId": "1001", "productId": "P001"}'</span>
  
<span class="hljs-comment"># 应该返回：VIP订单已插队！</span>
</code></pre>
<h2 data-id="heading-12">第四部分：微服务开发的“生存法则”</h2>
<h3 data-id="heading-13">1. 服务拆分原则 - “分家不分心”</h3>
<pre><code class="hljs language-diff" lang="diff">// 好的拆分：按业务能力
<span class="hljs-deletion">- 订单服务：管下单、支付、退款</span>
<span class="hljs-deletion">- 库存服务：管商品库存</span>
<span class="hljs-deletion">- 物流服务：管配送</span>

// 坏的拆分：按技术层
<span class="hljs-deletion">- Controller服务：只放Controller  // 别这么干！</span>
<span class="hljs-deletion">- Service服务：只放Service      // 这是给自己挖坑！</span>
<span class="hljs-deletion">- DAO服务：只放DAO            // 你会哭的！</span>
</code></pre>
<h3 data-id="heading-14">2. 数据库设计 - “各管各的账”</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 订单服务有自己的订单表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (
    id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">PRIMARY</span> KEY,
    user_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),  <span class="hljs-comment">-- 只存用户ID，不存用户详情</span>
    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)
    <span class="hljs-comment">-- 不在这里创建user表的外键！这是微服务大忌！</span>
);

<span class="hljs-comment">-- 用户服务有自己的用户表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (
    id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    vip_level <span class="hljs-type">INT</span>
    <span class="hljs-comment">-- 不知道订单表的存在，各过各的</span>
);
</code></pre>
<h3 data-id="heading-15">3. 分布式事务 - “家族的信任危机”</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 使用Seata处理分布式事务</span>
<span class="hljs-meta">@GlobalTransactional</span>  <span class="hljs-comment">// 分布式事务注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">placeOrder</span>(<span class="hljs-params">OrderRequest request</span>) {
    <span class="hljs-comment">// 1. 扣库存（调用库存服务）</span>
    inventoryService.<span class="hljs-title function_">reduceStock</span>(request.<span class="hljs-title function_">getProductId</span>());
    
    <span class="hljs-comment">// 2. 创建订单</span>
    orderService.<span class="hljs-title function_">createOrder</span>(request);
    
    <span class="hljs-comment">// 3. 扣款（调用支付服务）</span>
    paymentService.<span class="hljs-title function_">deductBalance</span>(request.<span class="hljs-title function_">getUserId</span>());
    
    <span class="hljs-comment">// 任何一步失败，所有操作都会回滚</span>
    <span class="hljs-comment">// 像极了"要么全部成功，要么全部撤销"</span>
}
</code></pre>
<h2 data-id="heading-16">总结：微服务之路的苦与乐</h2>
<h3 data-id="heading-17">你得到的“超能力”：</h3>
<ol>
<li><strong>独立部署</strong>：改个按钮颜色不用重启整个系统</li>
<li><strong>技术异构</strong>：订单用Java，推荐用Python，数据分析用Go</li>
<li><strong>弹性伸缩</strong>：双十一给订单服务多加10台机器</li>
<li><strong>容错性</strong>：推荐服务挂了？商品详情页照样能打开</li>
</ol>
<h3 data-id="heading-18">你面临的“挑战”：</h3>
<ol>
<li><strong>分布式debug</strong>：找bug像侦探破案，线索分布在5个服务里</li>
<li><strong>网络延迟</strong>：本地方法调用1ms，服务间调用可能100ms</li>
<li><strong>数据一致性</strong>：用户余额减少了，订单却没创建成功？</li>
<li><strong>运维复杂度</strong>：原来管1个应用，现在要管20个服务</li>
</ol>
<h3 data-id="heading-19">最后：</h3>
<p><strong>微服务不是银弹，是银制餐具</strong>：</p>
<ul>
<li>适合大型团队（各自做饭不打架）</li>
<li>适合快速迭代（各部分独立升级）</li>
<li>适合复杂系统（分而治之）</li>
</ul>
<p><strong>但如果你只是开个煎饼摊</strong>：</p>
<ul>
<li>一个平锅（单体应用）够了</li>
<li>非要搞5个小灶（微服务）？</li>
<li>光协调哪个摊鸡蛋哪个撒葱花就够你受的</li>
</ul>
<p>微服务解决的是"人"的问题，不是"技术"的问题。当团队大到需要分山头、业务复杂到需要分领域时，才是微服务登场的最佳时机。否则，你就是用导弹打蚊子——效果震撼，但真的没必要！</p>
<hr/>
<p><strong>代码世界的真理</strong>：没有最好的架构，只有最合适的架构。微服务不是终点，而是你架构演化路上的一个里程碑。创建第一个微服务，记得先从小处着手，毕竟，罗马不是一天建成的，微服务也不是一次拆完的！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6065e0ef4a9e42c48fe5059493d93033~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf56m656CB5a2X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767234567&amp;x-signature=zS2YVnvWQ9AiA4NqwqItPsqJD9Y%3D" alt="从零到一搭建SpringCloud微服务，一场代码世界的“分家”大戏.png" loading="lazy"/></p>
<p><strong>谢谢你看我的文章，既然看到这里了，如果觉得不错，随手点个赞、转发、在看三连吧，感谢感谢。那我们，下次再见。</strong></p>
<p>您的一键三连，是我更新的最大动力，谢谢</p>
<p>山水有相逢，来日皆可期，谢谢阅读，我们再会</p>
<p>我手中的金箍棒，上能通天，下能探海</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 0 搭建 React 待办应用：状态管理、副作用与双向绑定模拟]]></title>    <link>https://juejin.cn/post/7587265840066183174</link>    <guid>https://juejin.cn/post/7587265840066183174</guid>    <pubDate>2025-12-24T16:01:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587265840066183174" data-draft-id="7587265840066084870" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 0 搭建 React 待办应用：状态管理、副作用与双向绑定模拟"/> <meta itemprop="keywords" content="前端,React.js,面试"/> <meta itemprop="datePublished" content="2025-12-24T16:01:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="T___T"/> <meta itemprop="url" content="https://juejin.cn/user/1599155645973066"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 0 搭建 React 待办应用：状态管理、副作用与双向绑定模拟
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1599155645973066/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    T___T
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T16:01:02.000Z" title="Wed Dec 24 2025 16:01:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>React 作为前端主流框架，其<code>单向数据流</code> <code>组件化</code> <code>状态驱动视图</code>的设计理念，看似抽象却能通过一个简单的 TodoList 案例彻底吃透。本文不只是 “解释代码”，而是从<strong>设计初衷、底层逻辑、实际价值</strong>三个维度，拆解 <code>useState</code> <code>useEffect</code>、受控组件模拟双向绑定、父子通信等核心知识点，让你不仅 “会用”，更 “懂为什么这么用”。</p>
<h2 data-id="heading-0">一、案例整体架构：先懂 “拆分逻辑”，再看 “代码细节”</h2>
<p>在动手写代码前，React 开发的第一步是<code>组件拆分</code>—— 遵循单一职责原则，把复杂页面拆成独立、可复用的小组件，这是 React 组件化思想的核心。</p>
<p>本次 TodoList 的组件拆分如下：</p>






























<table><thead><tr><th>组件名</th><th>核心职责</th><th>核心交互</th></tr></thead><tbody><tr><td>App（根组件）</td><td>全局状态管理 + 核心逻辑封装</td><td>定义新增 / 删除 / 切换待办、数据持久化等方法</td></tr><tr><td>TodoInput</td><td>待办输入 + 提交</td><td>收集用户输入，触发 “新增待办” 逻辑</td></tr><tr><td>TodoList</td><td>待办列表渲染</td><td>展示待办项，转发 “删除 / 切换完成状态” 事件</td></tr><tr><td>TodoStats</td><td>待办数据统计</td><td>展示总数 / 已完成 / 未完成数，触发 “清除已完成” 逻辑</td></tr></tbody></table>
<p>这种拆分的核心价值：<strong>每个组件只做一件事，便于维护、复用和调试</strong>（比如后续想改输入框样式，只动 TodoInput 即可，不影响列表和统计逻辑）。</p>
<h2 data-id="heading-1">二、核心 API 深度拆解：不止 “会用”，更懂 “为什么这么设计”</h2>
<h3 data-id="heading-2">1. useState：React 状态管理的 “灵魂”</h3>
<p>React 中所有<strong>可变数据</strong>都必须通过**状态（State）**管理，而 <code>useState</code> 是最基础、最核心的状态钩子 —— 它解决了 “函数组件无法拥有自身状态” 的问题，也是 “状态驱动视图” 的核心载体。</p>
<h4 data-id="heading-3">（1）基础原理：为什么需要 useState？</h4>
<p>纯函数组件本身是 “无状态” 的（执行完就销毁，无法保存数据），而用户交互（比如输入待办、切换完成状态）必然需要 “保存可变数据”。<code>useState</code> 本质是给函数组件提供了持久化的状态存储空间，且这个存储空间和组件渲染周期绑定：</p>
<ul>
<li>状态更新 → 组件重新渲染 → 视图同步更新；</li>
<li>状态不更新 → 组件不会重复渲染，保证性能。</li>
</ul>
<h4 data-id="heading-4">（2）两种初始化方式：普通初始化 vs 惰性初始化</h4>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 方式1：普通初始化（适合简单、无计算的初始值）</span>
<span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// 方式2：惰性初始化（重点！ TodoList 中用的就是这种）</span>
<span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> saved = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'todos'</span>);
  <span class="hljs-keyword">return</span> saved ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(saved) : [];
});
</code></pre>
<p><strong>关键区别与设计初衷</strong>：</p>
<ul>
<li>普通初始化：<code>useState(初始值)</code> 中，初始值表达式会在<strong>组件每次渲染</strong>时都执行（哪怕状态没变化）；</li>
<li>惰性初始化：<code>useState(() =&gt; { ... })</code> 中，传入的函数仅在**组件首次渲染*时执行一次，后续渲染不会再跑。</li>
</ul>
<p>TodoList 中用惰性初始化的核心原因：<code>localStorage.getItem('todos')</code> 是浏览器本地读取操作，虽然开销小，但如果放在普通初始化里，每次组件渲染（比如新增 / 删除待办）都会重复读取本地存储，完全没必要；而惰性初始化只执行一次，既拿到了初始数据，又避免了性能浪费 —— 这是 React 性能优化的 “小细节”，也是理解 <code>useState</code> 设计的关键。</p>
<h4 data-id="heading-5">（3）状态更新的 “不可变原则”：为什么必须返回新值？</h4>
<p>React 规定：<strong>状态是只读的，修改状态必须返回新值，不能直接修改原状态</strong>。比如这里的 “新增待办” 逻辑：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = (<span class="hljs-params">text</span>) =&gt; {
  <span class="hljs-comment">// 错误写法：直接修改原数组（React 无法检测到状态变化，视图不更新）</span>
  <span class="hljs-comment">// todos.push({ id: Date.now(), text, completed: false });</span>
  <span class="hljs-comment">// setTodos(todos);</span>

  <span class="hljs-comment">// 正确写法：解构原数组 + 新增项，返回新数组</span>
  <span class="hljs-title function_">setTodos</span>([...todos, {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
    text,
    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
  }]);
};
</code></pre>
<p><strong>底层逻辑</strong>：React 判断状态是否变化的依据是<strong>引用是否改变</strong>。数组 / 对象是引用类型，直接修改原数组（<code>todos.push</code>），数组的引用没变化，React 会认为 “状态没改”，因此不会触发组件重新渲染；而通过 <code>[...todos]</code> 解构生成新数组，引用变了，React 才能检测到状态变化，进而更新视图。</p>
<p>这也是 React “单向数据流” 的核心体现：状态更新是 “不可变” 的，每一次状态变化都会生成新值，便于追踪数据流转（比如调试时能清晰看到每次状态更新的前后值）。</p>
<h3 data-id="heading-6">2. useEffect：副作用处理的 “专属管家”</h3>
<p>React 组件的核心职责是<strong>根据状态渲染视图</strong>，而像 “读取本地存储、发送网络请求、绑定事件监听、修改 DOM” 这类不直接参与渲染，但又必须执行的操作，统称为 “副作用（Side Effect）”。<code>useEffect</code> 是 React 专门为处理副作用设计的钩子，替代了类组件中 <code>componentDidMount</code> <code>componentDidUpdate</code> <code>componentWillUnmount</code> 等生命周期方法，且逻辑更集中。</p>
<h4 data-id="heading-7">（1）核心语法与执行机制</h4>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 副作用逻辑：比如保存数据到本地存储</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(todos));

  <span class="hljs-comment">// 可选的清理函数（比如取消事件监听、清除定时器）</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 组件卸载/依赖变化前执行</span>
  };
}, [todos]); <span class="hljs-comment">// 依赖数组：决定副作用的执行时机</span>
</code></pre>
<p><strong>执行时机的深度解析</strong>：</p>
<ul>
<li>依赖数组为空 <code>[]</code>：仅在组件<strong>首次渲染完成后</strong>执行一次（对应类组件 <code>componentDidMount</code>）；</li>
<li>依赖数组有值 <code>[todos]</code>：组件首次渲染执行 + 每次依赖项（todos）变化后执行（对应 <code>componentDidMount + componentDidUpdate</code>）；</li>
<li>无依赖数组：组件<strong>每次渲染完成后</strong>都执行（极少用，易导致性能问题）；</li>
<li>清理函数：组件卸载前 / 下一次副作用执行前触发（比如监听窗口大小变化后，卸载组件时要取消监听，避免内存泄漏）。</li>
</ul>
<h4 data-id="heading-8">（2）在 TodoList 中的核心应用：数据持久化</h4>
<p>代码中，<code>useEffect</code> 用来将 todos 同步到 localStorage，这是前端 “数据持久化” 的经典场景，我们拆解其价值：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(todos));
}, [todos]);
</code></pre>
<ul>
<li><strong>为什么 localStorage 只能存字符串？</strong> localStorage 是浏览器提供的本地存储 API，其底层设计只支持<strong>字符串键值对</strong>存储，因此存储数组 / 对象时，必须用 <code>JSON.stringify</code> 转为字符串；读取时用 <code>JSON.parse</code> 转回原数据类型，这是前端本地存储的通用规则。</li>
</ul>
<h4 data-id="heading-9">（3）useEffect 在这里的核心价值（为什么非它不可）</h4>
<h5 data-id="heading-10">1. 精准触发：只在需要时执行，保证性能</h5>
<p><code>useEffect</code> 的第二个参数（依赖数组 <code>[todos]</code>）是关键：</p>
<ul>
<li>组件首次渲染时，执行一次（把初始的 <code>todos</code> 保存到本地）；</li>
<li>只有 <code>todos</code> 发生<strong>实际变化</strong>时，才会再次执行（新增 / 删除 / 切换状态 / 清除已完成，只要 <code>todos</code> 变了，就同步保存）；</li>
<li><code>todos</code> 没变化时（比如组件因其他状态重新渲染），完全不执行，避免无效操作。</li>
</ul>
<p>对比 “写在组件顶层” 的无差别执行，<code>useEffect</code> 实现了 “按需执行”，既保证数据同步，又不浪费性能。</p>
<h5 data-id="heading-11">2. 时机正确：拿到最新的状态，避免数据不一致</h5>
<p><code>useEffect</code> 的执行时机是「组件渲染完成后」—— 也就是说，当 <code>useEffect</code> 里的代码执行时，<code>setTodos</code> 已经完成了状态更新，<code>todos</code> 一定是最新的。</p>
<p>比如新增待办时：</p>
<ol>
<li>调用 <code>addTodo</code> → 执行 <code>setTodos</code> → 组件重新渲染（<code>todos</code> 变为新值）；</li>
<li>渲染完成后，<code>useEffect</code> 检测到 <code>todos</code> 变化 → 执行保存逻辑 → 拿到的是最新的 <code>todos</code>。</li>
</ol>
<p>这就避免了 “异步更新导致保存旧值” 的问题，保证本地存储的数据和组件状态完全一致。</p>
<h5 data-id="heading-12">3. 逻辑聚合：一处监听，全场景生效</h5>
<p>不管是新增、删除、切换状态、清除已完成，只要最终导致 <code>todos</code> 变化，<code>useEffect</code> 都会自动触发保存 —— 无需在每个修改 <code>todos</code> 的函数里重复写保存逻辑，代码简洁、易维护，后续新增修改 <code>todos</code> 的逻辑（比如批量修改），完全不用动保存代码，天然符合 “开闭原则”。</p>
<h4 data-id="heading-13">（4）useEffect 的设计价值：分离 “渲染逻辑” 与 “副作用逻辑”</h4>
<p>React 追求 “组件核心逻辑纯净”—— 组件顶层只关注 “根据状态渲染什么”，副作用全部交给 <code>useEffect</code> 处理，这样：</p>
<ul>
<li>代码结构更清晰：渲染和副作用分离，一眼能区分 “视图相关” 和 “非视图相关” 逻辑；</li>
<li>便于调试：副作用的执行时机由依赖数组明确控制，能精准定位 “什么时候执行、为什么执行”；</li>
<li>避免内存泄漏：通过清理函数可优雅处理 “组件卸载后仍执行副作用” 的问题（比如请求数据时组件卸载了，清理函数可取消请求）。</li>
</ul>
<h3 data-id="heading-14">3. 受控组件：模拟双向绑定的底层逻辑</h3>
<p>Vue 中用 <code>v-model</code> 就能实现 “表单值 ↔ 数据” 的双向绑定，但 React 没有内置的双向绑定语法 —— 不是 “做不到”，而是 React 坚持<code>单向数据流</code>，通过 “受控组件” 手动模拟双向绑定，虽然代码多了几行，但能完全掌控数据流转。</p>
<h4 data-id="heading-15">（1）双向绑定的本质：视图 ↔ 数据同步</h4>
<p>不管是 Vue 的 <code>v-model</code> 还是 React 的受控组件，双向绑定的核心是两件事：</p>
<ol>
<li><strong>数据 → 视图</strong>：数据（状态）变化，视图（输入框）自动更新；</li>
<li><strong>视图 → 数据</strong>：视图（用户输入）变化，数据（状态）自动更新。</li>
</ol>
<h4 data-id="heading-16">（2）React 受控组件的实现：拆解每一步</h4>
<p>以 TodoInput 组件为例，逐行解析双向绑定的实现逻辑：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoInput</span> = (<span class="hljs-params">{ onAdd }</span>) =&gt; {
  <span class="hljs-comment">// 步骤1：定义状态存储输入框值（数据层）</span>
  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-comment">// 步骤2：处理表单提交</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
    <span class="hljs-comment">// 关键：阻止表单默认提交行为</span>
    e.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-comment">// 输入内容校验：去除首尾空格，避免空提交</span>
    <span class="hljs-keyword">const</span> text = inputValue.<span class="hljs-title function_">trim</span>();
    <span class="hljs-keyword">if</span> (!text) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 步骤3：将输入内容传给父组件（父子通信）</span>
    <span class="hljs-title function_">onAdd</span>(text);
    <span class="hljs-comment">// 步骤4：清空输入框（修改状态 → 视图清空）</span>
    <span class="hljs-title function_">setInputValue</span>(<span class="hljs-string">''</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
        // <span class="hljs-attr">核心1</span>：<span class="hljs-attr">数据</span> → <span class="hljs-attr">视图</span>（<span class="hljs-attr">状态控制输入框显示</span>）
        <span class="hljs-attr">value</span>=<span class="hljs-string">{inputValue}</span>
        // <span class="hljs-attr">核心2</span>：<span class="hljs-attr">视图</span> → <span class="hljs-attr">数据</span>（<span class="hljs-attr">输入变化同步更新状态</span>）
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setInputValue(e.target.value)}
        placeholder="请输入待办事项..."
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
};
</code></pre>
<p><strong>逐点深度解析</strong>：</p>
<ul>
<li><strong>数据 → 视图</strong>：<code>value={inputValue}</code> 是 “单向绑定” 的核心 —— 输入框显示的内容完全由 <code>inputValue</code> 状态决定，而非 DOM 自身的 value。比如执行 <code>setInputValue('')</code>，<code>inputValue</code> 变为空，输入框就会立刻清空，这是 “状态驱动视图” 的体现。</li>
<li><strong>视图 → 数据</strong>：<code>onChange</code> 事件监听输入框的每一次字符变化，<code>e.target.value</code> 是输入框当前的 DOM 取值，通过 <code>setInputValue</code> 将其同步到 <code>inputValue</code> 状态 —— 这一步是 “手动补全” 双向绑定的反向流程，也是 React 与 Vue 的核心区别（Vue 把这一步封装成了 <code>v-model</code>，React 让开发者手动控制，更灵活）。</li>
<li><strong>e.preventDefault()</strong> ：表单的默认行为是 “提交并刷新页面”，而 React 是单页应用，刷新页面会导致所有状态丢失，因此必须阻止这个默认行为 —— 这是前端开发的通用知识点，也是 React 处理表单的 “必做步骤”。</li>
<li><strong>为什么用 form + onSubmit 而非 button + onClick</strong>除了点击按钮提交，用户在输入框按<code>回车键</code>也能触发 <code>onSubmit</code>，而单纯的 <code>onClick</code> 无法响应回车提交，这是<strong>语义化 + 用户体验</strong>的双重考量。</li>
</ul>
<h4 data-id="heading-17">（3）受控组件的核心优势：完全可控</h4>
<p>相比 Vue 的 <code>v-model</code> 黑盒封装，React 受控组件的 “手动操作” 带来了两个核心价值：</p>
<ul>
<li><strong>可校验性</strong>：在 <code>onChange</code> 或 <code>handleSubmit</code> 中可随时对输入内容做校验（比如禁止输入特殊字符、限制长度、去除空格），比如在代码中 <code>inputValue.trim()</code> 就是简单的校验，若需要更复杂的校验（比如手机号格式），可直接在这一步处理；</li>
<li><strong>可追溯性</strong>：输入框的每一次值变化都必须通过 <code>setInputValue</code> 触发，在调试工具中能清晰看到 <code>inputValue</code> 的每一次更新记录，便于定位 “输入异常” 问题（比如输入框值不变，可直接查 <code>setInputValue</code> 是否执行）。</li>
</ul>
<h3 data-id="heading-18">4. 父子组件通信：单向数据流的极致体现</h3>
<p>React 的 “单向数据流” 不是 “限制”，而是 “保障”—— 数据只能从父组件通过 props 流向子组件，子组件不能直接修改父组件的状态，只能通过父组件传递的回调函数 “通知” 父组件修改状态。这种设计让数据流转路径清晰，避免了 “多个组件随意修改数据导致的混乱”。</p>
<h4 data-id="heading-19">（1）通信流程：以 “清除已完成任务” 为例</h4>
<ol>
<li><strong>父组件（App）</strong> ：定义状态修改逻辑 + 传递回调函数</li>
</ol>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 步骤1：父组件定义修改状态的核心逻辑</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">clearCompleted</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">setTodos</span>(todos.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>));
};

<span class="hljs-comment">// 步骤2：通过 props 将回调函数传递给子组件</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoStats</span> 
  <span class="hljs-attr">total</span>=<span class="hljs-string">{todos.length}</span>
  <span class="hljs-attr">completed</span>=<span class="hljs-string">{completedCount}</span>
  <span class="hljs-attr">active</span>=<span class="hljs-string">{activeCount}</span>
  <span class="hljs-attr">onClearCompleted</span>=<span class="hljs-string">{clearCompleted}</span> // <span class="hljs-attr">传递回调</span>
/&gt;</span></span>
</code></pre>
<ol start="2">
<li><strong>子组件（TodoStats）</strong> ：接收回调函数 + 触发回调</li>
</ol>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoStats</span> = (<span class="hljs-params">{ total, completed, active, onClearCompleted }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Total: {total}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Completed: {completed}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Active: {active}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      {/* 条件渲染：有已完成任务才显示按钮 */}
      {completed &gt; 0 &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClearCompleted}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"clear-btn"</span>&gt;</span>
          清除已完成任务
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><strong>深度解析</strong>：</p>
<ul>
<li>子组件 TodoStats 只负责 “展示数据 + 触发交互”，不关心 “清除已完成任务” 的具体逻辑 —— 哪怕后续修改清除逻辑（比如加确认弹窗），只需改父组件的 <code>clearCompleted</code>，子组件完全不用动，符合 “开闭原则”。</li>
<li>回调函数是 “子组件通知父组件” 的唯一方式：子组件无法直接访问父组件的 <code>todos</code> 状态，也不能直接调用 <code>setTodos</code>，只能通过父组件传递的 <code>onClearCompleted</code> 回调，触发父组件的状态修改逻辑 —— 这就是 “单向数据流”：数据向下传（父→子），事件向上传（子→父），所有状态修改都集中在父组件，便于追踪和调试。</li>
</ul>
<h4 data-id="heading-20">（2）props 的本质：只读的 “数据桥梁” (后面会单独来讲)</h4>
<p>props 是父子组件通信的唯一桥梁，但有一个核心规则：<strong>子组件不能修改 props</strong>。比如 TodoStats 接收的 <code>completed</code> <code>total</code> 等 props，子组件只能读取，不能修改 —— 因为 props 是父组件状态的 “快照”，修改 props 会导致数据源头混乱（比如子组件改了 <code>completed</code>，父组件的 <code>completedCount</code> 却没变化，数据不一致）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/013869adb5f94edcad2cc7302eb442b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767196862&amp;x-signature=PcjpbZS3MknSZBObnCXiTfAo50A%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-21">三、核心设计思想：从 TodoList 看 React 的底层逻辑</h2>
<p>通过这个 TodoList 案例，我们能提炼出 React 最核心的 4 个设计思想，这也是理解 React 的关键：</p>
<h3 data-id="heading-22">1. 状态驱动视图</h3>
<p>React 中 “视图是什么样” 完全由 “状态是什么样” 决定，没有 “手动操作 DOM” 的场景（比如不用 <code>document.getElementById</code> 改输入框值，不用 <code>appendChild</code> 加待办项）。所有视图变化，都是先修改状态，再由 React 自动更新 DOM—— 这避免了手动操作 DOM 的繁琐和易出错，也让代码更易维护（只需关注状态变化，不用关注 DOM 变化）。</p>
<h3 data-id="heading-23">2. 单向数据流</h3>
<p>数据只有一个流向：父组件 → 子组件，状态只有一个修改入口：定义状态的组件（比如 todos 定义在 App，只有 App 能改，子组件只能通过回调通知 App 改）。这种设计让数据流转 “可预测”—— 不管项目多复杂，都能顺着 props 找到数据的源头，顺着回调找到状态修改的地方。</p>
<h3 data-id="heading-24">3. 组件化与单一职责</h3>
<p>每个组件只做一件事：TodoInput 只处理输入，TodoList 只渲染列表，TodoStats 只展示统计。这种拆分让组件 “高内聚、低耦合”：</p>
<ul>
<li>高内聚：组件内部逻辑围绕核心职责展开，不掺杂其他功能；</li>
<li>低耦合：组件之间通过 props 通信，修改一个组件不会影响其他组件。</li>
</ul>
<h3 data-id="heading-25">4. 副作用与渲染分离</h3>
<p><code>useEffect</code> 将 “副作用逻辑”（比如本地存储）与 “渲染逻辑”（比如展示待办列表）分离，让组件的核心逻辑（根据状态渲染视图）保持 “纯净”—— 纯净的组件逻辑更易测试、更易复用，这也是 React 推崇的 “函数式编程” 思想的体现。</p>
<h2 data-id="heading-26">四、总结：从 TodoList 到 React 核心能力</h2>
<p>这个看似简单的 TodoList，实则涵盖了 React 日常开发的核心知识点：</p>
<ul>
<li><code>useState</code> 实现状态管理，理解 “不可变更新” 和 “惰性初始化”；</li>
<li><code>useEffect</code> 处理副作用，理解 “依赖数组” 和 “数据持久化”；</li>
<li>受控组件模拟双向绑定，理解 “状态驱动视图” 和 “单向数据流”；</li>
<li>父子组件通信，理解 props 的 “只读特性” 和回调函数的作用。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[观测云产品更新 | 应用性能监测、监控、场景、快照等]]></title>    <link>https://juejin.cn/post/7587261253913395215</link>    <guid>https://juejin.cn/post/7587261253913395215</guid>    <pubDate>2025-12-25T02:58:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587261253913395215" data-draft-id="7587322796825428008" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="观测云产品更新 | 应用性能监测、监控、场景、快照等"/> <meta itemprop="keywords" content="产品"/> <meta itemprop="datePublished" content="2025-12-25T02:58:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="可观测性用观测云"/> <meta itemprop="url" content="https://juejin.cn/user/2392958212523102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            观测云产品更新 | 应用性能监测、监控、场景、快照等
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2392958212523102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    可观测性用观测云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:58:27.000Z" title="Thu Dec 25 2025 02:58:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">观测云更新</h2>
<h3 data-id="heading-1">角色权限</h3>
<p>1、仪表板权限细化：新增独立的“仪表板新建”权限，原有“仪表板管理”权限仍包含所有操作。分配“新建”权限时会自动开启仪表板、视图基础查看权限。</p>
<p>2、导航栏根据用户的权限动态显示。若某一角色在指定模块中未获得任何权限，该模块将不会在其左侧导航栏中显示。此规则适用于以下模块：云账单、付费计划与账单、场景、事件中心、基础设施、日志、指标、应用性能监测、用户访问监测、LLM 监测、可用性监测、监控、异常追踪、安全监测。</p>
<h3 data-id="heading-2">监控</h3>
<p>1、告警策略：</p>
<ul>
<li>同时支持搜索和筛选对告警策略进行过滤；新增支持可按监控器名称（<code>checker_title</code>）、成员（<code>member</code>）进行精准筛选；</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/994b2dadc15b474b90c908f2980f362d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=qjreMKtKSXeOOQ6hV%2F2MGx8Bveg%3D" alt="" loading="lazy"/></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fmonitoring%2Fcreate-alert-setting%2F%23repeat" target="_blank" title="https://docs.guance.com/monitoring/create-alert-setting/#repeat" ref="nofollow noopener noreferrer">重复告警</a>：新增支持针对不同告警等级（如紧急、严重、警告等）分别设置重复告警的不发送时间间隔；</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f8740b87a4494d15a9f6b249d8b4867c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=notA%2B9Zg%2F7Ny%2B21isC8IYF%2BYPkk%3D" alt="" loading="lazy"/></p>
<ul>
<li>新增通知聚合规则：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fmonitoring%2Fcreate-alert-setting%2F%23custom-pattern" target="_blank" title="https://docs.guance.com/monitoring/create-alert-setting/#custom-pattern" ref="nofollow noopener noreferrer">“自定义”</a>。支持根据业务需求自由指定用于告警聚合的字段组合。输入字段名（多个字段以英文逗号分隔），系统将严格按此组合进行聚合：仅当事件数据包含所有指定字段且取值均有效时，才会触发聚合告警。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d00a84ffc9cf4689bafeb57a80ff49d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=eoYwtHmluoMM0Yppq%2B%2B21pqvucY%3D" alt="" loading="lazy"/></p>
<p>2、Arbiter 内置的 DQL 函数支持通过传入工作空间参数，查询指定空间的数据。适用于<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fmonitoring%2Fmonitor%2Fprogrammable-detection%2F" target="_blank" title="https://docs.guance.com/monitoring/monitor/programmable-detection/" ref="nofollow noopener noreferrer">可编程监控器</a>和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fsecurity%2Fcreate-detection-rules%2F" target="_blank" title="https://docs.guance.com/security/create-detection-rules/" ref="nofollow noopener noreferrer">SIEM</a> 检测规则的创建与修改场景。</p>
<h3 data-id="heading-3">应用性能监测</h3>
<p>1、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fapplication-performance-monitoring%2Fservice-manag%2Fservice-performance%2F" target="_blank" title="https://docs.guance.com/application-performance-monitoring/service-manag/service-performance/" ref="nofollow noopener noreferrer">性能指标</a>：</p>
<ul>
<li>新增 Apdex 统计，量化用户对应用性能的满意度；</li>
<li>统计指标时序可视化：将服务列表中的平均请求数、响应时间、错误数等核心统计指标，从数值展示升级为时序图形式，直观呈现变化趋势。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/064f6a32fb8d4d5aaed61f38cf2f5d47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=RJgPiJXbXKGHuEcyYlzQP%2Bl3A%2F8%3D" alt="" loading="lazy"/></p>
<p>2、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fapplication-performance-monitoring%2Fservice-manag%2Fservice-details%2F" target="_blank" title="https://docs.guance.com/application-performance-monitoring/service-manag/service-details/" ref="nofollow noopener noreferrer">服务详情</a>：</p>
<ul>
<li>支持 OpenTelemetry 服务语言的显示；</li>
<li>新增 Tab 页：服务拓扑、Profile、仪表板。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ddde2bc5985248919e5922240ed17efd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=7XoG7REo4wmZ%2BtK%2Fv%2FDc%2BHs6P4s%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">场景</h3>
<p>1、新增图表类型“<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fscene%2Fvisual-chart%2Fchange-comparison-chart%2F" target="_blank" title="https://docs.guance.com/scene/visual-chart/change-comparison-chart/" ref="nofollow noopener noreferrer">变化对比图</a>”：将指定指标在当前时段与历史同期（如昨日同一时刻、上周同日）的数值或其他指标进行量化对比，并以直观方式展现变化幅度，从而快速识别异常波动；</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90ae9e72314541a1a5d3ac9d918450aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=6ixaki0dLugufNuaoS2r5cipyAc%3D" alt="" loading="lazy"/></p>
<p>2、新建<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fscene%2Fvisual-chart%2Fpie-chart%2F" target="_blank" title="https://docs.guance.com/scene/visual-chart/pie-chart/" ref="nofollow noopener noreferrer">饼图（环形图）</a>时，当图例处于非隐藏状态，可选择是否显示 Value 值和 Value 百分比。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5d27720fc24400ba3b2b353e531530d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=Eg1xb7vg3dR3wHJr5j34LLhIqZI%3D" alt="" loading="lazy"/></p>
<p>3、图表 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fscene%2Fvisual-chart%2Fbar-chart%2F%23y" target="_blank" title="https://docs.guance.com/scene/visual-chart/bar-chart/#y" ref="nofollow noopener noreferrer">Y 轴</a>：优化原始数值展示。</p>
<h3 data-id="heading-5">快照</h3>
<p>1、快照列表样式整体优化；</p>
<p>2、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fplatform-capabilities%2Fsave-snapshot%2F%23begin-save-snapshot" target="_blank" title="https://docs.guance.com/platform-capabilities/save-snapshot/#begin-save-snapshot" ref="nofollow noopener noreferrer">保存快照</a>：新增“保存为静态时间”设置。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d8bf61c7ff7425ea0bca2cc9e211544~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=1%2BMijVF%2FpJAQTzDpKNSfoWLOAS8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">指标</h3>
<p>指标分析：查询结果中的数值新增支持灵活的显示格式设置，可设置小数位数和全精度结果展示。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a5112673ba64cfaa8f1443fbf150c11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=8pztva6HFuW5d%2FAaeaWZOdhgCz8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-7">管理</h3>
<p>1、跨工作空间授权：当数据范围选择“指标”时，可对指标授权范围进行<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fmanagement%2Fdata-authorization%2F%23scope" target="_blank" title="https://docs.guance.com/management/data-authorization/#scope" ref="nofollow noopener noreferrer">细化配置</a>；</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b957c0e453f43b4b0460c2b2849218d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=lQjDUB%2FuG0j5F55%2BSCFrs%2F8t%2FGw%3D" alt="" loading="lazy"/></p>
<p>2、<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.guance.com%2Fmanagement%2Fshare-management%2F" target="_blank" title="https://docs.guance.com/management/share-management/" ref="nofollow noopener noreferrer">分享管理</a>：新增类型快速筛选、搜索框。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29099d7557784884b4a769805708765b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767236307&amp;x-signature=O3n9WtPfylKyF4%2FqPIELCTzvcCw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">Pipelines</h3>
<p>每个数据类型新增支持设置两个默认 Pipeline（包括本地和中心 Pipeline）。</p>
<h3 data-id="heading-9">Open API</h3>
<p>仪表板跨空间查询时支持指定默认选中空间。</p>
<h2 data-id="heading-10">集成更新</h2>
<ul>
<li>新增 GCP Storage 集成；</li>
<li>新增 GCP Cloud SQL（MySQL）集成；</li>
<li>新增阿里云 VPC 对等连接集成；</li>
<li>新增 AWS Lambda Trace 集成；</li>
<li>新增阿里云 WAF 应用防火墙集成；</li>
<li>补充腾讯云 Tencent CVM / KeewiDB 视图；</li>
<li>修复 Ingress-nginx-prom 集成文档中大小写问题；</li>
<li>修复集成文档问题（包括中英文字符及格式问题）；</li>
<li>修复 TencentCloud 公网 CLB 采集器以支持非公网 IP；</li>
<li>修复 GCP 云监控中线性桶（linearBuckets）指标 Bug；</li>
<li>新增 CSPM 规则：S3 存储桶策略应限制来自其他 AWS 账户的访问；</li>
<li>新增云集成模板：Aliyun CPFS、Aliyun NLB、HuaweiCloud EVS、Aliyun CNAPIGateway、HuaweiCloud ROMA；</li>
<li>新增云脚本：GCP APIs 采集器；</li>
<li>新增云脚本：GCP RUN 采集器。</li>
</ul>
<h2 data-id="heading-11">DataKit 更新</h2>
<h3 data-id="heading-12">新加功能</h3>
<ul>
<li>新增 Flameshot 用以支持动态 Profile 采集</li>
<li>Cloud meta 同步新增 Google Cloud 云主机支持</li>
</ul>
<h3 data-id="heading-13">问题修复</h3>
<ul>
<li>优化 Pipeline 对 null 字符的处理</li>
<li>修复 Redis 主从模式中 slow log 采集问题</li>
<li>修复 Pipeline Refer table 可能崩溃的问题</li>
<li>修复一处 logfwd service/source 字段错误问题</li>
<li>修复 OpenTelemetry 指标采集对 count 类指标的处理，增加额外的 tag <code>__temporality</code>，便于 GuanceDB 处理</li>
<li>修复 DDTrace 采集器自定义 tag 无效问题</li>
</ul>
<h3 data-id="heading-14">功能优化</h3>
<ul>
<li>优化 service 启动行为，在启动过程中如果出现报错，会输出跟 service 启动有关的上下文信息，便于错误排查</li>
<li>优化基于 Jolokia 的 JVM 和 Kafka 指标采集</li>
<li>HTTP API 白名单功能优化，增加基于正则的白名单配置和禁用白名单的选项</li>
<li>优化 MongoDB 采集中错误日志处理</li>
<li>优化 Redis 采集中关于权限的说明</li>
<li>优化 DataKit 自身指标采集配置，新增 interval 配置入口，同时，自身指标中新增 eBPF 进程有关的 CPU/内存指标采集</li>
<li>DDTrace/OpenTelemetry trace 采集中新增 Trace SDK 名称/版本号/语言/公共字段提取</li>
<li>主机对象采集支持虚拟机/物理机检测，可据此设定不同的采集 tag</li>
</ul>
<h3 data-id="heading-15">兼容调整</h3>
<ul>
<li>Kafka 采集器做了较大调整，在这个版本中所有指标都归到 kafka 这个指标集下，且所有的指标都根据对应的 MBean 名称自动推导，不用人工配置采集的 MBean 以及其对应的指标命名</li>
<li>移除了 OpenTelemetry 指标采集时的 global tag 追加</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Function.prototype.bind实现]]></title>    <link>https://juejin.cn/post/7587256133792022568</link>    <guid>https://juejin.cn/post/7587256133792022568</guid>    <pubDate>2025-12-25T01:19:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587256133792022568" data-draft-id="7587245616754589747" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Function.prototype.bind实现"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-25T01:19:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户4939409522935"/> <meta itemprop="url" content="https://juejin.cn/user/2661285222166046"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Function.prototype.bind实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2661285222166046/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户4939409522935
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:19:01.000Z" title="Thu Dec 25 2025 01:19:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">目标</h2>
<p>实现函数<code>Function.prototype.mybind</code>，效果等同于<code>Function.prototype.bind</code></p>
<p>bind接受参数为：<code>(thisArg, ...args)</code></p>
<h2 data-id="heading-1">实现</h2>
<p>利用<code>apply</code>函数实现：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...args</span>) {
  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;
  
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bound</span>(<span class="hljs-params">...innerArgs</span>) {
    <span class="hljs-keyword">const</span> context = (<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> bound) ? <span class="hljs-variable language_">this</span> : thisArg;
  
    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, [...args, ...innerArgs]);
  }
  
  <span class="hljs-keyword">if</span> (fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>){
    bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
    bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = bound;
  }

  <span class="hljs-keyword">return</span> bound;
}
</code></pre>
<p>这里有一个细节，当得到了<code>bound = fn.bind(obj1)</code>后，再次调用<code>bound2 = bound.bind(obj2)</code>，会忽略这个<code>bind</code>调用，<code>bound2</code>与<code>bound</code>运行时的<code>this</code>都指向<code>obj1</code>。该行为手写<code>bind</code>与原始<code>bind</code>表现一致。</p>
<h2 data-id="heading-2">问题</h2>
<p><code>bound.prototype</code>应该为<code>undefined</code></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端Token无感刷新：让用户像在游乐园畅玩一样流畅]]></title>    <link>https://juejin.cn/post/7587336857537478665</link>    <guid>https://juejin.cn/post/7587336857537478665</guid>    <pubDate>2025-12-25T01:41:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587336857537478665" data-draft-id="7587335187072417818" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端Token无感刷新：让用户像在游乐园畅玩一样流畅"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-25T01:41:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JS_Likers"/> <meta itemprop="url" content="https://juejin.cn/user/1377017277975032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端Token无感刷新：让用户像在游乐园畅玩一样流畅
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1377017277975032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JS_Likers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:41:35.000Z" title="Thu Dec 25 2025 01:41:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>❤ 写在前面<br/>
如果觉得对你有帮助的话，点个小❤❤ 吧，你的支持是对我最大的鼓励~<br/>
个人独立开发wx小程序，感谢支持！
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d25c4001b1b4e6e902dc1f8863bcef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSlNfTGlrZXJz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231695&amp;x-signature=zkL4bG6Y6uSKgGKRAU%2BLmf6hZGU%3D" alt="small.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-0">🎪 从游乐园门票说起</h2>
<p>想象一下，你去游乐园玩，门票（Token）有一定有效期。传统方式中，门票过期时：</p>
<ul>
<li>保安拦下你：“票过期了，去售票处重新买！”</li>
<li>你不得不离开项目，排队重新买票，再回来继续玩</li>
</ul>
<p>而<strong>无感刷新</strong>就像有个贴心助手：</p>
<ul>
<li>门票快过期时，助手悄悄帮你续期</li>
<li>你完全感知不到，继续畅玩各个项目</li>
</ul>
<p>这就是我们今天要实现的用户体验！</p>
<h2 data-id="heading-1">🔍 为什么需要Token刷新？</h2>
<h3 data-id="heading-2">Token的生命周期</h3>
<pre><code class="hljs language-markdown" lang="markdown">┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  登录获取   │────▶│  使用Token  │────▶│  Token过期  │
│ AccessToken │     │  访问接口   │     │   401错误   │
└─────────────┘     └─────────────┘     └─────────────┘
<span class="hljs-code">                                              │
                        ┌─────────────────────┘
                        ▼
                 ┌─────────────┐     ┌─────────────┐
                 │ 传统方式：   │────▶│ 用户需重新  │
                 │ 跳转登录页  │     │    登录     │
                 └─────────────┘     └─────────────┘
</span></code></pre>
<p><strong>问题来了</strong>：每次Token过期都让用户重新登录，体验极差！</p>
<h2 data-id="heading-3">🎯 无感刷新的核心思路</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[用户发起请求] --&gt; B{Token是否有效?}
    B -- 有效 --&gt; C[正常请求]
    B -- 已过期 --&gt; D[拦截请求]
    D --&gt; E{是否正在刷新?}
    E -- 否 --&gt; F[发起刷新请求]
    F --&gt; G[获取新Token]
    G --&gt; H[重试原请求]
    E -- 是 --&gt; I[加入等待队列]
    I --&gt; J[刷新完成后重试]
    C --&gt; K[返回数据]
    H --&gt; K
    J --&gt; K
</code></pre>
<h2 data-id="heading-4">💻 实战代码实现（基于axios）</h2>
<h3 data-id="heading-5">第一步：基础配置</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// tokenManager.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenManager</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">accessToken</span> = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'access_token'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshToken</span> = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'refresh_token'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRefreshing</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否正在刷新</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsQueue</span> = []; <span class="hljs-comment">// 请求等待队列</span>
  }
  
  <span class="hljs-comment">// 保存token</span>
  <span class="hljs-title function_">setTokens</span>(<span class="hljs-params">accessToken, refreshToken</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">accessToken</span> = accessToken;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshToken</span> = refreshToken;
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'access_token'</span>, accessToken);
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'refresh_token'</span>, refreshToken);
  }
  
  <span class="hljs-comment">// 清除token</span>
  <span class="hljs-title function_">clearTokens</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">accessToken</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshToken</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'access_token'</span>);
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'refresh_token'</span>);
  }
}
</code></pre>
<h3 data-id="heading-6">第二步：axios拦截器设置</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// http.js</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TokenManager</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./tokenManager'</span>;

<span class="hljs-keyword">const</span> tokenManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenManager</span>();
<span class="hljs-keyword">const</span> http = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_BASE_API</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>
});

<span class="hljs-comment">// 请求拦截器</span>
http.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (tokenManager.<span class="hljs-property">accessToken</span>) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${tokenManager.accessToken}</span>`</span>;
    }
    <span class="hljs-keyword">return</span> config;
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
  }
);

<span class="hljs-comment">// 响应拦截器 - 核心逻辑在这里！</span>
http.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-comment">// 正常响应直接返回</span>
    <span class="hljs-keyword">return</span> response;
  },
  <span class="hljs-keyword">async</span> (error) =&gt; {
    <span class="hljs-keyword">const</span> originalRequest = error.<span class="hljs-property">config</span>;
    
    <span class="hljs-comment">// 如果不是401错误，直接返回</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> !== <span class="hljs-number">401</span> || originalRequest.<span class="hljs-property">_retry</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    }
    
    <span class="hljs-comment">// 标记这个请求已经重试过，避免无限循环</span>
    originalRequest.<span class="hljs-property">_retry</span> = <span class="hljs-literal">true</span>;
    
    <span class="hljs-comment">// 如果没有refreshToken，跳转到登录页</span>
    <span class="hljs-keyword">if</span> (!tokenManager.<span class="hljs-property">refreshToken</span>) {
      tokenManager.<span class="hljs-title function_">clearTokens</span>();
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    }
    
    <span class="hljs-comment">// 如果正在刷新token，将请求加入队列</span>
    <span class="hljs-keyword">if</span> (tokenManager.<span class="hljs-property">isRefreshing</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        tokenManager.<span class="hljs-property">requestsQueue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
          originalRequest.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${tokenManager.accessToken}</span>`</span>;
          <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">http</span>(originalRequest));
        });
      });
    }
    
    <span class="hljs-comment">// 开始刷新token</span>
    tokenManager.<span class="hljs-property">isRefreshing</span> = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 调用刷新接口</span>
      <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/auth/refresh'</span>, {
        <span class="hljs-attr">refresh_token</span>: tokenManager.<span class="hljs-property">refreshToken</span>
      });
      
      <span class="hljs-comment">// 保存新token</span>
      tokenManager.<span class="hljs-title function_">setTokens</span>(data.<span class="hljs-property">access_token</span>, data.<span class="hljs-property">refresh_token</span>);
      
      <span class="hljs-comment">// 执行等待队列中的所有请求</span>
      tokenManager.<span class="hljs-property">requestsQueue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>());
      tokenManager.<span class="hljs-property">requestsQueue</span> = [];
      
      <span class="hljs-comment">// 重试原始请求</span>
      originalRequest.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${data.access_token}</span>`</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">http</span>(originalRequest);
      
    } <span class="hljs-keyword">catch</span> (refreshError) {
      <span class="hljs-comment">// 刷新失败，清除token并跳转登录</span>
      tokenManager.<span class="hljs-title function_">clearTokens</span>();
      tokenManager.<span class="hljs-property">requestsQueue</span> = [];
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(refreshError);
    } <span class="hljs-keyword">finally</span> {
      tokenManager.<span class="hljs-property">isRefreshing</span> = <span class="hljs-literal">false</span>;
    }
  }
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http;
</code></pre>
<h3 data-id="heading-7">第三步：使用示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// userService.js</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/user/info'</span>);
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取用户信息失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateProfile</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">data</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/user/profile'</span>, data);
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'更新资料失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
};
</code></pre>
<h2 data-id="heading-8">🎨 增强体验：添加视觉提示</h2>
<p>虽然说是"无感"，但适当的提示能让体验更好：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在刷新token时显示加载提示</span>
<span class="hljs-keyword">let</span> refreshLoading = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 修改响应拦截器中的刷新部分</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 显示轻量级提示</span>
  refreshLoading = <span class="hljs-title function_">showLoading</span>(<span class="hljs-string">'正在更新登录状态...'</span>);
  
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/auth/refresh'</span>, {
    <span class="hljs-attr">refresh_token</span>: tokenManager.<span class="hljs-property">refreshToken</span>
  });
  
  <span class="hljs-comment">// 隐藏提示</span>
  refreshLoading?.<span class="hljs-title function_">hide</span>();
  <span class="hljs-title function_">showToast</span>(<span class="hljs-string">'登录状态已更新'</span>, <span class="hljs-string">'success'</span>, <span class="hljs-number">2000</span>);
  
  <span class="hljs-comment">// ... 其余逻辑</span>
} <span class="hljs-keyword">catch</span> (error) {
  refreshLoading?.<span class="hljs-title function_">hide</span>();
  <span class="hljs-title function_">showToast</span>(<span class="hljs-string">'登录已过期，请重新登录'</span>, <span class="hljs-string">'error'</span>);
  <span class="hljs-comment">// ... 其余错误处理</span>
}
</code></pre>
<h2 data-id="heading-9">🛡️ 安全注意事项</h2>
<ol>
<li><strong>Refresh Token有效期</strong>：通常比Access Token长，但也不是永久的</li>
<li><strong>单次使用</strong>：每次使用Refresh Token后，服务端应该颁发新的Refresh Token</li>
<li><strong>安全存储</strong>：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用更安全的方式存储</span>
<span class="hljs-keyword">const</span> secureStorage = {
  <span class="hljs-attr">setItem</span>: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">crypto</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">crypto</span>.<span class="hljs-property">subtle</span>) {
      <span class="hljs-comment">// 考虑使用加密存储</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 降级方案</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value);
    }
  },
  <span class="hljs-attr">getItem</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
};
</code></pre>
</li>
</ol>
<h2 data-id="heading-10">🎪 回到游乐园比喻</h2>
<p>现在我们的系统就像这样工作：</p>
<pre><code class="hljs language-markdown" lang="markdown">游乐园项目（API请求） → 检票口（拦截器）
<span class="hljs-code">    │
    ├── 票有效 → 直接进入
    │
    ├── 票过期，有续票资格 → 助手悄悄续票 → 继续游玩
    │
    └── 票过期，无续票资格 → 引导重新购票（登录）
</span></code></pre>
<h2 data-id="heading-11">📊 性能优化小贴士</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 预刷新：在token即将过期时提前刷新</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">shouldRefreshToken</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> tokenExpiry = <span class="hljs-title function_">getTokenExpiry</span>(tokenManager.<span class="hljs-property">accessToken</span>);
  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-comment">// 在过期前5分钟开始刷新</span>
  <span class="hljs-keyword">return</span> tokenExpiry - now &lt; <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
};

<span class="hljs-comment">// 2. 定时检查</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRefreshToken</span>() &amp;&amp; !tokenManager.<span class="hljs-property">isRefreshing</span>) {
    <span class="hljs-title function_">refreshTokenSilently</span>();
  }
}, <span class="hljs-number">60000</span>); <span class="hljs-comment">// 每分钟检查一次</span>

<span class="hljs-comment">// 3. 并发控制优化</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_QUEUE_SIZE</span> = <span class="hljs-number">50</span>;
<span class="hljs-keyword">if</span> (tokenManager.<span class="hljs-property">requestsQueue</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-variable constant_">MAX_QUEUE_SIZE</span>) {
  <span class="hljs-comment">// 队列过长，可能是异常情况</span>
  tokenManager.<span class="hljs-property">requestsQueue</span> = [];
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>(); <span class="hljs-comment">// 或采取其他恢复措施</span>
}
</code></pre>
<h2 data-id="heading-12">🎉 总结</h2>
<p>实现Token无感刷新的关键在于：</p>
<ol>
<li><strong>拦截401错误</strong>：在axios响应拦截器中捕获</li>
<li><strong>避免并发刷新</strong>：用标志位和队列控制</li>
<li><strong>优雅降级</strong>：刷新失败时友好引导重新登录</li>
<li><strong>用户体验</strong>：适当的提示（但不是打断）</li>
</ol>
<p>现在你的应用就像那个贴心的游乐园助手，让用户在不知不觉中保持登录状态，享受流畅的体验！</p>
<p>试试实现它，让你的应用告别烦人的"登录已过期"提示吧！🚀</p>
<hr/>
<p><strong>小作业</strong>：你能想到在哪些场景下，即使实现了无感刷新，仍然需要主动提示用户重新登录吗？欢迎在评论区分享你的想法！💭</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[oa流程到达某个节点之后触发自定义动作(外部接口)]]></title>    <link>https://juejin.cn/post/7587313610696425499</link>    <guid>https://juejin.cn/post/7587313610696425499</guid>    <pubDate>2025-12-25T02:59:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587313610696425499" data-draft-id="7587325326046150665" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="oa流程到达某个节点之后触发自定义动作(外部接口)"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-25T02:59:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hyinglin"/> <meta itemprop="url" content="https://juejin.cn/user/2362231708723822"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            oa流程到达某个节点之后触发自定义动作(外部接口)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2362231708723822/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Hyinglin
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:59:05.000Z" title="Thu Dec 25 2025 02:59:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>第一种方案（推荐）<br/>
在归档节点前添加自定义附加操作就可以（oa前台直接调用外部接口即可）</p>
</blockquote>
<blockquote>
<p>第二种方案（不推荐，用来扩展思路）<br/>
数据库轮询版</p>
</blockquote>
<h2 data-id="heading-0">一、数据库轮询版-整体思路</h2>
<h4 data-id="heading-1">核心思想（非常重要）</h4>
<blockquote>
<p><strong>不要直接扫“已结束流程”</strong><br/>
而是：<br/>
👉 <strong>“找出『刚刚结束』、且『还没通知过』的流程实例”</strong></p>
</blockquote>
<p>所以一定要有 <strong>去重标记</strong>。</p>
<hr/>
<h3 data-id="heading-2">总体架构</h3>
<pre><code class="hljs language-markdown" lang="markdown">Spring Boot 定时任务
<span class="hljs-code">        ↓
查询 OA 数据库
        ↓
找出【厂外调拨流程】中
【审批完成 &amp; 未通知】的 requestId
        ↓
发送飞书群通知
        ↓
记录通知日志（防重复）
</span></code></pre>
<hr/>
<h2 data-id="heading-3">二、你必须知道的 3 张关键表（e-cology 9）</h2>
<blockquote>
<p>⚠️ 表名在不同客户可能略有差异，但 <strong>下面这几张 90% 都存在</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-4">1️⃣ workflow_requestbase（流程实例主表）</h3>
<p>这是最重要的。</p>
<p>常用字段：</p>





























<table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>requestid</td><td>流程实例 ID</td></tr><tr><td>workflowid</td><td>流程模板 ID</td></tr><tr><td>currentstatus</td><td>流程状态</td></tr><tr><td>lastoperatedate</td><td>最后操作日期</td></tr><tr><td>lastoperatetime</td><td>最后操作时间</td></tr></tbody></table>
<h4 data-id="heading-5">currentstatus 常见值（经验）</h4>

























<table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>运行中</td></tr><tr><td>1</td><td>正常结束（审批通过）</td></tr><tr><td>2</td><td>强制结束</td></tr><tr><td>3</td><td>退回</td></tr></tbody></table>
<p>👉 <strong>你只要 <code>currentstatus = 1</code></strong></p>
<hr/>
<h3 data-id="heading-6">2️⃣ workflow_base（流程模板表）</h3>
<p>用来确认流程名（可选）</p>

















<table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>workflowId</td></tr><tr><td>workflowname</td><td>流程名称</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-7">3️⃣ 你自己建的表（强烈推荐）</h3>
<h4 data-id="heading-8">oa_notify_log（防重复）</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> oa_notify_log (
  request_id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,
  workflow_id <span class="hljs-type">int</span>,
  notify_time datetime
);
</code></pre>
<blockquote>
<p>❗ <strong>这是整个方案是否“能长期用”的关键</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-9">三、SQL：找出「刚刚审批完成」的流程</h2>
<h4 data-id="heading-10">核心 SQL（重点看）</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">select</span> r.requestid,
       r.workflowid,
       r.lastoperatedate,
       r.lastoperatetime
<span class="hljs-keyword">from</span> workflow_requestbase r
<span class="hljs-keyword">where</span> r.workflowid <span class="hljs-operator">=</span> <span class="hljs-number">456</span>            <span class="hljs-comment">-- 厂外调拨流程ID</span>
  <span class="hljs-keyword">and</span> r.currentstatus <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>         <span class="hljs-comment">-- 审批通过</span>
  <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (
      <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>
      <span class="hljs-keyword">from</span> oa_notify_log n
      <span class="hljs-keyword">where</span> n.request_id <span class="hljs-operator">=</span> r.requestid
  )
</code></pre>
<p>📌 <strong>解释</strong>：</p>
<ul>
<li>只查你关心的流程</li>
<li>只要“审批通过”的</li>
<li><strong>排除已经通知过的</strong></li>
</ul>
<hr/>
<h2 data-id="heading-11">四、Spring Boot 3 实现（完整可用示例）</h2>
<h3 data-id="heading-12">1️⃣ 定时任务配置</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@EnableScheduling</span>
<span class="hljs-variable">@Configuration</span>
public class ScheduleConfig {
}
</code></pre>
<hr/>
<h3 data-id="heading-13">2️⃣ 定时扫描任务</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OaWorkflowScanJob</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">JdbcTemplate</span> jdbcTemplate;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">FeishuService</span> feishuService;

    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 */1 * * * ?"</span>) <span class="hljs-comment">// 每 1 分钟扫一次</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">scanFinishedWorkflow</span>(<span class="hljs-params"/>) {

        <span class="hljs-title class_">String</span> sql = <span class="hljs-string">""</span><span class="hljs-string">"
            select requestid
            from workflow_requestbase
            where workflowid = ?
              and currentstatus = '1'
              and not exists (
                select 1 from oa_notify_log
                where request_id = workflow_requestbase.requestid
              )
        "</span><span class="hljs-string">""</span>;

        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; requestIds =
            jdbcTemplate.<span class="hljs-title function_">queryForList</span>(sql, <span class="hljs-title class_">Integer</span>.<span class="hljs-property">class</span>, <span class="hljs-number">456</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Integer</span> requestId : requestIds) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 1. 发送飞书</span>
                feishuService.<span class="hljs-title function_">send</span>(<span class="hljs-title function_">buildMsg</span>(requestId));

                <span class="hljs-comment">// 2. 记录已通知</span>
                <span class="hljs-title function_">saveNotifyLog</span>(requestId);

            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                <span class="hljs-comment">// 失败不写 log，下次还会再发</span>
                e.<span class="hljs-title function_">printStackTrace</span>();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveNotifyLog</span>(<span class="hljs-params">Integer requestId</span>) {
        jdbcTemplate.<span class="hljs-title function_">update</span>(
            <span class="hljs-string">"insert into oa_notify_log(request_id, workflow_id, notify_time) values (?, ?, getdate())"</span>,
            requestId, <span class="hljs-number">456</span>
        );
    }

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">buildMsg</span>(<span class="hljs-params">Integer requestId</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"【厂外调拨流程】审批已通过\n流程ID："</span> + requestId;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-14">3️⃣ 飞书发送（简版）</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeishuService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> <span class="hljs-variable constant_">WEBHOOK</span> =
        <span class="hljs-string">"https://open.feishu.cn/open-apis/bot/v2/hook/xxxx"</span>;

    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">RestTemplate</span> restTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> text</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; body = <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">of</span>(
            <span class="hljs-string">"msg_type"</span>, <span class="hljs-string">"text"</span>,
            <span class="hljs-string">"content"</span>, <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">"text"</span>, text)
        );
        restTemplate.<span class="hljs-title function_">postForObject</span>(<span class="hljs-variable constant_">WEBHOOK</span>, body, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>);
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-15">五、你这个方案一定要加的 4 个“保险”</h2>
<h4 data-id="heading-16">✅ 1️⃣ 必须用 <code>oa_notify_log</code></h4>
<p>否则 <strong>一定会重复发</strong></p>
<hr/>
<h4 data-id="heading-17">✅ 2️⃣ 定时频率不要太高</h4>
<ul>
<li>推荐：<strong>1～3 分钟</strong></li>
<li>不要秒级</li>
</ul>
<hr/>
<h4 data-id="heading-18">✅ 3️⃣ 只认 <code>currentstatus = 1</code></h4>
<p>不要自己猜其他状态</p>
<hr/>
<h4 data-id="heading-19">✅ 4️⃣ 飞书失败不要写 log</h4>
<p>让下次定时任务补发</p>
<hr/>
<h2 data-id="heading-20">六、这个方案的“客观缺点”（我必须告诉你）</h2>

























<table><thead><tr><th>点</th><th>说明</th></tr></thead><tbody><tr><td>延迟</td><td>最快 1 分钟</td></tr><tr><td>强制结束要额外判断</td><td>currentstatus = 2</td></tr><tr><td>表结构升级风险</td><td>有</td></tr><tr><td>并发高时压力大</td><td>有</td></tr></tbody></table>
<p>👉 <strong>但在“不能用 Action”的前提下，这是最稳的一种</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[vue 甘特图 vxe-gantt 任务里程碑和依赖线的使用]]></title>    <link>https://juejin.cn/post/7587277503947063296</link>    <guid>https://juejin.cn/post/7587277503947063296</guid>    <pubDate>2025-12-25T01:45:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587277503947063296" data-draft-id="7587277503947046912" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="vue 甘特图 vxe-gantt 任务里程碑和依赖线的使用"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2025-12-25T01:45:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户84179481456"/> <meta itemprop="url" content="https://juejin.cn/user/3921272428567529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            vue 甘特图 vxe-gantt 任务里程碑和依赖线的使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3921272428567529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户84179481456
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:45:20.000Z" title="Thu Dec 25 2025 01:45:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>vue 甘特图 vxe-gantt 任务里程碑和依赖线的使用</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgantt.vxeui.com%2F" target="_blank" title="https://gantt.vxeui.com/" ref="nofollow noopener noreferrer">gantt.vxeui.com/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aaf0d885ac1d46f482bae83c00ab625c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODQxNzk0ODE0NTY=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231920&amp;x-signature=%2Bo16%2FpZrEIHWJ2l0lIaJ371OJpc%3D" alt="extend_gantt_chart_gantt_milestone_links" loading="lazy"/></p>
<p>通过设置 task-bar-milestone-config 和 type=moveable 启用里程碑类型，当设置为里程碑类型时，只需要设置 start 开始日期就可以，无需设置 end 结束日期，设置 links 定义连接线,from 对应源任务的行主键,tom 对应目标任务的行主键</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vxe-gantt</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"ganttOptions"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">vxe-gantt</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">VxeGanttDependencyType</span>, <span class="hljs-title class_">VxeGanttTaskType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vxe-gantt'</span>

<span class="hljs-keyword">const</span> ganttOptions = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">border</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">rowConfig</span>: {
    <span class="hljs-attr">keyField</span>: <span class="hljs-string">'id'</span> <span class="hljs-comment">// 行主键</span>
  },
  <span class="hljs-attr">taskBarConfig</span>: {
    <span class="hljs-attr">showProgress</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否显示进度条</span>
    <span class="hljs-attr">showContent</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在任务条显示内容</span>
    <span class="hljs-attr">moveable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否允许拖拽任务移动日期</span>
    <span class="hljs-attr">resizable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否允许拖拽任务调整日期</span>
    <span class="hljs-attr">barStyle</span>: {
      <span class="hljs-attr">round</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 圆角</span>
      <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'#fca60b'</span>, <span class="hljs-comment">// 任务条的背景颜色</span>
      <span class="hljs-attr">completedBgColor</span>: <span class="hljs-string">'#65c16f'</span> <span class="hljs-comment">// 已完成部分任务条的背景颜色</span>
    }
  },
  <span class="hljs-attr">taskViewConfig</span>: {
    <span class="hljs-attr">tableStyle</span>: {
      <span class="hljs-attr">width</span>: <span class="hljs-number">280</span> <span class="hljs-comment">// 表格宽度</span>
    },
    <span class="hljs-attr">gridding</span>: {
      <span class="hljs-attr">leftSpacing</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 左侧间距多少列</span>
      <span class="hljs-attr">rightSpacing</span>: <span class="hljs-number">4</span> <span class="hljs-comment">// 右侧间距多少列</span>
    }
  },
  <span class="hljs-attr">taskBarMilestoneConfig</span>: {
    <span class="hljs-comment">// 自定义里程碑图标</span>
    icon ({ row }) {
      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">id</span> === <span class="hljs-number">10001</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vxe-icon-warning-triangle-fill'</span>
      }
      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">id</span> === <span class="hljs-number">10007</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vxe-icon-square-fill'</span>
      }
      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">id</span> === <span class="hljs-number">10009</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'vxe-icon-warning-circle-fill'</span>
      }
      <span class="hljs-keyword">return</span> <span class="hljs-string">'vxe-icon-radio-unchecked-fill'</span>
    },
    <span class="hljs-comment">// 自定义里程碑图标样式</span>
    iconStyle ({ row }) {
      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">id</span> === <span class="hljs-number">10001</span>) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">color</span>: <span class="hljs-string">'#65c16f'</span>
        }
      }
      <span class="hljs-keyword">if</span> (row.<span class="hljs-property">id</span> === <span class="hljs-number">10007</span>) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">color</span>: <span class="hljs-string">'#dc3cc7'</span>
        }
      }
    }
  },
  <span class="hljs-attr">taskLinkConfig</span>: {
    <span class="hljs-attr">lineType</span>: <span class="hljs-string">'flowDashed'</span>
  },
  <span class="hljs-attr">links</span>: [
    { <span class="hljs-attr">from</span>: <span class="hljs-number">10001</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">10002</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttDependencyType</span>.<span class="hljs-property">StartToFinish</span> },
    { <span class="hljs-attr">from</span>: <span class="hljs-number">10003</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">10004</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttDependencyType</span>.<span class="hljs-property">StartToStart</span> },
    { <span class="hljs-attr">from</span>: <span class="hljs-number">10007</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">10008</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttDependencyType</span>.<span class="hljs-property">StartToStart</span> },
    { <span class="hljs-attr">from</span>: <span class="hljs-number">10008</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">10009</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttDependencyType</span>.<span class="hljs-property">FinishToFinish</span> },
    { <span class="hljs-attr">from</span>: <span class="hljs-number">10009</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">10010</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttDependencyType</span>.<span class="hljs-property">FinishToStart</span> }
  ],
  <span class="hljs-attr">columns</span>: [
    { <span class="hljs-attr">type</span>: <span class="hljs-string">'seq'</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">70</span> },
    { <span class="hljs-attr">field</span>: <span class="hljs-string">'title'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'任务名称'</span> }
  ],
  <span class="hljs-attr">data</span>: [
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10001</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'项目启动会议'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-01'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttTaskType</span>.<span class="hljs-property">Milestone</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10002</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'项目启动与计划'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-03'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">'2024-03-08'</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">80</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">''</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10003</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'需求评审完成'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-03'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttTaskType</span>.<span class="hljs-property">Milestone</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10004</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'技术及方案设计'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-05'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">'2024-03-11'</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">80</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">''</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10005</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'功能开发'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-08'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">'2024-03-15'</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">70</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">''</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10007</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'测试环境发布'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-11'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttTaskType</span>.<span class="hljs-property">Milestone</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10008</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'系统测试'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-14'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">'2024-03-19'</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">80</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">''</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10009</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'测试完成'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-19'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttTaskType</span>.<span class="hljs-property">Milestone</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">10010</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'正式发布上线'</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">'2024-03-20'</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">progress</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">VxeGanttTaskType</span>.<span class="hljs-property">Milestone</span> }
  ]
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fx-extends%2Fvxe-gantt" target="_blank" title="https://gitee.com/x-extends/vxe-gantt" ref="nofollow noopener noreferrer">gitee.com/x-extends/v…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[localStorage使用不止于getItem、setItem、removeItem]]></title>    <link>https://juejin.cn/post/7587299670642556934</link>    <guid>https://juejin.cn/post/7587299670642556934</guid>    <pubDate>2025-12-25T01:49:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587299670642556934" data-draft-id="7587299670642491398" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="localStorage使用不止于getItem、setItem、removeItem"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-25T01:49:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追梦_life"/> <meta itemprop="url" content="https://juejin.cn/user/430664286745271"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            localStorage使用不止于getItem、setItem、removeItem
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664286745271/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追梦_life
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:49:19.000Z" title="Thu Dec 25 2025 01:49:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今天我们来聊聊js内置对象localStorage的使用，我们平时一般都是<code>getItem</code>、<code>setItem</code>和<code>removeItem</code>，很少接触其他的。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'info'</span>)
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'info'</span>, <span class="hljs-string">'123'</span>)
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">remoItem</span>(<span class="hljs-string">'info'</span>)
</code></pre>
<p>某天，突然有个小需求，需要我们清除local中所有以<code>user_</code>开头的数据，怎么办呢？显然光用<code>getItem</code>和<code>removeItem</code>是无法实现的。</p>
<p>那么，我们先来学习几个获取 localStorage 中所有缓存的 key的方法：</p>
<h2 data-id="heading-0">方法一：使用 for 循环</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllLocalStorageKeys</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> keys = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> key = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(i)
    keys.<span class="hljs-title function_">push</span>(key)
  }
  <span class="hljs-keyword">return</span> keys
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> allKeys = <span class="hljs-title function_">getAllLocalStorageKeys</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allKeys)
</code></pre>
<h2 data-id="heading-1">方法二：使用扩展运算符和 map</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> keys = [...<span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">length</span>)].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(i))
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys)
</code></pre>
<h2 data-id="heading-2">方法三：获取键值对</h2>
<p>如果你想同时获取键和对应的值：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllLocalStorageItems</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> items = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> key = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(i)
    <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
    items[key] = value
  }
  <span class="hljs-keyword">return</span> items
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> allItems = <span class="hljs-title function_">getAllLocalStorageItems</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allItems)
</code></pre>
<h2 data-id="heading-3">方法四：使用 Object.keys 的替代方法</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys)  <span class="hljs-comment">// 这会返回所有 localStorage 的 key</span>
</code></pre>
<h2 data-id="heading-4">方法五：封装成实用函数</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalStorageHelper</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getAllKeys</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>)
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getAllItems</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">obj, key</span>) =&gt;</span> {
      obj[key] = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
      <span class="hljs-keyword">return</span> obj
    }, {})
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getKeysByPrefix</span>(<span class="hljs-params">prefix</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key.<span class="hljs-title function_">startsWith</span>(prefix))
  }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> allKeys = <span class="hljs-title class_">LocalStorageHelper</span>.<span class="hljs-title function_">getAllKeys</span>()
<span class="hljs-keyword">const</span> allItems = <span class="hljs-title class_">LocalStorageHelper</span>.<span class="hljs-title function_">getAllItems</span>()
</code></pre>
<h2 data-id="heading-5">示例：统计存储情况</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">analyzeLocalStorage</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>)
  <span class="hljs-keyword">const</span> totalSize = keys.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, key</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> total + (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key).<span class="hljs-property">length</span> || <span class="hljs-number">0</span>)
  }, <span class="hljs-number">0</span>)
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`总条目数: <span class="hljs-subst">${keys.length}</span>`</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`总大小: <span class="hljs-subst">${totalSize}</span> 字符`</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`所有键名:`</span>, keys)
  
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">count</span>: keys.<span class="hljs-property">length</span>,
    <span class="hljs-attr">totalSize</span>: totalSize,
    <span class="hljs-attr">keys</span>: keys
  }
}

<span class="hljs-title function_">analyzeLocalStorage</span>()
</code></pre>
<p>推荐使用 <strong>方法一</strong> 或 <strong>方法四</strong>，它们简单直接且兼容性好。</p>
<p>知道了这些方法后，清除local中所有以<code>user_</code>开头的数据这个需求就很简单了。</p>
<pre><code class="hljs language-javascript" lang="javascript">	<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
		<span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'user_'</span>)) {
       <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
     }	
	})
</code></pre>
<h2 data-id="heading-6">最后，localStorage相关限制，我相信大家肯定也是了解的：</h2>
<ol>
<li><strong>同源策略</strong>：localStorage 受同源策略限制，只能访问当前域名下的存储</li>
<li><strong>数据类型</strong>：获取的 key 都是字符串类型</li>
<li><strong>存储限制</strong>：每个域名的 localStorage 通常有 5MB 左右的存储限制</li>
<li><strong>空值处理</strong>：如果 localStorage 为空，这些方法会返回空数组或空对象</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Context API 的订阅机制与性能优化]]></title>    <link>https://juejin.cn/post/7587368168621703174</link>    <guid>https://juejin.cn/post/7587368168621703174</guid>    <pubDate>2025-12-25T02:08:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587368168621703174" data-draft-id="7587368168621686790" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Context API 的订阅机制与性能优化"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2025-12-25T02:08:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="day1"/> <meta itemprop="url" content="https://juejin.cn/user/4310544201823182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Context API 的订阅机制与性能优化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4310544201823182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    day1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T02:08:48.000Z" title="Thu Dec 25 2025 02:08:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 引言：Context API 的双面性</h2>
<p>Context API 诞生的核心目标是解决 React 组件树中 “props 钻取” 问题—— 当深层子组件需要使用顶层组件的状态时，无需通过中间组件逐层传递 props。</p>
<p>然而，这种便利性的背后也隐藏着性能上的挑战。默认情况下，任何消费了 Context 的组件都会在 Context 值发生变化时被强制重新渲染，即使它只关心该值的一小部分。这可能导致大规模且不必要的渲染，从而影响应用性能。</p>
<h2 data-id="heading-1">2. 核心机制：被动的“拉取式”订阅</h2>
<p>要理解 Context 的工作原理，我们必须将其视为一个<strong>被动的、在“跳过更新”时进行检查的“拉取式”订阅系统</strong>，而非主动的“发布-订阅”模型。</p>
<ul>
<li>
<p><strong><code>React.createContext(defaultValue)</code></strong>: 创建一个 Context 对象。这个对象本身就像一个“主题”或“事件中心”。</p>
</li>
<li>
<p><strong><code>&lt;Context.Provider value={...}&gt;</code></strong>: 这是值的<strong>提供者</strong>。当它渲染时，它会将 <code>value</code> prop 的值推入一个全局的 Context 栈中，使其成为当前活跃的值。它<strong>不会主动通知</strong>任何组件。</p>
<p>这个“栈”是 React 用来管理嵌套 <code>Provider</code> 值的关键。你可以把它想象成一摞盘子：当遇到一个新的 <code>Provider</code> 时，React 会把新值（新盘子）放到最上面；当这个 <code>Provider</code> 的渲染结束后，React 会把最上面的值（盘子）拿走，从而恢复上一层 <code>Provider</code> 的值。这个“后进先出”的机制确保了无论嵌套多深，组件总能读取到离它最近的 <code>Provider</code> 的值。</p>
<p>这个过程由 <code>pushProvider</code> 函数完成，它将旧值保存到栈上，然后更新 Context 对象的当前值。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> pushProvider&lt;T&gt;(
  <span class="hljs-attr">providerFiber</span>: <span class="hljs-title class_">Fiber</span>,
  <span class="hljs-attr">context</span>: <span class="hljs-title class_">ReactContext</span>&lt;T&gt;,
  <span class="hljs-attr">nextValue</span>: T
): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">if</span> (isPrimaryRenderer) {
    <span class="hljs-comment">// 将旧值推入栈中</span>
    <span class="hljs-title function_">push</span>(valueCursor, context.<span class="hljs-property">_currentValue</span>, providerFiber);
    <span class="hljs-comment">// 更新 context 的当前值</span>
    context.<span class="hljs-property">_currentValue</span> = nextValue;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">push</span>(valueCursor, context.<span class="hljs-property">_currentValue2</span>, providerFiber);
    context.<span class="hljs-property">_currentValue2</span> = nextValue;
  }
}
</code></pre>
</li>
<li>
<p><strong><code>useContext(Context)</code></strong>: 这是<strong>订阅者</strong>。当组件调用 <code>useContext</code> 时，React 会做两件关键的事：</p>
<ol>
<li><strong>读取值</strong>：从 Context 栈中读取当前的活跃值。</li>
<li><strong>记录依赖（订阅）</strong>：将该 Context 和本次读取到的值（作为 <code>memoizedValue</code>）记录到当前组件 Fiber 的 <code>dependencies</code> 列表中。这一步就是“订阅”，它告诉 React：“这个组件依赖此 Context，并且它上次读取的值是 X”。</li>
</ol>
<p><code>useContext</code> 内部调用 <code>readContext</code>，最终由 <code>readContextForConsumer</code> 完成工作。它读取当前值，然后创建一个依赖项并附加到当前组件 Fiber 的 <code>dependencies</code> 链表上。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/react/packages/react-reconciler/src/ReactFiberNewContext.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> readContext&lt;T&gt;(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ReactContext</span>&lt;T&gt;): T {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContextForConsumer</span>(currentlyRenderingFiber, context);
}

<span class="hljs-keyword">function</span> readContextForConsumer&lt;T&gt;(
  <span class="hljs-attr">consumer</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">context</span>: <span class="hljs-title class_">ReactContext</span>&lt;T&gt;
): T {
  <span class="hljs-comment">// 读取当前 context 的值</span>
  <span class="hljs-keyword">const</span> value = isPrimaryRenderer
    ? context.<span class="hljs-property">_currentValue</span>
    : context.<span class="hljs-property">_currentValue2</span>;

  <span class="hljs-keyword">const</span> contextItem = {
    <span class="hljs-attr">context</span>: ((<span class="hljs-attr">context</span>: any): <span class="hljs-title class_">ReactContext</span>&lt;mixed&gt;),
    <span class="hljs-attr">memoizedValue</span>: value, <span class="hljs-comment">// 记录读取到的值</span>
    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
  };

  <span class="hljs-keyword">if</span> (lastContextDependency === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// ... 创建新的依赖列表</span>
    lastContextDependency = contextItem;
    consumer.<span class="hljs-property">dependencies</span> = {
      <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">NoLanes</span>,
      <span class="hljs-attr">firstContext</span>: contextItem,
    };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 追加到依赖链表末尾</span>
    lastContextDependency = lastContextDependency.<span class="hljs-property">next</span> = contextItem;
  }
  <span class="hljs-keyword">return</span> value;
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-2">内部更新检查流程</h4>
<p>Context 的更新通知并非由 <code>Provider</code> 主动发起，而是在 <code>Consumer</code> 端，当 React 试图优化渲染时被动触发的。</p>
<ol>
<li>
<p><strong><code>Provider</code> 值变更</strong>：<code>Provider</code> 的 <code>value</code> prop 获得了一个新的对象引用。<code>Provider</code> 重新渲染，并将这个新值推入 Context 栈。</p>
</li>
<li>
<p><strong>子组件渲染与检查</strong>：React 向下渲染子组件。</p>
<ul>
<li><strong>对于普通组件</strong>：由于父节点（或更上层的祖先）在渲染，它们也会默认重新渲染。在渲染过程中，它们调用 <code>useContext</code>，自然会读取到 Context 栈中最新的值。</li>
<li><strong>对于希望“跳过更新”的组件</strong>（如被 <code>React.memo</code> 包裹且 props 未变的组件）：React 在准备跳过它之前，会执行一道额外的安全检查——调用内部的 <code>checkIfContextChanged</code> 函数。</li>
</ul>
</li>
<li>
<p><strong><code>checkIfContextChanged</code> 的工作</strong>：此函数会遍历该组件的 <code>dependencies</code> 列表，用 <code>Object.is</code> 比较每一个依赖的“旧值” (<code>memoizedValue</code>) 和 Context 栈中的“当前值”。</p>
<ul>
<li>如果发现任何一个值不一致，函数返回 <code>true</code>。这个信号会<strong>阻止 React 跳过该组件</strong>，强制其重新渲染。</li>
<li>如果所有值都一致，函数返回 <code>false</code>，组件被成功跳过，避免了不必要的渲染。</li>
</ul>
<p>源码清晰地展示了这个过程：遍历 <code>dependencies</code> 链表，使用 <code>is</code> 函数（<code>Object.is</code> 的内部实现）比较 <code>memoizedValue</code> 和 <code>_currentValue</code>。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/react/packages/react-reconciler/src/ReactFiberNewContext.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkIfContextChanged</span>(<span class="hljs-params">
  currentDependencies: Dependencies
</span>): boolean {
  <span class="hljs-keyword">let</span> dependency = currentDependencies.<span class="hljs-property">firstContext</span>;
  <span class="hljs-keyword">while</span> (dependency !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> context = dependency.<span class="hljs-property">context</span>;
    <span class="hljs-keyword">const</span> newValue = isPrimaryRenderer
      ? context.<span class="hljs-property">_currentValue</span>
      : context.<span class="hljs-property">_currentValue2</span>;
    <span class="hljs-keyword">const</span> oldValue = dependency.<span class="hljs-property">memoizedValue</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">is</span>(newValue, oldValue)) {
      <span class="hljs-comment">// 只要有一个 context 的值变了，就返回 true</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    dependency = dependency.<span class="hljs-property">next</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
</li>
</ol>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4cb8c63907d4f35a0f8010cc782d31e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF5MQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767233328&amp;x-signature=h5LbBJOHnC0EsViN6pwTbztYLUs%3D" alt="9-1.png" loading="lazy"/></p>
<h2 data-id="heading-3">3. 性能瓶颈：必要 vs. 不必要的渲染</h2>
<p>在优化性能之前，我们需要区分两种渲染：</p>
<ul>
<li><strong>必要的渲染 (Necessary re-render)</strong>：当组件自身的状态变更，或者它直接使用的信息（如 props 或 context 的一部分）发生变化时，它的重新渲染是必要的。例如，当用户在输入框打字时，管理该输入的组件必须渲染。</li>
<li><strong>不必要的渲染 (Unnecessary re-render)</strong>：因为架构问题或 React 的渲染机制，一个组件在它依赖的数据完全没有变化的情况下也被重新渲染了。</li>
</ul>
<p><strong>Context API 的主要性能瓶颈，就在于它很容易导致不必要的渲染。</strong></p>
<p>根本原因在于其<strong>检查的粒度太大</strong>。一个组件一旦通过 <code>useContext</code> 订阅了某个 Context，它就依赖了<strong>整个 <code>value</code> 对象</strong>。只要 <code>value</code> 对象的引用发生变化，<code>checkIfContextChanged</code> 检查就会失败，从而强制该组件重新渲染——无论组件实际使用的是 <code>value</code> 中的哪个属性。</p>
<h4 data-id="heading-4">示例：一个典型的不必要渲染场景</h4>
<p>假设我们有一个包含用户认证和主题设置的全局 Context：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"light"</span>);

  <span class="hljs-comment">// 注意：每次 AppProvider 渲染，都会创建一个全新的 value 对象</span>
  <span class="hljs-keyword">const</span> value = { user, theme, setTheme };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span>;
}
</code></pre>
<p>现在，我们有两个被 <code>React.memo</code> 包裹的组件，以尝试优化性能：</p>
<ol>
<li><code>UserProfile</code> 只显示用户信息。</li>
<li><code>ThemeToggler</code> 只切换主题。</li>
</ol>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserProfile</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { user } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppContext</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"UserProfile rendered (unnecessary)"</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user ? user.name : "Guest"}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeToggler</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeToggler</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { theme, setTheme } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppContext</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"ThemeToggler rendered (necessary)"</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme((t) =&gt; (t === "light" ? "dark" : "light"))}&gt;
      {theme}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
});
</code></pre>
<p><strong>问题在于</strong>：当我们点击 <code>ThemeToggler</code> 按钮时，<code>setTheme</code> 会触发 <code>AppProvider</code> 的重新渲染。</p>
<ol>
<li><code>ThemeToggler</code> 的渲染是<strong>必要的</strong>，因为它直接使用了 <code>theme</code> 和 <code>setTheme</code>。</li>
<li><code>AppProvider</code> 重新渲染时，创建了一个<strong>新的 <code>value</code> 对象</strong>。</li>
<li>当 React 准备跳过 <code>UserProfile</code> 的渲染时，<code>checkIfContextChanged</code> 被触发。它比较 <code>AppContext</code> 的新旧 <code>value</code>，发现引用不同。</li>
<li>因此，React <strong>强制 <code>UserProfile</code> 重新渲染</strong>。这次渲染是<strong>不必要的</strong>，因为 <code>user</code> 的值根本没有改变。</li>
</ol>
<p>这就是 Context 导致不必要渲染的典型场景。<code>React.memo</code> 在这里失效了，因为它无法阻止由 Context 变更信号触发的强制更新。</p>
<h2 data-id="heading-5">4. 性能优化策略</h2>
<p>为了解决不必要的渲染，我们可以采用以下几种策略，从易到难，层层递进。</p>
<h3 data-id="heading-6">策略一：使用 <code>useMemo</code> 稳定 <code>value</code> 对象</h3>
<p>这是最基础的优化。我们应该确保 <code>Provider</code> 的 <code>value</code> 不会在每次渲染时都创建一个新对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"light"</span>);

  <span class="hljs-comment">// 只有当 user 或 theme 变化时，value 的引用才会改变</span>
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ user, theme, setTheme }), [user, theme]);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span>;
}
</code></pre>
<p><strong>效果</strong>：此举可以防止因 <code>AppProvider</code> 的父组件渲染而导致的、不相关的重新渲染。但它仍然没有解决我们上面的核心问题：<code>UserProfile</code> 依然会因为 <code>theme</code> 的变化而渲染。</p>
<h3 data-id="heading-7">策略二：拆分 Context</h3>
<p>这是解决 Context 性能问题的最有效、最符合 React 理念的方法：<strong>保持 Context 的单一职责</strong>。</p>
<p>不要创建一个包罗万象的“巨石”Context，而应该根据状态的关联性和更新频率，将其拆分为多个更小的、独立的 Context。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 创建独立的 Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();

<span class="hljs-comment">// 2. 创建独立的 Provider</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ user, setUser }), [user]);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"light"</span>);
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ theme, setTheme }), [theme]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 3. 组合 Provider</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProviders</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">UserProvider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 4. 组件按需消费</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { user } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>); <span class="hljs-comment">// 只订阅 UserContext</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"UserProfile rendered"</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user ? user.name : "Guest"}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeToggler</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { theme, setTheme } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>); <span class="hljs-comment">// 只订阅 ThemeContext</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"ThemeToggler rendered"</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme((t) =&gt; (t === "light" ? "dark" : "light"))}&gt;
      {theme}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>效果</strong>：现在，当 <code>ThemeToggler</code> 更新 <code>ThemeContext</code> 时，只有订阅了 <code>ThemeContext</code> 的组件会收到更新信号。<code>UserProfile</code> 因为只订阅了 <code>UserContext</code>，所以完全不受影响，其不必要的渲染被彻底消除。</p>
<h3 data-id="heading-8">策略三：组件组合</h3>
<p>核心思想是：<strong>将那些不关心 Context 变化的、昂贵的组件作为 <code>children</code> prop 传递给一个消费了 Context 的父组件。</strong></p>
<p>这样，当 Context 变化导致父组件重新渲染时，React 会发现 <code>children</code> prop 的引用没有改变（它是在父组件的父组件中定义的），因此会跳过对 <code>children</code> 的重新渲染。</p>
<p>让我们看一个正确应用的例子：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// AppProvider 包含 theme 和 setTheme</span>
<span class="hljs-comment">// ThemeToggler 用于改变 theme</span>

<span class="hljs-comment">// 1. 父组件消费 Context，并接受一个 children prop</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeWrapper</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> { theme } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppContext</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ThemeWrapper rendered, theme is: <span class="hljs-subst">${theme}</span>`</span>);

  <span class="hljs-comment">// 这个 div 的背景色会变，但它的 children 不会重新渲染</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
        <span class="hljs-attr">backgroundColor:</span> <span class="hljs-attr">theme</span> === <span class="hljs-string">"light"</span> ? "#<span class="hljs-attr">fff</span>" <span class="hljs-attr">:</span> "#<span class="hljs-attr">333</span>",
        <span class="hljs-attr">padding:</span> "<span class="hljs-attr">10px</span>",
      }}
    &gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 2. 昂贵的组件，自身不消费 Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ExpensiveTree</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveTree</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"ExpensiveTree rendered (should not happen on theme change)"</span>);
  <span class="hljs-comment">// ... 假设这里有非常复杂的 UI</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是一个非常昂贵的组件树，它不应该因为主题变化而重绘。<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
});

<span class="hljs-comment">// 3. 在应用中使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeToggler</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeWrapper</span>&gt;</span>
        {/* ExpensiveTree 在 App 中定义，作为 children 传递 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveTree</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeWrapper</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">AppProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>效果</strong>：当 <code>theme</code> 变化时，只有 <code>ThemeToggler</code> 和 <code>ThemeWrapper</code> 会重新渲染。<code>ThemeWrapper</code> 重新渲染是必要的，因为它需要应用新的背景色。但关键在于，它接收的 <code>children</code> (<code>&lt;ExpensiveTree /&gt;</code>) 是在 <code>App</code> 组件的作用域中创建的。对于 <code>ThemeWrapper</code> 来说，每次渲染时 <code>props.children</code> 的引用都是相同的。因此，React 会成功跳过对 <code>ExpensiveTree</code> 的渲染，避免了不必要的性能开销。</p>
<h2 data-id="heading-9">5. 总结</h2>
<p>理解 Context API 的订阅机制和性能权衡，是成为一名高效 React 开发者的关键。通过合理地组织 Context 并采用适当的优化策略，我们可以在享受其便利性的同时，构建出高性能、可扩展的应用程序。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用三行代码实现圣诞树？别逗了！让我们来真的]]></title>    <link>https://juejin.cn/post/7587322796825542696</link>    <guid>https://juejin.cn/post/7587322796825542696</guid>    <pubDate>2025-12-25T03:03:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587322796825542696" data-draft-id="7587342664077410319" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用三行代码实现圣诞树？别逗了！让我们来真的"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-25T03:03:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="无限大6"/> <meta itemprop="url" content="https://juejin.cn/user/2865758605422890"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用三行代码实现圣诞树？别逗了！让我们来真的
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2865758605422890/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    无限大6
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T03:03:25.000Z" title="Thu Dec 25 2025 03:03:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><h2 data-id="heading-0">🎄 用三行代码实现圣诞树？别逗了！让我们来真的！</h2>
<h3 data-id="heading-1">🌟 圣诞节的正确打开方式</h3>
<p>圣诞节快到了，是不是感觉家里缺了点什么？🎅 对，就是那棵 bling bling 的圣诞树！但是买真树太麻烦，买假树又没灵魂？没关系，今天我就教你用<strong>HTML+CSS+JS</strong>打造一棵属于你的「代码圣诞树」，让你的电脑屏幕充满节日气息！🎁</p>
<h3 data-id="heading-2">🛠️ 准备工作</h3>
<p>在开始之前，我们需要准备：</p>
<ul>
<li>一颗想搞事情的心 💡</li>
<li>一个文本编辑器（记事本也行，但我劝你用 VS Code）</li>
<li>一点 HTML+CSS+JS 基础</li>
<li>还有满脑子的圣诞精神 🎄</li>
</ul>
<h3 data-id="heading-3">🎨 开始制作圣诞树</h3>
<h4 data-id="heading-4">第一步：搭建骨架（HTML）</h4>
<p>首先，我们需要给圣诞树搭个骨架。就像盖房子一样，先打地基！</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的代码圣诞树 🎄<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"style.css"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>🎅 Merry Christmas! 🎄<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树的树干 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"trunk"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树的树冠，用三个三角形组成 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树上的装饰品 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decorations"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 树顶星星 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"star"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 雪花效果 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snow"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 礼物盒 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"gifts"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"script.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-5">第二步：化妆打扮（CSS）</h4>
<p>现在，我们需要给圣诞树穿上漂亮的衣服！这一步就像女朋友化妆，要细心！💄</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 全局样式 */</span>
* {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#1a1a2e</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#16213e</span> <span class="hljs-number">100%</span>);
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">overflow</span>: hidden;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Arial"</span>, sans-serif;
}

<span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">text-align</span>: center;
  <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-comment">/* 标题样式 */</span>
<span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">30px</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.5rem</span>;
  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>;
  <span class="hljs-attribute">animation</span>: glow <span class="hljs-number">2s</span> ease-in-out infinite alternate;
}

<span class="hljs-comment">/* 标题发光动画 */</span>
<span class="hljs-keyword">@keyframes</span> glow {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>;
  }
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">40px</span> <span class="hljs-number">#ff0</span>;
  }
}

<span class="hljs-comment">/* 圣诞树容器 */</span>
<span class="hljs-selector-class">.tree</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">display</span>: inline-block;
}

<span class="hljs-comment">/* 树干样式 */</span>
<span class="hljs-selector-class">.trunk</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#8b4513</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">60px</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span>;
}

<span class="hljs-comment">/* 树冠样式 - 三个三角形叠加 */</span>
<span class="hljs-selector-class">.leaves</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">border-left</span>: transparent solid;
  <span class="hljs-attribute">border-right</span>: transparent solid;
  <span class="hljs-attribute">border-bottom</span>: green solid;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
}

<span class="hljs-comment">/* 第一层树冠 */</span>
<span class="hljs-selector-class">.leaves-1</span> {
  <span class="hljs-attribute">border-left-width</span>: <span class="hljs-number">150px</span>;
  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">150px</span>;
  <span class="hljs-attribute">border-bottom-width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#228b22</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#006400</span> <span class="hljs-number">100%</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-number">50%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* 第二层树冠 */</span>
<span class="hljs-selector-class">.leaves-2</span> {
  <span class="hljs-attribute">border-left-width</span>: <span class="hljs-number">120px</span>;
  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">120px</span>;
  <span class="hljs-attribute">border-bottom-width</span>: <span class="hljs-number">160px</span>;
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">70px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#228b22</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#006400</span> <span class="hljs-number">100%</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-number">50%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* 第三层树冠 */</span>
<span class="hljs-selector-class">.leaves-3</span> {
  <span class="hljs-attribute">border-left-width</span>: <span class="hljs-number">90px</span>;
  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">90px</span>;
  <span class="hljs-attribute">border-bottom-width</span>: <span class="hljs-number">120px</span>;
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">140px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#228b22</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#006400</span> <span class="hljs-number">100%</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-number">50%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* 树顶星星 */</span>
<span class="hljs-selector-class">.star</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">25px</span> solid transparent;
  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">25px</span> solid transparent;
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">43px</span> solid <span class="hljs-number">#ffd700</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">250px</span>;
  <span class="hljs-attribute">animation</span>: twinkle <span class="hljs-number">1s</span> ease-in-out infinite alternate;
}

<span class="hljs-comment">/* 星星闪烁动画 */</span>
<span class="hljs-keyword">@keyframes</span> twinkle {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
  }
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ffd700</span>;
  }
}

<span class="hljs-comment">/* 星星的五个角 */</span>
<span class="hljs-selector-class">.star</span><span class="hljs-selector-pseudo">::before</span>,
<span class="hljs-selector-class">.star</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">25px</span> solid transparent;
  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">25px</span> solid transparent;
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">43px</span> solid <span class="hljs-number">#ffd700</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: -<span class="hljs-number">25px</span>;
}

<span class="hljs-selector-class">.star</span><span class="hljs-selector-pseudo">::before</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">72deg</span>);
}

<span class="hljs-selector-class">.star</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">144deg</span>);
}

<span class="hljs-comment">/* 装饰品基础样式 */</span>
<span class="hljs-selector-class">.decoration</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">animation</span>: blink <span class="hljs-number">1.5s</span> ease-in-out infinite alternate;
}

<span class="hljs-comment">/* 装饰品闪烁动画 */</span>
<span class="hljs-keyword">@keyframes</span> blink {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
  }
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> currentColor;
  }
}

<span class="hljs-comment">/* 不同颜色的装饰品 */</span>
<span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.red</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff0000</span>;
}

<span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.blue</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000ff</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#0000ff</span>;
}

<span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.yellow</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffff00</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ffff00</span>;
}

<span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.pink</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff1493</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff1493</span>;
}

<span class="hljs-comment">/* 雪花样式 */</span>
<span class="hljs-selector-class">.snowflake</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">animation</span>: fall linear infinite;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
}

<span class="hljs-comment">/* 雪花下落动画 */</span>
<span class="hljs-keyword">@keyframes</span> fall {
  <span class="hljs-selector-tag">from</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100px</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  }
  <span class="hljs-number">10%</span> {
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
  }
  <span class="hljs-selector-tag">to</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100vh</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  }
}

<span class="hljs-comment">/* 礼物盒容器 */</span>
<span class="hljs-selector-class">.gifts</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">100px</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;
}

<span class="hljs-comment">/* 礼物盒样式 */</span>
<span class="hljs-selector-class">.gift</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">animation</span>: bounce <span class="hljs-number">2s</span> ease-in-out infinite;
}

<span class="hljs-comment">/* 礼物盒弹跳动画 */</span>
<span class="hljs-keyword">@keyframes</span> bounce {
  <span class="hljs-number">0%</span>,
  <span class="hljs-number">100%</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);
  }
  <span class="hljs-number">50%</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">10px</span>);
  }
}

<span class="hljs-comment">/* 不同颜色的礼物盒 */</span>
<span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.red</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
}

<span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.green</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#008000</span>;
}

<span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.blue</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000ff</span>;
}

<span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.yellow</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffff00</span>;
}

<span class="hljs-comment">/* 礼物盒丝带 */</span>
<span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::before</span>,
<span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
}

<span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::before</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);
}

<span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
}
</code></pre>
<h4 data-id="heading-6">第三步：让它动起来（JS）</h4>
<p>现在，我们的圣诞树还只是个「静态美人」，让我们用 JavaScript 给它注入灵魂！✨</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 圣诞树装饰品生成</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDecorations</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> decorationsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".decorations"</span>);
  <span class="hljs-keyword">const</span> colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"yellow"</span>, <span class="hljs-string">"pink"</span>];
  <span class="hljs-keyword">const</span> count = <span class="hljs-number">20</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
    <span class="hljs-keyword">const</span> decoration = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
    decoration.<span class="hljs-property">className</span> = <span class="hljs-string">`decoration <span class="hljs-subst">${
      colors[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colors.length)]
    }</span>`</span>;

    <span class="hljs-comment">// 随机位置（在树冠范围内）</span>
    <span class="hljs-keyword">const</span> angle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>;
    <span class="hljs-keyword">const</span> radius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">120</span> + <span class="hljs-number">30</span>;
    <span class="hljs-keyword">const</span> x = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle) * radius;
    <span class="hljs-keyword">const</span> y = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle) * radius - <span class="hljs-number">100</span>;

    decoration.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">`calc(50% + <span class="hljs-subst">${x}</span>px)`</span>;
    decoration.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = <span class="hljs-string">`<span class="hljs-subst">${y}</span>px`</span>;
    decoration.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>}</span>s`</span>;

    decorationsContainer.<span class="hljs-title function_">appendChild</span>(decoration);
  }
}

<span class="hljs-comment">// 雪花生成器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createSnow</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> snowContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".snow"</span>);
  <span class="hljs-keyword">const</span> snowflakeCount = <span class="hljs-number">100</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; snowflakeCount; i++) {
    <span class="hljs-keyword">const</span> snowflake = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
    snowflake.<span class="hljs-property">className</span> = <span class="hljs-string">"snowflake"</span>;

    <span class="hljs-comment">// 随机大小</span>
    <span class="hljs-keyword">const</span> size = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">8</span> + <span class="hljs-number">2</span>;
    snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">`<span class="hljs-subst">${size}</span>px`</span>;
    snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${size}</span>px`</span>;

    <span class="hljs-comment">// 随机位置</span>
    snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>}</span>vw`</span>;

    <span class="hljs-comment">// 随机下落速度</span>
    <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span> + <span class="hljs-number">5</span>;
    snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">animationDuration</span> = <span class="hljs-string">`<span class="hljs-subst">${duration}</span>s`</span>;

    <span class="hljs-comment">// 随机延迟</span>
    snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5</span>}</span>s`</span>;

    snowContainer.<span class="hljs-title function_">appendChild</span>(snowflake);
  }
}

<span class="hljs-comment">// 礼物盒生成</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createGifts</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> giftsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".gifts"</span>);
  <span class="hljs-keyword">const</span> colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"yellow"</span>];
  <span class="hljs-keyword">const</span> count = <span class="hljs-number">4</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
    <span class="hljs-keyword">const</span> gift = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
    gift.<span class="hljs-property">className</span> = <span class="hljs-string">`gift <span class="hljs-subst">${
      colors[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colors.length)]
    }</span>`</span>;
    gift.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${i * <span class="hljs-number">0.5</span>}</span>s`</span>;
    giftsContainer.<span class="hljs-title function_">appendChild</span>(gift);
  }
}

<span class="hljs-comment">// 页面加载完成后执行</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"DOMContentLoaded"</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">createDecorations</span>();
  <span class="hljs-title function_">createSnow</span>();
  <span class="hljs-title function_">createGifts</span>();
});
</code></pre>
<h3 data-id="heading-7">🎉 让圣诞树跑起来</h3>
<p>现在，让我们把所有代码合并到一个完整的 HTML 文件中，你可以直接复制下面的代码保存为 <code>christmas-tree.html</code>，然后用浏览器打开它，就能看到你的圣诞树了！🎄</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>🎄 我的代码圣诞树<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
      <span class="hljs-comment">/* 全局样式 */</span>
      * {
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">box-sizing</span>: border-box;
      }

      <span class="hljs-selector-tag">body</span> {
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-number">#1a1a2e</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#16213e</span> <span class="hljs-number">100%</span>);
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
        <span class="hljs-attribute">display</span>: flex;
        <span class="hljs-attribute">justify-content</span>: center;
        <span class="hljs-attribute">align-items</span>: center;
        <span class="hljs-attribute">overflow</span>: hidden;
        <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Arial"</span>, sans-serif;
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
      }

      <span class="hljs-selector-class">.container</span> {
        <span class="hljs-attribute">text-align</span>: center;
        <span class="hljs-attribute">position</span>: relative;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;
        <span class="hljs-attribute">display</span>: flex;
        <span class="hljs-attribute">flex-direction</span>: column;
        <span class="hljs-attribute">justify-content</span>: center;
        <span class="hljs-attribute">align-items</span>: center;
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
      }

      <span class="hljs-comment">/* 标题样式 */</span>
      <span class="hljs-selector-tag">h1</span> {
        <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.5rem</span>;
        <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>;
        <span class="hljs-attribute">animation</span>: glow <span class="hljs-number">2s</span> ease-in-out infinite alternate;
        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">20</span>;
        <span class="hljs-attribute">position</span>: relative;
      }

      <span class="hljs-comment">/* 标题发光动画 */</span>
      <span class="hljs-keyword">@keyframes</span> glow {
        <span class="hljs-selector-tag">from</span> {
          <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>;
        }
        <span class="hljs-selector-tag">to</span> {
          <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> <span class="hljs-number">#ff0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">40px</span> <span class="hljs-number">#ff0</span>;
        }
      }

      <span class="hljs-comment">/* 圣诞树容器 */</span>
      <span class="hljs-selector-class">.tree</span> {
        <span class="hljs-attribute">position</span>: relative;
        <span class="hljs-attribute">display</span>: inline-block;
      }

      <span class="hljs-comment">/* 树干样式 */</span>
      <span class="hljs-selector-class">.trunk</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#8b4513</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">60px</span>;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span>;
      }

      <span class="hljs-comment">/* 树冠样式 - 三个三角形叠加 */</span>
      <span class="hljs-selector-class">.leaves</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>));
      }

      <span class="hljs-comment">/* 第一层树冠 */</span>
      <span class="hljs-selector-class">.leaves-1</span> {
        <span class="hljs-attribute">border-left</span>: <span class="hljs-number">150px</span> solid transparent;
        <span class="hljs-attribute">border-right</span>: <span class="hljs-number">150px</span> solid transparent;
        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">200px</span> solid <span class="hljs-number">#2e8b57</span>;
        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">animation</span>: sway <span class="hljs-number">3s</span> ease-in-out infinite alternate;
      }

      <span class="hljs-comment">/* 第二层树冠 */</span>
      <span class="hljs-selector-class">.leaves-2</span> {
        <span class="hljs-attribute">border-left</span>: <span class="hljs-number">120px</span> solid transparent;
        <span class="hljs-attribute">border-right</span>: <span class="hljs-number">120px</span> solid transparent;
        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">160px</span> solid <span class="hljs-number">#3cb371</span>;
        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">70px</span>;
        <span class="hljs-attribute">animation</span>: sway <span class="hljs-number">3s</span> ease-in-out infinite alternate-reverse;
      }

      <span class="hljs-comment">/* 第三层树冠 */</span>
      <span class="hljs-selector-class">.leaves-3</span> {
        <span class="hljs-attribute">border-left</span>: <span class="hljs-number">90px</span> solid transparent;
        <span class="hljs-attribute">border-right</span>: <span class="hljs-number">90px</span> solid transparent;
        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">120px</span> solid <span class="hljs-number">#228b22</span>;
        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">140px</span>;
        <span class="hljs-attribute">animation</span>: sway <span class="hljs-number">3s</span> ease-in-out infinite alternate;
      }

      <span class="hljs-comment">/* 树摇摆动画 */</span>
      <span class="hljs-keyword">@keyframes</span> sway {
        <span class="hljs-selector-tag">from</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">1deg</span>);
        }
        <span class="hljs-selector-tag">to</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">1deg</span>);
        }
      }

      <span class="hljs-comment">/* 树顶星星 - 使用更简单的方式实现 */</span>
      <span class="hljs-selector-class">.star</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffd700</span>;
        <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(
          <span class="hljs-number">50%</span> <span class="hljs-number">0%</span>,
          <span class="hljs-number">61%</span> <span class="hljs-number">35%</span>,
          <span class="hljs-number">98%</span> <span class="hljs-number">35%</span>,
          <span class="hljs-number">68%</span> <span class="hljs-number">57%</span>,
          <span class="hljs-number">79%</span> <span class="hljs-number">91%</span>,
          <span class="hljs-number">50%</span> <span class="hljs-number">70%</span>,
          <span class="hljs-number">21%</span> <span class="hljs-number">91%</span>,
          <span class="hljs-number">32%</span> <span class="hljs-number">57%</span>,
          <span class="hljs-number">2%</span> <span class="hljs-number">35%</span>,
          <span class="hljs-number">39%</span> <span class="hljs-number">35%</span>
        );
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">250px</span>;
        <span class="hljs-attribute">animation</span>: twinkle <span class="hljs-number">1s</span> ease-in-out infinite alternate;
        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;
      }

      <span class="hljs-comment">/* 星星闪烁动画 */</span>
      <span class="hljs-keyword">@keyframes</span> twinkle {
        <span class="hljs-selector-tag">from</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
        }
        <span class="hljs-selector-tag">to</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
          <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#ffd700</span>;
        }
      }

      <span class="hljs-comment">/* 装饰品基础样式 */</span>
      <span class="hljs-selector-class">.decoration</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;
        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">animation</span>: blink <span class="hljs-number">1.5s</span> ease-in-out infinite alternate;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> currentColor;
      }

      <span class="hljs-comment">/* 装饰品闪烁动画 */</span>
      <span class="hljs-keyword">@keyframes</span> blink {
        <span class="hljs-selector-tag">from</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
        }
        <span class="hljs-selector-tag">to</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.3</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
          <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> currentColor, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">30px</span> currentColor;
        }
      }

      <span class="hljs-comment">/* 不同颜色的装饰品，增加发光效果 */</span>
      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.red</span> {
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">#ff0000</span>, inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>);
      }

      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.blue</span> {
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000ff</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">#0000ff</span>, inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>);
      }

      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.yellow</span> {
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffff00</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">#ffff00</span>, inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>);
      }

      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.pink</span> {
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff1493</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">#ff1493</span>, inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>);
      }

      <span class="hljs-comment">/* 添加一些不同大小的装饰品 */</span>
      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.large</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">25px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;
      }

      <span class="hljs-selector-class">.decoration</span><span class="hljs-selector-class">.small</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">15px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;
        <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">2s</span>;
      }

      <span class="hljs-comment">/* 雪花样式 */</span>
      <span class="hljs-selector-class">.snowflake</span> {
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">animation</span>: fall linear infinite;
        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
      }

      <span class="hljs-comment">/* 雪花下落动画 */</span>
      <span class="hljs-keyword">@keyframes</span> fall {
        <span class="hljs-selector-tag">from</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100px</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
        }
        <span class="hljs-number">10%</span> {
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;
        }
        <span class="hljs-selector-tag">to</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100vh</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);
          <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
        }
      }

      <span class="hljs-comment">/* 礼物盒容器 */</span>
      <span class="hljs-selector-class">.gifts</span> {
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">80px</span>;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">display</span>: flex;
        <span class="hljs-attribute">gap</span>: <span class="hljs-number">25px</span>;
        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">5</span>;
      }

      <span class="hljs-comment">/* 礼物盒样式 - 立体效果 */</span>
      <span class="hljs-selector-class">.gift</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;
        <span class="hljs-attribute">position</span>: relative;
        <span class="hljs-attribute">animation</span>: bounce <span class="hljs-number">2s</span> ease-in-out infinite;
        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);
      }

      <span class="hljs-comment">/* 礼物盒弹跳动画 - 更自然的效果 */</span>
      <span class="hljs-keyword">@keyframes</span> bounce {
        <span class="hljs-number">0%</span>,
        <span class="hljs-number">100%</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
        }
        <span class="hljs-number">50%</span> {
          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">15px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.05</span>);
        }
      }

      <span class="hljs-comment">/* 不同颜色的礼物盒，添加渐变和立体效果 */</span>
      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.red</span> {
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, <span class="hljs-number">#ff0000</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#cc0000</span> <span class="hljs-number">100%</span>);
      }

      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.green</span> {
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, <span class="hljs-number">#008000</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#006400</span> <span class="hljs-number">100%</span>);
      }

      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.blue</span> {
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, <span class="hljs-number">#0000ff</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#0000cc</span> <span class="hljs-number">100%</span>);
      }

      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-class">.yellow</span> {
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, <span class="hljs-number">#ffff00</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#cccc00</span> <span class="hljs-number">100%</span>);
      }

      <span class="hljs-comment">/* 礼物盒盖子 - 立体效果 */</span>
      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::before</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">top</span>: -<span class="hljs-number">8px</span>;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">8px</span>;
        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(
          <span class="hljs-number">135deg</span>,
          <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.3</span>) <span class="hljs-number">0%</span>,
          <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.1</span>) <span class="hljs-number">100%</span>
        );
        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> -<span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>);
      }

      <span class="hljs-comment">/* 礼物盒丝带 - 更美观的设计 */</span>
      <span class="hljs-selector-class">.gift</span><span class="hljs-selector-pseudo">::after</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">8px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);
      }

      <span class="hljs-comment">/* 礼物盒底部丝带 */</span>
      <span class="hljs-selector-class">.gift</span> {
        <span class="hljs-attribute">position</span>: relative;
      }

      <span class="hljs-comment">/* 礼物盒丝带装饰 */</span>
      <span class="hljs-selector-class">.gift</span> <span class="hljs-selector-tag">span</span> {
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">8px</span>;
        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);
        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>🎅 Merry Christmas! 🎄<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树的树干 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"trunk"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树的树冠，用三个三角形组成 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"leaves leaves-3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 圣诞树上的装饰品 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decorations"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 树顶星星 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"star"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 雪花效果 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"snow"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 礼物盒 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"gifts"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// 圣诞树装饰品生成</span>
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">createDecorations</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> decorationsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".decorations"</span>);
        <span class="hljs-keyword">const</span> colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"yellow"</span>, <span class="hljs-string">"pink"</span>];
        <span class="hljs-keyword">const</span> sizes = [<span class="hljs-string">""</span>, <span class="hljs-string">"large"</span>, <span class="hljs-string">"small"</span>];
        <span class="hljs-keyword">const</span> count = <span class="hljs-number">25</span>; <span class="hljs-comment">// 增加数量，让树更丰富</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
          <span class="hljs-keyword">const</span> decoration = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
          decoration.<span class="hljs-property">className</span> = <span class="hljs-string">`decoration <span class="hljs-subst">${
            colors[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colors.length)]
          }</span> <span class="hljs-subst">${sizes[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * sizes.length)]}</span>`</span>;

          <span class="hljs-comment">// 简单的随机位置，确保在树内部</span>
          <span class="hljs-keyword">const</span> x = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">200</span> - <span class="hljs-number">100</span>; <span class="hljs-comment">// -100到100之间</span>
          <span class="hljs-keyword">const</span> y = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">180</span>; <span class="hljs-comment">// 0到180之间</span>

          <span class="hljs-comment">// 确保在三角形树冠范围内</span>
          <span class="hljs-keyword">const</span> distanceFromCenter = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x);
          <span class="hljs-keyword">const</span> maxWidthAtHeight = <span class="hljs-number">150</span> - (y / <span class="hljs-number">180</span>) * <span class="hljs-number">100</span>;

          <span class="hljs-keyword">if</span> (distanceFromCenter &lt; maxWidthAtHeight) {
            decoration.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">`calc(50% + <span class="hljs-subst">${x}</span>px)`</span>;
            decoration.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = <span class="hljs-string">`<span class="hljs-subst">${y}</span>px`</span>;
            decoration.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>}</span>s`</span>;
            decoration.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = <span class="hljs-number">2</span>;

            decorationsContainer.<span class="hljs-title function_">appendChild</span>(decoration);
          }
        }
      }

      <span class="hljs-comment">// 雪花生成器</span>
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSnow</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> snowContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".snow"</span>);
        <span class="hljs-keyword">const</span> snowflakeCount = <span class="hljs-number">100</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; snowflakeCount; i++) {
          <span class="hljs-keyword">const</span> snowflake = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
          snowflake.<span class="hljs-property">className</span> = <span class="hljs-string">"snowflake"</span>;

          <span class="hljs-comment">// 随机大小</span>
          <span class="hljs-keyword">const</span> size = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">8</span> + <span class="hljs-number">2</span>;
          snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">`<span class="hljs-subst">${size}</span>px`</span>;
          snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${size}</span>px`</span>;

          <span class="hljs-comment">// 随机位置</span>
          snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>}</span>vw`</span>;

          <span class="hljs-comment">// 随机下落速度</span>
          <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span> + <span class="hljs-number">5</span>;
          snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">animationDuration</span> = <span class="hljs-string">`<span class="hljs-subst">${duration}</span>s`</span>;

          <span class="hljs-comment">// 随机延迟</span>
          snowflake.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5</span>}</span>s`</span>;

          snowContainer.<span class="hljs-title function_">appendChild</span>(snowflake);
        }
      }

      <span class="hljs-comment">// 礼物盒生成</span>
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">createGifts</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> giftsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">".gifts"</span>);
        <span class="hljs-keyword">const</span> colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"yellow"</span>];
        <span class="hljs-keyword">const</span> count = <span class="hljs-number">5</span>; <span class="hljs-comment">// 增加一个礼物盒</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
          <span class="hljs-keyword">const</span> gift = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
          gift.<span class="hljs-property">className</span> = <span class="hljs-string">`gift <span class="hljs-subst">${
            colors[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colors.length)]
          }</span>`</span>;
          gift.<span class="hljs-property">style</span>.<span class="hljs-property">animationDelay</span> = <span class="hljs-string">`<span class="hljs-subst">${i * <span class="hljs-number">0.3</span>}</span>s`</span>;

          <span class="hljs-comment">// 添加丝带装饰</span>
          <span class="hljs-keyword">const</span> ribbon = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"span"</span>);
          gift.<span class="hljs-title function_">appendChild</span>(ribbon);

          giftsContainer.<span class="hljs-title function_">appendChild</span>(gift);
        }
      }

      <span class="hljs-comment">// 页面加载完成后执行</span>
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"DOMContentLoaded"</span>, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">createDecorations</span>();
        <span class="hljs-title function_">createSnow</span>();
        <span class="hljs-title function_">createGifts</span>();
      });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">🎨 代码解析</h3>
<h4 data-id="heading-9">1. 圣诞树的结构 🏗️</h4>
<p>圣诞树的结构其实很简单：</p>
<ul>
<li><strong>树干</strong>：一个棕色的长方形</li>
<li><strong>树冠</strong>：三个大小不一的三角形叠加在一起</li>
<li><strong>树顶星星</strong>：一个金色的五角星（用 CSS 边框实现）</li>
<li><strong>装饰品</strong>：彩色的小圆点，随机分布在树冠上</li>
<li><strong>雪花</strong>：白色的小圆点，从天上飘落</li>
<li><strong>礼物盒</strong>：彩色的正方形，带有白色丝带</li>
</ul>
<h4 data-id="heading-10">2. CSS 的魔法 ✨</h4>
<ul>
<li><strong>渐变背景</strong>：让树干和树冠看起来更有层次感</li>
<li><strong>动画效果</strong>：
<ul>
<li>标题发光动画 <code>glow</code></li>
<li>星星闪烁动画 <code>twinkle</code></li>
<li>装饰品闪烁动画 <code>blink</code></li>
<li>雪花下落动画 <code>fall</code></li>
<li>礼物盒弹跳动画 <code>bounce</code></li>
</ul>
</li>
<li><strong>定位技巧</strong>：使用 <code>position: absolute</code> 和 <code>transform: translateX(-50%)</code> 让元素居中</li>
</ul>
<h4 data-id="heading-11">3. JavaScript 的灵魂 🧠</h4>
<ul>
<li><strong>动态生成装饰品</strong>：随机位置、随机颜色、随机闪烁延迟</li>
<li><strong>雪花生成器</strong>：100 片雪花，随机大小、随机速度、随机位置</li>
<li><strong>礼物盒生成</strong>：4 个不同颜色的礼物盒，带有弹跳效果</li>
</ul>
<h3 data-id="heading-12">🎁 扩展功能</h3>
<p>如果你觉得这个圣诞树还不够炫酷，你可以尝试：</p>
<ol>
<li><strong>添加音乐</strong>：用 HTML5 的 <code>audio</code> 标签添加圣诞歌曲 🎵</li>
<li><strong>交互效果</strong>：点击圣诞树会下雪或播放音乐 🎶</li>
<li><strong>3D 效果</strong>：使用 CSS 3D 变换让圣诞树旋转 🌀</li>
<li><strong>更多装饰品</strong>：添加彩灯、铃铛、袜子等 🧦</li>
</ol>
<h3 data-id="heading-13">🤣 程序员的圣诞节</h3>
<p>作为一个程序员，我们的圣诞节是这样的：</p>
<ul>
<li>别人在装饰圣诞树，我们在装饰代码</li>
<li>别人在拆礼物，我们在拆 bug</li>
<li>别人在吃火鸡，我们在吃外卖</li>
<li>别人在看春晚，我们在看技术文档</li>
</ul>
<p>但是没关系，我们有属于自己的快乐！当看到自己写的圣诞树在屏幕上闪闪发光时，那种成就感是无法言喻的！🌟</p>
<h3 data-id="heading-14">🎄 结语</h3>
<p>好了，今天的圣诞树教程就到这里了！希望你能喜欢这个代码圣诞树，也希望你能在圣诞节收获满满的快乐和幸福！🎅</p>
<p>记住，生活就像圣诞树，需要我们用心去装饰，才能变得更加美好！✨</p>
<p>最后，祝大家：</p>
<ul>
<li>圣诞快乐！🎄</li>
<li>代码无 bug！🐛❌</li>
<li>工资涨不停！💰</li>
<li>永远不脱发！👨‍💻👩‍💻</li>
</ul>
<p>Merry Christmas and Happy New Year! 🎉</p>
<hr/>
<p>💡 <strong>小贴士</strong>：如果你觉得这个圣诞树不错，别忘了分享给你的朋友，让他们也感受一下程序员的圣诞浪漫！😂</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[学院本大二混子终于找到实习了...]]></title>    <link>https://juejin.cn/post/7587246055458471963</link>    <guid>https://juejin.cn/post/7587246055458471963</guid>    <pubDate>2025-12-25T01:11:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587246055458471963" data-draft-id="7587313610695671835" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="学院本大二混子终于找到实习了..."/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-12-25T01:11:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员小假"/> <meta itemprop="url" content="https://juejin.cn/user/2285197690931932"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            学院本大二混子终于找到实习了...
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2285197690931932/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员小假
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:11:14.000Z" title="Thu Dec 25 2025 01:11:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这段时间在找实习，到现在有 3 个中小厂的 offer，先过渡一下吧。距离上次发帖已经过去大半年了，这段时间里自己努力过，迷茫过，焦虑过，但好在没有停止继续前进。非常感谢帮助过我的前辈和朋友们，至少让我看到了希望，不管后面能不能进大厂，在当下的认知里，尽力得去做自己认为对的事情就够了。</p>
<h3 data-id="heading-0">大一</h3>
<p>还记得刚上大一的时候啥都不懂，那段时间自己也非常迷茫呀，不知道要选什么方向，于是就在网上疯狂地看别人的经验贴，有不懂的就问前辈们。那时候对考研的欲望非常强，想着一定要考研来弥补自己高考失利的遗憾，高数 英语 政治 408 要怎么学，统统了解了个遍，并计划着要在大二下开始考研之路(现在就当放屁)，前提是自己要在大二前找到实习，这样有保证点。(随着自己对考研的不断了解，现在自己完全不想读研了，更想自由点)。然后就是了解到算法好像很重要(当时的认知)，得多参加参加比赛次才行！蓝桥杯啥的，所以学完一个月的 C 语言后就开始学算法了，每天都在看算法书做题，看了好几本算法书，觉得算法真的挺有意思的，自己也加入了老师的算法团队，就这样学了有3 4个月吧，做了四五百道题。经过我不屑地努力，终于在蓝桥杯上获得了省三的好成绩...... 那时候才发现有趣归有趣，自己真不是那块料[笑cry]</p>
<p>于是开始就学 Java 了(当时还问我老师 Java 是不是过时了，我老师说可以学 go，好在我还是学 Java 了)，也慢慢了解了 Java 该如何学习，下载了牛客，结果看到同届居然有人在改简历找实习了[懵] 当时就蒙蔽了，后悔没早点学 Java。也慢慢了解到学院本学 Java 就是死路一条，于是我又陷入了深深地自己我怀疑..... 好在也慢慢认识到一些学院本大佬，至少让我看到了希望，于是想办法去联系到学长们，问之前学长们是怎么进大厂的，有没有什么办法可以弥补一下学历的差距呢[掉小珍珠了] 问了一圈发现最重要的就是卷实习，然后是博客和开源，竞赛除了 ACM 外，其他含金量不高。了解到这里，我就开始写写博客，当做笔记和总结也是非常不错的。到现在博客也有点成绩了(虽然都是水文)，总访问量 60 万+，粉丝量 4K+，获得过 CSDN Java 新星创作者，腾讯云创作之星，阿里云专家博主，华为云云享专家称号，面试的时候面试官也都会问一问，至少有点加分吧。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ceb6bfbe33e4625ac05bf7ef34f765c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5bCP5YGH:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229873&amp;x-signature=AWI%2B4uKiKrKWvkd1yAml2u%2FImHs%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2018f1fefd824a8da807db4535f805f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5bCP5YGH:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229873&amp;x-signature=pM0zO5hlpJvIuijz1pVqDbpJRsg%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b6f71d948b641e18e6ae95fca990899~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5bCP5YGH:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229873&amp;x-signature=AHqKYiyUH4ElekFqBpkdLcaKXpc%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d9a07de43b44b0ca548ac892a3155d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5bCP5YGH:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767229873&amp;x-signature=XfbW9lUcxsCw3vpe0EmjSm6%2F3Es%3D" alt="" loading="lazy"/></p>
<p>就这样学到了暑假，暑假两个月在家其实学得不多(现在想想都太后悔了，兄弟们环境很重要呀，一定要选一个适合自己的环境，不然效率真不高[打脸了])，项目准备了一个写在简历上了，想着大二开学就要找实习了！(服了，想是这么想的，但是因为自己和学校的种种原因就拖到了现在才找实习[老人手机])</p>
<h3 data-id="heading-1">大二</h3>
<p>转眼间就来到了大二，因为有个朋友(双非)在暑假进了大厂(现在已经开始第三段大厂实习了 是我的偶像哈哈 太强了)，因此也提醒了自己一定要早点找实习才行，开始准备第二个项目写在简历上，并开始背八股，花了一两个月过了小林的八股，结果都忘光光了[惊讶] 实在是太多了，马上改变策略，得好好背高频八股才行，背八股的话兄弟们一定要结合理解来背，不然太难背了(至少我是这样的)，而且要整理得偏口语化一点，方便说出来，面试只需要你点出重点就差不多啦。找第一段实习的过程是非常难的，但面试的内容不是说很难(这里指得是中小厂)，我还记得我第一次面试的，我觉得我什么都没准备好，项目没准备好、高频八股还背不熟、自我介绍怎么搞啊，怎么介绍项目呀 我不是写在简历上了嘛[疑惑]等等问题，结果第一次面试全程就问了基础八股[等offer] 哈哈我回答得稀烂，于是我就好好准备高频八股了，第二次面试全程就问了项目，没问八股，我一开始说的时候就是按照简历上面的来念的，面试官打断了我，说这些你简历上都有写，我要问得是你在做这个项目的过程中遇到了哪些复杂的问题以及如何解决的？哈哈我答得也是稀烂，于是我就好好复盘复盘，重新整理了项目介绍，还有一次中小厂面试，一上来就让我写两道力扣中等题，哈哈我不会[废了] 反正啥情况都有，所以找实习还是挺看运气的。兄弟们要找实习就多面面，边面边总结，这样会进步得比较快。就这样，边投边面直到现在。</p>
<h3 data-id="heading-2">总结与规划</h3>
<p>总结：自己还有很多的不足，希望能和大家一起进步，为了自己的目标去努力，纵使疾风起，人生不言弃。</p>
<p>规划：继续做博客，向百万访问量靠近，然后后面可能会去搞搞开源，多卷卷实习，尝试做一下自媒体，尽力去试试看能不能进大厂，至少不给自己留下啥遗憾，与君共勉，愿你我都能达到自己理想的目标，你若盛开，蝴蝶自来。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android基于共享内存实现跨进程大文件传输]]></title>    <link>https://juejin.cn/post/7587264707284877322</link>    <guid>https://juejin.cn/post/7587264707284877322</guid>    <pubDate>2025-12-25T01:15:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587264707284877322" data-draft-id="7587264707284844554" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android基于共享内存实现跨进程大文件传输"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-12-25T01:15:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="容华谢后"/> <meta itemprop="url" content="https://juejin.cn/user/3755587450187432"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android基于共享内存实现跨进程大文件传输
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3755587450187432/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    容华谢后
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:15:08.000Z" title="Thu Dec 25 2025 01:15:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa94a1e880534348babcb1a5d0c755b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a655Y2O6LCi5ZCO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767230177&amp;x-signature=IqduMdMs6uETE6%2ByGRhAktSTTU0%3D" alt="封面" loading="lazy"/></p>
<blockquote>
<p>转载请注明出处：<a href="https://juejin.cn/spost/7587264707284877322" target="_blank" title="https://juejin.cn/spost/7587264707284877322">juejin.cn/spost/75872…</a></p>
<p>本文出自 <a href="https://juejin.cn/user/3755587450187432/posts" target="_blank" title="https://juejin.cn/user/3755587450187432/posts">容华谢后的博客</a></p>
</blockquote>
<h2 data-id="heading-0">0.写在前面</h2>
<p>在实际的项目开发中，为了更好的性能和结构，我们经常会把一个项目应用分成多个进程或者多个组件，当不同进程的业务之间需要通信时，通常会选择AIDL、Bundle或者广播的方式进行通信，这些通信手段有一个共同的特点，就是只支持简单、小容量、不频繁的数据传输，当我们的应用存在这样的业务场景，比如视频流跨进程传输、大文件跨进程传输等需要复杂数据、频繁数据交换的功能时，就不能使用上述的通信手段了。</p>
<p>为了解决这个问题，可以选择共享内存的方式进行通信，在设备的内存中开辟一个固定容量的空间，使用生产者-消费者模型，生产者在内存中写入数据，通过PV操作通知消费者进行读取，消费者读取完成后再通知生产者进行写入。</p>
<h2 data-id="heading-1">1.实现</h2>
<h3 data-id="heading-2">1.1 数据结构</h3>
<p>首先定义下共享内存中的数据结构，首先定义3个信号量：</p>
<ul>
<li>
<p>sem_empty: 定义是否允许写，生产者写前 P(empty)，消费者读后 V(empty)</p>
</li>
<li>
<p>sem_full: 定义是否允许读，消费者读前 P(full)，生产者写后 V(full)</p>
</li>
<li>
<p>sem_mutex: 定义读写互斥锁，保护 state/data_len/data 的互斥</p>
</li>
</ul>
<p>接下来定义数据传输的状态，分别是 IDLE（空闲状态）、DATA（传输数据状态）、EOF（文件传输结束状态），然后定义每次传输数据的有效长度 data_len 和数据块 data属性。</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 数据传输结构
 */</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedBlock</span> {
    <span class="hljs-comment">// 是否允许写（Producer）</span>
    <span class="hljs-type">sem_t</span> sem_empty;
    <span class="hljs-comment">// 是否允许读（Consumer）</span>
    <span class="hljs-type">sem_t</span> sem_full;
    <span class="hljs-comment">// 读写互斥锁</span>
    <span class="hljs-type">sem_t</span> sem_mutex;
    <span class="hljs-comment">// 当前状态</span>
    <span class="hljs-type">uint32_t</span> state;
    <span class="hljs-comment">// data 中有效数据长度</span>
    <span class="hljs-type">uint32_t</span> data_len;
    <span class="hljs-comment">// 数据</span>
    <span class="hljs-type">uint8_t</span> data[SHM_DATA_SIZE];
};

<span class="hljs-comment">/**
 * 共享内存状态机
 *
 * IDLE : 空闲状态
 * DATA : 有有效数据
 * EOF  : 文件传输结束
 */</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShmState</span> : <span class="hljs-type">uint32_t</span> {
    SHM_STATE_IDLE = <span class="hljs-number">0</span>,
    SHM_STATE_DATA = <span class="hljs-number">1</span>,
    SHM_STATE_EOF = <span class="hljs-number">2</span>,
};
</code></pre>
<h3 data-id="heading-3">1.2 创建共享内存</h3>
<p>通过 open("/dev/ashmem", O_RDWR) 方法创建共享内存，得到文件描述符，fd 可通过 AIDL 传递给其他进程，在其他进程通过 fd 映射相同的内存区域进行操作。创建完成后通过 ioctl 方法设置共享内存的名称和大小，再使用 mmap 对内存的地址空间进行映射，然后通过 reinterpret_cast 对内存空间进行结构化。</p>
<p>接下来进行信号量初始化，初始状态为可写、不可读、可进入临界区状态，数据传输状态初始为空闲状态，到这里共享内存就创建完成了，继续往下看共享内存的数据是如何进行读写的。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 创建共享内存
 */</span>
extern "C"
JNIEXPORT jint JNICALL
<span class="hljs-built_in">Java_com_yangle_ashmem_NativeShm_createShm</span>(JNIEnv *, jobject) {
    <span class="hljs-comment">// 创建共享内存区域</span>
    int fd = <span class="hljs-built_in">open</span>("/dev/ashmem", O_RDWR);
    if (fd &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">LOGE</span>("ashmem create region failed");
        return -<span class="hljs-number">1</span>;
    }
    if (ioctl(fd, ASHMEM_SET_NAME, "shared_memory") != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">LOGE</span>("ASHMEM_SET_NAME failed: %s", strerror(errno));
        <span class="hljs-built_in">close</span>(fd);
        return -<span class="hljs-number">1</span>;
    }
    if (ioctl(fd, ASHMEM_SET_SIZE, sizeof(SharedBlock)) != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">LOGE</span>("ASHMEM_SET_SIZE failed: %s", strerror(errno));
        <span class="hljs-built_in">close</span>(fd);
        return -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 映射地址空间</span>
    void *addr = <span class="hljs-built_in">mmap</span>(nullptr, sizeof(SharedBlock), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);
    if (addr == MAP_FAILED) {
        <span class="hljs-built_in">LOGE</span>("mmap failed");
        <span class="hljs-built_in">close</span>(fd);
        return -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 共享内存空间用SharedBlock结构化</span>
    g_block = reinterpret_cast&lt;SharedBlock *&gt;(addr);
    <span class="hljs-built_in">memset</span>(g_block, <span class="hljs-number">0</span>, sizeof(SharedBlock));

    <span class="hljs-comment">// 初始化进程间信号量</span>
    <span class="hljs-comment">// 初始可写</span>
    <span class="hljs-built_in">sem_init</span>(&amp;g_block-&gt;sem_empty, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 初始不可读</span>
    <span class="hljs-built_in">sem_init</span>(&amp;g_block-&gt;sem_full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// 互斥锁</span>
    <span class="hljs-built_in">sem_init</span>(&amp;g_block-&gt;sem_mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);

    g_block-&gt;state = SHM_STATE_IDLE;
    <span class="hljs-built_in">LOGI</span>("createShm success, fd=%d", fd);
    return fd;
}
</code></pre>
<h3 data-id="heading-4">1.3 写入数据</h3>
<p>首先通过 sem_wait（P 操作）方法判断是否可写，以及临界区是否加锁，然后复制数据到共享内存中，通过 sem_post（V 操作）释放临界区锁，通知消费者可以读取数据。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 写入数据
 */</span>
extern "C"
JNIEXPORT jint JNICALL
<span class="hljs-built_in">Java_com_yangle_ashmem_NativeShm_write</span>(JNIEnv *env, jobject, jbyteArray data, jint len) {
    if (!g_block) {
        <span class="hljs-built_in">LOGE</span>("write: g_block is null");
        return -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// P(empty)，如果Consumer还没读完，上一次写会阻塞在这里</span>
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_empty);
    <span class="hljs-comment">// 进入临界区, 保护state、data_len、data的一致性</span>
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_mutex);

    jbyte *<span class="hljs-attribute">src</span> = env-&gt;<span class="hljs-built_in">GetByteArrayElements</span>(data, nullptr);
    <span class="hljs-built_in">memcpy</span>(g_block-&gt;data, src, len);
    g_block-&gt;data_len = len;
    g_block-&gt;state = SHM_STATE_DATA;
    env-&gt;<span class="hljs-built_in">ReleaseByteArrayElements</span>(data, src, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 离开临界区</span>
    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_mutex);
    <span class="hljs-comment">// V(full)，通知 Consumer 可以读取</span>
    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_full);
    return len;
}
</code></pre>
<h3 data-id="heading-5">1.4 读取数据</h3>
<p>读取数据是在另一进程进行的，通过使用 AIDL 传递过来的 fd 可以映射与生产者进程相同的内存区域，然后再将内存区域结构化成 SharedBlock，可以拿到内存中的信号量标志和数据。</p>
<p>首先判断是否读取，如果生产者还在写入，会停在 sem_wait(&amp;g_block-&gt;sem_full) 进行等待，然后判断是否传输完成，再进行数据读取，最后再释放临界区锁，通知生产者可以写入数据。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 读取数据
 */</span>
extern "C"
JNIEXPORT jint JNICALL
<span class="hljs-built_in">Java_com_yangle_ashmem_NativeShm_read</span>(JNIEnv* env, jobject, jint fd, jbyteArray out) {
    if (!g_block) {
        void *addr = <span class="hljs-built_in">mmap</span>(nullptr, sizeof(SharedBlock), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);
        if (addr == MAP_FAILED) {
            <span class="hljs-built_in">LOGE</span>("client mmap failed, fd=%d", fd);
            return -<span class="hljs-number">1</span>;
        }
        g_block = reinterpret_cast&lt;SharedBlock *&gt;(addr);
    }

    <span class="hljs-comment">// P(full)，等待 Producer 写入</span>
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_full);
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_mutex);

    <span class="hljs-comment">// 识别 EOF</span>
    if (g_block-&gt;state == SHM_STATE_EOF) {
        <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_mutex);
        <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_empty);
        <span class="hljs-built_in">LOGI</span>("receive EOF");
        return -<span class="hljs-number">1</span>;
    }

    int len = g_block-&gt;data_len;
    env-&gt;<span class="hljs-built_in">SetByteArrayRegion</span>(out, <span class="hljs-number">0</span>, len, reinterpret_cast&lt;jbyte*&gt;(g_block-&gt;data));

    <span class="hljs-comment">// 信号量可写</span>
    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_mutex);
    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_empty);
    return len;
}
</code></pre>
<h3 data-id="heading-6">1.5 传输结束</h3>
<p>数据传输完成后，发送结束标志，先判断是否读取完成，然后把传输状态修改为 SHM_STATE_EOF 结束，再释放临界区锁，通知消费者可以读取数据，消费者读取传输状态为结束，到此一轮数据传输完成。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 数据传输结束
 */</span>
extern "C"
JNIEXPORT void JNICALL
<span class="hljs-built_in">Java_com_yangle_ashmem_NativeShm_sendEof</span>(JNIEnv*, jobject) {
    if (!g_block) return;
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_empty);
    <span class="hljs-built_in">sem_wait</span>(&amp;g_block-&gt;sem_mutex);

    g_block-&gt;state = SHM_STATE_EOF;
    g_block-&gt;data_len = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_mutex);
    <span class="hljs-built_in">sem_post</span>(&amp;g_block-&gt;sem_full);
    <span class="hljs-built_in">LOGI</span>("send EOF");
}
</code></pre>
<h3 data-id="heading-7">1.6 销毁共享内存</h3>
<p>当不再传输数据后，也就是消费者收到 SHM_STATE_EOF 状态之后，可以通过 AIDL 通知生产者对共享内存进行销毁。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 销毁共享内存
 */</span>
extern "C"
JNIEXPORT void JNICALL
<span class="hljs-built_in">Java_com_yangle_ashmem_NativeShm_destroy</span>(JNIEnv*, jobject, jint fd) {
    if (g_block) {
        <span class="hljs-built_in">munmap</span>(g_block, sizeof(SharedBlock));
        g_block = nullptr;
    }
    <span class="hljs-built_in">close</span>(fd);
    <span class="hljs-built_in">LOGI</span>("destroy shm fd=%d", fd);
}
</code></pre>
<h2 data-id="heading-8">2.测试</h2>
<p>到这里共享内存传输的基本功能就完成了，写个例子来测试下，定义一个 ShmService（android:process=":shm" ） 进程作为数据发送方，MainActivity 作为数据接收方，先看下项目结构：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/485bc177eced42ae83d6b1fcad083c15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a655Y2O6LCi5ZCO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767230177&amp;x-signature=gw56ccUlRvjPWqVoKUIbaI5MR10%3D" alt="项目结构" loading="lazy"/></p>
<p>流程如下：</p>
<ul>
<li>
<p>1.MainActivity 与 ShmService 进行服务绑定，绑定成功后调用 AIDL 的 startTransfer 方法通知 ShmService 开始传输</p>
</li>
<li>
<p>2.ShmService 收到通知后开始创建共享内存，然后将 fd 通过 AIDL 的 onShmReady 回调方法传递给 MainActivity</p>
</li>
<li>
<p>3.ShmService 开始发送文件，MainActivity 开始读取文件</p>
</li>
<li>
<p>4.ShmService 发送文件完成后，通过共享内存信号量通知 MainActivity 结束</p>
</li>
<li>
<p>5.MainActivity 读取到 SHM_STATE_EOF 状态后，通过 AIDL 的 endTransfer 方法通知 ShmService</p>
</li>
<li>
<p>6.ShmService 收到结束通知后，销毁已创建的共享内存</p>
</li>
</ul>
<p><strong>MainActivity 如下：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> native = NativeShm()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> service: IShmService

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        bindService(Intent(<span class="hljs-keyword">this</span>, ShmService::<span class="hljs-keyword">class</span>.java), conn, BIND_AUTO_CREATE)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> conn = <span class="hljs-keyword">object</span> : ServiceConnection {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>, binder: <span class="hljs-type">IBinder</span>)</span></span> {
            service = IShmService.Stub.asInterface(binder)
            <span class="hljs-comment">// 通知服务端开始发送文件</span>
            service.startTransfer(<span class="hljs-keyword">object</span> : IShmCallback.Stub() {
                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onShmReady</span><span class="hljs-params">(pfd: <span class="hljs-type">ParcelFileDescriptor</span>)</span></span> {
                    startReceive(pfd.fd)
                }
            })
        }

        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>)</span></span> {}
    }

    <span class="hljs-comment">/**
     * 接收文件
     *
     * <span class="hljs-doctag">@param</span> fd 文件描述符
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startReceive</span><span class="hljs-params">(fd: <span class="hljs-type">Int</span>)</span></span> {
        Thread {
            <span class="hljs-keyword">val</span> <span class="hljs-keyword">out</span> = File(getExternalFilesDir(<span class="hljs-string">""</span>), <span class="hljs-string">"test.jpg"</span>)
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">out</span>.exists()) {
                <span class="hljs-keyword">out</span>.delete()
            }
            <span class="hljs-keyword">val</span> buf = ByteArray(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>)

            FileOutputStream(<span class="hljs-keyword">out</span>).use { fos -&gt;
                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                    <span class="hljs-keyword">val</span> len = native.read(fd, buf)
                    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) {
                        service.endTransfer()
                        <span class="hljs-keyword">break</span>
                    }
                    fos.write(buf, <span class="hljs-number">0</span>, len)
                }
            }
        }.start()
    }
}
</code></pre>
<p><strong>ShmService 如下：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShmService</span> : <span class="hljs-type">Service</span>() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> native = NativeShm()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> client: IShmService? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mFd: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(p0: <span class="hljs-type">Intent</span>?)</span></span>: IBinder? {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : IShmService.Stub() {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startTransfer</span><span class="hljs-params">(callback: <span class="hljs-type">IShmCallback</span>?)</span></span> {
                <span class="hljs-comment">// 创建共享内存</span>
                mFd = native.createShm()
                <span class="hljs-comment">// 将文件描述符回调给接收端</span>
                <span class="hljs-keyword">val</span> pfd = ParcelFileDescriptor.fromFd(mFd!!)
                callback?.onShmReady(pfd)
                <span class="hljs-comment">// 发送文件</span>
                sendFile(<span class="hljs-string">"test.jpg"</span>, mFd!!)
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">endTransfer</span><span class="hljs-params">()</span></span> {
                <span class="hljs-keyword">if</span> (mFd != <span class="hljs-literal">null</span>) {
                    native.destroy(mFd!!)
                }
            }
        }.also {
            client = it
        }
    }

    <span class="hljs-comment">/**
     * 发送文件
     *
     * <span class="hljs-doctag">@param</span> fileName 文件名
     * <span class="hljs-doctag">@param</span> fd       文件描述符
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendFile</span><span class="hljs-params">(fileName: <span class="hljs-type">String</span>, fd: <span class="hljs-type">Int</span>)</span></span> {
        Thread {
            <span class="hljs-keyword">val</span> buffer = ByteArray(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>)
            <span class="hljs-keyword">try</span> {
                assets.<span class="hljs-keyword">open</span>(fileName).use { input -&gt;
                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                        <span class="hljs-keyword">val</span> len = input.read(buffer)
                        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>
                        native.write(buffer, len)
                    }
                }
                native.sendEof()
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                e.printStackTrace()
            }
        }.start()
    }
}
</code></pre>
<p><strong>AIDL 如下：</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IShmService</span> {
    <span class="hljs-comment">/**
     * 开始传输
     *
     * @params callback 回调
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startTransfer</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> IShmCallback callback</span>)</span>;

    <span class="hljs-comment">/**
     * 结束传输
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endTransfer</span>()</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title">IShmCallback</span> {
   <span class="hljs-comment">/**
     * 共享内存初始化完成
     *
     * @params pfd 文件描述符
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onShmReady</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> ParcelFileDescriptor pfd</span>)</span>;
}
</code></pre>
<p><strong>注意在 onShmReady 方法中需要传递 ParcelFileDescriptor 类型，不能直接传递 int 类型的 fd，ParcelFileDescriptor 内部会自动实现 Binder 的自动映射。</strong></p>
<ul>
<li>
<p>Binder 会把 fd 复制到目标进程，目标进程拿到的 ParcelFileDescriptor 对象里有一个新的 fd。</p>
</li>
<li>
<p>系统会在底层做 fd 映射和引用计数，保证两个进程都可以安全访问同一个底层资源。</p>
</li>
<li>
<p>它不仅能封装 ashmem fd，也能封装普通文件、socket、pipe 等。</p>
</li>
</ul>
<h2 data-id="heading-9">3.PV操作</h2>
<p>在数据传输中使用PV信号量来控制生产者-消费者的读写操作，在这里再梳理下流程：</p>
<p><strong>写数据</strong></p>
<ul>
<li>
<p>1.sem_wait(sem_empty) — 等待缓冲区可写</p>
</li>
<li>
<p>2.sem_wait(sem_mutex) — 进入临界区</p>
</li>
<li>
<p>3.memcpy 数据到共享内存，设置 data_len、state = DATA</p>
</li>
<li>
<p>4.sem_post(sem_mutex) — 离开临界区</p>
</li>
<li>
<p>5.sem_post(sem_full) — 通知消费者有数据可读</p>
</li>
</ul>
<p><strong>读数据</strong></p>
<ul>
<li>
<p>6.sem_wait(sem_full) — 等待数据到达</p>
</li>
<li>
<p>7.sem_wait(sem_mutex) — 进入临界区，检查 state</p>
</li>
<li>
<p>8.若 state == EOF 则 sem_post(sem_mutex) 并 sem_post(sem_empty)，返回 EOF，否则拷贝数据到用户缓冲</p>
</li>
<li>
<p>9.sem_post(sem_mutex) — 离开临界区</p>
</li>
<li>
<p>10.sem_post(sem_empty) — 通知写数据端可以写下一个分片</p>
</li>
</ul>
<h2 data-id="heading-10">4.写在最后</h2>
<p>GitHub地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falidili%2FDemos%2Ftree%2Fmaster%2FAshmemDemo" target="_blank" title="https://github.com/alidili/Demos/tree/master/AshmemDemo" ref="nofollow noopener noreferrer">github.com/alidili/Dem…</a></p>
<p>到这里，Android消息推送SSE方案就介绍完了，如有问题可以给我留言评论或者在GitHub中提交Issues，谢谢！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 登录专题]]></title>    <link>https://juejin.cn/post/7587277503947014144</link>    <guid>https://juejin.cn/post/7587277503947014144</guid>    <pubDate>2025-12-25T01:37:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587277503947014144" data-draft-id="7585382553289932836" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 登录专题"/> <meta itemprop="keywords" content="Java,Spring Boot,后端"/> <meta itemprop="datePublished" content="2025-12-25T01:37:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哪里的破水瓶"/> <meta itemprop="url" content="https://juejin.cn/user/4394111849466414"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 登录专题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4394111849466414/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哪里的破水瓶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:37:57.000Z" title="Thu Dec 25 2025 01:37:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#444;background-image:linear-gradient(90deg,rgba(59,59,59,.1) 3%,transparent 0),linear-gradient(1turn,rgba(122,120,121,.1) 3%,transparent 0);background-size:30px 30px;background-position:50%;letter-spacing:1px;word-spacing:1px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:34px;margin-bottom:16px;font-weight:700;line-height:1.3;cursor:text;color:#444;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body h1{font-size:41px;margin-bottom:34px;line-height:1.5}.markdown-body h1:before{content:""}.markdown-body h2{font-size:30px;padding-left:.4em;border-left:.4em solid #5e5e5e;border-bottom:1px solid #444}.markdown-body h2:after{content:"🕛";position:absolute;top:0;right:0;transition:all;animation:rotate 10s linear infinite}@keyframes rotate{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.markdown-body h3{border-left:.4em solid #8d8d8d;font-size:24px;padding-left:.4em}.markdown-body h4{font-size:20px}.markdown-body h5{font-size:16px}.markdown-body h6{font-size:14px}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body table,.markdown-body ul{margin:.8em 0}.markdown-body strong{font-weight:1000;position:relative;color:#444;padding:0 3px}.markdown-body em{font-weight:inherit}.markdown-body a{box-sizing:border-box;color:grey;position:relative}.markdown-body a:before{position:absolute;box-sizing:border-box;content:"Go -&gt;";left:0;width:100%;max-width:0;color:#fff;background-color:hsla(0,0%,50.2%,.8);white-space:nowrap;transition:.2s ease;pointer-events:none;overflow:hidden}.markdown-body a:after{content:"";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:grey}.markdown-body a:active:before,.markdown-body a:hover:before{max-width:100%;padding-left:8px;border-radius:5px}.markdown-body hr{position:relative;width:100%;height:1px;border:none;margin-top:36px;margin-bottom:36px;background:linear-gradient(90deg,grey,#f1f1f1,#444,#444,#f1f1f1,grey);overflow:visible}.markdown-body ol,.markdown-body ul{padding-left:32px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px;list-style:inherit}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol{counter-reset:my-counter}.markdown-body ol&gt;li{padding-left:6px;list-style:none;counter-increment:my-counter;position:relative}.markdown-body ol&gt;li:before{position:absolute;left:-1.5em;content:counter(my-counter);font-weight:700}.markdown-body ol&gt;li:first-child:before{content:"1️⃣"}.markdown-body ol&gt;li:nth-child(2):before{content:"2️⃣"}.markdown-body ol&gt;li:nth-child(3):before{content:"3️⃣"}.markdown-body ol&gt;li:nth-child(4):before{content:"4️⃣"}.markdown-body ol&gt;li:nth-child(5):before{content:"5️⃣"}.markdown-body ol&gt;li:nth-child(6):before{content:"6️⃣"}.markdown-body ol&gt;li:nth-child(7):before{content:"7️⃣"}.markdown-body ol&gt;li:nth-child(8):before{content:"8️⃣"}.markdown-body ol&gt;li:nth-child(9):before{content:"9️⃣"}.markdown-body ol&gt;li:nth-child(10):before{content:"🔟"}.markdown-body ul&gt;li{list-style:none;position:relative}.markdown-body ul&gt;li:before{z-index:10;position:absolute;left:-1.57em;content:"🔹";margin-right:12px}.markdown-body ul&gt;li input{margin-left:8px!important}.markdown-body blockquote{position:relative;background-color:#d3d3d3;padding:5px 10px;border-left:.2em solid #000;border-radius:3px;transition:all .8s ease}.markdown-body blockquote:hover{opacity:.7}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(69,69,77,.8);color:#fff;font-size:.87em;padding:.07em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:7px;overflow:hidden}.markdown-body pre:before{z-index:10;position:absolute;top:14px;left:14px;width:12px;height:12px;border-radius:50%;background:#fc625d;-webkit-box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;content:" "}.markdown-body pre:after{z-index:9;content:"";position:absolute;width:100%;height:40px;top:0;background-color:#1a1a1a}.markdown-body pre&gt;code{display:block;font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#171717;color:#bababa;font-size:14px;padding:40px 20px 20px}.markdown-body del{color:grey}.markdown-body table{margin-bottom:1.25rem;border-collapse:collapse}.markdown-body table td,.markdown-body table th{margin:0;padding:8px;line-height:20px;vertical-align:middle;border:1px solid #ddd}.markdown-body table thead,.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table thead th,.markdown-body table tr:nth-child(2n) th{font-weight:700;vertical-align:middle;color:#444}.markdown-body table tbody tr td{font-weight:400;color:#444}.markdown-body table tbody tr:hover{background-color:#d3d3d3}.markdown-body table tbody tr:hover td{color:#fff}.markdown-body img{max-width:100%;margin:0 12px}@media (max-width:720px){.markdown-body h1{font-size:32.8px}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:19.2px}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:12.8px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">Cookie</h2>
<p>核心背景：HTTP 是无状态的</p>
<p>服务器默认不记得你是谁</p>
<ul>
<li>请求1 —— 完了就忘</li>
<li>请求2 —— 当新请求</li>
</ul>
<blockquote>
<p>在客户端保存状态标识，解决 HTTP 无状态问题</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@GetMapping("/hello")</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(HttpServletResponse response)</span> {
    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">"name"</span>, <span class="hljs-string">"value"</span>);
    <span class="hljs-comment">// 20秒后过期</span>
    cookie.setMaxAge(<span class="hljs-number">20</span>);
    response.addCookie(cookie);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
}

<span class="hljs-meta">@GetMapping("/user")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">user</span><span class="hljs-params">(HttpServletRequest request)</span> {
    Cookie[] cookies = request.getCookies();
    <span class="hljs-keyword">for</span> (Cookie cookie : cookies) {
        <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">"name"</span>)) {
            System.out.println(cookie.getName() + <span class="hljs-string">":"</span> + cookie.getValue());
        }
    }
}
</code></pre>
<blockquote>
<p>后端设置 cookie 时</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/965ecd33e1fc4443be12c98857005055~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=gqntX4QQQ5rhkFItcDkspEV4atE%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>前端发起请求携带 cookie 时</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c9f1ea3945a4d7bb7d2c57bc303fc0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=XXOqNh5B%2FKaAdP9ul4nTenXt%2FhI%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>cookie 管理界面</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cddd1732dccc409abc0d01ffe907292e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=NtyhaVEjIczCxU95ODkRAd3Smnk%3D" alt="image.png" loading="lazy"/></p>
<p><strong>优缺点</strong></p>
<p>优点：HTTP协议中支持的技术</p>
<p>缺点：</p>
<ul>
<li>移动端APP无法使用Cookie</li>
<li>不安全，用户可以自己禁用Cookie</li>
<li>Cookie不能跨域</li>
</ul>
<h2 data-id="heading-1">Session</h2>
<p>HttpSession 是服务器端保存用户会话状态的对象</p>
<p>核心特点：</p>
<ul>
<li>存在服务器内存（或 Redis）</li>
<li>以 SessionId 为索引</li>
<li>解决 HTTP 无状态问题</li>
</ul>
<blockquote>
<p>Session 是怎么连续的？（核心原理）</p>
</blockquote>
<p>第一次访问之后，会产生一个Cookie，往后访问都会带着它</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e9aa15fc4594aaa8d927e868e43bc26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=Og0AtRsXXuk%2Fa8%2FOKWcm%2FjP9UFg%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 存值</span>
<span class="hljs-meta">@GetMapping("/hello")</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(HttpSession session)</span> {
    log.info(<span class="hljs-string">"HttpSession-s1：{}"</span>, session.hashCode());
    session.setAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"hello"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
}

    <span class="hljs-comment">// 获取值</span>
<span class="hljs-meta">@GetMapping("/user")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">user</span><span class="hljs-params">(HttpSession session)</span> {
    log.info(<span class="hljs-string">"HttpSession-s2：{}"</span>, session.hashCode());
    <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">"name"</span>);
    log.info(<span class="hljs-string">"name: {}"</span>, name);
}
</code></pre>
<blockquote>
<p>缺点，分布式集群下无法使用 Session<br/>
优点：数据存放到服务端</p>
</blockquote>
<h2 data-id="heading-2">令牌JWT</h2>
<p>令牌会话跟踪方案的优缺点 ?</p>
<p>优点：</p>
<ul>
<li>支持PC端、移动端</li>
<li>解决集群环境下的认证问题</li>
<li>减轻服务器端存储压力</li>
</ul>
<p>缺点：需要自己实现</p>
<blockquote>
<p>全称：JSON Web Token （<a href="https://link.juejin.cn?target=https%3A%2F%2Fjwt.io%2F%25EF%25BC%2589" target="_blank" title="https://jwt.io/%EF%BC%89" ref="nofollow noopener noreferrer">jwt.io/）</a></p>
</blockquote>
<p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。
组成：</p>
<ul>
<li>第一部分：Header(头），记录令牌类型、签名算法等。 例如：{"alg":"HS256","type":"JWT"}</li>
<li>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{"id":"1","username":"Tom"}</li>
<li>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload融入，并加入指定密钥，通过指定签名算法计算而来。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1637e190202d440f94dfbd84ac8366d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=HWXDKvsDv3v%2FO6yApV0X%2Bqm746U%3D" alt="image.png" loading="lazy"/></p>
<p>Base64：是一种基于64个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式。</p>
<p>引入 maven</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.12.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-java" lang="java">HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
map.put(<span class="hljs-string">"id"</span>, <span class="hljs-number">1</span>);
map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"admin"</span>);

<span class="hljs-comment">// 字符串中应该，base64机密的，加密内容必须足够长</span>
<span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder().signWith(SignatureAlgorithm.HS256,
                <span class="hljs-string">"abcdefghijklmn"</span>)
        <span class="hljs-comment">// 自定义数据</span>
        .addClaims(map)
        <span class="hljs-comment">// 过期时间, 单位毫秒 + 1小时</span>
        .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>))
        .compact();

<span class="hljs-keyword">return</span> jwt;
</code></pre>
<p>打印 JWT，用三个 . 分出来三个部分</p>
<p>eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiYWRtaW4iLCJpZCI6MSwiZXhwIjoxNzY2MjI3Njk5fQ.ZBiknENQ1NoKxv4myhVF2uS-toijk90uXz9O70Mhg9s</p>
<ol>
<li>第一个部分，base64 解密是：{"alg":"HS256"}</li>
<li>第二部分，就是我们存入的对象</li>
<li>第三部分，就是加密字符串</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59168c7f62104d4f8d78453232e375be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=St2jEaThql6wUKwK1Q06NVJPcn4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/874484cedb7144a6af893612b26c144f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=mRPr1z2jBnH1HJvs96q%2FjGHX8Kg%3D" alt="image.png" loading="lazy"/></p>
<p><strong>令牌生成</strong></p>
<pre><code class="hljs language-java" lang="java">HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    map.put(<span class="hljs-string">"id"</span>, <span class="hljs-number">1</span>);
    map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"admin"</span>);

    <span class="hljs-comment">// 字符串中应该，base64加密的，加密内容必须足够长</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder().signWith(SignatureAlgorithm.HS256,
                    <span class="hljs-string">"abcdefghijklmn"</span>)
            <span class="hljs-comment">// 自定义数据</span>
            .addClaims(map)
            <span class="hljs-comment">// 过期时间, 单位毫秒 + 1小时</span>
            .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>))
            .compact();
</code></pre>
<p><strong>令牌解析</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-string">"eyJhbGciOiJIUzI1NiJ9..."</span>;
<span class="hljs-comment">// claims 实际就是 map</span>
<span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.parser().setSigningKey(<span class="hljs-string">"abcdefghijklmn"</span>)
        .parseClaimsJws(token).getBody();
</code></pre>
<h2 data-id="heading-3">过滤器</h2>
<p>多个过滤器是按照姓名</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 开启SpringBoot 对 Servlet 组件的扫描</span>
<span class="hljs-meta">@ServletComponentScan</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        SpringApplication.run(DemoApplication.class, args);
    }

}
</code></pre>
<p>配置过滤器</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@WebFilter(urlPatterns = "/*")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> {

    <span class="hljs-comment">// Web 服务器启动时调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException {
        Filter.<span class="hljs-built_in">super</span>.init(filterConfig);
    }

    <span class="hljs-comment">// 拦截请求</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException {

        <span class="hljs-comment">// 放行，不写就会被拦截</span>
        chain.doFilter(request, response);

    }

    <span class="hljs-comment">// Web 服务器关闭时调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        Filter.<span class="hljs-built_in">super</span>.destroy();
    }
}

</code></pre>
<h2 data-id="heading-4">拦截器</h2>
<blockquote>
<p>配置</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> {
        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoInterceptor</span>())
                <span class="hljs-comment">// 拦截所有请求</span>
                .addPathPatterns(<span class="hljs-string">"/**"</span>)
                <span class="hljs-comment">// 不拦截的请求</span>
                .excludePathPatterns(<span class="hljs-string">"/login"</span>);
    }
}
</code></pre>
<blockquote>
<p>拦截器</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception {
        System.out.println(<span class="hljs-string">"在请求之前到，true 返回，false 返回"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception {
        System.out.println(<span class="hljs-string">"目标运行之后运行"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception {
        System.out.println(<span class="hljs-string">"请求彻底结束"</span>);
    }
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5da61f720b464e0c8d4257072bd04439~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231477&amp;x-signature=DhNGSpTU7n8hqliMqkg%2FhUUsShI%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入剖析arthas技术原理]]></title>    <link>https://juejin.cn/post/7587335187072368666</link>    <guid>https://juejin.cn/post/7587335187072368666</guid>    <pubDate>2025-12-25T01:37:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587335187072368666" data-draft-id="7587263750249463859" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 深入剖析arthas技术原理"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-25T01:37:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="shark_chili"/> <meta itemprop="url" content="https://juejin.cn/user/2858385964801672"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             深入剖析arthas技术原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2858385964801672/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    shark_chili
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:37:44.000Z" title="Thu Dec 25 2025 01:37:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读31分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">写在文章开头</h2>
<p>笔者一直强调，计算机是一门理性的学科，一切都是需要可量化和落地的，而本文的arthas是一款强大的监控诊断工具，了解其设计理念和工作机制，可以辅助我们更好的使用这款工具。而本文将从<code>jdk8</code>版本兼容的旧有版本，即arhtas 3.6.0的源码角度出发，来深入分析和学习<code>arthas</code>出色的设计理念，希望对你日常使用有所帮助。</p>
<p>你好，我是 <strong>SharkChili</strong> ，禅与计算机程序设计艺术布道者，希望我的理念对您有所启发。</p>
<p><strong>📝 我的公众号：写代码的SharkChili</strong><br/>
在这里，我会分享技术干货、编程思考与开源项目实践。</p>
<p><strong>🚀 我的开源项目：mini-redis</strong><br/>
一个用于教学理解的 Redis 精简实现，欢迎 Star &amp; Contribute：<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fshark-ctrl%2Fmini-redis" target="_blank" title="https://github.com/shark-ctrl/mini-redis" ref="nofollow noopener noreferrer">github.com/shark-ctrl/…</a></p>
<p><strong>👥 欢迎加入读者群</strong><br/>
关注公众号，回复 <strong>【加群】</strong> 即可获取联系方式，期待与你交流技术、共同成长！</p>
<h2 data-id="heading-1">前置知识铺垫</h2>
<h2 data-id="heading-2">环境说明</h2>
<p>考虑到大部分读者使用的jdk版本为jdk8，所以笔者选择artahs 3.6.0的源码来展开演示本文的所有内容，无论是macOS还是Windows用户，请严格遵循如下几个环境说明：</p>
<ol>
<li>克隆或者下载arhtas-3.6.0版本：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas%2Ftree%2Farthas-all-3.6.0" target="_blank" title="https://github.com/alibaba/arthas/tree/arthas-all-3.6.0" ref="nofollow noopener noreferrer">github.com/alibaba/art…</a></li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8671fc78391a499a80a4c2d62768a043~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=IuFO90htsMT9QizgRD0n9uPzSTA%3D" alt="" loading="lazy"/></p>
<ol start="2">
<li>调试时，程序会从本地拉取arthas-core和agent文件，请读者提前完成arhtas-3.6.0 zip包的下载：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a203e29a0ba4a429fc2d58202183f0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=gYwcz36iDgOPVdG25olXJyyYhgU%3D" alt="" loading="lazy"/></p>
<p>并解压到默认读取路径，以mac os为例则是：</p>
<pre><code class="hljs language-bash" lang="bash">/Users/用户名/.arthas/lib/3.6.0/arthas/arthas-agent.jar和 arthas-core.jar
</code></pre>
<p>对应Windows用户则是：</p>
<pre><code class="hljs language-bash" lang="bash">C:/Users/用户名/.arthas/lib/3.6.0/arthas/arthas-agent.jar和 arthas-core.jar
</code></pre>
<h3 data-id="heading-3">jvm如何工作的</h3>
<p>在此之前，我们还是需要了解一下<code>java</code>程序的执行过程，方便对后文的理解，按照周志明老师《深入理解jvm虚拟机》说法，对应<code>java</code>程序分为前端编译和后端编译，这里前端编译我们可以理解为程序运行前的操作，该阶段会将写好的<code>java</code>代码通过<code>javac</code>编译器编译为虚拟机所能理解的字节码。</p>
<p>基于上述的处理构建成字节码也就是程序语言的中间表示形式，我们键入<code>java</code>指令启动程序，此时就会通过<code>C++</code>启动一个虚拟机实例处理上述字节码，也就是将字节码转为本地基础设施也就是操作系统所能识别的指令集并运行，这也就是后端编译，即： 解释器不断解释生成操作系统可理解的机器码运行 对于一些热点代码，虚拟机<code>JIT</code>会将其优化并编译为机器码缓存，后续则以机器码版本运行。基于上述步骤虚拟机以方法作为基本单元，即以栈帧来支持方法的调用和这些指令方法对应的数据结构的执行：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6558729ede604d0d89521882f23cb8cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=aJID9fs5aBDBRJuOz7R9E4k9b2Q%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">arhtas增强工作机制</h3>
<p>因为java是一门半截式半编译的语言，所以在运行时就有了很大的可操作空间，例如我们日常的<code>web</code>接口有大量的业务查询逻辑，就像下面这段代码：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-title class_">JSON</span><span class="hljs-built_in">Object</span> <span class="hljs-title function_">findById</span>(<span class="hljs-params">long id</span>) {
        <span class="hljs-comment">//模拟查询和返回用户数据</span>
        <span class="hljs-title class_">ThreadUtil</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-title class_">RandomUtil</span>.<span class="hljs-title function_">randomInt</span>(<span class="hljs-number">200</span>));
        <span class="hljs-title class_">JSON</span><span class="hljs-built_in">Object</span> jsonObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSON</span><span class="hljs-built_in">Object</span>().<span class="hljs-title function_">putOnce</span>(<span class="hljs-string">"id"</span>, id).<span class="hljs-title function_">putOnce</span>(<span class="hljs-string">"name"</span>, <span class="hljs-string">"张三"</span>);
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"查询结果:"</span>+jsonObject);
        <span class="hljs-keyword">return</span> jsonObject;
    }
}
</code></pre>
<p>此时我们为了统一打印输出接口耗时，强行在既有代码中进行各种硬编码不仅非常繁琐，还会让研发人员过分侵入到一些非业务工作以外的事情，影响编码的效率。</p>
<p>所以设计者基于java程序运行的特性在<code>jdk5</code>中引入了一种字节码增强的技术，其底层依赖于JVMTI也就是JVM Tool interface，它是JVM暴露出来来用户扩展的接口集合，基于这些接口编写我们就可以拓展开发属于自己的增强逻辑：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/19d6c48e9738449c933bf867da471121~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=xGQuBMMLCxRkQDgdnUkPOVq1xfc%3D" alt="" loading="lazy"/></p>
<p>该技术范围启动前增强和启动时增强，启动前增强顾名思义则是<code>JVM</code>启动时针对字节码做的增强操作，对应我们可以通过实现如下方法，基于入参<code>instrumentation</code>编写增强逻辑，例如<code>arthas-agent</code>的<code>AgentBootstrap</code>就基于该函数实现了启动前增强逻辑：</p>
<pre><code class="hljs language-typescript" lang="typescript"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">premain</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> args, Instrumentation inst</span>) {
        <span class="hljs-title function_">main</span>(args, inst);<span class="hljs-comment">//字节码增强逻辑</span>
    }
</code></pre>
<p>然后在打jar包时，通过<code>Premain-Class</code>指定入口类即可：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">&lt;Premain-<span class="hljs-keyword">Class</span>&gt;com.taobao.arthas.agent334.AgentBootstrap&lt;/Premain-<span class="hljs-keyword">Class</span>&gt;
</code></pre>
<p>对应我们也给出运行流程图，如下图，我们通过-jar 参数将打包好的jar包attach到目标虚拟机，在启动前通过<code>addTransformer</code>将字节码转换器添加到目标<code>JVM</code>拦截所有类实现定制化字节码增强。</p>
<p>此时，对应JVM进行类加载时，就会通过<code>ClassFileTransformer</code>完成字节码修改实现运行前增强，这种做法最典型的运用场景便是日常的idea破解即通过<code>-javaagent:/xxxx.jar=param</code>指定<code>jar</code>包完成运行前增强修改加密文件和证书：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d09fc10097774746ba367584c421f2af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=hoQKZj5IH8IADelBb5sVMRA2MCs%3D" alt="" loading="lazy"/></p>
<p>而另外一种则是运行时增强，最典型的运用就是<code>artahs</code>，运行时增强的实现则是通过实现<code>agentmain</code>函数，对应我们也可以在arthas-agent看到这个函数的实现：</p>
<pre><code class="hljs language-typescript" lang="typescript"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">agentmain</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> args, Instrumentation inst</span>) {
         <span class="hljs-title function_">main</span>(args, inst);
    }
</code></pre>
<p>在<code>agentmain</code>完成增强逻辑后，针对打包的jar通过Agent-Class指定入口类：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"> &lt;Agent-<span class="hljs-keyword">Class</span>&gt;com.taobao.arthas.agent334.AgentBootstrap&lt;/Agent-<span class="hljs-keyword">Class</span>&gt;
</code></pre>
<p>对应其工作流程如下图，通过VirtualMachine遍历定位到目标进程后，将agent attach到目标进程，执行agentmain完成jvm实例增强：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97b4bdee24114266a4e816dc3459bdc7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=z3dGr9TghnkQ%2B%2FACWLmsRajUbvY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">arthas对于字节码增强的应用</h3>
<p>arthas就是利用运行时增强的典型运用，其本质上就是在运行时通过attach到目标虚拟机，针对匹配的类进行通过高效简洁字节码工具<code>bytekit</code>完成字节码增强，而这也就是arthas的monitor、stack、trace等命令实现的本质。</p>
<p>对此笔者也给出一个简单的<code>bytekit</code>示例，我们还是以上面的<code>UserService</code>为例，我们希望针对这个类进行耗时打印同时耗时的逻辑不侵入到业务代码中，对此我们就可以用到阿里的bytekit这款简单易上手的字节码增强工具完成接口耗时打印的字节码增强。</p>
<p>首先我们引入相关的依赖，对应依赖和版本如下</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>bytekit-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.benf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cfr<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.152<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>


        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.bytebuddy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>byte-buddy-agent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.14.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>然后我们就可以落地下面这样一段代码，即基于<code>bytekit</code>注解声明方法执行前后的增强逻辑，以笔者本次的案例为例，本质就是：</p>
<ol>
<li>通过<code>atEnter</code>注解声明拦截逻辑执行前的逻辑，即记录开始时间，并通过inline指明逻辑直接放在方法内部，这种做法的好处是在于jit进行逃逸分析时可以做一些类似于方法内联等优化执行效率的逻辑</li>
<li><code>atEit</code>声明方法执行的后置逻辑，即打印输出耗时</li>
</ol>
<p>对应的拦截器的逻辑如下：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleInterceptor</span>  {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> start;

    @AtEnter(inline = <span class="hljs-literal">true</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atEnter</span>()</span> {
        <span class="hljs-comment">//记录开始时间</span>
        start = System.currentTimeMillis();
    }

    @AtExit(inline = <span class="hljs-literal">true</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atEit</span>()</span> {
        <span class="hljs-comment">//输出打印被增强的方法总耗时</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"cost:"</span> + (System.currentTimeMillis() - start));
    }
}
</code></pre>
<p>随后我们再给出对应的增强逻辑，核心代码如下：</p>
<ol>
<li>解析上述<code>SampleInterceptor</code>注解</li>
<li>获取<code>UserService</code>字节码</li>
<li>定位到<code>findById</code>，通过解析后得到的<code>processors</code>对该字节码进行增强</li>
<li>打印字节码和增强后的逻辑</li>
</ol>

<pre><code class="hljs language-ini" lang="ini">public static void main(String<span class="hljs-section">[]</span> args) throws Exception {
        // 解析定义的 Interceptor类 和相关的注解
        DefaultInterceptorClassParser <span class="hljs-attr">interceptorClassParser</span> = new DefaultInterceptorClassParser()<span class="hljs-comment">;</span>
        List&lt;InterceptorProcessor&gt; <span class="hljs-attr">processors</span> = interceptorClassParser.parse(SampleInterceptor.class)<span class="hljs-comment">;</span>
        // 加载字节码
        ClassNode <span class="hljs-attr">classNode</span> = AsmUtils.loadClass(UserService.class)<span class="hljs-comment">;</span>
        // 对加载到的字节码做增强处理
        for (MethodNode methodNode : classNode.methods) {
            if (!methodNode.name.equals("findById")) continue<span class="hljs-comment">;</span>

            MethodProcessor <span class="hljs-attr">methodProcessor</span> = new MethodProcessor(classNode, methodNode)<span class="hljs-comment">;</span>
            for (InterceptorProcessor interceptor : processors) {
                interceptor.process(methodProcessor)<span class="hljs-comment">;</span>
            }
        }
        // 获取增强后的字节码
        byte<span class="hljs-section">[]</span> <span class="hljs-attr">bytes</span> = AsmUtils.toBytes(classNode)<span class="hljs-comment">;</span>

        // 查看反编译结果
        System.out.println(Decompiler.decompile(bytes))<span class="hljs-comment">;</span>
        AgentUtils.reTransform(UserService.class, bytes)<span class="hljs-comment">;</span>

        UserService <span class="hljs-attr">sample</span> = new UserService()<span class="hljs-comment">;</span>
        sample.findById(1)<span class="hljs-comment">;</span>


    }
</code></pre>
<p>对应的增强后的字节码和耗时增强逻辑结果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5205314f84ae4c6abed7a0917c4e9f79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=mf%2BCxS%2BeJu9Ufgl85s%2BOs%2FFTK5c%3D" alt="" loading="lazy"/></p>
<p>为了更好的理解arthas的设计理念和逻辑，笔者也基于上述的demo示例进行设计和封装一个字节码增强工具类Enhancer。辅助我们更好的理解arhtas复杂的源码设计和实现，可以看到通过<code>ByteKit</code>本质上就是要求我们基于注解和方法给出需要声明的逻辑，然后AsmUtils会加载目标类的字节码修改目标方法的逻辑。</p>
<p>所以我们的<code>Enhancer</code>对于参数的封装要做到如下几点：</p>
<ol>
<li>明确要求用户传入需要增强的类类型</li>
<li>通过抽象类做好注解声明并规范用户要实现的方法</li>
<li>明确给出set集合让用户指明需要增强的方法</li>
</ol>
<p>有了上述的参数，我们的增强工具类就可以做到：</p>
<ol>
<li>通过传入的累加器的类类型解析得出拦截处理器</li>
<li>加载目标字节码文件</li>
<li>通过<code>set</code>过滤出需要增强的目标方法</li>
<li>修改目标方法的字节码</li>
<li>返回字节码文件</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eee780129f8e4416aa0f27b4c5131ec6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=JyuREt%2F3HJmhTdq%2BJZy0sOiWWs0%3D" alt="" loading="lazy"/></p>
<p>所以基于这个思路我们封装出了拦截器的抽象类，告知用户可灵活继承实现的扩展点：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">/**
 * 规范性约束
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractInterceptor</span> {
    <span class="hljs-comment">/**
     * 函数入口增强点
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atEnter</span>()</span> {
        <span class="hljs-comment">//nothing to do</span>
    }

    <span class="hljs-comment">/**
     * 函数退出扩展点
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atExit</span>()</span> {
        <span class="hljs-comment">//nothing to do</span>
    }
}
</code></pre>
<p>对应的我们的sample继承关系就变为这样：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleInterceptor</span> <span class="hljs-title">extends</span> <span class="hljs-title">AbstractInterceptor</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> start;

    @AtEnter(inline = <span class="hljs-literal">true</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atEnter</span>()</span> {
        <span class="hljs-comment">//记录开始时间</span>
        start = System.currentTimeMillis();
    }

    @AtExit(inline = <span class="hljs-literal">true</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atEit</span>()</span> {
        <span class="hljs-comment">//输出打印被增强的方法总耗时</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"cost:"</span> + (System.currentTimeMillis() - start));
    }
}
</code></pre>
<p>在此基础上我们封装一个字节码增强的工具类，即：</p>
<ol>
<li>通过<code>interceptorClzz</code>生成处理器<code>processorList</code></li>
<li>通过<code>AsmUtils</code>加载目标类的字节码</li>
<li>通过<code>matcherMethod</code>匹配目标方法，并通过<code>processorList</code>修改字节码完成增强</li>
</ol>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 字节码增强工具类
 */</span>
public class Enhancer {
    public byte<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">enhance</span>(Class target,
                          Set&lt;String&gt; matcherMethod,
                          Class&lt;? extends AbstractInterceptor&gt; clzz) throws Exception {
        <span class="hljs-comment">// 解析定义的 Interceptor类 和相关的注解</span>
        DefaultInterceptorClassParser interceptorClassParser = new <span class="hljs-built_in">DefaultInterceptorClassParser</span>();
        List&lt;InterceptorProcessor&gt; processorList = interceptorClassParser<span class="hljs-selector-class">.parse</span>(clzz);
        <span class="hljs-comment">// 加载需要增强的类的字节码</span>
        ClassNode classNode = AsmUtils<span class="hljs-selector-class">.loadClass</span>(target);
        <span class="hljs-comment">// 对加载到的字节码做增强处理</span>
        for (MethodNode methodNode : classNode.methods) {
            <span class="hljs-comment">//判断是否是匹配的方法,如果不是不做增强</span>
            if (!matcherMethod.contains(methodNode.name)) {
                continue;
            }
            <span class="hljs-comment">//基于解析后的processorList对目标进行增强</span>
            MethodProcessor methodProcessor = new <span class="hljs-built_in">MethodProcessor</span>(classNode, methodNode);
            for (InterceptorProcessor interceptor : processorList) {
                interceptor<span class="hljs-selector-class">.process</span>(methodProcessor);
            }
        }
        <span class="hljs-comment">// 获取增强后的字节码</span>
        byte<span class="hljs-selector-attr">[]</span> bytes = AsmUtils<span class="hljs-selector-class">.toBytes</span>(classNode);

        return bytes;
    }

    
}
</code></pre>
<p>最后我们再给出使用示例：</p>
<pre><code class="hljs language-arduino" lang="arduino"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception </span>{
        Enhancer enhance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Enhancer</span>();
        <span class="hljs-type">byte</span>[] bytes = enhance.<span class="hljs-built_in">enhance</span>(UserService.<span class="hljs-keyword">class</span>,
                CollUtil.<span class="hljs-built_in">newHashSet</span>(<span class="hljs-string">"findById"</span>),
                SampleInterceptor.<span class="hljs-keyword">class</span>);

        <span class="hljs-comment">// 查看反编译结果</span>
        System.out.<span class="hljs-built_in">println</span>(Decompiler.<span class="hljs-built_in">decompile</span>(bytes));
        AgentUtils.<span class="hljs-built_in">reTransform</span>(UserService.<span class="hljs-keyword">class</span>, bytes);
        <span class="hljs-comment">//测试修改后的结果是否打印输出耗时</span>
        UserService userService = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserService</span>();
        userService.<span class="hljs-built_in">findById</span>(<span class="hljs-number">1</span>);
    }
</code></pre>
<p>同时我们也给出对应的输出结果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b64b8e1923b149298fd3758383780b2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=FFLfq4KFu2uUhAinpHjIbQF1xI0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">详解arthas工作全流程</h2>
<h3 data-id="heading-7">arthas boot启动</h3>
<h4 data-id="heading-8">宏观流程说明</h4>
<p>通过上述的铺垫，我们已经对<code>arthas</code>运用的核心技术有了初步的了解，接下来笔者将从源码的江都深入分析这一点，首先我们需要从<code>arthas-boot</code>这个程序说起，本质上当我们执行<code>as.sh</code>后，执行脚本就是启动一个<code>arthas-boot</code>进程，对应的执行核心流程为：</p>
<ol>
<li>解析用户参数</li>
<li>获取非<code>arthas</code>进程以外的程序，并生成列表在控制台输出</li>
<li>等待用户输入需要指定进程序号</li>
<li>将目标进程号、<code>arhtas-core</code>和<code>arthas-agent</code>路径作为参数，启动<code>arthas-core.jar</code>让其完成后续工作</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c43d06b54db1446b8098a595b7483dbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=zmUnwakg8gpxGnnkT5IliLV49YA%3D" alt="" loading="lazy"/></p>
<p>如下图，笔者传入<code>--telnet-port 9999</code>启动<code>arthas-boot</code>，<code>arhtas-boot</code>启动时就会解析参数，然后通过执行jps指令获取非本进程的程序pid，然后生成列表，等待用户选择：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9d67d41bb674f2f804e76a5ce7bef52~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=mz2nPZZJzlD215ij9C8gvU%2Fz4U8%3D" alt="" loading="lazy"/></p>
<p>最后将pid号和arhtas-core和arthas一并作为参数启动arthas-core，就像下面这样：</p>
<pre><code class="hljs language-bash" lang="bash">java -jar /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-core.jar  -pid  61223  -telnet-port 9999, -core /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-core.jar  -agent  /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-agent.jar 
</code></pre>
<h4 data-id="heading-9">参数解析</h4>
<p>对应的笔者也给出对应源码来印证这一点，上述的主流程都位于<code>arthas-boot</code>的<code>Bootstrap</code>的<code>main</code>方法，因为逻辑比较长所以笔者这里逐步拆解分析，首先是参数解析，例如笔者上述传入的telnet参数就会在这里完成解析并绑定到<code>bootstrap</code>：</p>
<pre><code class="hljs language-swift" lang="swift">  <span class="hljs-type">CLI</span> cli <span class="hljs-operator">=</span> <span class="hljs-type">CLIConfigurator</span>.define(<span class="hljs-type">Bootstrap</span>.class);
        <span class="hljs-comment">//--telnet-port 9999</span>
        <span class="hljs-type">CommandLine</span> commandLine <span class="hljs-operator">=</span> cli.parse(<span class="hljs-type">Arrays</span>.asList(args));

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//将参数绑定到bootstrap 此时bootstrap属性就会添加配置的参数值</span>
            <span class="hljs-type">CLIConfigurator</span>.inject(commandLine, bootstrap);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> e) {
            <span class="hljs-comment">//......</span>
        }
</code></pre>
<h4 data-id="heading-10">获取目标进程</h4>
<p>然后就是查看用户启动参数中是否指明了pid，若没有则调用<code>ProcessUtils</code>的<code>select</code>通过jps指令生成进程列表让用户选择：</p>
<pre><code class="hljs language-scss" lang="scss">  <span class="hljs-comment">//查看参数是否指明了pid,若没有</span>
        long pid = bootstrap<span class="hljs-selector-class">.getPid</span>();
        <span class="hljs-comment">// 若没有指明pid,则调用select输出所有进程让用户选择</span>
        if (pid &lt; <span class="hljs-number">0</span>) {
            try {
              <span class="hljs-comment">//调用jps生成进程列表等待用户选择</span>
                pid = ProcessUtils<span class="hljs-selector-class">.select</span>(bootstrap.isVerbose(), telnetPortPid, bootstrap<span class="hljs-selector-class">.getSelect</span>());
            } catch (InputMismatchException e) {
               <span class="hljs-comment">//......</span>
            }
           <span class="hljs-comment">//......</span>
        }
</code></pre>
<p>对应的笔者也给出<code>ProcessUtils</code>的<code>select</code>的具体实现展开说明：</p>
<ol>
<li>通过jps获取非本进程以外的java进程</li>
<li>生成pid为key，进程pid+启动类的字符串value作为值如<code>57844 org.jetbrains.jps.cmdline.Launcher</code>的map集合</li>
<li>按顺序将其输出</li>
<li>利用Scanner工具类等待用户终端输入序号</li>
<li>返回对应pid，执行后续步骤：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5f2165286fa4bffa006f49cab332a93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=zA76Ama8UZibMj0C7mtk%2B5NnnJo%3D" alt="" loading="lazy"/></p>
<p>对应源码如下，大体逻辑和上述说明一致即通过jps获取所有进程，并生成map映射按序输出，随后基于用户选择结果返回指定pid号：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">boolean</span> v, <span class="hljs-type">long</span> telnetPortPid, <span class="hljs-type">String</span> select)</span> throws InputMismatchException </span>{
        <span class="hljs-comment">//执行jps指令生成pid为key 进程详情的value的map</span>
        Map&lt;Long, <span class="hljs-type">String</span>&gt; processMap = <span class="hljs-built_in">listProcessByJps</span>(v); 
        <span class="hljs-comment">//......</span>
        <span class="hljs-comment">// 将进程按序打印,从1开始,方便用户直观选择进程</span>
        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> process : processMap.<span class="hljs-built_in">values</span>()) {
            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {
                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"* ["</span> + count + <span class="hljs-string">"]: "</span> + process);
            } <span class="hljs-keyword">else</span> {
                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"  ["</span> + count + <span class="hljs-string">"]: "</span> + process);
            }
            count++;
        }

        <span class="hljs-comment">// 等待用户选择</span>
        <span class="hljs-type">String</span> line = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in).<span class="hljs-built_in">nextLine</span>();
        <span class="hljs-keyword">if</span> (line.<span class="hljs-built_in">trim</span>().<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-comment">// get the first process id</span>
            <span class="hljs-keyword">return</span> processMap.<span class="hljs-built_in">keySet</span>().<span class="hljs-built_in">iterator</span>().<span class="hljs-built_in">next</span>();
        }

        <span class="hljs-type">int</span> choice = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(line).<span class="hljs-built_in">nextInt</span>();

        <span class="hljs-comment">//......</span>
        <span class="hljs-comment">//通过数字定位到具体pid号返回</span>
        Iterator&lt;Long&gt; idIter = processMap.<span class="hljs-built_in">keySet</span>().<span class="hljs-built_in">iterator</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= choice; ++i) {
            <span class="hljs-keyword">if</span> (i == choice) {
                <span class="hljs-keyword">return</span> idIter.<span class="hljs-built_in">next</span>();
            }
            idIter.<span class="hljs-built_in">next</span>();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
</code></pre>
<h4 data-id="heading-11">整合参数启动arthas-core</h4>
<p>有了上述解析的参数和pid进程号，<code>arthas-boot</code>就会基于这些信息启动<code>arthas-core</code>，让其完成后续的核心工作(工作内容笔者后文会展开说明)，这里我们先看看<code>artahs-core</code>的最重要的一步<code>arthas-core</code>启动的实现，从源码可以看到其内部会通过<code>attachArgs</code>顺序拼接各种参数，然后生成类似于如下的启动指令启动core：</p>
<pre><code class="hljs language-bash" lang="bash">java -jar /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-core.jar  -pid  61223  -telnet-port 9999, -core /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-core.jar  -agent  /Users/sharkchili/.arthas/lib/4.1.3/arthas/arthas-agent.jar
</code></pre>
<p>对应逻辑比较简单，就是拼接和解析参数生成启动指令启动<code>jar</code>的逻辑，这里笔者就不多做赘述了：</p>
<pre><code class="hljs language-erlang" lang="erlang"><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(telnetPortPid &gt; <span class="hljs-number">0</span> &amp;&amp; pid == telnetPortPid)</span> {
            A<span class="hljs-title">nsiLog</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">"The target process already listen port {}, skip attach."</span>, bootstrap.getTelnetPortOrDefault())</span>;
        } <span class="hljs-title">else</span> {
            //<span class="hljs-title">double</span> <span class="hljs-title">check</span> <span class="hljs-title">telnet</span> <span class="hljs-title">port</span> <span class="hljs-title">and</span> <span class="hljs-title">pid</span> <span class="hljs-title">before</span> <span class="hljs-title">attach</span>
            <span class="hljs-title">telnetPortPid</span> = <span class="hljs-title">findProcessByTelnetClient</span><span class="hljs-params">(arthasHomeDir.getAbsolutePath(), bootstrap.getTelnetPortOrDefault())</span>;
            <span class="hljs-title">checkTelnetPortPid</span><span class="hljs-params">(bootstrap, telnetPortPid, pid)</span>;

            // <span class="hljs-title">start</span> <span class="hljs-title">arthas</span>-<span class="hljs-title">core</span>.<span class="hljs-title">jar</span>
            //拼接<span class="hljs-title">jar</span>和<span class="hljs-title">arhtas</span>-<span class="hljs-title">boot</span>路径
            L<span class="hljs-title">ist</span>&lt;S<span class="hljs-title">tring</span>&gt; <span class="hljs-title">attachArgs</span> = <span class="hljs-title">new</span> A<span class="hljs-title">rrayList</span>&lt;S<span class="hljs-title">tring</span>&gt;<span class="hljs-params">()</span>;
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-jar"</span>)</span>;
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(new File(arthasHomeDir, <span class="hljs-string">"arthas-core.jar"</span>)</span>.<span class="hljs-title">getAbsolutePath</span><span class="hljs-params">()</span>);
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-pid"</span>)</span>;
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">""</span> + pid)</span>;
            //......
            //拼接我们添加的<span class="hljs-title">telnet</span>参数
            <span class="hljs-title">if</span> <span class="hljs-params">(bootstrap.getTelnetPort() != null)</span> {
                <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-telnet-port"</span>)</span>;
                <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">""</span> + bootstrap.getTelnetPort())</span>;
            }

            <span class="hljs-title">if</span> <span class="hljs-params">(bootstrap.getHttpPort() != null)</span> {
                <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-http-port"</span>)</span>;
                <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">""</span> + bootstrap.getHttpPort())</span>;
            }
            //拼接<span class="hljs-title">core</span>和<span class="hljs-title">agent</span>的路径绝对路径地址
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-core"</span>)</span>;
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(new File(arthasHomeDir, <span class="hljs-string">"arthas-core.jar"</span>)</span>.<span class="hljs-title">getAbsolutePath</span><span class="hljs-params">()</span>);
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"-agent"</span>)</span>;
            <span class="hljs-title">attachArgs</span>.<span class="hljs-title">add</span><span class="hljs-params">(new File(arthasHomeDir, <span class="hljs-string">"arthas-agent.jar"</span>)</span>.<span class="hljs-title">getAbsolutePath</span><span class="hljs-params">()</span>);
            //......

            A<span class="hljs-title">nsiLog</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">"Try to attach process "</span> + pid)</span>;
            A<span class="hljs-title">nsiLog</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">"Start arthas-core.jar args: "</span> + attachArgs)</span>;
            //基于上述<span class="hljs-title">attachArgs</span>生成启动命令启动<span class="hljs-title">arthas</span>-<span class="hljs-title">core</span>
            P<span class="hljs-title">rocessUtils</span>.<span class="hljs-title">startArthasCore</span><span class="hljs-params">(pid, attachArgs)</span>; //<span class="hljs-title">java</span> -<span class="hljs-title">jar</span> /U<span class="hljs-title">sers</span>/<span class="hljs-title">sharkchili</span>/.<span class="hljs-title">arthas</span>/<span class="hljs-title">lib</span>/4.1.3/<span class="hljs-title">arthas</span>/<span class="hljs-title">arthas</span>-<span class="hljs-title">core</span>.<span class="hljs-title">jar</span>  -<span class="hljs-title">pid</span>  61223  -<span class="hljs-title">telnet</span>-<span class="hljs-title">port</span> 9999, -<span class="hljs-title">core</span> /U<span class="hljs-title">sers</span>/<span class="hljs-title">sharkchili</span>/.<span class="hljs-title">arthas</span>/<span class="hljs-title">lib</span>/4.1.3/<span class="hljs-title">arthas</span>/<span class="hljs-title">arthas</span>-<span class="hljs-title">core</span>.<span class="hljs-title">jar</span>  -<span class="hljs-title">agent</span>  /U<span class="hljs-title">sers</span>/<span class="hljs-title">sharkchili</span>/.<span class="hljs-title">arthas</span>/<span class="hljs-title">lib</span>/4.1.3/<span class="hljs-title">arthas</span>/<span class="hljs-title">arthas</span>-<span class="hljs-title">agent</span>.<span class="hljs-title">jar</span>

            A<span class="hljs-title">nsiLog</span>.<span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">"Attach process {} success."</span>, pid)</span>;
        }
</span></code></pre>
<p>自此我们来小结一下，<code>arthas-boot</code>启动步骤：</p>
<ol>
<li>解析启动参数</li>
<li>获取所有java进程生成列表等待用户选择</li>
<li>基于选择的pid号和agent和core两个核心模块的绝对路径生成arthas-core指令启动arhtas-core</li>
</ol>
<h3 data-id="heading-12">arthas-core 启动</h3>
<h4 data-id="heading-13">执行流程和调试环境说明</h4>
<p>我们重点还是关注一下arthas-core的逻辑，它是动态增强并实现动态插桩增强的关键，其内部本质工作本质就是将arthas-agent attach到上一步选定的进程进行动态增强。</p>
<p>为了能够调测这段源代码，笔者针对这段调测过程进行一个简要的说明，本质上通过上一步的arthas-boot会启动artahs-core让其将<code>arthas-agent</code>能够attach到运行时的目标虚拟机上，所以为了能够调测的attach的逻辑，arthas的作者也在启动脚本上做了一些手脚。</p>
<p>首先我们需要通过as脚本指定<code>--debug-attach</code>将<code>arthas-boot</code>启动，然后我们按照说明选择目标进程，以笔者为例就是一个<code>demo</code>进程，此时远程的<code>arhtas-core</code>就会开启调试模式监听<code>8888</code>端口等待idea远程<code>attach</code>，对应我们idea通过远程调试模式设置8888端口点击执行，此时我们idea就可以开始调测了解arhtas-core如何<code>attach</code>代理工具arthas-agent的逻辑了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1e854f624594f97930be4170430a504~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=sBxvq5SZVe81rCyVWQrCObjFwX8%3D" alt="" loading="lazy"/></p>
<p>了解整体思路之后，我们就开始搭建调测环境，首先我们编写一个demo程序，并将其通过javac编译：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>()</span> {
            count.incrementAndGet();
        }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">value</span>()</span> {
            <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            Counter.increment();
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"counter: "</span> + Counter.<span class="hljs-keyword">value</span>());
            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        }
    }
}
</code></pre>
<p>然后通过jdk8的java指令启动：</p>
<pre><code class="hljs language-bash" lang="bash">/Users/sharkchili/dev-tool/jdk8/Contents/Home/bin/java  Demo
</code></pre>
<p>随后，我们再打开<code>arthas</code>源码包<code>bin</code>在终端执行如下指令，并选择<code>demo</code>进程的序号连接：</p>
<pre><code class="hljs language-css" lang="css">./as<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--use-version</span> <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span> <span class="hljs-attr">--debug-attach</span>
</code></pre>
<p>最后idea配置远程模式<code>attach</code>到<code>8888</code>端口：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da6db35983b44f4d8f54223f386f55dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=ufBYWw7XBWPLWY7YDxdolII0tvg%3D" alt="" loading="lazy"/></p>
<p>由此我们就可以愉快的调试<code>arthas-core</code>了：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0584164fe26943f8ba4b629e09495e46~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=krpJIU8PKKG3dS8J3jtvAKLn0ZQ%3D" alt="" loading="lazy"/></p>
<p>对应调试步骤笔者也是参考这个issue，感兴趣的读者可以看看:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas%2Fissues%2F222" target="_blank" title="https://github.com/alibaba/arthas/issues/222" ref="nofollow noopener noreferrer">github.com/alibaba/art…</a></p>
<h4 data-id="heading-14">工作流程介绍</h4>
<p>arthas-core(以下简称为core)的逻辑比较简单，通过上文介绍我们知道arthas-boot在启动core的时候给定了一些参数，定位目标虚拟机pid号，通过agent参数指明的arthas-agent.jar attach到该虚拟机进程下。</p>
<p>对应源代码入口位于arhtas-core包的Arthas的main方法，其内部就是创建一个arthas对象，本质就是执行：</p>
<ol>
<li>parse解析获取所有启动core的参数</li>
<li>调用attach将参数给定路径的agent attach到目标虚拟机进程(也就是我们的demo)</li>
</ol>

<pre><code class="hljs language-typescript" lang="typescript">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arthas</span>(args);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> t) {
          <span class="hljs-comment">//......</span>
        }
    }

<span class="hljs-keyword">private</span> <span class="hljs-title class_">Arthas</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-title function_">attachAgent</span>(<span class="hljs-title function_">parse</span>(args));
    }
</code></pre>
<p>我们直接查看<code>attachAgent</code>可以看到笔者说明的3块核心逻辑：</p>
<ol>
<li>通过<code>VirtualMachine.list()</code>定位所有java进程，遍历匹配到目标进程的虚拟机描述符</li>
<li>通过<code>attach</code>连接到目标虚拟机进程</li>
<li>基于配置定位<code>arhtas-agent</code>本地路径，通过<code>loadAgent</code>将<code>arthas-agent</code>加载到目标虚拟机上</li>
</ol>
<p>逻辑比较简单，读者可以结合注释理解笔者上面所说的步骤，本质就是基于参数将agent attach到目标虚拟机进程，开始后续最最核心的字节码增强实现各种监控诊断指令：</p>
<pre><code class="hljs language-ini" lang="ini">private void attachAgent(Configure configure) throws Exception {
        VirtualMachineDescriptor <span class="hljs-attr">virtualMachineDescriptor</span> = null<span class="hljs-comment">;</span>
        //定位到被代理的虚拟机进程号
        for (VirtualMachineDescriptor descriptor : VirtualMachine.list()) {
            String <span class="hljs-attr">pid</span> = descriptor.id()<span class="hljs-comment">;</span>
            if (pid.equals(Long.toString(configure.getJavaPid()))) {
                <span class="hljs-attr">virtualMachineDescriptor</span> = descriptor<span class="hljs-comment">;</span>
                break<span class="hljs-comment">;</span>
            }
        }
        //将
        VirtualMachine <span class="hljs-attr">virtualMachine</span> = null<span class="hljs-comment">;</span>
        try {
            if (<span class="hljs-attr">null</span> == virtualMachineDescriptor) { // 使用 attach(String pid) 这种方式
                <span class="hljs-attr">virtualMachine</span> = VirtualMachine.attach(<span class="hljs-string">""</span> + configure.getJavaPid())<span class="hljs-comment">;</span>
            } else {
                <span class="hljs-attr">virtualMachine</span> = VirtualMachine.attach(virtualMachineDescriptor)<span class="hljs-comment">;</span>
            }

            //......
     //定位agent绝对路径
            String <span class="hljs-attr">arthasAgentPath</span> = configure.getArthasAgent()<span class="hljs-comment">;</span>
            //convert jar path to unicode string
            configure.setArthasAgent(encodeArg(arthasAgentPath))<span class="hljs-comment">;</span>
            configure.setArthasCore(encodeArg(configure.getArthasCore()))<span class="hljs-comment">;</span>
            try {//加载arthas-agent.jar,对当前进程进行增强操作
                virtualMachine.loadAgent(arthasAgentPath,
                        configure.getArthasCore() + "<span class="hljs-comment">;" + configure.toString());</span>
            } catch (IOException e) {
                //......
            }
        } finally {
            //......
        }
    }
</code></pre>
<h3 data-id="heading-15">arthas agent 增强(重点)</h3>
<h4 data-id="heading-16">宏观流程介绍</h4>
<p>自此我们就可以正式的开始分析arthas最核心的一个部分，即动态增强了，通过上述的步骤我们将artahs-agent attach到指定pid的虚拟机中，接下来我们就要通过源码的分析的方式了解，attach后的agent做了那些事情。</p>
<p>当arthas-agent attach目标jvm之后，就需要做到拦截所有类确保在必要时刻能够做到运行时动态增强，这时就需要用到<code>agentmain</code>方法，即通过配置中指定<code>Agent-Class</code>，确保加载到目标虚拟机的agent可以执行对应<code>agentmain</code>方法，执行必要的初始化流程(后文会展开详解)，生成一个arthas服务端监听3658端口，等待客户端连接：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/833b9b90adf0478b80f63908c4e5d992~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=9VNHfCH77svsSsxtOUbtX6E%2BUTU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-17">调试环境搭建</h4>
<p>为了更好的了解这个流程，笔者也介绍一下关于arthas-agent attach的详细流程，首先我们需要启动上述的demo并以监听模式运行，因为笔者环境默认jdk为jdk11，所以这里手动的指定了一下jdk版本：</p>
<pre><code class="hljs language-bash" lang="bash"> /Users/sharkchili/dev-tool/jdk8/Contents/Home/bin/java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 Demo
</code></pre>
<p>然后arhtas源码通过远程连接的方式连接8000端口：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ef504c922c94683b054412e83c98856~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=LEc0w4%2FTG9inQhDLQP4hMPKWUec%3D" alt="" loading="lazy"/></p>
<p>最后我们启动as脚本，并选择demo进程，执行到arhtas attach环节时，代码就会来到arhtas agent 包下AgentBootstrap的agentMain方法：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/abbd1eb71dac4e8da04eb7006a1fd2f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=cEyQn0s3MTxq984NPw4G4icNcjo%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-18">attach流程说明</h4>
<p>从上文的调试截图可以看到，其内部本质就是拿着<code>Instrumentation</code>引入动态增强的逻辑，我们步入<code>main</code>方法可以看到，其内部核心逻辑为：</p>
<ol>
<li>拉取<code>core</code>路径获取对应的类加载器</li>
<li>调用core包的类加载ArthasBootstrap.class</li>
<li>基于ArthasBootstrap.class初始化启动arhtas服务端监听3658端口(默认情况下)</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a65c8b11a8934fc1b88536049d652f3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=si9PwP%2BsG6hAoiQz3Nw02t9eA0s%3D" alt="" loading="lazy"/></p>
<p>对应<code>main</code>的源码如下，他会从<code>args</code>中获取agent和core的路径然后拉取加载器启动一个<code>bindingThread</code>启动<code>shellServer</code>也就是<code>arthas</code>服务端：</p>
<pre><code class="hljs language-ini" lang="ini">private static synchronized void main(String args, final Instrumentation inst) {
        // 尝试判断arthas是否已在运行，如果是的话，直接就退出
       
        try {
            ps.println("Arthas server agent start...")<span class="hljs-comment">;</span>
            // 传递的args参数分两个部分:arthasCoreJar路径和agentArgs, 分别是Agent的JAR包路径和期望传递到服务端的参数
            if (<span class="hljs-attr">args</span> == null) {
                <span class="hljs-attr">args</span> = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
            }
            <span class="hljs-attr">args</span> = decodeArg(args)<span class="hljs-comment">;</span>
     //获取core包合agent包路径
            String arthasCoreJar<span class="hljs-comment">;</span>
            final String agentArgs<span class="hljs-comment">;</span>
            int <span class="hljs-attr">index</span> = args.indexOf(<span class="hljs-string">';'</span>)<span class="hljs-comment">;</span>
            if (index != -1) {
              //从参数中获取arhtas core jar 路径
                <span class="hljs-attr">arthasCoreJar</span> = args.substring(<span class="hljs-number">0</span>, index)<span class="hljs-comment">; </span>
                //从参数中获取arthas agent jar路径
                <span class="hljs-attr">agentArgs</span> = args.substring(index)<span class="hljs-comment">;</span>
            } else {
                <span class="hljs-attr">arthasCoreJar</span> = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
                <span class="hljs-attr">agentArgs</span> = args<span class="hljs-comment">;</span>
            }


             */
             //获取core jar的类加载器
            final ClassLoader <span class="hljs-attr">agentLoader</span> = getClassLoader(inst, arthasCoreJarFile)<span class="hljs-comment">;</span>

            Thread <span class="hljs-attr">bindingThread</span> = new Thread() {
                @Override
                public void run() {
                    try {
                        bind(inst, agentLoader, agentArgs)<span class="hljs-comment">;//启动arthas服务端</span>
                    } catch (Throwable throwable) {
                        throwable.printStackTrace(ps)<span class="hljs-comment">;</span>
                    }
                }
            }<span class="hljs-comment">;</span>

            bindingThread.setName("arthas-binding-thread")<span class="hljs-comment">;</span>
            bindingThread.start()<span class="hljs-comment">;</span>
            bindingThread.join()<span class="hljs-comment">;</span>
        } catch (Throwable t) {
          //......
        }
    }
</code></pre>
<p>此时逻辑就到了<code>getInstance</code>的<code>getInstance</code>单例实现，其内部会解析参数完成完成如下工作：</p>
<ol>
<li><code>initFastjson</code>：初始化<code>json</code>工具规则配置</li>
<li>initSpy(重点)：将<code>SpyAPI</code>添加到当前<code>bootstrap</code>类加载器中</li>
<li><code>initArthasEnvironment</code>：初始化arthas环境变量</li>
<li>创建arthas日志输出文件夹arthas-output</li>
<li><code>LogUtil</code>初始化日志工具</li>
<li>增强<code>ClassLoader</code>：解决解决一些 ClassLoader 加载不到 SpyAPI的问题所以才要增强<code>ClassLoader</code></li>
<li>init beans：初始化一些视图窗口消息输入输出解析器和<code>history</code>指令管理器</li>
<li>bind：重点启动arthas server</li>
<li>初始化<code>executorService</code>线程池执行后监听并处理后续用户的监控诊断指令的异步任务</li>
<li>创建一个shutdown线程注册虚拟机钩子监听关闭事件以便及时关闭ArthasBootstrap</li>
</ol>

<pre><code class="hljs language-scss" lang="scss">private <span class="hljs-built_in">ArthasBootstrap</span>(Instrumentation instrumentation, Map&lt;String, String&gt; args) throws Throwable {
        this<span class="hljs-selector-class">.instrumentation</span> = instrumentation;
    <span class="hljs-comment">//初始化json工具规则配置</span>
        <span class="hljs-built_in">initFastjson</span>();

        <span class="hljs-comment">// 2. 将SpyAPI添加到当前bootstrap类加载器中</span>
        <span class="hljs-built_in">initSpy</span>();
        <span class="hljs-comment">// 3. 初始化arthas环境变量</span>
        <span class="hljs-built_in">initArthasEnvironment</span>(args);
   <span class="hljs-comment">//4. 创建arthas日志输出目录</span>
        String outputPathStr = configure<span class="hljs-selector-class">.getOutputPath</span>();
        if (outputPathStr == null) {
            outputPathStr = ArthasConstants<span class="hljs-selector-class">.ARTHAS_OUTPUT</span>;
        }
        outputPath = new <span class="hljs-built_in">File</span>(outputPathStr);
        outputPath<span class="hljs-selector-class">.mkdirs</span>();

        <span class="hljs-comment">// 5. 初始化日志工具</span>
        loggerContext = LogUtil<span class="hljs-selector-class">.initLogger</span>(arthasEnvironment);

        <span class="hljs-comment">// 4. 增强ClassLoader</span>
        <span class="hljs-built_in">enhanceClassLoader</span>();
        <span class="hljs-comment">// 5. 初始化一些视图解析器和history管理bean</span>
        <span class="hljs-built_in">initBeans</span>();

        <span class="hljs-comment">// 6. 启动agent server</span>
        <span class="hljs-built_in">bind</span>(configure);
    <span class="hljs-comment">//初始化命令解析的线程池</span>
        executorService = Executors<span class="hljs-selector-class">.newScheduledThreadPool</span>(<span class="hljs-number">1</span>, new ThreadFactory() {
            <span class="hljs-keyword">@Override</span>
            public Thread newThread(Runnable r) {
                final Thread t = new <span class="hljs-built_in">Thread</span>(r, "arthas-command-execute");
                t<span class="hljs-selector-class">.setDaemon</span>(true);
                return t;
            }
        });
   <span class="hljs-comment">//注册虚拟机钩子</span>
        shutdown = new <span class="hljs-built_in">Thread</span>("as-shutdown-hooker") {

            <span class="hljs-keyword">@Override</span>
            public void run() {
                ArthasBootstrap<span class="hljs-selector-class">.this</span><span class="hljs-selector-class">.destroy</span>();
            }
        };

        transformerManager = new <span class="hljs-built_in">TransformerManager</span>(instrumentation);
        Runtime<span class="hljs-selector-class">.getRuntime</span>()<span class="hljs-selector-class">.addShutdownHook</span>(shutdown);
    }
</code></pre>
<h2 data-id="heading-19">详解ArthasBootstrap启动核心流程</h2>
<h3 data-id="heading-20">详解spy初始化(重点)</h3>
<p>上文宏观说明了<code>ArthasBootstrap</code>整体流程，因为整体流程实现细节较多，所以笔者打算抽取一个篇幅逐步拆解这块流程，先来说说<code>initSpy</code>，该流程本质就是通过根加载器将搜寻<code>SpyAPI</code>这个<code>class</code>是否存在，若不存在则定位到对应的jar包物理地址将其添加到当前虚拟机(例如我们需要增强的Demo)程序：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a122fe28f37447b89d3a4958ac4838bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=k8zaxgQDnrM1KQ0Dk1OEIyVRyJA%3D" alt="" loading="lazy"/></p>
<p>这里我们需要了解两个问题：</p>
<ol>
<li>为什么需要加载<code>SpyAPI</code></li>
<li>为什么需要通过根加载器进行加载</li>
</ol>
<h4 data-id="heading-21">为什么需要加载SpyAPI</h4>
<p>我们查看SpyAPI是arthas增强的核心抽象类，它是增强操作逻辑的具体实现者，arhtas在进行增强时本质就是通过SpyAPI的调用实现的，SpyAPI内置了一个spyInstance，当我们针对特定实现类通过stack或者trace指令针对类进行动态增强观察其堆栈或者耗时时，本质就是通过SpyAPI对应atEnter的方法定位到每个指令的监听器执行函数增强。</p>
<p>例如我们针对Demo类increment执行watch指令，arhtas的增强操作就是通过增强器在方法前后插入SpyAPI的调用，每当程序执行increment操作时就会调用SpyAPI的atEnter、atExit等方法，而这些方法就会搜寻到watch指令的监听器并执行对应逻辑：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d543cbdd7b174077ae46cca926e65d84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=Gdc1yIGqRhj0LvYfDcdEjwsLCLw%3D" alt="" loading="lazy"/></p>
<p>对应我们这里也先给出<code>SpyAPI</code>的源代码，可以看到其内部暴露了<code>setSpy</code>及其atEnter等增强函数，其内部本质都是调用<code>spyInstance</code>通过<code>atEnter</code>获取对应指令的监听器执行前置或者后置的增强逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpyAPI</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractSpy</span> <span class="hljs-variable">NOPSPY</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NopSpy</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">AbstractSpy</span> <span class="hljs-variable">spyInstance</span> <span class="hljs-operator">=</span> NOPSPY;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> INITED;

    <span class="hljs-comment">//......</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSpy</span><span class="hljs-params">(AbstractSpy spy)</span> {
        spyInstance = spy;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">atEnter</span><span class="hljs-params">(Class&lt;?&gt; clazz, String methodInfo, Object target, Object[] args)</span> {
        spyInstance.atEnter(clazz, methodInfo, target, args);
    }
}
</code></pre>
<h4 data-id="heading-22">为什么需要通过根加载器进行加载</h4>
<p>通常情况下，java类加载器分为如下几种：</p>
<ol>
<li>bootstrap类加载器：由c++实现，是虚拟机自身的一部分，主要负责加载lib目录下存放的类</li>
<li>extension类加载器： 主要加载lib目录下ext目录中的类</li>
<li>application 应用加载器，主要加载用户类路径下所有的类库</li>
</ol>
<p>按照JVM双亲委派模型的说法，当进行类加载时，所有类都会优先将请求委托给父类，明确父类搜寻范围找不到对应类而无法完成加载后，才会自己尝试加载，由此保证rt.jar等基础核心jar包类加载安全，同理，为了避免加载spy这个核心增强的接口被破坏，arthas就会强制指明用根加载器完成加载，确保所有类都能够准确的加载到这个类：</p>
<pre><code class="hljs language-ini" lang="ini"> // 将Spy添加到BootstrapClassLoader
        ClassLoader <span class="hljs-attr">parent</span> = ClassLoader.getSystemClassLoader().getParent()<span class="hljs-comment">;</span>
        Class&lt;?&gt; <span class="hljs-attr">spyClass</span> = null<span class="hljs-comment">;</span>
        if (parent != null) {
            try {
                <span class="hljs-attr">spyClass</span> =parent.loadClass(<span class="hljs-string">"java.arthas.SpyAPI"</span>)<span class="hljs-comment">;</span>
            } catch (Throwable e) {
                // ignore
            }
        }
</code></pre>
<h3 data-id="heading-23">启动arthas server</h3>
<p>我们重点还是关注一下启动<code>arthas server</code>这一步，该步骤由bind方法负责，工作线程在cas成功后上锁后，顺序执行如下步骤：</p>
<ol>
<li>会通过读取启动参数确认启动方式(默认是telnet server对应3658端口)的配置创建<code>shellServer</code></li>
<li>初始化创建命令集合对象<code>BuiltinCommandPack</code>，其内部包含例如jad即JadCommand、stack即StackCommand这些命令的抽象实现类</li>
<li>基于netty创建workerGroup作为服务端的连接处理工作线程组</li>
<li>初始化server对象并添加到<code>termServers</code>容器中</li>
<li>变量<code>termServers</code>调用listen开启服务端监听</li>
</ol>
<p>对应完成后的服务端架构图如下所示，可以看到shellServer用termServers维护不同的网络服务端，同时用sessions维护用户会话，而常见的命令抽象也都以类似于BuiltinCommandPack这样的封装集合容器维护到resolvers容器中：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fdf8f761aa642489d465b93aa9d4a7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=bj64L2Whn7%2BOKyhjlO8BM7ZZQr0%3D" alt="" loading="lazy"/></p>
<p>对应我们也给出<code>bind</code>对应实现，正如笔者所说在<code>cas</code>修改状态保证线程互斥后，初始化<code>shellServer</code>完成：</p>
<ol>
<li>服务端初始化</li>
<li>命令初始化</li>
<li>启动服务端监听</li>
</ol>

<pre><code class="hljs language-scss" lang="scss">private void <span class="hljs-built_in">bind</span>(Configure configure) throws Throwable {

        long start = System<span class="hljs-selector-class">.currentTimeMillis</span>();

        if (!isBindRef.compareAndSet(false, true)) {<span class="hljs-comment">//cas 改变状态</span>
            throw new <span class="hljs-built_in">IllegalStateException</span>("already bind");
        }

        <span class="hljs-comment">//......</span>

        try { <span class="hljs-comment">//初始化shell server 欢迎输出等信息</span>
            ShellServerOptions options = new <span class="hljs-built_in">ShellServerOptions</span>()
                            <span class="hljs-selector-class">.setInstrumentation</span>(instrumentation)
                            <span class="hljs-selector-class">.setPid</span>(PidUtils.currentLongPid()) <span class="hljs-comment">//atacch 的pid</span>
                            <span class="hljs-selector-class">.setWelcomeMessage</span>(ArthasBanner.welcome());
            if (configure.getSessionTimeout() != null) {
                options<span class="hljs-selector-class">.setSessionTimeout</span>(configure.getSessionTimeout() * <span class="hljs-number">1000</span>);
            }

      <span class="hljs-comment">//......</span>
            shellServer = new <span class="hljs-built_in">ShellServerImpl</span>(options);

          <span class="hljs-comment">//......</span>
          <span class="hljs-comment">//初始化BuiltinCommandPack内部包含jad、monitor等执行的抽象</span>
            BuiltinCommandPack builtinCommands = new <span class="hljs-built_in">BuiltinCommandPack</span>(disabledCommands);<span class="hljs-comment">//绑定命令</span>
            List&lt;CommandResolver&gt; resolvers = new ArrayList&lt;CommandResolver&gt;();
            resolvers<span class="hljs-selector-class">.add</span>(builtinCommands);

            <span class="hljs-comment">//worker group</span>
            workerGroup = new <span class="hljs-built_in">NioEventLoopGroup</span>(new DefaultThreadFactory("arthas-TermServer", true));

            <span class="hljs-comment">// 基于配置创建并注册HttpTelnetTermServer、HttpTermServer等服务端</span>
            if (configure.getTelnetPort() != null &amp;&amp; configure<span class="hljs-selector-class">.getTelnetPort</span>() &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">logger</span>()<span class="hljs-selector-class">.info</span>("try to bind telnet server, host: {}, port: {}.", configure.getIp(), configure<span class="hljs-selector-class">.getTelnetPort</span>());
                shellServer<span class="hljs-selector-class">.registerTermServer</span>(new HttpTelnetTermServer(configure.getIp(), configure<span class="hljs-selector-class">.getTelnetPort</span>(),
                        options<span class="hljs-selector-class">.getConnectionTimeout</span>(), workerGroup, httpSessionManager));
            } else {
                <span class="hljs-built_in">logger</span>()<span class="hljs-selector-class">.info</span>("telnet port is {}, skip bind telnet server.", configure.getTelnetPort());
            }
            if (configure.getHttpPort() != null &amp;&amp; configure<span class="hljs-selector-class">.getHttpPort</span>() &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">logger</span>()<span class="hljs-selector-class">.info</span>("try to bind http server, host: {}, port: {}.", configure.getIp(), configure<span class="hljs-selector-class">.getHttpPort</span>());
                shellServer<span class="hljs-selector-class">.registerTermServer</span>(new HttpTermServer(configure.getIp(), configure<span class="hljs-selector-class">.getHttpPort</span>(),
                        options<span class="hljs-selector-class">.getConnectionTimeout</span>(), workerGroup, httpSessionManager));
            } else {
                <span class="hljs-comment">// listen local address in VM communication</span>
                if (configure.getTunnelServer() != null) {
                    shellServer<span class="hljs-selector-class">.registerTermServer</span>(new HttpTermServer(configure.getIp(), configure<span class="hljs-selector-class">.getHttpPort</span>(),
                            options<span class="hljs-selector-class">.getConnectionTimeout</span>(), workerGroup, httpSessionManager));
                }
                <span class="hljs-built_in">logger</span>()<span class="hljs-selector-class">.info</span>("http port is {}, skip bind http server.", configure.getHttpPort());
            }
     <span class="hljs-comment">//遍历resolvers集合中的命令包将其添加到shellServer的命令管理容器中</span>
            for (CommandResolver resolver : resolvers) {
                shellServer<span class="hljs-selector-class">.registerCommandResolver</span>(resolver);
            }
     <span class="hljs-comment">//内部遍历刚刚注册的服务端并启动监听</span>
            shellServer<span class="hljs-selector-class">.listen</span>(new BindHandler(isBindRef));<span class="hljs-comment">//监听</span>
            <span class="hljs-comment">//......</span>
        } catch (Throwable e) {
         <span class="hljs-comment">//......</span>

        }
    }
</code></pre>
<p>笔者这里也给出对应监听的实现，本质上就是遍历各个<code>server</code>并配置消息处理器<code>TermServerTermHandler</code>执行<code>listen</code>监听并通过<code>TermServerTermHandler</code>处理请求：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ShellServer listen(<span class="hljs-keyword">final</span> Handler&lt;Future&lt;<span class="hljs-built_in">Void</span>&gt;&gt; listenHandler) {
        <span class="hljs-keyword">final</span> List&lt;TermServer&gt; toStart;
        synchronized (<span class="hljs-keyword">this</span>) {
           <span class="hljs-comment">//......</span>
            toStart = termServers;
        }
        
       <span class="hljs-comment">//......</span>
        <span class="hljs-keyword">for</span> (TermServer termServer : toStart) {<span class="hljs-comment">//遍历启动创建的对应网络通信方式的server</span>
            termServer.termHandler(new TermServerTermHandler(<span class="hljs-keyword">this</span>));<span class="hljs-comment">//服务器server绑定 terminal handler</span>
            termServer.listen(handler); <span class="hljs-comment">//监听网络请求，收到的请求就会交由TermServerTermHandler也就是上一步初始化的处理器处理请求</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
</code></pre>
<h3 data-id="heading-24">客户端建立连接</h3>
<p>明确上述服务端建立之后，<code>arthas</code>会为我们分配一个客户端与其建立连接，分别执行：</p>
<ol>
<li>创建会话<code>session</code></li>
<li>终端输出欢迎信息</li>
<li>将会话保存到服务端缓存<code>sessions</code>中</li>
<li>监听客户端输入，并通过<code>ShellLineHandler</code>处理请求</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa11e2cb14dc4280a5b5b33f1a377425~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=G%2FovSYcjKUSXpGVqkZYRo%2BK31Jk%3D" alt="" loading="lazy"/></p>
<p>对应笔者给出<code>HttpTelnetTermServer</code>处理客户端连接处理的入口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TermServer</span> <span class="hljs-title function_">listen</span>(<span class="hljs-params">Handler&lt;Future&lt;TermServer&gt;&gt; listenHandler</span>) {
       <span class="hljs-comment">//初始化bootstrap</span>
        bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyHttpTelnetTtyBootstrap</span>(workerGroup, httpSessionManager).<span class="hljs-title function_">setHost</span>(hostIp).<span class="hljs-title function_">setPort</span>(port);
        <span class="hljs-keyword">try</span> {
            bootstrap.<span class="hljs-title function_">start</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">TtyConnection</span>&gt;() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">final TtyConnection conn</span>) {
                  <span class="hljs-comment">//监听TermServerTermHandler收到的请求并调用handle方法处理</span>
                    termHandler.<span class="hljs-title function_">handle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TermImpl</span>(<span class="hljs-title class_">Helper</span>.<span class="hljs-title function_">loadKeymap</span>(), conn));
                }
            }).<span class="hljs-title function_">get</span>(connectionTimeout, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MILLISECONDS</span>);
             <span class="hljs-comment">//......</span>
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> t) {
           <span class="hljs-comment">//......</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }
</code></pre>
<p><code>TermServerTermHandler</code>最终会执行到<code>ShellServerImpl</code>的<code>handleTerm</code>完成上文所说的<code>session</code>初始化和<code>readline</code>监听命令请求的核心逻辑，逻辑比较直观，读者可以结合注释了解：</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">handleTerm</span>(Term term) {
        synchronized (this) {<span class="hljs-comment">//保证停止后可以及时停止连接</span>
            <span class="hljs-comment">// That might happen with multiple ser</span>
            if (closed) {
                term<span class="hljs-selector-class">.close</span>();
                return;
            }
        }
   <span class="hljs-comment">// 创建本地会话session，为其分配命令列表、instrumentation(引入spy的代码插桩实例)</span>
        ShellImpl session = <span class="hljs-built_in">createShell</span>(term);
       <span class="hljs-comment">//......</span>
        <span class="hljs-comment">//终端输出欢迎信息</span>
        session<span class="hljs-selector-class">.init</span>();
        <span class="hljs-comment">//缓存session信息</span>
        sessions<span class="hljs-selector-class">.put</span>(session.id, session); 
        <span class="hljs-comment">//监听用户的输入命令</span>
        session<span class="hljs-selector-class">.readline</span>(); 
    }
</code></pre>
<h3 data-id="heading-25">基于stack了解arthas设计理念与工作机制</h3>
<p>在建立服务端之后，对应会话session.readline();监听客户端请求，例如笔者希望通过stack指令了解increment方法的执行堆栈信息：</p>
<pre><code class="hljs language-arduino" lang="arduino">stack Demo$Counter increment  -n <span class="hljs-number">5</span> 
</code></pre>
<p>其实<code>session</code>收到请求后会通过<code>ShellLineHandler</code>处理该请求，对应<code>ShellLineHandler</code>内部执行核心逻辑为：</p>
<ol>
<li>解析指令<code>token</code>获取指令字符串，对应本次示例就是<code>stack</code>字符串</li>
<li>基于指令字符串stack获取对应<code>command</code>对应本例就是<code>StackCommand</code>并封装成<code>ProcessImpl</code></li>
<li>基于上述<code>ProcessImpl</code>处理器、<code>session</code>会话等信息构成<code>JobImpl</code></li>
<li><code>JobImpl</code>执行<code>run</code>方法将上文的<code>ProcessImpl</code>(包含命令以及命令上下文信息)封装成<code>CommandProcessTask</code>提交到上文初始化好的线程池<code>executorService</code>中</li>
<li>重点来了，异步任务运行后<code>StackCommand</code>对应抽象父类<code>EnhancerCommand</code>对应<code>enhance</code>逻辑会针对命令对应的类执行插桩操作，即通过上文说明的<code>ByteKit</code>这个工具封装的而成的<code>InterceptorProcessor</code>针对目标类匹配方法进行字节码增强，本质上就是结合当前指令(例如本例的stack)获取对应监听器，以当前类作为key，监听器列表作为value缓存到全局map中，后续完成插桩后的类执行atEnter调用时就会通过全局监听器定位到当前类的监听器完成执行增强逻辑：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53fec23a916042fe96407c3b8000a7e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=rOptfiTbsgkoCHtdrY2uSGrgs8E%3D" alt="" loading="lazy"/></p>
<p>了解宏观流程后，我们给出<code>ShellLineHandler</code>的<code>handle</code>方法，本质就是解析传入的命令line，然后按照上面说的解析命令等信息封装成<code>process</code>(包含命令抽象和session)从而构建出job，然后调用run方法：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Override</span>
    public void handle(String line) {<span class="hljs-comment">//stack Demo$Counter increment</span>
        if (line == null) {
            <span class="hljs-comment">// EOF</span>
            <span class="hljs-built_in">handleExit</span>();
            return;
        }

        List&lt;CliToken&gt; tokens = CliTokens<span class="hljs-selector-class">.tokenize</span>(line);
        CliToken first = TokenUtils<span class="hljs-selector-class">.findFirstTextToken</span>(tokens);<span class="hljs-comment">//拿到一个 token得到对应的指令</span>
       <span class="hljs-comment">//......</span>

        Job job = <span class="hljs-built_in">createJob</span>(tokens);
        if (job != null) {
            job<span class="hljs-selector-class">.run</span>();<span class="hljs-comment">//提交到线程池</span>
        }
    }
</code></pre>
<p>由此来到JobImpl的run方法，由此看到最核心的逻辑，即将<code>process</code>处理器封装到<code>CommandProcessTask</code>提交到线程池中运行：</p>
<pre><code class="hljs language-arduino" lang="arduino">@<span class="hljs-function">Override
    <span class="hljs-keyword">public</span> Job <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">boolean</span> foreground)</span> </span>{
   <span class="hljs-comment">//......</span>
        process.<span class="hljs-built_in">setSession</span>(<span class="hljs-keyword">this</span>.session);
        process.<span class="hljs-built_in">run</span>(foreground);

    <span class="hljs-comment">//......</span>
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }


@<span class="hljs-function">Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fg)</span> </span>{
        <span class="hljs-comment">//......</span>
        Runnable task = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CommandProcessTask</span>(process);<span class="hljs-comment">//封装成任务</span>
        ArthasBootstrap.<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">execute</span>(task); <span class="hljs-comment">//丢到无界线程池中</span>
    }
</code></pre>
<p>经过层层抽象调用来到执行<code>stackCommand</code>的<code>process</code>，即执行抽象父类的通用增强逻辑：</p>
<ol>
<li>匹配定位要拦截的方法，插入<code>SpyAPI</code>的<code>atEnter</code>等方法完成字节码增强</li>
<li>定位子类即<code>stackCommand</code>的监听器以当前目标类为key，监听器为<code>value</code>缓存到全局监听器</li>
<li>返回增强后的字节码</li>
</ol>

<pre><code class="hljs language-scss" lang="scss"> <span class="hljs-keyword">@Override</span>
    public byte[] transform(final ClassLoader inClassLoader, String className, Class&lt;?&gt; classBeingRedefined,
            ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        try {
           <span class="hljs-comment">//......</span>

          

           <span class="hljs-comment">//拿到原有的代码的字节码</span>
            ClassNode classNode = new <span class="hljs-built_in">ClassNode</span>(Opcodes.ASM9);
            ClassReader classReader = AsmUtils<span class="hljs-selector-class">.toClassNode</span>(classfileBuffer, classNode);
           
            <span class="hljs-comment">// 生成增强字节码</span>
            DefaultInterceptorClassParser defaultInterceptorClassParser = new <span class="hljs-built_in">DefaultInterceptorClassParser</span>();

            <span class="hljs-comment">//......</span>

     <span class="hljs-comment">//过滤匹配需要增强的目标方法</span>
            List&lt;MethodNode&gt; matchedMethods = new ArrayList&lt;MethodNode&gt;();
            for (MethodNode methodNode : classNode.methods) {
                if (!isIgnore(methodNode, methodNameMatcher)) {
                    matchedMethods<span class="hljs-selector-class">.add</span>(methodNode);
                }
            }

              <span class="hljs-comment">//......</span>

           

            for (MethodNode methodNode : matchedMethods) {
                
                <span class="hljs-comment">// 先查找是否有 atBeforeInvoke 函数，如果有，则说明已经有trace了，则直接不再尝试增强，直接插入 listener</span>
                <span class="hljs-built_in">if</span>(AsmUtils.containsMethodInsnNode(methodNode, Type.getInternalName(SpyAPI.class), "atBeforeInvoke")) {
                     <span class="hljs-comment">//......</span>
                }else {
                    MethodProcessor methodProcessor = new <span class="hljs-built_in">MethodProcessor</span>(classNode, methodNode, groupLocationFilter);
                    <span class="hljs-comment">//遍历所有interceptor针对匹配的目标方法进行增强操作</span>
                    for (InterceptorProcessor interceptor : interceptorProcessors) {
                        try {
                            List&lt;Location&gt; locations = interceptor<span class="hljs-selector-class">.process</span>(methodProcessor);
                            for (Location location : locations) {
                                if (location instanceof MethodInsnNodeWare) {
                                    MethodInsnNodeWare methodInsnNodeWare = (MethodInsnNodeWare) location;
                                    MethodInsnNode methodInsnNode = methodInsnNodeWare<span class="hljs-selector-class">.methodInsnNode</span>();
<span class="hljs-comment">//针对当前类注册监听器，对应该方法底层就会以当前类作为key，添加一个相关指令的监听器(例如stack就是StackAdviceListener)等待执行增强逻辑执行时执行栈帧调用追踪</span>
                                     AdviceListenerManager<span class="hljs-selector-class">.registerTraceAdviceListener</span>(inClassLoader, className,
                                            methodInsnNode.owner, methodInsnNode.name, methodInsnNode.desc, listener);
                                }
                            }

                        } catch (Throwable e) {
                           <span class="hljs-comment">//......</span>
                        }
                    }
                }

 <span class="hljs-comment">//针对当前类注册监听器，例如本次用stack指令对Demo类的Counter内部类的increment做调用追踪，对应该方法底层就会以当前类作为key，添加一个StackAdviceListener等待执行增强逻辑执行时执行栈帧调用追踪</span>
                AdviceListenerManager<span class="hljs-selector-class">.registerAdviceListener</span>(inClassLoader, className, methodNode.name, methodNode.desc,
                        listener);
                <span class="hljs-comment">//......</span>
            byte<span class="hljs-selector-attr">[]</span> enhanceClassByteArray = AsmUtils<span class="hljs-selector-class">.toBytes</span>(classNode, inClassLoader, classReader);

          <span class="hljs-comment">//......</span>
    <span class="hljs-comment">//返回增强后的字节码</span>

            return enhanceClassByteArray;
        } catch (Throwable t) {
            logger<span class="hljs-selector-class">.warn</span>("transform loader[{}]:class[{}] failed.", inClassLoader, className, t);
            affect<span class="hljs-selector-class">.setThrowable</span>(t);
        }

        return null;
    }
</code></pre>
<h3 data-id="heading-26">解耦化拦截类方法执行增强逻辑</h3>
<p>后续对于该类即<code>Demo.Counter</code>的调用，就会执行到<code>SpyAPI</code>的<code>atEnter</code>方法，本质上就是对应<code>spyInstance</code>(也就是<code>SpyImpl</code>)的调用：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">atEnter</span>(<span class="hljs-params">Class&lt;?&gt; clazz, <span class="hljs-built_in">String</span> methodInfo, <span class="hljs-built_in">Object</span> target, <span class="hljs-built_in">Object</span>[] args</span>) {
        spyInstance.<span class="hljs-title function_">atEnter</span>(clazz, methodInfo, target, args);
    }
</code></pre>
<p>步入<code>SpyImpl</code>源代码可以看到，其底层就会通过全局监听器定位到这个类的监听器完成具体的增强逻辑，显见<code>arthas</code>作者对于解耦思想的见解：</p>
<pre><code class="hljs language-ini" lang="ini">@Override
    public void atEnter(Class&lt;?&gt; clazz, String methodInfo, Object target, Object<span class="hljs-section">[]</span> args) {
        ClassLoader <span class="hljs-attr">classLoader</span> = clazz.getClassLoader()<span class="hljs-comment">;</span>

        String<span class="hljs-section">[]</span> <span class="hljs-attr">info</span> = StringUtils.splitMethodInfo(methodInfo)<span class="hljs-comment">;</span>
        String <span class="hljs-attr">methodName</span> = info[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
        String <span class="hljs-attr">methodDesc</span> = info[<span class="hljs-number">1</span>]<span class="hljs-comment">;</span>
       //基于当前类到全局缓存获取所有监听器
        List&lt;AdviceListener&gt; <span class="hljs-attr">listeners</span> = AdviceListenerManager.queryAdviceListeners(classLoader, clazz.getName(),
                methodName, methodDesc)<span class="hljs-comment">;</span>
        if (listeners != null) {
            for (AdviceListener adviceListener : listeners) {
                try {
                    if (skipAdviceListener(adviceListener)) {
                        continue<span class="hljs-comment">;</span>
                    }
                    //执行匹配的监听器逻辑
                    adviceListener.before(clazz, methodName, methodDesc, target, args)<span class="hljs-comment">;</span>
                } catch (Throwable e) {
                    logger.error("class: {}, methodInfo: {}", clazz.getName(), methodInfo, e)<span class="hljs-comment">;</span>
                }
            }
        }

    }
</code></pre>
<p>以本次的<code>stack</code>为例也就是在调用前在当前线程内部维护一个开始时间，这里笔者考虑到<code>stack</code>指令介绍的完整性也将<code>atExit</code>注解对应执行的afterReturning方法，可以看到stack本质要做的就是：</p>
<ol>
<li>before记录其实时间</li>
<li>afterReturning通过finishing提取线程中的调用堆栈信息和线程信息封装成StackModel输出</li>
</ol>

<pre><code class="hljs language-java" lang="java"> <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt; clazz, ArthasMethod method, Object target, Object[] args)</span>
            <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 开始计算本次方法调用耗时</span>
        threadLocalWatch.start();
    }

<span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt; clazz, ArthasMethod method, Object target, Object[] args,
                               Object returnObject)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">Advice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> Advice.newForAfterRetuning(loader, clazz, method, target, args, returnObject);<span class="hljs-comment">//获取类信息 入参 出参信息</span>
        finishing(advice);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishing</span><span class="hljs-params">(Advice advice)</span> {
        <span class="hljs-comment">// 本次调用的耗时</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">double</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> threadLocalWatch.costInMillis();
            <span class="hljs-comment">//判断条件是否满足要输出的结果</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionResult</span> <span class="hljs-operator">=</span> isConditionMet(command.getConditionExpress(), advice, cost);
         <span class="hljs-comment">//......</span>
            <span class="hljs-keyword">if</span> (conditionResult) {
                <span class="hljs-comment">//提取当前线程内部维护的stacktrace构成调用链以及各种线程信息构成StackModel返回</span>
                <span class="hljs-type">StackModel</span> <span class="hljs-variable">stackModel</span> <span class="hljs-operator">=</span> ThreadUtil.getThreadStackModel(advice.getLoader(), Thread.currentThread());
                stackModel.setTs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
                process.appendResult(stackModel);
              <span class="hljs-comment">//......</span>
            }
        } <span class="hljs-keyword">catch</span> (Throwable e) {
           <span class="hljs-comment">//......</span>
        }
    }
</code></pre>
<p>最终我们就可以看到类似下面这样的输出结果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1eca0bed63e4987817a755a793389be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2hhcmtfY2hpbGk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767231464&amp;x-signature=UBCuxgDSPvvZchoYIplabXiI5jM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-27">关于arthas性能问题的探讨</h2>
<p>在笔者了解arthas这本技术的时候，看到github有这样一个话题：</p>
<pre><code class="hljs">arthas进行增强时，对于程序执行性能是否有影响
</code></pre>
<p>参考大部分答案结合笔者的经验，针对那些被JIT优化且生成机器码的字节码进行增强时，这就会使得原有的缓存失效，使得被增强的类经历：</p>
<ol>
<li>字节码修改</li>
<li>原有JIT优化后的代码失效</li>
<li>高并发的函数调用会调起抖动</li>
<li>再次经历解释执行、JIT编译再优化为编译版本的机器码执行</li>
</ol>
<p>从使用的表现来看，attach因为增强所有的classloader的那一瞬间CPU使用率确实会短暂飙升，出现服务抖动，所以在高并发的生产环境还是慎用。</p>
<p>感兴趣的读者可以移步了解该问题:Arthas attach 之后对原进程性能有多大的影响:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas%2Fissues%2F44" target="_blank" title="https://github.com/alibaba/arthas/issues/44" ref="nofollow noopener noreferrer">github.com/alibaba/art…</a></p>
<h2 data-id="heading-28">小结</h2>
<p>本文基于arthas 3.6.0源码针对arthas运行时增强技术进行深入分析，可以看到这个监控诊断工具利用了agent的attach进行运行时通过字节码进行通用的字节码修改增强，然后根据用户键入的指令获取对应监听器缓存到全局，在执行通用字节码即SpyAPI调用时就会定位到指定监听器完成响应的逻辑增强。</p>
<p>你好，我是 <strong>SharkChili</strong> ，禅与计算机程序设计艺术布道者，希望我的理念对您有所启发。</p>
<p><strong>📝 我的公众号：写代码的SharkChili</strong><br/>
在这里，我会分享技术干货、编程思考与开源项目实践。</p>
<p><strong>🚀 我的开源项目：mini-redis</strong><br/>
一个用于教学理解的 Redis 精简实现，欢迎 Star &amp; Contribute：<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fshark-ctrl%2Fmini-redis" target="_blank" title="https://github.com/shark-ctrl/mini-redis" ref="nofollow noopener noreferrer">github.com/shark-ctrl/…</a></p>
<p><strong>👥 欢迎加入读者群</strong><br/>
关注公众号，回复 <strong>【加群】</strong> 即可获取联系方式，期待与你交流技术、共同成长！</p>
<h2 data-id="heading-29">参考</h2>
<p>Arthas技术原理-源码调试环境搭建:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwanglikang.github.io%2F2024%2F08%2F03%2FArthas%25E6%258A%2580%25E6%259C%25AF%25E5%258E%259F%25E7%2590%2586-%25E6%25BA%2590%25E7%25A0%2581%25E8%25B0%2583%25E8%25AF%2595%25E7%258E%25AF%25E5%25A2%2583%25E6%2590%25AD%25E5%25BB%25BA%2F" target="_blank" title="https://wanglikang.github.io/2024/08/03/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" ref="nofollow noopener noreferrer">wanglikang.github.io/2024/08/03/…</a></p>
<p>深入剖析Arthas源码:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fbigcoder84%2Fp%2F18147350" target="_blank" title="https://www.cnblogs.com/bigcoder84/p/18147350" ref="nofollow noopener noreferrer">www.cnblogs.com/bigcoder84/…</a></p>
<p>Debug Arthas In IDEA :<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas%2Fissues%2F222" target="_blank" title="https://github.com/alibaba/arthas/issues/222" ref="nofollow noopener noreferrer">github.com/alibaba/art…</a></p>
<p>指定版本启动arthas:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas%2Fblob%2Fmaster%2FCONTRIBUTING.md" target="_blank" title="https://github.com/alibaba/arthas/blob/master/CONTRIBUTING.md" ref="nofollow noopener noreferrer">github.com/alibaba/art…</a></p>
<p>开源诊断利器Arthas ByteKit 深度解读(1)：基本原理介绍:<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fhengyunabc%2Farticle%2Fdetails%2F107398983" target="_blank" title="https://blog.csdn.net/hengyunabc/article/details/107398983" ref="nofollow noopener noreferrer">blog.csdn.net/hengyunabc/…</a></p>
<p>Java agent-05-Bytecode Kit-00-bytekit 入门介绍:<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F12979796066" target="_blank" title="https://zhuanlan.zhihu.com/p/12979796066" ref="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/129797960…</a></p>
<p>Java 程序的运行原理:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fluojw%2Fp%2F18112110" target="_blank" title="https://www.cnblogs.com/luojw/p/18112110" ref="nofollow noopener noreferrer">www.cnblogs.com/luojw/p/181…</a></p>
<p>Class VirtualMachine API官方文档:<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fjdk%2Fapi%2Fattach%2Fspec%2Fcom%2Fsun%2Ftools%2Fattach%2FVirtualMachine.html" target="_blank" title="https://docs.oracle.com/javase/8/docs/jdk/api/attach/spec/com/sun/tools/attach/VirtualMachine.html" ref="nofollow noopener noreferrer">docs.oracle.com/javase/8/do…</a></p>
<p>本文使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarkdown.com.cn" target="_blank" title="https://markdown.com.cn" ref="nofollow noopener noreferrer">markdown.com.cn</a> 排版</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面试题：ArrayList源码分析]]></title>    <link>https://juejin.cn/post/7587245616754491443</link>    <guid>https://juejin.cn/post/7587245616754491443</guid>    <pubDate>2025-12-24T12:51:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587245616754491443" data-draft-id="7208380301025067066" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面试题：ArrayList源码分析"/> <meta itemprop="keywords" content="面试,后端,Java"/> <meta itemprop="datePublished" content="2025-12-24T12:51:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="喝咖啡的工匠"/> <meta itemprop="url" content="https://juejin.cn/user/4459274892488461"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面试题：ArrayList源码分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4459274892488461/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    喝咖啡的工匠
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T12:51:20.000Z" title="Wed Dec 24 2025 12:51:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1 概述</h2>
<p>  <code>ArrayList</code>是基于数组实现的动态数组，内部使用一个Object类型的数组elementData来存储元素，同时还有一个整型变量size记录<code>ArrayList</code>中实际存储的元素个数。在添加元素时，如果元素个数已经达到数组的容量上限，<code>ArrayList</code>会自动进行扩容，以保证数组可以容纳更多元素。</p>
<p>  我们从以下几个方面对ArrayList的源码进行分析：</p>
<ol>
<li>ArrayList的核心字段</li>
<li>ArrayList的构造方法</li>
<li>ArrayList的添加元素</li>
<li>ArrayList的获取元素</li>
<li>ArrayList的替换元素</li>
<li>ArrayList的删除元素</li>
<li>ArrayList的判断是否包含某个元素</li>
<li>ArrayList的获取元素的下标</li>
<li>ArrayList的扩容机制</li>
<li>ArrayList的线程安全问题</li>
<li>ArrayList的基本介绍</li>
</ol>
<h2 data-id="heading-1">2 源码解析</h2>
<h3 data-id="heading-2">2.1 核心字段</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;
        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {
    <span class="hljs-comment">// 序列化版本 ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;
    <span class="hljs-comment">// 默认初始容量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;
    <span class="hljs-comment">// 空数组，用于初始化空的 ArrayList</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};
    <span class="hljs-comment">// 默认的空数组，用于初始化没有指定初始容量的 ArrayList</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    <span class="hljs-comment">// 存储元素的数组，transient 修饰表示该属性不会被序列化</span>
    <span class="hljs-keyword">transient</span> Object[] elementData;
    <span class="hljs-comment">// ArrayList 中元素的数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;

}
</code></pre>
<ul>
<li><code>DEFAULT_CAPACITY</code>：默认容量为10，也就是通过无惨构造函数创建时的默认容量。</li>
<li><code>EMPTY_ELEMENTDATA</code>：空数组，是用于空实例的共享空数组实例。</li>
<li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>：也是空数组，无惨构造函数就是用这个来初始化<code>ArrayList</code>的数组缓冲区；</li>
<li><code>elementData</code>：真正存放元素的地方，<code>ArrayList</code>元素的数组缓冲区。</li>
<li><code>size</code>：真正存储元素的个数，而不是elementData数组的长度</li>
</ul>
<h3 data-id="heading-3">2.2 构造函数</h3>
<p>  ArrayList提供了多个构造方法，其中包括无参构造方法和带参数的构造方法。无参构造方法将创建一个初始容量为0的空数组，而带参数的构造方法则可以指定初始容量.</p>
<p>  下面是ArrayList的构造方法的代码：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-comment">// 使用默认容量构造 ArrayList</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

<span class="hljs-comment">// 使用指定容量构造 ArrayList</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> {
    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Illegal Capacity: "</span> +
                                           initialCapacity);
    }
}

<span class="hljs-comment">// 使用另一个集合构造 ArrayList</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> {
    elementData = c.toArray();
    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 非空集合，将 elementData 转为 Object 数组</span>
        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 空集合，使用空数组</span>
        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;
    }
}


</code></pre>
<ul>
<li>
<p>ArrayList()：默认构造方法，创建一个空的<code>ArrayLis</code>t实例，<code>elementData</code>初始化为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
</li>
<li>
<p>ArrayList(int initialCapacity)：带有初始容量参数的构造方法，</p>
<ul>
<li>如果指定的initialCapacity大于0，则<code>elementData会</code>被初始化为一个指定大小的数组</li>
<li>如果initialCapacity等于0，则<code>elementData</code>被初始化为空数组；否则，抛出IllegalArgumentException异常。</li>
</ul>
</li>
<li>
<p>ArrayList(Collection&lt;? extends E&gt; c)：用另一个集合构造时，首先将集合转为数组，然后将数组赋值给 elementData。如果集合非空，那么将 elementData 数组转为 Object 数组；如果集合为空，那么直接使用空数组</p>
</li>
</ul>
<h3 data-id="heading-4">2.3 核心方法</h3>
<h4 data-id="heading-5">2.3.1 添加元素</h4>
<p>ArrayList提供了多个添加元素的方法，主要包括add(E e)和add(int index, E element)。在末尾添加元素：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {
    modCount++;
    add(e, elementData, size);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-type">int</span> s)</span> {
    <span class="hljs-keyword">if</span> (s == elementData.length)
        elementData = grow();
    elementData[s] = e;
    size = s + <span class="hljs-number">1</span>;
}
</code></pre>
<p>在指定位置插入元素：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> {
    rangeCheckForAdd(index);
    modCount++;
    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> s;
    Object[] elementData;
    <span class="hljs-keyword">if</span> ((s = size) == (elementData = <span class="hljs-built_in">this</span>.elementData).length)
        elementData = grow();
    System.arraycopy(elementData, index,
                     elementData, index + <span class="hljs-number">1</span>,
                     s - index);
    elementData[index] = element;
    size = s + <span class="hljs-number">1</span>;
}
</code></pre>
<ul>
<li><code>add(E e)</code>：在列表末尾添加元素，时间复杂度为O(1)（不考虑扩容）</li>
<li><code>add(int index, E element)</code>：在指定位置插入元素，需要移动后续元素，时间复杂度为O(n)</li>
<li><code>modCount</code>：记录结构性修改次数，用于迭代器的快速失败机制</li>
<li>插入前会检查容量，不足时触发扩容</li>
</ul>
<h4 data-id="heading-6">2.3.2 获取元素</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {
    Objects.checkIndex(index, size);
    <span class="hljs-keyword">return</span> elementData(index);
}

E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {
    <span class="hljs-keyword">return</span> (E) elementData[index];
}
</code></pre>
<p>要点说明：</p>
<ul>
<li>
<p>通过索引直接访问数组元素，时间复杂度O(1)。</p>
</li>
<li>
<p><code>Objects.checkIndex(index, size)</code>检查索引是否越界。</p>
</li>
<li>
<p>支持随机访问，实现了<code>RandomAccess</code>接口。</p>
</li>
</ul>
<h4 data-id="heading-7">2.3.3 替换元素</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> {

    Objects.checkIndex(index, size);

    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);

    elementData[index] = element;

    <span class="hljs-keyword">return</span> oldValue;

}
</code></pre>
<p>要点说明：</p>
<ul>
<li>替换指定位置的元素，时间复杂度O(1)。</li>
</ul>

<ul>
<li>返回被替换的旧元素。</li>
</ul>

<ul>
<li>会进行索引越界检查。</li>
</ul>
<h4 data-id="heading-8">2.3.4 删除元素</h4>
<p>ArrayList提供了两种删除方式：按索引删除和按元素删除。按索引删除：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {

    Objects.checkIndex(index, size);

    <span class="hljs-keyword">final</span> Object[] es = elementData;

    

    <span class="hljs-meta">@SuppressWarnings("unchecked")</span> <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) es[index];

    fastRemove(es, index);

    

    <span class="hljs-keyword">return</span> oldValue;

}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(Object[] es, <span class="hljs-type">int</span> i)</span> {

    modCount++;

    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> newSize;

    <span class="hljs-keyword">if</span> ((newSize = size - <span class="hljs-number">1</span>) &gt; i)

        System.arraycopy(es, i + <span class="hljs-number">1</span>, es, i, newSize - i);

    es[size = newSize] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 清除引用，帮助GC</span>

}
</code></pre>
<p>按元素删除：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> {

    <span class="hljs-keyword">final</span> Object[] es = elementData;

    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;

    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    found: {

        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {

            <span class="hljs-keyword">for</span> (; i &lt; size; i++)

                <span class="hljs-keyword">if</span> (es[i] == <span class="hljs-literal">null</span>)

                    <span class="hljs-keyword">break</span> found;

        } <span class="hljs-keyword">else</span> {

            <span class="hljs-keyword">for</span> (; i &lt; size; i++)

                <span class="hljs-keyword">if</span> (o.equals(es[i]))

                    <span class="hljs-keyword">break</span> found;

        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    }

    fastRemove(es, i);

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

}
</code></pre>
<p>要点说明：</p>
<ul>
<li>按索引删除：时间复杂度O(n)，需要移动后续元素。</li>
</ul>

<ul>
<li>按元素删除：先查找元素位置，再删除，时间复杂度O(n)。</li>
</ul>

<ul>
<li>删除后会将数组末尾元素置为null，帮助垃圾回收。</li>
</ul>

<ul>
<li>只删除第一个匹配的元素。</li>
</ul>
<h4 data-id="heading-9">2.3.5 判断是否包含某个元素</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> {

    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;

}
</code></pre>
<p>要点说明：</p>
<ul>
<li>通过indexOf方法实现，如果返回索引&gt;=0，说明包含该元素。</li>
</ul>

<ul>
<li>时间复杂度O(n)，需要遍历数组。</li>
</ul>
<h4 data-id="heading-10">2.3.6 获取元素的下标</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> {

    <span class="hljs-keyword">return</span> indexOfRange(o, <span class="hljs-number">0</span>, size);

}

<span class="hljs-type">int</span> <span class="hljs-title function_">indexOfRange</span><span class="hljs-params">(Object o, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {

    Object[] es = elementData;

    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) {

            <span class="hljs-keyword">if</span> (es[i] == <span class="hljs-literal">null</span>) {

                <span class="hljs-keyword">return</span> i;

            }

        }

    } <span class="hljs-keyword">else</span> {

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) {

            <span class="hljs-keyword">if</span> (o.equals(es[i])) {

                <span class="hljs-keyword">return</span> i;

            }

        }

    }

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

}

<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> {

    <span class="hljs-keyword">return</span> lastIndexOfRange(o, <span class="hljs-number">0</span>, size);

}
</code></pre>
<p>要点说明：</p>
<ul>
<li>indexOf：返回元素第一次出现的索引，未找到返回-1。</li>
</ul>

<ul>
<li>lastIndexOf：返回元素最后一次出现的索引。</li>
</ul>

<ul>
<li>时间复杂度O(n)。</li>
</ul>

<ul>
<li>对null值使用==比较，非null值使用equals比较。</li>
</ul>
<h4 data-id="heading-11">2.3.7 扩容机制</h4>
<p>扩容是ArrayList的核心机制，当数组容量不足时自动扩容。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> Object[] grow() {

    <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);

}

<span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-type">int</span> minCapacity) {

    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;

    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> ArraysSupport.newLength(oldCapacity,

            minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span>

            oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* preferred growth */</span>);

    <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> Arrays.copyOf(elementData, newCapacity);

}
</code></pre>
<p>扩容策略：</p>
<ul>
<li>
<p>默认扩容为原容量的1.5倍（oldCapacity + oldCapacity &gt;&gt; 1）。</p>
</li>
<li>
<p>如果1.5倍仍不足，则扩容到所需的最小容量。</p>
</li>
<li>
<p>使用<code>Arrays.copyOf</code>创建新数组并复制元素。</p>
</li>
<li>
<p>扩容操作时间复杂度O(n)。</p>
</li>
</ul>
<p>首次扩容的特殊处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> {

    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {

        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);

    }

    <span class="hljs-keyword">return</span> minCapacity;

}
</code></pre>
<ul>
<li>无参构造创建的ArrayList，首次添加元素时，如果所需容量小于10，会扩容到10。</li>
</ul>
<h4 data-id="heading-12">2.3.8 线程安全问题</h4>
<p>ArrayList不是线程安全的：</p>
<ul>
<li>
<p>多线程并发修改：多个线程同时调用add、remove等方法可能导致数据不一致。</p>
</li>
<li>
<p>迭代器快速失败：使用迭代器遍历时，如果其他线程修改了集合，会抛出<code>ConcurrentModificationException</code>。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>
<p>使用Collections.synchronizedList()：
<code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); </code></p>
</li>
<li>
<p>使用CopyOnWriteArrayList（适合读多写少场景）：<code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p>
</li>
<li>
<p>使用显式同步：</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">synchronized</span> (list) {

        list.add(element);

    }
</code></pre>
<h2 data-id="heading-13">3.总结</h2>
<ol>
<li>ArrayList作为Java集合框架中最常用的动态数组实现，具有以下特点：</li>
<li>动态扩容：ArrayList可以根据需要自动扩大其容量。当元素数量超过当前容量时，它会自动分配更多的内存来存储更多的元素。这样可以避免在添加元素时频繁进行数组拷贝，从而提高性能。默认扩容策略是扩容为原容量的1.5倍。</li>
<li>随机访问：ArrayList支持快速随机访问元素。由于ArrayList底层使用数组实现，因此可以通过索引直接访问数组中的元素，时间复杂度为O(1)。</li>
<li>元素允许为null：ArrayList允许元素为空（null），这意味着可以在ArrayList中添加null元素，并将其视为有效元素。</li>
<li>有序性：ArrayList以插入顺序来存储元素。这意味着元素将按照它们添加到ArrayList中的顺序进行存储，并且可以按照插入顺序迭代访问它们。</li>
<li>可以存储任何对象：ArrayList可以存储任何类型的对象。因为ArrayList是使用泛型实现的，所以可以在ArrayList中存储不同类型的元素，而不需要进行类型转换。</li>
<li>非线程安全：ArrayList不是线程安全的，在多线程环境下需要额外的同步机制。可以使用Collections.synchronizedList()或CopyOnWriteArrayList来实现线程安全。</li>
<li>插入和删除效率较低：在指定位置插入或删除元素时，需要移动后续元素，时间复杂度为O(n)。因此，如果需要频繁进行插入和删除操作，建议使用LinkedList。</li>
<li>内存连续：由于底层使用数组实现，ArrayList在内存中是连续存储的，这有利于CPU缓存，提高访问效率。</li>
</ol>
<p>适用场景：</p>
<ul>
<li>需要频繁随机访问元素</li>
<li>元素数量相对稳定，不需要频繁插入和删除</li>
<li>单线程环境或已做好同步控制的多线程环境</li>
</ul>
<p>不适用场景：</p>
<ul>
<li>需要频繁在中间位置插入或删除元素</li>
<li>多线程并发修改且未做同步控制</li>
<li>对内存使用有严格限制的场景</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[流程引擎、工作流、规则引擎、编排系统、表达式引擎……天呐，我到底该用哪个？]]></title>    <link>https://juejin.cn/post/7587299670642606086</link>    <guid>https://juejin.cn/post/7587299670642606086</guid>    <pubDate>2025-12-25T01:52:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587299670642606086" data-draft-id="7587349016221532201" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="流程引擎、工作流、规则引擎、编排系统、表达式引擎……天呐，我到底该用哪个？"/> <meta itemprop="keywords" content="后端,工作流引擎"/> <meta itemprop="datePublished" content="2025-12-25T01:52:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="踏浪无痕"/> <meta itemprop="url" content="https://juejin.cn/user/2834988091055719"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            流程引擎、工作流、规则引擎、编排系统、表达式引擎……天呐，我到底该用哪个？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2834988091055719/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    踏浪无痕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-25T01:52:10.000Z" title="Thu Dec 25 2025 01:52:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-25
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">你是不是也有这些困惑</h2>
<p>看项目文档，各种名词扑面而来：</p>
<ul>
<li>流程引擎（Flowable、Camunda）</li>
<li>工作流（Activiti）</li>
<li>规则引擎（Drools）</li>
<li>编排系统（LiteFlow）</li>
<li>表达式引擎（QLExpress、Aviator）</li>
<li>DAG调度（Airflow、DolphinScheduler）</li>
<li>任务编排（Temporal、Conductor）</li>
<li>BPMN、Saga、Event-Driven...</li>
</ul>
<p>每个框架都说自己能解决问题，每个概念看起来都差不多。</p>
<p>新手一脸懵逼，老手也经常搞混。</p>
<p>干了20年，我也被这些东西搞晕过。今天不讲那些虚的，直接告诉你怎么选。</p>
<p>答案很简单：别管这些名词，问自己四个问题就够了。</p>
<h2 data-id="heading-1">忘掉那些名词，只问四个问题</h2>
<p>看了一堆框架介绍还是不知道选哪个？正常，因为你在纠结概念。</p>
<p>别纠结了，概念都是虚的。问自己四个问题，立刻就清楚了。</p>
<h3 data-id="heading-2">问题1：你是要干活，还是改状态？</h3>
<p>这是最关键的一个问题。搞清楚这个，一大半框架就排除了。</p>
<p><strong>改状态是什么意思？</strong></p>
<pre><code class="hljs language-diff" lang="diff">请假审批：
员工提交 → 主管看了说"行" → HR看了说"行" → 完成

整个过程：
<span class="hljs-deletion">- 没有计算</span>
<span class="hljs-deletion">- 没有数据转换</span>
<span class="hljs-deletion">- 没有调用外部系统</span>
<span class="hljs-deletion">- 就是状态从 pending 变成 approved</span>

这就是纯改状态。
</code></pre>
<p><strong>干活是什么意思？</strong></p>
<pre><code class="hljs language-diff" lang="diff">订单处理：
下单 → 扣库存 → 调支付接口 → 调物流接口 → 发货

整个过程：
<span class="hljs-deletion">- 要计算金额</span>
<span class="hljs-deletion">- 要调用外部API</span>
<span class="hljs-deletion">- 要处理数据</span>
<span class="hljs-deletion">- 要执行业务逻辑</span>

这就是干活。
</code></pre>
<p><strong>判断标准：</strong></p>
<ul>
<li>改状态：就是让人点"同意"或"拒绝"，除了改个字段，啥也没干</li>
<li>干活：要计算、要调API、要处理数据</li>
</ul>
<p><strong>对应框架：</strong></p>
<ul>
<li>改状态 → BPMN系（Flowable、Camunda）</li>
<li>干活 → 继续往下判断</li>
</ul>
<h3 data-id="heading-3">问题2：主要是人处理，还是机器执行？</h3>
<p><strong>人处理：</strong></p>
<pre><code class="hljs language-diff" lang="diff">审批流程：
<span class="hljs-deletion">- 主管要看文档</span>
<span class="hljs-deletion">- 主管要做判断</span>
<span class="hljs-deletion">- 主管要点按钮</span>
<span class="hljs-deletion">- 然后等下一个人</span>

特点：大部分时间在等人
</code></pre>
<p><strong>机器执行：</strong></p>
<pre><code class="hljs language-diff" lang="diff">数据处理：
<span class="hljs-deletion">- 读数据库</span>
<span class="hljs-deletion">- 清洗数据</span>
<span class="hljs-deletion">- 转换格式</span>
<span class="hljs-deletion">- 写入目标表</span>

特点：机器自己跑，不用人管
</code></pre>
<p><strong>对应框架：</strong></p>
<ul>
<li>人为主 → BPMN系（Flowable、Camunda）</li>
<li>机器为主 → 继续往下判断</li>
</ul>
<h3 data-id="heading-4">问题3：是本地方法，还是跨系统调用？</h3>
<p><strong>本地方法：</strong></p>
<pre><code class="hljs language-diff" lang="diff">营销规则：
<span class="hljs-deletion">- 判断用户是不是VIP</span>
<span class="hljs-deletion">- 计算折扣</span>
<span class="hljs-deletion">- 返回结果</span>

都在一个应用里，不用调外部接口
</code></pre>
<p><strong>跨系统调用：</strong></p>
<pre><code class="hljs language-diff" lang="diff">订单流程：
<span class="hljs-deletion">- 调库存系统（HTTP）</span>
<span class="hljs-deletion">- 调支付系统（HTTP）</span>
<span class="hljs-deletion">- 调物流系统（HTTP）</span>

要跨多个服务
</code></pre>
<p><strong>对应框架：</strong></p>
<ul>
<li>本地 → 表达式系、脚本系（QLExpress、LiteFlow）</li>
<li>跨系统 → DAG系、服务编排系（Airflow、Temporal）</li>
</ul>
<h3 data-id="heading-5">问题4：自己玩，还是要搞生态？</h3>
<p><strong>自己玩：</strong></p>
<pre><code class="hljs language-diff" lang="diff">你的团队自己维护：
<span class="hljs-deletion">- 规则你们自己写</span>
<span class="hljs-deletion">- 代码你们自己改</span>
<span class="hljs-deletion">- 不需要外部开发者</span>
</code></pre>
<p><strong>搞生态：</strong></p>
<pre><code class="hljs language-diff" lang="diff">做平台，让别人扩展：
<span class="hljs-deletion">- 客户可以上传插件</span>
<span class="hljs-deletion">- 第三方可以写脚本</span>
<span class="hljs-deletion">- 需要沙箱隔离</span>
</code></pre>
<p><strong>对应技术：</strong></p>
<ul>
<li>自己玩 → 表达式 + 代码（QLExpress、Aviator）</li>
<li>搞生态 → Groovy脚本、插件机制</li>
</ul>
<h2 data-id="heading-6">那些让人头疼的框架，到底是干什么的</h2>
<p>四个问题问完，你大概知道方向了。现在看看具体框架都是什么情况。</p>
<p>不用全看，只看和你匹配的那一类就行。</p>
<h3 data-id="heading-7">BPMN系：Flowable、Camunda、Activiti</h3>
<p><strong>适合场景：</strong></p>
<ul>
<li>纯人工审批流程</li>
<li>需要流程图可视化</li>
<li>需要历史记录追溯</li>
<li>大公司、强合规要求</li>
</ul>
<p><strong>典型例子：</strong></p>
<ul>
<li>请假审批</li>
<li>报销审批</li>
<li>合同审批</li>
<li>采购流程</li>
</ul>
<p><strong>核心特点：</strong></p>
<ul>
<li>本质就是改状态</li>
<li>大部分时间在等人</li>
<li>业务价值为0（只是流程管理）</li>
<li>技术难度不高（就是状态机）</li>
</ul>
<p><strong>什么时候用：</strong></p>
<ul>
<li>大公司（100+人），有几十个审批流程要管理</li>
<li>金融、政府等强合规行业</li>
<li>需要标准化流程管理</li>
</ul>
<p><strong>什么时候别用：</strong></p>
<ul>
<li>小公司（别用，钉钉审批就够了）</li>
<li>没有复杂审批需求（自己写100行代码搞定）</li>
<li>为了"企业级"而用（过度设计）</li>
</ul>
<h3 data-id="heading-8">DAG系：Airflow、DolphinScheduler、Prefect</h3>
<p><strong>适合场景：</strong></p>
<ul>
<li>数据处理任务</li>
<li>离线批处理</li>
<li>定时调度</li>
<li>任务有依赖关系</li>
</ul>
<p><strong>典型例子：</strong></p>
<ul>
<li>数据ETL</li>
<li>报表生成</li>
<li>数据清洗</li>
<li>机器学习Pipeline</li>
</ul>
<p><strong>核心特点：</strong></p>
<ul>
<li>纯机器执行</li>
<li>长时间运行（小时、天级）</li>
<li>任务之间有依赖（A完成才能B）</li>
<li>需要调度和监控</li>
</ul>
<p><strong>什么时候用：</strong></p>
<ul>
<li>数据团队做离线处理</li>
<li>有复杂的任务依赖关系</li>
<li>需要定时调度（每天、每周）</li>
</ul>
<p><strong>什么时候别用：</strong></p>
<ul>
<li>实时性要求高的（秒级响应）</li>
<li>简单的定时任务（用Cron就够了）</li>
<li>没有依赖关系的任务</li>
</ul>
<h3 data-id="heading-9">表达式/脚本系：QLExpress、Aviator、LiteFlow、Groovy</h3>
<p><strong>适合场景：</strong></p>
<ul>
<li>规则计算</li>
<li>业务流程编排</li>
<li>本地方法调用</li>
<li>需要动态配置</li>
</ul>
<p><strong>典型例子：</strong></p>
<ul>
<li>营销活动规则（满减、折扣）</li>
<li>风控规则（黑名单、评分）</li>
<li>订单流程（本地编排）</li>
<li>积分计算</li>
</ul>
<p><strong>QLExpress / Aviator（表达式）：</strong></p>
<ul>
<li>优点：性能好、类Java语法、团队容易上手</li>
<li>缺点：功能受限、只能简单计算</li>
<li>适合：自己团队玩、简单规则</li>
</ul>
<p><strong>Groovy（脚本）：</strong></p>
<ul>
<li>优点：功能完整、可以调复杂API</li>
<li>缺点：性能差、调试难、类型不安全</li>
<li>适合：要搞插件生态、客户自定义逻辑</li>
</ul>
<p><strong>LiteFlow（编排）：</strong></p>
<ul>
<li>优点：可视化编排、组件复用</li>
<li>缺点：学习成本、维护成本</li>
<li>适合：流程确实复杂、经常变化</li>
</ul>
<p><strong>什么时候用：</strong></p>
<ul>
<li>规则经常变（不想每次改代码发版）</li>
<li>流程需要配置化</li>
<li>有一定复杂度（10+个分支）</li>
</ul>
<p><strong>什么时候别用：</strong></p>
<ul>
<li>简单的if-else（直接写代码）</li>
<li>流程固定不变（没必要配置化）</li>
<li>为了"灵活"而牺牲性能</li>
</ul>
<h3 data-id="heading-10">服务编排系：Temporal、Cadence、Conductor</h3>
<p><strong>适合场景：</strong></p>
<ul>
<li>微服务编排</li>
<li>分布式事务</li>
<li>长时间运行的业务流程</li>
<li>需要补偿机制</li>
</ul>
<p><strong>典型例子：</strong></p>
<ul>
<li>订单流程（支付 → 发货 → 签收）</li>
<li>旅游预订（机票 + 酒店 + 门票）</li>
<li>跨系统流程</li>
<li>Saga模式</li>
</ul>
<p><strong>核心特点：</strong></p>
<ul>
<li>支持长时间运行（天级）</li>
<li>支持失败重试</li>
<li>支持补偿逻辑</li>
<li>状态持久化</li>
</ul>
<p><strong>什么时候用：</strong></p>
<ul>
<li>微服务架构，需要编排多个服务</li>
<li>需要分布式事务</li>
<li>流程可能运行很久（几小时、几天）</li>
</ul>
<p><strong>什么时候别用：</strong></p>
<ul>
<li>单体应用（没有跨服务需求）</li>
<li>简单的API调用（直接用HTTP就行）</li>
<li>实时性要求极高的（毫秒级）</li>
</ul>
<h2 data-id="heading-11">懒得看？直接照这个选</h2>
<p>如果你嫌上面内容太多，直接看这个决策树。</p>
<p>跟着问题一步步走，到底了就知道该用什么。</p>
<pre><code class="hljs">开始
  ↓
主要是人审批吗？
  ↓ 是
  用 Flowable/Camunda（大公司）或钉钉审批（小公司）
  
  ↓ 否
是长时间运行的任务吗（&gt;10分钟）？
  ↓ 是
  用 Airflow/DolphinScheduler
  
  ↓ 否
需要跨系统调用吗？
  ↓ 是
  用 Temporal/Conductor（微服务）或 Airflow（数据处理）
  
  ↓ 否
逻辑很复杂吗（&gt;10个分支）？
  ↓ 是
  用 LiteFlow（编排）或 QLExpress（规则）
  
  ↓ 否
需要频繁修改规则吗？
  ↓ 是
  用 QLExpress/Aviator
  
  ↓ 否
直接写代码！
</code></pre>
<h2 data-id="heading-12">具体场景怎么选</h2>
<p>理论说完了，看几个实际例子。看看你的场景和哪个像。</p>
<h3 data-id="heading-13">场景1：请假审批</h3>
<p><strong>特征：</strong></p>
<ul>
<li>纯人工审批</li>
<li>状态流转</li>
<li>需要历史记录</li>
</ul>
<p><strong>选型：</strong></p>
<ul>
<li>小公司：钉钉/企业微信审批</li>
<li>大公司：Flowable/Camunda</li>
<li>自己开发：状态机 + 数据库</li>
</ul>
<h3 data-id="heading-14">场景2：电商订单流程</h3>
<p><strong>特征：</strong></p>
<ul>
<li>要调支付、库存、物流接口</li>
<li>有失败重试和补偿</li>
<li>短事务（分钟级）</li>
</ul>
<p><strong>选型：</strong></p>
<ul>
<li>复杂场景：Temporal/Cadence</li>
<li>简单场景：LiteFlow + 消息队列</li>
<li>最简单：直接写代码 + 状态机</li>
</ul>
<h3 data-id="heading-15">场景3：数据ETL</h3>
<p><strong>特征：</strong></p>
<ul>
<li>纯机器执行</li>
<li>长时间运行</li>
<li>任务有依赖</li>
</ul>
<p><strong>选型：</strong></p>
<ul>
<li>标准方案：Airflow/DolphinScheduler</li>
<li>简单场景：XXL-Job</li>
</ul>
<h3 data-id="heading-16">场景4：营销活动规则</h3>
<p><strong>特征：</strong></p>
<ul>
<li>规则计算</li>
<li>经常变化</li>
<li>本地方法</li>
</ul>
<p><strong>选型：</strong></p>
<ul>
<li>简单规则：QLExpress/Aviator</li>
<li>复杂规则：Drools</li>
<li>有编排需求：LiteFlow</li>
</ul>
<h2 data-id="heading-17">很多人踩过的坑</h2>
<p>说几个常见的错误，别重复踩坑。</p>
<h3 data-id="heading-18">误区1：追求"企业级架构"</h3>
<pre><code class="hljs">错误做法：
20人的创业公司，上了Flowable、Camunda、Airflow一整套

正确做法：
能用100行代码解决就别上框架
</code></pre>
<h3 data-id="heading-19">误区2：为了灵活性而牺牲性能</h3>
<pre><code class="hljs">错误做法：
所有逻辑都用Groovy脚本，方便修改

正确做法：
核心逻辑用Java写，只把经常变的部分配置化
</code></pre>
<h3 data-id="heading-20">误区3：过度抽象</h3>
<pre><code class="hljs language-arduino" lang="arduino">错误做法：
<span class="hljs-number">3</span>个简单流程，非要搞个<span class="hljs-string">"流程引擎"</span>

正确做法：
<span class="hljs-number">3</span>个流程就<span class="hljs-number">3</span>个方法，直接写代码
</code></pre>
<h3 data-id="heading-21">误区4：混淆概念</h3>
<pre><code class="hljs language-arduino" lang="arduino">错误理解：
<span class="hljs-string">"我需要流程编排，所以要用Flowable"</span>

正确理解：
先搞清楚你要干活还是改状态
是人审批还是机器执行
</code></pre>
<h2 data-id="heading-22">几句大实话</h2>
<p>最后说几句掏心窝的话。</p>
<h3 data-id="heading-23">1. 先用最简单的方案</h3>
<pre><code class="hljs language-erlang" lang="erlang">遇到问题：
第一反应不是<span class="hljs-string">"上框架"</span>
而是<span class="hljs-string">"能不能写100行代码搞定"</span>

<span class="hljs-number">90</span><span class="hljs-comment">%的情况，100行代码就够了</span>
</code></pre>
<h3 data-id="heading-24">2. 遇到瓶颈再优化</h3>
<pre><code class="hljs">流程很乱了 → 重构代码
改动很频繁 → 考虑配置化
管理不过来 → 考虑框架

别提前优化
</code></pre>
<h3 data-id="heading-25">3. 根据团队规模选择</h3>
<pre><code class="hljs language-diff" lang="diff">小团队（&lt;20人）：
<span class="hljs-deletion">- 能不用框架就不用</span>
<span class="hljs-deletion">- 钉钉审批、Cron、直接写代码</span>

中等团队（20-100人）：
<span class="hljs-deletion">- 流程&lt;10个：自己写</span>
<span class="hljs-deletion">- 流程&gt;10个：考虑轻量级框架</span>

大团队（&gt;100人）：
<span class="hljs-deletion">- 需要标准化管理</span>
<span class="hljs-deletion">- 可以考虑成熟框架</span>
</code></pre>
<h3 data-id="heading-26">4. 看业务特点</h3>
<pre><code class="hljs language-diff" lang="diff">强合规（金融、政府）：
<span class="hljs-deletion">- 必须用标准化工具</span>
<span class="hljs-deletion">- Flowable是选择之一</span>

数据密集：
<span class="hljs-deletion">- Airflow是标准方案</span>

微服务架构：
<span class="hljs-deletion">- Temporal值得考虑</span>

简单CRUD：
<span class="hljs-deletion">- 别折腾，写代码</span>
</code></pre>
<h2 data-id="heading-27">说到底，就这么点事</h2>
<p>看完还觉得复杂？那就记住这四个问题：</p>
<ol>
<li>干活还是改状态？</li>
<li>人为主还是机器为主？</li>
<li>本地方法还是跨系统？</li>
<li>自己玩还是搞生态？</li>
</ol>
<p>四个问题问完，基本就知道该用什么了。</p>
<p>那些"企业级"、"先进架构"、"灵活扩展"的词，都是包装。</p>
<p>看透本质，别被忽悠。</p>
<p>能用100行代码解决的，就别上框架。</p>
<p>技术是为业务服务的，不是为了炫技。</p>
<p>务实点，别整那些虚的。</p>
<p>就这样。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Stream是怎么运行的？]]></title>    <link>https://juejin.cn/post/7587239837973184563</link>    <guid>https://juejin.cn/post/7587239837973184563</guid>    <pubDate>2025-12-24T13:43:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587239837973184563" data-draft-id="7587254134401155081" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Stream是怎么运行的？"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-12-24T13:43:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="再来一根辣条"/> <meta itemprop="url" content="https://juejin.cn/user/3625525962110588"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Stream是怎么运行的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3625525962110588/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    再来一根辣条
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T13:43:15.000Z" title="Wed Dec 24 2025 13:43:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>先看这段样例代码：</p>
<pre><code class="hljs language-java" lang="java">        <span class="hljs-type">var</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();
        al.add(<span class="hljs-string">"Hello"</span>);
        al.add(<span class="hljs-string">"world"</span>);
        al.stream().map(String::toUpperCase).forEach(System.out::println);
</code></pre>
<h2 data-id="heading-0">1 创建流</h2>
<p>样例代码创建一个 <code>ArrayList</code>​ 实例，并将其转化为流进行数据处理。<code>stream()</code>​ 方法源自 <code>Collection</code> 接口。自 Java 8 起，该接口为适配 Stream 新增了几个转换方法。</p>
<p>代码1-1：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);
    }
    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);
    }
	<span class="hljs-comment">// 这是继承自 Iterable 接口的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);
    }

</code></pre>
<p>为保持向后兼容，这些新增方法均提供了默认实现。<code>java.util.stream.StreamSupport</code>​ 是操作流的工具类，该类在 Stream 内部代码中被频繁使用，但通常的业务代码无需直接调用。至于其中调用的 <code>spliterator()</code> 方法，则引入了一个新概念。</p>
<h3 data-id="heading-1">1.1 Spliterator</h3>
<p>“拆分器”（本文使用译名）以接口形式出现，<code>java.util.Spliterator</code>。官方文档对此接口说明为：</p>
<blockquote>
<p>用于遍历和分割源元素的对象。Spliterator 所覆盖元素的源可以是数组、集合、IO 通道或生成函数。</p>
<p>拆分器可逐个遍历元素（<code>tryAdvance()</code>​ ），也可批量顺序遍历（<code>forEachRemaining()</code>）。</p>
</blockquote>
<p>主要方法有，代码1-2：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Spliterator</span>&lt;T&gt; {
	<span class="hljs-comment">// 消费拆分器中一个元素</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span>;

	<span class="hljs-comment">// 消费拆分器中剩余所有元素</span>
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> {
        <span class="hljs-keyword">do</span> { } <span class="hljs-keyword">while</span> (tryAdvance(action));
    }
	
	<span class="hljs-comment">// 分出自身部分元素到一个新实例</span>
    Spliterator&lt;T&gt; <span class="hljs-title function_">trySplit</span><span class="hljs-params">()</span>;

	<span class="hljs-comment">// 当前拆分器中预估元素数量</span>
    <span class="hljs-type">long</span> <span class="hljs-title function_">estimateSize</span><span class="hljs-params">()</span>;

    <span class="hljs-keyword">default</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getExactSizeIfKnown</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> (characteristics() &amp; SIZED) == <span class="hljs-number">0</span> ? -<span class="hljs-number">1L</span> : estimateSize();
    }

	<span class="hljs-comment">// 当前拆分器的 特质</span>
    <span class="hljs-type">int</span> <span class="hljs-title function_">characteristics</span><span class="hljs-params">()</span>;
}
</code></pre>
<p>特别地，拆分器的特质是通过一组二进制位（如 <code>ORDERED</code>​、<code>DISTINCT</code>​、<code>SORTED</code> 等）来表示当前数据集的一些特性，这部分计算较为复杂，本文不作深入探讨。</p>
<p>​<code>Iterable</code>​ 接口自 Java 8 起新增了 <code>spliterator()</code> 方法，实现了从“迭代器”到“拆分器”的转换。其默认实现如代码1-3所示：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);
    }
</code></pre>
<p>​<code>Spliterators</code>​ 是一个用于操作或创建拆分器的工具类，通常业务代码中不会直接使用。尽管接口提供了默认实现，但 JDK 中每个具体的集合类型都会根据自身特点重写此方法。这里以最熟悉的 <code>ArrayList</code> 为例，观察其拆分器的工作方式，如代码1-4所示：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayListSpliterator</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListSpliterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Spliterator</span>&lt;E&gt; {
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// current index, modified on advance/split</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> fence; <span class="hljs-comment">// -1 until used; then one past last index</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedModCount; <span class="hljs-comment">// initialized when fence set</span>

        ArrayListSpliterator(<span class="hljs-type">int</span> origin, <span class="hljs-type">int</span> fence, <span class="hljs-type">int</span> expectedModCount) {
            <span class="hljs-built_in">this</span>.index = origin;
            <span class="hljs-built_in">this</span>.fence = fence;
            <span class="hljs-built_in">this</span>.expectedModCount = expectedModCount;
        }
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFence</span><span class="hljs-params">()</span> { <span class="hljs-comment">// initialize fence to size on first use</span>
            <span class="hljs-type">int</span> hi; <span class="hljs-comment">// (a specialized variant appears in method forEach)</span>
            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) {
                expectedModCount = modCount;
                hi = fence = size;
            }
            <span class="hljs-keyword">return</span> hi;
        }
        <span class="hljs-keyword">public</span> ArrayListSpliterator <span class="hljs-title function_">trySplit</span><span class="hljs-params">()</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> (lo &gt;= mid) ? <span class="hljs-literal">null</span> : <span class="hljs-comment">// divide range in half unless too small</span>
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayListSpliterator</span>(lo, index = mid, expectedModCount);
        }
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> {
            <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
            <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> getFence(), i = index;
            <span class="hljs-keyword">if</span> (i &lt; hi) {
                index = i + <span class="hljs-number">1</span>;
                <span class="hljs-meta">@SuppressWarnings("unchecked")</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E)elementData[i];
                action.accept(e);
                <span class="hljs-keyword">if</span> (modCount != expectedModCount)
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
	}
</code></pre>
<p>​<code>ArrayListSpliterator</code>​ 类的实现基于二分查找的思想。<code>index</code>​ 可理解为起始位置索引，<code>fence</code>​ 可理解为结束位置索引，<code>expectedModCount</code>​ 则记录了 <code>ArrayList</code>​ 中用于快速失败检测的 <code>modCount</code>​ 变量的值。<code>getFence</code>​ 方法的作用是初始化 <code>fence</code>​ 和 <code>expectedModCount</code>。</p>
<p>​<code>trySplit</code> 方法对指定范围内的元素进行二分。具体过程可通过以下代码演示：</p>
<pre><code class="hljs language-java" lang="java">        <span class="hljs-type">var</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));
        <span class="hljs-type">var</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> al.spliterator();  <span class="hljs-comment">// 3 4 5 </span>
        <span class="hljs-type">var</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> s0.trySplit(); <span class="hljs-comment">// 2</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.trySplit(); <span class="hljs-comment">// 1</span>
</code></pre>
<p>​<code>s0</code>​ 最初从 <code>al</code>​ 中获取全部元素，调用一次 <code>trySplit</code>​ 方法后，将元素 <code>1, 2</code>​ 分配给了变量 <code>s1</code>​。变量 <code>s1</code>​ 再次调用 <code>trySplit</code>​ 方法，将元素 <code>1</code>​ 分配给了变量 <code>s2</code>​。对于单元大小的拆分器（如 <code>s1</code>​、<code>s2</code>​），再次调用 <code>trySplit</code>​ 方法将返回 <code>null</code>。</p>
<p>​<code>ArrayList</code>​ 的 <code>forEachRemaining</code> 方法基于数组索引实现，其效果与接口的默认实现一致，此处不再赘述。</p>
<blockquote>
<p>[!IMPORTANT] ❗ 注意
拆分器只能遍历一次，即读指针只能向前走，没重置读指针位置的方法。</p>
</blockquote>
<p>后续看到<code>Spliterator</code>​相关的代码，基本可以简单理解为“数据源”，例如在样例代码中它就代表<code>ArrayList</code>实例。</p>
<h2 data-id="heading-2">2 操作流水线</h2>
<p>在开头的样例代码中，我们使用 <code>map(String::toUpperCase)</code>​ 来操作数据。<code>String::toUpperCase</code>​ 是 Java 中的方法引用，作用是将字符串转换为大写形式。而 <code>map</code> 方法则是 Stream 接收数据处理逻辑的入口。接下来，我们将探究数据的“操作”是如何被处理的。</p>
<p>至于为什么选择这四个类型，官方的解释是：Java 中的其他类型都可以转化为这四个类型，从而在效率与代码优雅之间取得平衡。换句话说，如果一个接口需要为所有类型都编写独立的实现，那得写9份看起来有点🤪。</p>
<p>对于样例代码来说，<code>java.util.stream.Stream#map</code>​ 方法的实现可以在<code>ReferencePipeline</code>类中找到。</p>
<h3 data-id="heading-3">2.1 ReferencePipeline 特化类</h3>
<p>​<code>ReferencePipeline</code>​ 类对应引用类型的特化实现，通常业务代码中也是这个类运行得最多。其 <code>map</code> 方法的实现如代码2-1所示：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> P_OUT, ? extends R&gt; mapper)</span> {
        Objects.requireNonNull(mapper);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="hljs-built_in">this</span>, StreamShape.REFERENCE,
                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            <span class="hljs-meta">@Override</span>
            Sink&lt;P_OUT&gt; <span class="hljs-title function_">opWrapSink</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, Sink&lt;R&gt; sink)</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(P_OUT u)</span> {
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        };
    }
</code></pre>
<p>可以看到，我们传入的“操作”逻辑被包装进一个 <code>StatelessOp</code> 类实例并返回。</p>
<h4 data-id="heading-4">2.1.1 StatelessOp类</h4>
<p>​<code>StatelessOp</code>​ 类，顾名思义，代表无状态操作，它是 <code>ReferencePipeline</code>​ 的一个内部类。很容易联想到，应该还有表示有状态操作的类：<code>StatefulOp</code>。有状态计算较为复杂，本文不会涉及，主要关注无状态计算的情况。</p>
<blockquote>
<p>[!TIP]
无状态：元素处理互不依赖；有状态：需要知道其他元素的信息，如<code>sorted</code>。</p>
</blockquote>
<p>​<code>StatelessOp</code> 类的继承关系，图2-1：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">classDiagram
    class PipelineHelper {
        &lt;&gt;
    }
    
    class BaseStream~T, S~ {
        &lt;&gt;
    }
    
    class AbstractPipeline~E_IN, E_OUT, S~ {
        &lt;&gt;
    }
    
    class ReferencePipeline~P_IN, P_OUT~ {
        &lt;&gt;
    }
    
    class StatelessOp~E_IN, E_OUT~ {
        &lt;&gt;
        &lt;&gt;
    }
    
    class Stream~T~ {
        &lt;&gt;
    }
    
    PipelineHelper &lt;|-- AbstractPipeline : 继承
    BaseStream &lt;|.. AbstractPipeline : 实现
    BaseStream &lt;|.. Stream : 继承
    Stream &lt;|.. ReferencePipeline : 实现
    AbstractPipeline &lt;|-- ReferencePipeline : 继承
    ReferencePipeline &lt;|-- StatelessOp : 继承
    
</code></pre>
<p>这个继承关系很重要，后面需要不时回顾。</p>
<p>​<code>StatelessOp</code> 类的声明，代码2-2：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatelessOp</span>&lt;E_IN, E_OUT&gt;
            <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReferencePipeline</span>&lt;E_IN, E_OUT&gt; {
        StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,
                    StreamShape inputShape,
                    <span class="hljs-type">int</span> opFlags) {
            <span class="hljs-built_in">super</span>(upstream, opFlags);
            <span class="hljs-keyword">assert</span> upstream.getOutputShape() == inputShape;
        }
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">opIsStateful</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
</code></pre>
<p>​<code>StreamShape</code>​ 是一个枚举，列举了前面提到的四种数据类型，用于表示当前数据流中的元素类型。<code>StreamOpFlag</code>​ 也是一个枚举（其注释远比代码丰富），用于表示数据流的各种特质。至于代码2-1中实现的 <code>opWrapSink</code>​ 方法，则定义在其父类 <code>AbstractPipeline</code> 中，如代码2-3所示：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">abstract</span> Sink&lt;E_IN&gt; <span class="hljs-title function_">opWrapSink</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, Sink&lt;E_OUT&gt; sink)</span>;
</code></pre>
<p>此方法的具体作用我们稍后再谈。接下来，让我们看看 <code>Sink.ChainedReference</code> 类。</p>
<h3 data-id="heading-5">2.2 Sink</h3>
<p>Sink这个词数据处理相关的程序中拿来作术语（flink中也有），动词形式有“下沉; 坐下; 减弱; 挖掘; 使受挫; 击球入洞; 灌”等意思；名词形式常为“洗涤池”之意。在数据处理中，这个词代表的概念常是数据处理的最后一步。</p>
<p>​<code>java.util.stream.Sink</code>​接口是增强版的<code>Consumer</code>（消费者），负责流中“消费”或“处理”数据，代码2-4：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sink</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; {
	<span class="hljs-comment">// 在开始处理数据元素之前被调用。用于进行一些初始化工作（例如，提前分配一个合适大小的数组）</span>
	<span class="hljs-comment">// -1 表示无法预估大小</span>
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">long</span> size)</span> {}
	<span class="hljs-comment">// 在所有数据元素都被处理完毕之后被调用。用于执行最终的清理或计算工作。</span>
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> {}
	<span class="hljs-comment">// 这是一个短路判断机制。在处理每个元素之前，流框架会询问这个 Sink：“是否需要取消后续处理？”</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancellationRequested</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
	<span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Java Stream中所有对数据的操作几乎都与此接口相关。它内部也有对四个类型实现的内部类，上文用到的<code>Sink.ChainedReference</code>类就是其中之一。</p>
<p>​<code>Sink.ChainedReference</code>类部分代码如下，代码2-5：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sink</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; {
	<span class="hljs-comment">// ... </span>
	
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainedReference</span>&lt;T, E_OUT&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sink</span>&lt;T&gt; {
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Sink&lt;? <span class="hljs-built_in">super</span> E_OUT&gt; downstream;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChainedReference</span><span class="hljs-params">(Sink&lt;? <span class="hljs-built_in">super</span> E_OUT&gt; downstream)</span> {
            <span class="hljs-built_in">this</span>.downstream = Objects.requireNonNull(downstream);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">long</span> size)</span> {
            downstream.begin(size);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> {
            downstream.end();
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancellationRequested</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> downstream.cancellationRequested();
        }
    }
}
</code></pre>
<p>结合代码2-1来看，我们传入的操作逻辑（即 <code>String::toUpperCase</code>​ 方法）被放置在了 <code>Consumer#accept</code> 方法的实现内部，将在后续的某个时刻被触发调用。</p>
<h3 data-id="heading-6">2.3 流水线的构成</h3>
<p>结合代码2-1和代码2-2，当前（<code>ReferencePipeline</code>​类）实例由构方法传入到父构造器中，通过层层调用最后回到<code>AbstractPipeline</code>类（回顾图2-1）。涉及此类的两个构造器方法，代码2-5：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-comment">// Constructor for the head of a stream pipeline.</span>
	AbstractPipeline(Spliterator&lt;?&gt; source,
                     <span class="hljs-type">int</span> sourceFlags, <span class="hljs-type">boolean</span> parallel) {
        <span class="hljs-built_in">this</span>.previousStage = <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">this</span>.sourceSpliterator = source;
        <span class="hljs-built_in">this</span>.sourceStage = <span class="hljs-built_in">this</span>;
        <span class="hljs-built_in">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;
        <span class="hljs-comment">// The following is an optimization of:</span>
        <span class="hljs-comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span>
        <span class="hljs-built_in">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="hljs-number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;
        <span class="hljs-built_in">this</span>.depth = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">this</span>.parallel = parallel;
    }
	<span class="hljs-comment">// Constructor for appending an intermediate operation stage onto an existing pipeline.</span>
    AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="hljs-type">int</span> opFlags) {
        <span class="hljs-keyword">if</span> (previousStage.linkedOrConsumed)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);
        previousStage.linkedOrConsumed = <span class="hljs-literal">true</span>;
        previousStage.nextStage = <span class="hljs-built_in">this</span>;

        <span class="hljs-built_in">this</span>.previousStage = previousStage;
        <span class="hljs-built_in">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;
        <span class="hljs-built_in">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
        <span class="hljs-built_in">this</span>.sourceStage = previousStage.sourceStage;
        <span class="hljs-keyword">if</span> (opIsStateful())
            sourceStage.sourceAnyStateful = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">this</span>.depth = previousStage.depth + <span class="hljs-number">1</span>;
    }

</code></pre>
<p>忽略其他操作，可以看出这是双向链表的构建方法。</p>
<ul>
<li>​<code>depth</code>：链表的“深度”，或者为当前节的序号，从0开始，依次加1。</li>
<li>​<code>sourceStage</code>：头节点的指针。</li>
<li>​<code>nextStage</code>：下一个节点的指针。</li>
<li>​<code>previousStage</code>：上一个节点的指针。</li>
</ul>
<p>从代码1-1中可以知道，流是调用<code>StreamSupport.stream(spliterator(), false)</code>方法创建的。它的具体实现是这样的，代码2-6：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">(Spliterator&lt;T&gt; spliterator, <span class="hljs-type">boolean</span> parallel)</span> {
        Objects.requireNonNull(spliterator);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferencePipeline</span>.Head&lt;&gt;(spliterator,
                                            StreamOpFlag.fromCharacteristics(spliterator),
                                            parallel);
    }
</code></pre>
<p>这个<code>ReferencePipeline.Head</code>类构造器最后调用的就是代码2-5中头节点构造器。</p>
<p>对于样例代码中<code>Stream#map</code>​方法的实现（代码2-1），<code>return new StatelessOp&lt;P_OUT, R&gt;(this, ...)</code>​ 这行代码中的<code>this</code>​是<code>ReferencePipeline.Head</code>​实例。但这行<code>StatelessOp</code>​的构造方法最终会调用到它的父类<code>AbstractPipeline</code>​构造方法（代码2-5），当运行至<code>previousStage.nextStage = this;</code>​行时，此时的<code>this</code>​则是当前<code>StatelessOp</code>​类实例。后续节点调用此方法时，这两个<code>this</code>将会依次后移，链表就这样构造出来了。形成类似于下图的逻辑结构，图2-2：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR
    A[Null] 
    B[ReferencePipeline头节点]
    C[ReferencePipeline节点B]
    D[ReferencePipeline节点C]
    E[Null]

     
    B --&gt; |nextStage| C
    C --&gt; |nextStage| D
    D --&gt; |nextStage| E
    
    C -.-&gt; |sourceStage| B
    D -.-&gt; |sourceStage| B

    C -.-&gt; |previousStage| B
    D -.-&gt; |previousStage| C
    B -.-&gt; |previousStage| A
</code></pre>
<p>在看源码时需注意代码中<code>this</code>指向的节点。</p>
<h2 data-id="heading-7">3 流的计算</h2>
<p>前面分析了数据和操作流水线的构建，接下来就是流最终是如何进行运算的。</p>
<h3 data-id="heading-8">3.1 流的执行</h3>
<p>在样例代码中，最后调用一个<code>forEach</code>​的终止操作来结束流的定义。终止操作是流计算和获取结果的方法，它们都定义在<code>java.util.stream.Stream</code>​接口中，实现在<code>ReferencePipeline</code>类中。部分终止方法实现，代码3-1：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> P_OUT&gt; action)</span> {
        evaluate(ForEachOps.makeRef(action, <span class="hljs-literal">false</span>));
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> P_OUT&gt; predicate)</span> {
        <span class="hljs-keyword">return</span> evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ALL));
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Optional&lt;P_OUT&gt; <span class="hljs-title function_">findAny</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> evaluate(FindOps.makeRef(<span class="hljs-literal">false</span>));
    }
</code></pre>
<p>这就是流的终止操作的特殊性，每个终止操作都由一个JDK内部<code>XxxOps</code>类包装后使用。</p>
<p>​<code>evaluate</code>​方法是执行流计算并获取结果的方法，为 <code>ReferencePipeline</code>​ 的父类 <code>AbstractPipeline</code>​ 中的<code>final</code>方法，代码3-2：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-keyword">final</span> &lt;R&gt; R <span class="hljs-title function_">evaluate</span><span class="hljs-params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> {
        <span class="hljs-keyword">assert</span> <span class="hljs-title function_">getOutputShape</span><span class="hljs-params">()</span> == terminalOp.inputShape();
        <span class="hljs-keyword">if</span> (linkedOrConsumed)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);
        linkedOrConsumed = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">return</span> isParallel()
               ? terminalOp.evaluateParallel(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()))
               : terminalOp.evaluateSequential(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()));
    }
</code></pre>
<p>此方法的主要作用是分派计算方法：对于串行计算调用 <code>evaluateSequential</code>​ 方法，对于并发计算则调用 <code>evaluateParallel</code>​ 方法。具体的计算方案由 <code>terminalOp</code> 这个终止操作类来实现。并发计算涉及的内容较为复杂，本文不会涉及。</p>
<p>注意代码中<code>this</code>​的指向。就样例代码而言，当前<code>terminalOp.evaluateSequential</code>​ 方法中的<code>this</code>​指向<code>Stream#map</code>​方法构建出的<code>ReferencePipeline</code>实例。</p>
<p>​<code>sourceSpliterator</code>方法可简单理解为“取出数据”操作，不过会有一些校验等，此处不展开。</p>
<p>此时<code>terminalOp</code>​变量为<code>java.util.stream.ForEachOps</code>实例，它的部分代码如下，代码3-3：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForEachOps</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ForEachOps</span><span class="hljs-params">()</span> { }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; TerminalOp&lt;T, Void&gt; <span class="hljs-title function_">makeRef</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action,
                                                  <span class="hljs-type">boolean</span> ordered)</span> {
        Objects.requireNonNull(action);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForEachOp</span>.OfRef&lt;&gt;(action, ordered);
    }
	<span class="hljs-comment">// ...</span>
	    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForEachOp</span>&lt;T&gt;
            <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TerminalOp</span>&lt;T, Void&gt;, TerminalSink&lt;T, Void&gt; {
			<span class="hljs-comment">// ... </span>
	        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OfRef</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForEachOp</span>&lt;T&gt; {
	            <span class="hljs-keyword">final</span> Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer;
	
	            OfRef(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer, <span class="hljs-type">boolean</span> ordered) {
	                <span class="hljs-built_in">super</span>(ordered);
	                <span class="hljs-built_in">this</span>.consumer = consumer;
	            }
	
	            <span class="hljs-meta">@Override</span>
	            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span> {
	                consumer.accept(t);
	            }
	        }
	        <span class="hljs-meta">@Override</span>
	        <span class="hljs-keyword">public</span> &lt;S&gt; Void <span class="hljs-title function_">evaluateSequential</span><span class="hljs-params">(PipelineHelper&lt;T&gt; helper,
	                                           Spliterator&lt;S&gt; spliterator)</span> {
	            <span class="hljs-keyword">return</span> helper.wrapAndCopyInto(<span class="hljs-built_in">this</span>, spliterator).get();
	        }
	        <span class="hljs-meta">@Override</span>
	        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">get</span><span class="hljs-params">()</span> {
	            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	        }
		<span class="hljs-comment">// ...</span>
		}
	<span class="hljs-comment">// ...</span>
}
</code></pre>
<p>可以看到它的<code>evaluateSequential</code>​方法是执行计算并获取结果的地方，但<code>forEach</code>​的终止操作不产出数据所以<code>get()</code>​方法直接返空。下面有返回值的终止操作例子（不知道为什么Java Stream模块内部没怎么用<code>Optional</code>类）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindOps</span> {
		<span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OfInt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FindSink</span>&lt;Integer, OptionalInt&gt;
                <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sink</span>.OfInt {
			<span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">public</span> OptionalInt <span class="hljs-title function_">get</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">return</span> hasValue ? OptionalInt.of(value) : <span class="hljs-literal">null</span>;
            }
}
</code></pre>
<p>​<code>PipelineHelper</code>​类看名字像个工具类，但它是<code>ReferencePipeline</code>​类的父类，回看图2-1，此处<code>helper</code>​参数应当视为<code>AbstractPipeline</code>类实例或者理解为“流水线”节点。</p>
<p>结合代码3-2，样例代码会运行到<code>helper.wrapAndCopyInto(this, spliterator).get()</code>​行。此时<code>this</code>​指向<code>ForEachOps</code>​实例，<code>helper</code>​参数更确切点说为<code>Stream#map</code>​方法构建出的<code>ReferencePipeline</code>​实例。<code>wrapAndCopyInto</code>​方法定义在<code>PipelineHelper</code>​中，实现在<code>AbstractPipeline</code>类里，如下，代码3-4：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">final</span> &lt;P_IN, S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sink</span>&lt;E_OUT&gt;&gt; S <span class="hljs-title function_">wrapAndCopyInto</span><span class="hljs-params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        <span class="hljs-keyword">return</span> sink;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">final</span> &lt;P_IN&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyInto</span><span class="hljs-params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> {
        Objects.requireNonNull(wrappedSink);

        <span class="hljs-keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
        }
        <span class="hljs-keyword">else</span> {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }

</code></pre>
<p>​<code>wrapAndCopyInto</code> 方法名虽未提及计算，但对于串行流而言，计算基本上就是在此处执行的，终止操作主要负责获取最终结果。</p>
<p>在当前样例代码的上下文中，由于没有使用 <code>filter</code> 等可能引发短路计算的中间操作，因此会执行非短路分支内的代码。</p>
<pre><code class="hljs language-java" lang="java">            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
</code></pre>
<p>在执行计算之前，还需要调用 <code>wrapSink(Sink&lt;E_OUT&gt; sink)</code> 方法。在了解此方法之前，我们先补充两个相关的接口定义，如代码3-5所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TerminalOp</span>&lt;E_IN, R&gt; {
	<span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TerminalSink</span>&lt;T, R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sink</span>&lt;T&gt;, Supplier&lt;R&gt; { }
</code></pre>
<p>第一个接口定义了终止操作的公共行为（主要是<code>evaluateParallel</code>​和<code>evaluateSequential</code>​方法），第二接口则是拓展了<code>Sink</code>​接口。结合代码3-3来看，<code>ForEachOp.OfRef</code>​是针对引用类数据的实现，也间接实现了<code>Sink</code>​接口。此时<code>wrapSink(Sink&lt;E_OUT&gt; sink)</code>​方法的入参为<code>ForEachOp.OfRef</code>实例。</p>
<p>接下来再看<code>java.util.stream.AbstractPipeline#wrapSink</code>方法，代码3-6：</p>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
    <span class="hljs-keyword">final</span> &lt;P_IN&gt; Sink&lt;P_IN&gt; <span class="hljs-title function_">wrapSink</span><span class="hljs-params">(Sink&lt;E_OUT&gt; sink)</span> {
        Objects.requireNonNull(sink);

        <span class="hljs-keyword">for</span> ( <span class="hljs-meta">@SuppressWarnings("rawtypes")</span> AbstractPipeline p=AbstractPipeline.<span class="hljs-built_in">this</span>; p.depth &gt; <span class="hljs-number">0</span>; p=p.previousStage) {
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        <span class="hljs-keyword">return</span> (Sink&lt;P_IN&gt;) sink;
    }
</code></pre>
<p>这里要注意代码中<code>this</code>​的指向，它是指向上一级<code>AbstractPipeline</code>​节点。对于样例代码，此处为<code>Stream#map</code>​方法构建出的<code>AbstractPipeline</code>​节点。而<code>sink</code>​参数则传入的<code>ForEachOp.OfRef</code>实例。</p>
<p>以样例代码来讲：</p>
<pre><code class="hljs language-java" lang="java">ForEachOp.OfRef实例 传入 -&gt; wrapSink(Sink&lt;E_OUT&gt; sink) 方法
AbstractPipeline.<span class="hljs-built_in">this</span> 拿出 Stream#map 方法构建出的AbstractPipeline实例

p.opWrapSink(p.previousStage.combinedFlags, sink)的调用展开为：

            <span class="hljs-meta">@Override</span>
            Sink&lt;P_OUT&gt; <span class="hljs-title function_">opWrapSink</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, Sink&lt;R&gt; sink)</span> {  <span class="hljs-comment">// ForEachOp.OfRef实例 -&gt; sink</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(P_OUT u)</span> {
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        
返回Sink.ChainedReference实例

p指针的已移动到头节点，depth 为 <span class="hljs-number">0</span> ，退出循环
</code></pre>
<p>结合代码2-5中的</p>
<pre><code class="hljs language-java" lang="java">        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChainedReference</span><span class="hljs-params">(Sink&lt;? <span class="hljs-built_in">super</span> E_OUT&gt; downstream)</span> {
            <span class="hljs-built_in">this</span>.downstream = Objects.requireNonNull(downstream);
        }
</code></pre>
<p>各个<code>Sink</code>​类中的<code>downstream</code>​变量确实指向下一级的<code>Sink</code>实例。</p>
<p>综上，流计算的前期步骤已经完成。接下来就看看数据是如何计算的。</p>
<h3 data-id="heading-9">3.2 数据的运算</h3>
<p>之前分析说过，串行流在<code>wrapAndCopyInto</code>方法就执行了计算。对于我们的样例代码来说计算就发生这三行代码中：</p>
<pre><code class="hljs language-java" lang="java">            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
</code></pre>
<p>​​<code>wrappedSink</code>​变量代表着流第一个操作，在本例中为<code>map(String::toUpperCase)</code>。</p>
<p>​​<code>spliterator</code>​代表数据源，本例中它为<code>ArrayList</code>。</p>
<p>​​<code>wrappedSink.begin</code>​流运算开始前的准备工作。大部分操作并不需要做什么准备，通常使用默认实现<code>downstream.begin(size);</code>​通知下游操作；对于<code>filter</code>​之类的操作，常常实现为<code>downstream.begin(-1);</code>表示未知大小。</p>
<p>​<code>spliterator.forEachRemaining</code>​语义为把数据源中的所有元素逐一遍历，<code>ArrayList</code>​实现为使用索引遍历具体此处略。这里需要注意数据流的形成。先看<code>forEachRemaining</code>方法类似的实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> {  <span class="hljs-comment">// 传入的是map(String::toUpperCase)方法构成的Sink实例</span>
    <span class="hljs-keyword">for</span> (i = lo; i &lt; hi; ++i) { 
        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) a[i];
        action.accept(e);
    }
}
</code></pre>
<p>结合代码2-1中的片段</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(P_OUT u)</span> {
    downstream.accept(mapper.apply(u)); <span class="hljs-comment">// mapper为map(String::toUpperCase)方法构成的Sink实例</span>
}
</code></pre>
<p>​<code>downstream</code>​变量结合之前所讲它为<code>ForEachOps</code>实例，即为打印元素的语句。</p>
<p>这里也表明上一级操作结果就是下一级操作的输入，数据流动起来了。</p>
<p>​<code>wrappedSink.end</code>方法通常也只是通知下游操作。</p>
<h2 data-id="heading-10">4 总结</h2>
<p>本文从一个简单的例子出发，展示了Java Stream运行的基本而完整流程，其中也涉及到重要概念与类设计。</p>
<p>限于篇幅与能力，本文略过有状态计算、并行计算等复杂部分；如有错漏，欢迎指出。</p>
<p>‍</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[记一次“丝滑”的服务器迁移]]></title>    <link>https://juejin.cn/post/7587252766831837226</link>    <guid>https://juejin.cn/post/7587252766831837226</guid>    <pubDate>2025-12-24T13:28:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587252766831837226" data-draft-id="7587253759092588580" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="记一次“丝滑”的服务器迁移"/> <meta itemprop="keywords" content="后端,运维"/> <meta itemprop="datePublished" content="2025-12-24T13:28:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="tonydf"/> <meta itemprop="url" content="https://juejin.cn/user/3809161241186638"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            记一次“丝滑”的服务器迁移
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3809161241186638/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    tonydf
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T13:28:05.000Z" title="Wed Dec 24 2025 13:28:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>近期，由于旧服务器性能无法满足日益增长的服务需求，需要将核心中间件平滑迁移至一台高性能的新服务器节点。涉及的服务包括 Elasticsearch、Kafka 集群，以及 PostgreSQL 和 RabbitMQ 等开发环境服务，我觉得还是有必要记录一下的，就算各位佬友用不到，对我自己来说，也是一次运维经验的整理。</p>
<p>我把这些工作分了下面这几个阶段。</p>
<h2 data-id="heading-1">第一阶段：准备迁移</h2>
<p>开始迁移之前，准备一下要迁移的服务，以及大体的迁移路线。</p>
<p>这一阶段，我这边的场景是分别准备</p>
<ul>
<li>postgreSQL</li>
<li>RabbitMQ</li>
<li>ElasticSearch</li>
<li>Kafka</li>
</ul>
<p>以上4个软件的安装环境，我这里RabbitMQ和PG只是作为开发环境的服务，作为一个单节点服务运行，要求不高，因此安装相对简单，基本按照官方文档或者操作习惯，从头安装即可。</p>
<p>主要还是ES和Kafka两个集群节点的迁移，我这里是把安装文件和相关的配置文件从即将下线的服务器直接scp到了新服务器节点，然后修改配置，重启服务的路线。</p>
<h2 data-id="heading-2">第二阶段：系统底层环境标准化</h2>
<p>在新节点部署前，需要执行以下初始化，确保环境与其他服务器节点对齐。</p>
<h3 data-id="heading-3">1. 内核与资源限制</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 修改内核参数</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"vm.max_map_count=262144"</span> &gt;&gt; /etc/sysctl.conf
sysctl -p

<span class="hljs-comment"># 修改资源限制</span>
<span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt;&gt; /etc/security/limits.conf
# 👇这里可以直接限制具体的资源对象，也可以像这样直接搞个*
* soft nofile 65536
* hard nofile 65536
EOF</span>
</code></pre>
<p>修改完成后的输出如下</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8912806f6e4940d3abc75b3587f8a654~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=3ECJe4R1iDkDAArN3e9eLLjEnL8%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a33ca1e483b04c38a1e3b493b13c6643~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=Hclap9hZsoWmHrTxupshbM8f3QA%3D" alt="" loading="lazy"/></p>
<p>这个按需执行即可，如果你要跑的服务不需要限制资源，那不用考虑</p>
<h3 data-id="heading-4">2. JDK环境</h3>
<p>我这里要安装JDK是因为我的kafka集群是基于Kraft模式，依赖jdk。</p>
<p>而es启动文件里虽然已经包含了一个JDK，但仅限es自身使用，因此其他应用也依赖JDK的话还是要安装一下。</p>
<pre><code class="hljs language-plain" lang="plain"># 安装系统全局 JDK
yum install -y java-17-openjdk-devel
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e67c6d4123a4e1d935b13ac15d529fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=UfcnoU3A0A1%2FoxPDXtCJk2HTB1Y%3D" alt="" loading="lazy"/></p>
<p>由于我的JDK环境要给到Kafka帐户使用，因此要给Kafka也进行授权</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 kafka 用户并授权安装目录</span>
useradd kafka
<span class="hljs-built_in">chown</span> -R kafka:kafka /home/tony/kafka
</code></pre>
<p>然后切到kafka用户下，看一下输出也ok即可</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab168d09d79f48e6beca4db60850b312~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=nsgRu%2BLnQ%2BL3Y2xwIWc5a35e1Hg%3D" alt="" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-5">第二阶段：Elasticsearch 节点平滑平移</h2>
<p>我这里，es做了安全配置，增加了X-Pack安全验证和SSL证书，因此迁移的时候，新节点上的配置必须“像素级”和原来的节点对齐，否则无法通过握手，甚至会导致集群脑裂或拒绝连接。</p>
<p>以下是具体步骤，在这之前，我已经完成了安装文件和<strong>证书文件</strong>的迁移。</p>
<h3 data-id="heading-6">修改配置</h3>
<p>es的配置复杂度基本都收拢到了elasticsearch.yml文件里，因此要修改这个文件就可以了.</p>
<p>关键的配置如下，我对敏感信息做了脱敏（密码和ip地址）</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># ---------------------------------- Cluster -----------------------------------</span>
<span class="hljs-comment"># 集群名称</span>
<span class="hljs-attr">cluster.name:</span> <span class="hljs-string">magicloud-cluster</span>

<span class="hljs-comment"># ------------------------------------ Node ------------------------------------</span>
<span class="hljs-comment"># 修改节点名以区分</span>
<span class="hljs-attr">node.name:</span> <span class="hljs-string">es-node214</span> 
<span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># ----------------------------------- Paths ------------------------------------</span>
<span class="hljs-comment"># 确保新节点上这些目录存在且es用户有权读写</span>
<span class="hljs-attr">path.data:</span> <span class="hljs-string">/usr/local/elasticsearch/data</span>
<span class="hljs-attr">path.logs:</span> <span class="hljs-string">/usr/local/elasticsearch/logs</span>

<span class="hljs-comment"># ---------------------------------- Network -----------------------------------</span>
<span class="hljs-comment"># IP配置</span>
<span class="hljs-attr">network.host:</span> <span class="hljs-string">xx.xxx.xx.xxx</span>
<span class="hljs-attr">http.port:</span> <span class="hljs-number">9200</span>

<span class="hljs-comment"># --------------------------------- Discovery ----------------------------------</span>
<span class="hljs-comment"># 种子节点写现有的节点</span>
<span class="hljs-attr">discovery.seed_hosts:</span> [<span class="hljs-string">"xx.xxx.xx.xx1:9300"</span>, <span class="hljs-string">"xx.xxx.xx.xx2:9300"</span>, <span class="hljs-string">"xx.xxx.xx.xx3:9300"</span>]

<span class="hljs-comment"># ---------------------------------- Various -----------------------------------</span>
<span class="hljs-attr">action.destructive_requires_name:</span> <span class="hljs-literal">true</span>
<span class="hljs-comment"># 当前节点的IP地址</span>
<span class="hljs-attr">transport.host:</span> <span class="hljs-string">xx</span>
<span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9300</span>

<span class="hljs-comment"># ------------------------ X-Pack Security Settings ------------------------</span>
<span class="hljs-comment"># 以下和原节点保持一致，注意证书路径要放对</span>
<span class="hljs-attr">xpack.security.enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">xpack.security.transport.ssl.enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">xpack.security.transport.ssl.verification_mode:</span> <span class="hljs-string">certificate</span>
<span class="hljs-attr">xpack.security.transport.ssl.keystore.path:</span> <span class="hljs-string">certs/elastic-certificates.p12</span>
<span class="hljs-attr">xpack.security.transport.ssl.truststore.path:</span> <span class="hljs-string">certs/elastic-certificates.p12</span>

<span class="hljs-attr">xpack.security.http.ssl.enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">xpack.security.http.ssl.keystore.path:</span> <span class="hljs-string">certs/elastic-certificates.p12</span>
<span class="hljs-attr">xpack.security.http.ssl.truststore.path:</span> <span class="hljs-string">certs/elastic-certificates.p12</span>

<span class="hljs-comment"># 密码保持一致</span>
<span class="hljs-attr">xpack.security.transport.ssl.keystore.password:</span> <span class="hljs-string">"xxx"</span>
<span class="hljs-attr">xpack.security.transport.ssl.truststore.password:</span> <span class="hljs-string">"xxx"</span>
<span class="hljs-attr">xpack.security.http.ssl.keystore.password:</span> <span class="hljs-string">"xxx"</span>
<span class="hljs-attr">xpack.security.http.ssl.truststore.password:</span> <span class="hljs-string">"xxx"</span>

<span class="hljs-attr">xpack.security.http.ssl.verification_mode:</span> <span class="hljs-string">certificate</span>
</code></pre>
<p>这里涉及到配置ES安全属性的内容，有不了解的小伙伴可以参考Elastic的官网，笔者之前也写过相关的<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5v4Q4fyRwD6QSsW96VELRQ" target="_blank" title="https://mp.weixin.qq.com/s/5v4Q4fyRwD6QSsW96VELRQ" ref="nofollow noopener noreferrer"><strong>博客</strong></a>**，**欢迎感兴趣的小伙伴点击翻阅，传送门👉：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5v4Q4fyRwD6QSsW96VELRQ" target="_blank" title="https://mp.weixin.qq.com/s/5v4Q4fyRwD6QSsW96VELRQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/5v4Q4fyRw…</a></p>
<h3 data-id="heading-7">修改权限</h3>
<p>因为es处于安全考虑，严禁root用户启动服务，因此要在新节点上创建相关的用户组并配置权限。</p>
<ul>
<li><strong>创建用户组</strong></li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建用户组</span>
groupadd elsearch
<span class="hljs-comment"># 创建用户并加入组</span>
useradd elsearch -g elsearch
<span class="hljs-comment"># 设置密码（可选，如果只是 su 切换则不一定需要）</span>
<span class="hljs-comment"># passwd elsearch</span>
</code></pre>
<ul>
<li><strong>操作目录授权</strong></li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 赋予安装目录权限</span>
<span class="hljs-built_in">chown</span> -R elsearch:elsearch /opt/es/elasticsearch-7.14.1/

<span class="hljs-comment"># 2. 赋予数据和日志目录权限（根据你之前的配置路径）</span>
<span class="hljs-built_in">chown</span> -R elsearch:elsearch /usr/local/elasticsearch/data
<span class="hljs-built_in">chown</span> -R elsearch:elsearch /usr/local/elasticsearch/logs
</code></pre>
<ul>
<li><strong>检查jvm堆内存</strong></li>
</ul>
<p>确保给新节点分配的内存（比如 -Xms4g -Xmx4g）不要超过系统可用内存的一半。</p>
<h3 data-id="heading-8">启动新节点并验证加入</h3>
<ul>
<li>启动</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">su - elsearch -c <span class="hljs-string">"/opt/es/elasticsearch-7.14.1/bin/elasticsearch -d"</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03dfe1b174de4acb803446f1a1ca4037~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=dpaWVm7RV3el0FofFv6dNQcDPeQ%3D" alt="" loading="lazy"/></p>
<ul>
<li>启动无误后，到原来的任意一个节点上验证一下加入情况</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">curl -X GET <span class="hljs-string">"http://10.185.3.176:9200/_cat/nodes?v"</span>
</code></pre>
<p>注意，此时即将准备下线的那个节点还是正常运行的，因此正常情况下，列表数量应该是N+1个记录，比如我这里原来是3个节点，此时就是4个。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3144f58fa7204f4287923a073fb3763d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=Zi7TEOjl%2BlTnnxOcomUQ6xgeVP0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">触发分片驱逐 （迁移数据）</h3>
<p>这一步就是让集群主动的“踢掉”准备下线的那个节点，并把那个节点上的数据同步到其他节点，这正是ElasticSearch作为一个分布式日志系统的强大之处！</p>
<pre><code class="hljs language-bash" lang="bash">curl -X PUT <span class="hljs-string">"http://{xxx,这里是在一个原有的节点上}:9200/_cluster/settings"</span> -H <span class="hljs-string">'Content-Type: application/json'</span> -d<span class="hljs-string">'
{
  "transient": {
    "cluster.routing.allocation.exclude._ip": "{被驱逐的节点ip}"
  }
}'</span>
</code></pre>
<p>执行后的响应如下</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab514a2eccd549de9d0639807371af3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=mZbuzEElY7Boi6ZVi1V5b9VTzqI%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">监控迁移进度</h3>
<p>可以通过一下命令观察待驱逐的节点shards数量变化，直到它变成0，这一步需要一定的执行时间，时间长短和日志文件的大小有关，耐心等待即可。</p>
<pre><code class="hljs language-plain" lang="plain">curl -u elastic -k "https://xx.xxx.xx.xxx:9200/_cat/allocation?v"
</code></pre>
<p>也可以借助一些可视化的监控工具查看迁移进度</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11980622041d41a98a54d05260e19d59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=M2yzQfvb91lB62o0NdePNqPdbNE%3D" alt="" loading="lazy"/></p>
<p>迁移完成后</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e98349de500e493da190f6c069bf5840~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=H%2FNl4UPcW3iEz5sCvVKXdscIFBE%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">收尾与配置刷新</h3>
<p>上一步完成收，线上的ES集群实际上就已经是全新的集群了，但由于原来的集群节点我们还没有修改，当服务重启后，还是会有问题。所以我们还要逐一修改原有的节点配置，这里只要配置服务发现的节点数组对象就可以了</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 以下xxx代表实际的ip地址</span>
discovery.seed_hosts: [<span class="hljs-string">"xxx1:9300"</span>, <span class="hljs-string">"xxx2:9300"</span>, <span class="hljs-string">"xxx3:9300"</span>]
</code></pre>
<p>修改完成后，还要接触前面设置的驱逐限制,这一步也很重要，否则新节点以后也会受限</p>
<pre><code class="hljs language-bash" lang="bash">curl -u elastic -k -X PUT <span class="hljs-string">"https://xxx:9200/_cluster/settings?pretty"</span> -H <span class="hljs-string">'Content-Type: application/json'</span> -d<span class="hljs-string">'
{
  "transient": {
    "cluster.routing.allocation.exclude._ip": null
  }
}'</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e5bfdf208f74beda7407708a5687a82~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=%2FFfNAGY7NGRkPtbyl8F9WXYCr0U%3D" alt="" loading="lazy"/></p>
<p>全部执行完成后，需要把集群内所有的节点再重启一遍，虽然有点繁琐，但这是必须的，重启完成后，看一下集群状态</p>
<pre><code class="hljs language-bash" lang="bash">curl -u elastic -k https://xxx:9200/_cluster/health?pretty
</code></pre>
<p>或者通过管理面板查看，变成“Green”即可</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/931e471f9e8b43049f22b82fca852acf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=3PTSd7dfZ3n4SRuzVbvXorX19Fg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eaec8a6826774191a94058c52ae87216~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=CQXdG63l%2F5d%2BQkOkR0yU6nTqDX8%3D" alt="" loading="lazy"/></p>
<p>好了，值此ElasticSearch的迁移工作完成，可以把准备替换的那台节点上的es节点干掉了。</p>
<pre><code class="hljs language-bash" lang="bash">ps -ef | grep elasticsearch | grep -v grep | awk <span class="hljs-string">'{print $2}'</span> | xargs <span class="hljs-built_in">kill</span> -9
</code></pre>
<p>注意，这里别忘了要把新增节点上的端口放开</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 开放 9200 和 9300 端口</span>
firewall-cmd --permanent --add-port=9200/tcp
firewall-cmd --permanent --add-port=9300/tcp

<span class="hljs-comment"># 重新加载防火墙配置使生效</span>
firewall-cmd --reload

<span class="hljs-comment"># 查看是否生效</span>
firewall-cmd --list-ports
</code></pre>
<h4 data-id="heading-12"/>
<h2 data-id="heading-13">第三阶段：Kafka节点平滑迁移</h2>
<h3 data-id="heading-14">修改配置</h3>
<p>和es的迁移一样，我这里也是提前把安装文件，配置文件等都拷贝到了新节点，然后修改配置文件，我这里的Kafka集群使用的新的Kraft模式，这里修改的是Kraft目录里的配置，主要修改voters参数和node.id，注意node.id必须是一个集群里没出现过的id</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment">############################# Server Basics #############################</span>
<span class="hljs-comment"># 基本配置</span>
process.roles=broker,controller
node.id=214
controller.quorum.voters=214@xxx:9093,178@xxx:9093,176@xxx:9093


<span class="hljs-comment"># =============================默认配置======================= #</span>
listeners=PLAINTEXT://xxx:9092,CONTROLLER://10.185.3.214:9093

inter.broker.listener.name=PLAINTEXT
advertised.listeners=PLAINTEXT://xxx:9092
listener.security.protocol.map=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL
<span class="hljs-comment"># ========================================默认配置结束=================================== #</span>

controller.listener.names=CONTROLLER
process.cluster.id=xxxx
num.network.threads=3
num.io.threads=8
socket.send.buffer.bytes=102400
socket.receive.buffer.bytes=102400
socket.request.max.bytes=104857600


<span class="hljs-comment">############################# Log Basics #############################</span>

log.dirs=/usr/kafka/kraft-combined-logs
num.partitions=3
default.replication.factor=3
num.recovery.threads.per.data.dir=1
offsets.topic.replication.factor=3
transaction.state.log.replication.factor=3
transaction.state.log.min.isr=2

log.retention.hours=168
log.segment.bytes=1073741824
log.retention.check.interval.ms=300000

</code></pre>
<h3 data-id="heading-15">节点环境准备</h3>
<p>和ElasticSearch的迁移一样，创建用户组和授权</p>
<pre><code class="hljs language-bash" lang="bash">groupadd kafka &amp;&amp; useradd kafka -g kafka
<span class="hljs-built_in">mkdir</span> -p /usr/kafka/kraft-combined-logs
<span class="hljs-built_in">chown</span> -R kafka:kafka /usr/kafka/kraft-combined-logs
<span class="hljs-built_in">chown</span> -R kafka:kafka /home/tony/kafka/
</code></pre>
<h3 data-id="heading-16">数据重分配 *</h3>
<blockquote>
<p>这一步，看你的Kafka实际作用，如果只是传递实时消息，那迁移完成后直接重置消息日志也是可以的，前提是你确实不需要迁移的哈</p>
</blockquote>
<ul>
<li>提取原来的Topic</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 先把所有 topic 名字提出来，存到 topics.txt</span>
bin/kafka-topics.sh --bootstrap-server xx.xxx:9092 --list | grep -v <span class="hljs-string">"__consumer_offsets"</span> &gt; topics.txt

<span class="hljs-comment"># 将其转换为 Kafka 识别的json格式</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">'{"topics": ['</span> &gt; topics-to-move.json
sed <span class="hljs-string">'s/.*/  {"topic": "&amp;"},/'</span> topics.txt | sed <span class="hljs-string">'$s/,$//'</span> &gt;&gt; topics-to-move.json
<span class="hljs-built_in">echo</span> <span class="hljs-string">'], "version": 1}'</span> &gt;&gt; topics-to-move.json
</code></pre>
<p>这样就得到了一个完整的 topics-to-move.json。</p>
<ul>
<li>生成迁移方案</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">bin/kafka-reassign-partitions.sh --bootstrap-server 10.185.3.176:9092 \
--topics-to-move-json-file topics-to-move.json \
--broker-list <span class="hljs-string">"176,178,214"</span> \
--generate
</code></pre>
<p>上面的176这些，就是node.id的名称，这个要确保集群内唯一</p>
<p>执行后，屏幕会打印出两段长长的json串，我们需要把第二段（proposed partition reassignment configuration）下面的全部内容拷贝下来保存到一个文件里，比如execute-reassign.json</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31e94ca5e06345dc9c8c4a4db3173176~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=V9wVTzBOLftYA1nSn3jhy%2BsGy3E%3D" alt="" loading="lazy"/></p>
<ul>
<li>搬家</li>
</ul>
<p>上面文件保存后，就可以搬家了</p>
<pre><code class="hljs language-bash" lang="bash">./bin/kafka-reassign-partitions.sh --bootstrap-server 10.185.3.176:9092 \
--reassignment-json-file execute-reassign.json \
--execute
</code></pre>
<p>执行这个命令查看搬家进度</p>
<pre><code class="hljs language-bash" lang="bash">./bin/kafka-reassign-partitions.sh --bootstrap-server xxx:9092 \
--reassignment-json-file execute-reassign.json \
--verify
</code></pre>
<p>如果看到 Reassignment of partition ... is in progress，就说明搬家正在进行中。直到所有分区都显示： Status: completed successfully。此时，你可以去新节点的存储目录看一眼，确认数据量是否已经上来：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02dc84c425874c6cad03b2e00794237d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=gonOvHsJNi5EYDx280QYkuGwKK8%3D" alt="" loading="lazy"/></p>
<p>等原节点被掏空后，就可以下线掉它了，至此，Kafka集群已经是全新的集群了</p>
<h3 data-id="heading-17">收尾与配置刷新</h3>
<p>和es的迁移一样，这里集群里原来的节点也要进行修改，主要是修改controller.quorum.voters，集群里每个节点的配置要保持一致。</p>
<p>然后滚动重启即可</p>
<h3 data-id="heading-18">可能出现的问题 *</h3>
<p>迁移Kafka的时候，非常容易出现问题，比如我这里就遇到了下面这个问题，实际上这个错误就是kafka在进行三方校验的时候出错了，元数据日志里记录了旧集群的状态，可以通过编辑或者查看/usr/kafka/kafka-3.8-176/kraft-combined-logs/meta.properties这个文件来确认</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/baa65456a47741b5bbd031862f6c245d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdG9ueWRm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767187684&amp;x-signature=VXhsB9QlMFjjDQ%2B0mfh9GS5R7iQ%3D" alt="" loading="lazy"/></p>
<p>我也试过手动修改这个元数据文件，但不起作用，如果前面的数据重新分配步骤已经完成，或者说你不需要重洗分配，那最简单蛮粗暴的方法就是重置他们。</p>
<ul>
<li>停止所有kafka的进程</li>
<li>清空元数据（慎重）</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">rm</span> -rf /usr/kafka/kraft-combined-logs/*
</code></pre>
<ul>
<li>重新格式化</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">su - kafka -c <span class="hljs-string">"/home/tony/kafka/kafka_2.12-3.8.0/bin/kafka-storage.sh format -t {配置文件里设置的集群id} -c /home/tony/kafka/kafka_2.12-3.8.0/config/kraft/server-cluser.properties"</span>
</code></pre>
<ul>
<li>重启</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">su - kafka -c <span class="hljs-string">"/home/tony/kafka/kafka_2.12-3.8.0/bin/kafka-server-start.sh -daemon /home/tony/kafka/kafka_2.12-3.8.0/config/kraft/server-cluser.properties"</span>
</code></pre>
<h3 data-id="heading-19">第四阶段：定期打扫</h3>
<h4 data-id="heading-20">ES日志自动清理</h4>
<p>我们的场景里，ES搜集的是所有业务系统的操作日志，可以方便的定位问题。但问题就是日志量比较庞大，我这里的策略是写了一个监控程序，跑在一台业务服务器，然后滚动删除日期比较早的日志。这部分我是使用C#接入ES的官方SDK，NEST来做的，代码比较简单不在灌入。</p>
<blockquote>
<p>这个看实际情况，我们的情况是比较早的日志就不保留了，直接删除释放空间，当然也可以打包下载下来做归档。</p>
</blockquote>
<h4 data-id="heading-21">Kafka日志自动清理任务</h4>
<p>Kafka产生的持久化数据主要有有业务数据和集群元数据，其中存储在“/kraft-combined-logs/”路径下的文件绝对不能手动删除，Kafka本身会自动清理它。而在安装文件的logs目录下产生的目录是可以删除的，而且他也是无限增长的，所以我们可以搞个脚本，然后挂到计划任务里，定期删掉他；</p>
<pre><code class="hljs language-plain" lang="plain">#!/bin/bash

# 1. 定义路径
LOG_DIR="/home/tony/kafka/kafka_2.12-3.8.0/logs"
CLEAN_LOG="/home/tony/shells/cleanlog.log"

# 确保存放清理记录的目录存在
mkdir -p /home/tony/shells

echo "--- 开始清理任务: $(date +'%Y-%m-%d %H:%M:%S') ---" &gt;&gt; "$CLEAN_LOG"

# 2. 直接获取文件列表，避免子 Shell 导致计数器失效
# 使用 .log.* 匹配被压缩或切分后的历史日志（如 server.log.2025-12-24-1）
files=$(find "$LOG_DIR" -type f -name "*.log.*" -mtime +30)

count=0
for file in $files; do
    if [ -f "$file" ]; then
        rm -f "$file"
        if [ $? -eq 0 ]; then
            echo "[SUCCESS] 已删除: $file" &gt;&gt; "$CLEAN_LOG"
            ((count++))
        else
            echo "[ERROR] 无法删除: $file" &gt;&gt; "$CLEAN_LOG"
        fi
    fi
done

# 3. 记录总结
echo "本次任务共清理 $count 个文件." &gt;&gt; "$CLEAN_LOG"
echo "------------------------------------------------" &gt;&gt; "$CLEAN_LOG"
</code></pre>
<hr/>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 编辑计划任务</span>
crontab -e

<span class="hljs-comment"># 添加如下内容（每天凌晨 02:00 执行一次）</span>
00 02 * * * /bin/bash /home/tony/shells/clean_kafka_log.sh &gt; /dev/null 2&gt;&amp;1
</code></pre>
<h2 data-id="heading-22">第五阶段：搞定rabbitmq和pg</h2>
<p>这两个在我这里就是开发测试用，所以我就是参照官方文档和网上的一些教程还有AI的搭配，重新安装的，但是pg安装完成后有一个数据恢复的过程，这里简单过一下吧</p>
<h3 data-id="heading-23">PostgreSQL</h3>
<p>pg的安装我采用的是源码安装方式，因为我这里是open Euler系统，官方的提供rpm包我试着安装失败，所以改成了通过源码的方式。具体大家参考官网就好。</p>
<ul>
<li>安装依赖</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">sudo dnf check-update
sudo dnf install -y gcc gcc-c++ make readline-devel zlib-devel openssl-devel libicu-devel systemd-devel bison flex
</code></pre>
<ul>
<li>创建用户与目录</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 postgres 用户组和用户</span>
sudo groupadd postgres
sudo useradd -g postgres postgres

<span class="hljs-comment"># 创建安装目录和数据目录</span>
sudo <span class="hljs-built_in">mkdir</span> -p /opt/pgsql17
sudo <span class="hljs-built_in">mkdir</span> -p /var/lib/pgsql/17/data
sudo <span class="hljs-built_in">chown</span> -R postgres:postgres /opt/pgsql17 /var/lib/pgsql/17/data
</code></pre>
<ul>
<li>下载安装源码</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 切换到临时目录</span>
<span class="hljs-built_in">cd</span> /usr/local/src

<span class="hljs-comment"># 下载 PG 17.6 源码</span>
sudo wget https://ftp.postgresql.org/pub/source/v17.6/postgresql-17.6.tar.gz

<span class="hljs-comment"># 解压</span>
sudo tar -zxvf postgresql-17.6.tar.gz
<span class="hljs-built_in">cd</span> postgresql-17.6
</code></pre>
<ul>
<li>配置编译</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 配置（启用 OpenSSL 和 Systemd 支持）</span>
./configure --prefix=/opt/pgsql17 \
            --with-openssl \
            --with-systemd \
            --with-icu

<span class="hljs-comment"># 编译</span>
make

<span class="hljs-comment"># 安装</span>
sudo make install
</code></pre>
<p>make的时候会消耗一点时间</p>
<ul>
<li>配置环境变量</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 编辑 /etc/profile.d/pgsql.sh</span>
sudo bash -c <span class="hljs-string">'cat &gt; /etc/profile.d/pgsql.sh &lt;&lt; EOF
export PGHOME=/opt/pgsql17
export PGDATA=/var/lib/pgsql/17/data
export PATH=\$PGHOME/bin:\$PATH
EOF'</span>

<span class="hljs-comment"># 使配置生效</span>
<span class="hljs-built_in">source</span> /etc/profile.d/pgsql.sh
</code></pre>
<ul>
<li>初始化数据库</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 切换用户</span>
sudo -i -u postgres

<span class="hljs-comment"># 执行初始化</span>
/opt/pgsql17/bin/initdb -D /var/lib/pgsql/17/data --locale=en_US.UTF-8 --encoding=UTF8

<span class="hljs-comment"># 退出用户</span>
<span class="hljs-built_in">exit</span>
</code></pre>
<ul>
<li>配置开机启动</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">sudo vim /etc/systemd/system/postgresql-17.service
</code></pre>
<p>写入下面内容（这些教程上都有，我也是copy的，这里直接镜像一份）</p>
<pre><code class="hljs language-bash" lang="bash">[Unit]
Description=PostgreSQL 17 database server
After=network.target

[Service]
Type=notify
User=postgres
Group=postgres
ExecStart=/opt/pgsql17/bin/postmaster -D /var/lib/pgsql/17/data
ExecReload=/bin/kill -HUP <span class="hljs-variable">$MAINPID</span>
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target
</code></pre>
<ul>
<li>启动和验证</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 重新加载系统服务</span>
sudo systemctl daemon-reload

<span class="hljs-comment"># 启动并设置开机自启</span>
sudo systemctl <span class="hljs-built_in">enable</span> --now postgresql-17

<span class="hljs-comment"># 检查状态</span>
sudo systemctl status postgresql-17
</code></pre>
<ul>
<li>恢复备份</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 切换到 postgres 用户</span>
sudo -i -u postgres

<span class="hljs-comment"># 创建一个新数据库（例如叫 mydb）</span>
createdb mydb

<span class="hljs-comment"># -d 指定目标数据库，-f 指定备份文件路径</span>
psql -d mydb -f /root/pgbackup/pg14_full_backup.sql
</code></pre>
<ul>
<li>我这里是全量备份的，所以直接这样</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">psql -f /tmp/pg14_full_backup.sql postgres
</code></pre>
<blockquote>
<p>原节点的pg版本是14，新节点是17</p>
</blockquote>
<ul>
<li>异常处理</li>
</ul>
<p>执行过程中，openEuler开启了用那个的权限控制，所以可能要只ing一下操作</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 确保 postgres 用户对二进制文件夹有进入权限。</span>
sudo <span class="hljs-built_in">chmod</span> +x /opt/pgsql17/bin/postgres
sudo <span class="hljs-built_in">chown</span> -R postgres:postgres /opt/pgsql17
<span class="hljs-comment"># openEuler 的 SELinux 可能会阻止自定义路径下的程序执行。你可以临时关闭它测试一下</span>
sudo setenforce 0
<span class="hljs-comment"># 然后在重启下</span>
</code></pre>
<h3 data-id="heading-24">RabbitMQ</h3>
<p>上面pg的安装说了太多了，rabbitmq就精简点吧，大家自己搜一下也行，而且他这个有<a href="https://link.juejin.cn?target=https%3A%2F%2Frabbitmq.org.cn%2Fdocs" target="_blank" title="https://rabbitmq.org.cn/docs" ref="nofollow noopener noreferrer">中文文档</a>，也很详细。我这里就不多说了哈</p>
<p>直接跳过了!</p>
<h2 data-id="heading-25">结语</h2>
<p>上面这点事儿，白天折腾了一整天，晚上趁着热乎赶紧整理，主要还是怕自己忘了，因为有些步骤我在之前部署集群的时候确实是不熟练，所以把这些运维知识点也算是巩固对齐了一下。没想到，一整理起来，洋洋洒洒写了这么多。</p>
<p>最后，希望大家的服务器，永不宕机，永不重启！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Rust的多所有权机制]]></title>    <link>https://juejin.cn/post/7587245616754606131</link>    <guid>https://juejin.cn/post/7587245616754606131</guid>    <pubDate>2025-12-24T13:50:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587245616754606131" data-draft-id="7587245616754573363" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Rust的多所有权机制"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-24T13:50:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GKunLi"/> <meta itemprop="url" content="https://juejin.cn/user/430664725579725"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Rust的多所有权机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664725579725/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GKunLi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T13:50:04.000Z" title="Wed Dec 24 2025 13:50:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Rust 中，通常情况下一个值只能有一个所有者（Owner）。但在实际开发（尤其是 Web 开发）中，我们经常需要多个地方同时持有同一个数据。</p>
<p>比如在 <strong>Actix-web</strong> 中，你的数据库连接池或全局配置需要被每一个线程、每一个请求处理器（Handler）共享。这时候，单一所有权就不够用了。</p>
<p>为了解决这个问题，Rust 提供了<strong>多所有权</strong>机制，核心工具是 <code>Rc</code> 和 <code>Arc</code>。</p>
<h2 data-id="heading-0">1. 核心工具：引用计数（Reference Counting）</h2>
<p>多所有权的本质不是“复制数据”，而是 <strong>“共享数据，并记录有多少人在用它”</strong>。</p>
<h3 data-id="heading-1"><code>Rc&lt;T&gt;</code> (Reference Counted)</h3>
<ul>
<li><strong>适用场景</strong>：单线程环境。</li>
<li><strong>原理</strong>：你在堆上存一份数据，每当有人想要所有权，计数器就 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">+</span><span class="mord">1</span></span></span></span></span>；有人不用了，计数器就 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">−</span><span class="mord">1</span></span></span></span></span>。当计数器归零时，数据自动销毁。</li>
<li><strong>缺点</strong>：不是线程安全的。</li>
</ul>
<h3 data-id="heading-2"><code>Arc&lt;T&gt;</code> (Atomic Reference Counted)</h3>
<ul>
<li><strong>适用场景</strong>：多线程环境（<strong>Actix-web 开发中最常用</strong>）。</li>
<li><strong>原理</strong>：使用“原子操作”来更新计数器，确保在多线程同时修改计数时不会出错。</li>
<li><strong>代价</strong>：比 <code>Rc</code> 稍微重一点，但在 Web 并发环境下是必须的。</li>
</ul>
<hr/>
<h2 data-id="heading-3">2. 形象的比喻：合租房的钥匙</h2>
<ul>
<li>
<p><strong>普通所有权</strong>：一间房只有一把钥匙，你要进去，前一个人必须把钥匙彻底给你（Move）。他给你后，他就进不去了。</p>
</li>
<li>
<p><strong>多所有权 (Arc)</strong> ：房间还是那间房，但我们可以<strong>配很多把钥匙</strong>。</p>
<ul>
<li>每配一把（<code>.clone()</code>），登记簿上的“人数”就 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">+</span><span class="mord">1</span></span></span></span></span>。</li>
<li>每个人离开时把钥匙还回去，人数就 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">−</span><span class="mord">1</span></span></span></span></span>。</li>
<li><strong>最后一个人</strong>还钥匙并离开时，灯才会灭，房间（内存）才会被回收。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-4">3. 在 Actix-web 中的实战用法</h2>
<p>在 Actix-web 中，你几乎每天都在隐式或显式地使用 <code>Arc</code>。最典型的例子就是 <code>web::Data</code>。</p>
<p>Rust</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> actix_web::{web, App, HttpServer};
<span class="hljs-keyword">use</span> std::sync::Arc;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppState</span> {
    app_name: <span class="hljs-type">String</span>,
}

<span class="hljs-meta">#[actix_web::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> std::io::<span class="hljs-type">Result</span>&lt;()&gt; {
    <span class="hljs-comment">// 1. 创建共享状态</span>
    <span class="hljs-comment">// web::Data 内部其实就封装了一个 Arc</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">shared_data</span> = web::Data::<span class="hljs-title function_ invoke__">new</span>(AppState {
        app_name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"MyActixApp"</span>),
    });

    HttpServer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">move</span> || {
        App::<span class="hljs-title function_ invoke__">new</span>()
            .<span class="hljs-title function_ invoke__">app_data</span>(shared_data.<span class="hljs-title function_ invoke__">clone</span>()) <span class="hljs-comment">// 2. 这里在为每个线程“配钥匙”</span>
            .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">"/"</span>, web::<span class="hljs-title function_ invoke__">get</span>().<span class="hljs-title function_ invoke__">to</span>(index))
    })
    .<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">"127.0.0.1:8080"</span>)?
    .<span class="hljs-title function_ invoke__">run</span>()
    .<span class="hljs-keyword">await</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-5">4. 关键点：多所有权不代表“可变”</h2>
<p>这是初学者最容易混淆的地方：<strong><code>Arc</code> 本身只让你“看”，不让你“改”。</strong></p>
<ul>
<li>如果你有多把钥匙进入房间（<code>Arc</code>），你们默认只能进去<strong>参观</strong>。</li>
<li>如果其中一个人想进去<strong>装修（修改数据）</strong> ，必须配合<strong>内部可变性</strong>工具：<code>Mutex</code>（互斥锁）或 <code>RwLock</code>（读写锁）。</li>
</ul>
<p>所以，在 Rust 后端开发中，你经常会看到这种“叠罗汉”的写法：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code></p>
<blockquote>
<p>意思是：一个可以多线程共享（Arc）的、能锁住进行修改（Mutex）的数据。</p>
</blockquote>
<h2 data-id="heading-6">5. 总结</h2>





























<table><thead><tr><th><strong>工具</strong></th><th><strong>多所有权？</strong></th><th><strong>线程安全？</strong></th><th><strong>常用场景</strong></th></tr></thead><tbody><tr><td><code>Box&lt;T&gt;</code></td><td>❌ 否</td><td>❌ 否</td><td>堆上分配数据，单一所有权</td></tr><tr><td><code>Rc&lt;T&gt;</code></td><td>✅ 是</td><td>❌ 否</td><td>单线程内的复杂数据共享</td></tr><tr><td><code>Arc&lt;T&gt;</code></td><td>✅ 是</td><td>✅ 是</td><td><strong>Web 开发、多线程共享状态、数据库连接池</strong></td></tr></tbody></table>
<h3 data-id="heading-7">1). <code>Box&lt;T&gt;</code>：基础的堆内存分配</h3>
<blockquote>
<p>场景：当你有一个非常大的结构体，不希望在函数调用时在栈 <strong>（Stack）</strong> 上频繁拷贝；或者你需要定义递归类型。</p>
</blockquote>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigData</span> {
    data: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>], <span class="hljs-comment">// 1MB 的大数据</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// 将大数据放入堆（Heap）中，栈上只保留一个指针</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">boxed_data</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(BigData {
        data: [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>],
    });

    <span class="hljs-comment">// 传递时非常快，只移动指针</span>
    <span class="hljs-title function_ invoke__">process_data</span>(boxed_data);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_data</span>(data: <span class="hljs-type">Box</span>&lt;BigData&gt;) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"处理了 {} 字节的数据"</span>, data.data.<span class="hljs-title function_ invoke__">len</span>());
}
</code></pre>
<h3 data-id="heading-8">2). <code>Rc&lt;T&gt;</code>：单线程内的多处共享</h3>
<blockquote>
<p>场景：在 GUI 开发或单线程逻辑中，有多个对象需要引用同一个配置，且没有线程安全压力。</p>
</blockquote>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> std::rc::Rc;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> {
    theme: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">common_config</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Config {
        theme: <span class="hljs-string">"Dark"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
    });

    <span class="hljs-comment">// 克隆 Rc，增加计数，不拷贝数据本身</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">component_a</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;common_config);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">component_b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;common_config);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"当前配置引用数: {}"</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;common_config)); <span class="hljs-comment">// 输出 3</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"组件 A 的主题: {}"</span>, component_a.theme);
}
</code></pre>
<h3 data-id="heading-9">3). <code>Arc&lt;T&gt;</code>：Actix-web 中的多线程状态共享</h3>
<blockquote>
<p>场景：这是你在学习 Actix-web 时最常用的。它让多个 worker 线程能安全地访问同一个全局状态（比如数据库连接、全局计数器）。
注意：如果要修改数据，通常配合 Mutex 使用。</p>
</blockquote>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> actix_web::{web, App, HttpServer, Responder};
<span class="hljs-keyword">use</span> std::sync::{Arc, Mutex};

<span class="hljs-comment">// 定义全局状态</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AppState</span> {
    <span class="hljs-comment">// Arc 保证多个线程都能持有这个计数器</span>
    <span class="hljs-comment">// Mutex 保证同一时刻只有一个线程能修改它</span>
    visitor_count: Arc&lt;Mutex&lt;<span class="hljs-type">u32</span>&gt;&gt;,
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>(data: web::Data&lt;AppState&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Responder</span> {
    <span class="hljs-comment">// 1. 先锁住数据</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = data.visitor_count.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-comment">// 2. 解引用并修改</span>
    *count += <span class="hljs-number">1</span>;
    
    <span class="hljs-built_in">format!</span>(<span class="hljs-string">"你是第 {} 位访客"</span>, count)
}

<span class="hljs-meta">#[actix_web::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> std::io::<span class="hljs-type">Result</span>&lt;()&gt; {
    <span class="hljs-comment">// 创建共享状态</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">app_state</span> = AppState {
        visitor_count: Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>)),
    };
    
    <span class="hljs-comment">// 包装成 Actix 的 Data 类型（它内部也会处理 Arc）</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = web::Data::<span class="hljs-title function_ invoke__">new</span>(app_state);

    HttpServer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">move</span> || {
        App::<span class="hljs-title function_ invoke__">new</span>()
            .<span class="hljs-title function_ invoke__">app_data</span>(data.<span class="hljs-title function_ invoke__">clone</span>()) <span class="hljs-comment">// 每个线程都拿到一个 Arc 的副本</span>
            .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">"/"</span>, web::<span class="hljs-title function_ invoke__">get</span>().<span class="hljs-title function_ invoke__">to</span>(index))
    })
    .<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">"127.0.0.1:8080"</span>)?
    .<span class="hljs-title function_ invoke__">run</span>()
    .<span class="hljs-keyword">await</span>
}
</code></pre>
<h3 data-id="heading-10">核心区别总结：</h3>
<ul>
<li>
<p>Box：独占所有权。就像你买了一本书放在家里，只有你能看。</p>
</li>
<li>
<p>Rc：单线程多所有权。就像在家里（单线程），你和爸妈共享一台电视机，看电视的人数为 0 时电视才关掉。</p>
</li>
<li>
<p>Arc：多线程多所有权。就像在公司（多线程），大家共用一台饮水机。因为有多个人（线程）可能同时去接水，所以需要特殊的“原子操作”来记录人数，确保安全。</p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[苍穹外卖—Knife4j 的接口文档打不开的一种解决方法]]></title>    <link>https://juejin.cn/post/7587245616754769971</link>    <guid>https://juejin.cn/post/7587245616754769971</guid>    <pubDate>2025-12-24T15:21:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587245616754769971" data-draft-id="7587263750248874035" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="苍穹外卖—Knife4j 的接口文档打不开的一种解决方法"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-24T15:21:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="今天好冷"/> <meta itemprop="url" content="https://juejin.cn/user/4381977769945513"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            苍穹外卖—Knife4j 的接口文档打不开的一种解决方法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4381977769945513/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    今天好冷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T15:21:21.000Z" title="Wed Dec 24 2025 15:21:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">前因</h4>
<p>前一天跟着黑马敲完了员工分页查询的代码，第二天跟着敲了启用禁用的内容，敲完要用Knife4j接口文档的时候，突然就弹bug了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99ac15f7840f48ff8a8f08fdd8ad25e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LuK5aSp5aW95Ya3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767194481&amp;x-signature=6hYMKvyPljIkV0TM0j%2BsSxQzuok%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c71e670e6fa64f918ba0e01820e1ffa6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LuK5aSp5aW95Ya3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1767194481&amp;x-signature=rf4mkEcnhEJgnniUWcc8084sviY%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-1">查原因</h4>
<p>后面问ai问了好久，后来查出问题是出在那个自定义的转换器上(skyserver/src/main/java/com/sky/config/WebMvcConfiguration.java)</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//创建一个消息转换器对象</span>
MappingJackson2HttpMessageConverter converter = new <span class="hljs-built_in">MappingJackson2HttpMessageConverter</span>();
<span class="hljs-comment">//为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span>
converter<span class="hljs-selector-class">.setObjectMapper</span>(new JacksonObjectMapper());
<span class="hljs-comment">//将自己的消息转换器加入容器</span>
converters<span class="hljs-selector-class">.add</span>(<span class="hljs-number">0</span>,converter);     
<span class="hljs-comment">/*把自定义的转换器加到了第一位，这导致系统在生成接口文档(JSON数据)时，
错误地使用了自定义转换器，把文档对象变成了一串 Base64 字符串，前端看不懂就报错了。*/</span> 
</code></pre>
<h4 data-id="heading-2">解决方法</h4>
<p>自测了一下，能够正常打开Knife4j文档，时间格式等的json转换也正常</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 推荐做法：遍历找到系统自带的那个转换器，只替换它的“翻译字典”（ObjectMapper）</span>
<span class="hljs-comment">// 这样既保留了系统原有的兼容性（文档能看），又加上了你的 Long 转 String 功能</span>
<span class="hljs-keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : converters) {
    <span class="hljs-keyword">if</span> (converter <span class="hljs-keyword">instanceof</span> MappingJackson2HttpMessageConverter) {
    <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">jacksonConverter</span> <span class="hljs-operator">=</span> (MappingJackson2HttpMessageConverter) converter;
    jacksonConverter.setObjectMapper(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonObjectMapper</span>());
    <span class="hljs-comment">// 找到一个替换了就行，不需要全部替换</span>
    <span class="hljs-keyword">break</span>;
   }
}
</code></pre>
<p>个人根据ai得出的方法，如有错请指正！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 自定义指令实现图片懒加载：从原理到实践]]></title>    <link>https://juejin.cn/post/7587238733504397355</link>    <guid>https://juejin.cn/post/7587238733504397355</guid>    <pubDate>2025-12-24T12:03:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7587238733504397355" data-draft-id="7587245616753901619" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 自定义指令实现图片懒加载：从原理到实践"/> <meta itemprop="keywords" content="JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-12-24T12:03:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="saberxyL"/> <meta itemprop="url" content="https://juejin.cn/user/3942228504379243"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 自定义指令实现图片懒加载：从原理到实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3942228504379243/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    saberxyL
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-24T12:03:01.000Z" title="Wed Dec 24 2025 12:03:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-24
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 为什么要实现懒加载？</h2>
<p>在现代 Web 应用中，图片是流量消耗大户。如果页面包含大量图片（如相册、商品列表），<strong>首屏加载时间</strong>会显著增加。懒加载的核心思想是：</p>
<ul>
<li><strong>延迟加载</strong>：图片进入可视区域时才开始加载</li>
<li><strong>提升性能</strong>：减少首屏请求数，节省用户流量</li>
<li><strong>优化体验</strong>：快速响应，避免页面卡顿</li>
</ul>
<hr/>
<h2 data-id="heading-1">2. 核心原理</h2>
<h3 data-id="heading-2">2.1 技术栈选择</h3>
<ul>
<li><strong>Vue3 自定义指令</strong>：<code>v-lazy</code>，直接操作 DOM 元素</li>
<li><strong>Intersection Observer API</strong>：现代浏览器原生 API，监听元素是否进入视口</li>
<li><strong>图片预加载</strong>：创建 <code>Image</code> 对象提前加载，避免直接修改 <code>src</code> 导致闪烁</li>
</ul>
<h3 data-id="heading-3">2.2 工作流程</h3>
<pre><code class="hljs language-text" lang="text">1. 元素初始化 → 设置默认 loading 图片
2. 开启 IntersectionObserver 监听
3. 元素进入视口 (isIntersecting = true) → 触发加载
4. 预加载图片 → onload → 设置真实 src
5. 预加载失败 → onerror → 设置错误图
6. 关闭监听，防止重复加载
</code></pre>
<hr/>
<h2 data-id="heading-4">3. 完整代码实现</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/directives/lazy.js</span>

<span class="hljs-comment">// 默认图片（建议使用 Base64 或本地路径）</span>
<span class="hljs-keyword">const</span> defaultLoading = <span class="hljs-string">'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'</span>
<span class="hljs-keyword">const</span> defaultError = <span class="hljs-string">'https://cdn.example.com/images/error.png'</span>

<span class="hljs-keyword">const</span> imgLazy = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
    <span class="hljs-keyword">let</span> observer = <span class="hljs-literal">null</span>

    <span class="hljs-comment">// 1. 解析指令参数（支持对象和字符串两种形式）</span>
    <span class="hljs-keyword">const</span> { src, loading, error } =
      <span class="hljs-keyword">typeof</span> binding.<span class="hljs-property">value</span> === <span class="hljs-string">'object'</span>
        ? binding.<span class="hljs-property">value</span>
        : { <span class="hljs-attr">src</span>: binding.<span class="hljs-property">value</span> }

    <span class="hljs-comment">// 2. 初始化：设置加载中的占位图</span>
    el.<span class="hljs-property">src</span> = loading || defaultLoading

    <span class="hljs-comment">// 3. 图片预加载函数（核心逻辑）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">imgLoad</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>() <span class="hljs-comment">// 创建虚拟 Image 对象预加载</span>
      img.<span class="hljs-property">src</span> = src

      <span class="hljs-comment">// 加载成功</span>
      img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
        el.<span class="hljs-property">src</span> = src
        <span class="hljs-comment">// 可选：添加淡入动画</span>
        el.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">'opacity 0.3s'</span>
        el.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-string">'1'</span>
      }

      <span class="hljs-comment">// 加载失败</span>
      img.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
        el.<span class="hljs-property">src</span> = error || defaultError
      }
    }

    <span class="hljs-comment">// 4. 创建 IntersectionObserver 监听</span>
    observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> entry = entries[<span class="hljs-number">0</span>]

      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
        <span class="hljs-title function_">imgLoad</span>() <span class="hljs-comment">// 进入视口，开始加载</span>
        observer.<span class="hljs-title function_">unobserve</span>(el) <span class="hljs-comment">// 关闭监听，避免重复加载</span>
      }
    }, {
      <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'100px'</span>, <span class="hljs-comment">// 提前 100px 开始加载，提升体验</span>
      <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.01</span> <span class="hljs-comment">// 只要有一点点可见就触发</span>
    })

    <span class="hljs-comment">// 5. 开启监听，并挂载到元素上（方便卸载时清理）</span>
    observer.<span class="hljs-title function_">observe</span>(el)
    el.<span class="hljs-property">_imgObserver</span> = observer
  },

  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
    <span class="hljs-comment">// 6. 清理监听器，防止内存泄漏</span>
    el.<span class="hljs-property">_imgObserver</span>?.<span class="hljs-title function_">unobserve</span>(el)
    el.<span class="hljs-property">_imgObserver</span> = <span class="hljs-literal">null</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> imgLazy
</code></pre>
<hr/>
<h2 data-id="heading-5">4. 在 Vue3 中使用</h2>
<h3 data-id="heading-6">4.1 全局注册</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> imgLazy <span class="hljs-keyword">from</span> <span class="hljs-string">'./directives/lazy'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'lazy'</span>, imgLazy)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h3 data-id="heading-7">4.2 组件内使用</h3>
<pre><code class="hljs language-Vue" lang="Vue">&lt;template&gt;
  &lt;div class="gallery"&gt;
    &lt;!-- 基础用法：直接传 URL --&gt;
    &lt;img v-lazy="item.url" v-for="item in list" :key="item.id" /&gt;

    &lt;!-- 进阶用法：配置 loading 和 error --&gt;
    &lt;img
      v-lazy="{
        src: item.url,
        loading: '/images/loading.gif',
        error: '/images/error.png'
      }"
      v-for="item in list"
      :key="item.id"
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      list: [
        { id: 1, url: 'https://example.com/img1.jpg' },
        { id: 2, url: 'https://example.com/img2.jpg' },
        // ... 更多图片
      ]
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
/* 可选：添加加载动画 */
img {
  opacity: 0;
  transition: opacity 0.3s;
}
img[src] {
  opacity: 1;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-8">5. 进阶优化建议</h2>
<h3 data-id="heading-9">5.1 性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 优化的 observer 配置</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, {
  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'200px'</span>, <span class="hljs-comment">// 更大的预加载区域</span>
  <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span>,      <span class="hljs-comment">// 10% 可见时触发</span>
  <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>           <span class="hljs-comment">// 相对于视口</span>
})
</code></pre>
<h3 data-id="heading-10">5.2 支持 WebP 和懒加载降级</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">imgLoad</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()

  <span class="hljs-comment">// 检测浏览器是否支持 WebP</span>
  <span class="hljs-keyword">const</span> supportsWebP = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>).<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">'image/webp'</span>).<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'data:image/webp'</span>) === <span class="hljs-number">0</span>

  img.<span class="hljs-property">src</span> = supportsWebP ? src.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.webp'</span>) : src

  img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> { el.<span class="hljs-property">src</span> = img.<span class="hljs-property">src</span> }
  img.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> { el.<span class="hljs-property">src</span> = error || defaultError }
}
</code></pre>
<h3 data-id="heading-11">5.3 添加加载完成回调</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 扩展指令支持回调</span>
<span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
  <span class="hljs-keyword">const</span> { src, loading, error, onLoaded, onError } = binding.<span class="hljs-property">value</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">imgLoad</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()
    img.<span class="hljs-property">src</span> = src
    img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
      el.<span class="hljs-property">src</span> = src
      onLoaded?.(el) <span class="hljs-comment">// 加载完成回调</span>
    }
    img.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
      el.<span class="hljs-property">src</span> = error || defaultError
      onError?.(el) <span class="hljs-comment">// 加载失败回调</span>
    }
  }
  <span class="hljs-comment">// ... 其余代码</span>
}
</code></pre>
<p>使用：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;img v-lazy="{
  src: item.url,
  onLoaded: (el) =&gt; console.log('图片加载完成', el),
  onError: (el) =&gt; console.log('图片加载失败', el)
}" /&gt;
</code></pre>
<hr/>
<h2 data-id="heading-12">6. 注意事项与最佳实践</h2>
<h3 data-id="heading-13">6.1 内存泄漏防范</h3>
<ul>
<li>✅ <strong>必须在 <code>unmounted</code> 时调用 <code>unobserve</code></strong></li>
<li>✅ 避免在组件卸载后继续操作 DOM</li>
<li>✅ 使用 <code>?.</code> 可选链操作符防止报错</li>
</ul>
<h3 data-id="heading-14">6.2 图片格式建议</h3>
<ul>
<li><strong>loading 图片</strong>：使用 1x1 像素的透明 GIF 或 Base64，避免额外请求</li>
<li><strong>error 图片</strong>：使用稳定的 CDN 地址或本地资源</li>
<li><strong>真实图片</strong>：优先使用 WebP 格式，体积更小</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>