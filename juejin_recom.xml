<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Go语言动手写Web框架 - Gee第一天]]></title>    <link>https://juejin.cn/post/7585222924565921832</link>    <guid>https://juejin.cn/post/7585222924565921832</guid>    <pubDate>2025-12-19T07:53:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585222924565921832" data-draft-id="7585130590292705295" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go语言动手写Web框架 - Gee第一天"/> <meta itemprop="keywords" content="Go"/> <meta itemprop="datePublished" content="2025-12-19T07:53:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Way2top"/> <meta itemprop="url" content="https://juejin.cn/user/1458388314893300"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go语言动手写Web框架 - Gee第一天
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1458388314893300/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Way2top
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:53:16.000Z" title="Fri Dec 19 2025 07:53:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>写在前面：本项目参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgeektutu.com%2Fpost%2Fgee.html" target="_blank" title="https://geektutu.com/post/gee.html" ref="nofollow noopener noreferrer">7天用Go从零实现Web框架Gee教程</a>，下面的内容全部来自于该网站内容。主要是记录我在学习过程中的所思所想，如有存在问题还请多多指教。</p>
<h3 data-id="heading-0">Day1</h3>
<h4 data-id="heading-1">标准库启动 Web 服务</h4>
<p>Go 内置了 <code>net/http</code> 库，封装了HTTP网络编程的基础的接口，我们实现的<code>Gee</code> Web 框架便是基于<code>net/http</code>的。我们接下来通过一个例子，简单介绍下这个库的使用。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"log"</span>
        <span class="hljs-string">"net/http"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        http.HandleFunc(<span class="hljs-string">"/"</span>, indexHandler)
        http.HandleFunc(<span class="hljs-string">"/hello"</span>, helloHandler)
        log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, <span class="hljs-literal">nil</span>))
}

<span class="hljs-comment">// handler echoes r.URL.Path</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
        fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        <span class="hljs-comment">// 等价于</span>
        <span class="hljs-comment">// data := []byte(`URL.Path = "/"\n`)</span>
        <span class="hljs-comment">// w.Write(data)</span>
}

<span class="hljs-comment">// handler echoes r.URL.Header</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
        <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {
                fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)
        }
}
</code></pre>
<p><code>http.HandleFunc</code> 的作用是注册路由+注册处理函数，这里简单来说就是：</p>
<ul>
<li>
<p>当请求命中 <code>/</code> 的时候执行<code>indexHandler</code></p>
</li>
<li>
<p>当请求命中 <code>/hello</code> 的时候执行 <code>helloHandler</code></p>
</li>
</ul>
<p>对于注册的处理函数（这里就是 <code>indexHandler</code> 和 <code>helloHandler</code>）也是有要求的，它的签名必须是：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span>
</code></pre>
<p>否则编译都过不了。</p>
<p>程序运行后，终端输入命令有如下结果：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">coding</span>/<span class="hljs-selector-tag">GoProject</span>/<span class="hljs-selector-tag">Gee</span> <span class="hljs-selector-tag">via</span>  <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.24</span><span class="hljs-selector-class">.3</span> 
❯ <span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//localhost:9999/</span>
<span class="hljs-selector-tag">URL</span><span class="hljs-selector-class">.Path</span> = "/"

<span class="hljs-selector-tag">coding</span>/<span class="hljs-selector-tag">GoProject</span>/<span class="hljs-selector-tag">Gee</span> <span class="hljs-selector-tag">via</span>  <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.24</span><span class="hljs-selector-class">.3</span> 
❯ <span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//localhost:9999/hello</span>
<span class="hljs-selector-tag">Header</span><span class="hljs-selector-attr">[<span class="hljs-string">"Accept"</span>]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">"*/*"</span>]</span>
<span class="hljs-selector-tag">Header</span><span class="hljs-selector-attr">[<span class="hljs-string">"User-Agent"</span>]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">"curl/8.7.1"</span>]</span>
</code></pre>
<p>我们现在就来分析一下，从 <code> curl  ``http://localhost:9999/</code> 到 <code>URL.Path = "/"</code> 的完整流程。</p>
<p>当用户输入 <code> curl  ``http://localhost:9999/</code> 的时候，程序监听到了这个请求，发现请求路径为 <code>/</code>，于是触发与 <code>/</code> 绑定的处理函数 <code>indexHandler</code>。</p>
<p>我们发现这个 <code>indexHandler</code> 包含两个传参 <code>w</code> 和 <code>r</code>，但实际上这两个传参完全不需要我们手动操作或者在某个地方手动传入。当收到请求报文的时候，<code>net/http</code> 会自动帮我们解析请求报文，并从中解析出 <code>w http.ResponseWriter</code> 和 <code>req *http.Request</code> 这两个参数，然后自动传入 <code>indexHandler</code> 中。于是接下来就直接走到了函数内部的 <code>fmt.Fprintf(w, "URL.Path = %q\n", req.URL.Path)</code> 中了。</p>
<p>在讲接下来的数据流向之前，有必要讲清楚 <code>http.ResponseWriter</code> 以及 <code>fmt.Fprintf</code>。首先，<code>http.ResponseWriter</code> 是一个接口，接口结构如下：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> ResponseWriter <span class="hljs-keyword">interface</span> {
        Header() Header
        Write([]<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)
        WriteHeader(statusCode <span class="hljs-type">int</span>)
}
</code></pre>
<p>通过 <code>net/http</code> 解析出来的 <code>w</code> 传参就是一个实现了 <code>ResponseWriter</code> 接口的对象。<code>w</code> 在源码层面是一个接口类型变量，但运行时它持有的是一个实现了 <code>ResponseWriter</code> 接口的具体结构体实例。</p>
<p><strong>w 不是抽象的“接口对象”，它是一个具体结构体示例。</strong> 在标准库里大概是这种结构（简化代码）：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> response <span class="hljs-keyword">struct</span> {
    conn    *conn          <span class="hljs-comment">// TCP 连接</span>
    buf     *bufio.Writer  <span class="hljs-comment">// 写缓冲</span>
    header  Header
    status  <span class="hljs-type">int</span>
}
</code></pre>
<p>那么也就是说，传入 <code>indexHandler</code> 的参数 <code>w</code> 实现了 <code>Write</code> 方法。</p>
<p>接下来看到 <code>fmt.Fprintf</code>。我们来看 <code>fmt.Fprintf</code> 的定义：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...any)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)
</code></pre>
<p>这里，只要 <code>w</code> 实现了 <code>io.Writer</code>，那么 <code>Fprintf</code> 内部就会调用 <code>w.Write</code>。而 <code>http.ResponseWriter</code> <strong>实现了</strong> <strong><code>io.Writer</code></strong> <strong>，</strong> 所以：</p>
<pre><code class="hljs language-arduino" lang="arduino">fmt.<span class="hljs-built_in">Fprintf</span>(w, <span class="hljs-string">"hello"</span>)
</code></pre>
<p>实际执行的是：</p>
<pre><code class="hljs language-lua" lang="lua">w.Write([]<span class="hljs-built_in">byte</span>(<span class="hljs-string">"hello"</span>)) // 至于为什么是 []<span class="hljs-built_in">byte</span>(<span class="hljs-string">"hello"</span>) 而不是 <span class="hljs-string">"hello"</span>，是因为实际上在 Write 之前还有一个格式化的步骤，具体可以去看看 Fprintf 的源码
</code></pre>
<p>到这里我们就可以看懂示例代码中的这句了：</p>
<pre><code class="hljs language-perl" lang="perl">fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
</code></pre>
<p>它等价于：</p>
<pre><code class="hljs language-ini" lang="ini">data := <span class="hljs-section">[]</span>byte(`<span class="hljs-attr">URL.Path</span> = <span class="hljs-string">"/"</span>\n`)
w.Write(data)
</code></pre>
<p>这里之前还需要简单说一下 req，你可以简单理解为，通过 req 就可以拿到请求报文中的所有东西，例如：</p>
<pre><code class="hljs language-scss" lang="scss">req<span class="hljs-selector-class">.Method</span>        <span class="hljs-comment">// "GET"</span>
req<span class="hljs-selector-class">.URL</span><span class="hljs-selector-class">.Path</span>      <span class="hljs-comment">// "/hello"</span>
req<span class="hljs-selector-class">.URL</span><span class="hljs-selector-class">.RawQuery</span>  <span class="hljs-comment">// "name=ryan"</span>
req<span class="hljs-selector-class">.Proto</span>         <span class="hljs-comment">// "HTTP/1.1"</span>
req<span class="hljs-selector-class">.URL</span><span class="hljs-selector-class">.Query</span>()<span class="hljs-selector-class">.Get</span>("name")
req<span class="hljs-selector-class">.URL</span><span class="hljs-selector-class">.Query</span>()<span class="hljs-selector-attr">[<span class="hljs-string">"name"</span>]</span>
</code></pre>
<p>所以这里是把请求报文中的请求路径拿过来做了一个拼接，然后作为 <code>x.Write</code> 的传参写入。</p>
<hr/>
<p>至此我们已经捋清楚了从请求报文发过来一直到将其中的请求路径作为 <code>x.Write</code> 传参写入的过程了，接下来的问题就是，<code>x.Write</code> 是啥？它写入到了哪里？写完之后我又是怎么在终端看到最终结果的呢？</p>
<p>具体来说：</p>
<ul>
<li>
<p><code>w</code> 是 <code>net/http</code> 内部的 response 对象</p>
</li>
<li>
<p><code>Write</code> 把字节写入 <strong>HTTP 响应缓冲区</strong></p>
</li>
<li>
<p>handler 返回后</p>
</li>
<li>
<p><code>net/http</code> 把这些字节通过 TCP 发给浏览器</p>
</li>
</ul>
<h4 data-id="heading-2"><code>http.Handler</code> 接口</h4>
<p>现在我们回头看看一开始的示例代码，就应该很清晰了：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"log"</span>
        <span class="hljs-string">"net/http"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        http.HandleFunc(<span class="hljs-string">"/"</span>, indexHandler)
        http.HandleFunc(<span class="hljs-string">"/hello"</span>, helloHandler)
        log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, <span class="hljs-literal">nil</span>))
}

<span class="hljs-comment">// handler echoes r.URL.Path</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
        fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        <span class="hljs-comment">// 等价于</span>
        <span class="hljs-comment">// data := []byte(`URL.Path = "/"\n`)</span>
        <span class="hljs-comment">// w.Write(data)</span>
}

<span class="hljs-comment">// handler echoes r.URL.Header</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
        <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {
                fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)
        }
}
</code></pre>
<p>在示例代码中，我们通过 http.HandleFunc 注册了两个函数：</p>
<ul>
<li>
<p>"/" 路径对应 indexHandler</p>
</li>
<li>
<p>"/hello" 路径对应 helloHandler</p>
</li>
</ul>
<p>当浏览器或 curl 发起请求时，net/http 会自动调用我们注册的函数，并将请求信息封装成 req，响应的写入器封装成 w，传入函数内部。</p>
<p>也就是说，每一个请求都会被自动交给一个“处理单元”来处理，我们不需要自己去解析报文、管理 TCP 连接或构造响应。</p>
<p><strong>这种把请求和处理逻辑绑定起来，并由框架负责调用的机制，就是 Go 语言中所谓的 handler 模型。</strong></p>
<p>官方定义上，handler 是一个接口：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> {
    ServeHTTP(w http.ResponseWriter, r *http.Request)
}
</code></pre>
<p>任何实现了 ServeHTTP 方法的对象，都是一个 handler。我们注册的函数其实是通过 http.HandlerFunc 适配器被自动包装成了 Handler，从而可以被 net/http 调用。</p>
<p>这里你可能有一个疑问，函数怎么可以实现一个接口呢？不都是结构体实现接口吗？这是怎么适配的？</p>
<p>实际上，GO 允许你为自定义类型添加方法，不管这个类型是结构体、内置类型还是函数类型。</p>
<p>在标准库中就定义了一个类型：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span>
</code></pre>
<p>然后给他添加一个方法：</p>
<pre><code class="hljs language-scss" lang="scss">func (f HandlerFunc) <span class="hljs-built_in">ServeHTTP</span>(w http.ResponseWriter, r *http.Request) {
    <span class="hljs-built_in">f</span>(w, r)
}
</code></pre>
<p>所以 <strong>函数类型也实现了</strong> <strong><code>http.Handler</code></strong> <strong>接口</strong>。</p>
<p>总结来说：</p>
<ul>
<li>handler 是处理单个 HTTP 请求的逻辑单元</li>
<li>可以是函数，也可以是实现 ServeHTTP 的结构体</li>
<li>它让我们只需关注业务逻辑，不必关心底层网络和报文处理</li>
</ul>
<hr/>
<h4 data-id="heading-3">手动实现 <code>Engine</code> 统一处理请求</h4>
<p>示例代码的最后一行是用来启动 Web 服务的：</p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-built_in">log</span>.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, <span class="hljs-literal">nil</span>))
</code></pre>
<p>通过查看源码可以知道，<code>ListenAndServe</code> 的第二个传参是一个 Handler 类型，默认为空：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-type">string</span>, handler Handler)</span></span> <span class="hljs-type">error</span> {
        server := &amp;Server{Addr: addr, Handler: handler}
        <span class="hljs-keyword">return</span> server.ListenAndServe()
}
</code></pre>
<p>前面我们已经介绍过了 Handler 类型，如果 ListenAndServe 不传入 Handler 类型参数，那么使用全局默认的路由映射表处理请求（<code>http.DefaultServeMux</code>），如果我们传入了参数，那么就按照我们自己传入的 Handler 类型来处理 HTTP 请求，更准确的说，是根据我们传入的 Handler 类型的 ServeHTTP 方法来处理 HTTP 请求。</p>
<p>这一小节我们就来自己构建一个实现了 Handler 接口的结构体 <code>Engine</code>。</p>
<p>具体代码实现如下：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"log"</span>
        <span class="hljs-string">"net/http"</span>
)

<span class="hljs-comment">// Engine is the uni handler for all requests</span>
<span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {
        <span class="hljs-keyword">switch</span> req.URL.Path {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:
                fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        <span class="hljs-keyword">case</span> <span class="hljs-string">"/hello"</span>:
                <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {
                        fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)
                }
        <span class="hljs-keyword">default</span>:
                fmt.Fprintf(w, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, req.URL)
        }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        engine := <span class="hljs-built_in">new</span>(Engine)
        log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, engine))
}
</code></pre>
<p>首先我们定义了一个 <code>Engine</code> 类型的结构体。这里解释一下为什么是一个空的结构体：因为我们并不需要该结构体来存储任何数据，我们只是希望构建一个实现了 Handler 接口的（也就是实现了 ServeHTTP 方法）的结构体，那么使用空结构体来实现就是一种很合适的方式，我们希望 <code>Engine</code> 只是一种“行为承载体”，方法集就是它的存在意义。另外，Go 中的空结构体还不会占用任何内存。</p>
<p>当然，这里只是简单实现 ServeHTTP 方法，后续版本中我们会慢慢完善 <code>Engine</code>，到后面 <code>Engine</code> 就不再是空结构体了，还需要包含一些数据类型用于存储。只是在这一部分，使用空结构体是没有问题的。</p>
<p>继续往下走，就到了具体实现 ServeHTTP 的部分了。显然，两个传参是必要的（因为 Handler 中的 ServeHTTP 就需要这两个类型的传参）。</p>
<p>接着我们可以看到，通过 <code>switch</code> 对 请求的地址（<code>req.URL.Path</code>）进行判断：</p>
<ul>
<li>
<p>如果是 "/"，打印 <code>req.URL.Path</code></p>
</li>
<li>
<p>如果是 "/hello"，打印 <code>req.Header</code></p>
</li>
<li>
<p>如果都不是，打印 <code>"404 NOT FOUND: %s\n"</code></p>
</li>
</ul>
<p>那么你会发现，我们把对于不同路由的处理，写到了我们自定义的实现了 Handler 接口的 <code>Engine</code> 结构体中。运行这个函数之后，在终端输入命令，同样会得到如下结果：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">coding</span>/<span class="hljs-selector-tag">GoProject</span>/<span class="hljs-selector-tag">Gee</span> <span class="hljs-selector-tag">via</span>  <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.24</span><span class="hljs-selector-class">.3</span> 
❯ <span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//localhost:9999/     </span>
<span class="hljs-selector-tag">URL</span><span class="hljs-selector-class">.Path</span> = "/"

<span class="hljs-selector-tag">coding</span>/<span class="hljs-selector-tag">GoProject</span>/<span class="hljs-selector-tag">Gee</span> <span class="hljs-selector-tag">via</span>  <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.24</span><span class="hljs-selector-class">.3</span> 
❯ <span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//localhost:9999/hello</span>
<span class="hljs-selector-tag">Header</span><span class="hljs-selector-attr">[<span class="hljs-string">"User-Agent"</span>]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">"curl/8.7.1"</span>]</span>
<span class="hljs-selector-tag">Header</span><span class="hljs-selector-attr">[<span class="hljs-string">"Accept"</span>]</span> = <span class="hljs-selector-attr">[<span class="hljs-string">"*/*"</span>]</span>

<span class="hljs-selector-tag">coding</span>/<span class="hljs-selector-tag">GoProject</span>/<span class="hljs-selector-tag">Gee</span> <span class="hljs-selector-tag">via</span>  <span class="hljs-selector-tag">v1</span><span class="hljs-selector-class">.24</span><span class="hljs-selector-class">.3</span> 
❯ <span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//localhost:9999/world</span>
<span class="hljs-number">404</span> <span class="hljs-selector-tag">NOT</span> <span class="hljs-selector-tag">FOUND</span>: /<span class="hljs-selector-tag">world</span>
</code></pre>
<blockquote>
<p>在 <code>main</code> 函数中，我们给 <code>ListenAndServe</code> 方法的第二个参数传入了刚才创建的<code>engine</code>实例。至此，我们走出了实现Web框架的第一步，即，将所有的HTTP请求转向了我们自己的处理逻辑。还记得吗，在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。</p>
<p>代码的运行结果与之前的是一致的。</p>
</blockquote>
<p>这里有必要解释一下，为什么说这算是迈出了实现 Web 框架的第一步。</p>
<p>在没有自定义 Engine 之前：</p>
<ul>
<li>
<p>每个路由都要单独注册 handler</p>
</li>
<li>
<p>每个 handler 只处理自己对应的路径</p>
</li>
<li>
<p><strong>控制权分散在各个函数里</strong></p>
</li>
<li>
<p>想做统一操作（日志、异常处理、统一返回格式）就很麻烦，需要在每个 handler 里重复写</p>
</li>
</ul>
<p>但是在定义了 Engine 之后，所有的请求都需要先经过 <code>engine.ServeHTTP</code>，那么在这个我们自己实现的 <code>engine.ServeHTTP</code> 内部，就可以做：</p>
<ul>
<li>
<p>路由匹配</p>
</li>
<li>
<p>日志打印</p>
</li>
<li>
<p>异常处理</p>
</li>
<li>
<p>响应统一封装</p>
</li>
</ul>
<p><strong>核心变化</strong>：控制权从“分散在各个 handler 函数” → “集中在 Engine 里统一管理”。</p>
<p>当然了，这里的 Engine 只是为了引出实现 Web 框架的一个例子，实际上路由匹配肯定不是像现在这么写了，如果像现在这样写，那么每多一个路由都要改 Engine 的源代码，当然是不行的。</p>
<p>Engine 的核心价值是“统一入口 + 可扩展分发”，路由匹配写在 Engine 里只是为了演示；实际框架中路由匹配由映射表管理，用户注册路由，Engine 只负责分发，这样就不会每次加路由都改 Engine 代码。</p>
<h4 data-id="heading-4">Gee 框架的雏形</h4>
<p>下面，我们重新组织上面代码，搭建出整个框架的雏形。最终的代码目录结构是这样的：</p>
<pre><code class="hljs language-go" lang="go">gee/
  |--gee.<span class="hljs-keyword">go</span>
  |--<span class="hljs-keyword">go</span>.mod
main.<span class="hljs-keyword">go</span>
<span class="hljs-keyword">go</span>.mod
</code></pre>
<p><strong>gee/go.mod</strong></p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-keyword">module</span> <span class="hljs-title class_">Gee</span>

go <span class="hljs-number">1.24</span>
</code></pre>
<p><strong>gee/gee.go</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> gee

<span class="hljs-keyword">import</span> (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"net/http"</span>
)

<span class="hljs-comment">// HandlerFunc 定义了Gee框架使用的请求处理函数类型</span>
<span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span>

<span class="hljs-comment">// Engine 声明一个 Engine 结构体，这个结构体会实现 ServeHTTP 接口</span>
<span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> {
        router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc <span class="hljs-comment">// 路由表</span>
}

<span class="hljs-comment">// New 创建 Engine 实例，初始化空的路由表</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine {
        <span class="hljs-keyword">return</span> &amp;Engine{router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}
}

<span class="hljs-comment">// 工具函数，后续 GET 和 POST 会使用这个函数给 engine 的路由表添加路由</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {
        key := method + <span class="hljs-string">"-"</span> + pattern
        engine.router[key] = handler
}

<span class="hljs-comment">// GET 提供给用户注册 GET 请求的便捷方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {
        engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)
}

<span class="hljs-comment">// POST 提供给用户注册 POST 请求的便捷方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {
        engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) {
        <span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {
        key := req.Method + <span class="hljs-string">"-"</span> + req.URL.Path
        fmt.Fprintf(w, <span class="hljs-string">"拼接出来的url：%s\n"</span>, key)
        <span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok {
                handler(w, req)
        } <span class="hljs-keyword">else</span> {
                w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 返回状态码</span>
                fmt.Fprintf(w, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, req.URL)
        }
}
</code></pre>
<blockquote>
<p>那么<code>gee.go</code>就是重头戏了。我们重点介绍一下这部分的实现。</p>
<ul>
<li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li>
<li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em> 中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li>
<li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li>
</ul>
</blockquote>
<p><strong>go.mod</strong></p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-keyword">module</span> <span class="hljs-title class_">Gee</span>

go <span class="hljs-number">1.24</span>

<span class="hljs-keyword">require</span> gee v0.<span class="hljs-number">0.0</span>

replace gee =&gt; ./gee
</code></pre>
<p><strong>main.go</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
        <span class="hljs-string">"fmt"</span>
        <span class="hljs-string">"gee"</span>
        <span class="hljs-string">"net/http"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        r := gee.New() <span class="hljs-comment">// 创建 Engine 实例</span>

        r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
                fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        })

        r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
                <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {
                        fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)
                }
        })

        r.Run(<span class="hljs-string">":9999"</span>) <span class="hljs-comment">// 启动 Web 服务</span>
}
</code></pre>
<blockquote>
<p>看到这里，如果你使用过<code>gin</code>框架的话，肯定会觉得无比的亲切。<code>gee</code>框架的设计以及API均参考了<code>gin</code>。使用<code>New()</code>创建 gee 的实例，使用 <code>GET()</code>方法添加路由，最后使用<code>Run()</code>启动Web服务。这里的路由，只是静态路由，不支持<code>/hello/:name</code>这样的动态路由，动态路由我们将在下一次实现。</p>
</blockquote>
<p>最后，我们分析一下，用我们自定义的框架完成之后，从 <code> curl  ``http://localhost:9999/</code> 到 <code>URL.Path = "/"</code> 的完整流程。</p>
<p>当我们启动服务之后，在终端输入 <code> curl  ``http://localhost:9999/</code>，此时 net/http 会收到请求报文并进行解析，解析出 <code>w http.ResponseWriter</code> 和 <code>req *http.Request</code>，并传入 gee/gee.go 中的 ServeHTTP 函数进行处理。</p>
<pre><code class="hljs language-scss" lang="scss">func (engine *Engine) <span class="hljs-built_in">ServeHTTP</span>(w http.ResponseWriter, req *http.Request) {
        key := req.Method + <span class="hljs-string">"-"</span> + req.URL.Path
        // fmt.<span class="hljs-built_in">Fprintf</span>(w, <span class="hljs-string">"拼接出来的url：%s\n"</span>, key)
        if handler, ok := engine.router[key]; ok {
                <span class="hljs-built_in">handler</span>(w, req)
        } else {
                fmt<span class="hljs-selector-class">.Fprintf</span>(w, "<span class="hljs-number">404</span> NOT FOUND: %s\n", req.URL)
        }
}
</code></pre>
<p>然后通过 <code>req.Method</code> 和 <code>req.URL.Path</code> 拼接出路由 <code>key</code>，然后从 <code>engine</code> 的路由表中进行查找，如果存在该路由，那么就把 <code>w</code> 和 <code>req</code> 交给对应的处理函数进行处理；如果不存在该路由，就返回 <code>"404 NOT FOUND: %s\n"</code>。</p>
<p>这里，我们拼接出来的 <code>key</code> 是 <code>"GET-/"</code>。在 <code>main.go</code> 中，通过 <code>r.GET</code> 方法已经将该路由注册到了 <code>engine</code> 的路由表中了：</p>
<pre><code class="hljs language-go" lang="go">r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
                fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        })
</code></pre>
<p>那么，就可以通过路由映射表找到对应的处理函数：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
                fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)
        }
</code></pre>
<p>然后将 <code>w</code> 和 <code>req</code> 参数传入给这个处理函数，最后 <code>fmt.Fprintf</code> 来调用 <code>w.Write</code>，后面的<code>"URL.Path = %q\n"</code> 作为 <code>w.Write</code> 的传参写入 <strong>HTTP 响应缓冲区，</strong> handler 返回后，<code>net/http</code> 把这些字节通过 TCP 发给浏览器。</p>
<p>这就是基于我们自己编写的简单框架中数据的流向。</p>
<hr/>
<p>至此，整个<code>Gee</code>框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然，到目前为止，我们还没有实现比<code>net/http</code>标准库更强大的能力，不用担心，很快就可以将动态路由、中间件等功能添加上去了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Redis 实战：从零手写分布式锁（误删问题与 Lua 脚本优化）]]></title>    <link>https://juejin.cn/post/7585406229151711270</link>    <guid>https://juejin.cn/post/7585406229151711270</guid>    <pubDate>2025-12-19T07:57:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585406229151711270" data-draft-id="7585406229151694886" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Redis 实战：从零手写分布式锁（误删问题与 Lua 脚本优化）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T07:57:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ShaneD771"/> <meta itemprop="url" content="https://juejin.cn/user/2482077907032171"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Redis 实战：从零手写分布式锁（误删问题与 Lua 脚本优化）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2482077907032171/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ShaneD771
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:57:51.000Z" title="Fri Dec 19 2025 07:57:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    17
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Redis 实战：从零手写分布式锁（误删问题与 Lua 脚本优化）</h2>
<p>在单体架构中，我们习惯使用 <code>synchronized</code> 或 <code>Lock</code> 来解决并发安全问题。但在分布式集群架构下，不同的服务运行在不同的 JVM 中，本地锁也就失效了。</p>
<p>本文将复现如何基于 Redis 实现一个分布式锁，并一步步解决<strong>死锁</strong>、<strong>误删</strong>、<strong>原子性</strong>等经典问题。</p>
<h3 data-id="heading-1">一、 初级版本：利用 SETNX 实现互斥</h3>
<p>Redis 的 <code>SETNX</code> (Set if Not Exists) 命令天生具备互斥性：只有 Key 不存在时才能设置成功。</p>
<p>为了防止获取锁的服务器宕机导致锁永远无法释放（死锁），我们需要在使用 <code>SETNX</code> 的同时设置过期时间（TTL）。</p>
<p><strong>核心命令：</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">SET</span> lock:<span class="hljs-keyword">key</span> threadId NX EX <span class="hljs-number">10</span>
</code></pre>
<p><em>注意：必须保证 SETNX 和 EXPIRE 是原子操作，不能分成两条命令执行。</em></p>
<h4 data-id="heading-2">Java 代码实现</h4>
<p>定义一个 <code>SimpleRedisLock</code> 类，实现基础的加锁和解锁逻辑。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> {

    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">// 锁的业务名称</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate; <span class="hljs-comment">// Redis操作工具</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">"lock:"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> {
        <span class="hljs-comment">// 获取线程ID作为标识</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();
        <span class="hljs-comment">// 执行 SET lock:name threadId NX EX timeout</span>
        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">""</span>, timeoutSec, TimeUnit.SECONDS);
        <span class="hljs-comment">// 防止自动拆箱空指针</span>
        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 简单粗暴直接删</span>
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
</code></pre>
<h3 data-id="heading-3">二、 进阶版本：解决“误删”问题</h3>
<p>初级版本存在一个严重的隐患：<strong>如果业务执行时间超过了锁的过期时间，会发生什么？</strong></p>
<h4 data-id="heading-4">1. 事故场景还原</h4>
<p>假设锁的有效期是 10s，但业务执行了 15s：</p>
<ol>
<li><strong>线程 A</strong> 获取锁，开始执行业务。</li>
<li><strong>10s 后</strong>，Redis 锁自动过期释放。</li>
<li><strong>线程 B</strong> 尝试获取锁，成功拿到（因为 A 的锁没了）。</li>
<li><strong>15s 后</strong>，线程 A 业务执行完毕，执行 <code>unlock()</code>，直接删除了 Key。</li>
<li><strong>问题出现</strong>：线程 A 删掉的其实是 <strong>线程 B</strong> 正在持有的锁！</li>
<li>此时 <strong>线程 C</strong> 进来，发现没锁，直接加锁。导致 B 和 C 并发执行，互斥失效。</li>
</ol>
<h4 data-id="heading-5">2. 解决方案：给锁加上“身份证”</h4>
<p>为了遵循“解铃还须系铃人”的原则，我们需要在解锁时判断：<strong>这把锁是不是我的？</strong></p>
<ul>
<li><strong>改进 Value</strong>：单用线程 ID 在集群下可能重复，我们需要拼接一个 JVM 的唯一标识（UUID）。</li>
<li><strong>改进 unlock</strong>：删除前先查询 Value，判断是否与自己一致。</li>
</ul>
<h4 data-id="heading-6">3. 代码升级</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> cn.hutool.core.lang.UUID;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> {
    <span class="hljs-comment">// ... 构造方法同上 ...</span>

    <span class="hljs-comment">// 生成 JVM 唯一的 UUID 前缀</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">"-"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> {
        <span class="hljs-comment">// 拼接 UUID + 线程 ID</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();
        <span class="hljs-comment">// 存入 Redis</span>
        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 获取当前线程的标识</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();
        <span class="hljs-comment">// 2. 获取 Redis 中锁的标识</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
        <span class="hljs-comment">// 3. 判断是否一致</span>
        <span class="hljs-keyword">if</span> (threadId.equals(id)) {
            <span class="hljs-comment">// 4. 一致才删除</span>
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }
}
</code></pre>
<h3 data-id="heading-7">三、 终极版本：Lua 脚本保证原子性</h3>
<p>上面的 Java 代码解决了“误删”的大部分场景，但在极端并发下依然有漏洞。</p>
<h4 data-id="heading-8">1. 原子性漏洞</h4>
<p>在 unlock 方法中，“判断锁标识” 和 “删除锁” 是两个动作。</p>
<p>如果线程 A 判断成功（是自己的锁），正准备删除时，系统发生了 GC 停顿（Stop The World）或者网络阻塞。</p>
<p>恰好在这段时间内，锁过期了，线程 B 抢到了锁。</p>
<p>等线程 A 恢复运行，它不会再次判断，而是直接执行 delete，结果还是把 B 的锁给删了。</p>
<h4 data-id="heading-9">2. 解决方案：Lua 脚本</h4>
<p>Redis 提供了 Lua 脚本功能，可以将多条命令作为一个整体执行，中间不会被其他命令插入，从而保证了原子性。</p>
<p><strong>编写 Lua 脚本 (<code>unlock.lua</code>)：</strong></p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-comment">-- KEYS[1] 是锁的 key</span>
<span class="hljs-comment">-- ARGV[1] 是当前线程的标识</span>
<span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'get'</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span>
    <span class="hljs-comment">-- 标识一致，执行删除</span>
    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'del'</span>, KEYS[<span class="hljs-number">1</span>])
<span class="hljs-keyword">else</span>
    <span class="hljs-comment">-- 不一致，返回 0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h4 data-id="heading-10">3. 代码最终形态</h4>
<p>我们需要预加载 Lua 脚本，并使用 <code>execute</code> 方法调用。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> {

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;
    <span class="hljs-comment">// 静态代码块预加载 Lua 脚本</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;
    <span class="hljs-keyword">static</span> {
        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();
        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"unlock.lua"</span>)); <span class="hljs-comment">// 脚本文件位置</span>
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">"-"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();
        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 调用 Lua 脚本</span>
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + name), <span class="hljs-comment">// KEYS[1]</span>
                ID_PREFIX + Thread.currentThread().getId()    <span class="hljs-comment">// ARGV[1]</span>
        );
    }
}
</code></pre>
<h3 data-id="heading-11">四、 总结</h3>
<p>手写 Redis 分布式锁是一个非常好的学习过程，经历了三个阶段：</p>
<ol>
<li><strong>基础版</strong>：利用 <code>SETNX</code> 实现互斥，<code>EX</code> 防止死锁。</li>
<li><strong>改进版</strong>：利用 <code>UUID + ThreadID</code> 防止锁超时后误删他人锁。</li>
<li><strong>终极版</strong>：利用 <code>Lua 脚本</code> 解决“查询”与“删除”非原子性的问题。</li>
</ol>
<p><strong>注意</strong>：这只是一个入门级的分布式锁实现。在生产环境中，还要考虑<strong>锁续期</strong>（看门狗机制）、<strong>可重入性</strong>、<strong>主从一致性</strong>（Redlock）等问题。建议生产环境直接使用成熟的框架 <strong>Redisson</strong>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java并发编程基础：从线程到锁]]></title>    <link>https://juejin.cn/post/7585171571129401380</link>    <guid>https://juejin.cn/post/7585171571129401380</guid>    <pubDate>2025-12-19T08:05:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585171571129401380" data-draft-id="7584640225644773439" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java并发编程基础：从线程到锁"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T08:05:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="無量"/> <meta itemprop="url" content="https://juejin.cn/user/1116759546145086"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java并发编程基础：从线程到锁
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759546145086/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    無量
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:05:57.000Z" title="Fri Dec 19 2025 08:05:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读44分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在当今互联网高并发的背景下,并发编程已成为Java开发者的必备技能。从简单的多线程应用到复杂的分布式系统,线程安全问题无处不在。本文将从进程与线程的基础概念出发,深入剖析synchronized和volatile的底层原理,结合电商业务场景,带你系统掌握Java并发编程的核心知识。</p>
<h2 data-id="heading-1">一、理论知识与核心概念</h2>
<h3 data-id="heading-2">1.1 进程与线程的区别</h3>
<p><strong>进程(Process)</strong> 是操作系统进行资源分配和调度的基本单位,拥有独立的内存空间。每个进程都有自己独立的代码段、数据段和堆栈段。</p>
<p><strong>线程(Thread)</strong> 是CPU调度和执行的最小单位,是进程中的一个执行单元。同一进程内的多个线程共享进程的内存空间(堆内存、方法区),但每个线程有自己独立的栈空间。</p>



































<table><thead><tr><th>对比维度</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源占用</td><td>独立内存空间,开销大</td><td>共享进程内存,开销小</td></tr><tr><td>通信方式</td><td>IPC(管道、消息队列、共享内存)</td><td>直接读写共享变量</td></tr><tr><td>创建速度</td><td>慢(需要分配独立内存)</td><td>快(只需分配栈空间)</td></tr><tr><td>影响范围</td><td>进程崩溃不影响其他进程</td><td>线程崩溃可能导致整个进程崩溃</td></tr><tr><td>上下文切换</td><td>开销大(需要切换内存空间)</td><td>开销小(共享内存空间)</td></tr></tbody></table>
<h3 data-id="heading-3">1.2 线程的创建方式</h3>
<p>Java提供了四种创建线程的方式:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 方式1: 继承Thread类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Thread by extending Thread: "</span> + Thread.currentThread().getName());
    }
}

<span class="hljs-comment">// 方式2: 实现Runnable接口(推荐)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Thread by Runnable: "</span> + Thread.currentThread().getName());
    }
}

<span class="hljs-comment">// 方式3: 实现Callable接口(有返回值)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Thread by Callable: "</span> + Thread.currentThread().getName();
    }
}

<span class="hljs-comment">// 方式4: 线程池(生产环境推荐)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() {
                <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">"custom-pool-"</span> + threadNumber.getAndIncrement());
                }
            },
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());
}
</code></pre>
<p><strong>对比分析:</strong></p>
<ul>
<li><strong>继承Thread</strong>: 由于Java单继承限制,扩展性差,不推荐</li>
<li><strong>实现Runnable</strong>: 解耦任务与线程,可以被线程池重用,推荐使用</li>
<li><strong>实现Callable</strong>: 可以返回结果和抛出异常,适合需要返回值的场景</li>
<li><strong>线程池</strong>: 避免频繁创建销毁线程,复用线程资源,生产环境必选</li>
</ul>
<h3 data-id="heading-4">1.3 线程的生命周期</h3>
<p>Java线程有6种状态,定义在<code>Thread.State</code>枚举中:</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────┐
│   NEW   │ (新建状态: Thread对象创建,但未调用start())
└────┬────┘
     │ <span class="hljs-built_in">start</span>()
     ▼
┌──────────────┐
│   RUNNABLE   │ (可运行状态: 包含就绪Ready和运行Running两种子状态)
└──────┬───────┘
       │
       ├──────► BLOCKED (阻塞状态: 等待获取synchronized锁)
       │
       ├──────► WAITING (无限期等待: Object.wait()、Thread<span class="hljs-selector-class">.join</span>()、LockSupport<span class="hljs-selector-class">.park</span>())
       │
       ├──────► TIMED_WAITING (限期等待: Thread.sleep()、<span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.wait</span>(timeout)、Thread<span class="hljs-selector-class">.join</span>(timeout))
       │
       ▼
┌──────────────┐
│  TERMINATED  │ (终止状态: run()方法执行完毕或抛出异常)
└──────────────┘
</code></pre>
<p><strong>关键状态转换:</strong></p>
<ol>
<li><strong>NEW → RUNNABLE</strong>: 调用<code>start()</code>方法</li>
<li><strong>RUNNABLE → BLOCKED</strong>: 尝试获取synchronized锁失败,进入锁的EntryList队列</li>
<li><strong>RUNNABLE → WAITING</strong>: 调用<code>Object.wait()</code>、<code>Thread.join()</code>、<code>LockSupport.park()</code></li>
<li><strong>RUNNABLE → TIMED_WAITING</strong>: 调用<code>Thread.sleep(timeout)</code>、<code>Object.wait(timeout)</code>等带超时的方法</li>
<li><strong>BLOCKED/WAITING/TIMED_WAITING → RUNNABLE</strong>: 获取到锁、被notify唤醒、超时时间到</li>
<li><strong>RUNNABLE → TERMINATED</strong>: run()方法执行完毕</li>
</ol>
<h3 data-id="heading-5">1.4 并发与并行</h3>
<p><strong>并发(Concurrency)</strong>: 单核CPU通过时间片轮转,快速切换执行多个任务,看起来像同时执行,实际上是交替执行。强调的是<strong>任务调度能力</strong>。</p>
<p><strong>并行(Parallelism)</strong>: 多核CPU真正同时执行多个任务,每个核心独立运行一个线程。强调的是<strong>同时执行能力</strong>。</p>
<pre><code class="hljs language-less" lang="less">并发(单核<span class="hljs-selector-tag">CPU</span>):
时间 ───┬───┬───┬───┬───┬───┬───┬───►
任务<span class="hljs-selector-tag">A</span>   █       █       █
任务<span class="hljs-selector-tag">B</span>     █       █       █
任务<span class="hljs-selector-tag">C</span>       █       █       █

并行(多核CPU):
时间 ───────────────────────────►
核心<span class="hljs-number">1</span>   █████████████████████  (任务A)
核心<span class="hljs-number">2</span>   █████████████████████  (任务B)
核心<span class="hljs-number">3</span>   █████████████████████  (任务C)
</code></pre>
<h3 data-id="heading-6">1.5 线程安全的定义</h3>
<p><strong>线程安全</strong>是指多个线程访问同一个对象时,无论运行时环境采用何种调度方式或这些线程如何交替执行,该对象都能表现出正确的行为,并且不需要调用方提供额外的同步措施。</p>
<p><strong>线程安全的三大特性:</strong></p>
<ol>
<li><strong>原子性(Atomicity)</strong>: 一个或多个操作要么全部执行成功,要么全部不执行</li>
<li><strong>可见性(Visibility)</strong>: 一个线程修改了共享变量,其他线程能立即看到修改后的值</li>
<li><strong>有序性(Ordering)</strong>: 程序执行的顺序按照代码的先后顺序执行</li>
</ol>
<p><strong>判断线程安全的标准:</strong></p>
<ul>
<li>多线程环境下,对共享变量的操作不会导致数据不一致</li>
<li>不会出现丢失更新、脏读、不可重复读等问题</li>
<li>程序运行结果与单线程环境保持一致</li>
</ul>
<h2 data-id="heading-7">二、原理深度剖析</h2>
<h3 data-id="heading-8">2.1 synchronized原理详解</h3>
<p>synchronized是Java提供的内置锁机制,用于解决多线程并发访问共享资源的同步问题。在JDK 1.6之前,synchronized是重量级锁,性能较差。JDK 1.6对synchronized进行了大量优化,引入了偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等技术。</p>
<h4 data-id="heading-9">2.1.1 对象头与Mark Word结构</h4>
<p>在HotSpot虚拟机中,对象在内存中的布局分为三个区域:</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│                   Java对象内存布局                 │
├─────────────────────────────────────────────────┤
│  <span class="hljs-number">1</span>. 对象头(Object Header)                        │
│     ├─ <span class="hljs-selector-tag">Mark</span> Word (<span class="hljs-number">8</span>字节,<span class="hljs-number">64</span>位JVM)                 │
│     └─ Class Pointer (<span class="hljs-number">4</span>/<span class="hljs-number">8</span>字节,指向类元数据)       │
│  <span class="hljs-number">2</span>. 实例数据(Instance Data)                      │
│  <span class="hljs-number">3</span>. 对齐填充(Padding)                            │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>Mark Word</strong>在不同锁状态下的结构(64位JVM):</p>



























































<table><thead><tr><th>锁状态</th><th>25bit</th><th>31bit</th><th>1bit</th><th>4bit</th><th>1bit(是否偏向锁)</th><th>2bit(锁标志位)</th></tr></thead><tbody><tr><td>无锁状态</td><td>unused</td><td>hashcode</td><td>unused</td><td>age</td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>threadID(54bit)</td><td>epoch(2bit)</td><td>unused</td><td>age</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中Lock Record的指针(62bit)</td><td/><td/><td/><td/><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量(Monitor)的指针(62bit)</td><td/><td/><td/><td/><td>10</td></tr><tr><td>GC标记</td><td>空</td><td/><td/><td/><td/><td>11</td></tr></tbody></table>
<p><strong>字段说明:</strong></p>
<ul>
<li><strong>hashcode</strong>: 对象的identity hash code</li>
<li><strong>age</strong>: 对象的分代年龄(最大15,超过15晋升老年代)</li>
<li><strong>threadID</strong>: 持有偏向锁的线程ID</li>
<li><strong>epoch</strong>: 偏向时间戳,用于批量重偏向</li>
</ul>
<h4 data-id="heading-10">2.1.2 偏向锁(Biased Locking)</h4>
<p><strong>设计初衷:</strong></p>
<p>在大多数情况下,锁不存在竞争,总是由同一个线程多次获得。为了减少同一线程获取锁的代价(CAS操作也有开销),引入了偏向锁。</p>
<p><strong>偏向锁的获取流程:</strong></p>
<pre><code class="hljs language-objectivec" lang="objectivec">┌─────────────────────────────────────────────────┐
│           偏向锁获取流程                          │
└─────────────────────────────────────────────────┘

线程访问同步块
      │
      ▼
检查Mark Word是否为可偏向状态(锁标志位<span class="hljs-number">01</span>,偏向锁标志<span class="hljs-number">1</span>)
      │
      ├─ <span class="hljs-literal">YES</span> ─► 检查threadID是否指向当前线程
      │           │
      │           ├─ <span class="hljs-literal">YES</span> ─► 直接执行同步块(无需<span class="hljs-built_in">CAS</span>)
      │           │
      │           └─ <span class="hljs-literal">NO</span>  ─► <span class="hljs-built_in">CAS</span>将Mark Word的threadID改为当前线程ID
      │                      │
      │                      ├─ 成功 ─► 获得偏向锁,执行同步块
      │                      │
      │                      └─ 失败 ─► 发生竞争,撤销偏向锁,膨胀为轻量级锁
      │
      └─ <span class="hljs-literal">NO</span>  ─► 检查是否允许偏向
                  │
                  ├─ 允许 ─► <span class="hljs-built_in">CAS</span>尝试获取偏向锁
                  │
                  └─ 不允许 ─► 直接使用轻量级锁
</code></pre>
<p><strong>偏向锁的撤销:</strong></p>
<p>偏向锁在以下情况下会撤销:</p>
<ol>
<li><strong>有其他线程尝试获取锁</strong>: 当前持有偏向锁的线程A在运行,线程B尝试获取该锁</li>
<li><strong>调用wait/notify方法</strong>: 偏向锁不支持这些操作</li>
<li><strong>对象的identityHashCode被调用</strong>: Mark Word需要存储hashcode,没有空间存储threadID</li>
</ol>
<p><strong>撤销过程(需要等待全局安全点 Safepoint):</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 撤销偏向锁的过程(简化)</span>
<span class="hljs-number">1.</span> 暂停持有偏向锁的线程(STW - Stop The World)
<span class="hljs-number">2.</span> 检查持有偏向锁的线程是否还存活
   - 如果线程已经退出同步块 → 撤销偏向锁,恢复到无锁状态
   - 如果线程还在同步块内 → 升级为轻量级锁
<span class="hljs-number">3.</span> 唤醒暂停的线程
</code></pre>
<p><strong>批量重偏向与批量撤销:</strong></p>
<ul>
<li><strong>批量重偏向</strong>: 当一个类的对象被多个线程访问,但不存在竞争时,JVM会对该类的所有对象进行批量重偏向(更新epoch)</li>
<li><strong>批量撤销</strong>: 当撤销偏向锁的次数超过阈值(默认40次),JVM会认为该类不适合偏向锁,直接撤销该类所有对象的偏向锁</li>
</ul>
<p><strong>JDK 15后默认禁用偏向锁的原因:</strong></p>
<ol>
<li>偏向锁的撤销需要进入安全点(STW),在高并发场景下反而降低性能</li>
<li>现代应用程序中,真正无竞争的场景越来越少</li>
<li>JIT编译器和锁消除技术的进步,降低了偏向锁的收益</li>
</ol>
<h4 data-id="heading-11">2.1.3 轻量级锁(Lightweight Locking)</h4>
<p><strong>适用场景:</strong></p>
<p>线程交替执行同步块,不存在真正的竞争。通过CAS操作避免使用互斥量(Mutex),减少操作系统层面的线程阻塞。</p>
<p><strong>轻量级锁的获取流程:</strong></p>
<pre><code class="hljs language-less" lang="less">┌─────────────────────────────────────────────────┐
│           轻量级锁获取流程                         │
└─────────────────────────────────────────────────┘

<span class="hljs-number">1</span>. 线程进入同步块前,在栈帧中创建<span class="hljs-selector-tag">Lock</span> <span class="hljs-selector-tag">Record</span>
   ┌──────────────┐
   │  <span class="hljs-selector-tag">Lock</span> <span class="hljs-selector-tag">Record</span> │
   ├──────────────┤
   │ <span class="hljs-selector-tag">Displaced</span>    │  ← 存储对象原始的<span class="hljs-selector-tag">Mark</span> <span class="hljs-selector-tag">Word</span>
   │ <span class="hljs-selector-tag">Mark</span> <span class="hljs-selector-tag">Word</span>    │
   ├──────────────┤
   │ <span class="hljs-selector-tag">Owner</span>指针    │  → 指向锁对象
   └──────────────┘

<span class="hljs-number">2</span>. <span class="hljs-selector-tag">CAS</span>将对象的<span class="hljs-selector-tag">Mark</span> <span class="hljs-selector-tag">Word</span>替换为指向<span class="hljs-selector-tag">Lock</span> <span class="hljs-selector-tag">Record</span>的指针

   对象<span class="hljs-selector-tag">Mark</span> <span class="hljs-selector-tag">Word</span>:  <span class="hljs-selector-attr">[Lock Record指针 | 00]</span>
                             │
                             └─────► 指向栈帧中的<span class="hljs-selector-tag">Lock</span> <span class="hljs-selector-tag">Record</span>

<span class="hljs-number">3</span>. <span class="hljs-selector-tag">CAS</span>替换结果:
   ├─ 成功 ─► 获得轻量级锁,执行同步块
   │
   └─ 失败 ─► 检查<span class="hljs-selector-tag">Mark</span> <span class="hljs-selector-tag">Word</span>是否指向当前线程的栈帧
               │
               ├─ 是 ─► 锁重入,再次创建<span class="hljs-selector-tag">Lock</span> <span class="hljs-selector-tag">Record</span>
               │
               └─ 否 ─► 发生竞争,自旋尝试获取锁
                          │
                          └─ 自旋次数超过阈值 ─► 膨胀为重量级锁
</code></pre>
<p><strong>自旋优化(Spin Lock):</strong></p>
<p>当线程获取轻量级锁失败时,不立即阻塞,而是执行忙循环(自旋)等待,避免用户态到内核态的切换。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 自旋等待示例(伪代码)</span>
<span class="hljs-type">int</span> <span class="hljs-variable">spinCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (!tryAcquireLock()) {
    spinCount++;
    <span class="hljs-keyword">if</span> (spinCount &gt; MAX_SPIN_COUNT) {
        <span class="hljs-comment">// 自旋次数超过阈值,膨胀为重量级锁</span>
        inflateToHeavyweightLock();
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// CPU空转,等待锁释放</span>
    <span class="hljs-comment">// 可能执行PAUSE指令,降低CPU功耗</span>
}
</code></pre>
<p><strong>自适应自旋(Adaptive Spinning):</strong></p>
<p>JDK 1.6引入,自旋次数不再固定:</p>
<ul>
<li>如果上一次自旋成功获得锁,允许更长的自旋时间</li>
<li>如果上一次自旋失败,缩短自旋时间或直接阻塞</li>
</ul>
<p><strong>轻量级锁的释放:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">1.</span> CAS将Lock Record中的Displaced Mark Word替换回对象头
<span class="hljs-number">2.</span> CAS替换结果:
   ├─ 成功 ─► 释放锁成功
   └─ 失败 ─► 说明有其他线程在竞争,锁已膨胀为重量级锁,需要唤醒阻塞的线程
</code></pre>
<h4 data-id="heading-12">2.1.4 重量级锁(Heavyweight Locking)</h4>
<p>当轻量级锁自旋一定次数后仍未获取到锁,锁会膨胀为重量级锁。重量级锁依赖操作系统的Mutex Lock(互斥量)实现,会导致线程在用户态和内核态之间切换。</p>
<p><strong>Monitor对象结构:</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">┌─────────────────────────────────────────────────┐</span>
<span class="hljs-string">│</span>              <span class="hljs-string">ObjectMonitor结构</span>                    <span class="hljs-string">│</span>
<span class="hljs-string">├─────────────────────────────────────────────────┤</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">_owner:</span>      <span class="hljs-string">持有锁的线程</span>                        <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">_EntryList:</span>  <span class="hljs-string">等待锁的线程队列(BLOCKED状态)</span>        <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">_WaitSet:</span>    <span class="hljs-string">调用wait()方法的线程队列(WAITING状态)│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">_count:</span>      <span class="hljs-string">锁的重入次数</span>                        <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">_recursions:</span> <span class="hljs-string">重入计数器</span>                          <span class="hljs-string">│</span>
<span class="hljs-string">└─────────────────────────────────────────────────┘</span>

<span class="hljs-string">重量级锁的状态转换:</span>

           <span class="hljs-string">┌──────────┐</span>
           <span class="hljs-string">│</span>  <span class="hljs-string">Thread1</span> <span class="hljs-string">│</span> <span class="hljs-string">(获得锁,_owner指向Thread1)</span>
           <span class="hljs-string">└────┬─────┘</span>
                <span class="hljs-string">│</span> <span class="hljs-string">synchronized(obj)</span>
                <span class="hljs-string">▼</span>
          <span class="hljs-string">┌──────────┐</span>
          <span class="hljs-string">│</span> <span class="hljs-string">_owner</span>   <span class="hljs-string">│</span> <span class="hljs-string">────►</span> <span class="hljs-string">Thread1</span>
          <span class="hljs-string">└──────────┘</span>

          <span class="hljs-string">┌──────────┐</span>
          <span class="hljs-string">│_EntryList│</span> <span class="hljs-string">◄────</span> <span class="hljs-string">Thread2,</span> <span class="hljs-string">Thread3</span> <span class="hljs-string">(尝试获取锁,进入BLOCKED状态)</span>
          <span class="hljs-string">└──────────┘</span>

          <span class="hljs-string">┌──────────┐</span>
          <span class="hljs-string">│</span> <span class="hljs-string">_WaitSet</span> <span class="hljs-string">│</span> <span class="hljs-string">◄────</span> <span class="hljs-string">Thread4</span> <span class="hljs-string">(调用wait(),进入WAITING状态)</span>
          <span class="hljs-string">└──────────┘</span>
</code></pre>
<p><strong>重量级锁的获取与释放流程:</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">获取流程:
<span class="hljs-bullet">1.</span> 线程尝试获取锁(CAS修改<span class="hljs-emphasis">_owner为当前线程)
2. 如果_</span>owner为空,获取成功
<span class="hljs-bullet">3.</span> 如果<span class="hljs-emphasis">_owner指向当前线程,锁重入(_</span>count++)
<span class="hljs-bullet">4.</span> 如果<span class="hljs-emphasis">_owner指向其他线程,进入_</span>EntryList,线程阻塞(BLOCKED状态)

释放流程:
<span class="hljs-bullet">1.</span> <span class="hljs-emphasis">_count-- (处理锁重入)
2. 如果_</span>count == 0,释放锁(<span class="hljs-emphasis">_owner置为NULL)
3. 从_</span>EntryList中唤醒一个线程(notify)
<span class="hljs-bullet">4.</span> 被唤醒的线程从BLOCKED状态转为RUNNABLE状态,重新竞争锁
</code></pre>
<h4 data-id="heading-13">2.1.5 锁升级的完整过程</h4>
<pre><code class="hljs language-makefile" lang="makefile">┌─────────────────────────────────────────────────────────────┐
│                    synchronized锁升级过程                      │
└─────────────────────────────────────────────────────────────┘

  无锁状态           偏向锁             轻量级锁           重量级锁
    │                 │                   │                 │
    │  CAS获取        │  有其他线程       │   自旋失败      │
    │  偏向锁         │  竞争锁           │   或竞争激烈    │
    ├────────────────►├──────────────────►├────────────────►│
    │                 │                   │                 │
<span class="hljs-section">锁标志位: 01      锁标志位: 01        锁标志位: 00      锁标志位: 10</span>
<span class="hljs-section">偏向标志: 0      偏向标志: 1</span>
<span class="hljs-section">性能: 最快        性能: 快            性能: 较快         性能: 慢</span>
<span class="hljs-section">开销: 无          开销: CAS          开销: CAS+自旋     开销: 用户态/内核态切换</span>
<span class="hljs-section">适用: 无竞争      适用: 单线程反复   适用: 交替执行     适用: 高竞争</span>
                  获取同一把锁       少量竞争           多线程竞争激烈
</code></pre>
<p><strong>性能对比:</strong></p>





























<table><thead><tr><th>锁类型</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁解锁无需额外消耗</td><td>有线程竞争会带来额外的锁撤销消耗</td><td>只有一个线程访问同步块</td></tr><tr><td>轻量级锁</td><td>竞争线程不阻塞,响应速度快</td><td>自旋消耗CPU</td><td>线程交替执行同步块,竞争不激烈</td></tr><tr><td>重量级锁</td><td>不消耗CPU(线程阻塞)</td><td>线程阻塞,响应时间慢</td><td>竞争激烈,同步块执行时间长</td></tr></tbody></table>
<h3 data-id="heading-14">2.2 volatile关键字与Java内存模型(JMM)</h3>
<h4 data-id="heading-15">2.2.1 Java内存模型(JMM)基础</h4>
<p>Java内存模型(Java Memory Model)定义了线程和主内存之间的抽象关系,规定了一个线程如何以及何时可以看到其他线程修改的共享变量的值。</p>
<p><strong>JMM抽象结构:</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1842820c737b41d690cfcaafb20cd45c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Sh6YeP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738181&amp;x-signature=El1410hVJiPnFH%2Fc73BArFoC3js%3D" alt="04-java-memory-model.svg" loading="lazy"/></p>
<p><strong>内存交互操作(8种原子操作):</strong></p>
<ol>
<li><strong>lock(锁定)</strong>: 作用于主内存的变量,标识为线程独占状态</li>
<li><strong>unlock(解锁)</strong>: 作用于主内存的变量,释放独占状态</li>
<li><strong>read(读取)</strong>: 作用于主内存的变量,把值传输到工作内存</li>
<li><strong>load(载入)</strong>: 作用于工作内存的变量,把read的值放入工作内存的变量副本</li>
<li><strong>use(使用)</strong>: 作用于工作内存的变量,把值传递给执行引擎</li>
<li><strong>assign(赋值)</strong>: 作用于工作内存的变量,把执行引擎的值赋给工作内存的变量</li>
<li><strong>store(存储)</strong>: 作用于工作内存的变量,把值传送到主内存</li>
<li><strong>write(写入)</strong>: 作用于主内存的变量,把store的值写入主内存的变量</li>
</ol>
<p><strong>happens-before原则(8大规则):</strong></p>
<p>happens-before原则定义了操作之间的偏序关系,如果操作A happens-before操作B,那么A的执行结果对B可见。</p>
<ol>
<li><strong>程序次序规则</strong>: 单线程内,按照代码顺序执行</li>
<li><strong>监视器锁规则</strong>: unlock操作 happens-before 后续对同一个锁的lock操作</li>
<li><strong>volatile变量规则</strong>: volatile写操作 happens-before 后续对该变量的读操作</li>
<li><strong>线程启动规则</strong>: Thread.start() happens-before 该线程的每一个动作</li>
<li><strong>线程终止规则</strong>: 线程的所有操作 happens-before 其他线程检测到该线程终止(Thread.join()返回、Thread.isAlive()返回false)</li>
<li><strong>线程中断规则</strong>: 线程interrupt()方法的调用 happens-before 被中断线程检测到中断事件发生</li>
<li><strong>对象终结规则</strong>: 对象的构造函数执行结束 happens-before finalize()方法</li>
<li><strong>传递性</strong>: 如果A happens-before B,B happens-before C,那么A happens-before C</li>
</ol>
<h4 data-id="heading-16">2.2.2 volatile的两大特性</h4>
<p><strong>1. 可见性保证</strong></p>
<p>当一个变量被声明为volatile时,对该变量的写操作会立即刷新到主内存,对该变量的读操作会从主内存中读取最新值。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileVisibilityExample</span> {
    <span class="hljs-comment">// 不使用volatile,可能导致可见性问题</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 使用volatile,保证可见性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">volatileFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-comment">// 示例1: 不使用volatile的问题</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-keyword">while</span> (!flag) {
                <span class="hljs-comment">// 线程可能永远无法看到flag的变化</span>
                <span class="hljs-comment">// JIT编译器可能将flag缓存到寄存器</span>
            }
            System.out.println(<span class="hljs-string">"线程1: flag变为true"</span>);
        }).start();

        Thread.sleep(<span class="hljs-number">1000</span>);
        flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 主线程修改flag</span>
        System.out.println(<span class="hljs-string">"主线程: 已将flag设置为true"</span>);

        <span class="hljs-comment">// 示例2: 使用volatile保证可见性</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-keyword">while</span> (!volatileFlag) {
                <span class="hljs-comment">// volatile保证能立即看到volatileFlag的变化</span>
            }
            System.out.println(<span class="hljs-string">"线程2: volatileFlag变为true"</span>);
        }).start();

        Thread.sleep(<span class="hljs-number">1000</span>);
        volatileFlag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 主线程修改volatileFlag</span>
        System.out.println(<span class="hljs-string">"主线程: 已将volatileFlag设置为true"</span>);
    }
}
</code></pre>
<p><strong>2. 有序性保证(禁止指令重排序)</strong></p>
<p>volatile通过内存屏障(Memory Barrier)禁止特定类型的指令重排序。</p>
<p><strong>内存屏障的四种类型:</strong></p>






























<table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad屏障</td><td>Load1; LoadLoad; Load2</td><td>确保Load1的数据装载先于Load2及后续装载指令</td></tr><tr><td>StoreStore屏障</td><td>Store1; StoreStore; Store2</td><td>确保Store1的数据刷新到主内存先于Store2及后续存储指令</td></tr><tr><td>LoadStore屏障</td><td>Load1; LoadStore; Store2</td><td>确保Load1的数据装载先于Store2及后续存储指令</td></tr><tr><td>StoreLoad屏障</td><td>Store1; StoreLoad; Load2</td><td>确保Store1的数据刷新到主内存先于Load2及后续装载指令(开销最大)</td></tr></tbody></table>
<p><strong>volatile写操作插入的内存屏障:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">volatile</span>写操作:
    StoreStore屏障    ← 禁止上面的普通写与<span class="hljs-keyword">volatile</span>写重排序
    <span class="hljs-keyword">volatile</span> write
    StoreLoad屏障     ← 禁止<span class="hljs-keyword">volatile</span>写与下面可能的<span class="hljs-keyword">volatile</span>读/写重排序
</code></pre>
<p><strong>volatile读操作插入的内存屏障:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">volatile</span>读操作:
    <span class="hljs-keyword">volatile</span> read
    LoadLoad屏障      ← 禁止下面的普通读与<span class="hljs-keyword">volatile</span>读重排序
    LoadStore屏障     ← 禁止下面的普通写与<span class="hljs-keyword">volatile</span>读重排序
</code></pre>
<p><strong>经典案例:DCL双重检查锁定模式</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
    <span class="hljs-comment">// 必须使用volatile,防止指令重排序</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {  <span class="hljs-comment">// 第一次检查(不加锁,提高性能)</span>
            <span class="hljs-keyword">synchronized</span> (Singleton.class) {  <span class="hljs-comment">// 加锁</span>
                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {  <span class="hljs-comment">// 第二次检查(防止多次创建)</span>
                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// ← 关键代码</span>
                }
            }
        }
        <span class="hljs-keyword">return</span> instance;
    }
}
</code></pre>
<p><strong>为什么必须使用volatile?</strong></p>
<p><code>instance = new Singleton()</code>实际包含三个步骤:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">1.</span> memory = allocate();    <span class="hljs-comment">// 分配对象内存空间</span>
<span class="hljs-number">2.</span> ctorInstance(memory);   <span class="hljs-comment">// 初始化对象</span>
<span class="hljs-number">3.</span> instance = memory;      <span class="hljs-comment">// 设置instance指向刚分配的内存地址</span>
</code></pre>
<p>由于指令重排序,可能变成:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">1.</span> memory = allocate();    <span class="hljs-comment">// 分配对象内存空间</span>
<span class="hljs-number">3.</span> instance = memory;      <span class="hljs-comment">// 设置instance指向刚分配的内存地址(此时对象还未初始化!)</span>
<span class="hljs-number">2.</span> ctorInstance(memory);   <span class="hljs-comment">// 初始化对象</span>
</code></pre>
<p><strong>问题场景:</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">时间线:</span>
<span class="hljs-attr">T1:</span> <span class="hljs-string">线程A执行到步骤3,instance不为null,但对象还未初始化</span>
<span class="hljs-attr">T2:</span> <span class="hljs-string">线程B执行第一次检查,发现instance</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">,直接返回instance</span>
<span class="hljs-attr">T3:</span> <span class="hljs-string">线程B使用instance访问对象属性,空指针异常或数据错误!</span>
</code></pre>
<p>使用volatile禁止指令重排序后,保证步骤2一定在步骤3之前执行。</p>
<h4 data-id="heading-17">2.2.3 volatile vs synchronized对比</h4>













































<table><thead><tr><th>特性</th><th>volatile</th><th>synchronized</th></tr></thead><tbody><tr><td>原子性</td><td>❌ 不保证(仅保证单次读/写的原子性)</td><td>✅ 保证(临界区内的操作是原子的)</td></tr><tr><td>可见性</td><td>✅ 保证</td><td>✅ 保证</td></tr><tr><td>有序性</td><td>✅ 保证(禁止指令重排序)</td><td>✅ 保证(同一时刻只有一个线程执行)</td></tr><tr><td>阻塞性</td><td>❌ 不阻塞</td><td>✅ 可能阻塞(重量级锁)</td></tr><tr><td>适用范围</td><td>只能修饰变量</td><td>可以修饰方法、代码块</td></tr><tr><td>性能</td><td>高(只插入内存屏障)</td><td>较低(可能涉及锁竞争和上下文切换)</td></tr><tr><td>使用场景</td><td>状态标志、一次性安全发布</td><td>复合操作、临界区保护</td></tr></tbody></table>
<p><strong>使用场景选择:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 适合使用volatile的场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileSuitableCase</span> {
    <span class="hljs-comment">// 场景1: 状态标志</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shutdownRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> {
        shutdownRequested = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">while</span> (!shutdownRequested) {
            <span class="hljs-comment">// 执行任务</span>
        }
    }

    <span class="hljs-comment">// 场景2: 一次性安全发布(配合DCL)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Singleton instance;
}

<span class="hljs-comment">// ❌ 不适合使用volatile的场景(需要使用synchronized)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileNotSuitableCase</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// ❌ 错误:volatile不能保证count++的原子性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
        count++;  <span class="hljs-comment">// 实际是三个操作: 读取 -&gt; 加1 -&gt; 写回</span>
    }

    <span class="hljs-comment">// ✅ 正确:使用synchronized保证原子性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCorrect</span><span class="hljs-params">()</span> {
        count++;
    }
}
</code></pre>
<h3 data-id="heading-18">2.3 线程间通信机制</h3>
<h4 data-id="heading-19">2.3.1 wait/notify/notifyAll机制</h4>
<p><strong>核心方法:</strong></p>
<ul>
<li><code>Object.wait()</code>: 释放当前持有的锁,进入对象的等待队列(WaitSet),线程状态变为WAITING</li>
<li><code>Object.wait(long timeout)</code>: 限时等待,超时后自动唤醒,线程状态变为TIMED_WAITING</li>
<li><code>Object.notify()</code>: 随机唤醒等待队列中的一个线程,被唤醒的线程从WAITING状态转为BLOCKED状态,重新竞争锁</li>
<li><code>Object.notifyAll()</code>: 唤醒等待队列中的所有线程</li>
</ul>
<p><strong>为什么必须在synchronized块中使用?</strong></p>
<ol>
<li><strong>防止丢失唤醒</strong>: 如果wait()不在synchronized块中,可能在调用wait()之前,notify()已经被调用,导致线程永久等待</li>
<li><strong>保证原子性</strong>: wait/notify操作通常伴随着对共享变量的判断和修改,需要同步保护</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 错误示例:不在synchronized块中使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrongUsage</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrongWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        lock.wait();  <span class="hljs-comment">// IllegalMonitorStateException: 未持有锁</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrongNotify</span><span class="hljs-params">()</span> {
        lock.notify();  <span class="hljs-comment">// IllegalMonitorStateException: 未持有锁</span>
    }
}

<span class="hljs-comment">// ✅ 正确示例:在synchronized块中使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorrectUsage</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">correctWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            lock.wait();  <span class="hljs-comment">// 正确:持有锁</span>
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">correctNotify</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {
            lock.notify();  <span class="hljs-comment">// 正确:持有锁</span>
        }
    }
}
</code></pre>
<p><strong>wait的释放锁与阻塞过程:</strong></p>
<pre><code class="hljs language-scss" lang="scss">┌────────────────────────────────────────────────┐
│           wait()方法的执行流程                   │
└────────────────────────────────────────────────┘

<span class="hljs-number">1</span>. 线程持有synchronized锁
   ┌─────────────┐
   │  Thread <span class="hljs-selector-tag">A</span>   │  ← 持有锁,_owner指向Thread <span class="hljs-selector-tag">A</span>
   └──────┬──────┘
          │ 调用lock<span class="hljs-selector-class">.wait</span>()
          ▼
<span class="hljs-number">2</span>. 释放锁,进入WaitSet
   ┌─────────────┐
   │  _owner     │  ← <span class="hljs-built_in">NULL</span>(锁已释放)
   └─────────────┘
   ┌─────────────┐
   │  _WaitSet   │  ← Thread <span class="hljs-selector-tag">A</span> (WAITING状态)
   └─────────────┘
   ┌─────────────┐
   │  _EntryList │  ← Thread <span class="hljs-selector-tag">B</span> (获得锁,继续执行)
   └─────────────┘
          │
          │ 其他线程调用lock<span class="hljs-selector-class">.notify</span>()
          ▼
<span class="hljs-number">3</span>. 从WaitSet移到EntryList,重新竞争锁
   ┌─────────────┐
   │  _WaitSet   │  ← 空
   └─────────────┘
   ┌─────────────┐
   │  _EntryList │  ← Thread <span class="hljs-selector-tag">A</span> (BLOCKED状态,等待获取锁)
   └─────────────┘
          │
          │ 获得锁
          ▼
<span class="hljs-number">4</span>. 重新持有锁,继续执行wait()之后的代码
   ┌─────────────┐
   │  _owner     │  ← Thread <span class="hljs-selector-tag">A</span>
   └─────────────┘
</code></pre>
<p><strong>notify的随机唤醒 vs notifyAll的全部唤醒:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotifyExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNotify</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-comment">// 启动3个等待线程</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                <span class="hljs-keyword">synchronized</span> (lock) {
                    <span class="hljs-keyword">try</span> {
                        System.out.println(<span class="hljs-string">"线程"</span> + threadNum + <span class="hljs-string">"开始等待"</span>);
                        lock.wait();
                        System.out.println(<span class="hljs-string">"线程"</span> + threadNum + <span class="hljs-string">"被唤醒"</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }

        Thread.sleep(<span class="hljs-number">1000</span>);

        <span class="hljs-comment">// 测试notify():只唤醒一个线程(随机)</span>
        <span class="hljs-keyword">synchronized</span> (lock) {
            System.out.println(<span class="hljs-string">"调用notify(),只唤醒一个线程"</span>);
            lock.notify();  <span class="hljs-comment">// 只有一个线程被唤醒,其他两个继续等待</span>
        }

        Thread.sleep(<span class="hljs-number">1000</span>);

        <span class="hljs-comment">// 测试notifyAll():唤醒所有线程</span>
        <span class="hljs-keyword">synchronized</span> (lock) {
            System.out.println(<span class="hljs-string">"调用notifyAll(),唤醒所有线程"</span>);
            lock.notifyAll();  <span class="hljs-comment">// 所有等待的线程被唤醒</span>
        }
    }
}
</code></pre>
<p><strong>虚假唤醒(Spurious Wakeup)问题:</strong></p>
<p>在某些操作系统的实现中,wait()可能在没有被notify/notifyAll的情况下意外唤醒。因此,<strong>必须在循环中使用wait()</strong>,而不是if语句。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 错误:使用if判断</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpuriousWakeupWrong</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-keyword">if</span> (!condition) {  <span class="hljs-comment">// ❌ 使用if,虚假唤醒后不再检查条件</span>
                lock.wait();
            }
            <span class="hljs-comment">// 执行业务逻辑</span>
        }
    }
}

<span class="hljs-comment">// ✅ 正确:使用while循环</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpuriousWakeupCorrect</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-keyword">while</span> (!condition) {  <span class="hljs-comment">// ✅ 使用while,被唤醒后重新检查条件</span>
                lock.wait();
            }
            <span class="hljs-comment">// 执行业务逻辑</span>
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalCondition</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {
            condition = <span class="hljs-literal">true</span>;
            lock.notifyAll();
        }
    }
}
</code></pre>
<p><strong>经典案例:生产者-消费者模式</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumer</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-comment">// 生产者</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">(String item)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-comment">// 使用while循环,防止虚假唤醒</span>
            <span class="hljs-keyword">while</span> (queue.size() == maxSize) {
                System.out.println(<span class="hljs-string">"队列已满,生产者等待..."</span>);
                lock.wait();  <span class="hljs-comment">// 队列满,等待消费者消费</span>
            }

            queue.offer(item);
            System.out.println(<span class="hljs-string">"生产: "</span> + item + <span class="hljs-string">", 当前队列大小: "</span> + queue.size());

            lock.notifyAll();  <span class="hljs-comment">// 唤醒等待的消费者</span>
        }
    }

    <span class="hljs-comment">// 消费者</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-comment">// 使用while循环,防止虚假唤醒</span>
            <span class="hljs-keyword">while</span> (queue.isEmpty()) {
                System.out.println(<span class="hljs-string">"队列为空,消费者等待..."</span>);
                lock.wait();  <span class="hljs-comment">// 队列空,等待生产者生产</span>
            }

            <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.poll();
            System.out.println(<span class="hljs-string">"消费: "</span> + item + <span class="hljs-string">", 当前队列大小: "</span> + queue.size());

            lock.notifyAll();  <span class="hljs-comment">// 唤醒等待的生产者</span>
            <span class="hljs-keyword">return</span> item;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ProducerConsumer</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerConsumer</span>();

        <span class="hljs-comment">// 启动3个生产者</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">producerId</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++) {
                        pc.produce(<span class="hljs-string">"产品-"</span> + producerId + <span class="hljs-string">"-"</span> + j);
                        Thread.sleep(<span class="hljs-number">100</span>);
                    }
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }, <span class="hljs-string">"生产者-"</span> + i).start();
        }

        <span class="hljs-comment">// 启动2个消费者</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) {
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">7</span>; j++) {
                        pc.consume();
                        Thread.sleep(<span class="hljs-number">150</span>);
                    }
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }, <span class="hljs-string">"消费者-"</span> + i).start();
        }
    }
}
</code></pre>
<h4 data-id="heading-20">2.3.2 LockSupport工具类</h4>
<p>LockSupport是JDK 1.5引入的线程阻塞工具类,提供了更灵活的线程阻塞和唤醒机制。</p>
<p><strong>核心方法:</strong></p>
<ul>
<li><code>LockSupport.park()</code>: 阻塞当前线程,除非许可(permit)可用</li>
<li><code>LockSupport.park(Object blocker)</code>: 阻塞当前线程,并设置阻塞对象(便于诊断)</li>
<li><code>LockSupport.parkNanos(long nanos)</code>: 限时阻塞(纳秒级)</li>
<li><code>LockSupport.unpark(Thread thread)</code>: 使指定线程可用许可,如果线程被阻塞,则唤醒它</li>
</ul>
<p><strong>许可(Permit)机制:</strong></p>
<p>LockSupport内部维护了一个许可(permit),类似于信号量,但最多只有一个许可(0或1)。</p>
<pre><code class="hljs language-css" lang="css">许可机制:
<span class="hljs-number">1</span>. <span class="hljs-built_in">unpark</span>() → 许可设置为<span class="hljs-number">1</span>
<span class="hljs-number">2</span>. <span class="hljs-built_in">park</span>()   → 如果许可为<span class="hljs-number">1</span>,消耗许可(设置为<span class="hljs-number">0</span>),继续执行
              如果许可为<span class="hljs-number">0</span>,阻塞线程

特点:
- 许可最多为<span class="hljs-number">1</span>,多次<span class="hljs-built_in">unpark</span>()不会累加
- <span class="hljs-built_in">unpark</span>()可以在<span class="hljs-built_in">park</span>()之前调用(与wait/notify不同)
</code></pre>
<p><strong>与wait/notify的区别:</strong></p>



































<table><thead><tr><th>特性</th><th>wait/notify</th><th>LockSupport.park/unpark</th></tr></thead><tbody><tr><td>是否需要synchronized</td><td>✅ 必须在synchronized块中</td><td>❌ 不需要</td></tr><tr><td>唤醒指定线程</td><td>❌ notify()随机唤醒</td><td>✅ unpark(thread)指定线程</td></tr><tr><td>顺序要求</td><td>✅ 必须先wait()后notify()</td><td>❌ unpark()可以在park()之前调用</td></tr><tr><td>许可累加</td><td>❌ 不支持</td><td>❌ 不支持(最多1个许可)</td></tr><tr><td>响应中断</td><td>✅ 抛出InterruptedException</td><td>✅ 不抛异常,但Thread.interrupted()返回true</td></tr></tbody></table>
<p><strong>基本使用示例:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            System.out.println(<span class="hljs-string">"线程开始,准备阻塞"</span>);
            LockSupport.park();  <span class="hljs-comment">// 阻塞,等待许可</span>
            System.out.println(<span class="hljs-string">"线程被唤醒,继续执行"</span>);
        });

        thread.start();
        Thread.sleep(<span class="hljs-number">2000</span>);

        System.out.println(<span class="hljs-string">"主线程唤醒子线程"</span>);
        LockSupport.unpark(thread);  <span class="hljs-comment">// 给thread一个许可,唤醒线程</span>
    }
}
</code></pre>
<p><strong>许可机制演示:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportPermitExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            System.out.println(<span class="hljs-string">"线程启动"</span>);

            <span class="hljs-comment">// 场景1: unpark()在park()之前调用</span>
            <span class="hljs-comment">// 由于已经有许可,park()不会阻塞</span>
            LockSupport.park();
            System.out.println(<span class="hljs-string">"第一次park()不阻塞(许可已提前发放)"</span>);

            <span class="hljs-comment">// 场景2: 许可已被消耗,再次park()会阻塞</span>
            System.out.println(<span class="hljs-string">"第二次park()会阻塞(许可已消耗)"</span>);
            LockSupport.park();
            System.out.println(<span class="hljs-string">"第二次park()被唤醒"</span>);
        });

        <span class="hljs-comment">// 提前发放许可</span>
        LockSupport.unpark(thread);
        thread.start();

        Thread.sleep(<span class="hljs-number">2000</span>);

        <span class="hljs-comment">// 唤醒第二次park()</span>
        LockSupport.unpark(thread);
    }
}
</code></pre>
<p><strong>LockSupport的应用场景:</strong></p>
<ol>
<li><strong>实现自定义锁</strong>: AQS(AbstractQueuedSynchronizer)底层使用LockSupport实现线程阻塞和唤醒</li>
<li><strong>精确唤醒指定线程</strong>: 不需要notifyAll()唤醒所有线程,减少无效唤醒</li>
<li><strong>灵活的阻塞机制</strong>: 不需要获取锁,使用更灵活</li>
</ol>
<h2 data-id="heading-21">三、实战场景应用</h2>
<h3 data-id="heading-22">场景1:电商订单状态更新的并发控制</h3>
<p><strong>业务背景:</strong></p>
<p>在电商系统中,订单状态可能被多个线程同时修改:</p>
<ul>
<li>用户支付成功后,支付回调线程将订单状态从"待支付"改为"待发货"</li>
<li>订单超时未支付,定时任务线程将订单状态改为"已取消"</li>
<li>管理员手动取消订单,管理后台线程将订单状态改为"已取消"</li>
</ul>
<p><strong>问题分析:</strong></p>
<p>如果不进行并发控制,可能出现以下问题:</p>
<ol>
<li><strong>竞态条件</strong>: 支付回调和超时取消同时执行,导致状态不一致</li>
<li><strong>丢失更新</strong>: 后执行的操作覆盖先执行的操作</li>
<li><strong>状态机混乱</strong>: 订单状态跳过中间状态,如从"待支付"直接变为"已完成"</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 订单状态枚举</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderStatus</span> {
    PENDING_PAYMENT(<span class="hljs-number">1</span>, <span class="hljs-string">"待支付"</span>),
    PAID(<span class="hljs-number">2</span>, <span class="hljs-string">"已支付"</span>),
    SHIPPED(<span class="hljs-number">3</span>, <span class="hljs-string">"已发货"</span>),
    COMPLETED(<span class="hljs-number">4</span>, <span class="hljs-string">"已完成"</span>),
    CANCELLED(<span class="hljs-number">5</span>, <span class="hljs-string">"已取消"</span>);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> code;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;

    OrderStatus(<span class="hljs-type">int</span> code, String desc) {
        <span class="hljs-built_in">this</span>.code = code;
        <span class="hljs-built_in">this</span>.desc = desc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> code;
    }
}

<span class="hljs-comment">// 订单实体</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> {
    <span class="hljs-keyword">private</span> Long orderId;
    <span class="hljs-keyword">private</span> OrderStatus status;
    <span class="hljs-keyword">private</span> Integer version;  <span class="hljs-comment">// 乐观锁版本号</span>
    <span class="hljs-keyword">private</span> Long userId;
    <span class="hljs-keyword">private</span> BigDecimal amount;
    <span class="hljs-keyword">private</span> LocalDateTime createTime;
    <span class="hljs-keyword">private</span> LocalDateTime updateTime;

    <span class="hljs-comment">// getter/setter省略</span>
}
</code></pre>
<p><strong>解决方案A:synchronized方法控制</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderService.class);

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-comment">// 方案A: 使用synchronized控制并发</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateOrderStatus</span><span class="hljs-params">(Long orderId, OrderStatus targetStatus, String operator)</span> {
        <span class="hljs-comment">// 1. 查询订单</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
        <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
            log.warn(<span class="hljs-string">"订单不存在, orderId={}"</span>, orderId);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 2. 状态机校验</span>
        <span class="hljs-keyword">if</span> (!validateStatusTransition(order.getStatus(), targetStatus)) {
            log.warn(<span class="hljs-string">"订单状态转换不合法, orderId={}, currentStatus={}, targetStatus={}"</span>,
                orderId, order.getStatus(), targetStatus);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 3. 更新订单状态</span>
        order.setStatus(targetStatus);
        order.setUpdateTime(LocalDateTime.now());
        orderMapper.updateById(order);

        log.info(<span class="hljs-string">"订单状态更新成功, orderId={}, {} -&gt; {}, operator={}"</span>,
            orderId, order.getStatus(), targetStatus, operator);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// 状态机校验:定义合法的状态转换</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStatusTransition</span><span class="hljs-params">(OrderStatus current, OrderStatus target)</span> {
        <span class="hljs-keyword">if</span> (current == target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 相同状态,无需更新</span>
        }

        <span class="hljs-keyword">switch</span> (current) {
            <span class="hljs-keyword">case</span> PENDING_PAYMENT:
                <span class="hljs-comment">// 待支付 → 已支付、已取消</span>
                <span class="hljs-keyword">return</span> target == OrderStatus.PAID || target == OrderStatus.CANCELLED;
            <span class="hljs-keyword">case</span> PAID:
                <span class="hljs-comment">// 已支付 → 已发货、已取消(特殊情况)</span>
                <span class="hljs-keyword">return</span> target == OrderStatus.SHIPPED || target == OrderStatus.CANCELLED;
            <span class="hljs-keyword">case</span> SHIPPED:
                <span class="hljs-comment">// 已发货 → 已完成</span>
                <span class="hljs-keyword">return</span> target == OrderStatus.COMPLETED;
            <span class="hljs-keyword">case</span> COMPLETED:
            <span class="hljs-keyword">case</span> CANCELLED:
                <span class="hljs-comment">// 已完成、已取消为终态,不允许再转换</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>优点:</strong></p>
<ul>
<li>实现简单,代码清晰</li>
<li>保证同一时刻只有一个线程修改订单状态</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>锁粒度过大,synchronized锁住整个方法,所有订单更新都串行执行</li>
<li>性能差,高并发场景下成为瓶颈</li>
<li>单机锁,分布式环境下无法保证安全性</li>
</ul>
<p><strong>解决方案B:数据库乐观锁(version字段)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderService.class);

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-comment">// 方案B: 使用数据库乐观锁</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateOrderStatusWithOptimisticLock</span><span class="hljs-params">(Long orderId, OrderStatus targetStatus, String operator)</span> {
        <span class="hljs-comment">// 最多重试3次</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">maxRetry</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxRetry; i++) {
            <span class="hljs-comment">// 1. 查询订单(包含version)</span>
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
                log.warn(<span class="hljs-string">"订单不存在, orderId={}"</span>, orderId);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-comment">// 2. 状态机校验</span>
            <span class="hljs-keyword">if</span> (!validateStatusTransition(order.getStatus(), targetStatus)) {
                log.warn(<span class="hljs-string">"订单状态转换不合法, orderId={}, currentStatus={}, targetStatus={}"</span>,
                    orderId, order.getStatus(), targetStatus);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-comment">// 3. 使用乐观锁更新(WHERE id=? AND version=?)</span>
            <span class="hljs-type">Integer</span> <span class="hljs-variable">oldVersion</span> <span class="hljs-operator">=</span> order.getVersion();
            order.setStatus(targetStatus);
            order.setVersion(oldVersion + <span class="hljs-number">1</span>);
            order.setUpdateTime(LocalDateTime.now());

            <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> orderMapper.updateByIdAndVersion(order, oldVersion);

            <span class="hljs-keyword">if</span> (affectedRows &gt; <span class="hljs-number">0</span>) {
                log.info(<span class="hljs-string">"订单状态更新成功, orderId={}, {} -&gt; {}, operator={}, retry={}"</span>,
                    orderId, order.getStatus(), targetStatus, operator, i);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
                log.warn(<span class="hljs-string">"订单状态更新失败(版本冲突), orderId={}, 第{}次重试"</span>, orderId, i + <span class="hljs-number">1</span>);
                <span class="hljs-comment">// 版本冲突,重试</span>
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">50</span>);  <span class="hljs-comment">// 避免频繁重试</span>
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        }

        log.error(<span class="hljs-string">"订单状态更新失败(超过最大重试次数), orderId={}"</span>, orderId);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStatusTransition</span><span class="hljs-params">(OrderStatus current, OrderStatus target)</span> {
        <span class="hljs-comment">// 同方案A</span>
        <span class="hljs-comment">// ...</span>
    }
}

<span class="hljs-comment">// MyBatis Mapper</span>
<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Order&gt; {
    <span class="hljs-comment">/**
     * 乐观锁更新订单
     * SQL: UPDATE t_order SET status=#{status}, version=#{version}, update_time=#{updateTime}
     *      WHERE id=#{id} AND version=#{oldVersion}
     */</span>
    <span class="hljs-meta">@Update("UPDATE t_order SET status=#{order.status}, version=#{order.version}, " +
            "update_time=#{order.updateTime} " +
            "WHERE id=#{order.id} AND version=#{oldVersion}")</span>
    <span class="hljs-type">int</span> <span class="hljs-title function_">updateByIdAndVersion</span><span class="hljs-params">(<span class="hljs-meta">@Param("order")</span> Order order, <span class="hljs-meta">@Param("oldVersion")</span> Integer oldVersion)</span>;
}
</code></pre>
<p><strong>优点:</strong></p>
<ul>
<li>无锁化设计,高并发性能好</li>
<li>通过version字段保证更新的原子性</li>
<li>适用于读多写少的场景</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>冲突时需要重试,增加复杂度</li>
<li>重试次数过多可能影响性能</li>
<li>单表更新有效,涉及多表事务时需要额外处理</li>
</ul>
<p><strong>解决方案C:分布式锁</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderService.class);

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedissonClient redissonClient;

    <span class="hljs-comment">// 方案C: 使用分布式锁(Redisson)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateOrderStatusWithDistributedLock</span><span class="hljs-params">(Long orderId, OrderStatus targetStatus, String operator)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">"order:lock:"</span> + orderId;
        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockKey);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 尝试加锁,最多等待10秒,锁自动释放时间30秒</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span> (!locked) {
                log.warn(<span class="hljs-string">"获取分布式锁失败, orderId={}"</span>, orderId);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-comment">// 1. 查询订单</span>
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
                log.warn(<span class="hljs-string">"订单不存在, orderId={}"</span>, orderId);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-comment">// 2. 状态机校验</span>
            <span class="hljs-keyword">if</span> (!validateStatusTransition(order.getStatus(), targetStatus)) {
                log.warn(<span class="hljs-string">"订单状态转换不合法, orderId={}, currentStatus={}, targetStatus={}"</span>,
                    orderId, order.getStatus(), targetStatus);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-comment">// 3. 更新订单状态</span>
            order.setStatus(targetStatus);
            order.setUpdateTime(LocalDateTime.now());
            orderMapper.updateById(order);

            log.info(<span class="hljs-string">"订单状态更新成功, orderId={}, {} -&gt; {}, operator={}"</span>,
                orderId, order.getStatus(), targetStatus, operator);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error(<span class="hljs-string">"获取分布式锁被中断, orderId={}"</span>, orderId, e);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 释放锁</span>
            <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStatusTransition</span><span class="hljs-params">(OrderStatus current, OrderStatus target)</span> {
        <span class="hljs-comment">// 同方案A</span>
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p><strong>优点:</strong></p>
<ul>
<li>分布式环境下保证安全性</li>
<li>锁粒度可控(按订单ID加锁,不同订单并行处理)</li>
<li>支持锁续期(Redisson Watchdog机制)</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>依赖Redis,增加系统复杂度</li>
<li>网络延迟影响性能</li>
<li>需要处理Redis故障和锁续期问题</li>
</ul>
<p><strong>性能测试对比:</strong></p>





































<table><thead><tr><th>方案</th><th>并发线程数</th><th>总请求数</th><th>平均RT</th><th>TPS</th><th>成功率</th></tr></thead><tbody><tr><td>synchronized方法</td><td>100</td><td>10000</td><td>250ms</td><td>400</td><td>100%</td></tr><tr><td>数据库乐观锁</td><td>100</td><td>10000</td><td>80ms</td><td>1250</td><td>95%(重试后成功)</td></tr><tr><td>分布式锁(Redisson)</td><td>100</td><td>10000</td><td>120ms</td><td>833</td><td>100%</td></tr></tbody></table>
<p><strong>推荐方案:</strong></p>
<ul>
<li><strong>单机应用</strong>: 使用数据库乐观锁(方案B),性能最优</li>
<li><strong>分布式应用</strong>: 使用分布式锁(方案C),保证安全性</li>
<li><strong>低并发场景</strong>: 使用synchronized(方案A),实现简单</li>
</ul>
<h3 data-id="heading-23">场景2:使用volatile实现优雅停止线程</h3>
<p><strong>业务背景:</strong></p>
<p>监控线程周期性检查系统状态(如订单超时检测、库存同步),需要能优雅停止线程而不是强制中断。</p>
<p><strong>错误实现:boolean变量未加volatile</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThreadWrong</span> {
    <span class="hljs-comment">// ❌ 错误:未使用volatile,可能导致主线程修改后,工作线程无法感知</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stopRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 启动工作线程</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!stopRequested) {  <span class="hljs-comment">// 可能永远读取不到stopRequested的变化</span>
                count++;
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            System.out.println(<span class="hljs-string">"工作线程停止, 总执行次数: "</span> + count);
        }, <span class="hljs-string">"Worker-Thread"</span>).start();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
        stopRequested = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 主线程修改,工作线程可能看不到</span>
        System.out.println(<span class="hljs-string">"主线程已设置停止标志"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-type">StopThreadWrong</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThreadWrong</span>();
        worker.start();

        Thread.sleep(<span class="hljs-number">5000</span>);
        worker.stop();  <span class="hljs-comment">// 工作线程可能无法停止!</span>
    }
}
</code></pre>
<p><strong>问题原因:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">内存可见性问题:

主线程(CPU0)                    工作线程(CPU1)
┌─────────────┐                ┌─────────────┐
│ stopRequested│                │ stopRequested│
│   = <span class="hljs-literal">false</span>   │                │   = <span class="hljs-literal">false</span>   │  ← CPU1缓存中的值
└──────┬──────┘                └──────┬──────┘
       │                              │
       │ stopRequested = <span class="hljs-literal">true</span>         │ <span class="hljs-keyword">while</span>(!stopRequested)
       ▼                              │   循环继续...
┌─────────────┐                      │
│主内存        │                      │
│stopRequested│                      │
│   = <span class="hljs-literal">true</span>    │                      ▼
└─────────────┘              可能永远读取不到<span class="hljs-literal">true</span>!
                             (CPU1缓存未失效,一直使用缓存值<span class="hljs-literal">false</span>)
</code></pre>
<p><strong>正确实现:使用volatile</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThreadCorrect</span> {
    <span class="hljs-comment">// ✅ 正确:使用volatile,保证可见性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stopRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 启动工作线程</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!stopRequested) {  <span class="hljs-comment">// volatile保证能立即读取到主线程的修改</span>
                count++;
                System.out.println(<span class="hljs-string">"执行任务 #"</span> + count);
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    <span class="hljs-keyword">break</span>;
                }
            }
            System.out.println(<span class="hljs-string">"工作线程优雅停止, 总执行次数: "</span> + count);
        }, <span class="hljs-string">"Worker-Thread"</span>).start();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
        stopRequested = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// volatile写操作,立即刷新到主内存</span>
        System.out.println(<span class="hljs-string">"主线程已设置停止标志"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-type">StopThreadCorrect</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThreadCorrect</span>();
        worker.start();

        Thread.sleep(<span class="hljs-number">5000</span>);
        worker.stop();  <span class="hljs-comment">// 工作线程能立即感知到stopRequested变化,优雅停止</span>
    }
}
</code></pre>
<p><strong>原理解释:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">volatile</span>保证可见性:

主线程                          工作线程
  │                              │
  │ stopRequested = <span class="hljs-literal">true</span>         │
  │      ↓                       │
  │  StoreStore屏障              │
  │      ↓                       │
  │  写入主内存                  │
  │      ↓                       │
  │  StoreLoad屏障               │
  │      ↓                       │
  └──────────────────────────────┤
                                 │
                                 │ <span class="hljs-keyword">while</span>(!stopRequested)
                                 │      ↓
                                 │  LoadLoad屏障
                                 │      ↓
                                 │  从主内存读取(强制刷新CPU缓存)
                                 │      ↓
                                 │  读取到<span class="hljs-literal">true</span>,退出循环
</code></pre>
<p><strong>实际应用:订单超时检测</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTimeoutMonitor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderTimeoutMonitor.class);

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderService orderService;

    <span class="hljs-comment">// 停止标志</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stopRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 监控线程</span>
    <span class="hljs-keyword">private</span> Thread monitorThread;

    <span class="hljs-comment">/**
     * 启动监控
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (monitorThread != <span class="hljs-literal">null</span> &amp;&amp; monitorThread.isAlive()) {
            log.warn(<span class="hljs-string">"监控线程已启动,无需重复启动"</span>);
            <span class="hljs-keyword">return</span>;
        }

        stopRequested = <span class="hljs-literal">false</span>;
        monitorThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            log.info(<span class="hljs-string">"订单超时监控线程启动"</span>);

            <span class="hljs-keyword">while</span> (!stopRequested) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 查询超时未支付的订单</span>
                    List&lt;Order&gt; timeoutOrders = orderService.selectTimeoutOrders();

                    <span class="hljs-keyword">for</span> (Order order : timeoutOrders) {
                        <span class="hljs-comment">// 自动取消超时订单</span>
                        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> orderService.updateOrderStatus(
                            order.getOrderId(),
                            OrderStatus.CANCELLED,
                            <span class="hljs-string">"System-Timeout"</span>
                        );

                        <span class="hljs-keyword">if</span> (success) {
                            log.info(<span class="hljs-string">"自动取消超时订单, orderId={}"</span>, order.getOrderId());
                        }
                    }

                    <span class="hljs-comment">// 每60秒检查一次</span>
                    Thread.sleep(<span class="hljs-number">60000</span>);

                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    log.warn(<span class="hljs-string">"监控线程被中断"</span>);
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    log.error(<span class="hljs-string">"监控线程异常"</span>, e);
                }
            }

            log.info(<span class="hljs-string">"订单超时监控线程停止"</span>);
        }, <span class="hljs-string">"Order-Timeout-Monitor"</span>);

        monitorThread.start();
    }

    <span class="hljs-comment">/**
     * 停止监控
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
        stopRequested = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// volatile写,保证可见性</span>

        <span class="hljs-keyword">if</span> (monitorThread != <span class="hljs-literal">null</span>) {
            monitorThread.interrupt();  <span class="hljs-comment">// 中断sleep状态</span>
        }

        log.info(<span class="hljs-string">"已发送停止信号"</span>);
    }

    <span class="hljs-comment">/**
     * 应用启动时自动启动监控
     */</span>
    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> {
        start();
    }

    <span class="hljs-comment">/**
     * 应用关闭时优雅停止监控
     */</span>
    <span class="hljs-meta">@PreDestroy</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        stop();
    }
}
</code></pre>
<h2 data-id="heading-24">四、生产案例与故障排查</h2>
<h3 data-id="heading-25">案例1:线程死锁排查与解决</h3>
<p><strong>故障现象:</strong></p>
<p>某电商平台在促销活动期间,系统响应缓慢,部分用户下单接口卡死超时。监控显示CPU使用率不高,但TPS大幅下降。</p>
<p><strong>排查过程:</strong></p>
<p><strong>步骤1:使用jstack生成线程dump</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查找Java进程PID</span>
jps -l

<span class="hljs-comment"># 生成线程dump</span>
jstack -l 12345 &gt; thread_dump.txt
</code></pre>
<p><strong>步骤2:分析死锁日志</strong></p>
<p>在thread_dump.txt中发现死锁信息:</p>
<pre><code class="hljs language-vbnet" lang="vbnet">Found one Java-level deadlock:
=============================
<span class="hljs-string">"Thread-A"</span>:
  waiting <span class="hljs-keyword">to</span> lock monitor <span class="hljs-number">0</span>x00007f8a1c004e00 (<span class="hljs-type">object</span> <span class="hljs-number">0</span>x00000000e0a12345, a com.example.OrderLock),
  which <span class="hljs-built_in">is</span> held <span class="hljs-keyword">by</span> <span class="hljs-string">"Thread-B"</span>
<span class="hljs-string">"Thread-B"</span>:
  waiting <span class="hljs-keyword">to</span> lock monitor <span class="hljs-number">0</span>x00007f8a1c004d00 (<span class="hljs-type">object</span> <span class="hljs-number">0</span>x00000000e0a12346, a com.example.InventoryLock),
  which <span class="hljs-built_in">is</span> held <span class="hljs-keyword">by</span> <span class="hljs-string">"Thread-A"</span>

Java stack information <span class="hljs-keyword">for</span> the threads listed above:
===================================================
<span class="hljs-string">"Thread-A"</span>:
        at com.example.OrderService.createOrder(OrderService.java:<span class="hljs-number">45</span>)
        - waiting <span class="hljs-keyword">to</span> lock &lt;<span class="hljs-number">0</span>x00000000e0a12345&gt; (a com.example.OrderLock)
        - locked &lt;<span class="hljs-number">0</span>x00000000e0a12346&gt; (a com.example.InventoryLock)

<span class="hljs-string">"Thread-B"</span>:
        at com.example.InventoryService.deductStock(InventoryService.java:<span class="hljs-number">32</span>)
        - waiting <span class="hljs-keyword">to</span> lock &lt;<span class="hljs-number">0</span>x00000000e0a12346&gt; (a com.example.InventoryLock)
        - locked &lt;<span class="hljs-number">0</span>x00000000e0a12345&gt; (a com.example.OrderLock)
</code></pre>
<p><strong>步骤3:定位死锁代码</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 死锁代码(错误示例)</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> InventoryService inventoryService;

    <span class="hljs-comment">// 线程A:先锁库存,再锁订单</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-keyword">synchronized</span> (inventoryLock) {  <span class="hljs-comment">// ← 先获取inventoryLock</span>
            System.out.println(<span class="hljs-string">"OrderService获取inventoryLock"</span>);

            <span class="hljs-comment">// 模拟业务处理</span>
            <span class="hljs-keyword">try</span> { Thread.sleep(<span class="hljs-number">100</span>); } <span class="hljs-keyword">catch</span> (InterruptedException e) {}

            <span class="hljs-keyword">synchronized</span> (orderLock) {  <span class="hljs-comment">// ← 再获取orderLock</span>
                System.out.println(<span class="hljs-string">"OrderService获取orderLock"</span>);
                <span class="hljs-comment">// 创建订单逻辑</span>
            }
        }
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-comment">// 线程B:先锁订单,再锁库存</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(Long orderId, Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-keyword">synchronized</span> (orderLock) {  <span class="hljs-comment">// ← 先获取orderLock</span>
            System.out.println(<span class="hljs-string">"InventoryService获取orderLock"</span>);

            <span class="hljs-comment">// 模拟业务处理</span>
            <span class="hljs-keyword">try</span> { Thread.sleep(<span class="hljs-number">100</span>); } <span class="hljs-keyword">catch</span> (InterruptedException e) {}

            <span class="hljs-keyword">synchronized</span> (inventoryLock) {  <span class="hljs-comment">// ← 再获取inventoryLock</span>
                System.out.println(<span class="hljs-string">"InventoryService获取inventoryLock"</span>);
                <span class="hljs-comment">// 扣减库存逻辑</span>
            }
        }
    }
}
</code></pre>
<p><strong>死锁场景复现:</strong></p>
<pre><code class="hljs language-less" lang="less">时间线:
<span class="hljs-selector-tag">T1</span>: 线程<span class="hljs-selector-tag">A</span>执行<span class="hljs-selector-tag">createOrder</span>(),获取<span class="hljs-selector-tag">inventoryLock</span>
<span class="hljs-selector-tag">T2</span>: 线程<span class="hljs-selector-tag">B</span>执行<span class="hljs-selector-tag">deductStock</span>(),获取<span class="hljs-selector-tag">orderLock</span>
<span class="hljs-selector-tag">T3</span>: 线程<span class="hljs-selector-tag">A</span>尝试获取<span class="hljs-selector-tag">orderLock</span>,被线程<span class="hljs-selector-tag">B</span>持有,阻塞等待
<span class="hljs-selector-tag">T4</span>: 线程<span class="hljs-selector-tag">B</span>尝试获取<span class="hljs-selector-tag">inventoryLock</span>,被线程<span class="hljs-selector-tag">A</span>持有,阻塞等待
<span class="hljs-selector-tag">T5</span>: 死锁!两个线程互相等待对方释放锁

┌─────────────────────────────────────────────────┐
│              死锁示意图                          │
└─────────────────────────────────────────────────┘

    <span class="hljs-selector-tag">Thread-A</span>                       <span class="hljs-selector-tag">Thread-B</span>
        │                              │
        │ 获取<span class="hljs-selector-tag">inventoryLock</span>            │
        ├────────────────►             │
        │ 持有<span class="hljs-selector-tag">inventoryLock</span>            │
        │                              │ 获取<span class="hljs-selector-tag">orderLock</span>
        │                              ├────────────────►
        │                              │ 持有<span class="hljs-selector-tag">orderLock</span>
        │                              │
        │ 尝试获取<span class="hljs-selector-tag">orderLock</span>            │
        ├─────────┐                    │
        │  等待   │ ◄──────────────────┤ 被<span class="hljs-selector-tag">Thread-B</span>持有
        │         │                    │
        │         │                    │ 尝试获取<span class="hljs-selector-tag">inventoryLock</span>
        │         │                    ├─────────┐
        │         │ 被<span class="hljs-selector-tag">Thread-A</span>持有 ───►│  等待   │
        │         │                    │         │
        │         │                    │         │
        └─────────┴────────────────────┴─────────┘
                      死锁!
</code></pre>
<p><strong>死锁的四个必要条件:</strong></p>
<ol>
<li><strong>互斥条件</strong>: 资源不能被多个线程同时访问</li>
<li><strong>持有并等待</strong>: 线程持有一个资源,同时等待获取另一个资源</li>
<li><strong>不可剥夺</strong>: 资源不能被强制从持有线程中剥夺</li>
<li><strong>循环等待</strong>: 存在线程等待环路(A等B,B等A)</li>
</ol>
<p><strong>解决方案1:统一锁顺序(破坏循环等待)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 解决方案1:统一锁的获取顺序</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-comment">// 使用同一把锁对象(从Spring容器获取)</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> LockManager lockManager;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-type">Object</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> lockManager.getInventoryLock();
        <span class="hljs-type">Object</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> lockManager.getOrderLock();

        <span class="hljs-comment">// 统一按照:先锁inventory,再锁order</span>
        <span class="hljs-keyword">synchronized</span> (inventoryLock) {
            System.out.println(<span class="hljs-string">"OrderService获取inventoryLock"</span>);

            <span class="hljs-keyword">synchronized</span> (orderLock) {
                System.out.println(<span class="hljs-string">"OrderService获取orderLock"</span>);
                <span class="hljs-comment">// 创建订单逻辑</span>
            }
        }
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> LockManager lockManager;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(Long orderId, Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-type">Object</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> lockManager.getInventoryLock();
        <span class="hljs-type">Object</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> lockManager.getOrderLock();

        <span class="hljs-comment">// 统一按照:先锁inventory,再锁order(与OrderService保持一致)</span>
        <span class="hljs-keyword">synchronized</span> (inventoryLock) {
            System.out.println(<span class="hljs-string">"InventoryService获取inventoryLock"</span>);

            <span class="hljs-keyword">synchronized</span> (orderLock) {
                System.out.println(<span class="hljs-string">"InventoryService获取orderLock"</span>);
                <span class="hljs-comment">// 扣减库存逻辑</span>
            }
        }
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockManager</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInventoryLock</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> inventoryLock;
    }

    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getOrderLock</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> orderLock;
    }
}
</code></pre>
<p><strong>解决方案2:使用tryLock超时机制(破坏持有并等待)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 解决方案2:使用Lock的tryLock()方法</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">inventoryLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">orderLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 尝试获取inventoryLock,最多等待1秒</span>
            <span class="hljs-keyword">if</span> (inventoryLock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) {
                <span class="hljs-keyword">try</span> {
                    System.out.println(<span class="hljs-string">"OrderService获取inventoryLock"</span>);

                    <span class="hljs-comment">// 尝试获取orderLock,最多等待1秒</span>
                    <span class="hljs-keyword">if</span> (orderLock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) {
                        <span class="hljs-keyword">try</span> {
                            System.out.println(<span class="hljs-string">"OrderService获取orderLock"</span>);
                            <span class="hljs-comment">// 创建订单逻辑</span>
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                        } <span class="hljs-keyword">finally</span> {
                            orderLock.unlock();
                        }
                    } <span class="hljs-keyword">else</span> {
                        System.out.println(<span class="hljs-string">"OrderService获取orderLock超时,放弃操作"</span>);
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                } <span class="hljs-keyword">finally</span> {
                    inventoryLock.unlock();
                }
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"OrderService获取inventoryLock超时,放弃操作"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>解决方案3:重构代码,避免嵌套锁</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 解决方案3:避免嵌套锁,使用单锁或无锁设计</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> InventoryService inventoryService;

    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-comment">// 1. 先扣减库存(原子操作,数据库层面保证)</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">deducted</span> <span class="hljs-operator">=</span> inventoryService.tryDeductStock(skuId, quantity);
        <span class="hljs-keyword">if</span> (!deducted) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">"库存不足"</span>);
        }

        <span class="hljs-comment">// 2. 创建订单(无需额外加锁)</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();
        order.setSkuId(skuId);
        order.setQuantity(quantity);
        order.setStatus(OrderStatus.PENDING_PAYMENT);
        orderMapper.insert(order);
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> InventoryMapper inventoryMapper;

    <span class="hljs-comment">// 使用数据库CAS操作,避免加锁</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryDeductStock</span><span class="hljs-params">(Long skuId, <span class="hljs-type">int</span> quantity)</span> {
        <span class="hljs-comment">// UPDATE inventory SET stock = stock - #{quantity}</span>
        <span class="hljs-comment">// WHERE sku_id = #{skuId} AND stock &gt;= #{quantity}</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">affectedRows</span> <span class="hljs-operator">=</span> inventoryMapper.deductStock(skuId, quantity);
        <span class="hljs-keyword">return</span> affectedRows &gt; <span class="hljs-number">0</span>;
    }
}
</code></pre>
<p><strong>预防死锁的最佳实践:</strong></p>
<ol>
<li><strong>避免嵌套锁</strong>: 尽量使用单锁,减少锁的嵌套层级</li>
<li><strong>统一锁顺序</strong>: 如果必须嵌套,所有线程按相同顺序获取锁</li>
<li><strong>使用tryLock</strong>: 设置超时时间,避免无限等待</li>
<li><strong>缩小锁范围</strong>: 只锁必要的代码块,减少持锁时间</li>
<li><strong>使用并发工具类</strong>: 如ConcurrentHashMap、原子类,避免显式加锁</li>
</ol>
<h3 data-id="heading-26">案例2:synchronized锁粒度过大导致性能问题</h3>
<p><strong>故障现象:</strong></p>
<p>某订单查询接口在高并发下TPS严重下降,从正常的1000 TPS降至200 TPS,平均响应时间从50ms上升至300ms。</p>
<p><strong>问题分析:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 问题代码:整个方法加锁,锁粒度过大</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderQueryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;

    <span class="hljs-comment">// 问题:synchronized锁住整个方法,包括数据库查询和缓存操作</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> OrderDTO <span class="hljs-title function_">getOrderDetail</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-comment">// 1. 查询缓存(约50ms)</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">"order:"</span> + orderId;
        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> (OrderDTO) redisTemplate.opsForValue().get(cacheKey);
        <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> cached;
        }

        <span class="hljs-comment">// 2. 查询数据库(约100ms)</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
        <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 3. 转换DTO(约10ms)</span>
        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> convertToDTO(order);

        <span class="hljs-comment">// 4. 写入缓存(约50ms)</span>
        redisTemplate.opsForValue().set(cacheKey, dto, <span class="hljs-number">10</span>, TimeUnit.MINUTES);

        <span class="hljs-keyword">return</span> dto;
    }

    <span class="hljs-keyword">private</span> OrderDTO <span class="hljs-title function_">convertToDTO</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-comment">// 转换逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
    }
}
</code></pre>
<p><strong>性能瓶颈分析:</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">高并发场景(100个线程同时查询):</span>

┌─────────────────────────────────────────────────┐
│         synchronized方法串行执行                  │
└─────────────────────────────────────────────────┘

<span class="hljs-section">Thread-1: [查缓存|查DB|转换|写缓存] ───► 210ms</span>
                                        │
<span class="hljs-section">Thread-2:                [查缓存|查DB|转换|写缓存] ───► 420ms (等待210ms)</span>
                                                       │
<span class="hljs-section">Thread-3:                               [查缓存|查DB|转换|写缓存] ───► 630ms (等待420ms)</span>
                                                                      │
<span class="hljs-section">Thread-100:                                                          ...  ───► 21000ms (等待20790ms)</span>

<span class="hljs-section">平均响应时间: 10500ms (完全不可接受!)</span>
<span class="hljs-section">TPS: 100 / 21s ≈ 4.76 (严重下降)</span>
</code></pre>
<p><strong>优化方案1:缩小synchronized块范围</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 优化方案1:缩小synchronized块,只保护关键代码</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderQueryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;

    <span class="hljs-comment">// 每个订单一个锁对象,避免全局锁</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Long, Object&gt; locks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">getOrderDetail</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-comment">// 1. 查询缓存(不加锁)</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">"order:"</span> + orderId;
        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> (OrderDTO) redisTemplate.opsForValue().get(cacheKey);
        <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> cached;
        }

        <span class="hljs-comment">// 2. 缓存未命中,加锁查询数据库(防止缓存击穿)</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> locks.computeIfAbsent(orderId, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());

        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-comment">// 双重检查:再次查询缓存</span>
            cached = (OrderDTO) redisTemplate.opsForValue().get(cacheKey);
            <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> cached;
            }

            <span class="hljs-comment">// 查询数据库</span>
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-comment">// 转换DTO</span>
            <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> convertToDTO(order);

            <span class="hljs-comment">// 写入缓存</span>
            redisTemplate.opsForValue().set(cacheKey, dto, <span class="hljs-number">10</span>, TimeUnit.MINUTES);

            <span class="hljs-keyword">return</span> dto;
        }
        <span class="hljs-comment">// 注意:这里可以考虑清理locks中的对象,避免内存泄漏</span>
    }

    <span class="hljs-keyword">private</span> OrderDTO <span class="hljs-title function_">convertToDTO</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
    }
}
</code></pre>
<p><strong>优化方案2:读写分离锁(ReadWriteLock)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 优化方案2:使用读写锁,允许多个读线程并发</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderQueryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;

    <span class="hljs-comment">// 读写锁:多个读线程可以并发,写线程独占</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwLock.readLock();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwLock.writeLock();

    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">getOrderDetail</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">"order:"</span> + orderId;

        <span class="hljs-comment">// 1. 读锁:查询缓存(允许多线程并发读)</span>
        readLock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> (OrderDTO) redisTemplate.opsForValue().get(cacheKey);
            <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> cached;
            }
        } <span class="hljs-keyword">finally</span> {
            readLock.unlock();
        }

        <span class="hljs-comment">// 2. 写锁:查询数据库并写入缓存(独占)</span>
        writeLock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 双重检查</span>
            <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> (OrderDTO) redisTemplate.opsForValue().get(cacheKey);
            <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> cached;
            }

            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> convertToDTO(order);
            redisTemplate.opsForValue().set(cacheKey, dto, <span class="hljs-number">10</span>, TimeUnit.MINUTES);

            <span class="hljs-keyword">return</span> dto;
        } <span class="hljs-keyword">finally</span> {
            writeLock.unlock();
        }
    }

    <span class="hljs-keyword">private</span> OrderDTO <span class="hljs-title function_">convertToDTO</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
    }
}
</code></pre>
<p><strong>优化方案3:无锁化设计(推荐)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 优化方案3:使用Guava LoadingCache,自动加载,无需手动加锁</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderQueryService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-comment">// Guava Cache:自动加载,线程安全,无需手动加锁</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadingCache&lt;Long, OrderDTO&gt; orderCache = CacheBuilder.newBuilder()
        .maximumSize(<span class="hljs-number">10000</span>)  <span class="hljs-comment">// 最多缓存10000个订单</span>
        .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES)  <span class="hljs-comment">// 10分钟过期</span>
        .build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;Long, OrderDTO&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">load</span><span class="hljs-params">(Long orderId)</span> <span class="hljs-keyword">throws</span> Exception {
                <span class="hljs-comment">// 缓存未命中时自动调用此方法</span>
                <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
                <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderNotFoundException</span>(<span class="hljs-string">"订单不存在: "</span> + orderId);
                }
                <span class="hljs-keyword">return</span> convertToDTO(order);
            }
        });

    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">getOrderDetail</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 自动处理并发加载,无需手动加锁</span>
            <span class="hljs-keyword">return</span> orderCache.get(orderId);
        } <span class="hljs-keyword">catch</span> (ExecutionException e) {
            <span class="hljs-keyword">if</span> (e.getCause() <span class="hljs-keyword">instanceof</span> OrderNotFoundException) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"查询订单失败"</span>, e);
        }
    }

    <span class="hljs-keyword">private</span> OrderDTO <span class="hljs-title function_">convertToDTO</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
    }
}
</code></pre>
<p><strong>性能提升对比:</strong></p>








































<table><thead><tr><th>方案</th><th>并发线程数</th><th>平均RT</th><th>TPS</th><th>提升幅度</th></tr></thead><tbody><tr><td>synchronized方法(原始)</td><td>100</td><td>300ms</td><td>200</td><td>-</td></tr><tr><td>缩小synchronized块</td><td>100</td><td>80ms</td><td>800</td><td>4倍</td></tr><tr><td>ReadWriteLock</td><td>100</td><td>60ms</td><td>1000</td><td>5倍</td></tr><tr><td>无锁化设计(Guava Cache)</td><td>100</td><td>50ms</td><td>1200</td><td>6倍</td></tr></tbody></table>
<h2 data-id="heading-27">五、常见问题与避坑指南</h2>
<h3 data-id="heading-28">5.1 为什么wait/notify必须在synchronized块中?</h3>
<p><strong>原因1:防止丢失唤醒(Lost Wakeup)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 错误示例:不在synchronized块中使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LostWakeup</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-comment">// 线程A:等待条件</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">if</span> (!condition) {  <span class="hljs-comment">// ← 检查条件(未加锁)</span>
            <span class="hljs-comment">// 假设此时线程切换,线程B执行notifyCondition()</span>
            lock.wait();  <span class="hljs-comment">// ← 可能永久阻塞(notify已经被调用)</span>
        }
    }

    <span class="hljs-comment">// 线程B:唤醒线程</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCondition</span><span class="hljs-params">()</span> {
        condition = <span class="hljs-literal">true</span>;
        lock.notify();  <span class="hljs-comment">// ← notify在wait()之前被调用,丢失唤醒</span>
    }
}
</code></pre>
<p><strong>时间线分析:</strong></p>
<pre><code class="hljs language-scss" lang="scss">时间 | 线程<span class="hljs-selector-tag">A</span> | 线程<span class="hljs-selector-tag">B</span>
-----|-------|-------
T1   | if (!condition)  <span class="hljs-comment">// false,准备wait() |</span>
T2   |                  | condition = true; <span class="hljs-built_in">notify</span>(); ← notify先执行
T3   | lock<span class="hljs-selector-class">.wait</span>();  ← 永久阻塞(notify已丢失) |
</code></pre>
<p><strong>原因2:保证原子性</strong></p>
<p>wait/notify通常伴随共享变量的判断和修改,需要同步保护。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 正确示例:在synchronized块中使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorrectWaitNotify</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitForCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {  <span class="hljs-comment">// ← 先获取锁</span>
            <span class="hljs-keyword">while</span> (!condition) {  <span class="hljs-comment">// ← 原子性检查条件</span>
                lock.wait();  <span class="hljs-comment">// ← 释放锁,等待通知</span>
            }
            <span class="hljs-comment">// 被唤醒后,重新持有锁,继续执行</span>
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCondition</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {  <span class="hljs-comment">// ← 先获取锁</span>
            condition = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// ← 原子性修改条件</span>
            lock.notifyAll();  <span class="hljs-comment">// ← 唤醒等待线程</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-29">5.2 synchronized锁的是什么?</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTarget</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">staticLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-comment">// 1. synchronized修饰普通方法:锁的是this对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 等价于: synchronized (this) { ... }</span>
    }

    <span class="hljs-comment">// 2. synchronized修饰静态方法:锁的是Class对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 等价于: synchronized (SynchronizedTarget.class) { ... }</span>
    }

    <span class="hljs-comment">// 3. synchronized(this):锁的是当前实例对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// 与method1()竞争同一把锁</span>
        }
    }

    <span class="hljs-comment">// 4. synchronized(lock):锁的是lock对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-comment">// 独立的锁,不与其他方法竞争</span>
        }
    }

    <span class="hljs-comment">// 5. synchronized(Class对象):锁的是类锁</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method5</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (SynchronizedTarget.class) {
            <span class="hljs-comment">// 与method2()竞争同一把锁</span>
        }
    }
}
</code></pre>
<p><strong>注意事项:</strong></p>
<ul>
<li><strong>不同实例的synchronized方法不互斥</strong>:每个实例有自己的锁(this)</li>
<li><strong>静态synchronized方法与普通synchronized方法不互斥</strong>:锁的是不同对象(Class vs this)</li>
<li><strong>String、Integer等常量池对象不要作为锁</strong>:可能被多个地方共享,导致意外的锁竞争</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 错误:使用String作为锁</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringLockProblem</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-string">"LOCK"</span>;  <span class="hljs-comment">// ← 字符串常量,可能被其他代码共享</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {  <span class="hljs-comment">// ← 可能与其他使用"LOCK"字符串的代码竞争同一把锁</span>
            <span class="hljs-comment">// ...</span>
        }
    }
}

<span class="hljs-comment">// ✅ 正确:使用new Object()作为锁</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectLockCorrect</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// ← 独立的锁对象</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (lock) {
            <span class="hljs-comment">// ...</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-30">5.3 volatile能保证原子性吗?为什么i++不安全?</h3>
<p><strong>答案:volatile不能保证原子性。</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileNotAtomic</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
        count++;  <span class="hljs-comment">// ❌ 不是原子操作!</span>
    }
}
</code></pre>
<p><strong>count++的字节码分析:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">count++实际分为<span class="hljs-number">3</span>个步骤:

<span class="hljs-number">1.</span> LOAD:   从主内存读取count的值到工作内存  (读操作)
<span class="hljs-number">2.</span> ADD:    工作内存中count值+<span class="hljs-number">1</span>              (计算操作)
<span class="hljs-number">3.</span> STORE:  将新值写回主内存                 (写操作)

字节码:
  getstatic     count    <span class="hljs-comment">// 读取count</span>
  iconst_1               <span class="hljs-comment">// 加载常量1</span>
  iadd                   <span class="hljs-comment">// 相加</span>
  putstatic     count    <span class="hljs-comment">// 写回count</span>
</code></pre>
<p><strong>并发问题场景:</strong></p>
<pre><code class="hljs language-ini" lang="ini">初始: <span class="hljs-attr">count</span> = <span class="hljs-number">0</span>

时间线:
T1: 线程A读取<span class="hljs-attr">count</span>=<span class="hljs-number">0</span>              (LOAD)
T2: 线程B读取<span class="hljs-attr">count</span>=<span class="hljs-number">0</span>              (LOAD)
T3: 线程A计算0+<span class="hljs-attr">1</span>=<span class="hljs-number">1</span>                (ADD)
T4: 线程B计算0+<span class="hljs-attr">1</span>=<span class="hljs-number">1</span>                (ADD)
T5: 线程A写回<span class="hljs-attr">count</span>=<span class="hljs-number">1</span>              (STORE)
T6: 线程B写回<span class="hljs-attr">count</span>=<span class="hljs-number">1</span>              (STORE)  ← 覆盖了线程A的结果

预期结果: <span class="hljs-attr">count</span> = <span class="hljs-number">2</span>
实际结果: <span class="hljs-attr">count</span> = <span class="hljs-number">1</span>  ← 丢失了一次更新!
</code></pre>
<p><strong>volatile只保证了每次读写的可见性,但无法保证多步操作的原子性。</strong></p>
<p><strong>正确做法:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 方案1:使用synchronized</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
    count++;
}

<span class="hljs-comment">// 方案2:使用AtomicInteger</span>
<span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
    count.incrementAndGet();  <span class="hljs-comment">// CAS原子操作</span>
}
</code></pre>
<h3 data-id="heading-31">5.4 什么时候用synchronized,什么时候用volatile?</h3>








































<table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>简单状态标志</td><td>volatile</td><td>只需要可见性,无复合操作</td></tr><tr><td>一次性安全发布(DCL单例)</td><td>volatile</td><td>防止指令重排序</td></tr><tr><td>计数器(i++)</td><td>synchronized / AtomicInteger</td><td>需要原子性</td></tr><tr><td>复合操作(check-then-act)</td><td>synchronized</td><td>需要原子性和可见性</td></tr><tr><td>临界区保护</td><td>synchronized</td><td>需要互斥访问</td></tr><tr><td>长时间持锁</td><td>Lock</td><td>支持超时、中断、公平锁</td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 适合volatile的场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileSuitable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shutdownRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> {
        shutdownRequested = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 简单赋值,无复合操作</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">while</span> (!shutdownRequested) {  <span class="hljs-comment">// 只读取,不修改</span>
            <span class="hljs-comment">// ...</span>
        }
    }
}

<span class="hljs-comment">// ❌ 不适合volatile的场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileNotSuitable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
        count++;  <span class="hljs-comment">// ❌ 复合操作,volatile无法保证原子性</span>
    }

    <span class="hljs-comment">// ✅ 应该使用synchronized</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCorrect</span><span class="hljs-params">()</span> {
        count++;
    }
}
</code></pre>
<h3 data-id="heading-32">5.5 Thread.sleep()和Object.wait()的区别</h3>



































<table><thead><tr><th>特性</th><th>Thread.sleep()</th><th>Object.wait()</th></tr></thead><tbody><tr><td>所属类</td><td>Thread类(静态方法)</td><td>Object类(实例方法)</td></tr><tr><td>是否释放锁</td><td>❌ 不释放</td><td>✅ 释放</td></tr><tr><td>是否需要在synchronized中</td><td>❌ 不需要</td><td>✅ 必须</td></tr><tr><td>唤醒方式</td><td>时间到自动唤醒</td><td>notify/notifyAll唤醒或超时</td></tr><tr><td>使用场景</td><td>暂停执行一段时间</td><td>线程间协作,等待条件满足</td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepVsWait</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            System.out.println(<span class="hljs-string">"持有锁,准备sleep"</span>);
            Thread.sleep(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// ← 不释放锁,持有2秒</span>
            System.out.println(<span class="hljs-string">"sleep结束,仍持有锁"</span>);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">synchronized</span> (lock) {
            System.out.println(<span class="hljs-string">"持有锁,准备wait"</span>);
            lock.wait();  <span class="hljs-comment">// ← 释放锁,等待被唤醒</span>
            System.out.println(<span class="hljs-string">"被唤醒,重新获得锁"</span>);
        }
    }
}
</code></pre>
<h3 data-id="heading-33">5.6 如何优雅地停止一个线程?</h3>
<p><strong>❌ 错误方式:使用stop()方法(已废弃)</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
    <span class="hljs-comment">// ...</span>
});
thread.start();
thread.stop();  <span class="hljs-comment">// ❌ 已废弃,不安全!会导致数据不一致</span>
</code></pre>
<p><strong>✅ 正确方式1:使用volatile标志位</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThreadWithFlag</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stopRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-keyword">while</span> (!stopRequested) {
                <span class="hljs-comment">// 执行任务</span>
            }
            System.out.println(<span class="hljs-string">"线程优雅停止"</span>);
        }).start();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
        stopRequested = <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p><strong>✅ 正确方式2:使用interrupt()中断</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThreadWithInterrupt</span> {
    <span class="hljs-keyword">private</span> Thread thread;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> {
        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) {
                    <span class="hljs-comment">// 执行任务</span>
                    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 响应中断</span>
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                <span class="hljs-comment">// 捕获中断异常,执行清理工作</span>
                System.out.println(<span class="hljs-string">"线程被中断"</span>);
            }
            System.out.println(<span class="hljs-string">"线程优雅停止"</span>);
        });
        thread.start();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) {
            thread.interrupt();  <span class="hljs-comment">// 发送中断信号</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-34">5.7 synchronized方法和synchronized(this)的区别?</h3>
<p><strong>答案:没有本质区别,synchronized方法是synchronized(this)的语法糖。</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedMethodVsBlock</span> {
    <span class="hljs-comment">// 方式1:synchronized方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// 方式2:synchronized(this)代码块</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// ...</span>
        }
    }

    <span class="hljs-comment">// 两者等价,锁的都是this对象</span>
}
</code></pre>
<p><strong>区别:</strong></p>
<ul>
<li><strong>锁粒度</strong>: synchronized方法锁整个方法,synchronized块可以只锁部分代码</li>
<li><strong>灵活性</strong>: synchronized块可以选择锁对象,synchronized方法固定锁this</li>
</ul>
<p><strong>推荐使用synchronized块</strong>:锁粒度更小,性能更好。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ✅ 推荐:缩小锁范围</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 不需要同步的代码(如参数校验)</span>
    <span class="hljs-keyword">if</span> (param == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();
    }

    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
        <span class="hljs-comment">// 只锁必要的代码</span>
    }

    <span class="hljs-comment">// 不需要同步的代码(如日志记录)</span>
}
</code></pre>
<h3 data-id="heading-35">5.8 静态synchronized方法锁的是什么?</h3>
<p><strong>答案:锁的是Class对象,即类锁。</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticSynchronizedMethod</span> {
    <span class="hljs-comment">// 静态synchronized方法:锁的是StaticSynchronizedMethod.class</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 等价于: synchronized (StaticSynchronizedMethod.class) { ... }</span>
    }

    <span class="hljs-comment">// 等价写法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethodEquivalent</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">synchronized</span> (StaticSynchronizedMethod.class) {
            <span class="hljs-comment">// ...</span>
        }
    }
}
</code></pre>
<p><strong>类锁 vs 对象锁:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLockVsObjectLock</span> {
    <span class="hljs-comment">// 类锁(所有实例共享)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"类锁"</span>);
    }

    <span class="hljs-comment">// 对象锁(每个实例独立)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceMethod</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"对象锁"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ClassLockVsObjectLock</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLockVsObjectLock</span>();
        <span class="hljs-type">ClassLockVsObjectLock</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLockVsObjectLock</span>();

        <span class="hljs-comment">// 场景1:两个线程调用不同实例的instanceMethod()</span>
        <span class="hljs-comment">// 结果:不互斥(不同对象锁)</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(obj1::instanceMethod).start();
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(obj2::instanceMethod).start();

        <span class="hljs-comment">// 场景2:两个线程调用staticMethod()</span>
        <span class="hljs-comment">// 结果:互斥(同一个类锁)</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ClassLockVsObjectLock::staticMethod).start();
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ClassLockVsObjectLock::staticMethod).start();

        <span class="hljs-comment">// 场景3:一个线程调用staticMethod(),另一个调用instanceMethod()</span>
        <span class="hljs-comment">// 结果:不互斥(不同的锁)</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ClassLockVsObjectLock::staticMethod).start();
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(obj1::instanceMethod).start();
    }
}
</code></pre>
<h2 data-id="heading-36">六、最佳实践与总结</h2>
<h3 data-id="heading-37">6.1 并发编程三大特性保证</h3>

































<table><thead><tr><th>特性</th><th>synchronized</th><th>volatile</th><th>Lock</th><th>Atomic类</th></tr></thead><tbody><tr><td>原子性</td><td>✅</td><td>❌ (单次读写是原子的)</td><td>✅</td><td>✅</td></tr><tr><td>可见性</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>有序性</td><td>✅</td><td>✅ (禁止重排序)</td><td>✅</td><td>✅</td></tr></tbody></table>
<p><strong>保证方式:</strong></p>
<ol>
<li><strong>原子性</strong>: synchronized、Lock、Atomic类的CAS操作</li>
<li><strong>可见性</strong>: volatile、synchronized(unlock时刷新主内存)、Lock、final</li>
<li><strong>有序性</strong>: volatile(内存屏障)、synchronized(串行执行)、happens-before规则</li>
</ol>
<h3 data-id="heading-38">6.2 synchronized vs Lock选择指南</h3>
<pre><code class="hljs language-arduino" lang="arduino">选择<span class="hljs-keyword">synchronized</span>的场景:
├─ 简单的同步需求(如简单的计数器)
├─ 不需要高级特性(超时、中断、公平锁)
├─ JDK <span class="hljs-number">1.6</span>+版本(<span class="hljs-keyword">synchronized</span>已优化,性能接近Lock)
└─ 代码简洁性优先

选择Lock的场景:
├─ 需要尝试非阻塞获取锁(tryLock)
├─ 需要可中断获取锁(lockInterruptibly)
├─ 需要超时获取锁(<span class="hljs-built_in">tryLock</span>(timeout))
├─ 需要公平锁(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ReentrantLock</span>(<span class="hljs-literal">true</span>))
├─ 需要读写分离(ReadWriteLock)
├─ 需要Condition多条件等待
└─ 需要更灵活的锁控制
</code></pre>
<p><strong>示例对比:</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 场景1:简单同步 → 使用synchronized</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCounter</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
        count++;
    }
}

<span class="hljs-comment">// 场景2:需要超时获取锁 → 使用Lock</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeoutLock</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryOperation</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 执行操作</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">finally</span> {
                    lock.unlock();
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 超时,放弃操作</span>
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<h3 data-id="heading-39">6.3 线程安全的设计原则</h3>
<ol>
<li><strong>不可变对象优先</strong>: 使用final、不可变集合(Collections.unmodifiableXxx)</li>
<li><strong>最小化锁范围</strong>: 只锁必要的代码,减少持锁时间</li>
<li><strong>避免嵌套锁</strong>: 减少死锁风险,使用单锁或无锁设计</li>
<li><strong>使用并发工具类</strong>: ConcurrentHashMap、AtomicInteger等,避免显式加锁</li>
<li><strong>线程封闭</strong>: ThreadLocal、栈封闭,避免共享变量</li>
<li><strong>无状态设计</strong>: Stateless服务,天然线程安全</li>
</ol>
<h3 data-id="heading-40">6.4 高性能并发编程建议</h3>
<ol>
<li>
<p><strong>减少锁竞争:</strong></p>
<ul>
<li>缩小锁粒度(细粒度锁、分段锁)</li>
<li>减少持锁时间</li>
<li>使用读写锁(ReadWriteLock)</li>
<li>使用无锁算法(CAS)</li>
</ul>
</li>
<li>
<p><strong>避免伪共享(False Sharing):</strong></p>
<ul>
<li>使用@Contended注解(JDK 8+)</li>
<li>手动填充缓存行</li>
</ul>
</li>
<li>
<p><strong>合理使用线程池:</strong></p>
<ul>
<li>避免频繁创建销毁线程</li>
<li>根据任务特性选择线程池类型(CPU密集型 vs IO密集型)</li>
<li>设置合理的队列大小和拒绝策略</li>
</ul>
</li>
<li>
<p><strong>异步化设计:</strong></p>
<ul>
<li>使用CompletableFuture、异步消息队列</li>
<li>解耦同步调用,提高吞吐量</li>
</ul>
</li>
</ol>
<h3 data-id="heading-41">6.5 代码审查Checklist</h3>
<p>并发编程代码审查时,重点检查以下几点:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 共享变量是否正确同步(synchronized、volatile、Lock)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否存在竞态条件(check-then-act、read-modify-write)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否正确使用wait/notify(在synchronized块中、使用while循环)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否存在死锁风险(嵌套锁、锁顺序不一致)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> synchronized/Lock是否正确释放(使用finally块)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> volatile是否被误用(复合操作应使用synchronized)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 线程停止是否优雅(使用标志位或interrupt,不使用stop)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否使用了线程安全的集合类(ConcurrentHashMap vs HashMap)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否考虑了可见性、原子性、有序性三大特性</li>
</ul>
<h3 data-id="heading-42">6.6 总结</h3>
<p>Java并发编程是一个复杂但必须掌握的领域。本文从线程基础出发,深入剖析了synchronized和volatile的底层原理,结合电商业务场景展示了实战应用,并通过生产案例分析了死锁和性能问题的排查方法。</p>
<p><strong>核心要点:</strong></p>
<ol>
<li><strong>synchronized是Java内置的互斥锁</strong>,JDK 1.6后引入了锁升级机制(偏向锁→轻量级锁→重量级锁),性能大幅提升</li>
<li><strong>volatile保证可见性和有序性</strong>,但不保证原子性,适用于状态标志和一次性安全发布</li>
<li><strong>wait/notify必须在synchronized块中使用</strong>,防止丢失唤醒和保证原子性</li>
<li><strong>线程安全的三大特性</strong>(原子性、可见性、有序性)是并发编程的核心</li>
<li><strong>锁粒度优化</strong>是提升并发性能的关键,缩小锁范围、使用读写锁、无锁化设计</li>
<li><strong>死锁的预防</strong>:避免嵌套锁、统一锁顺序、使用tryLock超时机制</li>
</ol>
<p>在实际开发中,应根据业务场景选择合适的并发控制手段,遵循最佳实践,编写高性能、线程安全的代码。并发编程没有银弹,需要在正确性、性能、复杂度之间找到平衡点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[webpack迁移rsbuild——配置深度对比]]></title>    <link>https://juejin.cn/post/7585139951345909811</link>    <guid>https://juejin.cn/post/7585139951345909811</guid>    <pubDate>2025-12-19T08:17:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585139951345909811" data-draft-id="7584711683773284352" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="webpack迁移rsbuild——配置深度对比"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T08:17:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="布列瑟农的星空"/> <meta itemprop="url" content="https://juejin.cn/user/976022056218471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            webpack迁移rsbuild——配置深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976022056218471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    布列瑟农的星空
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:17:37.000Z" title="Fri Dec 19 2025 08:17:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">综合对比</h2>
<p>webpack项目整体上可以无痛迁移到rsbuild，其中rspack对标webpack，swc对标babel和terser，这些对标不仅是从能力上对标，更是参考了目标的大量配置api设计，因此绝大多数重要能力的配置api都可以沿用webpack的，迁移过程中几乎不需要关注能力/特性丢失问题，体验极佳。</p>
<h2 data-id="heading-1">编译</h2>
<h3 data-id="heading-2">js(x)/ts(x)编译</h3>
<p>webapck大多基于babel，rsbuild基于swc，swc的配置也对标了babel常用的preset和plugin,如@babel/preset-react，不过也缺失了一些细节优化插件，如@babel/plugin-proposal-class-properties。</p>
<p>rsbuild提供了常用的配置插件，默认值的设置也比较贴近实践，使用更为简单，比如对react的编译：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { pluginReact } <span class="hljs-keyword">from</span> <span class="hljs-string">'@rsbuild/plugin-react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">pluginReact</span>()],
};
</code></pre>
<p>如果确实需要使用部分babel插件，比如项目中可能有自定义的ast处理脚本，rsbuild也提供了接入方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { pluginBabel } <span class="hljs-keyword">from</span> <span class="hljs-string">'@rsbuild/plugin-babel'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">pluginBabel</span>()],
};
</code></pre>
<p>需要注意的是，该插件并不是将swc切换为babel，而是在swc的基础上额外执行babel转义，因此会增加编译时间。</p>
<h3 data-id="heading-3">ts装饰器</h3>
<p>Rsbuild 不会读取 <code>tsconfig.json</code> 中的 <code>experimentalDecorators</code> 选项，而是提供了 <a href="https://link.juejin.cn?target=https%3A%2F%2Frsbuild.rs%2Fzh%2Fconfig%2Fsource%2Fdecorators%23decoratorsversion" target="_blank" title="https://rsbuild.rs/zh/config/source/decorators#decoratorsversion" ref="nofollow noopener noreferrer">decorators.version</a> 配置项来指定装饰器版本</p>
<pre><code class="hljs language-css" lang="css">export default {
    source: { 
        decorators: { 
            version: <span class="hljs-string">'legacy'</span>, 
        }, 
    }, 
};
</code></pre>
<p>另外swc明确支持ts的decoratorMetadata，迁移的时候可以不用担心装饰器被破坏。</p>
<h2 data-id="heading-4">样式</h2>
<h3 data-id="heading-5">less/sass</h3>
<p>webpack的less-loader,sass-loader对应@rsbuild/plugin-less和@rsbuild/plugin-sass,配置的不同点在于webpack通过module.rules[].test匹配,而rsbuild通过插件本身的include和exclude</p>
<h3 data-id="heading-6">css modules</h3>
<p>不管是规范还是多数实践，项目中一般都会对css module文件名中增加module标记，比如*.module.less。rsbuild也是根据该规范判断样式文件是否启用css modules。但webpack更灵活，可以任意设置该文件是否启用css modules:</p>
<pre><code class="hljs language-javascript" lang="javascript"> {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.module\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-string">'style-loader'</span>, <span class="hljs-comment">// 或 mini-css-extract-plugin.loader</span>
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">modules</span>: {
                <span class="hljs-attr">mode</span>: <span class="hljs-string">'local'</span>, <span class="hljs-comment">// 局部作用域（默认）</span>
                <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">'[name]__[local]--[hash:base64:5]'</span>, <span class="hljs-comment">// 类名生成规则</span>
                <span class="hljs-attr">exportLocalsConvention</span>: <span class="hljs-string">'camelCase'</span>, <span class="hljs-comment">// 导出驼峰命名（如 .btn-primary → btnPrimary）</span>
              },
            },
          },
        ],
      },
</code></pre>
<p>因此如果迁移rsbuild，建议对不符合css modules命名规范的文件重新命名。
当然rsbuild也可以对任意文件设置是否启用css modules
在默认情况下，只有 <code>*.module.css</code> 结尾的文件才被视为 CSS Modules 模块。</p>
<blockquote>
<p>如果你想将其他 CSS 文件也当做 CSS Modules 模块进行处理，可以通过配置 <a href="https://link.juejin.cn?target=https%3A%2F%2Frsbuild.rs%2Fzh%2Fconfig%2Foutput%2Fcss-modules%23cssmodulesauto" target="_blank" title="https://rsbuild.rs/zh/config/output/css-modules#cssmodulesauto" ref="nofollow noopener noreferrer">output.cssModules.auto</a> 来实现。</p>
<p>比如：</p>
</blockquote>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">cssModules</span>: {
      <span class="hljs-attr">auto</span>: <span class="hljs-function">(<span class="hljs-params">resource</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> resource.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'.module.'</span>) || resource.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'shared/'</span>);
      },
    },
  },
};
</code></pre>
<p>设置后，以下两个文件都会被视为 CSS Modules：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> styles1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo.module.css'</span>;
<span class="hljs-keyword">import</span> styles2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./shared/bar.css'</span>;
</code></pre>
<p>但个人并不推荐该方式。</p>
<h3 data-id="heading-7">postcss和tailwind</h3>
<p>rsbuild的tools.postcss对标webpack的postcss-loader，对tailwind的配置也通过postcss。不过其内置的Lightning CSS覆盖了postcss一些插件，比如autoprefixer。</p>
<h2 data-id="heading-8">压缩</h2>
<h3 data-id="heading-9">SWC vs Terser</h3>
<p>SWC的压缩配置对标Terser，Terser有的SWC几乎都有，可以无脑切换。</p>
<h3 data-id="heading-10">css-minimizer-webpack-plugin和Lightning CSS的压缩</h3>
<p>css-minimizer-webpack-plugin可以设置压缩工具为cssnano（默认）、Lightning CSS、csso，rsbuild仅支持Lightning CSS（当前主流）。Lightning CSS相当于cssnano（压缩）+ autoprefixer（前缀）+ postcss-preset-env（语法降级）</p>
<h2 data-id="heading-11">其他重要插件</h2>
<h3 data-id="heading-12">svgr</h3>

















<table><thead><tr><th/><th>webpack</th><th>rsbuild</th><th>重要区别</th></tr></thead><tbody><tr><td>插件</td><td>@svgr/webpack</td><td>@rsbuild/plugin-svgr</td><td>混合导入</td></tr></tbody></table>
<p>webpack支持混合导入，svg可以当成path或一个React组件</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> starUrl, { <span class="hljs-title class_">ReactComponent</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Star</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./star.svg'</span>


<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{starUrl}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"star"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Star</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
)
</code></pre>
<p>@rsbuild/plugin-svgr开启具名导入后，需要额外开启混合导入，否则无法当成path处理。虽然该插件支持混合导入，但推荐的写法如下</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Logo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./logo.svg?react'</span>; 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span></span>;
</code></pre>
<blockquote>
<p>建议优先使用 <code>?react</code> 来将 SVG 转换为 React 组件，而不是使用混合导入。因为混合导入有如下局限性：</p>
<ol>
<li>包体积增加：混合导入会导致单个 SVG 模块被编译为两种代码（即使部分导出没有被使用），这会增加产物的包体积。</li>
<li>编译速度下降：混合导入会产生额外的编译开销。即使代码中未使用到 ReactComponent 导出，SVG 文件仍然会被 SVGR 编译。而 SVGR 是基于 Babel 实现的，性能开销较大。</li>
</ol>
</blockquote>
<h3 data-id="heading-13">code-inspector-plugin</h3>

















<table><thead><tr><th/><th>webpack</th><th>rsbuild</th><th>重要区别</th></tr></thead><tbody><tr><td>插件</td><td>code-inspector-plugin</td><td>code-inspector-plugin</td><td>配置方式</td></tr></tbody></table>
<p>webpack和rspack的配置方式类似</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> { codeInspectorPlugin } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'code-inspector-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">() =&gt;</span> ({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">codeInspectorPlugin</span>({
      <span class="hljs-attr">bundler</span>: <span class="hljs-string">'webpack'</span>,
    }),
  ],
});
<span class="hljs-comment">// rspack.config.js</span>
<span class="hljs-keyword">const</span> { codeInspectorPlugin } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'code-inspector-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// other config...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">codeInspectorPlugin</span>({
      <span class="hljs-attr">bundler</span>: <span class="hljs-string">'rspack'</span>,
    }),
    <span class="hljs-comment">// other plugins...</span>
  ],
};
</code></pre>
<p>但rsbuild的配置略有不同——rsbuild的plugin并不是rspack的plugin</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// rsbuild.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'@rsbuild/core'</span>;
<span class="hljs-keyword">import</span> { codeInspectorPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'code-inspector-plugin'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-comment">// ...other config</span>
  <span class="hljs-attr">tools</span>: {
    <span class="hljs-attr">rspack</span>: {
      <span class="hljs-attr">plugins</span>: [
        <span class="hljs-title function_">codeInspectorPlugin</span>({
          <span class="hljs-attr">bundler</span>: <span class="hljs-string">'rspack'</span>,
        }),
      ],
    },
  },
});
</code></pre>
<h2 data-id="heading-14">rsbuild vs vite 重要特性横向对比</h2>
<h3 data-id="heading-15">按需编译</h3>
<p>vite的按需编译依赖浏览器的esm加载机制，而rsbuild的按需编译（Lazy compilation），依赖于拆包，即只编译入口，动态import引入文件按需编译。如果问开发服务器启动时间，那肯定是vite更快，但要问开发环境页面加载时间，大型项目可能rsbuild更快。</p>
<h3 data-id="heading-16">热更新</h3>
<p>rsbuild的热更新还是chunk粒度，而vite是文件粒度，速度上来说vite更快，但实际体验差距不大。</p>
<h3 data-id="heading-17">兼容性</h3>
<p>如果都是从webpack升级，相比vite，显然rsbuild更安全，除了插件的兼容，更关键的是编译兼容。</p>
<p>swc的语法降级，对标babel的@babel/preset-env，支持按需引入polyfill(类似useBuiltIns: 'usage')；同时swc也可以安全地编译ts的元数据和装饰器；压缩上对标Terser，几乎可以无缝迁移相关配置。这三点超越了esbuild。</p>
<h3 data-id="heading-18">webpack特性丢失问题</h3>
<p>rsbuild几乎没有特性丢失的问题，比如模块联邦，splitChuks均能与webpack保持一致，而vite由于内置打包是rollup，这两个特性支持并不好。</p>
<h2 data-id="heading-19">结论</h2>
<p>纯个人意见，充满主观判断：rsbuild相比webpack全面超越，相比vite，无论是兼容性还是开发/配置体验都更好。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度驱动：React Hooks 核心之 `useState` 与 `useEffect` 实战详解]]></title>    <link>https://juejin.cn/post/7585206549305507903</link>    <guid>https://juejin.cn/post/7585206549305507903</guid>    <pubDate>2025-12-19T07:51:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206549305507903" data-draft-id="7585091990347661348" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度驱动：React Hooks 核心之 `useState` 与 `useEffect` 实战详解"/> <meta itemprop="keywords" content="React.js,响应式编程,JavaScript"/> <meta itemprop="datePublished" content="2025-12-19T07:51:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="San30"/> <meta itemprop="url" content="https://juejin.cn/user/1766294768060816"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度驱动：React Hooks 核心之 `useState` 与 `useEffect` 实战详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1766294768060816/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    San30
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:51:01.000Z" title="Fri Dec 19 2025 07:51:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>在 React 的函数组件世界里，Hooks 是灵魂所在。正如你的 <code>readme.md</code> 中所言，“以 <code>use</code> 开头的函数，都是 React 提供的 Hooks，用于在函数组件中使用状态和其他 React 功能。”其中，<code>useState</code> 解决了“数据如何驱动视图”的问题，而 <code>useEffect</code> 则解决了“如何处理纯函数之外的副作用”的问题。</p>
<h2 data-id="heading-0">第一部分：useState——赋予组件“记忆”的能力</h2>
<h3 data-id="heading-1">1. 响应式状态的本质</h3>
<p>在 React 之前，普通变量（如 <code>let count = 0</code>）的变化无法触发 UI 的重新渲染。<code>useState</code> 的出现，为程序员带来了<strong>关键的响应式状态</strong>，<strong>状态就是变化的数据，组件的核心是状态。</strong></p>
<p>最典型的定义方式：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
</code></pre>
<ul>
<li><strong>数组解构</strong>：<code>useState</code> 返回一个长度为 2 的数组。第一项是当前状态的值，第二项是更新该状态的函数。</li>
<li><strong>确定性</strong>：初始化时，状态必须是确定的，肯定的。</li>
</ul>
<h3 data-id="heading-2">2. 惰性初始化（Lazy Initialization）</h3>
<p>当你需要通过复杂计算来确定初始值时，可以向 <code>useState</code> 传入一个<strong>纯函数</strong>：</p>
<p>什么是纯函数？</p>
<p>纯函数是指对于相同的输入始终返回相同输出，且没有副作用（如修改外部状态或依赖外部可变数据）的函数。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> num2 = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;
  <span class="hljs-keyword">return</span> num1 + num2;
});
</code></pre>
<p>为什么要用函数？</p>
<p>如果初始值计算开销很大（比如读取本地缓存、循环计算），直接写在 useState(expensive()) 中会导致每次组件重新渲染时都执行该计算。而传入函数，React 只会在组件初次挂载时执行它一次。</p>
<p>注意，这个函数必须是同步的，不支持异步的，异步的初始会带来不确定性，而状态必须是可预测且确定的。</p>
<h3 data-id="heading-3">3. 更新函数的两种姿势</h3>
<p>更新状态的两种逻辑：</p>
<ol>
<li><strong>直接传递新值</strong>：<code>setCount(count + 1)</code>。</li>
<li><strong>传递更新函数</strong>：<code>setNum(prevNum =&gt; prevNum + 1)</code>。</li>
</ol>
<p>核心区别：</p>
<p>使用 <code>prevNum =&gt; prevNum + 1</code> 是为了安全地基于上一次的值更新。由于 React 的状态更新可能是异步的，或者在闭包环境中，直接引用 count 可能会拿到旧值。使用回调函数形式可以确保你拿到的 prevNum 永远是内存中最新的状态。</p>
<h2 data-id="heading-4">第二部分：useEffect——掌控副作用的艺术</h2>
<h3 data-id="heading-5">1. 什么是副作用（Side Effect）？</h3>
<p>副作用的对立面就是纯函数。</p>
<ul>
<li><strong>纯函数</strong>：相同输入永远得到相同输出，无副作用。</li>
<li><strong>副作用</strong>：指那些不直接参与 UI 计算的操作，如网络请求、手动修改 DOM、设置定时器、记录日志等。</li>
</ul>
<p><code>useEffect</code> 的设计初衷，就是为这些“不纯”的操作提供一个安全的避风港。</p>
<h3 data-id="heading-6">2. 依赖项数组（Dependency Array）的奥秘</h3>
<p><code>useEffect</code> 的第二个参数决定了副作用何时运行，这是初学者最容易困惑的地方：</p>

























<table><thead><tr><th><strong>依赖参数</strong></th><th><strong>执行时机</strong></th><th><strong>对应生命周期</strong></th></tr></thead><tbody><tr><td><strong>不传</strong></td><td>每次组件渲染（render）后都执行</td><td>持续更新</td></tr><tr><td><strong>空数组 <code>[]</code></strong></td><td>仅在组件挂载（Mount）后执行一次</td><td><code>onMounted</code></td></tr><tr><td><strong>有值 <code>[num]</code></strong></td><td>挂载后执行，且当 <code>num</code> 变化时重新执行</td><td><code>onUpdated</code></td></tr></tbody></table>
<h3 data-id="heading-7">3. 清理函数（Cleanup）：防止内存泄漏</h3>
<p>这是 <code>App.jsx</code> 和 <code>Demo.jsx</code> 中最精彩的部分。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); }, <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 清理函数</span>
    }
}, [num]);
</code></pre>
<p><strong>为什么要 Cleanup？</strong></p>
<ol>
<li><strong>重复创建问题</strong>：如果不清除，每次 <code>num</code> 变化都会产生一个新的定时器，旧的定时器依然在后台运行。</li>
<li><strong>内存泄漏</strong>：在 <code>Demo.jsx</code> 中，如果组件卸载了（<code>num</code> 变成奇数），但定时器没关，它会尝试操作已经不存在的逻辑，导致性能下降甚至崩溃。</li>
</ol>
<p><strong>执行时机</strong>：</p>
<ol>
<li>
<p>清理函数会在<strong>下一次副作用执行前</strong>被调用，如<code>App.jsx</code>中加的<code>[num]</code>依赖，在<code>num</code>发生改变时，副作用重新执行。</p>
</li>
<li>
<p>清理函数会在<strong>组件卸载前</strong>被调用，如<code>Demo.jsx</code>中的<code>[]</code>依赖，副作用仅在组件挂载后执行一次，但在<code>num</code>为奇数时，<code>Demo</code>子组件会卸载。</p>
</li>
</ol>
<h2 data-id="heading-8">第三部分：实战代码深度剖析</h2>
<h3 data-id="heading-9">案例 1：App.jsx 中的动态监听</h3>
<p>在 <code>App.jsx</code> 中，<code>useEffect</code> 监听了 <code>[num]</code>。当用户点击 <code>div</code> 使 <code>num</code> 增加时：</p>
<ol>
<li>
<p>React 发现 <code>num</code> 变了。</p>
</li>
<li>
<p>React 先调用上一次 Effect 返回的 <code>remove</code> 清理函数，执行 <code>clearInterval</code>。</p>
</li>
<li>
<p>React 执行新的 Effect，开启一个新的定时器，打印最新的 num。</p>
<p>这就是为什么你在控制台能看到“实时更新”的数字，且不会堆积多个定时器。</p>
</li>
</ol>
<h3 data-id="heading-10">案例 2：Demo.jsx 的挂载与卸载</h3>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'123123'</span>); <span class="hljs-comment">// 仅在 Demo 出现时打印一次</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'remove'</span>); } <span class="hljs-comment">// 仅在 Demo 消失时执行</span>
}, []);
</code></pre>
<p>在主组件中：<code>{num % 2 === 0 &amp;&amp; &lt;Demo /&gt;}</code>。</p>
<ul>
<li>当 <code>num</code> 从 0 变 1 时，条件为假，<code>Demo</code> 组件被销毁。</li>
<li>此时 React 自动触发 <code>Demo</code> 内部 <code>useEffect</code> 的 <code>return</code> 函数。</li>
<li><strong>结论</strong>：这完美模拟了 Vue 中的 <code>onMounted</code> 和 <code>onUnmounted</code>。</li>
</ul>
<h2 data-id="heading-11">第四部分：Hooks 的使用准则</h2>
<p>为了确保这些钩子正常工作，必须遵守 React 的两条金科玉律：</p>
<ol>
<li><strong>只在最顶层使用 Hooks</strong>：不要在循环、条件判断或嵌套函数中调用 Hook。这保证了每次渲染时 Hook 的调用顺序一致，React 才能正确关联状态。</li>
<li><strong>只在 React 函数中调用 Hooks</strong>：不要在普通的 JS 函数中调用，除非是你自定义的 Hook（以 <code>use</code> 开头）。</li>
</ol>
<h2 data-id="heading-12">第五部分：总结与感悟</h2>
<p><code>useState</code> 和 <code>useEffect</code> 的组合，体现了 React <strong>声明式编程</strong>的思想：</p>
<ul>
<li>你只需要声明： <strong>“当数据是这样时，界面应该长这样”</strong> （<code>useState</code>）。</li>
<li>你只需要声明： <strong>“当数据变化时，我需要同步做这些额外的事”</strong> （<code>useEffect</code>）。</li>
</ul>
<p>通过提供清理机制，React 强迫开发者思考资源的生命周期，从而编写出更健壮、无泄漏的前端应用。</p>
<h2 data-id="heading-13">第六部分：App.jsx和Demo.jsx源码</h2>
<p><strong>这个 App.jsx + Demo.jsx 应用主要做了两件事：</strong></p>
<ol>
<li>点击一个数字，让它加 1。</li>
<li>当数字是偶数时，显示一个叫  的组件；奇数时隐藏它。</li>
<li>同时，用定时器每隔 1 秒打印当前数字，并确保不会造成内存泄漏（比如旧的定时器没关掉）。</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// App.jsx</span>
<span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/Demo.jsx'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryData</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">666</span>);
        }, <span class="hljs-number">2000</span>)
    });
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
        }, <span class="hljs-number">1000</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'remove'</span>);
            <span class="hljs-built_in">clearInterval</span>(timer);
        }
    }, [num])
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(prevNum =&gt; prevNum + 1)}&gt;{num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            {num % 2 === 0 &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> /&gt;</span>}
        <span class="hljs-tag">&lt;/&gt;</span></span>
    )
}
</code></pre>
<h3 data-id="heading-14"><strong>主组件 App</strong></h3>
<p>每当<code>num</code>发生变化时，这个<code> useEffect</code> 会先清理上一次的副作用（通过<code>return</code>函数），再执行新的副作用。</p>
<p>它启动了一个每秒打印当前 num 的定时器。</p>
<p>返回的函数（return () =&gt; {...}）就是清理函数，会在下一次 useEffect 执行前，或者组件卸载时自动调用。</p>
<p>为什么需要清理？</p>
<p>如果不清理，每次 num 变化都会新建一个定时器，但旧的还在跑！
比如：num=0 时开了一个定时器，num=1 时又开一个……最后可能有 10 个定时器同时打印，造成内存泄漏或逻辑混乱。</p>
<p>所以：只要用了 setInterval、setTimeout、监听事件等，几乎都要写清理函数。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> {useEffect, useState} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'timer'</span>);
        }, <span class="hljs-number">1000</span>)
        <span class="hljs-comment">// 当 num 是偶数时，子组件还在页面上，没有卸载 React 不会执行return清理函数</span>
        <span class="hljs-comment">// 而当 num 变为奇数时，&lt;Demo /&gt; 被移除 → React 自动调用 return () =&gt; {...} → 清理定时器。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { 
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'remove'</span>);
            <span class="hljs-built_in">clearInterval</span>(timer);
        }
    }, [])
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            偶数Demo
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
}
</code></pre>
<h3 data-id="heading-15"><strong>子组件 Demo</strong></h3>
<p>useEffect(..., [])：只在组件第一次挂载时执行一次（类似 Vue 的 onMounted）。</p>
<p>当 num 变成奇数时， 被移除 → React 自动调用 return () =&gt; {...} → 清理定时器。</p>
<p>这样就避免了：组件都消失了，定时器还在后台跑！</p>
<p>这就是 React 的“生命周期”思想：挂载 onMounted → 更新 onUpdated→ 卸载 onUnmounted，而 useEffect + 清理函数 能覆盖全部阶段。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于vue3 封装的antdv/element-Plus 快速生成增删改查页面]]></title>    <link>https://juejin.cn/post/7585206349748650036</link>    <guid>https://juejin.cn/post/7585206349748650036</guid>    <pubDate>2025-12-19T08:08:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206349748650036" data-draft-id="7585222924565889064" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于vue3 封装的antdv/element-Plus 快速生成增删改查页面"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T08:08:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不知名用户来了"/> <meta itemprop="url" content="https://juejin.cn/user/3579665589475639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于vue3 封装的antdv/element-Plus 快速生成增删改查页面
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3579665589475639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不知名用户来了
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:08:28.000Z" title="Fri Dec 19 2025 08:08:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是一个基于pnpm工作空间的Vue 3组件库，包含三个主要的子包：</p>
<ul>
<li><code>@mengtr/vue3-antdv</code>：基于Ant Design Vue的组件库</li>
<li><code>@mengtr/vue3-element</code>：基于Element Plus的组件库</li>
<li><code>@mengtr/vue3-common</code>：公共的工具库和类型定义</li>
</ul>
<p><strong>npm地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fsearch%3Fq%3D%2540mengtr" target="_blank" title="https://www.npmjs.com/search?q=%40mengtr" ref="nofollow noopener noreferrer">www.npmjs.com/search?q=%4…</a></strong></p>
<p><strong>github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmengtianren%2Fmengtr" target="_blank" title="https://github.com/mengtianren/mengtr" ref="nofollow noopener noreferrer">github.com/mengtianren…</a></strong></p>
<h2 data-id="heading-0">ant-design-vue 表现</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7508bd75808403aa88ce9ea2d59a0df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN55-l5ZCN55So5oi35p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736891&amp;x-signature=cChP4A16cD9GYt9xp3Qe78BHrNc%3D" alt="antdv.png" loading="lazy"/></p>
<h2 data-id="heading-1">element-plus 表现</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/872a2e07e56645fc8f9d0671eb52e8df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN55-l5ZCN55So5oi35p2l5LqG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736891&amp;x-signature=hL%2BxG%2FsStuDtnnr%2FeuV1F0uY8js%3D" alt="element.png" loading="lazy"/></p>
<h2 data-id="heading-2">项目结构</h2>
<pre><code class="hljs language-bash" lang="bash">mengtr/
├── vue3-antdv/           <span class="hljs-comment"># 基于Ant Design Vue的组件库</span>
│   ├── src/
│   │   ├── components/   <span class="hljs-comment"># 组件目录</span>
│   │   ├── types/        <span class="hljs-comment"># 类型定义</span>
│   │   └── index.ts      <span class="hljs-comment"># 入口文件</span>
│   ├── package.json
│   └── vite.config.ts
├── vue3-element/         <span class="hljs-comment"># 基于Element Plus的组件库</span>
│   ├── src/
│   │   ├── components/   <span class="hljs-comment"># 组件目录</span>
│   │   ├── types/        <span class="hljs-comment"># 类型定义</span>
│   │   └── index.ts      <span class="hljs-comment"># 入口文件</span>
│   ├── package.json
│   └── vite.config.ts
├── vue3-common/          <span class="hljs-comment"># 公共工具库和类型定义</span>
│   ├── src/
│   │   ├── hooks/        <span class="hljs-comment"># Vue 3 Hooks</span>
│   │   ├── types/        <span class="hljs-comment"># 类型定义</span>
│   │   └── index.ts      <span class="hljs-comment"># 入口文件</span>
│   ├── package.json
│   └── vite.config.ts
├── package.json          <span class="hljs-comment"># 根项目配置</span>
└── pnpm-workspace.yaml   <span class="hljs-comment"># pnpm工作空间配置</span>
</code></pre>
<h2 data-id="heading-3">安装</h2>
<h3 data-id="heading-4">安装整个组件库</h3>
<pre><code class="hljs language-bash" lang="bash">pnpm add @mengtr/vue3-antdv @mengtr/vue3-element @mengtr/vue3-common
</code></pre>
<h3 data-id="heading-5">单独安装某个子包</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装基于Ant Design Vue的组件库</span>
pnpm add @mengtr/vue3-antdv

<span class="hljs-comment"># 安装基于Element Plus的组件库</span>
pnpm add @mengtr/vue3-element

<span class="hljs-comment"># 安装公共工具库</span>
pnpm add @mengtr/vue3-common
</code></pre>
<h2 data-id="heading-6">包说明</h2>
<h3 data-id="heading-7">1. @mengtr/vue3-common</h3>
<p>公共的工具库和类型定义，被其他两个包依赖。</p>
<h4 data-id="heading-8">导出方法</h4>



































<table><thead><tr><th>方法名</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>useTable</code></td><td>分页表格数据管理钩子</td><td>- <code>getData</code>: 数据获取函数<br/>- <code>init</code>: 是否初始化加载<br/>- <code>param</code>: 初始参数<br/>- <code>pageKey</code>: 分页参数映射</td><td><code>{ tableData, pagination, onSearch, onReset, onSetParam, search }</code></td></tr><tr><td><code>useTreeTable</code></td><td>树状表格数据管理钩子</td><td>- <code>getData</code>: 数据获取函数<br/>- <code>init</code>: 是否初始化加载<br/>- <code>param</code>: 初始参数</td><td><code>{ tableData, onSearch, onReset, onSetParam, search }</code></td></tr><tr><td><code>setTablePageKey</code></td><td>设置分页参数映射</td><td>- <code>key</code>: 包含page、size、records、total的对象</td><td><code>void</code></td></tr><tr><td><code>buildInitialFormData</code></td><td>构建表单初始数据</td><td>- <code>fields</code>: 表单字段配置<br/>- <code>data</code>: 初始数据</td><td><code>object</code></td></tr></tbody></table>
<h4 data-id="heading-9">使用示例</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { useTable, setTablePageKey } <span class="hljs-keyword">from</span> <span class="hljs-string">'@mengtr/vue3-common'</span>

<span class="hljs-comment">// 设置分页参数映射</span>
<span class="hljs-title function_">setTablePageKey</span>({
  <span class="hljs-attr">page</span>: <span class="hljs-string">'page'</span>,
  <span class="hljs-attr">size</span>: <span class="hljs-string">'pageSize'</span>,
  <span class="hljs-attr">records</span>: <span class="hljs-string">'rows'</span>,
  <span class="hljs-attr">total</span>: <span class="hljs-string">'total'</span>
})

<span class="hljs-comment">// 使用useTable钩子</span>
<span class="hljs-keyword">const</span> { tableData, pagination, onSearch, onReset } = <span class="hljs-title function_">useTable</span>(
  <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/list'</span>, { params }), <span class="hljs-comment">// 数据获取函数</span>
  <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否初始化加载</span>
  { <span class="hljs-attr">status</span>: <span class="hljs-number">1</span> } <span class="hljs-comment">// 初始参数</span>
)

<span class="hljs-comment">// 使用useTreeTable钩子</span>
<span class="hljs-keyword">const</span> { tableData, onSearch, onReset } = <span class="hljs-title function_">useTreeTable</span>(
  <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/tree'</span>, { params }), <span class="hljs-comment">// 数据获取函数</span>
  <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否初始化加载</span>
  { <span class="hljs-attr">parentId</span>: <span class="hljs-number">0</span> } <span class="hljs-comment">// 初始参数</span>
)

</code></pre>
<h3 data-id="heading-10">2. @mengtr/vue3-antdv</h3>
<p>基于Ant Design Vue的组件库，提供了一系列常用的业务组件。</p>
<h4 data-id="heading-11">导出组件</h4>













































<table><thead><tr><th>组件名</th><th>别名</th><th>描述</th></tr></thead><tbody><tr><td><code>GPage</code></td><td><code>GTablePage</code></td><td>完整的增删改查页面组件</td></tr><tr><td><code>GSearch</code></td><td>-</td><td>搜索功能组件</td></tr><tr><td><code>GTable</code></td><td>-</td><td>表格+弹窗组件</td></tr><tr><td><code>GModal</code></td><td>-</td><td>模态框组件</td></tr><tr><td><code>GForm</code></td><td>-</td><td>表单组件</td></tr><tr><td><code>GFormItem</code></td><td>-</td><td>表单字段组件（即将废弃）</td></tr><tr><td><code>BaseTable</code></td><td>-</td><td>基础表格组件</td></tr></tbody></table>
<h4 data-id="heading-12">导出方法</h4>

























<table><thead><tr><th>方法名</th><th>描述</th><th>来源</th></tr></thead><tbody><tr><td><code>useTable</code></td><td>分页表格数据管理钩子</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr><tr><td><code>useTreeTable</code></td><td>树状表格数据管理钩子</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr><tr><td><code>setTablePageKey</code></td><td>设置分页参数映射</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr></tbody></table>
<h4 data-id="heading-13">使用示例</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;!-- GPage 完整增删改查页面 --&gt;
  &lt;GPage :options="pageOptions" @export="onExport" @import="onImport" /&gt;
  
  &lt;!-- GSearch 搜索功能组件 --&gt;
  &lt;GSearch :options="searchOptions" @search="onSearch" @reset="onReset" /&gt;
  
  &lt;!-- GTable 表格+弹窗组件 --&gt;
  &lt;GTable :options="tableOptions" /&gt;
  
  &lt;!-- BaseTable 基础表格组件 --&gt;
  &lt;BaseTable :type="1" ref="tableRef" :options="baseTableOptions"&gt;
    &lt;template #bodyCell="{ column, record, text, index }"&gt;
      &lt;!-- 自定义单元格内容 --&gt;
      &lt;span v-if="column.dataIndex === 'status'"&gt;
        &lt;a-tag :color="record.status === 1 ? 'green' : 'red'"&gt;
          {{ record.status === 1 ? '启用' : '禁用' }}
        &lt;/a-tag&gt;
      &lt;/span&gt;
    &lt;/template&gt;
  &lt;/BaseTable&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { GPage, GSearch, GTable, BaseTable, useTable } from '@mengtr/vue3-antdv'
import axios from 'axios'

// GPage 配置示例
const pageOptions = {
  search: {
    searchOptions: [
      { type: 'string', label: '名称', name: 'name', span: 6 },
      { type: 'select', label: '状态', name: 'status', options: [{ value: 1, label: '启用' }, { value: 0, label: '禁用' }] }
    ],
    enableCreate: true,
    enableExport: true,
    enableImport: true
  },
  table: {
    columns: [
      { title: '名称', dataIndex: 'name', key: 'name' },
      { title: '状态', dataIndex: 'status', key: 'status' },
      { title: '操作', dataIndex: 'action', key: 'action' }
    ],
    actions: [
      { label: '编辑', key: 1 },
      { label: '详情', key: 2 },
      { label: '删除', key: 3 },
      { label: '自定义', key: 4, callback: (record) =&gt; console.log('自定义操作', record) }
    ],
    initParam: {}
  },
  modal: {
    config: { title: '编辑' },
    form: {
      config: {},
      fields: [
        { type: 'input', label: '名称', name: 'name', config: { placeholder: '请输入名称' } }
      ]
    }
  },
  API: {
    getPage: (params) =&gt; axios.get('/api/list', { params }),
    detailApi: (id) =&gt; axios.get(`/api/detail/${id}`),
    delApi: (id) =&gt; axios.delete(`/api/delete/${id}`),
    putApi: (data) =&gt; axios.put('/api/update', data),
    postApi: (data) =&gt; axios.post('/api/create', data)
  }
}

// GSearch 配置示例
const searchOptions = {
  searchOptions: [
    { type: 'string', label: '名称', name: 'name' },
    { type: 'select', label: '状态', name: 'status', options: [{ value: 1, label: '启用' }, { value: 0, label: '禁用' }] }
  ],
  enableCreate: true,
  enableExport: true
}

// GTable 配置示例
const tableOptions = {
  columns: [
    { title: '名称', dataIndex: 'name', key: 'name' },
    { title: '状态', dataIndex: 'status', key: 'status' },
    { title: '操作', dataIndex: 'action', key: 'action' }
  ],
  actions: [
    { label: '编辑', key: 1 },
    { label: '详情', key: 2 },
    { label: '删除', key: 3 }
  ],
  data: (params) =&gt; axios.get('/api/list', { params })
}

// BaseTable 配置示例
const baseTableOptions = {
  columns: [
    { title: '名称', dataIndex: 'name', key: 'name' },
    { title: '状态', dataIndex: 'status', key: 'status' },
    { title: '操作', dataIndex: 'action', key: 'action' }
  ],
  data: (params) =&gt; axios.get('/api/list', { params }),
  initParam: {},
  rowKey: 'id'
}

// 事件处理
const onExport = () =&gt; { /* 导出逻辑 */ }
const onImport = () =&gt; { /* 导入逻辑 */ }
const onSearch = (data) =&gt; { /* 搜索逻辑 */ }
const onReset = () =&gt; { /* 重置逻辑 */ }
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-14">3. @mengtr/vue3-element</h3>
<p>基于Element Plus的组件库，提供了与<code>@mengtr/vue3-antdv</code>相同的组件API，但使用Element Plus实现。</p>
<h4 data-id="heading-15">导出组件</h4>













































<table><thead><tr><th>组件名</th><th>别名</th><th>描述</th></tr></thead><tbody><tr><td><code>GPage</code></td><td><code>GTablePage</code></td><td>完整的增删改查页面组件</td></tr><tr><td><code>GSearch</code></td><td>-</td><td>搜索功能组件</td></tr><tr><td><code>GTable</code></td><td>-</td><td>表格+弹窗组件</td></tr><tr><td><code>GModal</code></td><td>-</td><td>模态框组件</td></tr><tr><td><code>GForm</code></td><td>-</td><td>表单组件</td></tr><tr><td><code>GFormItem</code></td><td>-</td><td>表单字段组件（即将废弃）</td></tr><tr><td><code>BaseTable</code></td><td>-</td><td>基础表格组件</td></tr></tbody></table>
<h4 data-id="heading-16">导出方法</h4>

























<table><thead><tr><th>方法名</th><th>描述</th><th>来源</th></tr></thead><tbody><tr><td><code>useTable</code></td><td>分页表格数据管理钩子</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr><tr><td><code>useTreeTable</code></td><td>树状表格数据管理钩子</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr><tr><td><code>setTablePageKey</code></td><td>设置分页参数映射</td><td>从<code>@mengtr/vue3-common</code>导入</td></tr></tbody></table>
<h4 data-id="heading-17">使用示例</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;!-- GPage 完整增删改查页面 --&gt;
  &lt;GPage :options="pageOptions" @export="onExport" @import="onImport" /&gt;
  
  &lt;!-- GSearch 搜索功能组件 --&gt;
  &lt;GSearch :options="searchOptions" @search="onSearch" @reset="onReset" /&gt;
  
  &lt;!-- GTable 表格+弹窗组件 --&gt;
  &lt;GTable :options="tableOptions" /&gt;
  
  &lt;!-- BaseTable 基础表格组件 --&gt;
  &lt;BaseTable :type="1" ref="tableRef" :options="baseTableOptions"&gt;
    &lt;template #bodyCell="{ column, record, text, index }"&gt;
      &lt;!-- 自定义单元格内容 --&gt;
      &lt;span v-if="column.property === 'status'"&gt;
        &lt;el-tag :type="record.status === 1 ? 'success' : 'danger'"&gt;
          {{ record.status === 1 ? '启用' : '禁用' }}
        &lt;/el-tag&gt;
      &lt;/span&gt;
    &lt;/template&gt;
  &lt;/BaseTable&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { GPage, GSearch, GTable, BaseTable, useTable } from '@mengtr/vue3-element'
import axios from 'axios'

// 配置与@mengtr/vue3-antdv相同
const pageOptions = {
  // ... 配置内容与@mengtr/vue3-antdv相同
}

const searchOptions = {
  // ... 配置内容与@mengtr/vue3-antdv相同
}

const tableOptions = {
  // ... 配置内容与@mengtr/vue3-antdv相同
}

const baseTableOptions = {
  // ... 配置内容与@mengtr/vue3-antdv相同
}

// 事件处理
const onExport = () =&gt; { /* 导出逻辑 */ }
const onImport = () =&gt; { /* 导入逻辑 */ }
const onSearch = (data) =&gt; { /* 搜索逻辑 */ }
const onReset = () =&gt; { /* 重置逻辑 */ }
&lt;/script&gt;
</code></pre>
<h2 data-id="heading-18">组件详细说明</h2>
<h3 data-id="heading-19">GPage / GTablePage</h3>
<p>完整的增删改查页面组件，集成了搜索、表格、分页、模态框等功能。</p>
<h4 data-id="heading-20">属性</h4>




















<table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>options</code></td><td><code>IPageOptions</code></td><td>页面配置项，包含搜索、表格、模态框和API配置</td></tr><tr><td><code>disabled</code></td><td><code>boolean</code></td><td>是否禁用</td></tr></tbody></table>
<h4 data-id="heading-21">事件</h4>






























<table><thead><tr><th>事件名</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td><code>export</code></td><td>导出事件</td><td>-</td></tr><tr><td><code>import</code></td><td>导入事件</td><td>-</td></tr><tr><td><code>search</code></td><td>搜索事件</td><td><code>data: object</code></td></tr><tr><td><code>reset</code></td><td>重置事件</td><td>-</td></tr></tbody></table>
<h3 data-id="heading-22">GSearch</h3>
<p>搜索功能组件，支持多种搜索字段类型。</p>
<h4 data-id="heading-23">属性</h4>















<table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>options</code></td><td><code>ISearch</code></td><td>搜索配置项</td></tr></tbody></table>
<h4 data-id="heading-24">事件</h4>



































<table><thead><tr><th>事件名</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td><code>search</code></td><td>搜索事件</td><td><code>data: object</code></td></tr><tr><td><code>reset</code></td><td>重置事件</td><td>-</td></tr><tr><td><code>create</code></td><td>新增事件</td><td>-</td></tr><tr><td><code>export</code></td><td>导出事件</td><td>-</td></tr><tr><td><code>import</code></td><td>导入事件</td><td>-</td></tr></tbody></table>
<h3 data-id="heading-25">GTable</h3>
<p>表格+弹窗组件，集成了表格和模态框功能。</p>
<h4 data-id="heading-26">属性</h4>















<table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>options</code></td><td><code>ITable</code></td><td>表格配置项</td></tr></tbody></table>
<h3 data-id="heading-27">BaseTable</h3>
<p>基础表格组件，支持分页、排序、筛选等功能。</p>
<h4 data-id="heading-28">属性</h4>























<table><thead><tr><th>属性</th><th>类型</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>1 | 2</code></td><td>表格类型，1表示普通表格，2表示树形表格</td><td>1</td></tr><tr><td><code>options</code></td><td><code>IProps</code></td><td>表格配置项</td><td><code>{}</code></td></tr></tbody></table>
<h4 data-id="heading-29">插槽</h4>















<table><thead><tr><th>插槽名</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td><code>bodyCell</code></td><td>自定义单元格内容</td><td><code>{ column, record, text, index }</code></td></tr></tbody></table>
<h4 data-id="heading-30">暴露方法</h4>



































<table><thead><tr><th>方法名</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td><code>onSearch</code></td><td>触发搜索</td><td><code>(data?: any) =&gt; void</code></td></tr><tr><td><code>onReset</code></td><td>重置搜索</td><td><code>() =&gt; void</code></td></tr><tr><td><code>onSetParam</code></td><td>设置参数</td><td><code>(param: any) =&gt; void</code></td></tr><tr><td><code>search</code></td><td>搜索对象</td><td><code>Ref&lt;object&gt;</code></td></tr><tr><td><code>pagination</code></td><td>分页对象</td><td><code>Ref&lt;object&gt;</code></td></tr></tbody></table>
<h2 data-id="heading-31">开发</h2>
<h3 data-id="heading-32">安装依赖</h3>
<pre><code class="hljs language-bash" lang="bash">pnpm install
</code></pre>
<h3 data-id="heading-33">构建所有包</h3>
<pre><code class="hljs language-bash" lang="bash">pnpm run build
</code></pre>
<h3 data-id="heading-34">单独构建某个包</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 构建vue3-antdv包</span>
pnpm --filter @mengtr/vue3-antdv run build

<span class="hljs-comment"># 构建vue3-element包</span>
pnpm --filter @mengtr/vue3-element run build

<span class="hljs-comment"># 构建vue3-common包</span>
pnpm --filter @mengtr/vue3-common run build
</code></pre>
<h3 data-id="heading-35">发布包</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 发布所有包</span>
pnpm publish -r

<span class="hljs-comment"># 单独发布某个包</span>
pnpm --filter @mengtr/vue3-antdv publish
</code></pre>
<h2 data-id="heading-36">类型定义</h2>
<h3 data-id="heading-37">IProps</h3>
<p>表格配置项类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IProps</span>&lt;T = <span class="hljs-built_in">any</span>, P = <span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-attr">columns</span>: P[]           <span class="hljs-comment">// 表格列配置</span>
    <span class="hljs-attr">data</span>: T                <span class="hljs-comment">// 数据获取函数</span>
    initParam?: <span class="hljs-built_in">any</span>        <span class="hljs-comment">// 初始化参数</span>
    rowKey?: <span class="hljs-built_in">string</span>        <span class="hljs-comment">// 行键</span>
    scroll?: { x?: <span class="hljs-built_in">number</span>; y?: <span class="hljs-built_in">number</span> }  <span class="hljs-comment">// 滚动配置</span>
    bordered?: <span class="hljs-built_in">boolean</span>     <span class="hljs-comment">// 是否显示边框</span>
    init?: <span class="hljs-built_in">boolean</span>         <span class="hljs-comment">// 是否初始化数据</span>
}
</code></pre>
<h3 data-id="heading-38">GetData</h3>
<p>数据获取函数类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">GetData</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-function">(<span class="hljs-params">params: { page: { page: <span class="hljs-built_in">number</span>; size: <span class="hljs-built_in">number</span> }; param: <span class="hljs-built_in">any</span> }</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;{ [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span> } &amp; { <span class="hljs-attr">records</span>: T[]; <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span> }&gt;
</code></pre>
<h3 data-id="heading-39">TreeData</h3>
<p>树状数据获取函数类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TreeData</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-function">(<span class="hljs-params">params: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;T[]&gt;
</code></pre>
<h2 data-id="heading-40">FormItem 类型</h2>
<h3 data-id="heading-41">TFormItemType</h3>
<p>表单字段类型枚举：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TFormItemType</span> =
  | <span class="hljs-string">'input'</span>        <span class="hljs-comment">// 输入框</span>
  | <span class="hljs-string">'textarea'</span>     <span class="hljs-comment">// 文本域</span>
  | <span class="hljs-string">'number'</span>       <span class="hljs-comment">// 数字输入框</span>
  | <span class="hljs-string">'select'</span>       <span class="hljs-comment">// 下拉选择器</span>
  | <span class="hljs-string">'treeselect'</span>   <span class="hljs-comment">// 树状选择器</span>
  | <span class="hljs-string">'switch'</span>       <span class="hljs-comment">// 开关</span>
  | <span class="hljs-string">'datepicker'</span>   <span class="hljs-comment">// 日期选择器</span>
  | <span class="hljs-string">'rangepicker'</span>  <span class="hljs-comment">// 日期范围选择器</span>
  | <span class="hljs-string">'component'</span>   <span class="hljs-comment">// 自定义组件</span>
  | <span class="hljs-string">'object'</span>       <span class="hljs-comment">// 对象类型（嵌套表单）</span>
  | <span class="hljs-string">'array'</span>        <span class="hljs-comment">// 数组类型（动态表单）</span>
</code></pre>
<h3 data-id="heading-42">IBaseFormItem</h3>
<p>基础表单字段接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBaseFormItem</span> {
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">TFormItemType</span>     <span class="hljs-comment">// 字段类型</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>            <span class="hljs-comment">// 字段名</span>
  label?: <span class="hljs-built_in">string</span>          <span class="hljs-comment">// 标签名</span>
  span?: <span class="hljs-built_in">number</span>           <span class="hljs-comment">// 占用列数</span>
  defaultValue?: <span class="hljs-built_in">any</span>      <span class="hljs-comment">// 默认值</span>
  disabled?: <span class="hljs-built_in">boolean</span>      <span class="hljs-comment">// 是否禁用</span>

  dependsOn?: {           <span class="hljs-comment">// 依赖条件</span>
    <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[]        <span class="hljs-comment">// 依赖字段路径</span>
    <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>            <span class="hljs-comment">// 依赖字段值</span>
  }

  callback?: <span class="hljs-function">(<span class="hljs-params">formData: Recordable, field: IFormItem, oldValue?: <span class="hljs-built_in">any</span>, newValue?: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>  <span class="hljs-comment">// 字段变化回调</span>
  watch?: {              <span class="hljs-comment">// 监听配置</span>
    <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>[]        <span class="hljs-comment">// 监听字段路径</span>
    <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>  <span class="hljs-comment">// 监听回调</span>
  },
  config?: <span class="hljs-title class_">Recordable</span>     <span class="hljs-comment">// 额外配置</span>
}
</code></pre>
<h3 data-id="heading-43">IFormItem</h3>
<p>表单字段联合类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">IFormItem</span> =
  | <span class="hljs-title class_">IInputFormItem</span>        <span class="hljs-comment">// 输入框</span>
  | <span class="hljs-title class_">ITextareaFormItem</span>     <span class="hljs-comment">// 文本域</span>
  | <span class="hljs-title class_">INumberFormItem</span>       <span class="hljs-comment">// 数字输入框</span>
  | <span class="hljs-title class_">ISelectFormItem</span>       <span class="hljs-comment">// 下拉选择器</span>
  | <span class="hljs-title class_">ISwitchFormItem</span>       <span class="hljs-comment">// 开关</span>
  | <span class="hljs-title class_">IDatePickerFormItem</span>   <span class="hljs-comment">// 日期选择器</span>
  | <span class="hljs-title class_">IRangePickerFormItem</span>  <span class="hljs-comment">// 日期范围选择器</span>
  | <span class="hljs-title class_">IComponentFormItem</span>    <span class="hljs-comment">// 自定义组件</span>
  | <span class="hljs-title class_">IObjectFormItem</span>       <span class="hljs-comment">// 对象类型（嵌套表单）</span>
  | <span class="hljs-title class_">IArrayFormItem</span>        <span class="hljs-comment">// 数组类型（动态表单）</span>
</code></pre>
<h2 data-id="heading-44">搜索类型</h2>
<h3 data-id="heading-45">TSearchType</h3>
<p>搜索字段类型枚举：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TSearchType</span> =
  | <span class="hljs-string">'number'</span>       <span class="hljs-comment">// 数字类型</span>
  | <span class="hljs-string">'string'</span>       <span class="hljs-comment">// 字符串类型</span>
  | <span class="hljs-string">'datapicker'</span>   <span class="hljs-comment">// 日期选择器</span>
  | <span class="hljs-string">'rangepicker'</span>  <span class="hljs-comment">// 日期范围选择器</span>
  | <span class="hljs-string">'select'</span>       <span class="hljs-comment">// 下拉选择器</span>
  | <span class="hljs-string">'treeselect'</span>   <span class="hljs-comment">// 树状选择器</span>
</code></pre>
<h3 data-id="heading-46">TSearchOption</h3>
<p>搜索字段联合类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TSearchOption</span> =
  | <span class="hljs-title class_">INumberSearchField</span>       <span class="hljs-comment">// 数字类型搜索字段</span>
  | <span class="hljs-title class_">IStringSearchField</span>       <span class="hljs-comment">// 字符串类型搜索字段</span>
  | <span class="hljs-title class_">IDataPickerSearchField</span>   <span class="hljs-comment">// 日期选择器搜索字段</span>
  | <span class="hljs-title class_">IRangePickerSearchField</span>  <span class="hljs-comment">// 日期范围选择器搜索字段</span>
  | <span class="hljs-title class_">ISelectSearchField</span>       <span class="hljs-comment">// 下拉选择器搜索字段</span>
</code></pre>
<h3 data-id="heading-47">ISearch</h3>
<p>搜索配置接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISearch</span> {
  <span class="hljs-attr">searchOptions</span>: <span class="hljs-title class_">TSearchOption</span>[]  <span class="hljs-comment">// 搜索字段配置</span>
  enableExport?: <span class="hljs-built_in">boolean</span>         <span class="hljs-comment">// 是否启用导出</span>
  enableImport?: <span class="hljs-built_in">boolean</span>         <span class="hljs-comment">// 是否启用导入</span>
  enableCreate?: <span class="hljs-built_in">boolean</span>         <span class="hljs-comment">// 是否启用新增</span>
  span?: <span class="hljs-built_in">number</span>                  <span class="hljs-comment">// 搜索字段占用列数</span>
}
</code></pre>
<h2 data-id="heading-48">注意事项</h2>
<ol>
<li>确保你的项目使用Vue 3.5.0或以上版本</li>
<li>确保正确安装了对应的UI库依赖：
<ul>
<li>使用<code>@mengtr/vue3-antdv</code>时，需要安装<code>ant-design-vue</code>和<code>@ant-design/icons-vue</code></li>
<li>使用<code>@mengtr/vue3-element</code>时，需要安装<code>element-plus</code>和<code>@element-plus/icons-vue</code></li>
</ul>
</li>
<li>建议使用pnpm作为包管理器，以获得最佳的工作空间支持</li>
<li><code>GFormItem</code>组件即将废弃，建议使用<code>GForm</code>组件替代</li>
<li>组件库提供了完整的TypeScript类型定义，建议使用TypeScript开发以获得更好的开发体验</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 Flutter Pay 插件实现 Apple Pay 和 Google Pay 的完整指南]]></title>    <link>https://juejin.cn/post/7585289701826740233</link>    <guid>https://juejin.cn/post/7585289701826740233</guid>    <pubDate>2025-12-19T08:11:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585289701826740233" data-draft-id="7585289701826592777" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 Flutter Pay 插件实现 Apple Pay 和 Google Pay 的完整指南"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2025-12-19T08:11:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一名普通的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/3913917126936087"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 Flutter Pay 插件实现 Apple Pay 和 Google Pay 的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917126936087/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一名普通的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:11:28.000Z" title="Fri Dec 19 2025 08:11:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p><code>pay</code> 是 Google 官方维护的 Flutter 插件，提供了统一的 API 来集成 Apple Pay 和 Google Pay。相比其他支付插件，它更加轻量且易于配置。本文将详细介绍如何使用这个插件在 Flutter 应用中实现原生支付功能。</p>
<h2 data-id="heading-1">插件介绍</h2>
<h3 data-id="heading-2">为什么选择 pay 插件？</h3>
<ul>
<li><strong>官方维护</strong>: 由 Google 官方团队维护，更新及时</li>
<li><strong>统一 API</strong>: 一套代码同时支持 Apple Pay 和 Google Pay</li>
<li><strong>配置简单</strong>: 使用 JSON 配置文件，无需复杂的原生代码</li>
<li><strong>灵活性高</strong>: 支持多种支付网关（Stripe、Braintree、Adyen 等）</li>
<li><strong>内置 UI</strong>: 提供标准的支付按钮组件</li>
</ul>
<h3 data-id="heading-3">插件架构</h3>
<pre><code class="hljs language-ASCII" lang="ASCII">┌─────────────────────────────────────────────────────┐
│                   Flutter App                       │
│                   (Payment UI)                      │
├─────────────────────────────────────────────────────┤
│                       pay                           │
│                     (Plugin)                        │
├────────────────────────┬────────────────────────────┤
│       Apple Pay        │        Google Pay          │
│        (iOS)           │        (Android)           │
├────────────────────────┴────────────────────────────┤
│                  Payment Gateway                    │
│      Stripe  |  Braintree  |  Adyen  |  Others...   │
└─────────────────────────────────────────────────────┘
</code></pre>
<h2 data-id="heading-4">环境准备</h2>
<h3 data-id="heading-5">前置要求</h3>
<ul>
<li>Flutter SDK &gt;= 3.0.0</li>
<li>Dart &gt;= 2.17.0</li>
<li>iOS 12.0+ (Apple Pay)</li>
<li>Android API 19+ (Google Pay)</li>
<li>支付网关账户（如 Stripe）</li>
</ul>
<h3 data-id="heading-6">开发环境</h3>
<ul>
<li>Xcode 14+ (iOS 开发)</li>
<li>Android Studio / VS Code</li>
<li>真机设备（模拟器支持有限）</li>
</ul>
<h2 data-id="heading-7">安装与配置</h2>
<h3 data-id="heading-8">1. 添加依赖</h3>
<p>在 <code>pubspec.yaml</code> 中添加：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">pay:</span> <span class="hljs-string">^3.3.0</span>
</code></pre>
<p>运行：</p>
<pre><code class="hljs language-bash" lang="bash">flutter pub get
</code></pre>
<h3 data-id="heading-9">2. iOS 配置 (Apple Pay)</h3>
<h4 data-id="heading-10">2.1 修改 <code>ios/Podfile</code></h4>
<pre><code class="hljs language-ruby" lang="ruby">platform <span class="hljs-symbol">:ios</span>, <span class="hljs-string">'12.0'</span>
</code></pre>
<h4 data-id="heading-11">2.2 在 Xcode 中添加 Apple Pay 能力</h4>
<ol>
<li>打开 <code>ios/Runner.xcworkspace</code></li>
<li>选择 Runner 项目 → Signing &amp; Capabilities</li>
<li>点击 "+ Capability" → 添加 "Apple Pay"</li>
<li>添加你的 Merchant ID（格式：<code>merchant.com.yourcompany.yourapp</code>）</li>
</ol>
<h4 data-id="heading-12">2.3 Apple Developer 配置</h4>
<ol>
<li>登录 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2F" target="_blank" title="https://developer.apple.com/" ref="nofollow noopener noreferrer">Apple Developer Portal</a></li>
<li>进入 Certificates, Identifiers &amp; Profiles</li>
<li>选择 Identifiers → Merchant IDs</li>
<li>创建新的 Merchant ID</li>
<li>为你的 App ID 启用 Apple Pay 并关联 Merchant ID</li>
</ol>
<h3 data-id="heading-13">3. Android 配置 (Google Pay)</h3>
<h4 data-id="heading-14">3.1 修改 <code>android/app/build.gradle.kts</code></h4>
<pre><code class="hljs language-kotlin" lang="kotlin">android {
    compileSdk = <span class="hljs-number">34</span>
    
    defaultConfig {
        minSdk = <span class="hljs-number">19</span>
        targetSdk = <span class="hljs-number">34</span>
    }
}
</code></pre>
<h4 data-id="heading-15">3.2 修改 <code>android/app/src/main/AndroidManifest.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 启用 Google Pay API --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.google.android.gms.wallet.api.enabled"</span>
            <span class="hljs-attr">android:value</span>=<span class="hljs-string">"true"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<h2 data-id="heading-16">支付配置文件</h2>
<p><code>pay</code> 插件使用 JSON 配置文件来定义支付参数。这是该插件的核心特性。</p>
<h3 data-id="heading-17">1. 创建配置文件目录</h3>
<pre><code class="hljs">assets/
├── apple_pay_config.json
└── google_pay_config.json
</code></pre>
<h3 data-id="heading-18">2. Apple Pay 配置文件</h3>
<p>创建 <code>assets/apple_pay_config.json</code>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"provider"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"apple_pay"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"merchantIdentifier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"merchant.com.yourcompany.yourapp"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"displayName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Your Store Name"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"merchantCapabilities"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"3DS"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"debit"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"credit"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"supportedNetworks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"amex"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"discover"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"masterCard"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"visa"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"countryCode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"US"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"currencyCode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"USD"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"requiredBillingContactFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"emailAddress"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"name"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"phoneNumber"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"postalAddress"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"requiredShippingContactFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"emailAddress"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"name"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"phoneNumber"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"postalAddress"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"shippingMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"amount"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.00"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3-5 business days"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"identifier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"standard"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"label"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Standard Shipping"</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"amount"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"9.99"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1-2 business days"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"identifier"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"express"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"label"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Express Shipping"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-19">配置参数说明</h3>

































<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>merchantIdentifier</code></td><td>Apple Developer 中创建的 Merchant ID</td></tr><tr><td><code>displayName</code></td><td>支付表单中显示的商户名称</td></tr><tr><td><code>merchantCapabilities</code></td><td>支持的支付能力（3DS、借记卡、信用卡）</td></tr><tr><td><code>supportedNetworks</code></td><td>支持的卡网络</td></tr><tr><td><code>countryCode</code></td><td>商户所在国家代码</td></tr><tr><td><code>currencyCode</code></td><td>交易货币代码</td></tr></tbody></table>
<h3 data-id="heading-20">3. Google Pay 配置文件</h3>
<p>创建 <code>assets/google_pay_config.json</code>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"provider"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"google_pay"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"environment"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TEST"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersionMinor"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowedPaymentMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"CARD"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"tokenizationSpecification"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"PAYMENT_GATEWAY"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"gateway"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"stripe"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"stripe:version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2020-08-27"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"stripe:publishableKey"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pk_test_your_publishable_key"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"allowedCardNetworks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
            <span class="hljs-string">"VISA"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-string">"MASTERCARD"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-string">"AMEX"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-string">"DISCOVER"</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"allowedAuthMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
            <span class="hljs-string">"PAN_ONLY"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-string">"CRYPTOGRAM_3DS"</span>
          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"billingAddressRequired"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"billingAddressParameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"format"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"FULL"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"phoneNumberRequired"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"merchantInfo"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"merchantId"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"BCR2DN4XXXXX"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"merchantName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Your Store Name"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"transactionInfo"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"countryCode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"US"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"currencyCode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"USD"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-21">Google Pay 配置参数说明</h3>





























<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>environment</code></td><td><code>TEST</code> 或 <code>PRODUCTION</code></td></tr><tr><td><code>gateway</code></td><td>支付网关名称（stripe、braintree 等）</td></tr><tr><td><code>merchantId</code></td><td>Google Pay 商户 ID（生产环境需要）</td></tr><tr><td><code>allowedCardNetworks</code></td><td>支持的卡网络</td></tr><tr><td><code>allowedAuthMethods</code></td><td>支持的认证方式</td></tr></tbody></table>
<h3 data-id="heading-22">4. 引用资源文件</h3>
<p>在 <code>pubspec.yaml</code> 中添加：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">flutter:</span>
  <span class="hljs-attr">assets:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">assets/apple_pay_config.json</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">assets/google_pay_config.json</span>
</code></pre>
<h2 data-id="heading-23">Apple Pay 实现</h2>
<h3 data-id="heading-24">基础实现</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:pay/pay.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplePayExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> ApplePayExample({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  State&lt;ApplePayExample&gt; createState() =&gt; _ApplePayExampleState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_ApplePayExampleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">ApplePayExample</span>&gt; </span>{
  <span class="hljs-keyword">late</span> <span class="hljs-keyword">final</span> Pay _payClient;

  <span class="hljs-comment">// 定义支付项目</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;PaymentItem&gt; _paymentItems = [
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'商品小计'</span>,
      amount: <span class="hljs-string">'99.99'</span>,
      status: PaymentItemStatus.final_price,
    ),
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'运费'</span>,
      amount: <span class="hljs-string">'5.99'</span>,
      status: PaymentItemStatus.final_price,
    ),
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'总计'</span>,
      amount: <span class="hljs-string">'105.98'</span>,
      status: PaymentItemStatus.final_price,
    ),
  ];

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    <span class="hljs-comment">// 从配置文件初始化</span>
    _payClient = Pay({
      PayProvider.apple_pay: PaymentConfiguration.fromJsonString(
        _applePayConfigString,
      ),
    });
  }

  <span class="hljs-comment">// 处理支付结果</span>
  <span class="hljs-keyword">void</span> _onApplePayResult(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result) {
    <span class="hljs-comment">// result 包含支付 token 和其他信息</span>
    debugPrint(<span class="hljs-string">'Apple Pay 结果: <span class="hljs-subst">$result</span>'</span>);
    
    <span class="hljs-comment">// 将 token 发送到后端处理</span>
    _processPayment(result);
  }

  Future&lt;<span class="hljs-keyword">void</span>&gt; _processPayment(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; paymentResult) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 发送到后端</span>
    <span class="hljs-comment">// final response = await http.post(...);</span>
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      body: Center(
        child: ApplePayButton(
          paymentConfiguration: PaymentConfiguration.fromJsonString(
            _applePayConfigString,
          ),
          paymentItems: _paymentItems,
          style: ApplePayButtonStyle.black,
          type: ApplePayButtonType.buy,
          onPaymentResult: _onApplePayResult,
          onError: (error) {
            debugPrint(<span class="hljs-string">'Apple Pay 错误: <span class="hljs-subst">$error</span>'</span>);
          },
          loadingIndicator: <span class="hljs-keyword">const</span> CircularProgressIndicator(),
        ),
      ),
    );
  }
}
</code></pre>
<h3 data-id="heading-25">Apple Pay 按钮样式</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 按钮样式选项</span>
ApplePayButtonStyle.black      <span class="hljs-comment">// 黑色背景</span>
ApplePayButtonStyle.white      <span class="hljs-comment">// 白色背景</span>
ApplePayButtonStyle.whiteOutline  <span class="hljs-comment">// 白色带边框</span>

<span class="hljs-comment">// 按钮类型选项</span>
ApplePayButtonType.buy         <span class="hljs-comment">// "使用 Apple Pay 购买"</span>
ApplePayButtonType.plain       <span class="hljs-comment">// Apple Pay 图标</span>
ApplePayButtonType.setUp       <span class="hljs-comment">// "设置 Apple Pay"</span>
ApplePayButtonType.inStore     <span class="hljs-comment">// "店内使用 Apple Pay"</span>
ApplePayButtonType.donate      <span class="hljs-comment">// "使用 Apple Pay 捐赠"</span>
ApplePayButtonType.checkout    <span class="hljs-comment">// "使用 Apple Pay 结账"</span>
ApplePayButtonType.book        <span class="hljs-comment">// "使用 Apple Pay 预订"</span>
ApplePayButtonType.subscribe   <span class="hljs-comment">// "使用 Apple Pay 订阅"</span>
</code></pre>
<h2 data-id="heading-26">Google Pay 实现</h2>
<h3 data-id="heading-27">基础实现</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:pay/pay.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GooglePayExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> GooglePayExample({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  State&lt;GooglePayExample&gt; createState() =&gt; _GooglePayExampleState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_GooglePayExampleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">GooglePayExample</span>&gt; </span>{
  <span class="hljs-comment">// 定义支付项目</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;PaymentItem&gt; _paymentItems = [
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'商品总计'</span>,
      amount: <span class="hljs-string">'99.99'</span>,
      status: PaymentItemStatus.final_price,
    ),
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'运费'</span>,
      amount: <span class="hljs-string">'5.99'</span>,
      status: PaymentItemStatus.final_price,
    ),
    <span class="hljs-keyword">const</span> PaymentItem(
      label: <span class="hljs-string">'总计'</span>,
      amount: <span class="hljs-string">'105.98'</span>,
      status: PaymentItemStatus.final_price,
    ),
  ];

  <span class="hljs-comment">// 处理支付结果</span>
  <span class="hljs-keyword">void</span> _onGooglePayResult(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result) {
    debugPrint(<span class="hljs-string">'Google Pay 结果: <span class="hljs-subst">$result</span>'</span>);
    
    <span class="hljs-comment">// 从结果中提取 token</span>
    <span class="hljs-keyword">final</span> token = result[<span class="hljs-string">'paymentMethodData'</span>][<span class="hljs-string">'tokenizationData'</span>][<span class="hljs-string">'token'</span>];
    debugPrint(<span class="hljs-string">'支付 Token: <span class="hljs-subst">$token</span>'</span>);
    
    <span class="hljs-comment">// 将 token 发送到后端处理</span>
    _processPayment(token);
  }

  Future&lt;<span class="hljs-keyword">void</span>&gt; _processPayment(<span class="hljs-built_in">String</span> token) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 发送到后端</span>
    <span class="hljs-comment">// final response = await http.post(...);</span>
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      body: Center(
        child: GooglePayButton(
          paymentConfiguration: PaymentConfiguration.fromAsset(
            <span class="hljs-string">'assets/google_pay_config.json'</span>,
          ),
          paymentItems: _paymentItems,
          type: GooglePayButtonType.buy,
          onPaymentResult: _onGooglePayResult,
          onError: (error) {
            debugPrint(<span class="hljs-string">'Google Pay 错误: <span class="hljs-subst">$error</span>'</span>);
          },
          loadingIndicator: <span class="hljs-keyword">const</span> CircularProgressIndicator(),
        ),
      ),
    );
  }
}
</code></pre>
<h3 data-id="heading-28">Google Pay 按钮样式</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 按钮类型选项</span>
GooglePayButtonType.buy        <span class="hljs-comment">// "使用 Google Pay 购买"</span>
GooglePayButtonType.book       <span class="hljs-comment">// "使用 Google Pay 预订"</span>
GooglePayButtonType.checkout   <span class="hljs-comment">// "使用 Google Pay 结账"</span>
GooglePayButtonType.donate     <span class="hljs-comment">// "使用 Google Pay 捐赠"</span>
GooglePayButtonType.order      <span class="hljs-comment">// "使用 Google Pay 下单"</span>
GooglePayButtonType.pay        <span class="hljs-comment">// "使用 Google Pay 支付"</span>
GooglePayButtonType.plain      <span class="hljs-comment">// Google Pay 图标</span>
GooglePayButtonType.subscribe  <span class="hljs-comment">// "使用 Google Pay 订阅"</span>
</code></pre>
<h2 data-id="heading-29">完整代码示例</h2>
<h3 data-id="heading-30">支付服务类</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:convert'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:io'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/services.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:pay/pay.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativePayService</span> </span>{
  <span class="hljs-keyword">static</span> NativePayService? _instance;
  <span class="hljs-keyword">late</span> Pay _payClient;
  
  PaymentConfiguration? _applePayConfig;
  PaymentConfiguration? _googlePayConfig;

  NativePayService._();

  <span class="hljs-keyword">static</span> NativePayService <span class="hljs-keyword">get</span> instance {
    _instance ??= NativePayService._();
    <span class="hljs-keyword">return</span> _instance!;
  }

  <span class="hljs-comment">/// <span class="markdown">初始化支付服务</span></span>
  Future&lt;<span class="hljs-keyword">void</span>&gt; initialize() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> configurations = &lt;PayProvider, PaymentConfiguration&gt;{};

    <span class="hljs-keyword">if</span> (Platform.isIOS) {
      <span class="hljs-keyword">final</span> applePayConfigString = <span class="hljs-keyword">await</span> rootBundle.loadString(
        <span class="hljs-string">'assets/apple_pay_config.json'</span>,
      );
      _applePayConfig = PaymentConfiguration.fromJsonString(
        applePayConfigString,
      );
      configurations[PayProvider.apple_pay] = _applePayConfig!;
    }

    <span class="hljs-keyword">if</span> (Platform.isAndroid) {
      <span class="hljs-keyword">final</span> googlePayConfigString = <span class="hljs-keyword">await</span> rootBundle.loadString(
        <span class="hljs-string">'assets/google_pay_config.json'</span>,
      );
      _googlePayConfig = PaymentConfiguration.fromJsonString(
        googlePayConfigString,
      );
      configurations[PayProvider.google_pay] = _googlePayConfig!;
    }

    _payClient = Pay(configurations);
  }

  <span class="hljs-comment">/// <span class="markdown">获取当前平台的支付配置</span></span>
  PaymentConfiguration? <span class="hljs-keyword">get</span> currentConfig {
    <span class="hljs-keyword">if</span> (Platform.isIOS) <span class="hljs-keyword">return</span> _applePayConfig;
    <span class="hljs-keyword">if</span> (Platform.isAndroid) <span class="hljs-keyword">return</span> _googlePayConfig;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  }

  <span class="hljs-comment">/// <span class="markdown">检查原生支付是否可用</span></span>
  Future&lt;<span class="hljs-built_in">bool</span>&gt; isAvailable() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (Platform.isIOS) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _payClient.userCanPay(PayProvider.apple_pay);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Platform.isAndroid) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _payClient.userCanPay(PayProvider.google_pay);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
  }

  <span class="hljs-comment">/// <span class="markdown">显示支付表单</span></span>
  Future&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; showPaymentSheet({
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">List</span>&lt;PaymentItem&gt; paymentItems,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">if</span> (Platform.isIOS) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _payClient.showPaymentSelector(
        PayProvider.apple_pay,
        paymentItems,
      );
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Platform.isAndroid) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _payClient.showPaymentSelector(
        PayProvider.google_pay,
        paymentItems,
      );
    }
    <span class="hljs-keyword">throw</span> UnsupportedError(<span class="hljs-string">'不支持的平台'</span>);
  }
}
</code></pre>
<h3 data-id="heading-31">跨平台支付页面</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:io'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:pay/pay.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'../services/native_pay_service.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckoutScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> CheckoutScreen({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  State&lt;CheckoutScreen&gt; createState() =&gt; _CheckoutScreenState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CheckoutScreenState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CheckoutScreen</span>&gt; </span>{
  <span class="hljs-built_in">bool</span> _isLoading = <span class="hljs-keyword">true</span>;
  <span class="hljs-built_in">bool</span> _isPayAvailable = <span class="hljs-keyword">false</span>;
  <span class="hljs-built_in">String?</span> _errorMessage;

  <span class="hljs-comment">// 购物车商品</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;CartItem&gt; _cartItems = [
    CartItem(name: <span class="hljs-string">'Flutter 开发指南'</span>, price: <span class="hljs-number">49.99</span>),
    CartItem(name: <span class="hljs-string">'Dart 编程实战'</span>, price: <span class="hljs-number">39.99</span>),
  ];

  <span class="hljs-comment">// 计算总价</span>
  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> _subtotal =&gt; _cartItems.fold(<span class="hljs-number">0</span>, (sum, item) =&gt; sum + item.price);
  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> _shipping =&gt; <span class="hljs-number">5.99</span>;
  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> _total =&gt; _subtotal + _shipping;

  <span class="hljs-comment">// 支付项目列表</span>
  <span class="hljs-built_in">List</span>&lt;PaymentItem&gt; <span class="hljs-keyword">get</span> _paymentItems =&gt; [
    PaymentItem(
      label: <span class="hljs-string">'商品小计'</span>,
      amount: _subtotal.toStringAsFixed(<span class="hljs-number">2</span>),
      status: PaymentItemStatus.final_price,
    ),
    PaymentItem(
      label: <span class="hljs-string">'运费'</span>,
      amount: _shipping.toStringAsFixed(<span class="hljs-number">2</span>),
      status: PaymentItemStatus.final_price,
    ),
    PaymentItem(
      label: <span class="hljs-string">'总计'</span>,
      amount: _total.toStringAsFixed(<span class="hljs-number">2</span>),
      status: PaymentItemStatus.final_price,
    ),
  ];

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _initializePayment();
  }

  Future&lt;<span class="hljs-keyword">void</span>&gt; _initializePayment() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> NativePayService.instance.initialize();
      <span class="hljs-keyword">final</span> isAvailable = <span class="hljs-keyword">await</span> NativePayService.instance.isAvailable();
      
      setState(() {
        _isPayAvailable = isAvailable;
        _isLoading = <span class="hljs-keyword">false</span>;
      });
    } <span class="hljs-keyword">catch</span> (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = <span class="hljs-keyword">false</span>;
      });
    }
  }

  <span class="hljs-keyword">void</span> _onPaymentResult(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result) {
    debugPrint(<span class="hljs-string">'支付结果: <span class="hljs-subst">$result</span>'</span>);
    
    <span class="hljs-comment">// 显示成功提示</span>
    ScaffoldMessenger.of(context).showSnackBar(
      <span class="hljs-keyword">const</span> SnackBar(
        content: Text(<span class="hljs-string">'支付成功！'</span>),
        backgroundColor: Colors.green,
      ),
    );

    <span class="hljs-comment">// 处理支付结果</span>
    _processPaymentOnServer(result);
  }

  Future&lt;<span class="hljs-keyword">void</span>&gt; _processPaymentOnServer(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 提取 token 并发送到后端</span>
    <span class="hljs-built_in">String</span> token;
    
    <span class="hljs-keyword">if</span> (Platform.isIOS) {
      <span class="hljs-comment">// Apple Pay token</span>
      token = result[<span class="hljs-string">'token'</span>] ?? <span class="hljs-string">''</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Google Pay token</span>
      token = result[<span class="hljs-string">'paymentMethodData'</span>]?[<span class="hljs-string">'tokenizationData'</span>]?[<span class="hljs-string">'token'</span>] ?? <span class="hljs-string">''</span>;
    }

    <span class="hljs-comment">// 发送到后端处理</span>
    <span class="hljs-comment">// await PaymentApi.processPayment(token: token, amount: _total);</span>
  }

  <span class="hljs-keyword">void</span> _onPaymentError(<span class="hljs-built_in">Object?</span> error) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(<span class="hljs-string">'支付失败: <span class="hljs-subst">$error</span>'</span>),
        backgroundColor: Colors.red,
      ),
    );
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(
        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'结账'</span>),
      ),
      body: _isLoading
          ? <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator())
          : _buildContent(),
    );
  }

  Widget _buildContent() {
    <span class="hljs-keyword">return</span> SingleChildScrollView(
      padding: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">16</span>),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          <span class="hljs-comment">// 购物车商品列表</span>
          _buildCartItems(),
          
          <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">16</span>),
          
          <span class="hljs-comment">// 价格明细</span>
          _buildPriceSummary(),
          
          <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">24</span>),
          
          <span class="hljs-comment">// 支付按钮</span>
          _buildPaymentButton(),
          
          <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">16</span>),
          
          <span class="hljs-comment">// 或者使用其他支付方式</span>
          _buildAlternativePayment(),
        ],
      ),
    );
  }

  Widget _buildCartItems() {
    <span class="hljs-keyword">return</span> Card(
      child: Column(
        children: _cartItems.map((item) =&gt; ListTile(
          title: Text(item.name),
          trailing: Text(<span class="hljs-string">'\$<span class="hljs-subst">${item.price.toStringAsFixed(<span class="hljs-number">2</span>)}</span>'</span>),
        )).toList(),
      ),
    );
  }

  Widget _buildPriceSummary() {
    <span class="hljs-keyword">return</span> Card(
      child: Padding(
        padding: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">16</span>),
        child: Column(
          children: [
            _buildPriceRow(<span class="hljs-string">'小计'</span>, _subtotal),
            _buildPriceRow(<span class="hljs-string">'运费'</span>, _shipping),
            <span class="hljs-keyword">const</span> Divider(),
            _buildPriceRow(<span class="hljs-string">'总计'</span>, _total, isBold: <span class="hljs-keyword">true</span>),
          ],
        ),
      ),
    );
  }

  Widget _buildPriceRow(<span class="hljs-built_in">String</span> label, <span class="hljs-built_in">double</span> amount, {<span class="hljs-built_in">bool</span> isBold = <span class="hljs-keyword">false</span>}) {
    <span class="hljs-keyword">return</span> Padding(
      padding: <span class="hljs-keyword">const</span> EdgeInsets.symmetric(vertical: <span class="hljs-number">4</span>),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: TextStyle(
              fontWeight: isBold ? FontWeight.bold : FontWeight.normal,
              fontSize: isBold ? <span class="hljs-number">18</span> : <span class="hljs-number">14</span>,
            ),
          ),
          Text(
            <span class="hljs-string">'\$<span class="hljs-subst">${amount.toStringAsFixed(<span class="hljs-number">2</span>)}</span>'</span>,
            style: TextStyle(
              fontWeight: isBold ? FontWeight.bold : FontWeight.normal,
              fontSize: isBold ? <span class="hljs-number">18</span> : <span class="hljs-number">14</span>,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPaymentButton() {
    <span class="hljs-keyword">if</span> (!_isPayAvailable) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Text(
        <span class="hljs-string">'此设备不支持 Apple Pay / Google Pay'</span>,
        textAlign: TextAlign.center,
        style: TextStyle(color: Colors.grey),
      );
    }

    <span class="hljs-keyword">final</span> config = NativePayService.instance.currentConfig;
    <span class="hljs-keyword">if</span> (config == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> SizedBox.shrink();

    <span class="hljs-keyword">if</span> (Platform.isIOS) {
      <span class="hljs-keyword">return</span> ApplePayButton(
        paymentConfiguration: config,
        paymentItems: _paymentItems,
        style: ApplePayButtonStyle.black,
        type: ApplePayButtonType.checkout,
        onPaymentResult: _onPaymentResult,
        onError: _onPaymentError,
        loadingIndicator: <span class="hljs-keyword">const</span> Center(
          child: CircularProgressIndicator(),
        ),
      );
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> GooglePayButton(
        paymentConfiguration: config,
        paymentItems: _paymentItems,
        type: GooglePayButtonType.checkout,
        onPaymentResult: _onPaymentResult,
        onError: _onPaymentError,
        loadingIndicator: <span class="hljs-keyword">const</span> Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
  }

  Widget _buildAlternativePayment() {
    <span class="hljs-keyword">return</span> Column(
      children: [
        <span class="hljs-keyword">const</span> Row(
          children: [
            Expanded(child: Divider()),
            Padding(
              padding: EdgeInsets.symmetric(horizontal: <span class="hljs-number">16</span>),
              child: Text(<span class="hljs-string">'或'</span>, style: TextStyle(color: Colors.grey)),
            ),
            Expanded(child: Divider()),
          ],
        ),
        <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">16</span>),
        OutlinedButton(
          onPressed: () {
            <span class="hljs-comment">// 跳转到信用卡支付页面</span>
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'使用信用卡支付'</span>),
        ),
      ],
    );
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartItem</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> price;

  CartItem({<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.price});
}
</code></pre>
<h3 data-id="heading-32">应用入口</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'screens/checkout_screen.dart'</span>;

<span class="hljs-keyword">void</span> main() {
  runApp(<span class="hljs-keyword">const</span> MyApp());
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Pay Plugin Demo'</span>,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: <span class="hljs-keyword">true</span>,
      ),
      home: <span class="hljs-keyword">const</span> CheckoutScreen(),
    );
  }
}
</code></pre>
<h2 data-id="heading-33">与支付网关集成</h2>
<h3 data-id="heading-34">Stripe 集成</h3>
<h4 data-id="heading-35">后端代码 (Node.js)</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> stripe = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stripe'</span>)(<span class="hljs-string">'sk_test_your_secret_key'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());

<span class="hljs-comment">// 处理 Apple Pay / Google Pay token</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/process-payment'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { token, amount, currency } = req.<span class="hljs-property">body</span>;

    <span class="hljs-comment">// 创建支付</span>
    <span class="hljs-keyword">const</span> charge = <span class="hljs-keyword">await</span> stripe.<span class="hljs-property">charges</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">amount</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(amount * <span class="hljs-number">100</span>), <span class="hljs-comment">// 转换为分</span>
      <span class="hljs-attr">currency</span>: currency || <span class="hljs-string">'usd'</span>,
      <span class="hljs-attr">source</span>: token,
      <span class="hljs-attr">description</span>: <span class="hljs-string">'App Purchase'</span>,
    });

    res.<span class="hljs-title function_">json</span>({
      <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">chargeId</span>: charge.<span class="hljs-property">id</span>,
    });
  } <span class="hljs-keyword">catch</span> (error) {
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({
      <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>,
    });
  }
});

<span class="hljs-comment">// 或者使用 Payment Intent（推荐）</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/create-payment-intent'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { amount, currency } = req.<span class="hljs-property">body</span>;

    <span class="hljs-keyword">const</span> paymentIntent = <span class="hljs-keyword">await</span> stripe.<span class="hljs-property">paymentIntents</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">amount</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(amount * <span class="hljs-number">100</span>),
      <span class="hljs-attr">currency</span>: currency || <span class="hljs-string">'usd'</span>,
      <span class="hljs-attr">automatic_payment_methods</span>: {
        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
      },
    });

    res.<span class="hljs-title function_">json</span>({
      <span class="hljs-attr">clientSecret</span>: paymentIntent.<span class="hljs-property">client_secret</span>,
    });
  } <span class="hljs-keyword">catch</span> (error) {
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span> });
  }
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<h3 data-id="heading-36">其他支付网关配置</h3>
<h4 data-id="heading-37">Braintree</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"provider"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"google_pay"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"environment"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TEST"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersionMinor"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowedPaymentMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"CARD"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"tokenizationSpecification"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"PAYMENT_GATEWAY"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"gateway"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"braintree"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"braintree:apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"braintree:sdkVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3.0.0"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"braintree:merchantId"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"your_merchant_id"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"braintree:clientKey"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"your_client_key"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"allowedCardNetworks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"VISA"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"MASTERCARD"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"allowedAuthMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"PAN_ONLY"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"CRYPTOGRAM_3DS"</span><span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-38">Adyen</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"provider"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"google_pay"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"environment"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TEST"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"apiVersionMinor"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowedPaymentMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"CARD"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"tokenizationSpecification"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"PAYMENT_GATEWAY"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"gateway"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"adyen"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"gatewayMerchantId"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"your_merchant_account"</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"parameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"allowedCardNetworks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"VISA"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"MASTERCARD"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"AMEX"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
          <span class="hljs-attr">"allowedAuthMethods"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"PAN_ONLY"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"CRYPTOGRAM_3DS"</span><span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-39">测试与调试</h2>
<h3 data-id="heading-40">测试环境设置</h3>
<ol>
<li>
<p><strong>Google Pay 测试模式</strong></p>
<ul>
<li>配置文件中设置 <code>"environment": "TEST"</code></li>
<li>加入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fpay%2Fapi%2Fandroid%2Fguides%2Fresources%2Ftest-card-suite" target="_blank" title="https://developers.google.com/pay/api/android/guides/resources/test-card-suite" ref="nofollow noopener noreferrer">Google Pay API 测试卡组</a></li>
</ul>
</li>
<li>
<p><strong>Apple Pay 沙盒测试</strong></p>
<ul>
<li>使用 Sandbox 测试账户</li>
<li>在设置中添加测试卡</li>
</ul>
</li>
</ol>
<h3 data-id="heading-41">调试技巧</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 详细日志输出</span>
<span class="hljs-keyword">void</span> _onPaymentResult(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; result) {
  <span class="hljs-comment">// 打印完整结果</span>
  debugPrint(<span class="hljs-string">'完整支付结果:'</span>);
  debugPrint(<span class="hljs-keyword">const</span> JsonEncoder.withIndent(<span class="hljs-string">'  '</span>).convert(result));
  
  <span class="hljs-comment">// Apple Pay 结果结构</span>
  <span class="hljs-keyword">if</span> (Platform.isIOS) {
    debugPrint(<span class="hljs-string">'Token: <span class="hljs-subst">${result[<span class="hljs-string">'token'</span>]}</span>'</span>);
    debugPrint(<span class="hljs-string">'Transaction ID: <span class="hljs-subst">${result[<span class="hljs-string">'transactionIdentifier'</span>]}</span>'</span>);
    debugPrint(<span class="hljs-string">'Payment Method: <span class="hljs-subst">${result[<span class="hljs-string">'paymentMethod'</span>]}</span>'</span>);
  }
  
  <span class="hljs-comment">// Google Pay 结果结构</span>
  <span class="hljs-keyword">if</span> (Platform.isAndroid) {
    <span class="hljs-keyword">final</span> paymentMethodData = result[<span class="hljs-string">'paymentMethodData'</span>];
    debugPrint(<span class="hljs-string">'Type: <span class="hljs-subst">${paymentMethodData[<span class="hljs-string">'type'</span>]}</span>'</span>);
    debugPrint(<span class="hljs-string">'Token: <span class="hljs-subst">${paymentMethodData[<span class="hljs-string">'tokenizationData'</span>][<span class="hljs-string">'token'</span>]}</span>'</span>);
    debugPrint(<span class="hljs-string">'Card Network: <span class="hljs-subst">${paymentMethodData[<span class="hljs-string">'info'</span>][<span class="hljs-string">'cardNetwork'</span>]}</span>'</span>);
  }
}
</code></pre>
<h3 data-id="heading-42">常见测试场景</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 测试不同金额</span>
<span class="hljs-keyword">final</span> testAmounts = [
  PaymentItem(label: <span class="hljs-string">'小额测试'</span>, amount: <span class="hljs-string">'1.00'</span>, status: PaymentItemStatus.final_price),
  PaymentItem(label: <span class="hljs-string">'标准测试'</span>, amount: <span class="hljs-string">'99.99'</span>, status: PaymentItemStatus.final_price),
  PaymentItem(label: <span class="hljs-string">'大额测试'</span>, amount: <span class="hljs-string">'999.99'</span>, status: PaymentItemStatus.final_price),
];

<span class="hljs-comment">// 测试待定价格（如运费计算中）</span>
<span class="hljs-keyword">final</span> pendingItems = [
  PaymentItem(label: <span class="hljs-string">'商品'</span>, amount: <span class="hljs-string">'50.00'</span>, status: PaymentItemStatus.final_price),
  PaymentItem(label: <span class="hljs-string">'运费'</span>, amount: <span class="hljs-string">'0.00'</span>, status: PaymentItemStatus.pending), <span class="hljs-comment">// 待计算</span>
];
</code></pre>
<h2 data-id="heading-43">常见问题</h2>
<h3 data-id="heading-44">Q1: Apple Pay 按钮不显示？</h3>
<p><strong>可能原因与解决方案</strong>:</p>
<ol>
<li>
<p><strong>设备未添加支付卡</strong></p>
<ul>
<li>在设置 → 钱包与 Apple Pay 中添加卡片</li>
</ul>
</li>
<li>
<p><strong>Merchant ID 配置错误</strong></p>
<ul>
<li>检查 Xcode 中的 Merchant ID 是否与配置文件一致</li>
<li>确认 Apple Developer 中已正确配置</li>
</ul>
</li>
<li>
<p><strong>模拟器限制</strong></p>
<ul>
<li>Apple Pay 在模拟器上支持有限，建议使用真机测试</li>
</ul>
</li>
</ol>
<h3 data-id="heading-45">Q2: Google Pay 返回 "Request Failed"？</h3>
<p><strong>解决方案</strong>:</p>
<ol>
<li>检查 <code>AndroidManifest.xml</code> 中的 meta-data 配置</li>
<li>确认 Google Play Services 已更新</li>
<li>检查配置文件中的 gateway 参数是否正确</li>
<li>确保设备已安装 Google Pay 应用</li>
</ol>
<h3 data-id="heading-46">Q3: 如何处理用户取消支付？</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">void</span> _onPaymentError(<span class="hljs-built_in">Object?</span> error) {
  <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">is</span> PlatformException) {
    <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'cancelled'</span>) {
      <span class="hljs-comment">// 用户取消了支付</span>
      debugPrint(<span class="hljs-string">'用户取消支付'</span>);
      <span class="hljs-keyword">return</span>;
    }
  }
  <span class="hljs-comment">// 其他错误</span>
  debugPrint(<span class="hljs-string">'支付错误: <span class="hljs-subst">$error</span>'</span>);
}
</code></pre>
<h3 data-id="heading-47">Q4: 如何自定义支付按钮？</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 使用 Pay 客户端手动触发支付</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPayButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;PaymentItem&gt; paymentItems;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;) onResult;

  <span class="hljs-keyword">const</span> CustomPayButton({
    <span class="hljs-keyword">super</span>.key,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.paymentItems,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.onResult,
  });

  Future&lt;<span class="hljs-keyword">void</span>&gt; _handlePayment() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> NativePayService.instance.showPaymentSheet(
        paymentItems: paymentItems,
      );
      onResult(result);
    } <span class="hljs-keyword">catch</span> (e) {
      debugPrint(<span class="hljs-string">'支付错误: <span class="hljs-subst">$e</span>'</span>);
    }
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> ElevatedButton(
      onPressed: _handlePayment,
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        padding: <span class="hljs-keyword">const</span> EdgeInsets.symmetric(vertical: <span class="hljs-number">16</span>, horizontal: <span class="hljs-number">32</span>),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Platform.isIOS ? Icons.apple : Icons.g_mobiledata),
          <span class="hljs-keyword">const</span> SizedBox(width: <span class="hljs-number">8</span>),
          Text(Platform.isIOS ? <span class="hljs-string">'Apple Pay'</span> : <span class="hljs-string">'Google Pay'</span>),
        ],
      ),
    );
  }
}
</code></pre>
<h3 data-id="heading-48">Q5: 如何支持多种货币？</h3>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 动态配置货币</span>
PaymentItem createPaymentItem({
  <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> label,
  <span class="hljs-keyword">required</span> <span class="hljs-built_in">double</span> amount,
  <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> currencyCode,
}) {
  <span class="hljs-comment">// 根据货币格式化金额</span>
  <span class="hljs-built_in">String</span> formattedAmount;
  <span class="hljs-keyword">switch</span> (currencyCode) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'JPY'</span>: <span class="hljs-comment">// 日元无小数</span>
      formattedAmount = amount.toInt().toString();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      formattedAmount = amount.toStringAsFixed(<span class="hljs-number">2</span>);
  }

  <span class="hljs-keyword">return</span> PaymentItem(
    label: label,
    amount: formattedAmount,
    status: PaymentItemStatus.final_price,
  );
}
</code></pre>
<h2 data-id="heading-49">生产环境检查清单</h2>
<h3 data-id="heading-50">通用检查</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 替换测试配置为生产配置</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 配置生产环境的支付网关密钥</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实现支付结果的服务端验证</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 添加支付失败重试机制</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 配置错误监控和日志</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 实现订单状态同步</li>
</ul>
<h3 data-id="heading-51">Apple Pay 检查</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 在 Apple Developer 中完成商户认证</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 上传支付处理证书到支付网关</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 测试所有支持的卡网络</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 验证 Merchant ID 配置</li>
</ul>
<h3 data-id="heading-52">Google Pay 检查</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 申请 Google Pay 生产环境访问权限</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 设置 <code>"environment": "PRODUCTION"</code></li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 配置正确的 <code>merchantId</code></li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 完成 Google Pay API 集成检查清单</li>
</ul>
<h2 data-id="heading-53">参考资源</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fpay" target="_blank" title="https://pub.dev/packages/pay" ref="nofollow noopener noreferrer">pay 插件官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fpay%2Fapi" target="_blank" title="https://developers.google.com/pay/api" ref="nofollow noopener noreferrer">Google Pay API 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fapple-pay%2F" target="_blank" title="https://developer.apple.com/apple-pay/" ref="nofollow noopener noreferrer">Apple Pay 开发文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fpay%2Fapi%2Fweb%2Fguides%2Fbrand-guidelines" target="_blank" title="https://developers.google.com/pay/api/web/guides/brand-guidelines" ref="nofollow noopener noreferrer">Google Pay 品牌指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdesign%2Fhuman-interface-guidelines%2Fapple-pay" target="_blank" title="https://developer.apple.com/design/human-interface-guidelines/apple-pay" ref="nofollow noopener noreferrer">Apple Pay 人机界面指南</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 环境搭建 5 步走（零基础友好）]]></title>    <link>https://juejin.cn/post/7585206549305606207</link>    <guid>https://juejin.cn/post/7585206549305606207</guid>    <pubDate>2025-12-19T08:12:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206549305606207" data-draft-id="7585173051647000612" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 环境搭建 5 步走（零基础友好）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T08:12:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="微笑的曙光"/> <meta itemprop="url" content="https://juejin.cn/user/3458394913521387"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 环境搭建 5 步走（零基础友好）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3458394913521387/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    微笑的曙光
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:12:49.000Z" title="Fri Dec 19 2025 08:12:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>Vue.js渐进式前端框架，聚焦视图层，以数据驱动、组件化为核心。其响应式数据系统实现数据与视图双向绑定，无需手动操作DOM；组件化设计降低大型项目开发复杂度。框架轻量灵活，可按需集成Vue Router、Pinia/Vuex、Vite等生态工具。Vue 2稳定、生态成熟，Vue3适配TypeScript且性能优化。它学习成本低，中文文档完善，广泛应用于单页应用、后台管理系统、移动端H5、小程序等场景，是企业级前端开发的主流选择。</p>
</blockquote>
<p>Vue3 官方推荐使用 <strong>Vite</strong> 作为构建工具（比传统 Vue CLI 更快、更轻量化），以下是基于 Vite 的 5 步极简搭建流程，兼顾易操作和实用性：</p>
<h2 data-id="heading-0">如图：</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1fe00df4bed4db2940e12a812b34058~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6u56yR55qE5puZ5YWJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736769&amp;x-signature=n7GGF4zpswxBSQG6pv%2FvIfQu%2Fzk%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-1">一、 安装 Node.js（核心依赖）</h3>
<p>Vue3 项目依赖 Node.js 环境（提供 npm/yarn 包管理工具），要求 Node.js 版本 ≥ 18.0（推荐 LTS 版本，如 20.x）。</p>
<ul>
<li>下载：访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2F" target="_blank" title="https://nodejs.org/" ref="nofollow noopener noreferrer">Node.js 官网</a>，选择对应系统（Windows/Mac/Linux）的安装包，一键安装（Windows 建议勾选「Add to PATH」）。</li>
<li>验证：打开终端/CMD，输入以下命令，能显示版本号即成功：
<pre><code class="hljs language-bash" lang="bash">node -v   <span class="hljs-comment"># 如 v20.10.0</span>
npm -v    <span class="hljs-comment"># 如 v10.2.3</span>
</code></pre>
</li>
<li>可选优化（加快 npm 下载速度）：配置淘宝镜像源
<pre><code class="hljs language-bash" lang="bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com
</code></pre>
</li>
</ul>
<h3 data-id="heading-2">二、安装 Vite 项目创建器（全局）</h3>
<p>Vite 是 Vue3 官方推荐的构建工具，先全局安装「Vite 项目脚手架」：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g create-vite
</code></pre>
<ul>
<li>若提示权限不足（Mac/Linux）：加 <code>sudo</code> 前缀
<pre><code class="hljs language-bash" lang="bash">sudo npm install -g create-vite
</code></pre>
</li>
<li>备选：若习惯 Vue CLI，可安装 <code>npm install -g @vue/cli@latest</code>（Vue CLI 5+ 支持 Vue3）。</li>
</ul>
<h3 data-id="heading-3">三、创建 Vue3 项目</h3>
<p>在终端进入你想存放项目的目录（如 <code>cd ~/Desktop</code>），执行以下命令创建项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># create-vite 项目名 --template vue（指定 Vue3 模板）</span>
create-vite my-vue3-app --template vue
</code></pre>
<ul>
<li><code>my-vue3-app</code> 是自定义项目名（可改，如 <code>vue3-demo</code>）；</li>
<li>执行后，终端会提示「进入项目目录 + 安装依赖」，先按提示进入项目：
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> my-vue3-app  <span class="hljs-comment"># 进入项目根目录</span>
</code></pre>
</li>
<li>安装项目依赖（核心步骤，缺一不可）：
<pre><code class="hljs language-bash" lang="bash">npm install
</code></pre>
</li>
</ul>
<h3 data-id="heading-4">四、启动开发服务器</h3>
<p>依赖安装完成后，启动本地开发服务：</p>
<pre><code class="hljs language-bash" lang="bash">npm run dev
</code></pre>
<ul>
<li>执行成功后，终端会输出访问地址（如 <code>http://127.0.0.1:5173/</code>）；</li>
<li>复制地址到浏览器打开，能看到 Vue3 默认欢迎页面，说明项目启动成功！</li>
</ul>
<h3 data-id="heading-5">五、验证运行 + 基础配置</h3>
<h4 data-id="heading-6">1. 验证功能</h4>
<ul>
<li>浏览器打开 <code>http://127.0.0.1:5173/</code>，能看到 Vue3 标志和「Hello Vue 3 + Vite」文字，即搭建完成；</li>
<li>测试热更新：打开项目文件夹，编辑 <code>src/App.vue</code>（如修改 <code>&lt;h1&gt;</code> 里的文字），保存后浏览器会自动刷新，验证热重载功能。</li>
</ul>
<h4 data-id="heading-7">2. 基础配置（可选但实用）</h4>
<ul>
<li>打包项目：开发完成后，执行 <code>npm run build</code>，会生成 <code>dist</code> 文件夹（可部署到服务器）；</li>
<li>安装调试工具：浏览器安装「Vue Devtools」扩展（<a href="https://link.juejin.cn?target=https%3A%2F%2Fchromewebstore.google.com%2Fdetail%2Fvuejs-devtools%2Fnhdogjmejiglipccpnnnanhbledajbpd" target="_blank" title="https://chromewebstore.google.com/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" ref="nofollow noopener noreferrer">Chrome 应用商店</a>），可调试 Vue3 组件、状态；</li>
<li>扩展功能：如需用 TypeScript，创建项目时改模板为 <code>--template vue-ts</code>。</li>
</ul>
<h3 data-id="heading-8">六、核心注意事项</h3>
<ol>
<li>若端口被占用（如 5173），Vite 会自动切换端口（如 5174），以终端输出为准；</li>
<li>Windows 若终端识别不了 <code>npm</code>，重启终端/电脑（确保 Node.js 已加入环境变量）；</li>
<li>若依赖安装失败，可删除项目下的 <code>node_modules</code> 文件夹，重新执行 <code>npm install</code>。</li>
</ol>
<p>至此，Vue3 开发环境已完全搭建，可直接在 <code>src</code> 目录下编写组件、开发业务逻辑！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[对比理解 Vue 响应式 API：data(), ref、reactive、computed 与 watch 详解]]></title>    <link>https://juejin.cn/post/7585180150254714895</link>    <guid>https://juejin.cn/post/7585180150254714895</guid>    <pubDate>2025-12-19T08:18:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585180150254714895" data-draft-id="7585130590292819983" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="对比理解 Vue 响应式 API：data(), ref、reactive、computed 与 watch 详解"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-12-19T08:18:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="爱分享的鱼鱼"/> <meta itemprop="url" content="https://juejin.cn/user/3901536646733133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            对比理解 Vue 响应式 API：data(), ref、reactive、computed 与 watch 详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3901536646733133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    爱分享的鱼鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:18:29.000Z" title="Fri Dec 19 2025 08:18:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue 开发中，理解响应式数据的概念以及如何正确使用不同的响应式 API 是非常重要的。本文将详细介绍 Vue 2 中的 data 选项、Vue 3 Composition API 中的 ref、reactive、toRefs 和 toRef 函数之间的区别和使用场景，同时也会介绍 computed 和 watch 的区别与使用场景。</p>
<h2 data-id="heading-0">基本概念</h2>
<p>响应式数据（Reactive Data）指的是当数据发生变化时，使用该数据的界面会自动更新，而无需手动操作DOM。
响应式数据具有以下特征：</p>
<ol>
<li><strong>自动追踪变化</strong>：框架会自动监测数据的变化</li>
<li><strong>依赖关系建立</strong>：框架知道哪些视图依赖哪些数据</li>
<li><strong>自动更新视图</strong>：当数据变化时，相关视图会自动重新渲染</li>
</ol>
<h2 data-id="heading-1">1. Vue 2 中的 data 选项</h2>
<p>在 Vue 2 中，我们通常在组件的 data 选项中定义响应式数据。</p>
<h3 data-id="heading-2">1.1 基本用法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue!'</span>,
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
      }
    }
  }
}
</code></pre>
<h3 data-id="heading-3">1.2 特点</h3>
<ul>
<li>data 必须是一个函数，返回一个包含响应式数据的对象</li>
<li>Vue 会递归地将 data 中的所有属性转换为 getter/setter</li>
<li>访问和修改数据时不需要使用 <code>.value</code></li>
<li>适用于 Options API</li>
</ul>
<h2 data-id="heading-4">2. Vue 3 中的 ref</h2>
<p>ref 是 Vue 3 Composition API 中的一个函数，用于创建一个响应式的引用。</p>
<h3 data-id="heading-5">2.1 基本用法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 基本类型</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Hello Vue 3!'</span>)

<span class="hljs-comment">// 对象类型</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
})

<span class="hljs-comment">// 访问值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">value</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 'Alice'</span>

<span class="hljs-comment">// 修改值</span>
count.<span class="hljs-property">value</span>++
user.<span class="hljs-property">value</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'Bob'</span>
</code></pre>
<h3 data-id="heading-6">2.2 特点</h3>
<ul>
<li>可以包装任何类型的值（基本类型、对象、数组等）</li>
<li>返回一个带有 <code>.value</code> 属性的响应式引用对象</li>
<li>在模板中使用时，Vue 会自动解包，无需使用 <code>.value</code></li>
<li>适用于需要将基本类型变为响应式的场景</li>
</ul>
<h2 data-id="heading-7">3. Vue 3 中的 reactive</h2>
<p>reactive 是 Vue 3 Composition API 中的另一个重要函数，用于创建响应式对象。</p>
<h3 data-id="heading-8">3.1 基本用法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue 3!'</span>,
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
  }
})

<span class="hljs-comment">// 访问值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>) <span class="hljs-comment">// 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 'Alice'</span>

<span class="hljs-comment">// 修改值</span>
state.<span class="hljs-property">count</span>++
state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'Bob'</span>
</code></pre>
<h3 data-id="heading-9">3.2 特点</h3>
<ul>
<li>只能用于对象和数组（不能用于基本类型）</li>
<li>返回原始对象的代理（Proxy）</li>
<li>不需要使用 <code>.value</code> 访问属性</li>
<li>对对象进行深层响应式转换</li>
</ul>
<h2 data-id="heading-10">4. 四者之间的详细对比</h2>





























































<table><thead><tr><th>特性</th><th>data (Vue 2)</th><th>ref</th><th>reactive</th><th>toRefs</th><th>toRef</th></tr></thead><tbody><tr><td>Vue 版本</td><td>Vue 2</td><td>Vue 3</td><td>Vue 3</td><td>Vue 3</td><td>Vue 3</td></tr><tr><td>API 类型</td><td>Options API</td><td>Composition API</td><td>Composition API</td><td>Composition API</td><td>Composition API</td></tr><tr><td>数据类型支持</td><td>任意类型</td><td>任意类型</td><td>仅对象/数组</td><td>对象属性</td><td>单个对象属性</td></tr><tr><td>访问方式</td><td>直接访问</td><td>.value 访问（模板中除外）</td><td>直接访问</td><td>.value 访问</td><td>.value 访问</td></tr><tr><td>解构支持</td><td>不支持</td><td>支持（但失去响应性）</td><td>支持（但失去响应性）</td><td>支持（保持响应性）</td><td>支持（保持响应性）</td></tr><tr><td>自动解包</td><td>不适用</td><td>模板中自动解包</td><td>不适用</td><td>不适用</td><td>不适用</td></tr></tbody></table>
<h2 data-id="heading-11">5. 使用场景推荐</h2>
<h3 data-id="heading-12">5.1 何时使用 data</h3>
<ul>
<li>使用 Vue 2 项目时</li>
<li>使用 Options API 时</li>
<li>需要在组件选项中定义响应式数据时</li>
</ul>
<h3 data-id="heading-13">5.2 何时使用 ref</h3>
<ul>
<li>需要将基本类型（字符串、数字、布尔值）变为响应式时</li>
<li>需要重新分配整个对象时</li>
<li>在模板中需要直接使用变量名（而非对象属性）时</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 适合使用 ref 的场景</span>
<span class="hljs-keyword">const</span> isVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> userName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Alice'</span>)

<span class="hljs-comment">// 切换整个对象</span>
<span class="hljs-keyword">let</span> user = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
})

user.<span class="hljs-property">value</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
}
</code></pre>
<h3 data-id="heading-14">5.3 何时使用 reactive</h3>
<ul>
<li>需要创建包含多个相关属性的响应式状态对象时</li>
<li>处理复杂的数据结构时</li>
<li>不需要重新分配整个对象，只需要修改对象属性时</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 适合使用 reactive 的场景</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
  },
  <span class="hljs-attr">permissions</span>: [<span class="hljs-string">'read'</span>, <span class="hljs-string">'write'</span>],
  <span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">true</span>
})
</code></pre>
<h3 data-id="heading-15">5.4 何时使用 toRefs 和 toRef</h3>
<ul>
<li>需要将 reactive 对象的属性解构为独立的响应式引用时</li>
<li>需要将 reactive 对象的部分属性传递给其他函数时</li>
<li>需要保持解构后属性的响应性时</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 适合使用 toRefs 的场景</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">permissions</span>: []
})

<span class="hljs-comment">// 解构但仍保持响应性</span>
<span class="hljs-keyword">const</span> { count, name } = <span class="hljs-title function_">toRefs</span>(state)

<span class="hljs-comment">// 适合使用 toRef 的场景</span>
<span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">'count'</span>)
<span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">'name'</span>)
</code></pre>
<h2 data-id="heading-16">6. 注意事项与最佳实践</h2>
<h3 data-id="heading-17">6.1 ref 的注意事项</h3>
<ol>
<li>在 JavaScript 中访问 ref 的值时必须使用 <code>.value</code></li>
<li>解构 ref 会失去响应性</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> { value } = count <span class="hljs-comment">// 错误：失去了响应性</span>
</code></pre>
<h3 data-id="heading-18">6.2 reactive 的注意事项</h3>
<ol>
<li>不能用于基本类型</li>
<li>替换 reactive 对象本身不会保持响应性</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })

<span class="hljs-comment">// 错误：这将失去响应性</span>
state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> })
</code></pre>
<ol start="3">
<li>解构 reactive 对象会失去响应性</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> })
<span class="hljs-keyword">const</span> { count } = state <span class="hljs-comment">// 错误：失去了响应性</span>
</code></pre>
<h3 data-id="heading-19">6.3 最佳实践</h3>
<ol>
<li><strong>基本类型用 ref，对象类型优先考虑 reactive</strong></li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 推荐</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">users</span>: [],
  <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>
})
</code></pre>
<ol start="2">
<li><strong>组合使用 ref 和 reactive</strong></li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 复杂状态使用 reactive</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">users</span>: [],
  <span class="hljs-attr">pagination</span>: {
    <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>
  }
})

<span class="hljs-comment">// 简单状态使用 ref</span>
<span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">const</span> errorMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
</code></pre>
<ol start="3">
<li><strong>使用 toRefs 解构 reactive 对象</strong></li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { reactive, toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>
})

<span class="hljs-comment">// 正确的解构方式</span>
<span class="hljs-keyword">const</span> { count, name } = <span class="hljs-title function_">toRefs</span>(state)
</code></pre>
<ol start="4">
<li><strong>使用 toRef 创建单个响应式引用</strong></li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { reactive, toRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>
})

<span class="hljs-comment">// 创建单个响应式引用</span>
<span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">'count'</span>)
<span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">'name'</span>)

<span class="hljs-comment">// 修改原始属性会影响 toRef 创建的引用</span>
state.<span class="hljs-property">count</span>++
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countRef.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 修改 toRef 创建的引用也会影响原始属性</span>
countRef.<span class="hljs-property">value</span>++
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>) <span class="hljs-comment">// 2</span>
</code></pre>
<h2 data-id="heading-20">7. 实际项目中的应用示例</h2>
<p>以下是在实际项目中使用这些 API 的示例：</p>
<h3 data-id="heading-21">7.1 使用 ref 处理表单状态</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> formData = <span class="hljs-title function_">ref</span>({
      <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-string">''</span>
    })
    
    <span class="hljs-keyword">const</span> isSubmitting = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">const</span> errorMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
      isSubmitting.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 提交表单逻辑</span>
      } <span class="hljs-keyword">catch</span> (error) {
        errorMessage.<span class="hljs-property">value</span> = error.<span class="hljs-property">message</span>
      } <span class="hljs-keyword">finally</span> {
        isSubmitting.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
      }
    }
    
    <span class="hljs-keyword">return</span> {
      formData,
      isSubmitting,
      errorMessage,
      handleSubmit
    }
  }
}
</code></pre>
<h3 data-id="heading-22">7.2 使用 reactive 管理复杂状态</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { reactive, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">users</span>: [],
      <span class="hljs-attr">filters</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">'active'</span>
      },
      <span class="hljs-attr">pagination</span>: {
        <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>,
        <span class="hljs-attr">total</span>: <span class="hljs-number">0</span>
      },
      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>
    })
    
    <span class="hljs-comment">// 计算属性</span>
    <span class="hljs-keyword">const</span> activeUsers = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> state.<span class="hljs-property">users</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">status</span> === <span class="hljs-string">'active'</span>)
    })
    
    <span class="hljs-keyword">return</span> {
      state,
      activeUsers
    }
  }
}
</code></pre>
<h2 data-id="heading-23">8. computed 与 watch 的区别</h2>
<p>在 Vue 开发中，除了响应式数据外，我们还需要处理派生状态和副作用。这就需要用到 computed 和 watch。</p>
<h3 data-id="heading-24">8.1 computed（计算属性）</h3>
<p>computed 用于声明式地描述依赖响应式数据的复杂逻辑，创建一个响应式的只读值。</p>
<h4 data-id="heading-25">基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)

<span class="hljs-comment">// 只读计算属性</span>
<span class="hljs-keyword">const</span> doubled = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)

<span class="hljs-comment">// 可写的计算属性</span>
<span class="hljs-keyword">const</span> writableComputed = <span class="hljs-title function_">computed</span>({
  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>,
  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
    count.<span class="hljs-property">value</span> = val / <span class="hljs-number">2</span>
  }
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled.<span class="hljs-property">value</span>) <span class="hljs-comment">// 0</span>

count.<span class="hljs-property">value</span>++
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span>
</code></pre>
<h4 data-id="heading-26">特点</h4>
<ul>
<li>基于响应式依赖进行缓存，只有依赖发生改变时才会重新计算</li>
<li>默认是只读的，但也可以创建可写的计算属性</li>
<li>适用于复杂的逻辑计算，避免在模板中放入太多逻辑</li>
<li>在模板中使用时会被自动解包，无需使用 <code>.value</code></li>
</ul>
<h3 data-id="heading-27">8.2 watch（侦听器）</h3>
<p>watch 用于监听响应式数据的变化并在变化时执行副作用。</p>
<h4 data-id="heading-28">基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
})

<span class="hljs-comment">// 侦听单个 ref</span>
<span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
})

<span class="hljs-comment">// 侦听 getter 函数</span>
<span class="hljs-title function_">watch</span>(
  <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">value</span>.<span class="hljs-property">name</span>,
  <span class="hljs-function">(<span class="hljs-params">newName, oldName</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldName}</span> to <span class="hljs-subst">${newName}</span>`</span>)
  }
)

<span class="hljs-comment">// 侦听多个数据源</span>
<span class="hljs-title function_">watch</span>(
  [count, <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">value</span>.<span class="hljs-property">name</span>],
  <span class="hljs-function">(<span class="hljs-params">[newCount, newName], [oldCount, oldName]</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count: <span class="hljs-subst">${oldCount}</span> -&gt; <span class="hljs-subst">${newCount}</span>`</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name: <span class="hljs-subst">${oldName}</span> -&gt; <span class="hljs-subst">${newName}</span>`</span>)
  }
)

<span class="hljs-comment">// 深度侦听</span>
<span class="hljs-title function_">watch</span>(
  user,
  <span class="hljs-function">(<span class="hljs-params">newUser, oldUser</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'user changed'</span>, newUser, oldUser)
  },
  { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> }
)
</code></pre>
<h4 data-id="heading-29">特点</h4>
<ul>
<li>用于执行副作用，如 API 请求、手动 DOM 操作等</li>
<li>不会缓存，只要依赖发生变化就会执行</li>
<li>可以监听单个或多个数据源</li>
<li>支持深度监听、立即执行等选项</li>
</ul>
<h3 data-id="heading-30">8.3 computed 与 watch 的区别对比</h3>



































<table><thead><tr><th>特性</th><th>computed</th><th>watch</th></tr></thead><tbody><tr><td>主要用途</td><td>创建响应式只读值</td><td>执行副作用</td></tr><tr><td>缓存机制</td><td>有缓存，依赖不变时不重新计算</td><td>无缓存，每次变化都执行</td></tr><tr><td>返回值</td><td>返回一个不可变的响应式对象</td><td>无返回值（执行副作用）</td></tr><tr><td>使用场景</td><td>复杂逻辑计算、数据格式化</td><td>API 请求、异步操作、DOM 操作</td></tr><tr><td>执行时机</td><td>模板渲染时按需计算</td><td>数据变化时立即执行</td></tr></tbody></table>
<h2 data-id="heading-31">10. 总结</h2>
<p>选择使用哪种响应式 API 主要取决于以下因素：</p>
<ol>
<li><strong>Vue 版本</strong>：Vue 2 使用 data，Vue 3 可以使用 ref、reactive、toRefs 和 toRef</li>
<li><strong>数据类型</strong>：基本类型推荐使用 ref，对象类型可以使用 reactive</li>
<li><strong>使用场景</strong>：需要频繁替换整个值时使用 ref，处理复杂嵌套对象时使用 reactive</li>
<li><strong>API 风格</strong>：Options API 使用 data，Composition API 使用 ref、reactive、toRefs 和 toRef</li>
<li><strong>派生状态处理</strong>：需要缓存的派生值用 computed，需要执行副作用用 watch</li>
<li><strong>解构需求</strong>：需要解构 reactive 对象属性并保持响应性时使用 toRefs 或 toRef</li>
</ol>
<p>理解这些差异有助于我们在实际开发中做出更好的选择，写出更高效、更易维护的 Vue 代码。</p>
<pre><code class="hljs"/></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 Arco Table 迁移到 VTable：VTable使用经验分享]]></title>    <link>https://juejin.cn/post/7585289701826822153</link>    <guid>https://juejin.cn/post/7585289701826822153</guid>    <pubDate>2025-12-19T08:19:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585289701826822153" data-draft-id="7585180775705296923" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 Arco Table 迁移到 VTable：VTable使用经验分享"/> <meta itemprop="keywords" content="前端,开源,React.js"/> <meta itemprop="datePublished" content="2025-12-19T08:19:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码小学僧"/> <meta itemprop="url" content="https://juejin.cn/user/255519436842030"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 Arco Table 迁移到 VTable：VTable使用经验分享
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/255519436842030/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码小学僧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:19:04.000Z" title="Fri Dec 19 2025 08:19:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">VTable简介</h2>
<p>VTable: 不只是高性能的多维数据分析表格，更是行列间创作的方格艺术家！</p>
<p>在现代应用程序中，表格组件是不可或缺的一部分，它们能够快速展示大量数据，并提供良好的可视化效果和交互体验。VTable是一款基于可视化渲染引擎VRender的高性能表格组件库，为用户提供卓越的性能和强大的多维分析能力，以及灵活强大的图形能力。</p>
<p>官网链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable" target="_blank" title="https://visactor.com/vtable" ref="nofollow noopener noreferrer">visactor.com/vtable</a></p>
<p>github地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FVisActor%2FVTable" target="_blank" title="https://github.com/VisActor/VTable" ref="nofollow noopener noreferrer">github.com/VisActor/VT…</a></p>
<h2 data-id="heading-1">创建项目</h2>
<p>准备分享几个简单的实践案例，我目前主要使用的是基础表格ListTable在react项目中，所以案例基本也都是ListTable的，后续在项目中使用到了其他表格的过程中遇到值得分享的内容也会继续分享的。</p>
<p>全部代码示例: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLLmoskk%2Fvtable-demo" target="_blank" title="https://github.com/LLmoskk/vtable-demo" ref="nofollow noopener noreferrer">github.com/LLmoskk/vta…</a></p>
<p>在线预览: <a href="https://link.juejin.cn?target=https%3A%2F%2Fllmoskk.github.io%2Fvtable-demo%2F" target="_blank" title="https://llmoskk.github.io/vtable-demo/" ref="nofollow noopener noreferrer">llmoskk.github.io/vtable-demo…</a></p>
<p>先起一个react项目，经典vite起手，注: react-vtable React 19 还不被支持 我们需要使用18版本的react。</p>
<h2 data-id="heading-2">指挥 AI + MCP 快速准确的使用 vtable</h2>
<p>我目前使用的AI IDE是 AWS 的 krio，我们先添加context7 mcp， 这个mcp的作用是让ai获取最新的文档，避免使用过时的api。现在主流的IDE基本都支持添加MCP了，不在此一一举例。</p>
<pre><code class="hljs language-perl" lang="perl">{
  <span class="hljs-string">"mcpServers"</span>: {
    <span class="hljs-string">"context7"</span>: {
      <span class="hljs-string">"args"</span>: [
        <span class="hljs-string">"-y"</span>,
        <span class="hljs-string">"@upstash/context7-mcp@latest"</span>
      ],
      <span class="hljs-string">"command"</span>: <span class="hljs-string">"npx"</span>,
      <span class="hljs-string">"disabled"</span>: false,
      <span class="hljs-string">"autoApprove"</span>: [
        <span class="hljs-string">"resolve-library-id"</span>
      ]
    },
  }
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3127ad2a0089455d8bc40ce2b93e043c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=Wr0xNoOebrHxSYTHqp8lAdVcKgI%3D" alt="" loading="lazy"/></p>
<p>可以看到已经成功调用mcp工具去获取文档信息了。我要求他实现一个树形表格。</p>
<p>很快啊！ ai就写完了。效果还不错，这里就不贴代码了，没有太多参考价值，只是用来演示一下使用ai + mcp结合快速的实现vtable的功能，无需自己去翻阅文档了。</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a96efadf1664559944b567be3e9e49c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=IBxnNQFpyzLO2hW3gnmtYu0rvPU%3D" alt="" width="100%" loading="lazy"/>
<h2 data-id="heading-3">实现计算数据并持久化记忆修改拖拽列宽度</h2>
<p><strong>项目场景概述：</strong></p>
<p>在处理数据量较大的表格时，若将所有列的宽度固定为120px，可能会导致某些数据较少的列占据过多的空间。因此，提出了一个解决方案：动态调整列宽，根据数据值自动测量并设置每一列的最终宽度。</p>
<ol>
<li>
<p><strong>列宽自适应</strong>：通过分析表格前20行的数据，我们将动态计算各列的最佳宽度，以确保表格布局更加合理。</p>
</li>
<li>
<p><strong>用户自定义拖拽</strong>：允许用户手动拖动列边界调整列宽。拖拽后的宽度将在本地存储（localStorage）中保存，有效提升用户体验。</p>
</li>
<li>
<p><strong>加载优先级机制</strong>：表格加载时，将优先考虑以下顺序来设置列宽：</p>
<ol>
<li>本地存储中的宽度</li>
<li>自动计算得出的宽度</li>
<li>默认宽度设置</li>
</ol>
</li>
</ol>
<p>将编写一个名为 <code>use-column-width.ts</code> 的文件，封装一个自定义Hook。该Hook的功能是按照上述逻辑计算列宽，并与用户拖拽的宽度进行记忆。我们将利用ahook中的 <code>useLocalStorageState</code> 来保持状态信息同步存储到 localStorage 中。</p>
<p><del>测量文本宽度 ~~~~<em>参考文章</em> ~~~~<em><a href="https://juejin.cn/post/7091990279565082655" target="_blank" title="https://juejin.cn/post/7091990279565082655">juejin.cn/post/709199…</a></em>~~~~ <em>，</em> ~~~~完整代码不在这里贴出了可访问仓库自取 ~~~~<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLLmoskk%2Fvtable-demo%2Fblob%2Fmain%2Fsrc%2Fpages%2Fdemo1%2Futils%2Fcalculate-column-width.ts" target="_blank" title="https://github.com/LLmoskk/vtable-demo/blob/main/src/pages/demo1/utils/calculate-column-width.ts" ref="nofollow noopener noreferrer">github.com/LLmoskk/vta…</a></del></p>
<p>(不需要自己写了，可以用vtable写好的measureText 😅)</p>
<p>如果没有定制要求的话可以直接使用表格的 <code>自动列宽模式（autoWidth）</code> 已经帮忙计算过一遍了。</p>
<p>vtable文字测量方法: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FVisActor%2FVUtil%2Fblob%2Fmain%2Fpackages%2Fvutils%2Fsrc%2Fgraphics%2Ftext%2Fmeasure%2FtextMeasure.ts" target="_blank" title="https://github.com/VisActor/VUtil/blob/main/packages/vutils/src/graphics/text/measure/textMeasure.ts" ref="nofollow noopener noreferrer">github.com/VisActor/VU…</a></p>
<p>npm 地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40visactor%2Fvutils" target="_blank" title="https://www.npmjs.com/package/@visactor/vutils" ref="nofollow noopener noreferrer">www.npmjs.com/package/@vi…</a></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { useLocalStorageState } <span class="hljs-keyword">from</span> <span class="hljs-string">'ahooks'</span>;
<span class="hljs-keyword">import</span> { useCallback, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> <span class="hljs-title class_">ColumnDefine</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@visactor/vtable'</span>;
<span class="hljs-keyword">import</span> { calculateColumnsWidthMap } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/calculate-column-width'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Sort</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../type'</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">UseColumnWidthParams</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ColumnDefine</span>&gt; = {
  <span class="hljs-comment">/** 列配置数组 */</span>
  columns?: T[];
  <span class="hljs-comment">/** localStorage的key */</span>
  <span class="hljs-attr">storageKey</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 表格数据，用于计算列宽 */</span>
  data?: <span class="hljs-built_in">any</span>[];
  <span class="hljs-comment">/** 默认列 宽 */</span>
  defaultWidth?: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 视图ID */</span>
  viewId?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 是否已排序的信息 */</span>
  sorts?: <span class="hljs-title class_">Sort</span>[];
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">UseColumnWidthReturn</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ColumnDefine</span>&gt; = {
  <span class="hljs-comment">/** 应用了列宽的列配置（优先级：本地存储 &gt; 计算值 &gt; 默认值） */</span>
  <span class="hljs-attr">columnsWithWidth</span>: T[];
  <span class="hljs-comment">/** 保存列宽的函数 */</span>
  <span class="hljs-attr">saveColumnWidths</span>: <span class="hljs-function">(<span class="hljs-params">colWidths: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-comment">/** 列宽映射对象 */</span>
  <span class="hljs-attr">columnWidths</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;;
};

<span class="hljs-comment">/**
* 管理表格列宽持久化的hook
* 当columns的field顺序发生变化时，会自动清理不存在的列宽设置
*
* 列宽优先级：本地存储 &gt; 计算值 &gt; 默认值
*/</span>
<span class="hljs-keyword">const</span> useColumnWidth = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ColumnDefine</span>&gt;({
  columns,
  storageKey,
  data = [],
  defaultWidth = <span class="hljs-number">120</span>,
  sorts,
}: <span class="hljs-title class_">UseColumnWidthParams</span>&lt;T&gt;): <span class="hljs-title class_">UseColumnWidthReturn</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">const</span> [storedValue, setStoredValue] = useLocalStorageState&lt;<span class="hljs-built_in">any</span>&gt;(storageKey, {
    <span class="hljs-attr">defaultValue</span>: {},
  });
  <span class="hljs-keyword">const</span> columnWidths = storedValue;

  <span class="hljs-keyword">const</span> calculatedWidthMap = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span>
      <span class="hljs-title function_">calculateColumnsWidthMap</span>(
        columns,
        data,
        sorts,
      ),
    [columns, data, sorts],
  );

  <span class="hljs-comment">// 保存列宽到 localStorage</span>
  <span class="hljs-keyword">const</span> saveColumnWidths = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">colWidths: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">widthMap</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = {};
      columns?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">col, index</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (colWidths[index]) {
          widthMap[<span class="hljs-title class_">String</span>(col.<span class="hljs-property">field</span>)] = colWidths[index];
        }
      });

      <span class="hljs-title function_">setStoredValue</span>(widthMap);
    },
    [columns, setStoredValue],
  );

  <span class="hljs-comment">// 应用列宽到列配置</span>
  <span class="hljs-comment">// 优先级：本地存储 &gt; 计算值 &gt; 默认值</span>
  <span class="hljs-keyword">const</span> columnsWithWidth = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> columns?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">col</span>) =&gt;</span> {
      <span class="hljs-comment">// checkbox 固定 40 cellType 可能为函数</span>
      <span class="hljs-keyword">if</span> (col.<span class="hljs-property">cellType</span> === <span class="hljs-string">'checkbox'</span> || col.<span class="hljs-property">headerType</span> === <span class="hljs-string">'checkbox'</span>) {
        <span class="hljs-keyword">return</span> {
          ...col,
          <span class="hljs-attr">width</span>: <span class="hljs-number">40</span>,
        };
      }

      <span class="hljs-comment">// 优先使用本地存储的宽度</span>
      <span class="hljs-keyword">if</span> (columnWidths?.[<span class="hljs-title class_">String</span>(col.<span class="hljs-property">field</span>)]) {
        <span class="hljs-keyword">return</span> {
          ...col,
          <span class="hljs-attr">width</span>: columnWidths[<span class="hljs-title class_">String</span>(col.<span class="hljs-property">field</span>)],
        };
      }

      <span class="hljs-comment">// 其次使用计算的宽度</span>
      <span class="hljs-keyword">const</span> calculatedWidth = calculatedWidthMap.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">String</span>(col.<span class="hljs-property">field</span>));
      <span class="hljs-keyword">if</span> (calculatedWidth) {
        <span class="hljs-keyword">return</span> {
          ...col,
          <span class="hljs-attr">width</span>: calculatedWidth,
        };
      }

      <span class="hljs-comment">// 最后使用默认宽度</span>
      <span class="hljs-keyword">return</span> {
        ...col,
        <span class="hljs-attr">width</span>: defaultWidth,
      };
    });
  }, [columns, columnWidths, calculatedWidthMap, defaultWidth]);

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">columnsWithWidth</span>: columnsWithWidth || [],
    saveColumnWidths,
    <span class="hljs-attr">columnWidths</span>: columnWidths || {},
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useColumnWidth;
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30815046bb3b42d9af2179ad64d2b55a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=kZHTXIln4SDvlTEf8OUc%2Bi%2Fop2o%3D" alt="" width="100%" loading="lazy"/>
<h2 data-id="heading-4">主题切换</h2>
<p>vtable提供了<code>Arco design</code>的主题与 <code>Dark Mode</code>的主题，我的项目是由<code>Arco design</code>的table切换到vtable的，所以使用自官方提供的主题包，并且我的项目需要适配暗色模式，于是也用到了 <code>Dark Mode</code> 来定制修改了下，基本配置信息都可以在文档中查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable%2Foption%2FListTable%23theme" target="_blank" title="https://visactor.com/vtable/option/ListTable#theme" ref="nofollow noopener noreferrer">visactor.com/vtable/opti…</a></p>
<p>内置主题有五个</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">const</span> <span class="hljs-string">builtinThemes</span> <span class="hljs-string">=</span> [
    { <span class="hljs-attr">key:</span> <span class="hljs-string">'DEFAULT'</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">'默认主题'</span>, <span class="hljs-attr">theme:</span> <span class="hljs-string">themes.DEFAULT</span> },
    { <span class="hljs-attr">key:</span> <span class="hljs-string">'DARK'</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">'暗色主题'</span>, <span class="hljs-attr">theme:</span> <span class="hljs-string">themes.DARK</span> },
    { <span class="hljs-attr">key:</span> <span class="hljs-string">'BRIGHT'</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">'明亮主题'</span>, <span class="hljs-attr">theme:</span> <span class="hljs-string">themes.BRIGHT</span> },
    { <span class="hljs-attr">key:</span> <span class="hljs-string">'ARCO'</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">'Arco主题'</span>, <span class="hljs-attr">theme:</span> <span class="hljs-string">themes.ARCO</span> },
    { <span class="hljs-attr">key:</span> <span class="hljs-string">'SIMPLIFY'</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">'简约主题'</span>, <span class="hljs-attr">theme:</span> <span class="hljs-string">themes.SIMPLIFY</span> }
  ]<span class="hljs-string">;</span>
</code></pre>
<p>我们还可以extends主题进行扩展定制，我们系统中是由<code>Arco design</code>的Table组件迁移至vtable的，切换到ARCO主题后，发现还是和组件库的表格有些不同的，因此我做了些样式覆写。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { themes } <span class="hljs-keyword">from</span> <span class="hljs-string">"@visactor/vtable"</span>;

<span class="hljs-comment">/**
* 获取通用的 VTable 主题配置
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getCommonVTableTheme</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">return</span> themes.<span class="hljs-property">ARCO</span>.<span class="hljs-title function_">extends</span>({
            <span class="hljs-attr">frameStyle</span>: {
                <span class="hljs-attr">borderLineWidth</span>: <span class="hljs-number">0</span>,
            },
            <span class="hljs-attr">headerStyle</span>: {
                <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'#F0F1F5'</span>,
                <span class="hljs-attr">fontSize</span>: <span class="hljs-number">12</span>,
                <span class="hljs-attr">fontWeight</span>: <span class="hljs-number">400</span>,
                <span class="hljs-attr">autoWrapText</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">lineClamp</span>: <span class="hljs-number">3</span>,
            },
            <span class="hljs-attr">bodyStyle</span>: {
                <span class="hljs-comment">// 使用函数动态设置背景色，如果是 aggregation 行则使用 headerStyle 的样式</span>
                <span class="hljs-attr">bgColor</span>: <span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
                    <span class="hljs-comment">// 检查是否是 aggregation 行</span>
                    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">table</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args.<span class="hljs-property">table</span>.<span class="hljs-property">isAggregation</span> === <span class="hljs-string">'function'</span>) {
                        <span class="hljs-keyword">const</span> isAggregationCell = args.<span class="hljs-property">table</span>.<span class="hljs-title function_">isAggregation</span>(
                            args.<span class="hljs-property">col</span>,
                            args.<span class="hljs-property">row</span>,
                        );
                        <span class="hljs-keyword">if</span> (isAggregationCell) {
                            <span class="hljs-keyword">return</span> <span class="hljs-string">'#F0F1F5'</span>;
                        }
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-string">'#FFFFFF'</span>;
                },
            },
            <span class="hljs-attr">bottomFrozenStyle</span>: {
                <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'#F0F1F5'</span>,
                <span class="hljs-attr">fontWeight</span>: <span class="hljs-number">600</span>,
                <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,
            },
            <span class="hljs-attr">tooltipStyle</span>: {
                <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'black'</span>,
                <span class="hljs-attr">color</span>: <span class="hljs-string">'white'</span>,
                <span class="hljs-attr">fontSize</span>: <span class="hljs-number">12</span>,
                <span class="hljs-attr">padding</span>: [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
            },
            <span class="hljs-attr">scrollStyle</span>: {
                <span class="hljs-attr">visible</span>: <span class="hljs-string">'always'</span>, <span class="hljs-comment">// 滚动条始终显示</span>
                <span class="hljs-attr">hoverOn</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 滚动条不悬浮在内容上，而是独立显示</span>
            },
            <span class="hljs-attr">selectionStyle</span>: {
                <span class="hljs-attr">cellBgColor</span>: <span class="hljs-string">'rgba(133,165,242,0.2)'</span>,
            },
        });
    }
};
</code></pre>
<p>对单元格的条件定制，遍历列配置后可以单独根据条件设置单元格样式</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> salesColumn = baseColumns.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">col</span> =&gt;</span> col.<span class="hljs-property">field</span> === <span class="hljs-string">'sales'</span>);
  <span class="hljs-keyword">if</span> (salesColumn) {
    (salesColumn <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">style</span> = {
      <span class="hljs-attr">color</span>: <span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> value = args.<span class="hljs-property">dataValue</span>;
        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">150000</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'#059669'</span>; <span class="hljs-comment">// 绿色：高销售额</span>
        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">100000</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'#0891b2'</span>; <span class="hljs-comment">// 蓝色：中等销售额</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'#dc2626'</span>; <span class="hljs-comment">// 红色：低销售额</span>
      },
      <span class="hljs-attr">fontWeight</span>: <span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> args.<span class="hljs-property">dataValue</span> &gt;= <span class="hljs-number">150000</span> ? <span class="hljs-string">'bold'</span> : <span class="hljs-string">'normal'</span>;
      }
    };
  }
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be8a0b7cbbac4c1a8f6fe18aceb49e6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=QbPF%2F62PXrndTHn1RicVD2qgl%2FA%3D" alt="" width="100%" loading="lazy"/>
<h2 data-id="heading-5">表格转置与冻结表格</h2>
<p>冻结列功能配置: <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable%2Fguide%2Fbasic_function%2Ffrozen_column_row" target="_blank" title="https://visactor.com/vtable/guide/basic_function/frozen_column_row" ref="nofollow noopener noreferrer">visactor.com/vtable/guid…</a></p>
<p>在后台系统看表的时候一般需要固定左侧的几列。支持顶部、底部、左侧、右侧的冻结设置。</p>
<p>我在项目中遇到的问题就是切换主题到暗色的时候，表格固定按钮的图标没有跟随主题变化，通过查询文档得知可以注册 icon 自定义图标的一些配置。然后我从源码中获取到原始的 svg 传入跟随主题变化的 <code>frozen_color</code></p>
<p>注册icon: <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable%2Fguide%2Fcustom_define%2Fcustom_icon" target="_blank" title="https://visactor.com/vtable/guide/custom_define/custom_icon" ref="nofollow noopener noreferrer">visactor.com/vtable/guid…</a></p>
<pre><code class="hljs language-php" lang="php">export <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">registerVtableIcon</span> = (isDark?: <span class="hljs-keyword">boolean</span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">frozen_size</span> = <span class="hljs-number">22</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">frozen_size_2</span> = <span class="hljs-number">22</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">frozen_color</span> = isDark ? <span class="hljs-string">'#FFFFFF'</span> : <span class="hljs-string">'#282F38'</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">frozen_color_opacity</span> = <span class="hljs-string">'0.35'</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">freeze_color_opacity</span> = <span class="hljs-string">'0.2'</span>;

  register.<span class="hljs-title function_ invoke__">icon</span>(<span class="hljs-string">'frozen'</span>, {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'svg'</span>,
    <span class="hljs-attr">svg</span>:
      <span class="hljs-string">'&lt;svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"&gt;'</span> +
      `&lt;path d=<span class="hljs-string">"M8.49975 3.66663C8.32294 3.66663 8.15337 3.73686 8.02835 3.86189C7.90332 3.98691 7.83309 4.15648 7.83309 4.33329V9.63246C6.76475 10.2533 6.07942 11.1795 6.00625 12.2308C5.99892 12.2786 5.99692 12.3268 6.00009 12.3741L5.99975 12.4166C5.99975 12.5934 6.06999 12.763 6.19501 12.888C6.32004 13.0131 6.48961 13.0833 6.66642 13.0833H10.3333L10.3331 17.5L10.8611 18.292C10.8763 18.3148 10.8969 18.3335 10.9211 18.3464C10.9453 18.3594 10.9723 18.3662 10.9998 18.3662C11.0272 18.3662 11.0542 18.3594 11.0784 18.3464C11.1026 18.3335 11.1232 18.3148 11.1384 18.292L11.6664 17.5L11.6666 13.0833H15.3331C15.5099 13.0833 15.6795 13.0131 15.8045 12.888C15.9295 12.763 15.9998 12.5934 15.9998 12.4166C15.9998 12.4025 15.9998 12.3883 15.9994 12.3741C16.0028 12.3263 16.0008 12.2776 15.9933 12.2295C15.9196 11.1786 15.2343 10.2528 14.1664 9.63229V4.33329C14.1664 4.15648 14.0962 3.98691 13.9712 3.86189C13.8461 3.73686 13.6766 3.66663 13.4998 3.66663H8.49975Z"</span> fill=<span class="hljs-string">"${frozen_color}"</span> fill-opacity=<span class="hljs-string">"${frozen_color_opacity}"</span>/&gt;` +
      <span class="hljs-string">'&lt;/svg&gt;'</span>,
    <span class="hljs-attr">width</span>: frozen_size,
    <span class="hljs-attr">height</span>: frozen_size,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'frozen'</span>,
    <span class="hljs-attr">funcType</span>: IconFuncTypeEnum.frozen,
    <span class="hljs-attr">positionType</span>: IconPosition.right,
    <span class="hljs-attr">marginRight</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">hover</span>: {
      <span class="hljs-attr">width</span>: frozen_size_2,
      <span class="hljs-attr">height</span>: frozen_size_2,
      <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'rgba(101, 117, 168, 0.1)'</span>,
    },
    <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>,
  });

  register.<span class="hljs-title function_ invoke__">icon</span>(<span class="hljs-string">'freeze'</span>, {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'svg'</span>,
    <span class="hljs-attr">svg</span>:
      <span class="hljs-string">'&lt;svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"&gt;'</span> +
      <span class="hljs-string">'&lt;g clip-path="url(#clip0)"&gt;'</span> +
      `&lt;path d=<span class="hljs-string">"M17.1313 8.42047C17.1932 8.48238 17.2423 8.55587 17.2759 8.63676C17.3094 8.71764 17.3266 8.80434 17.3266 8.89189C17.3266 8.97944 17.3094 9.06613 17.2759 9.14702C17.2423 9.2279 17.1932 9.3014 17.1313 9.3633L13.3843 13.1103C13.7007 14.3048 13.5305 15.4443 12.8388 16.2395C12.8104 16.2781 12.7778 16.3136 12.7417 16.3451L12.712 16.3755C12.6501 16.4374 12.5766 16.4865 12.4957 16.52C12.4148 16.5535 12.3281 16.5707 12.2406 16.5707C12.153 16.5707 12.0663 16.5535 11.9854 16.52C11.9046 16.4865 11.8311 16.4374 11.7692 16.3755L9.17633 13.7826L6.05316 16.9058L5.11983 17.0925C5.09291 17.0979 5.06508 17.0965 5.03881 17.0886C5.01254 17.0806 4.98863 17.0663 4.96923 17.0469C4.94982 17.0275 4.9355 17.0036 4.92755 16.9773C4.9196 16.951 4.91827 16.9232 4.92366 16.8963L5.11033 15.963L8.23333 12.8396L5.64066 10.2471C5.57875 10.1852 5.52964 10.1117 5.49614 10.0309C5.46263 9.94997 5.44539 9.86327 5.44539 9.77572C5.44539 9.68817 5.46263 9.60148 5.49614 9.52059C5.52964 9.43971 5.57875 9.36621 5.64066 9.3043C5.65066 9.2943 5.66066 9.2843 5.67099 9.27464C5.70266 9.2383 5.73833 9.20547 5.77766 9.17664C6.57283 8.48564 7.71199 8.31564 8.90599 8.63197L12.6528 4.88497C12.7147 4.82306 12.7882 4.77395 12.8691 4.74045C12.95 4.70694 13.0367 4.6897 13.1242 4.6897C13.2118 4.6897 13.2985 4.70694 13.3794 4.74045C13.4603 4.77395 13.5338 4.82306 13.5957 4.88497L17.1312 8.42047H17.1313ZM15.7172 8.8918L13.1243 6.29914L9.56483 9.8588C9.47574 9.94788 9.36323 10.0099 9.24034 10.0376C9.11746 10.0654 8.98922 10.0578 8.87049 10.0156C8.22783 9.78764 7.63899 9.7553 7.17749 9.89814L12.1182 14.8388C12.261 14.3771 12.2287 13.7885 12.0007 13.146C11.9585 13.0272 11.9509 12.899 11.9787 12.7761C12.0064 12.6532 12.0684 12.5407 12.1575 12.4516L15.7172 8.89164V8.8918Z"</span> fill=<span class="hljs-string">"${frozen_color}"</span> fill-opacity=<span class="hljs-string">"${freeze_color_opacity}"</span>/&gt;` +
      <span class="hljs-string">'&lt;/g&gt;'</span> +
      <span class="hljs-string">'&lt;defs&gt;'</span> +
      <span class="hljs-string">'&lt;clipPath id="clip0"&gt;'</span> +
      <span class="hljs-string">'&lt;rect width="22" height="22" fill="white"/&gt;'</span> +
      <span class="hljs-string">'&lt;/clipPath&gt;'</span> +
      <span class="hljs-string">'&lt;/defs&gt;'</span> +
      <span class="hljs-string">'&lt;/svg&gt;'</span>,
    <span class="hljs-attr">width</span>: frozen_size,
    <span class="hljs-attr">height</span>: frozen_size,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'freeze'</span>,
    <span class="hljs-attr">funcType</span>: IconFuncTypeEnum.frozen,
    <span class="hljs-attr">positionType</span>: IconPosition.right,
    <span class="hljs-attr">marginRight</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">hover</span>: {
      <span class="hljs-attr">width</span>: frozen_size_2,
      <span class="hljs-attr">height</span>: frozen_size_2,
      <span class="hljs-attr">bgColor</span>: <span class="hljs-string">'rgba(101, 117, 168, 0.1)'</span>,
    },
    <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>,
  });
};
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47862d971e5342f7aca6dd83d6eef8a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=L1%2BcmUSRQbNUpxm46c9ZsaTk9TA%3D" alt="" width="100%" loading="lazy"/>
<p>表格转置设置下<code>transpose</code> 即可行转列，转置表格特别适合数据列很多但行数较少的场景，虽然目前我的项目中还未使用到。</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b59242eac427437e98fb499b5193a890~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=QXH8c3ccHq1xOOJMnfXWDGCvDdA%3D" alt="" width="100%" loading="lazy"/>
<h2 data-id="heading-6">表格尺寸配置</h2>
<p>行高列宽文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable%2Fguide%2Fbasic_function%2Frow_height_column_width" target="_blank" title="https://visactor.com/vtable/guide/basic_function/row_height_column_width" ref="nofollow noopener noreferrer">visactor.com/vtable/guid…</a></p>
<p>widthMode有三种模式 <code>'standard' | 'adaptive' | 'autoWidth'</code></p>
<p>如果没有业务特别定制的列宽要求的话，设置 <code>自动列宽模式（autoWidth）</code>最佳，可以根据列头和 body 单元格中的内容自动计算列宽度，忽略设置的 <code>width</code> 属性和 <code>defaultColWidth</code>。但计算会浪费一些性能，就看自己的取舍了。</p>
<p>还有值得注意的一点是最好设置表格 <code>maxWidth+minWidth</code>因为我们允许用户自由拖拽列宽了，但又不希望无限制，所以一般我都会加上边界限制。</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e88954cee6c74b02aa06a28fdcf55c20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=So45nmSoFyYRM%2FeYHNl9LaAWiak%3D" alt="" width="100%" loading="lazy"/>
<h2 data-id="heading-7">表头固定悬浮</h2>
<p>传统的dom表格可以设置表头粘性定位，但我使用vtable的时候想要实现这个功能，只能让整体vtable的dom粘性了，效果不是很好，最后想到的办法是让vtable的高度尽量保持一屏。就可以实现类似表头粘性定位的交互了。</p>
<pre><code class="hljs language-scss" lang="scss">  const <span class="hljs-selector-attr">[tableHeight, setTableHeight]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">500</span>); <span class="hljs-comment">// 默认撑开的一个高度</span>
  
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const calculateHeight = () =&gt; {
      <span class="hljs-comment">// 计算表格高度：视口高度 - 顶部导航栏(60) - 底部间距(16) - Tabs高度(36) - 分页器高度(32)</span>
      <span class="hljs-comment">// 目标是让表格高度占满一屏，这样当滚动到底部时，表格正好铺满屏幕</span>
      const <span class="hljs-attribute">height</span> = window<span class="hljs-selector-class">.innerHeight</span> - <span class="hljs-number">60</span> - <span class="hljs-number">16</span> - <span class="hljs-number">36</span> - <span class="hljs-number">32</span> - <span class="hljs-number">80</span>;
      <span class="hljs-built_in">setTableHeight</span>(Math.max(height, <span class="hljs-number">400</span>)); <span class="hljs-comment">// 设置最小高度</span>
    };

    <span class="hljs-built_in">calculateHeight</span>();
    window<span class="hljs-selector-class">.addEventListener</span>('resize', calculateHeight);

    return () =&gt; {
      window<span class="hljs-selector-class">.removeEventListener</span>('resize', calculateHeight);
    };
  }, <span class="hljs-selector-attr">[]</span>);
  
  &lt;ListTable
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attribute">height</span>={tableHeight}
  /&gt;
</code></pre>
<h2 data-id="heading-8">复制表格内容</h2>
<p>vtable支持添加 keyboardOptions copySelected 即可开启表格ctrl + c 复制到能力。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">keyboardOptions</span>={{
    copySelected: true,
}}
</code></pre>
<p>但是项目中的表格有些单元格我使用了 customRender 自定义渲染的能力，我将一个 json的数据转换为icon + 文本的呈现形式，这时候复制到话就会出问题。因此需要<code>formatCopyValue</code> <a href="https://link.juejin.cn?target=https%3A%2F%2Fvisactor.com%2Fvtable%2Foption%2FListTable%23formatCopyValue((value%3A%2520string)%2520%3D%253E%2520string)" target="_blank" title="https://visactor.com/vtable/option/ListTable#formatCopyValue((value:%20string)%20=%3E%20string)" ref="nofollow noopener noreferrer">visactor.com/vtable/opti…</a></p>
<pre><code class="hljs language-css" lang="css">{
  "<span class="hljs-attribute">icon</span>": <span class="hljs-string">"xxxx"</span>,
  <span class="hljs-string">"text"</span>: <span class="hljs-string">"Demo"</span>
}
</code></pre>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formatCopyValueForVTable = (<span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toStr</span> = (<span class="hljs-params">v: <span class="hljs-built_in">unknown</span></span>) =&gt; (v == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-title class_">String</span>(v));
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">toStr</span>(value);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">parseCell</span> = (<span class="hljs-params">cell: <span class="hljs-built_in">string</span></span>) =&gt; {
    <span class="hljs-keyword">const</span> trimmed = cell.<span class="hljs-title function_">trim</span>();
    <span class="hljs-keyword">if</span> (trimmed.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'{'</span>) &amp;&amp; trimmed.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'}'</span>)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(trimmed);
        <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span>) {
          <span class="hljs-comment">// 优先检查 describe 字段（asset 对象）</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-string">'describe'</span> <span class="hljs-keyword">in</span> obj) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">toStr</span>((obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">describe</span> ?? <span class="hljs-string">''</span>);
          }
          <span class="hljs-comment">// 其次检查 text 字段（icon-text 对象）</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-string">'text'</span> <span class="hljs-keyword">in</span> obj) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">toStr</span>((obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">text</span> ?? <span class="hljs-string">''</span>);
          }
        }
      } <span class="hljs-keyword">catch</span> (_) {
        <span class="hljs-comment">// 非合法 JSON，保持原样</span>
      }
    }
    <span class="hljs-keyword">return</span> cell;
  };

  <span class="hljs-keyword">return</span> value
    .<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">line</span>) =&gt;</span> line.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\t'</span>).<span class="hljs-title function_">map</span>(parseCell).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>))
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>);
};
</code></pre>
<p>这样复制出来的内容就正常了。</p>
<h2 data-id="heading-9">总结</h2>
<p>VTable 提供了高性能的表格使用体验，帮助开发者简化操作。其开放的可配置 API 选项丰富，基本满足各种业务开发需求。此外，Vtable 在响应问题和产品迭代方面也展现出快速高效的特点，为用户提供了优质的支持和服务。</p>
<p>感恩 Vtable 开源项目为我们带来了如此好用的工具，它的高性能和灵活配置极大地方便了我们的开发工作。开源的精神让更多的开发者受益，希望能够有更多此类优秀的开源项目继续涌现！开源万岁！</p>
<h2 data-id="heading-10">交流群 飞书与微信公众号</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d850b55efd984a80a1769657238a7fbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=rhqVlM65oXPDT2ffSPgY5I4cnGg%3D" alt="" loading="lazy"/><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/369036e1d70247b3a27a32630097e988~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB5bCP5a2m5YOn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737258&amp;x-signature=JMR3qGv0bC95doFJZBo9Uds%2BoCY%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 语言基础学习文档]]></title>    <link>https://juejin.cn/post/7585145251843997711</link>    <guid>https://juejin.cn/post/7585145251843997711</guid>    <pubDate>2025-12-19T08:21:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585145251843997711" data-draft-id="7584991956126711843" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 语言基础学习文档"/> <meta itemprop="keywords" content="Go"/> <meta itemprop="datePublished" content="2025-12-19T08:21:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宾燕哥哥"/> <meta itemprop="url" content="https://juejin.cn/user/3712397421843598"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 语言基础学习文档
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3712397421843598/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宾燕哥哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:21:15.000Z" title="Fri Dec 19 2025 08:21:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Go 语言基础学习文档</h2>
<h3 data-id="heading-1">一、环境搭建</h3>
<h4 data-id="heading-2">1.1 下载与安装</h4>
<ul>
<li>**官方下载地址：**<a href="https://link.juejin.cn?target=https%3A%2F%2Fgolang.org%2Fdl%2F" target="_blank" title="https://golang.org/dl/" ref="nofollow noopener noreferrer">golang.org/dl/</a></li>
<li>**官方镜像站（推荐）：**<a href="https://link.juejin.cn?target=https%3A%2F%2Fgolang.google.cn%2Fdl%2F" target="_blank" title="https://golang.google.cn/dl/" ref="nofollow noopener noreferrer">golang.google.cn/dl/</a></li>
<li>安装方式：傻瓜式安装（按提示下一步即可完成）</li>
</ul>
<h4 data-id="heading-3">1.2 安装验证</h4>
<ol>
<li>
<p><strong>验证有没有安装成功</strong></p>
<pre><code class="hljs language-cmd" lang="cmd">go version
</code></pre>
<p>打印输出类似”go version go1.24.2 windows/amd64“，说明安装成功。</p>
</li>
<li>
<p><strong>查看 Go 环境</strong></p>
<pre><code class="hljs language-cmd" lang="cmd">go env
</code></pre>
<blockquote>
<p><strong>Go1.11</strong> 版本之后无需手动配置环境变量，使用 <strong>go mod</strong> 管理项目，也不需要非得把项目放到 <strong>GOPATH</strong> 目录下，你可以在任意位置新建项目。</p>
<p><strong>Go1.13</strong> 以后可以彻底不要 <strong>GOPATH</strong> 了。</p>
</blockquote>
</li>
</ol>
<h4 data-id="heading-4">1.3 开发工具</h4>
<ol>
<li>推荐使用 <strong>VSCode</strong></li>
<li><strong>VSCode</strong> 安装 <strong>Go 语言插件</strong>（插件名称：Go）</li>
</ol>
<h3 data-id="heading-5">二、基础语法</h3>
<h4 data-id="heading-6">2.1 fmt 模块（格式化输出）</h4>
<h5 data-id="heading-7">2.1.1 Print</h5>
<p>用于基本打印输出，多参数打印无空格。</p>
<pre><code class="hljs language-go" lang="go">fmt.Print(<span class="hljs-string">"a"</span>)
<span class="hljs-comment">// a</span>

fmt.Print(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)
<span class="hljs-comment">// abc （PS:打印多个时，不会有空格）</span>
</code></pre>
<h5 data-id="heading-8">2.1.2 Println</h5>
<p>用于打印输出并支持格式化。</p>
<pre><code class="hljs language-go" lang="go">fmt.Println(<span class="hljs-string">"a"</span>)
<span class="hljs-comment">// a</span>
<span class="hljs-comment">// 换行</span>

fmt.Println(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)
<span class="hljs-comment">// a b c （PS:打印多个时，会有空格）</span>
<span class="hljs-comment">// 换行</span>
</code></pre>
<h5 data-id="heading-9">2.1.3 Printf</h5>
<p>用于格式化打印输出，支持占位符。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>

fmt.Printf(<span class="hljs-string">"a=%v,b=%v,c=%v"</span>, a, b, c)
<span class="hljs-comment">// a=1,b=2,c=3</span>

fmt.Printf(<span class="hljs-string">"a=%v,a的类型是%T"</span>, a, a)
<span class="hljs-comment">// a=1,a的类型是int</span>
</code></pre>
<h4 data-id="heading-10">2.2 变量与常量</h4>
<h5 data-id="heading-11">2.2.1 变量</h5>
<p>变量是程序运行过程中可以改变的量，Go 语言支持两种声明方式。</p>
<ol>
<li>
<p><strong>var 变量声明法</strong></p>
<ul>
<li>
<p>适用范围：可用于全局变量和局部变量。</p>
</li>
<li>
<p>基本用法</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 声明变量</span>
<span class="hljs-keyword">var</span> a <span class="hljs-type">string</span>
<span class="hljs-comment">// 变量赋值</span>
a = <span class="hljs-string">"a"</span>

<span class="hljs-comment">// 声明变量并赋值</span>
<span class="hljs-keyword">var</span> a <span class="hljs-type">string</span> = <span class="hljs-string">"a"</span>
<span class="hljs-comment">// 声明变量并赋值，简写（类型推导，可省略）</span>
vat a = <span class="hljs-string">"a"</span>

<span class="hljs-comment">// 一次声明多个变量（多个变量的类型都一样）</span>
<span class="hljs-keyword">var</span> a, b, c, <span class="hljs-type">string</span>
a = <span class="hljs-string">"a"</span>
b = <span class="hljs-string">"b"</span>
c = <span class="hljs-string">"c"</span>

<span class="hljs-comment">// 一次声明多个变量，（多个变量的类型可以不一样）</span>
<span class="hljs-keyword">var</span> (
	a <span class="hljs-type">string</span>
	b <span class="hljs-type">int</span>
	c <span class="hljs-type">bool</span>
)

<span class="hljs-comment">// 一次声明多个变量并赋值</span>
<span class="hljs-keyword">var</span> (
	a <span class="hljs-type">string</span> = <span class="hljs-string">"a"</span>
	b <span class="hljs-type">int</span>    = <span class="hljs-number">1</span>
	c <span class="hljs-type">bool</span>   = <span class="hljs-literal">true</span>
)

<span class="hljs-comment">// 一次声明多个变量并赋值，简写（类型推导，可省略）</span>
<span class="hljs-keyword">var</span> (
	a = <span class="hljs-string">"a"</span>
	b = <span class="hljs-number">1</span>
	c = <span class="hljs-literal">true</span>
)
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>短变量声明法</strong></p>
<ul>
<li>
<p>适用范围：仅用于函数内部的局部变量。</p>
</li>
<li>
<p>基本用法</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 声明变量并赋值</span>
a := <span class="hljs-string">"a"</span>

<span class="hljs-comment">// 一次声明多个变量并赋值</span>
a, b, c := <span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<h5 data-id="heading-12">2.2.2 常量</h5>
<p>常量是恒定不变的值，定义时必须赋值。</p>
<ol>
<li>
<p><strong>const 定义常量</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 声明常量并赋值</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-string">"a"</span>

<span class="hljs-comment">// 一次性声明多个常量并赋值</span>
<span class="hljs-keyword">const</span> (
	a = <span class="hljs-string">"a"</span>
    b = <span class="hljs-string">"b"</span>
)
</code></pre>
</li>
<li>
<p><strong>常量省略值的特性</strong></p>
<p>同时声明多个常量时，若省略值，则表示和上一行的值相同。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">const</span> (
	a = <span class="hljs-string">"a"</span>
	b
	c
)
fmt.Printf(<span class="hljs-string">"a = %v, b = %v, c = %v\n"</span>, a, b, c)
<span class="hljs-comment">// a = a, b = a, c = a</span>
</code></pre>
</li>
</ol>
<h4 data-id="heading-13">2.3 数据类型</h4>
<p>Go 语言数据类型分为 <strong>基本数据类型</strong> 和 <strong>复合数据类型</strong> 两大类。</p>
<ul>
<li>基本数据类型：整型、浮点型、布尔型、字符串</li>
<li>复合数据类型：数组、切片、结构体、函数、map、通道（channel）、接口等</li>
</ul>
<h5 data-id="heading-14">2.3.1 整型 int</h5>
<p>整型分为 <strong>有符号整型</strong> 和 <strong>无符号整型</strong> 两类，不同类型占用字节数不同。</p>
<ol>
<li>
<p><strong>声明示例</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span> = <span class="hljs-number">1</span>
fmt.Printf(<span class="hljs-string">"num=%v,类型=%T\n"</span>, num, num)
<span class="hljs-comment">// num=1,类型=int</span>
</code></pre>
</li>
<li>
<p><strong>整型分类</strong></p>

























































































<table><thead><tr><th>类型</th><th>有无符号</th><th>位数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>int8</td><td>有符号</td><td>8</td><td>-128 到 127（-2^7到2^7-1）</td><td/></tr><tr><td>int16</td><td>有符号</td><td>16</td><td>-32768 到 32767（-2^15到2^15-1）</td><td/></tr><tr><td>int32</td><td>有符号</td><td>32</td><td>-2147483648 到 2147483647（-2^31到2^31-1）</td><td>别名：rune</td></tr><tr><td>int64</td><td>有符号</td><td>64</td><td>-9223372036854775808 到 9223372036854775807（-2^63到2^63-1）</td><td/></tr><tr><td>uint8</td><td>无符号</td><td>8</td><td>0 到 255（0到2^8-1）</td><td>别名：byte</td></tr><tr><td>uint16</td><td>无符号</td><td>16</td><td>0 到 65535（0到2^16-1）</td><td/></tr><tr><td>uint32</td><td>无符号</td><td>32</td><td>0 到 4294967295（0到2^32-1）</td><td/></tr><tr><td>uint64</td><td>无符号</td><td>64</td><td>0 到 18446744073709551615（0到2^64-1）</td><td/></tr><tr><td>int</td><td>有符号</td><td>系统相关</td><td>32位系统同int32，64位系统同int64</td><td>推荐优先使用</td></tr><tr><td>uint</td><td>无符号</td><td>系统相关</td><td>32位系统同uint32，64位系统同uint64</td><td/></tr><tr><td>uintptr</td><td>无符号</td><td>系统相关</td><td>足够存储指针值的无符号整数</td><td>用于底层编程（如指针操作）</td></tr></tbody></table>
</li>
<li>
<p><strong>整型类型转换</strong></p>
<p>不同整型之间无法直接运算，需要强制类型转换，高位转低位时需注意数据溢出。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 不同类型直接运算报错</span>
<span class="hljs-keyword">var</span> num1 <span class="hljs-type">int8</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> num2 <span class="hljs-type">int16</span> = <span class="hljs-number">1</span>
fmt.Println(num1 + num2) <span class="hljs-comment">// 报错</span>

<span class="hljs-comment">// 强制类型转换后运算</span>
<span class="hljs-keyword">var</span> num1 <span class="hljs-type">int8</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> num2 <span class="hljs-type">int16</span> = <span class="hljs-number">1</span>
fmt.Println(<span class="hljs-type">int16</span>(num1) + num2) <span class="hljs-comment">// 输出：2</span>

<span class="hljs-comment">// 高位转低位的溢出问题</span>
<span class="hljs-keyword">var</span> num1 <span class="hljs-type">int16</span> = <span class="hljs-number">130</span>
fmt.Println(<span class="hljs-type">int8</span>(num1)) <span class="hljs-comment">// 输出：-126</span>
</code></pre>
</li>
<li>
<p><strong>数字字面量格式</strong></p>

























<table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>表示十进制输出</td></tr><tr><td>%b</td><td>表示二进制输出</td></tr><tr><td>%o</td><td>表示八进制输出</td></tr><tr><td>%x</td><td>表示十六进制输出</td></tr></tbody></table>
<p>示例代码</p>
<pre><code class="hljs language-go" lang="go">num := <span class="hljs-number">16</span>
fmt.Printf(<span class="hljs-string">"num=%v\n"</span>, num)  <span class="hljs-comment">// 输出：num=16</span>
fmt.Printf(<span class="hljs-string">"num=%d\n"</span>, num)  <span class="hljs-comment">// 输出：num=16</span>
fmt.Printf(<span class="hljs-string">"num=%b\n"</span>, num)  <span class="hljs-comment">// 输出：num=10000</span>
fmt.Printf(<span class="hljs-string">"num=%o\n"</span>, num)  <span class="hljs-comment">// 输出：num=20</span>
fmt.Printf(<span class="hljs-string">"num=%x\n"</span>, num)  <span class="hljs-comment">// 输出：num=10</span>
</code></pre>
</li>
<li>
<p><strong>获取变量占用字节数</strong></p>
<p>使用 <code>unsafe.Sizeof</code> 函数可以返回变量占用的字节数。</p>
<pre><code class="hljs language-go" lang="go">num1 := <span class="hljs-type">int</span>(<span class="hljs-number">1</span>)
num2 := <span class="hljs-type">int8</span>(<span class="hljs-number">1</span>)
num3 := <span class="hljs-type">int16</span>(<span class="hljs-number">1</span>)
num4 := <span class="hljs-type">int32</span>(<span class="hljs-number">1</span>)
num5 := <span class="hljs-type">int64</span>(<span class="hljs-number">1</span>)

fmt.Println(unsafe.Sizeof(num1)) <span class="hljs-comment">// 输出：8</span>
fmt.Println(unsafe.Sizeof(num2)) <span class="hljs-comment">// 输出：1</span>
fmt.Println(unsafe.Sizeof(num3)) <span class="hljs-comment">// 输出：2</span>
fmt.Println(unsafe.Sizeof(num4)) <span class="hljs-comment">// 输出：4</span>
fmt.Println(unsafe.Sizeof(num5)) <span class="hljs-comment">// 输出：8</span>
</code></pre>
</li>
</ol>
<h5 data-id="heading-15">2.3.2 浮点型 float</h5>
<p>Go 语言支持两种浮点型：<code>float32</code> 和 <code>float64</code>。</p>
<ol>
<li>
<p><strong>声明示例</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 类型推导，默认是float64</span>
num := <span class="hljs-number">3.1415926</span>
fmt.Printf(<span class="hljs-string">"num=%v,类型=%T\n"</span>, num, num) <span class="hljs-comment">// 输出：num=3.1415926,类型=float64</span>

<span class="hljs-comment">// 显式声明float32</span>
num1 := <span class="hljs-type">float32</span>(<span class="hljs-number">3.1415926</span>)
fmt.Printf(<span class="hljs-string">"num1=%v,类型=%T\n"</span>, num1, num1) <span class="hljs-comment">// 输出：num1=3.1415925,类型=float32</span>

<span class="hljs-comment">// 显式声明float64</span>
num2 := <span class="hljs-type">float64</span>(<span class="hljs-number">3.1415926</span>)
fmt.Printf(<span class="hljs-string">"num2=%v,类型=%T\n"</span>, num2, num2) <span class="hljs-comment">// 输出：num2=3.1415926,类型=float64</span>
</code></pre>
</li>
<li>
<p><strong>浮点型范围</strong></p>
<ul>
<li>
<p><code>float32</code>：最大范围约为 3.4e38</p>
</li>
<li>
<p><code>float64</code>：最大范围约为 1.8e308</p>
<p>示例代码</p>
<pre><code class="hljs language-go" lang="go">fmt.Println(math.MaxFloat32) <span class="hljs-comment">// 输出：3.4028234663852886e+38</span>
fmt.Println(math.MaxFloat64) <span class="hljs-comment">// 输出：1.7976931348623157e+308</span>
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>格式化输出</strong></p>
<p>使用 <code>%f</code> 占位符输出浮点型，可指定小数位数。</p>
<pre><code class="hljs language-go" lang="go">num1 := <span class="hljs-number">3.1415926</span>
fmt.Printf(<span class="hljs-string">"%v\n"</span>, num1)    <span class="hljs-comment">// 输出：3.1415926</span>
fmt.Printf(<span class="hljs-string">"%f\n"</span>, num1)    <span class="hljs-comment">// 输出：3.141593（默认保留6位，四舍五入）</span>
fmt.Printf(<span class="hljs-string">"%.2f\n"</span>, num1)  <span class="hljs-comment">// 输出：3.14（保留2位）</span>
fmt.Printf(<span class="hljs-string">"%.3f\n"</span>, num1)  <span class="hljs-comment">// 输出：3.142（保留3位）</span>
</code></pre>
</li>
<li>
<p><strong>科学计数法</strong></p>
<p>浮点型支持科学计数法表示。</p>
<pre><code class="hljs language-go" lang="go">num1 := <span class="hljs-number">3.14e2</span>
fmt.Printf(<span class="hljs-string">"num1=%v,类型=%T\n"</span>, num1, num1) <span class="hljs-comment">// 输出：num1=314,类型=float64</span>

num2 := <span class="hljs-number">3.14e-2</span>
fmt.Printf(<span class="hljs-string">"num2=%v,类型=%T\n"</span>, num2, num2) <span class="hljs-comment">// 输出：num2=0.0314,类型=float64</span>
</code></pre>
</li>
<li>
<p><strong>精度丢失问题</strong></p>
<p>二进制浮点数转换为十进制时可能存在精度丢失，可使用第三方包 <code>github.com/shopspring/decimal</code> 解决。</p>
<pre><code class="hljs language-go" lang="go">num := <span class="hljs-number">1129.6</span>
fmt.Println(num * <span class="hljs-number">100</span>) <span class="hljs-comment">// 输出：112959.99999999999</span>

num1 := <span class="hljs-number">8.2</span>
num2 := <span class="hljs-number">3.8</span>
fmt.Println(num1 - num2) <span class="hljs-comment">// 输出：4.3999999999999995</span>
</code></pre>
</li>
<li>
<p><strong>浮点型与整型转换</strong></p>
<ul>
<li>
<p>整型转浮点型：直接强制转换，不会丢失数据</p>
<pre><code class="hljs language-go" lang="go">num1 := <span class="hljs-number">3</span>
num2 := <span class="hljs-type">float32</span>(num1)
fmt.Printf(<span class="hljs-string">"num2=%v,类型=%T\n"</span>, num2, num2) <span class="hljs-comment">// 输出：num2=3,类型=float32</span>

num3 := <span class="hljs-type">float64</span>(num1)
fmt.Printf(<span class="hljs-string">"num3=%v,类型=%T\n"</span>, num3, num3) <span class="hljs-comment">// 输出：num3=3,类型=float64</span>
</code></pre>
</li>
<li>
<p>浮点型转整型：强制转换会丢失小数部分</p>
<pre><code class="hljs language-go" lang="go">num1 := <span class="hljs-number">3.14</span>
num2 := <span class="hljs-type">int</span>(num1)
fmt.Printf(<span class="hljs-string">"num2=%v,类型=%T\n"</span>, num2, num2) <span class="hljs-comment">// 输出：num2=3,类型=int</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<h5 data-id="heading-16">2.3.2 布尔类型 bool</h5>
<p>布尔型用 <code>bool</code> 表示，只有 <code>true</code> 和 <code>false</code> 两个值。</p>
<ol>
<li>
<p><strong>注意事项</strong></p>
<ul>
<li>布尔型变量默认值为 <code>false</code></li>
<li>不允许将整型强制转换为布尔型</li>
<li>布尔型无法参与数值运算，也无法与其他类型转换</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span>
fmt.Printf(<span class="hljs-string">"布尔类型的默认值=%v,类型=%T\n"</span>, flag, flag) <span class="hljs-comment">// 输出：布尔类型的默认值=false,类型=bool</span>

num := <span class="hljs-number">1</span>
flag = <span class="hljs-type">bool</span>(num) <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">if</span> num { <span class="hljs-comment">// 报错</span>
    fmt.Println(<span class="hljs-string">"num为真"</span>)
}

str := <span class="hljs-string">"hello"</span>
flag = <span class="hljs-type">bool</span>(str) <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">if</span> str { <span class="hljs-comment">// 报错</span>
    fmt.Println(<span class="hljs-string">"str为真"</span>)
}
</code></pre>
</li>
</ol>
<h5 data-id="heading-17">2.3.4 字符串</h5>
<p>字符串的值用双引号 <code>""</code> 或反引号 <code> ``</code> 包裹。</p>
<ol>
<li>
<p><strong>注意事项</strong></p>
<ul>
<li>双引号用于表示单行字符串，支持转义符。</li>
<li>反引号用于表示多行字符串，原样输出内容，不解析转义符。</li>
<li>单引号 <code>''</code> 用于表示字符，而非字符串。</li>
</ul>
</li>
<li>
<p><strong>字符串转义符</strong></p>
<p>常见转义符如下表：</p>

































<table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\'</td><td>单引号</td></tr><tr><td>\"</td><td>双引号</td></tr><tr><td>\\</td><td>反斜杠</td></tr></tbody></table>
<p>示例代码</p>
<pre><code class="hljs language-go" lang="go">str := <span class="hljs-string">"mumu: \"hello golang\""</span>
fmt.Println(str) <span class="hljs-comment">// 输出：mumu: "hello golang"</span>
</code></pre>
</li>
<li>
<p><strong>多行字符串</strong></p>
<p><strong>Go</strong> 语言中要定义一个多行字符串时，就必须使用反引号。</p>
<pre><code class="hljs language-go" lang="go">multiLine := <span class="hljs-string">`这是第一行
这是第二行
	这是带缩进的第三行
这是第四行`</span>
	fmt.Println(multiLine)
<span class="hljs-comment">// 这是第一行</span>
<span class="hljs-comment">// 这是第二行</span>
<span class="hljs-comment">//         这是带缩进的第三行</span>
<span class="hljs-comment">// 这是第四行</span>
</code></pre>
</li>
<li>
<p><strong>字符串常用的方法</strong></p>




























































<table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>len(str)</code></td><td>返回字符串字节数</td><td><code>str := "mumu"; fmt.Println(len(str)) // 输出：4</code></td></tr><tr><td><code>+</code></td><td>拼接字符串</td><td><code>fmt.Println("hello" + " golang") // 输出：hello golang</code></td></tr><tr><td><code>fmt.Sprintf</code></td><td>格式化拼接字符串</td><td><code>str1:="hello";str2:="golang";str3:=fmt.Sprintf("%v %v",str1,str2) // str3为hello golang</code></td></tr><tr><td><code>strings.Split(str, sep)</code></td><td>按分隔符分割字符串，返回切片</td><td><code>str:="hello golang";arr:=strings.Split(str," ");fmt.Println(arr) // 输出：[hello golang]</code></td></tr><tr><td><code>strings.Join(arr, sep)</code></td><td>将切片按分隔符合并为字符串</td><td><code>arr:=[]string{"hello","golang"};str:=strings.Join(arr,"-");fmt.Println(str) // 输出：hello-golang</code></td></tr><tr><td><code>strings.Contains(str1, str2)</code></td><td>判断 str1 是否包含 str2</td><td><code>str1:="hello golang";str2:="ello";fmt.Println(strings.Contains(str1,str2)) // 输出：true</code></td></tr><tr><td><code>strings.HasPrefix(str1, str2)</code></td><td>判断 str1 是否以 str2 开头</td><td><code>str1:="hello golang";str2:="hello";fmt.Println(strings.HasPrefix(str1,str2)) // 输出：true</code></td></tr><tr><td><code>strings.HasSuffix(str1, str2)</code></td><td>判断 str1 是否以 str2 结尾</td><td><code>str1:="hello golang";str2:="golang";fmt.Println(strings.HasSuffix(str1,str2)) // 输出：true</code></td></tr><tr><td><code>strings.Index(str, substr)</code></td><td>查找 substr 在 str 中首次出现的索引，不存在返回 -1</td><td><code>fmt.Println(strings.Index("hello golang","golang")) // 输出：6</code></td></tr><tr><td><code>strings.LastIndex(str, substr)</code></td><td>查找 substr 在 str 中最后出现的索引，不存在返回 -1</td><td><code>fmt.Println(strings.LastIndex("hello golang","an")) // 输出：9</code></td></tr></tbody></table>
</li>
</ol>
<h5 data-id="heading-18">2.3.5 byte &amp; rune</h5>
<p><code>byte</code> 和 <code>rune</code> 是 Go 语言中用于表示字符的专属类型，底层都是整型的别名。</p>
<ol>
<li>
<p><strong>byte 与 rune 的区别</strong></p>























<table><thead><tr><th>类型</th><th>底层类型</th><th>占用字节</th><th>适用场景</th></tr></thead><tbody><tr><td>byte</td><td>uint8</td><td>1</td><td>表示 ASCII 字符（0-127 范围）</td></tr><tr><td>rune</td><td>int32</td><td>4</td><td>表示 Unicode 字符（如中文、emoji 等）</td></tr></tbody></table>
</li>
<li>
<p><strong>字符串遍历</strong></p>
<ul>
<li>
<p><strong><code>for i</code> 循环遍历（按字节）</strong></p>
<p>Go 字符串底层是字节数组，<code>for i</code> 循环遍历的是每个字节的值。</p>
<pre><code class="hljs language-go" lang="go">s := <span class="hljs-string">"Hello 世界"</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ {
    fmt.Printf(<span class="hljs-string">"%x "</span>, s[i]) <span class="hljs-comment">// 输出：48 65 6c 6c 6f 20 e4 b8 96 e7 95 8c</span>
}
</code></pre>
</li>
<li>
<p><strong><code>for range</code> 遍历（按 rune）</strong></p>
<p><code>for range</code> 会自动将字符串按 Unicode 字符拆分，遍历的是 <code>rune</code> 类型的值。</p>
<pre><code class="hljs language-go" lang="go">s := <span class="hljs-string">"Hello 世界"</span>
<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s {
    fmt.Printf(<span class="hljs-string">"%c "</span>, r) <span class="hljs-comment">// 输出：H e l l o  世 界</span>
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>字符串长度计算</strong></p>
<ul>
<li>
<p><strong>len (str)：返回字节数</strong></p>
<p>对于包含多字节字符的字符串，字节数大于字符数。</p>
<pre><code class="hljs language-go" lang="go">str:= <span class="hljs-string">"go 你好"</span>
fmt.Println(<span class="hljs-built_in">len</span>(str)) <span class="hljs-comment">// 输出：9（go占2字节，空格占1，你好各占3，共2+1+3+3=9）</span>
</code></pre>
</li>
<li>
<p><strong>len ([] rune (str))：返回字符数</strong></p>
<p>将字符串转为 <code>rune</code> 切片后，再计算长度即可得到字符数。</p>
<pre><code class="hljs language-go" lang="go">str:= <span class="hljs-string">"go 你好"</span>
fmt.Println(<span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(str))) <span class="hljs-comment">// 输出：5</span>
</code></pre>
</li>
<li>
<p><strong>utf8.RuneCountInString (str)：返回字符数</strong></p>
<p>使用 <code>unicode/utf8</code> 包的函数直接获取字符数。</p>
<pre><code class="hljs language-go" lang="go">str:= <span class="hljs-string">"go 你好"</span>
fmt.Println(utf8.RuneCountInString(str)) <span class="hljs-comment">// 输出：5</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>持续更新中...</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一个定时器，理清 JavaScript 里的 this]]></title>    <link>https://juejin.cn/post/7585222924566151208</link>    <guid>https://juejin.cn/post/7585222924566151208</guid>    <pubDate>2025-12-19T08:22:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585222924566151208" data-draft-id="7585146584893128754" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一个定时器，理清 JavaScript 里的 this"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-12-19T08:22:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="T___T"/> <meta itemprop="url" content="https://juejin.cn/user/1599155645973066"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一个定时器，理清 JavaScript 里的 this
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1599155645973066/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    T___T
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:22:51.000Z" title="Fri Dec 19 2025 08:22:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文将从最基础的对象方法中<code>this</code>的指向说起，深入剖析定时器中<code>this</code>“不听话” 的原因，再逐一讲解几种常见的 “救回<code>this</code>” 的方法，包括经典的<code>var that = this</code>、灵活的<code>call/apply</code>、实用的<code>bind</code>，以及 ES6 中更优雅的箭头函数。通过清晰的案例对比和原理分析，帮你彻底理清<code>this</code>的绑定规律，从此不再被<code>this</code>的指向问题困扰。</p>
<h2 data-id="heading-0">一、从最普通的对象方法说起：this 指向当前对象</h2>
<p>先从最正常的场景看起：一个对象，里面有个方法，方法里打印 </p>
<p>this 和 <code>this.name</code>。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  }
};
obj.<span class="hljs-title function_">func1</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2dafc4d2e7c46859c2f53bd40a55b5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=mIUxUjHA%2FrDyeiEMvQBhBaYQ5yQ%3D" alt="image.png" loading="lazy"/></p>
<p>在这种<strong>通过“对象.方法()”调用</strong>的场景下：</p>
<ul>
<li>this 指向的是 <code>obj</code> 本身</li>
<li><code>this.name</code> 就是 <code>"Cherry"</code></li>
</ul>
<p>也就是说，只要是“谁点出来的函数，</p>
<p>this 一般就指向谁”。</p>
<p>这一点很多人都懂，真正乱的是下面这种情况。</p>
<h2 data-id="heading-1">二、一进定时器，this 就不听话了</h2>
<p>把上面的对象稍微改一下：再加一个方法，里面开个定时器。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  },
  <span class="hljs-attr">func2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);   <span class="hljs-comment">// 这里的 this 还是 obj</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 这里的 this 是谁？</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">func1</span>();      <span class="hljs-comment">// 这里很多人第一反应是“调用不到”</span>
    }, <span class="hljs-number">3000</span>);
  }
};
obj.<span class="hljs-title function_">func2</span>();
</code></pre>
<p>运行之后你会发现：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94e7ef26bb8c4ffabea6c5109ab553ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=k%2BfKWTnowU9FYepLXTPkKofduaI%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>func2 里面第一行 <code>console.log(this)</code> 打印的是 <code>obj</code></li>
<li>但是定时器回调里的 <code>console.log(this)</code>，却不再是 <code>obj</code>，而是全局对象（浏览器里是 <code>window</code>，严格模式下甚至可能是 <code>undefined</code>）</li>
</ul>
<p>原因是：<strong>谁调用这个函数，</strong></p>
<p><strong>this 就指向谁</strong>。</p>
<ul>
<li>obj.func2() 是“对象.方法调用”，所以 <code>this === obj</code></li>
<li><code>setTimeout</code> 回调是“普通函数调用”，真正执行时类似 <code>window.callback()</code>，所以 this 又回到了全局</li>
</ul>
<p>于是 </p>
<p>this.func1() 就出现了典型错误：<br/>
你以为是调用 obj.func1，实际上是在全局环境下找 func1。</p>
<h2 data-id="heading-2">三、三种常见的“救回 this”姿势</h2>
<p>为了在定时器里还能拿到“外层的那个对象”，常见有三种写法。</p>
<h3 data-id="heading-3">1. 老派写法：<code>var that = this</code></h3>
<p>最早接触到的方案一般是这个：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  },
  <span class="hljs-attr">func2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;   <span class="hljs-comment">// 先把外层的 this 存起来</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);      <span class="hljs-comment">// 这里还是全局对象</span>
      that.<span class="hljs-title function_">func1</span>();           <span class="hljs-comment">// 用 that 调用</span>
    }, <span class="hljs-number">3000</span>);
  }
};
obj.<span class="hljs-title function_">func2</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e418a6ff1f2d4073947293c336a36859~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=mG4mGNomUaDeREwJ0C82w1Lvguw%3D" alt="image.png" loading="lazy"/></p>
<p>思路很直白：</p>
<ul>
<li>外层 this 是我们想要的对象</li>
<li>回调内部再用一个变量 <code>that</code> 把它“闭包”住</li>
<li>不再依赖回调里的 this，而是用 <code>that</code> 去调用</li>
</ul>
<p>优点：</p>
<ul>
<li>所有环境都支持，ES5 就可以用<br/>
缺点：</li>
<li>可读性一般，多层回调时会出现 <code>that = this</code> / <code>self = this</code> 满天飞</li>
</ul>
<h3 data-id="heading-4">2. <code>call</code> / <code>apply</code>：立即执行并指定 this</h3>
<p>第二种方案是利用 <code>Function.prototype.call</code> / <code>apply</code>，它们有两个关键点：</p>
<ul>
<li>都是<strong>立即调用函数</strong></li>
<li>第一个参数是要绑定的 this</li>
</ul>
<p>例如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}
<span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span> };
<span class="hljs-title function_">show</span>();             <span class="hljs-comment">// this =&gt; window / undefined</span>
show.<span class="hljs-title function_">call</span>(obj);     <span class="hljs-comment">// this =&gt; obj</span>
show.<span class="hljs-title function_">apply</span>(obj);    <span class="hljs-comment">// this =&gt; obj</span>
</code></pre>
<p><code>call</code> 和 <code>apply</code> 的区别只在于<strong>传参方式</strong>：</p>
<ul>
<li><code>call(fnThis, arg1, arg2, ...)</code></li>
<li><code>apply(fnThis, [arg1, arg2, ...])</code></li>
</ul>
<p>在和定时器结合时，有一种稍微“绕”一点的写法，会先用 <code>call</code> 执行一次，然后把返回的函数交给定时器：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 这里的 this 被 call 成 obj</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">func1</span>();
  
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// 这个函数真正被 setTimeout 调用时，this 又回到全局</span>
  };
}.<span class="hljs-title function_">call</span>(obj), <span class="hljs-number">2000</span>);
</code></pre>
<p>分析一下这个写法的流程：</p>
<ul>
<li><code>.call(obj)</code> 先<strong>立刻执行</strong>这段函数，里面的 this 是 <code>obj</code></li>
<li>这个函数里 this.func1() 能正常调用到 obj.func1</li>
<li>它 <code>return</code> 的那个内部函数才是真正交给 <code>setTimeout</code> 的</li>
<li>这个内部函数在将来执行时，又是一次“普通函数调用”，于是 this 再次回到全局</li>
</ul>
<p>这种写法属于“利用 <code>call</code> 硬拉一次 </p>
<p>this 过来”，但在实际项目里，<strong>更常见的做法不是这样用 <code>call</code>，而是第三种：<code>bind</code></strong>。</p>
<h3 data-id="heading-5">3. <code>bind</code>：先订婚，后结婚</h3>
<p><code>bind</code> 和 <code>call/apply</code> 很容易混：</p>
<ul>
<li><code>call/apply</code>：<strong>马上执行</strong>，并临时指定一次 this</li>
<li><code>bind</code>：<strong>不执行</strong>，而是返回一个“this 永远被绑死”的新函数</li>
</ul>
<p>用一个简单对比看差异：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  }
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">func1</span>.<span class="hljs-title function_">bind</span>(obj)); <span class="hljs-comment">// 打印的是一个新函数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">func1</span>.<span class="hljs-title function_">call</span>(obj)); <span class="hljs-comment">// 打印的是 func1 的返回值（这里是 undefined）</span>
<span class="hljs-keyword">const</span> f = obj.<span class="hljs-property">func1</span>.<span class="hljs-title function_">bind</span>(obj);
<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// 始终以 obj 作为 this 调用</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68ec222d2f3e4c539ade13ddbb36b301~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=1j0yKGwRpgP3Vt9DKKN%2Bzm11tHk%3D" alt="image.png" loading="lazy"/></p>
<p>套用一个比较形象的说法：</p>
<ul>
<li><code>call/apply</code>：<strong>闪婚</strong>，当场拍板，函数当场执行完事</li>
<li><code>bind</code>：<strong>先订婚</strong>，先约定好将来的 this，真正结婚（执行）是以后</li>
</ul>
<p>因此在定时器这种“将来才会执行”的场景，<code>bind</code> 非常自然：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  },
  <span class="hljs-attr">func2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">func1</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">3000</span>);
  }
};
obj.<span class="hljs-title function_">func2</span>();
</code></pre>
<ul>
<li><code>this.func1.bind(this)</code> 立即返回了一个新函数</li>
<li>这个新函数里 this 被<strong>固定成当前对象</strong></li>
<li><code>setTimeout</code> 三秒后再执行它时，this 依然是那个对象</li>
</ul>
<p>相较于 <code>that = this</code> 和“花里胡哨的 call 写法”，<code>bind</code> 在这种场景下是最容易读懂的一种。</p>
<h2 data-id="heading-6">四、箭头函数：不再创建自己的 this</h2>
<p>还有一种办法，是直接 **放弃回调自己的 **</p>
<p><strong>this</strong>，而是用外层的。</p>
<p>这就是箭头函数的做法：<strong>箭头函数不会创建自己的执行上下文，它的</strong> <strong>this 完全继承自外层作用域</strong>。</p>
<blockquote>
<p>箭头函数的核心是<strong>没有自己的 <code>this</code></strong>，它的 <code>this</code> 是<strong>词法绑定</strong>（定义时继承外层作用域的 <code>this</code>），而非动态绑定。</p>
</blockquote>
<p>把前面的定时器改成箭头函数版本：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);       <span class="hljs-comment">// obj</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Cherry</span>
  },
  <span class="hljs-attr">func2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);       <span class="hljs-comment">// obj</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);     <span class="hljs-comment">// 依然是 obj</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">func1</span>();          <span class="hljs-comment">// 也能正常调用</span>
    }, <span class="hljs-number">3000</span>);
  }
};
obj.<span class="hljs-title function_">func2</span>();
obj.<span class="hljs-title function_">func1</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a700d4e338ec4b65a26feab9a09c2b82~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=4Mn69SgKwQbdBLUTA5HV58yYni0%3D" alt="image.png" loading="lazy"/></p>
<p>这里的关键点是：</p>
<ul>
<li>func2 里的 this 是对象本身</li>
<li>箭头函数的 this 直接沿用 func2 的 this</li>
<li>所以在箭头函数里，this 没有发生“跳变”，始终是那个对象</li>
</ul>
<p>再结合一个简单的对比例子，看得更清楚。</p>
<h3 data-id="heading-7">1. 普通函数和箭头函数的 this 对比</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">normal</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
}
<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
};
<span class="hljs-title function_">normal</span>(); <span class="hljs-comment">// 非严格模式下 this =&gt; window</span>
<span class="hljs-title function_">arrow</span>();  <span class="hljs-comment">// this 继承自定义它时所在的作用域（全局里一般也是 window / undefined）</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c7c5f7153bb43f1a503a4e24e19c1eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=mRwOZ7bHoy6R1bXybfV5eDC4St8%3D" alt="image.png" loading="lazy"/></p>
<p>再注意一个常被问到的问题：</p>
<ul>
<li><strong>箭头函数不能作为构造函数使用</strong>，也就是说不能 <code>new</code> 一个箭头函数<br/>
在实际代码里，如果你尝试 <code>new func()</code>（func 是箭头函数），会直接报错</li>
</ul>
<h3 data-id="heading-8">2. 顶层箭头函数的 this</h3>
<p>在普通脚本里，如果写一个顶层箭头函数：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
};
<span class="hljs-title function_">func</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dea99a14b5843cfa2e3fa5ca54f36d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=IS3BujGabuK9w1AxxA6%2BKDCz2AQ%3D" alt="image.png" loading="lazy"/></p>
<p>这里的 </p>
<p>this 继承自顶层作用域：</p>
<ul>
<li>浏览器非模块脚本中，一般是 <code>window</code></li>
<li>严格模式 / ES 模块中，顶层 this 往往是 <code>undefined</code></li>
</ul>
<p>这也再次说明：箭头函数的 </p>
<p>this 完全取决于<strong>它被定义时所处的环境</strong>，而不是被谁调用。</p>
<h3 data-id="heading-9">3. 继承外层作用域的 this</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Cherry'</span>,
  <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {          <span class="hljs-comment">// 普通函数，this === obj</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'外层 this：'</span>, <span class="hljs-variable language_">this</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {         <span class="hljs-comment">// 箭头函数，this 继承外层</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'箭头函数 this：'</span>, <span class="hljs-variable language_">this</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'name：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    }, <span class="hljs-number">1000</span>);
  }
};
obj.<span class="hljs-title function_">func</span>();
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0ab842e366941d58aeb6d5e3d98d23f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVF9fX1Q=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737371&amp;x-signature=7AL9lWMeDUWaPS5uJYDfS%2BqscAk%3D" alt="image.png" loading="lazy"/></p>
<p>把 setTimeout 里的箭头函数换成普通函数，this 会丢失</p>
<blockquote>
<p><strong><code>setTimeout</code> 中的回调函数是被 JavaScript 引擎 “独立调用” 的，而非作为某个对象的方法调用</strong>。</p>
</blockquote>
<h2 data-id="heading-10">五、小结 &amp; 使用建议</h2>
<p>把上面的内容串一下，可以得到这样一份“速记表”：</p>
<ul>
<li>
<hr/>
<p><strong>this 的基础规律</strong></p>
<ul>
<li><strong>谁调用，指向谁</strong>：<code>obj.method()</code> 里 <code>this === obj</code></li>
<li>普通函数直接调用：<code>fn()</code> 里 this 是全局对象 / <code>undefined</code>（严格模式）</li>
</ul>
</li>
<li>
<p><strong><code>setTimeout</code> / 回调里的</strong></p>
<p><strong>this</strong></p>
<ul>
<li>回调是普通函数调用，this 默认指向全局</li>
<li>所以在对象方法里直接写 <code>setTimeout(function () { this.xxx })</code>，往往拿不到我们想要的对象</li>
</ul>
</li>
<li>
<p><strong>三种修复方式的对比</strong></p>
<ul>
<li>
<p><strong><code>var that = this</code></strong></p>
<ul>
<li>利用闭包保存外层 this</li>
<li>兼容最好，但代码略显“老派”</li>
</ul>
</li>
<li>
<p><strong><code>call/apply</code></strong></p>
<ul>
<li>立即执行函数</li>
<li>第一个参数用来指定 this</li>
<li>适合“当场就要执行一次”的场景</li>
</ul>
</li>
<li>
<p><strong><code>bind</code></strong></p>
<ul>
<li>返回“this 被锁死”的新函数，而不是立即执行</li>
<li>非常适合“定时器、事件监听、回调”这些“稍后再执行”的情形</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>箭头函数</strong></p>
<ul>
<li>不创建自己的 this，只继承外层</li>
<li>在对象方法中配合回调使用，能有效避免 this 跳来跳去</li>
<li>不适合作为构造函数（不能 <code>new</code>）</li>
</ul>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Next项目中静态资源的压缩、优化]]></title>    <link>https://juejin.cn/post/7585180150254747663</link>    <guid>https://juejin.cn/post/7585180150254747663</guid>    <pubDate>2025-12-19T08:25:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585180150254747663" data-draft-id="7585206349748240436" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Next项目中静态资源的压缩、优化"/> <meta itemprop="keywords" content="Next.js"/> <meta itemprop="datePublished" content="2025-12-19T08:25:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="saintofficial"/> <meta itemprop="url" content="https://juejin.cn/user/1864415033966120"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Next项目中静态资源的压缩、优化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1864415033966120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    saintofficial
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:25:51.000Z" title="Fri Dec 19 2025 08:25:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><h3 data-id="heading-0">前言</h3>
<p>几个月前从0到1搭建落地了现在Next框架的项目，做了很多项目处理，现在想整理一下整个过程，这一次主要是对Next项目中静态资源(图片、打包的静态css、js)的压缩、优化，做个记录</p>
<h3 data-id="heading-1">实现了什么</h3>
<ol>
<li>存放在public(图片)在commit的时候，会通过tinify进行压缩之后再提交</li>
<li>压缩后的public(静态资源),会在jenkins打包的过程统一上传至CF的桶中形成CDN链接url</li>
<li>url通过配置next.config自定义loaderFile映射到Image组件src</li>
</ol>
<h3 data-id="heading-2">过程</h3>
<h4 data-id="heading-3">commit进行tinify压缩（实现1）</h4>
<p>npm包：husky、lint-staged、tinify</p>
<ul>
<li>触发点：.husky/pre-commit 调用 npx lint-staged，所以每次 git commit 都会跑 lint-staged。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9abcb384a1744a699f5344e56d570394~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=WgGF9wR6hvqOm5NqbNzRpKgpfL4%3D" alt="38a8ecd4-9f15-41bd-b913-209fb22b4c34.png" loading="lazy"/></p>
<ul>
<li>匹配规则：package.json 里的 lint-staged 配置，当前匹配 *.png, *.jpg, *.jpeg</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31163929f21a4363930d6869366783b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=nKAizHzVsdXMR37qllHpMcgisW0%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>压缩逻辑：使用 TinyPNG（tinify），读取 .env 的 TINIFY_KEY，对传入的文件（由 lint-staged 提供的已暂存文件列表）逐个压缩并覆盖原文件。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/536fa150dfdb4583982422de408c76b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=0aO12FyBizxzDvwSPxxi%2B7tuI2Q%3D" alt="image.png" loading="lazy"/></p>
<p>直接覆盖原文件
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9eb5e193dff14427a59ca650228d6aa7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=9w2Y1z2w3qh5IHyPifA65DlnAfI%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>完整代码，需要在 .env 设置 TINIFY_KEY</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>

<span class="hljs-keyword">import</span> dotenv <span class="hljs-keyword">from</span> <span class="hljs-string">"dotenv"</span>
<span class="hljs-keyword">import</span> tinify <span class="hljs-keyword">from</span> <span class="hljs-string">"tinify"</span>

<span class="hljs-comment">// 读取 .env 文件中的 TINIFY_KEY</span>
dotenv.<span class="hljs-title function_">config</span>()

tinify.<span class="hljs-property">key</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">TINIFY_KEY</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatFileSize</span>(<span class="hljs-params">bytes</span>) {
  <span class="hljs-keyword">if</span> (bytes &lt; <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> bytes + <span class="hljs-string">" B"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes &lt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> (bytes / <span class="hljs-number">1024</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) + <span class="hljs-string">" KB"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (bytes / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) + <span class="hljs-string">" MB"</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compressImage</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">const</span> ext = path.<span class="hljs-title function_">extname</span>(filePath).<span class="hljs-title function_">toLowerCase</span>()
  <span class="hljs-keyword">const</span> originalSize = fs.<span class="hljs-title function_">statSync</span>(filePath).<span class="hljs-property">size</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 只处理 jpg/jpeg/png/webp</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/\.(jpe?g|png|webp)$/i</span>.<span class="hljs-title function_">test</span>(ext)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`跳过不支持的文件类型: <span class="hljs-subst">${filePath}</span>`</span>)
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">await</span> tinify.<span class="hljs-title function_">fromFile</span>(filePath).<span class="hljs-title function_">toFile</span>(filePath)
    <span class="hljs-keyword">const</span> compressedSize = fs.<span class="hljs-title function_">statSync</span>(filePath).<span class="hljs-property">size</span>

    <span class="hljs-keyword">if</span> (compressedSize &lt; originalSize) {
      <span class="hljs-keyword">const</span> savings = originalSize - compressedSize
      <span class="hljs-keyword">const</span> savingsPercent = ((savings / originalSize) * <span class="hljs-number">100</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`✅ <span class="hljs-subst">${path.basename(filePath)}</span> - 原始: <span class="hljs-subst">${formatFileSize(originalSize)}</span> → `</span> +
          <span class="hljs-string">`压缩后: <span class="hljs-subst">${formatFileSize(compressedSize)}</span> (减少: <span class="hljs-subst">${formatFileSize(savings)}</span>, <span class="hljs-subst">${savingsPercent}</span>%)`</span>
      )
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`⚠️  <span class="hljs-subst">${path.basename(filePath)}</span> - 压缩后变大，已跳过 `</span> + <span class="hljs-string">`(原始: <span class="hljs-subst">${formatFileSize(originalSize)}</span> → <span class="hljs-subst">${formatFileSize(compressedSize)}</span>)`</span>
      )
    }
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`❌ 压缩失败: <span class="hljs-subst">${filePath}</span>`</span>, err.<span class="hljs-property">message</span>)
  }
}

<span class="hljs-comment">// 获取 lint-staged 传入的文件列表</span>
<span class="hljs-keyword">const</span> files = process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-regexp">/\.(jpe?g|png|webp)$/i</span>.<span class="hljs-title function_">test</span>(f))

<span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"ℹ️ 没有需要压缩的图片文件"</span>)
  process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>)
}

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(compressImage)).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"✨ 图片压缩完成"</span>)
})

</code></pre>
<h4 data-id="heading-4">jenkins上传CDN</h4>
<p>准备：Jenkins、@aws-sdk/client-s3</p>
<ul>
<li>构建前去选择是否需要上传，毕竟上传过一次之后就不用在上传了</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ffe502b5e384bb583f87ca3eb131ead~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=OsjO5qHtwIV41ZOvyz35pqrMVHI%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>在Build Steps的时候写一个shell脚本去执行打包，大致就是在build后之后，去执行自己在项目中写到upload.js，js主要去上传库中public文件夹下的所有静态资源</li>
<li>其实也不止这种资源性的，我们打包后的static文件夹下的也可以上传CDN，我们在nginx做一个映射就可以</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fb683a988f8480a97acd37a2812e0d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=J48tJN5p2pcX0AXQgTq4IWtmfNc%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>实现代码</li>
</ul>
<ol>
<li>
<p>初始化 S3 / CloudFront 与策略控制，增量上传还是全量上传，对比远端 Metadata["file-hash"] 与本地 md5，未变则跳过上传
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0fca67c15c57465b81f7a4c59c0dea06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=Xs3znQgZwjJSGZ08yg%2F5SRMQJnU%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>遍历与过滤：递归 public/，跳过 public/pwa/，将 bar.png 上传为 bar.png。上传时用 PutObject，设置 ContentType（mime-types 识别）和元数据 file-hash 为 MD5。</p>
</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb647ea5e7934ae99a6960193ed2384e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=j8II9cr7%2BcpfpN9cU%2FrhmmYWqnk%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e73dcababd2f48de82ba27f7c6e66ca5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=iI5TPshJSdMMdMvJQfIqyiP2rSQ%3D" alt="image.png" loading="lazy"/></p>
<p>上传static</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/453ce09bb6fb4cdcbf46fdc82a37a00d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=OBx9ywtjggLEbionsVLw%2BdfORwg%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>CDN 刷新：收集本次处理的 key 列表，若 ONLY_REFRESH_IMAGES=true 则只保留图片后缀（png/jpg/jpeg/gif/webp/svg/bmp/ico）。为每批（≤3000）调用 CloudFront CreateInvalidation，路径前加 /，callerReference 用时间戳+批次保证唯一。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03bed7e146354b9bb0f6a255720a23ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=F%2BMVutzcuboZkqcKckiXQCRTdYc%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-5">Image的loader</h4>
<p>那么接下来让我们的url上自动拼接上CND域名前缀到Image组件上，Image本身用法还是不变</p>
<pre><code class="hljs language-ini" lang="ini">&lt;Image <span class="hljs-attr">src</span>=<span class="hljs-string">'/a/b.png'</span> alt=<span class="hljs-string">'online'</span> ... /&gt;

最终networl看到的
&lt;Image <span class="hljs-attr">src</span>=<span class="hljs-string">'https://xx.com/a/b.png'</span> alt=<span class="hljs-string">'xx'</span> ... /&gt;
</code></pre>
<p>next.config
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fb2a45a91314c819993459676689b46~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=9qJ3BdkRJ2C7YKTdaPKdUPjKR1k%3D" alt="image.png" loading="lazy"/></p>
<p>imageLoader.ts 具体咋用可以看文档，功能就是帮你拼接前缀到Image到src上，仍然保留w=<span class="math math-inline"><span class="katex-error" title="ParseError: KaTeX parse error: Expected 'EOF', got '&amp;' at position 8: {width}&amp;̲q=" style="color:#cc0000">{width}&amp;q=</span></span>{quality || 75}，前提是你的CDN支持配置</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33ebf96821d34d6a857790b857de5eed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2FpbnRvZmZpY2lhbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737551&amp;x-signature=WQZSwr5gj3JjD0n5acFFyyo7oG8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-6">总结</h3>
<ul>
<li>无，还有好多可以写hh</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python函数与模块化编程：局部变量与全局变量的深度解析]]></title>    <link>https://juejin.cn/post/7585173051646787620</link>    <guid>https://juejin.cn/post/7585173051646787620</guid>    <pubDate>2025-12-19T07:33:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585173051646787620" data-draft-id="7585171571129139236" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python函数与模块化编程：局部变量与全局变量的深度解析"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-12-19T07:33:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="站大爷IP"/> <meta itemprop="url" content="https://juejin.cn/user/2905353241759261"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python函数与模块化编程：局部变量与全局变量的深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2905353241759261/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    站大爷IP
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:33:40.000Z" title="Fri Dec 19 2025 07:33:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>在Python编程中，变量就像数据世界的"容器"，而局部变量和全局变量则是两种不同作用范围的容器。理解它们的区别和正确使用方式，是写出结构清晰、可维护性高的代码的关键。本文将通过实际代码示例，带你轻松掌握这两种变量的核心特性和使用技巧。</p>
<h2 data-id="heading-0">一、变量作用域的直观理解</h2>
<p>想象你正在装修一套房子，变量就像不同房间里的家具。全局变量是放在客厅的公共物品，整个房子的人都能看到和使用；局部变量则是放在卧室的私人物品，只有进入卧室的人才能看到。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 全局变量示例</span>
public_book = <span class="hljs-string">"Python编程从入门到实践"</span>  <span class="hljs-comment"># 放在客厅的书</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_book</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"正在阅读: <span class="hljs-subst">{public_book}</span>"</span>)  <span class="hljs-comment"># 可以直接使用全局变量</span>

read_book()
<span class="hljs-comment"># 输出: 正在阅读: Python编程从入门到实践</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这个例子中，<code>public_book</code>就像客厅的书，函数<code>read_book</code>可以直接访问它。但如果我们尝试在函数内部修改这个全局变量，就会遇到问题：</p>
<pre><code class="hljs language-python" lang="python">public_book = <span class="hljs-string">"Python编程从入门到实践"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">modify_book</span>():
    public_book = <span class="hljs-string">"Fluent Python"</span>  <span class="hljs-comment"># 看似修改了全局变量</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"函数内: <span class="hljs-subst">{public_book}</span>"</span>)

modify_book()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"函数外: <span class="hljs-subst">{public_book}</span>"</span>)

<span class="hljs-comment"># 输出:</span>
<span class="hljs-comment"># 函数内: Fluent Python</span>
<span class="hljs-comment"># 函数外: Python编程从入门到实践</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>发现了吗？函数内部的修改并没有影响到外部的全局变量。这是因为Python默认将赋值操作视为创建局部变量。要真正修改全局变量，需要使用<code>global</code>关键字：</p>
<pre><code class="hljs language-python" lang="python">public_book = <span class="hljs-string">"Python编程从入门到实践"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">real_modify_book</span>():
    <span class="hljs-keyword">global</span> public_book  <span class="hljs-comment"># 声明要修改全局变量</span>
    public_book = <span class="hljs-string">"Fluent Python"</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"函数内: <span class="hljs-subst">{public_book}</span>"</span>)

real_modify_book()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"函数外: <span class="hljs-subst">{public_book}</span>"</span>)

<span class="hljs-comment"># 输出:</span>
<span class="hljs-comment"># 函数内: Fluent Python</span>
<span class="hljs-comment"># 函数外: Fluent Python</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-1">二、局部变量的生存空间</h2>
<p>局部变量就像函数内部的临时工，只在函数执行期间存在。函数结束后，这些变量就会被Python的垃圾回收机制清理掉：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function">def <span class="hljs-title">calculate_area</span><span class="hljs-params">(width, height)</span>:
    area =</span> width * height  <span class="hljs-meta"># area是局部变量</span>
    <span class="hljs-built_in">print</span>(f<span class="hljs-string">"面积是: {area}"</span>)
    <span class="hljs-keyword">return</span> area

result = <span class="hljs-built_in">calculate_area</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(result)  # 可以访问返回值
<span class="hljs-meta"># print(area)  # 这行会报错，因为area在函数外不存在</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>局部变量的这种特性有几个重要优势：</p>
<ol>
<li><strong>避免命名冲突</strong>：不同函数可以使用相同名称的局部变量</li>
<li><strong>内存效率</strong>：函数结束后自动释放内存</li>
<li><strong>代码隔离</strong>：每个函数有自己的变量空间，减少意外修改</li>
</ol>
<p>看这个例子：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_function</span>():
    x = <span class="hljs-number">10</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"第一个函数: <span class="hljs-subst">{x}</span>"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">second_function</span>():
    x = <span class="hljs-number">20</span>  <span class="hljs-comment"># 与第一个函数的x完全无关</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"第二个函数: <span class="hljs-subst">{x}</span>"</span>)

first_function()
second_function()

<span class="hljs-comment"># 输出:</span>
<span class="hljs-comment"># 第一个函数: 10</span>
<span class="hljs-comment"># 第二个函数: 20</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-2">三、全局变量的双刃剑效应</h2>
<p>全局变量看似方便，但过度使用会带来维护噩梦。它们就像放在客厅的贵重物品，所有人都能接触，但也容易不小心碰倒。</p>
<h3 data-id="heading-3">1. 全局变量的合理使用场景</h3>
<ul>
<li>
<p><strong>配置参数</strong>：整个程序需要共享的配置值</p>
</li>
<li>
<p><strong>状态标志</strong>：表示程序整体状态的变量</p>
</li>
<li>
<p><strong>常量集合</strong>：不会改变的共享数据</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 合理的全局变量使用示例</span>
<span class="hljs-attr">APP_NAME</span> = <span class="hljs-string">"数据采集系统"</span>
<span class="hljs-attr">VERSION</span> = <span class="hljs-string">"1.0.0"</span>
<span class="hljs-attr">MAX_CONNECTIONS</span> = <span class="hljs-number">100</span>

def show_info():
    print(f"{APP_NAME} v{VERSION}, 最大连接数: {MAX_CONNECTIONS}")

show_info()
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
</ul>
<h3 data-id="heading-4">2. 全局变量的潜在问题</h3>
<p>考虑这个修改配置的例子：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 不好的实践：全局变量被随意修改</span>
config = {<span class="hljs-string">"timeout"</span>: <span class="hljs-number">30</span>, <span class="hljs-string">"retries"</span>: <span class="hljs-number">3</span>}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>():
    config[<span class="hljs-string">"timeout"</span>] = <span class="hljs-number">60</span>  <span class="hljs-comment"># 意外修改了全局配置</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据处理中..."</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">another_process</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"当前超时设置: <span class="hljs-subst">{config[<span class="hljs-string">'timeout'</span>]}</span>"</span>)  <span class="hljs-comment"># 得到意外结果</span>

process_data()
another_process()
<span class="hljs-comment"># 输出: 当前超时设置: 60 (可能不是我们想要的)</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-5">3. 更好的替代方案</h3>
<p>对于需要共享的数据，考虑使用：</p>
<ul>
<li><strong>函数参数传递</strong>：显式传递需要的数据</li>
<li><strong>类属性</strong>：将相关数据封装在类中</li>
<li><strong>配置模块</strong>：使用专门的配置文件或模块</li>
</ul>
<p>改进后的版本：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 使用函数参数传递配置</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">config</span>):
    new_config = config.copy()  <span class="hljs-comment"># 避免修改原始配置</span>
    new_config[<span class="hljs-string">"timeout"</span>] = <span class="hljs-number">60</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据处理中..."</span>)
    <span class="hljs-keyword">return</span> new_config

<span class="hljs-keyword">def</span> <span class="hljs-title function_">another_process</span>(<span class="hljs-params">config</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"当前超时设置: <span class="hljs-subst">{config[<span class="hljs-string">'timeout'</span>]}</span>"</span>)

base_config = {<span class="hljs-string">"timeout"</span>: <span class="hljs-number">30</span>, <span class="hljs-string">"retries"</span>: <span class="hljs-number">3</span>}
updated_config = process_data(base_config)
another_process(base_config)  <span class="hljs-comment"># 原始配置不变</span>
<span class="hljs-comment"># 输出: 当前超时设置: 30</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-6">四、变量作用域的嵌套迷宫</h2>
<p>当函数内部再定义函数时，作用域规则会变得更复杂。这就像房子里有嵌套的房间：</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">outer_function</span>():
    outer_var = <span class="hljs-string">"外部变量"</span>
    
    def <span class="hljs-built_in">inner_function</span>():
        inner_var = <span class="hljs-string">"内部变量"</span>
        <span class="hljs-built_in">print</span>(outer_var)  # 可以访问外部函数的变量
        <span class="hljs-built_in">print</span>(inner_var)
    
    <span class="hljs-built_in">inner_function</span>()
    # <span class="hljs-built_in">print</span>(inner_var)  # 这行会报错，内部变量外部不可见

<span class="hljs-built_in">outer_function</span>()
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这种嵌套作用域在闭包(closure)中非常有用：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_multiplier</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiplier</span>(<span class="hljs-params">x</span>):
        <span class="hljs-keyword">return</span> x * n  <span class="hljs-comment"># 可以访问外部函数的n</span>
    <span class="hljs-keyword">return</span> multiplier

double = make_multiplier(<span class="hljs-number">2</span>)
triple = make_multiplier(<span class="hljs-number">3</span>)

<span class="hljs-built_in">print</span>(double(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 10 (5*2)</span>
<span class="hljs-built_in">print</span>(triple(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 15 (5*3)</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-7">五、实战技巧与最佳实践</h2>
<h3 data-id="heading-8">1. 最小化全局变量</h3>
<p>遵循"最小惊讶原则"，尽量减少全局变量的使用。问自己：这个变量真的需要全局可见吗？</p>
<h3 data-id="heading-9">2. 使用描述性命名</h3>
<p>全局变量可以加前缀如<code>g_</code>或<code>GLOBAL_</code>来明确标识：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">g_user_count</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 全局用户计数</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-10">3. 避免全局常量与变量的混淆</h3>
<p>Python没有真正的常量，但可以约定全大写命名表示不应修改的值：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">MAX_USERS</span> = <span class="hljs-number">1000</span>  <span class="hljs-comment"># 约定为常量，不应修改</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-11">4. 使用模块管理全局状态</h3>
<p>对于大型项目，将全局状态组织在专门模块中：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-meta"># config.py</span>
APP_CONFIG = {
    <span class="hljs-string">"debug"</span>: True,
    <span class="hljs-string">"db_url"</span>: <span class="hljs-string">"sqlite:///data.db"</span>
}

<span class="hljs-meta"># main.py</span>
<span class="hljs-keyword">import</span> config
<span class="hljs-built_in">print</span>(config.APP_CONFIG[<span class="hljs-string">"db_url"</span>])
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-12">5. 调试技巧：查找变量作用域问题</h3>
<p>当遇到"变量未定义"错误时，可以：</p>
<ol>
<li>检查变量是否在正确的作用域定义</li>
<li>查看是否意外创建了同名局部变量</li>
<li>使用IDE的变量查看功能追踪变量生命周期</li>
</ol>
<h2 data-id="heading-13">六、常见误区与解决方案</h2>
<h3 data-id="heading-14">误区1：在函数内误以为修改了全局变量</h3>
<pre><code class="hljs language-csharp" lang="csharp">count = <span class="hljs-number">0</span>

<span class="hljs-function">def <span class="hljs-title">increment</span>():
    count +</span>= <span class="hljs-number">1</span>  <span class="hljs-meta"># 报错: UnboundLocalError</span>

increment()
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>解决</strong>：使用<code>global</code>声明或改为返回值方式</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 方案1: 使用global</span>
count = <span class="hljs-number">0</span>
<span class="hljs-function">def <span class="hljs-title">increment_global</span>():
    <span class="hljs-keyword">global</span> count
    count +</span>= <span class="hljs-number">1</span>

<span class="hljs-meta"># 方案2: 返回值方式</span>
<span class="hljs-function">def <span class="hljs-title">increment_return</span>():
    <span class="hljs-keyword">return</span> count + 1
</span></code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-15">误区2：嵌套函数中意外捕获变量</h3>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">create_counters</span>():
    counters = []
    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
        def <span class="hljs-built_in">counter</span>():
            return i  # 总是返回<span class="hljs-number">2</span>，因为循环结束后i=<span class="hljs-number">2</span>
        counters.<span class="hljs-built_in">append</span>(counter)
    return counters

c1, c2, c3 = <span class="hljs-built_in">create_counters</span>()
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">c1</span>(), <span class="hljs-built_in">c2</span>(), <span class="hljs-built_in">c3</span>())  # 输出: <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>解决</strong>：使用默认参数绑定当前值</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">create_counters</span>():
    counters = []
    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
        def <span class="hljs-built_in">counter</span>(x=i):  # 默认参数绑定当前i值
            return x
        counters.<span class="hljs-built_in">append</span>(counter)
    return counters

c1, c2, c3 = <span class="hljs-built_in">create_counters</span>()
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">c1</span>(), <span class="hljs-built_in">c2</span>(), <span class="hljs-built_in">c3</span>())  # 输出: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-16">七、性能考量</h2>
<p>虽然变量作用域主要影响代码结构，但也有性能方面的考量：</p>
<ol>
<li><strong>局部变量访问更快</strong>：Python查找局部变量比全局变量快</li>
<li><strong>全局变量增加内存占用</strong>：程序生命周期内一直存在</li>
<li><strong>过度嵌套影响性能</strong>：深层嵌套的作用域查找会变慢</li>
</ol>
<p>简单性能测试：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> timeit

<span class="hljs-comment"># 测试局部变量访问</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">local_test</span>():
    x = <span class="hljs-number">10</span>
    <span class="hljs-keyword">return</span> x

<span class="hljs-comment"># 测试全局变量访问</span>
y = <span class="hljs-number">10</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">global_test</span>():
    <span class="hljs-keyword">return</span> y

<span class="hljs-built_in">print</span>(<span class="hljs-string">"局部变量:"</span>, timeit.timeit(local_test, number=<span class="hljs-number">1000000</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"全局变量:"</span>, timeit.timeit(global_test, number=<span class="hljs-number">1000000</span>))

<span class="hljs-comment"># 典型输出(具体值取决于机器):</span>
<span class="hljs-comment"># 局部变量: 0.045</span>
<span class="hljs-comment"># 全局变量: 0.072</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-17">八、总结与行动建议</h2>
<p>掌握局部变量和全局变量的使用，就像掌握了Python作用域的"交通规则"：</p>
<ol>
<li><strong>默认使用局部变量</strong>：它们更安全、更高效</li>
<li><strong>谨慎使用全局变量</strong>：只在真正需要共享状态时使用</li>
<li><strong>利用函数参数传递数据</strong>：这是最清晰的数据流方式</li>
<li><strong>考虑使用类</strong>：当数据和操作紧密相关时</li>
</ol>
<p>下次编写代码时，试着问自己：</p>
<ul>
<li>这个变量需要被多个函数访问吗？</li>
<li>这个变量的生命周期应该有多长？</li>
<li>是否有更清晰的数据传递方式？</li>
</ul>
<p>通过有意识地管理变量作用域，你的代码将更容易理解、调试和维护，真正实现"自文档化"的优雅代码。记住，好的变量作用域设计，就是给数据划定清晰的边界，让每个数据都在正确的位置发挥价值。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【性能优化】给Vue应用“瘦身”：让你的网页快如闪电的烹饪秘籍]]></title>    <link>https://juejin.cn/post/7585138968167530532</link>    <guid>https://juejin.cn/post/7585138968167530532</guid>    <pubDate>2025-12-19T08:26:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585138968167530532" data-draft-id="7585214391828316203" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【性能优化】给Vue应用“瘦身”：让你的网页快如闪电的烹饪秘籍"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-12-19T08:26:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JS_Likers"/> <meta itemprop="url" content="https://juejin.cn/user/1377017277975032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【性能优化】给Vue应用“瘦身”：让你的网页快如闪电的烹饪秘籍
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1377017277975032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JS_Likers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:26:36.000Z" title="Fri Dec 19 2025 08:26:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>欢迎使用我的小程序👇👇👇👇</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d25c4001b1b4e6e902dc1f8863bcef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSlNfTGlrZXJz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766737690&amp;x-signature=XdSwFz7hhhX8YpdYuZvWr3UHLnM%3D" alt="small.png" loading="lazy"/></p>
<hr/>
<blockquote>
<p>想象一下：你精心烹制的Vue应用端上桌，用户却因加载慢而转身离开...别担心！今天我来教你几招性能优化“烹饪技巧”，让你的应用“色香味”俱全！</p>
</blockquote>
<h2 data-id="heading-0">🍳 前菜：为什么需要性能优化？</h2>
<p>你的Vue应用就像一道菜，用户希望：</p>
<ul>
<li><strong>快速上菜</strong>（首屏加载快）</li>
<li><strong>口感顺滑</strong>（交互流畅）</li>
<li><strong>回味无穷</strong>（使用体验好）</li>
</ul>
<p>性能差的网站就像冷掉的披萨，再好吃也没人爱！</p>
<h2 data-id="heading-1">🔪 主菜：Vue性能优化七大秘籍</h2>
<h3 data-id="heading-2">1. 代码打包：给食材“瘦身”</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vue.config.js - 就像主厨的调味秘诀</span>
<span class="hljs-keyword">const</span> { defineConfig } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@vue/cli-service'</span>)

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {
    <span class="hljs-comment">// 开启Gzip压缩 - 像真空压缩食材</span>
    config.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">'compression'</span>).<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">'compression-webpack-plugin'</span>))
    
    <span class="hljs-comment">// 拆分包 - 分开装盘更优雅</span>
    config.<span class="hljs-property">optimization</span>.<span class="hljs-title function_">splitChunks</span>({
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
      <span class="hljs-attr">maxSize</span>: <span class="hljs-number">244</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 每个“餐盘”不超过244KB</span>
    })
  }
})
</code></pre>
<p><strong>小技巧</strong>：使用 <code>vue-cli</code> 的 <code>--report</code> 参数生成打包分析报告，像X光一样看清你的“脂肪”分布！</p>
<h3 data-id="heading-3">2. 懒加载：像自助餐一样按需取用</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 常规加载 - 一次全上桌 --&gt;
    &lt;!-- &lt;HeavyComponent /&gt; --&gt;
    
    &lt;!-- 懒加载 - 客人需要时才上菜 --&gt;
    &lt;button @click="showComponent = true"&gt;点这道菜&lt;/button&gt;
    &lt;component v-if="showComponent" :is="HeavyComponent" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      showComponent: false,
      HeavyComponent: () =&gt; import('./components/HeavyComponent.vue')
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>路由懒加载</strong>更是神器：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 路由配置 - 每道菜单独包装</span>
<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/dashboard'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/Dashboard.vue'</span>) <span class="hljs-comment">// 客人进入餐厅才准备这道菜</span>
  }
]
</code></pre>
<h3 data-id="heading-4">3. 虚拟滚动：长列表的“折叠椅”</h3>
<p>想象一下10000个项目的列表——就像要同时展示10000道菜，不可能！虚拟滚动只渲染可视区域：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;!-- 普通列表 - 所有菜都摆出来 --&gt;
  &lt;!-- &lt;div v-for="item in 10000" :key="item.id"&gt;{{ item.name }}&lt;/div&gt; --&gt;
  
  &lt;!-- 虚拟滚动 - 只摆客人能看到的几道 --&gt;
  &lt;VirtualList :items="largeList" :item-height="50"&gt;
    &lt;template #default="{ item }"&gt;
      &lt;ListItem :item="item" /&gt;
    &lt;/template&gt;
  &lt;/VirtualList&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-5">4. 计算属性 vs 方法：聪明的“预制菜”</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 方法调用 - 每次点单都现做（性能差） --&gt;
    &lt;!-- &lt;p&gt;{{ calculateTotal() }}&lt;/p&gt; --&gt;
    
    &lt;!-- 计算属性 - 提前准备好的预制菜（性能好） --&gt;
    &lt;p&gt;{{ totalPrice }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      items: [
        { price: 100, quantity: 2 },
        { price: 200, quantity: 1 }
      ]
    }
  },
  computed: {
    // 依赖变化时才重新计算
    totalPrice() {
      return this.items.reduce((sum, item) =&gt; 
        sum + item.price * item.quantity, 0
      )
    }
  },
  methods: {
    // 每次渲染都会执行
    calculateTotal() {
      return this.items.reduce((sum, item) =&gt; 
        sum + item.price * item.quantity, 0
      )
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-6">5. Keep-Alive：给组件盖“保温盖”</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;!-- 常规组件 - 离开就倒掉 --&gt;
  &lt;!-- &lt;TabContent /&gt; --&gt;
  
  &lt;!-- Keep-Alive - 盖上保温盖，回来还是热的 --&gt;
  &lt;keep-alive&gt;
    &lt;component :is="currentTab" /&gt;
  &lt;/keep-alive&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-7">6. 图片优化：给视觉“减负”</h3>
<p><strong>懒加载图片：</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;img 
    v-lazy="imageUrl" 
    alt="美味佳肴"
    loading="lazy"  &lt;!-- 原生懒加载 --&gt;
  /&gt;
&lt;/template&gt;

&lt;script&gt;
import VueLazyload from 'vue-lazyload'

Vue.use(VueLazyload, {
  preLoad: 1.3, // 提前1.3屏加载
  attempt: 3    // 尝试3次加载
})
&lt;/script&gt;
</code></pre>
<p><strong>现代图片格式：</strong></p>
<ul>
<li>WebP：比JPEG小25-35%</li>
<li>AVIF：下一代格式，压缩率更高</li>
</ul>
<h3 data-id="heading-8">7. 监控与分析：安装“厨房摄像头”</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 性能监控</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 测量组件加载时间</span>
    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>()
    
    <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>()
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`组件渲染耗时: <span class="hljs-subst">${end - start}</span>ms`</span>)
      
      <span class="hljs-comment">// 发送到监控平台</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendMetrics</span>(<span class="hljs-string">'component_render_time'</span>, end - start)
    })
  }
}
</code></pre>
<h2 data-id="heading-9">🍰 甜点：快速优化清单</h2>
<p>✅ <strong>立即能做的：</strong></p>
<ol>
<li>开启Gzip压缩（服务器配置）</li>
<li>使用路由懒加载</li>
<li>压缩图片（Tinypng.com）</li>
<li>移除未使用的代码</li>
</ol>
<p>✅ <strong>进阶技巧：</strong></p>
<ol>
<li>使用CDN分发静态资源</li>
<li>服务端渲染(SSR)改善首屏</li>
<li>PWA提升离线体验</li>
<li>Web Workers处理繁重计算</li>
</ol>
<h2 data-id="heading-10">📊 成果展示：优化前后对比</h2>





























<table><thead><tr><th>指标</th><th>优化前</th><th>优化后</th><th>提升</th></tr></thead><tbody><tr><td>首屏加载</td><td>4.2s</td><td>1.8s</td><td>⬇️ 57%</td></tr><tr><td>打包体积</td><td>2.1MB</td><td>890KB</td><td>⬇️ 58%</td></tr><tr><td>Lighthouse评分</td><td>62</td><td>92</td><td>⬆️ 30分</td></tr></tbody></table>
<h2 data-id="heading-11">🎯 结语：优化是持续的过程</h2>
<p>性能优化就像保持身材——不是一次性节食，而是养成健康习惯。每周花15分钟检查你的Vue应用：</p>
<ol>
<li>运行 <code>npm run build -- --report</code></li>
<li>查看Lighthouse报告</li>
<li>优化最慢的3个组件</li>
</ol>
<p>记住：<strong>每毫秒都很重要</strong>——100毫秒的延迟就能让转化率下降7%！</p>
<p><strong>今日主厨推荐</strong>：从路由懒加载开始，这是性价比最高的优化方式！</p>
<hr/>
<p>💡 <strong>小测验</strong>：你的Vue应用现在“体重”多少？运行 <code>npm run build</code> 看看打包后的体积，在评论区分享你的“减肥”成果吧！</p>
<p><em>优化愉快，让你的Vue应用飞起来！🚀</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 HBuilder 上架 iOS 应用时如何管理Bundle ID、证书与描述文件]]></title>    <link>https://juejin.cn/post/7585138968167546916</link>    <guid>https://juejin.cn/post/7585138968167546916</guid>    <pubDate>2025-12-19T08:40:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585138968167546916" data-draft-id="7585171571129565220" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 HBuilder 上架 iOS 应用时如何管理Bundle ID、证书与描述文件"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T08:40:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="疯狂的程序猴"/> <meta itemprop="url" content="https://juejin.cn/user/2760245749234147"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 HBuilder 上架 iOS 应用时如何管理Bundle ID、证书与描述文件
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2760245749234147/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    疯狂的程序猴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:40:22.000Z" title="Fri Dec 19 2025 08:40:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在不少跨端项目里，HBuilder 更像一个“完成开发”的标志。页面跑通、接口联调结束，开发任务似乎已经告一段落。但当应用真正要提交到 App Store 时，很多团队才意识到：HBuilder 解决的是开发效率问题，而 iOS 上架依然遵循原生体系的规则。</p>
<p>我第一次用 HBuilder 完成 iOS 上架时，构建阶段并没有遇到太多阻碍，真正花时间的，是围绕证书、Bundle ID、IPA 和上传方式的一系列细节。这些问题并不是 HBuilder 特有的，而是任何进入 iOS 发布流程都会面对的现实。</p>
<hr/>
<h2 data-id="heading-0"><strong>HBuilder 的打包能力，并不等于“发布准备完成”</strong></h2>
<p>无论是本地打包还是云打包，HBuilder 最终都会生成一个标准的 IPA。
但在工程实践中，IPA 只是中间产物，而不是发布结果。</p>
<p>我见过的情况包括：</p>
<ul>
<li>打包成功，但 IPA 无法上传</li>
<li>安装到测试设备没问题，提交审核却失败</li>
<li>云打包生成的配置与账号实际状态不一致</li>
</ul>
<p>这些问题的根源，往往不在 HBuilder 本身，而在 iOS 发布所依赖的基础对象是否清晰。</p>
<hr/>
<h2 data-id="heading-1"><strong>Bundle ID 是 HBuilder 项目最容易被忽略的约束</strong></h2>
<p>在 HBuilder 的配置界面中，Bundle ID 看起来只是一个必填项，很容易在开发阶段被随意填写。
但进入 App Store 体系后，它会成为所有资源的关联核心。</p>
<p>在一些项目中，我会在打包之前先确认 Apple 开发者账号里已经存在的应用标识，避免以下情况：</p>
<ul>
<li>使用了已经被占用的 Bundle ID</li>
<li>测试包和正式包混用标识</li>
<li>历史项目残留影响新应用</li>
</ul>
<p>当不在 macOS 环境下时，可以通过 开心上架（Appuploader）查看账号内的 Bundle ID 列表，快速了解当前账号的实际状态。这一步不会改变打包流程，但会让后续操作更有把握。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08ced68f66304c1990ffdcc4eb5ef6d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55av54uC55qE56iL5bqP54y0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738422&amp;x-signature=hrkRJZgB8P3nbQ3ervIPTzv3Z%2BI%3D" alt="查看bid" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-2"><strong>HBuilder 并没有简化证书体系，只是屏蔽了细节</strong></h2>
<p>不少开发者在使用 HBuilder 时，会对证书的存在感变弱。
但 iOS 并不会因为使用了跨端工具而放宽签名要求。</p>
<p>在一些项目中，我遇到过：</p>
<ul>
<li>云打包正常，但 TestFlight 阶段失败</li>
<li>更换构建环境后签名失效</li>
<li>无法确认当前使用的是哪一份证书</li>
</ul>
<p>后来在一些团队里，我们选择把证书管理独立出来。
例如，通过 开心上架（Appuploader）创建 iOS 证书，生成可复用的证书文件，供 HBuilder 打包和后续发布使用。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5fb538accd34c69a91b0539731d6a05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55av54uC55qE56iL5bqP54y0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738422&amp;x-signature=S4%2FnSALrSI%2BUK0hH049RbEdH0c8%3D" alt="证书管理" loading="lazy"/></p>
<p>这样做的好处在于：</p>
<ul>
<li>证书不依赖某一台 Mac 的钥匙串</li>
<li>构建节点和发布节点可以共用</li>
<li>证书来源和用途更清晰</li>
</ul>
<hr/>
<h2 data-id="heading-3"><strong>描述文件，是 HBuilder 上架过程中最容易“用错”的部分</strong></h2>
<p>在 HBuilder 项目中，描述文件往往是自动生成或自动下载的，很少有人会主动检查它的内容。
但在排查上架问题时，描述文件几乎总是绕不开的对象。</p>
<p>我曾遇到构建成功、安装正常，却始终无法通过审核的情况。最终发现是 IPA 中携带的描述文件类型不符合 App Store 要求。</p>
<p>在发布前，我通常会直接查看描述文件内部信息，而不是只看文件名。
通过 开心上架（Appuploader）查看 mobileprovision 文件内容，可以确认：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b739a8bc0b324195b446a6297db10cd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55av54uC55qE56iL5bqP54y0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738422&amp;x-signature=w5jLnbgPso9f9hsl%2Bl%2F3SXY6G%2Bo%3D" alt="查看文件" loading="lazy"/></p>
<ul>
<li>描述文件类型是否为发布</li>
<li>绑定的 Bundle ID 是否一致</li>
<li>使用的证书是否正确</li>
</ul>
<p>这一步对 HBuilder 项目尤其重要，因为很多错误并不会在打包阶段提示。</p>
<hr/>
<h2 data-id="heading-4"><strong>HBuilder 项目中，上传方式往往决定协作成本</strong></h2>
<p>在单人项目中，用 Xcode 或平台推荐方式上传 IPA 并不复杂。但在多人或跨平台团队中，上传很容易成为瓶颈。</p>
<p>当构建发生在云端，而上传必须依赖某一台 Mac 时，发布节奏就会被人为限制。</p>
<p>在一些项目中，我们使用 开心上架（Appuploader）的上传方式，在 Windows 或 Linux 环境中完成 IPA 提交，例如：</p>
<pre><code class="hljs language-bash" lang="bash">appuploader_cli -u appleid@example.com -p xxxx-xxxx-xxxx -c 1 -f app.ipa
</code></pre>
<p>这样，HBuilder 的打包结果可以在不同系统中被提交，上架流程不再依赖特定设备。</p>
<hr/>
<h2 data-id="heading-5"><strong>HBuilder 只是开发工具，上架仍然是原生工程问题</strong></h2>
<p>经历过几次完整流程后，我逐渐意识到：
HBuilder 并没有“替代”iOS 上架流程，它只是让开发阶段更高效。</p>
<p>真正决定上架是否顺利的，仍然是：</p>
<ul>
<li>Bundle ID 是否清晰</li>
<li>证书和描述文件是否匹配</li>
<li>IPA 是否符合发布要求</li>
<li>上传流程是否可协作</li>
</ul>
<p>Xcode、HBuilder云打包、CI 和开心上架（Appuploader）各自解决不同问题</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android AI解放生产力（七）：更丰富的AI运用前瞻]]></title>    <link>https://juejin.cn/post/7585146584893964338</link>    <guid>https://juejin.cn/post/7585146584893964338</guid>    <pubDate>2025-12-19T08:47:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585146584893964338" data-draft-id="7585289701826707465" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android AI解放生产力（七）：更丰富的AI运用前瞻"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-12-19T08:47:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TimeFine"/> <meta itemprop="url" content="https://juejin.cn/user/3913917123802615"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android AI解放生产力（七）：更丰富的AI运用前瞻
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917123802615/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TimeFine
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:47:51.000Z" title="Fri Dec 19 2025 08:47:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、更多的skill</h2>
<p>开发人员可以提炼项目中的skill，作为一种能力共享给所有人员使用。比如：</p>
<ul>
<li>code review 的skill</li>
<li>Compose 性能检查的skill</li>
<li>慢函数检测的skill</li>
</ul>
<p>也可以扩展更多实用的skill来进一步丰富能力。</p>
<p>有一个网站当前收录了28K多skills供开发人员学习交流，网站是：<a href="https://link.juejin.cn?target=https%3A%2F%2Fskillsmp.com%2Fzh" target="_blank" title="https://skillsmp.com/zh" ref="nofollow noopener noreferrer">skillsmp.com/zh</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fd5f5c6e4a8428babf4a71ef34365fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVGltZUZpbmU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738870&amp;x-signature=HrQIuwrmIMSGEscISv6iEBa%2BTfc%3D" alt="image.png" loading="lazy"/></p>
<p>可以逛逛，学习如何编辑skill，以及找到自己可用的skill。</p>
<h2 data-id="heading-1">二、更多的agent</h2>
<p>智能体越来越多，共享的数据也越来越丰富，github上有一个项目收录了非常多免费的AGENT服务，目前有7万多star，可以访问试试看，网站是：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodelcontextprotocol%2Fservers" target="_blank" title="https://github.com/modelcontextprotocol/servers" ref="nofollow noopener noreferrer">github.com/modelcontex…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8807bc48dc0c4885bd8da63c3043c462~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVGltZUZpbmU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738870&amp;x-signature=W3Vpj1ZQWV1cF2OoXOvN0AWcdP8%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-2">三、n8n工作流</h2>
<p>n8n 可以把它理解成一个“自动化流程搭积木的工具”：你把不同应用/服务（比如 GitHub、Slack、Google Sheets、HTTP API、数据库等）用一个个“节点（node）”连起来，画成一条流程（workflow），让它在某个事件发生时自动执行。</p>
<p>它怎么工作：</p>
<ul>
<li>触发器（Trigger）：流程从哪里开始。比如“收到一个 Webhook 请求”就启动流程。</li>
<li>动作节点（Action nodes）：流程要做什么。比如“请求一个 API”“写入表格”“发消息”“创建工单”等。</li>
<li>你可以写一点代码：如果需要更复杂的判断/数据处理，n8n 支持在流程里加自定义代码来处理数据（“低代码 + 可写代码”）。</li>
</ul>
<p>为什么很多开发会用它：</p>
<ul>
<li>连接很多工具：官方强调有大量集成（400+）可直接用。</li>
<li>可自托管：你可以自己部署在服务器/内网（更好管数据和权限），也可以用官方云。</li>
</ul>
<p>几个直观例子：</p>
<ul>
<li>GitHub 有新 PR → 自动跑检查 → 结果发到 Slack/飞书</li>
<li>App 崩溃上报（Sentry/自建）→ 自动建 Jira 工单并分配到对应模块负责人</li>
<li>收到一个 HTTP 请求（Webhook）→ 调用内部 API → 把结果写入表格/数据库并通知群里</li>
</ul>
<p>n8n有中文教程，网站是：<a href="https://link.juejin.cn?target=https%3A%2F%2Fn8n.akashio.com%2Farticle%2Fwelcome" target="_blank" title="https://n8n.akashio.com/article/welcome" ref="nofollow noopener noreferrer">n8n.akashio.com/article/wel…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b07f77907464878a960fb64f9036f6c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVGltZUZpbmU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766738870&amp;x-signature=9IBBdsLXNbXHM7omg%2Br2fxBUtLk%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">四、面向未来</h2>
<p>现在的AI社区空前火热，各路工程师热情高涨，AI编程的浪潮滚滚向前，大家都是学习者、追随者，跟上时代的发展脚步，一起来解放生产力。人生苦短，多用AI。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[跨平台开发地图：客户端技术选型指南 | 2025年12月]]></title>    <link>https://juejin.cn/post/7585222924566249512</link>    <guid>https://juejin.cn/post/7585222924566249512</guid>    <pubDate>2025-12-19T08:53:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585222924566249512" data-draft-id="7585130590292983823" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="跨平台开发地图：客户端技术选型指南 | 2025年12月"/> <meta itemprop="keywords" content="Flutter,客户端"/> <meta itemprop="datePublished" content="2025-12-19T08:53:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员老刘"/> <meta itemprop="url" content="https://juejin.cn/user/662360127965769"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            跨平台开发地图：客户端技术选型指南 | 2025年12月
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/662360127965769/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员老刘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:53:26.000Z" title="Fri Dec 19 2025 08:53:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>哈喽，我是老刘</strong></p>
<p>2024年全球移动应用下载量突破2570亿次，但开发者面对的现实是：平台越来越多、成本翻倍、体验难统一。iOS/Android/鸿蒙/桌面端/Web/小程序，各有一套开发与设计规范，原生很难在多设备上做到一致。</p>
<p>跨平台是机会，却更是选择题：Flutter讲性能、React Native讲生态、uni-app讲覆盖、KMP讲原生。</p>
<p>如何做好这道选择题，把有限的资源发挥出最大的效率？</p>
<p>老刘每个月为大家画出最新的跨平台技术选型地图，帮你快速做决策。</p>
<p>本月很多跨平台框架都有细节方面的更新。</p>
<hr/>
<h2 data-id="heading-0">一、2025年跨平台技术趋势</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/92ab24e8767945c0894d032da4c4c26b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=B%2FMX9MzHSQy5vQxtPGgCKf83jlQ%3D" alt="" loading="lazy"/></p>
<p><strong>第一个变化：性能差距在缩小</strong></p>
<p>现在Flutter的自渲染引擎已经能达到60fps的流畅度。</p>
<p>uni-app x的UTS编译技术，直接把代码转成原生Kotlin和Swift。</p>
<p>跨平台方案与原生的性能差距已经小到用户感知不到的程度。</p>
<p><strong>第二个变化：大厂开始重注跨平台</strong></p>
<p>2024年5月，微软正式停止Xamarin支持，全力推.NET MAUI。</p>
<p>同一时间，Google官方开始支持Kotlin Multiplatform。</p>
<p><strong>第三个变化：AI加持下的开发效率暴增</strong></p>
<p>现在用Claude Code、Cursor等工具写Flutter代码，效率比以前高了3倍。</p>
<p>特别是UI界面，直接传入设计图就能生成可用的代码。</p>
<p>跨平台开发的学习门槛大幅降低。</p>
<h3 data-id="heading-1">最新技术动态</h3>
<h4 data-id="heading-2">React Native 新架构全面启用</h4>
<p><strong>React Native 0.83 里程碑版本</strong></p>
<p>React Native 0.83 - No Breaking Changes: <a href="https://link.juejin.cn?target=https%3A%2F%2Freactnative.dev%2Fblog" target="_blank" title="https://reactnative.dev/blog" ref="nofollow noopener noreferrer">reactnative.dev/blog</a></p>
<ul>
<li>
<p><strong>0.83 正式发布 (12月10日)</strong></p>
<ul>
<li>史无前例：<strong>首个无 User-Facing Breaking Changes 的版本</strong>，升级平滑</li>
<li><strong>React 19.2 支持</strong>：引入 <code>&lt;Activity&gt;</code> (可保留状态的隐藏) 和 <code>useEffectEvent</code></li>
<li><strong>全新桌面端 DevTools</strong>：不再依赖浏览器，内置网络请求审查 (Network Inspector) 和性能追踪 (Performance Tracing)</li>
<li><strong>Web API 对齐</strong>：Intersection Observer API 进入 Canary 阶段</li>
<li>安全提示：不受 React Server Components (CVE-2025–55182) 漏洞影响</li>
</ul>
</li>
<li>
<p>0.82 (10月发布)</p>
<ul>
<li>完全基于新架构运行，作为新时代的开端</li>
</ul>
</li>
</ul>
<h4 data-id="heading-3">Kotlin Multiplatform 生态成熟加速</h4>
<p><strong>Compose Multiplatform 1.10.0 蓄势待发</strong></p>
<ul>
<li>
<p><strong>Compose Multiplatform 1.10.0-RC2 (12月9日)</strong></p>
<ul>
<li>修复 iOS 辅助功能 (Accessibility) 导致的崩溃问题</li>
<li>解决布局节点树可能损坏的 Bug</li>
<li>1.10.0 正式版即将到来，建议开发者关注 RC 版本的稳定性验证</li>
</ul>
</li>
<li>
<p>Compose Multiplatform 1.9.3 (11月6日)</p>
<ul>
<li>带来对最新 AGP 的兼容建议、引入实验性的 MaterialExpressiveTheme</li>
</ul>
</li>
</ul>
<h4 data-id="heading-4">.NET MAUI 企业级发展</h4>
<p><strong>.NET 10 LTS 与首个维护版本</strong></p>
<p>.NET Multi-platform App UI：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdotnet.microsoft.com%2Fen-us%2Fapps%2Fmaui" target="_blank" title="https://dotnet.microsoft.com/en-us/apps/maui" ref="nofollow noopener noreferrer">dotnet.microsoft.com/en-us/apps/…</a></p>
<ul>
<li><strong>.NET 10.0.1 (12月9日)</strong>：.NET 10 LTS 发布后的首个维护补丁，进一步提升稳定性</li>
<li>.NET 10 (11月发布)：正式成为 LTS 版本，支持至 2028年11月</li>
<li>Uno Platform 6.3：带来 .NET 10 (RC) 支持、VS 2026 兼容及 WebAssembly 性能提升</li>
</ul>
<h4 data-id="heading-5">Flutter 平台更新</h4>
<p>Flutter 3.38 持续演进: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Frelease%2Fwhats-new" target="_blank" title="https://docs.flutter.dev/release/whats-new" ref="nofollow noopener noreferrer">docs.flutter.dev/release/wha…</a></p>
<ul>
<li><strong>稳定版现状 (12月中旬)</strong>：3.38 仍为当前最新稳定大版本，重点在于生态适配与 iOS 26+ 支持</li>
<li>3.38 于11月发布，支持 Apple 强制的 UIScene 生命周期，需要进行代码迁移</li>
<li>文档站点迁移到 Jaspr（Dart Web 框架），开发者文档与工具集成改进</li>
<li>Widget Previewer 在 VS Code/IntelliJ 进一步集成，提升预览与调试效率</li>
<li>平台支持同步 iOS 26、Xcode 26、macOS 26，稳定性与兼容性提升</li>
<li>Dart 3.6 点速记语法（Dot shorthands）默认开启，减少样板代码（如 <code>.start</code>）</li>
<li>Web 开发增强：<code>web_dev_config.yaml</code> 支持配置开发服务器与代理，热重载可多浏览器连接</li>
<li>OverlayPortal 新能力：子 Widget 可渲染到任意 Overlay，适合弹窗、气泡、提示等复杂浮层</li>
<li>Windows 桌面增强：<code>PlatformDispatcher.displays</code> 可获取显示器分辨率、刷新率、DPR、物理尺寸等</li>
<li>修复 Android 端 Activity 销毁内存泄漏（issue #173770），影响自 3.29.0 引入的缺陷</li>
</ul>
<h4 data-id="heading-6">uni-app x 进展</h4>
<p>uni-app x 4.84/4.85 更新日志: <a href="https://link.juejin.cn?target=https%3A%2F%2Funiapp.dcloud.io%2Frelease" target="_blank" title="https://uniapp.dcloud.io/release" ref="nofollow noopener noreferrer">uniapp.dcloud.io/release</a></p>
<ul>
<li>新增 API <code>uni.createWorker</code> 支持 Worker 线程，提升计算与渲染并发能力（4.84）</li>
<li>App(iOS/Android) 新增 <code>image</code> 支持 SVG、<code>live-player</code>/<code>live-pusher</code> 实时音视频、广告视频等能力</li>
<li>HarmonyOS 增强：<code>themeChange</code> 主题切换、登录/分享、屏幕亮度 API、逻辑层 JSVM 迁移至子线程</li>
<li>多平台稳定性修复：list-view 拖动加载崩溃、编译器 async 嵌套报错、web-view/scroll-view 等问题修复（4.85）</li>
</ul>
<h4 data-id="heading-7">Valdi 进展</h4>
<p>Snapchat 开源跨平台框架: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSnapchat%2FValdi" target="_blank" title="https://github.com/Snapchat/Valdi" ref="nofollow noopener noreferrer">github.com/Snapchat/Va…</a></p>
<ul>
<li><strong>正式开源 (11月中旬-12月)</strong>：Snapchat 将内部打磨 8 年的跨平台框架 Valdi 正式开源 (Beta 阶段)</li>
<li><strong>核心特性</strong>：
<ul>
<li><strong>TypeScript + Native Views</strong>：使用 TSX 编写，编译为纯原生视图 (UIKit/Android View)，无 WebView，无 JS Bridge</li>
<li><strong>高性能架构</strong>：内置全局视图复用池 (View Recycling) 和 C++ 布局引擎，主打列表滚动与复杂 UI 性能</li>
<li><strong>开发体验</strong>：支持 VS Code 调试、毫秒级热重载 (Hot Reload)</li>
</ul>
</li>
<li><strong>社区动态</strong>：Callstack 等技术团队已发布深度评测，认为其在 "原生性能 vs 开发效率" 的平衡上提供了新思路，是 React Native 的有力竞争者</li>
</ul>
<p>接下来老刘按照跨平台技术框架的三种路线，分别介绍一下目前主流的跨平台技术。</p>
<hr/>
<h2 data-id="heading-8">二、自渲染类框架</h2>
<p><strong>什么是自渲染？</strong></p>
<p>简单来说，就是框架自己画界面，不用系统提供的组件。</p>
<p>就像游戏引擎一样，每个像素都是自己控制的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eef7619abe3f4d08b9fc0d098e5a8c48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=VthvB5sVwh3c3KpKUG2srmt8reM%3D" alt=" " loading="lazy"/></p>
<p>这样做有什么好处？</p>
<p><strong>第一，界面完全一致</strong></p>
<p>在iPhone上看到的按钮，和在Android上看到的按钮，一模一样。</p>
<p>同样的UI代码，在不同平台上运行，不会因为转嫁到系统的UI组件而导致展示效果或者逻辑不一致。</p>
<p><strong>第二，性能媲美原生</strong></p>
<p>因为跳过了系统的UI层，直接操作GPU绘制。</p>
<p>本质上和原生系统框架采用相同的架构，因此性能上也不会有太大的区别。</p>
<p><strong>第三，没有兼容性bug</strong></p>
<p>其它两种方案不管是中间层还是转义，最终都会去调用系统原生的组件。</p>
<p>这个过程中因为不同系统的组件功能差异和实现方案不同就会导致一些兼容性问题。</p>
<p>其中比较复杂的问题可能需要开发者自己去原生代码的层面去定位和解决。</p>
<p>而自渲染的框架，因为跳过了系统的UI层，所以不会有这个问题。</p>
<h3 data-id="heading-9">2.1 Flutter</h3>
<h4 data-id="heading-10">Flutter现在有多火？</h4>
<p>2024年Stack Overflow调查显示，Flutter是最受欢迎的跨平台框架。</p>
<p>全球有超过500万开发者在使用。</p>
<p>连阿里巴巴、腾讯、字节跳动都在使用Flutter。</p>
<p><strong>为什么这么多大厂选择Flutter？</strong></p>
<p><strong>原因一：性能真的强</strong></p>
<p>自从切换了Impeller引擎，Flutter真的是和原生应用性能一致。</p>
<p><strong>原因二：开发效率高</strong></p>
<p>热重载功能让你改代码后，1秒钟就能看到效果。</p>
<p>不用重新编译，不用重新安装。</p>
<p>同时，Dart语言本身的在编码复杂性和功能性方面平衡做的非常好，日常开发的效率很高。</p>
<p><strong>原因三：生态成熟</strong></p>
<p>pub.dev上有超过4万个插件包。</p>
<p>基本上你能想到的功能，都有现成的插件。</p>
<p>地图、支付、推送、数据库...应有尽有。</p>
<p><strong>原因四：对单元测试的良好支持</strong></p>
<p>Flutter是目前为止客户端开发领域中对单元测试支持最好的框架。</p>
<p>这一点比原生开发都要好，是Flutter独有的优势。</p>
<p>如果你的团队使用TDD或者敏捷流程，Flutter可能是最优选择。</p>
<p><strong>原因五：AI的积极跟进</strong></p>
<p>Flutter在AI时代的表现让人刮目相看。</p>
<p>Google官方推出了Flutter AI Toolkit，直接集成了Gemini API。</p>
<p>开发者可以用几行代码就实现AI聊天、图像识别、语音转文字等功能。</p>
<p>而且Flutter对AI模型的本地部署支持也很好。</p>
<p>TensorFlow Lite、ONNX Runtime都有官方插件。</p>
<p>你可以把AI模型直接打包到应用里，不依赖网络也能跑AI功能。</p>
<p>这在隐私要求高的场景下特别有用。</p>
<p>最近还有个新玩意儿——Dart MCP Server。</p>
<p>简单说，就是让AI助手能直接理解和操作你的Dart/Flutter项目。</p>
<p>你可以让AI直接帮你写Flutter代码、读取运行中的组件树、调试问题、优化性能。</p>
<p>总之，可以看到Flutter团队在对接AI方面的前瞻性和重视度。</p>
<hr/>
<h2 data-id="heading-11">三、中间层类框架</h2>
<p><strong>什么是中间层框架？</strong></p>
<p>简单来说，就是在你的代码和系统原生组件之间，加了一个"翻译官"。</p>
<p>你用JavaScript写界面逻辑，框架帮你"翻译"成原生的Button、TextView。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9ba092f5758445f982b3a5cc766a15e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=fF4xa9YNc51LzFPGcTJQnpitCRI%3D" alt=" " loading="lazy"/></p>
<p>这种方案有什么特点？</p>
<p><strong>第一，开发体验接近Web</strong></p>
<p>如果你的团队熟悉React、Vue这些Web框架，上手会很快。</p>
<p>基本上就是把Web开发的那套思路搬到移动端。</p>
<p><strong>第二，能调用原生组件</strong></p>
<p>最终渲染的还是系统原生的Button、Input。</p>
<p>所以界面看起来很"原生"，符合各平台的设计规范。</p>
<p><strong>第三，存在性能损耗</strong></p>
<p>因为有个"翻译"的过程，JavaScript和原生代码之间要频繁通信。</p>
<p>就像两个人通过翻译官对话，肯定比直接对话慢一些。</p>
<p>但这个损耗在交互不频繁的界面中，用户是感知不到的。</p>
<h3 data-id="heading-12">3.1 React Native</h3>
<h4 data-id="heading-13">React Native的优势</h4>
<p><strong>原因一：Web开发者的福音</strong></p>
<p>如果你会React，学React Native基本没有门槛。</p>
<p>同样的JSX语法，同样的组件化思想，同样的状态管理。</p>
<p>一个熟练的React开发者，一周就能上手React Native。</p>
<p><strong>原因二：生态系统超级丰富</strong></p>
<p>npm上有超过15万个React Native相关的包。</p>
<p>导航、动画、图表、支付...你能想到的功能都有现成的库。</p>
<p>而且因为和React共享生态，很多Web端的库稍作修改就能用。</p>
<p><strong>原因三：热更新能力</strong></p>
<p>这是React Native的杀手锏功能。</p>
<p>发现bug？不用重新发版，直接推送补丁代码就能修复。</p>
<p>新功能上线？用户打开App就能看到，不用去应用商店更新。</p>
<p>这对产品迭代速度的提升是巨大的。</p>
<p><strong>原因四：Meta的持续投入</strong></p>
<p>2024年Meta发布了新架构（New Architecture）。</p>
<p>引入了Fabric渲染器和TurboModules，性能提升了30%。</p>
<p>2025年10月8日，React Native 0.82 正式发布，新架构全面启用，旧架构正式退役。</p>
<h3 data-id="heading-14">3.2 .NET MAUI</h3>
<h4 data-id="heading-15">.NET MAUI是什么来头？</h4>
<p>2024年5月，微软正式停止了Xamarin的支持。</p>
<p>.NET MAUI（Multi-platform App UI）成为微软官方的跨平台解决方案。</p>
<p>这不是简单的换个名字，而是架构的全面升级。</p>
<p><strong>MAUI相比Xamarin有什么改进？</strong></p>
<p><strong>第一，统一的项目结构</strong></p>
<p>以前Xamarin需要为每个平台创建单独的项目。</p>
<p>MAUI只需要一个项目，就能构建所有平台的应用。</p>
<p><strong>第二，性能大幅提升</strong></p>
<p>新的渲染引擎减少了50%的内存占用。</p>
<p>启动速度比Xamarin快了30%。</p>
<p><strong>第三，开发体验优化</strong></p>
<p>热重载功能让你改C#代码后，立即看到效果。</p>
<p>集成了最新的.NET 8特性，开发效率更高。</p>
<h4 data-id="heading-16">.NET MAUI的独特优势</h4>
<p><strong>企业级支持</strong></p>
<p>微软提供长期技术支持（LTS）。</p>
<p>对于企业应用来说，这种稳定性保障非常重要。</p>
<p><strong>强大的数据处理能力</strong></p>
<p>C#在处理复杂业务逻辑方面有天然优势。</p>
<p>特别是金融、ERP这类数据密集型应用。</p>
<p><strong>与微软生态深度集成</strong></p>
<p>如果你的后端用Azure、数据库用SQL Server。</p>
<p>MAUI能提供最佳的集成体验。</p>
<p><strong>总结一下中间层框架的特点</strong></p>
<p>优势：学习成本低，能复用Web开发经验，界面原生感强。</p>
<p>劣势：存在桥接性能损耗，依赖第三方库封装原生功能。</p>
<p>适合场景：快速开发、团队技术栈匹配、对原生感要求高的项目。</p>
<hr/>
<h2 data-id="heading-17">四、转译类框架</h2>
<p><strong>什么是转译？</strong></p>
<p>简单来说，就是把你写的高级语言代码，"翻译"成目标平台的原生代码。</p>
<p>比如你用Kotlin写业务逻辑，框架帮你"翻译"成iOS的Swift代码。</p>
<p>或者你用类TypeScript的语法写界面，框架帮你"翻译"成Android的Kotlin和iOS的Swift。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b1297c1152f4c9e98c5e71a19b15c84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=fdvztuLBYbyISJ%2BGDglNqDaz3KY%3D" alt=" " loading="lazy"/></p>
<p>这种方案有什么特点？</p>
<p><strong>第一，性能最接近原生</strong></p>
<p>因为最终运行的就是原生代码，没有任何中间层损耗。</p>
<p>就像你直接用Swift写iOS应用，用Kotlin写Android应用一样。</p>
<p><strong>第二，能享受原生生态</strong></p>
<p>转译后的代码可以直接调用平台的所有API。</p>
<p><strong>第三，转译效果可能不完美</strong></p>
<p>毕竟是机器"翻译"的代码，有时候可能不如手写的原生代码优雅。</p>
<p>特别是复杂的业务逻辑，转译后的代码可能需要人工优化。</p>
<p>但这个问题随着AI技术的发展，正在快速改善。</p>
<h3 data-id="heading-18">4.1 Kotlin Multiplatform (KMP)</h3>
<h4 data-id="heading-19">KMP为什么突然火了？</h4>
<p>2024年是KMP的爆发年。</p>
<p>5月份，Google在I/O大会上宣布官方支持KMP。</p>
<p>以前KMP只是JetBrains的"个人项目"，现在有了Google的官方背书。</p>
<p>Android开发者可以放心使用，不用担心被抛弃。</p>
<p><strong>Kotlin-to-Swift 导出功能已公开发布（10月首次发布），仍处早期阶段。</strong></p>
<p>你用Kotlin写的业务逻辑，可以直接转成Swift代码。</p>
<p>iOS开发者拿到的就是纯Swift代码，可以像原生项目一样调试和优化。</p>
<h4 data-id="heading-20">KMP的核心理念</h4>
<p><strong>"业务逻辑用KMP共享，UI用Compose Multiplatform统一开发"</strong></p>
<p>这是KMP的最新发展方向，结合了Compose Multiplatform的强大能力。</p>
<p>传统的KMP是"业务逻辑共享，UI各平台原生"。</p>
<p>但现在有了更好的选择——Compose Multiplatform。</p>
<p>一套Compose代码可以运行在Android、iOS、Desktop、Web等所有平台。</p>
<p>业务逻辑用KMP共享，UI用Compose Multiplatform统一开发。</p>
<p><strong>这样做有什么好处？</strong></p>
<p><strong>第一，真正的一套代码多平台</strong></p>
<p>不仅业务逻辑共享，UI也可以共享，开发效率大幅提升。</p>
<p><strong>第二，保持原生性能</strong></p>
<p>Compose Multiplatform在各平台都编译为原生代码，性能接近原生应用。</p>
<p><strong>第三，技术栈统一</strong></p>
<p>全部使用Kotlin生态，学习成本更低，团队协作更高效。</p>
<p><strong>第四，渐进式迁移</strong></p>
<p>你不需要重写整个应用，可以先从一个模块开始。</p>
<p>比如先把网络层用KMP重写，然后逐步迁移UI到Compose Multiplatform。</p>
<p><strong>但这个组合也有挑战</strong></p>
<p><strong>Compose Multiplatform 在 iOS 端已稳定</strong>：生态仍在加速建设，注意版本兼容与插件成熟度</p>
<p><strong>学习成本相对较高</strong>：需要掌握Kotlin和Compose</p>
<p><strong>生态还在建设中</strong>：第三方库相对较少，但发展很快</p>
<h3 data-id="heading-21">4.2 uni-app / uni-app x</h3>
<h4 data-id="heading-22">uni-app的进化之路</h4>
<p>说到uni-app，很多人的印象还停留在"小程序开发工具"。</p>
<p>但2024年，uni-app发生了质的变化。</p>
<p><strong>传统uni-app</strong>：基于Vue.js + JavaScript，更适用于小程序开发</p>
<p><strong>uni-app x</strong>：全新架构，使用UTS语言，性能达到原生级别</p>
<p>这不是简单的版本升级，而是技术路线的根本改变。</p>
<h4 data-id="heading-23">uni-app x的技术突破</h4>
<p><strong>第一，UTS语言</strong></p>
<p>UTS（UniTypeScript）是DCloud自研的编程语言。</p>
<p>语法类似TypeScript，但编译后直接生成原生代码。</p>
<p>Android平台编译成Kotlin，iOS平台编译成Swift，鸿蒙平台编译成ArkTS。</p>
<p><strong>第二，uvue渲染引擎</strong></p>
<p>这是uni-app x的核心技术。</p>
<p>不同于传统的WebView渲染，uvue直接调用原生渲染引擎。</p>
<p>性能和原生应用完全一致，没有任何损耗。</p>
<p><strong>第三，无桥接架构</strong></p>
<p>传统跨平台框架都有个"桥接层"，用来连接JavaScript和原生代码。</p>
<p>uni-app x直接编译成原生代码，完全没有桥接层。</p>
<p>这意味着没有跨语言通信损耗，性能达到原生级别。</p>
<p><strong>第四，直接调用原生API</strong></p>
<p>因为编译后就是原生代码，可以直接调用平台的所有API。</p>
<p>不需要等插件封装，新的系统功能立即可用。</p>
<h4 data-id="heading-24">uni-app x的独特优势</h4>
<p><strong>平台支持最全</strong></p>
<p>这是uni-app的传统优势。</p>
<p>一套代码可以发布到：iOS、Android、Web、各种小程序、快应用、鸿蒙...</p>
<p>总共支持14+个平台，这是其他框架做不到的。</p>
<p><strong>小程序优先的设计理念</strong></p>
<p>如果你的产品需要同时支持App和小程序。</p>
<p>uni-app是唯一的选择。</p>
<p>其他框架都是"App优先"，小程序支持都是后加的。</p>
<p><strong>国产化支持</strong></p>
<p>对鸿蒙、信创等国产化平台支持最好。</p>
<p>这对国内企业来说非常重要。</p>
<p><strong>学习成本低</strong></p>
<p>如果你会Vue.js，学uni-app基本没有门槛。</p>
<p>语法、组件、生态都和Vue高度一致。</p>
<p><strong>但uni-app也有局限</strong></p>
<p><strong>生态相对封闭</strong>：主要依赖DCloud的生态</p>
<p><strong>国际化程度低</strong>：海外开发者使用较少</p>
<p><strong>技术栈绑定</strong>：主要适合Vue技术栈</p>
<h3 data-id="heading-25">4.3 Valdi 加入战场</h3>
<h4 data-id="heading-26">Valdi 的基本原理</h4>
<p>Valdi的核心思路属于转义方案的范畴，但是并发代码级转义。</p>
<p>具体怎么做到的？</p>
<p><strong>1. 编译时转译</strong></p>
<ul>
<li>TSX代码 → 原生视图代码（OC/Swift + Java/Kotlin）</li>
<li>布局引擎用C++重写，支持独立重渲染和视图回收</li>
<li>编译阶段就生成类型安全的绑定，空指针异常直接堵在编译期</li>
</ul>
<p><strong>2. 运行时架构</strong></p>
<ul>
<li>无JS Bridge，零跨线程通信开销</li>
<li>业务逻辑可分层：性能关键路径用C++/Swift/Kotlin写"Polyglot模块"，框架自动生成TS绑定</li>
<li>非关键逻辑留在JS端，配合Worker线程做后台任务</li>
</ul>
<p><strong>3. 热重载机制</strong></p>
<ul>
<li>文件保存 → 200ms内看到刷新</li>
<li>不丢状态、不重启App</li>
<li>VSCode调试链完整，断点直接断在TS源码</li>
</ul>
<p><strong>4. 内存管理</strong></p>
<ul>
<li>自动视图回收</li>
<li>增量渲染</li>
</ul>
<p>这种技术方案其实是介于转译和中间层之间的一种方式。</p>
<p>UI组件树翻译成原生组件，组件的生命周期交给C++编写的引擎管理，业务逻辑部分则保留在TS层。</p>
<p>这样的好处是在一定程度上避免了转译类方案代码翻译不到位造成的一些问题。</p>
<p>但是仍然会有中间层方案在高UI交互场景下的性能问题，这部分就需要把处理逻辑放到C++/Swift/Kotlin编写的"Polyglot模块"解决。</p>
<p>总的来说，这套架构在Snapchat内部跑了8年，扛住了8.5亿月活的洪荒流量。</p>
<p>现在开源出来，就是把踩过的坑都帮你填平了。</p>
<p><strong>总结一句话：Valdi很有潜力，但现在更适合技术探索，不是生产环境的首选。</strong></p>
<p>站在纯粹客户端跨平台开发的角度，转义类方案老刘目前更推荐KMP。</p>
<p>Valdi可以作为一个有潜力的备选，等生态更加成熟后再重新考虑。</p>
<p><strong>总结一下转译类框架的特点</strong></p>
<p>优势：性能最接近原生，能享受原生生态，没有运行时损耗。</p>
<p>劣势：学习成本相对较高，转译效果可能需要优化。</p>
<p>适合场景：对性能要求高、需要调用大量原生功能、有原生开发基础的团队。</p>
<hr/>
<h2 data-id="heading-27">五、技术选型指南</h2>
<p>看了这么多框架，是不是更纠结了？</p>
<p>别慌，老刘给你一个简单粗暴的选型指南。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9eafa0a98ea408fbc59d52c36959648~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=9HTf1paChYK7DAiOZ4w5y9VqNkg%3D" alt=" " loading="lazy"/></p>
<h3 data-id="heading-28">5.1 Flutter：大多数App的不二之选</h3>
<p>其实对于大多数App来说，Flutter都是当前阶段最合适的选择</p>
<p>为什么这么说？</p>
<p><strong>性能足够强悍</strong></p>
<p>如果在大街上随机找100个人，把他们手机里面的非游戏类App都拿出来，那么其中99%都是Flutter可以胜任的。</p>
<p>对于性能有极端要求的App来说其实大概率原生开发也不行，需要更深度的优化方式。</p>
<p>比如把数据加解密、视频编解码等工作封装到更底层的so库中。</p>
<p>而这种优化方案在Flutter项目中也能使用，工作量和原生中差不多。</p>
<p><strong>开发效率够高</strong></p>
<p>Flutter的热重载功能，改代码后1秒内就能看到效果。</p>
<p>这比原生开发快了10倍不止。</p>
<p>而且Flutter的组件库非常丰富。</p>
<p>Material Design和Cupertino组件开箱即用。</p>
<p>对于更复杂的组件和绘制定制场景，由于Flutter自带渲染引擎，因此也可以直接在暴露给开发者的canvas上进行更复杂的渲染定制。</p>
<p><strong>TDD开发流程的完美搭档</strong></p>
<p>Flutter天生支持单元测试、集成测试、UI测试。</p>
<p>测试覆盖率可以轻松达到90%以上。</p>
<p>CI/CD集成也非常简单，GitHub Actions、GitLab CI都有现成的模板。</p>
<p>如果计划采用TDD相关的开发流程，Flutter可能是目前唯一的选择。</p>
<p><strong>AI时代的宠儿</strong></p>
<p>Google全力加持Flutter，AI工具链日趋完善。</p>
<p>GPT、Cursor、Claude Code对Flutter的支持都很好。</p>
<p>写Flutter代码，AI能帮你完成80%的重复工作。</p>
<p><strong>Flutter适合什么项目？</strong></p>
<ul>
<li>需要高性能的应用（游戏、视频、图形处理）</li>
<li>对UI一致性要求高的应用</li>
<li>团队有充足的学习时间</li>
<li>需要长期维护的项目</li>
<li>对包体积不是特别敏感的应用</li>
</ul>
<h3 data-id="heading-29">5.2 KMP：潜力股还是画饼？先别急着上车</h3>
<p><strong>Kotlin Multiplatform：Google亲儿子的野心与现实</strong></p>
<p>KMP确实很香，但现在上车可能还早了点。</p>
<p><strong>现状分析：技术很香，但生态还在"襁褓期"</strong></p>
<p>KMP的技术理念非常先进。</p>
<p>但问题是——生态还不够成熟。</p>
<p>第三方库支持有限，很多常用功能需要自己封装。</p>
<p>调试工具也不够完善，出了问题排查起来比较麻烦。</p>
<p><strong>适用场景：密集调用原生API的项目可以关注</strong></p>
<p>如果你的应用需要大量调用原生API：</p>
<ul>
<li>相机、麦克风、传感器</li>
<li>蓝牙、NFC、GPS</li>
<li>系统级权限管理</li>
</ul>
<p>KMP确实有优势。</p>
<p>因为它可以直接调用原生代码，没有性能损耗。</p>
<p><strong>风险提醒：早期采用者需要踩坑的心理准备</strong></p>
<p>选择KMP，你需要做好这些准备：</p>
<ul>
<li>遇到问题时，Stack Overflow上的答案可能很少</li>
<li>第三方库可能不支持，需要自己写原生桥接</li>
<li>团队需要同时掌握Kotlin、Swift、Android、iOS开发</li>
<li>项目初期开发效率可能不如Flutter</li>
</ul>
<p><strong>未来展望：如果KMP真正成熟，将是原生开发的强力补充</strong></p>
<p>Google已经把KMP列为官方支持的技术。</p>
<p>JetBrains也在大力投入。</p>
<p>如果生态能在2025年下半年成熟起来，KMP确实值得考虑。</p>
<p><strong>建议：除非你是技术极客，否则再等等</strong></p>
<p>如果你的团队技术实力很强，喜欢尝试新技术，可以在小项目上试试KMP。</p>
<p>但如果你需要稳定可靠的解决方案，建议再等一年。</p>
<p>等KMP的生态更成熟一些，再考虑大规模使用。</p>
<h3 data-id="heading-30">5.3 App + 小程序：别被"一套代码走天下"忽悠了</h3>
<p><strong>App和小程序一套代码？这可能是个伪命题！</strong></p>
<p>很多人被"一套代码，多端运行"的口号忽悠了。</p>
<p>以为App和小程序可以用同一套代码。</p>
<p>但现实是——这样做可能得不偿失。</p>
<p><strong>思维误区：把小程序当App的"乞丐版"是大错特错</strong></p>
<p>很多人觉得小程序就是App的简化版。</p>
<p>功能少一点，界面简单一点，用户体验差一点。</p>
<p>这种想法完全错了。</p>
<p>App和小程序应该承担不同的产品职责。</p>
<p><strong>正确姿势：App和小程序应该承担不同的产品职责</strong></p>
<p>App的优势：</p>
<ul>
<li>性能更好，可以做复杂交互</li>
<li>可以离线使用</li>
<li>推送通知更及时</li>
<li>用户粘性更高</li>
</ul>
<p>小程序的优势：</p>
<ul>
<li>获客成本更低</li>
<li>分享传播更容易</li>
<li>用户使用门槛更低</li>
<li>可以借助平台流量</li>
</ul>
<p><strong>成功案例解析：微信读书的分工</strong></p>
<p>微信读书就是一个很好的例子。</p>
<p><strong>App承担重交互功能：</strong></p>
<ul>
<li>长时间阅读体验优化</li>
<li>个性化推荐算法</li>
<li>离线下载功能</li>
<li>复杂的社交互动</li>
</ul>
<p><strong>小程序专注营销拉新：</strong></p>
<ul>
<li>好友推荐分享</li>
<li>读书打卡活动</li>
<li>限时免费活动</li>
<li>新用户引导体验</li>
</ul>
<p>这样分工，App和小程序各司其职，效果比"一套代码"好得多。</p>
<p><strong>技术选型建议</strong></p>
<p><strong>功能重叠度高的情况：</strong></p>
<p>如果你的App和小程序功能重叠度超过70%，可以考虑uni-app等跨端方案。</p>
<p>比如电商类应用，商品展示、购物车、订单管理这些功能，App和小程序基本一样。</p>
<p><strong>功能差异化大的情况：</strong></p>
<p>如果App和小程序的功能差异很大，建议分别选择最适合的技术栈。</p>
<p>App用Flutter或原生开发，专注用户体验。</p>
<p>小程序用原生小程序开发，专注营销转化。</p>
<p><strong>避坑指南：不要为了技术统一而牺牲用户体验</strong></p>
<p>很多团队为了技术栈统一，强行用一套代码开发App和小程序。</p>
<p>结果App体验不如原生，小程序功能又太复杂。</p>
<p>两边都不讨好。</p>
<p>记住：技术是为产品服务的，不是为了技术而技术。</p>
<p><strong>总结一下技术选型的核心原则</strong></p>
<ol>
<li>
<p><strong>大多数情况选Flutter</strong>：性能、生态、开发效率都很均衡</p>
</li>
<li>
<p><strong>KMP可以关注但别急着用</strong>：等生态成熟一些再说</p>
</li>
<li>
<p><strong>App和小程序要差异化定位</strong>：不要被"一套代码"忽悠</p>
</li>
<li>
<p><strong>根据团队技术栈选择</strong>：学习成本也是成本</p>
</li>
<li>
<p><strong>考虑项目的长期维护</strong>：选择有长期支持的技术</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-31">六、总结与建议</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f7ceb7c7220486f992975b4dbce0498~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739206&amp;x-signature=sYSYMeSzyUhXnaUHgzSaSJ8wUQM%3D" alt=" " loading="lazy"/></p>
<p>写了这么多，老刘最后给你一个终极建议。</p>
<p><strong>2025年跨平台开发，记住这三个关键词：务实、聚焦、长期主义。</strong></p>
<h3 data-id="heading-32">务实：别追求完美的技术方案</h3>
<p>很多团队陷入"技术洁癖"。</p>
<p>总想找到一个完美的跨平台方案，既要性能好，又要学习成本低，还要生态丰富。</p>
<p>醒醒吧，这样的方案不存在。</p>
<p><strong>每种技术都有trade-off。</strong></p>
<p>Flutter性能好但包体积大。</p>
<p>React Native生态好但有桥接损耗。</p>
<p>KMP接近原生但生态不成熟。</p>
<p>uni-app平台全但主要适合Vue技术栈。</p>
<p><strong>选择技术的核心是：在当前约束条件下，哪个方案的收益最大。</strong></p>
<p>不要追求完美，要追求合适。</p>
<h3 data-id="heading-33">聚焦：一个团队最多掌握两种跨平台技术</h3>
<p>很多公司什么技术都想试。</p>
<p>Flutter也搞，React Native也搞，KMP也要研究。</p>
<p>结果每个都不精通，遇到问题都解决不了。</p>
<p><strong>建议：选定一个主力技术栈，最多再备一个备选方案。</strong></p>
<h3 data-id="heading-34">长期主义：技术选型要考虑3年后的维护成本</h3>
<p>很多人以为选定技术栈就万事大吉了。</p>
<p>其实真正决定项目生死的，是你选定技术栈之后做的那些事。</p>
<p><strong>架构设计够不够清晰？</strong></p>
<p>模块划分是否合理，接口设计是否稳定，这些直接影响后续迭代的难度。</p>
<p><strong>开发流程够不够规范？</strong></p>
<p>CI/CD流水线、代码审查、测试覆盖率，这些看似繁琐的流程，3年后会救你的命。</p>
<p><strong>代码规范够不够严格？</strong></p>
<p>命名规范、注释规范、目录结构，新人能不能快速上手，老代码能不能看懂。</p>
<p><strong>技术债务管理够不够及时？</strong></p>
<p>每次为了赶进度留下的坑，3年后都会变成巨坑。</p>
<p>选定技术栈不是终点，而是起点。</p>
<p>做好这些基础建设，才是项目能持续健康演进的根本。</p>
<p>否则，再好的技术栈也救不了你。</p>
<h3 data-id="heading-35">最后的最后：技术选型没有标准答案</h3>
<p>老刘写这篇文章，不是为了告诉你"必须选哪个技术"。</p>
<p>而是希望你在选择时，能有一个清晰的思考框架。</p>
<p><strong>2025年，跨平台开发已经不是"能不能做"的问题，而是"怎么做得更好"的问题。</strong></p>
<p>选对了技术栈，团队效率起飞。</p>
<p>选错了技术栈，就是几个月的坑。</p>
<p>希望这篇"跨平台开发地图"能帮你避开那些坑，找到最适合你的路。</p>
<blockquote>
<p>如果看到这里的同学对客户端或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。</p>
<p>私信免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。</p>
<p>可以作为Flutter学习的知识地图。</p>
<p>—— laoliu_dev</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Infra平台市场报告：京东云稳居前三]]></title>    <link>https://juejin.cn/post/7585289701826969609</link>    <guid>https://juejin.cn/post/7585289701826969609</guid>    <pubDate>2025-12-19T08:54:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585289701826969609" data-draft-id="7585406229166981170" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Infra平台市场报告：京东云稳居前三"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2025-12-19T08:54:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Infra平台市场报告：京东云稳居前三
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:54:16.000Z" title="Fri Dec 19 2025 08:54:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>近日，赛迪顾问发布《2025中国AI Infra平台市场研究报告》，凭借在异构算力调度、GPU池化管理等领域的技术创新和实践成果，京东云在“2024年中国AI Infra 平台算力管理层市场厂商竞争力象限分析图”中稳居产品能力前三。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/207d4ad744a94f8da0aced15cd7ee9da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739255&amp;x-signature=rzkJnKuS0hNpQqUD3cnk426%2Ffmw%3D" alt="图片" loading="lazy"/></p>
<p>赛迪在报告中指出：当前AI Infra平台已形成“算力管理层—模型管理层—应用管理层”三层能力体系。其中，算力管理层占主导地位，2024年市场份额达64.6%，异构算力精细化纳管正成为AI Infra平台标配。京东云依托京东集团丰富的业务场景，聚焦“异构算力+极致推理”，致力于构建新一代人工智能基础设施（AI Infra）。其核心平台JoyScale通过软硬件协同优化，实现对华为昇腾、寒武纪、海光等国产芯片的高性能异构计算支持，并借助算力池化与智能调度，提升集群利用效率，实现国产算力的统一纳管与高效运维。</p>
<p>面向大模型训练、推理的算力需求，京东云推出的JoyScale AI算力平台，作为基于京东内部统一GPU池化实践打磨的同源同栈AI基础设施算力平台，支持训练任务和推理服务统一调度和资源共享，支持10+家国产AI算力卡，20+训练推理框架，也是目前业界唯一同时支持英伟达显卡和昇腾NPU远程调用的算力平台，为AI应用的高效运行提供强大的算力支持。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d674c82568164c2c8d7eff51991ba8c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766739255&amp;x-signature=b97HLZRIQfFCaHwaMANJyWjJSH8%3D" alt="图片" loading="lazy"/></p>
<p>JoyScale AI算力平台，具备四大核心优势：</p>
<ul>
<li>
<p><strong>极致算力性能</strong>。行业领先的内核态池化引擎，提供多卡聚合、单卡切分、多机多卡集群化调度、推理加速等差异化能力，满足大参数模型集群化部署要求，JoyScale作为通过信通院最高等级双认证的AI算力平台，可以满足金融级数据安全、性能和稳定性要求，整体推理性能提升50%。</p>
</li>
<li>
<p><strong>高效异构算力调度</strong>。JoyScale全面适配十余家国产算力，兼容适配昇腾、寒武纪、海光等多种国产加速卡，支持异构算力统一纳管、精细化运维，云原生AI调度能力，极致提升AI任务部署密度，整体资源利用率提升70%。</p>
</li>
<li>
<p><strong>深度国产AI生态合作</strong>。京东云和众多国产芯片厂商深度合作，互相开放运行时Runtime层代码，通过GPU/NPU切分池化技术，从内核层屏蔽异构厂商硬件的复杂性，实现更高效的AI算力。</p>
</li>
<li>
<p><strong>支持超20种AI训推框架</strong>。训练框架支持PyTorch、TensorFlow、DeepSpeed，MindSpore等；推理框架支持vllm，sglang，MindIE，triton，TensorRT-LLM等。</p>
</li>
</ul>
<p>当前，基于京东集团复杂场景实践，京东云已经构建了一站式大模型产品矩阵，从底层的智算基础设施，到中间层的模型服务和工具，再到上层的Agent应用开发，支持国央企快速部署大模型及AI应用，重塑AI生产力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[How does AutoMQ implement a sub-10ms latency Diskless Kafka?]]></title>    <link>https://juejin.cn/post/7585138968167612452</link>    <guid>https://juejin.cn/post/7585138968167612452</guid>    <pubDate>2025-12-19T08:59:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585138968167612452" data-draft-id="7585173051647213604" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="How does AutoMQ implement a sub-10ms latency Diskless Kafka?"/> <meta itemprop="keywords" content="后端,架构"/> <meta itemprop="datePublished" content="2025-12-19T08:59:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AutoMQ"/> <meta itemprop="url" content="https://juejin.cn/user/2878958479084707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            How does AutoMQ implement a sub-10ms latency Diskless Kafka?
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2878958479084707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AutoMQ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:59:12.000Z" title="Fri Dec 19 2025 08:59:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Abstract</strong></h2>
<p>Running Apache Kafka in the cloud is constrained by three fundamental engineering challenges: the heavy reliance on local disks for low-latency performance, excessive cross-availability zone (AZ) data transfer costs, and the lack of elasticity caused by tightly coupled compute and storage.</p>
<p>In response, AutoMQ has architected a completely new Diskless Kafka solution built on Amazon FSx and S3. This article details how AutoMQ re-engineers the storage layer to achieve sub-10ms write latency while maintaining 100% compatibility with the Kafka protocol—delivering a cloud-native Kafka platform that is high-performance, operationally effortless, and significantly cost-efficient.</p>
<blockquote>
<p><strong>Note:</strong> Unless otherwise specified, all references to AutoMQ in this article refer to the AutoMQ BYOC edition.</p>
</blockquote>
<h2 data-id="heading-1"><strong>FSx for NetApp ONTAP</strong></h2>
<p>Before delving into the implementation details of AutoMQ, let's first introduce FSx for NetApp ONTAP (referred to as FSx hereinafter), which is the cornerstone for AutoMQ to achieve sub-10ms performance on AWS.</p>
<p>Amazon FSx for NetApp ONTAP is a fully managed service that provides highly reliable, scalable, high-performing, and feature-rich file storage built on NetApp's popular ONTAP file system.</p>
<ul>
<li>FSx is architected to deliver consistent sub-10ms latency for data accessed via its SSD storage tier.</li>
<li>It provides throughput of up to tens of GB/s and millions of IOPS per file system.</li>
</ul>
<p>This allows many databases, such as Oracle and Microsoft SQL Server, to be deployed on it.</p>
<p>FSx ensures data reliability through HA Pair. Each HA Pair consists of an active file server and a standby file server. Every write operation is persisted on both nodes before returning a response to the client, ensuring that FSx still has complete data even if any file server fails.</p>
<p>FSx HA Pair offers two types: Single-AZ and Multi-AZ. Under Multi-AZ, FSx can tolerate AZ-level unavailability failures. What's more appealing is that Multi-AZ does <strong>not charge inter-zone traffic fees</strong> for access in any zone within the same region.</p>
<p>Here comes the most interesting part:</p>
<ol>
<li>We purchased a 1536MBps second-generation Multi-AZ file system on AWS, which costs $4108 per month.</li>
<li>Use this FSx as a traffic relay for inter-zone communication, that is, write data in zone1, then read and delete it in zone2. Assuming the transfer speed is 1400MBps, 3,543,750 GB of data can be transmitted in a month.</li>
<li>If 3,543,750 GB of data is transmitted directly using the inter-zone network, it will cost 3543750 * 0.02 = $70,875, which is 17 times the cost of FSx.</li>
</ol>
<p>This dramatic cost disparity fundamentally upends traditional cloud architectural decision-making. FSx evolves from a simple storage service into the strategic key for neutralizing prohibitive cross-AZ data transfer costs.</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fofficial%3Futm_source%3Dseo_inner_link" target="_blank" title="https://go.automq.com/official?utm_source=seo_inner_link" ref="nofollow noopener noreferrer">AutoMQ</a> identified and capitalized on this significant architectural advantage. By leveraging FSx as our foundation, we transformed its high-performance capabilities and zero cross-AZ networking costs into a system-level competitive edge. This strategy enabled us to engineer a Diskless Kafka that delivers sub-10ms write latency while maintaining exceptional cost efficiency.</p>
<h2 data-id="heading-2"><strong>Architecture</strong></h2>
<p>With FSx providing the ideal storage foundation, the next challenge is engineering a truly cloud-native Kafka. To determine the optimal implementation path, we must first analyze the architectural layering of Apache Kafka to identify the precise point of intervention for our redesign.</p>
<p>Apache Kafka consists of three layers:</p>
<ul>
<li><strong>Network:</strong> the network layer is responsible for handling new client connections -&gt; parsing requests -&gt; calling the corresponding compute layer logic based on the API_KEY -&gt; sending the response back to the client.</li>
<li><strong>Compute:</strong> the compute layer includes logic such as transactions, compaction, and deduplication. It includes Apache Kafka decades years of new features, client compatibility, and bug fixes, accounting for 98% of the code in the Apache Kafka codebase.</li>
<li><strong>Storage:</strong> the storage layer is responsible for splitting the infinitely long Log into finite-length data segments called LogSegments, and then mapping the LogSegments to specific files in the local file system.</li>
</ul>
<p>If one wants to implement a 100% compatible Apache Kafka product from scratch, it not only requires adapting to the existing 1000+ KIPs of Apache Kafka but also continuously following up on new features and fixes from the Apache Kafka community in the future, which is an almost impossible task.</p>
<p>Therefore, AutoMQ has chosen to fork from Apache Kafka and carry out cloud-native transformations on its basis to implement a sub-10ms latency Diskless Kafka.</p>
<ul>
<li>100% Kafka Compatible: AutoMQ retains nearly all of the compute layer’s code, allowing it to confidently state that its Kafka Protocol handling behavior is fully consistent with Apache Kafka’s.</li>
<li>Zero Inter-Zone Traffic: AutoMQ has added a zone-routing interceptor beneath KafkaApis to intercept Produce and Metadata requests. This allows clients to only communicate with brokers in the same zone, thereby achieving zero inter-zone traffic for Kafka clients.</li>
<li>Diskless: AutoMQ replaces Apache Kafka’s minimum storage unit, LogSegment, with a cloud-native implementation: ElasticLogSegment. ElasticLogSegment writes Kafka Records to the storage acceleration layer FSx with sub-millisecond latency before returning success to the client. In the background, it then asynchronously batches and writes the data to S3. By combining two types of cloud storage—FSx and S3—AutoMQ enables a diskless Kafka solution that delivers both sub-10ms latency and cost-effectiveness.</li>
</ul>
<p><img src="https://image.automq.com/20251219bot/nkec3c.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>Eliminating Cross-AZ Traffic</strong></h2>
<p>To achieve zero inter-zone traffic on AWS, KafkaProducers and KafkaConsumers must be prevented from communicating with brokers in different zones. Apache Kafka uses a leader-based architecture, where a partition leader resides on exactly one broker. This means that if a KafkaProducer from another zone sends messages to this partition leader, inter-zone traffic will be generated.</p>
<p>To solve this problem, AutoMQ proposes the concepts of main broker and proxy broker:</p>
<ul>
<li>Main Broker: The behavior and role of the main broker are consistent with those of the broker in Apache Kafka; it is merely a concept introduced in conjunction with the proxy broker.</li>
<li>Proxy Broker: The proxy broker will mirror and synchronize the status of all partition leaders on the main broker, and pretend to be the corresponding partition leader to provide Produce and Fetch services to the Kafka client.</li>
</ul>
<p>Each main broker has one proxy broker in every other zone. This allows clients in any zone to directly access all partitions of the cluster within their own zone. Note that "main broker" and "proxy broker" are virtual role concepts; a single AutoMQ process can function as both a main broker and a proxy broker for others simultaneously.</p>
<p>To ensure that Produce and Fetch requests only access brokers within the same zone, AutoMQ uses a zone-routing interceptor to intercept Metadata requests. If the broker hosting the partition leader is not in the client’s current zone, the interceptor will replace the broker address in the Metadata response with that of the proxy broker in the client’s zone, based on the client’s zone information.</p>
<p>Take the following diagram as an example: Node0 and Node1 are proxy brokers for each other, where the partition leaders of P1 and P2 are on Node0 and Node1, respectively. The response returned by the client metadata request in AZ2 will be modified to {P1 =&gt; Node1, P2 =&gt; Node1}.</p>
<p><img src="https://image.automq.com/20251219bot/3y3urc.png" alt="" loading="lazy"/></p>
<p>Through the mechanism described above, we have successfully "pinned" client connections to the local Availability Zone (AZ). However, this is only half the battle.</p>
<p>Since the Proxy Broker essentially acts as a "masquerader," a critical question remains: When it receives gigabytes of incoming write traffic, how can it ensure data persistence and strong consistency just like a genuine Leader, all while strictly avoiding any cross-zone data transfer?</p>
<h2 data-id="heading-4"><strong>Write Path</strong></h2>
<h3 data-id="heading-5">Sub-10ms Zone-Aligned Write</h3>
<p>If the actual leader of the partition targeted by KafkaProducer is not in the current zone, the local proxy broker will act as the partition leader to process the Produce request. While the proxy broker appears to the client as the partition leader, it still requires the real partition leader’s participation for data validity verification, deduplication, ordering, and storage when actually performing writes.</p>
<p>To enable low-latency, inter-zone writes without moving large data payloads between zones, AutoMQ uses a lightweight two-phase protocol that leverages FSx as a shared, low-latency buffer.</p>
<p>When a client in any AZ sends a Produce request:</p>
<ol>
<li>Prepare Phase (Local Write)</li>
<li>The local proxy broker writes the full request data directly to the shared FSx volume (in the same region) and records its position. This happens entirely within the client’s AZ and completes in sub-milliseconds.</li>
<li>Confirm Phase (Remote Coordination)</li>
<li>The proxy broker sends a tiny coordination message (~100 bytes) to the main broker (the true partition leader), which then:</li>
<li>The main broker executes Partition#appendRecordsToLeader to perform logic such as data verification, deduplication, ordering, and persistence.</li>
<li>The Record data is written to the latency-optimized WAL (implemented via FSx), at which point persistence is considered successful.</li>
<li>To reduce FSx write overhead, persistence here only records metadata (including position, as well as offsets and epochs assigned during the append process).</li>
<li>The complete RecordBatch is still cached in the WAL cache for tail-read and background upload to S3.</li>
<li>Embed the ProduceResponse into the confirmation result, return it to the proxy broker, which then forwards the result to the KafkaProducer.</li>
</ol>
<p>Because FSx is regionally shared and accessible from all AZs via NFS, no actual record data crosses AZ boundaries; only a minimal control message does. This reduces inter-zone traffic by 3–4 orders of magnitude compared to Apache Kafka.</p>
<p><img src="https://image.automq.com/20251219bot/gx868x.png" alt="" loading="lazy"/></p>
<p>Through this Produce processing flow, we can derive the composition of the processing time for a single ProduceRequest in AutoMQ:</p>
<ul>
<li>Write ProduceRequest to FSx</li>
<li>Inter-zone request Confirm RPC: Inter-zone RPC latency + Read ProduceRequest from FSx + Write confirm record to FSx</li>
</ul>
<p>In AWS's us-east-1, the average production latency on the client side is only about 6ms.</p>
<h3 data-id="heading-6"><strong>Cost-Effective Storage</strong></h3>
<p>By leveraging the write path described above, we utilize FSx to achieve ultimate write performance. However, you might ask: "FSx is powerful, but it comes at a premium. Wouldn't storing massive volumes of historical data be prohibitively expensive?"</p>
<p>This brings us to another key highlight of the AutoMQ architecture: we position FSx strictly as a "high-performance write buffer," while offloading the heavy lifting of massive data storage to the highly cost-effective S3.</p>
<p>FSx is priced at <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.35</mn><mi>p</mi><mi>e</mi><mi>r</mi><mi>G</mi><mi>B</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>S</mi><mn>3</mn><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>s</mi><mi>o</mi><mi>n</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">0.35 per GB per month, while S3 costs only </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord">0.35</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">GBp</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mord mathnormal">so</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span>0.023 per GB per month. To optimize storage costs, AutoMQ therefore uses FSx only as a durable, low-latency write buffer, with primary data committed to S3.</p>
<ol>
<li>When unuploaded data in the WAL cache exceeds 500MiB, or 30 seconds have elapsed since the last upload, AutoMQ commits the WAL cache data (which caches recently written complete RecordBatches) to S3.</li>
<li>AutoMQ reclassifies and sorts the data by (partition, offset) before uploading it.</li>
<li>If the data for a given partition exceeds 8MiB, it will be uploaded as an independent object(StreamObject, SO). Compact objects improve the efficiency of reading historical data, while independent objects also facilitate data cleaning for topics with different TTLs.</li>
<li>Data from the remaining partitions will be grouped and written into a single object (StreamSetObject, SSO) to avoid a linear increase in S3 API call frequency as the number of partitions grows.</li>
<li>After the data is uploaded to S3, delete the data in FSx.</li>
</ol>
<p>An <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fofficial%3Futm_source%3Dseo_inner_link" target="_blank" title="https://go.automq.com/official?utm_source=seo_inner_link" ref="nofollow noopener noreferrer">AutoMQ</a> cluster with 10 Gbps write throughput and 50 nodes requires only less than 100 GB of total space on FSx via this mechanism.</p>
<blockquote>
<p>StreamSetObject (SSO) will further compact in the background to improve cold read efficiency: 1) Small SSO will be compacted into larger SSO; 2) Large SSO will be split into independent SO.</p>
</blockquote>
<h2 data-id="heading-7"><strong>Read Path</strong></h2>
<p>By this stage, the data has been safely persisted: expensive "hot data" is temporarily buffered in high-speed FSx, while massive volumes of "cold data" are organized and offloaded to cost-effective S3.</p>
<p>So, how can consumers efficiently read data distributed across these different media with the speed of local disk access, all while maintaining "zero cross-AZ traffic"?</p>
<p>In reality, FSx and S3 store AutoMQ's recently written data and historical data, respectively. Since both are regional shared cloud storage services, any AutoMQ node can access the complete dataset of the entire cluster.</p>
<p>Similar to the write path, AutoMQ uses proxy brokers to simulate partition leaders and provide zone-aligned read services across all zones, ensuring data reading efficiency. The proxy broker’s ability to simulate the main broker lies in mirroring the main broker’s state:</p>
<ol>
<li>The proxy broker continuously subscribes to state changes of the main broker, including WAL's end offset and partition snapshots (high watermark, last stable offset, ...).</li>
<li>The proxy broker first reads the data from the main broker's WAL in FSx and replays it into the cache.</li>
<li>Then, it applies the partition snapshots locally. At this point, the proxy broker has completed the state mirroring of the main broker.</li>
<li>Finally, the proxy broker can directly return the latest written data from the WAL cache to the consumer, while historical data is read from S3 on demand and returned to the consumer.</li>
</ol>
<blockquote>
<p>"If it walks like a duck, quacks like a duck, then it's a duck."</p>
</blockquote>
<p><img src="https://image.automq.com/20251219bot/ax34kt.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-8"><strong>Comparison</strong></h2>
<p>To summarize, this single architecture delivers the speed of FSx, the cost-efficiency of S3, and zero cross-AZ traffic simultaneously. What does this translate to in a production environment? Let the benchmark data speak for itself.</p>
<p>For a scenario with 1 Gbps write throughput, 1 Gbps consumption rate, and a 3-day TTL, 6 m7g.4xlarge compute instances, and 2 × 1536 GB FSx storage are required. The specific cost breakdown is as follows:</p>
<p><img src="https://image.automq.com/20251219bot/u8a5jo.png" alt="" loading="lazy"/></p>
<p>The data of The AutoMQ Open Source &amp; Apache Kafka is referenced from <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.automq.com%2Fdocs%2Fautomq%2Fbenchmarks%2Fautomq-vs-apache-kafka-benchmarks-and-cost" target="_blank" title="https://www.automq.com/docs/automq/benchmarks/automq-vs-apache-kafka-benchmarks-and-cost" ref="nofollow noopener noreferrer">AutoMQ vs. Apache Kafka Benchmarks and Cost</a>.</p>
<p>The conclusion is clear: <strong>you no longer need to pay a premium for high performance.</strong> Compared to traditional architectures, AutoMQ achieves a TCO reduction of over 10x, all while delivering the same &lt;10ms latency experience.</p>
<h2 data-id="heading-9"><strong>Conclusion</strong></h2>
<p>AutoMQ rewrites the laws of survival for Kafka in the cloud. By perfectly fusing the extreme performance of FSx with the ultimate cost-efficiency of S3, we deliver sub-10ms write latency and <strong>true zero cross-AZ costs</strong>—all while maintaining 100% Kafka compatibility.</p>
<p>Start your free trial of <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.automq.com%2Fhome%3Futm_source%3Dseo_inner_link" target="_blank" title="https://go.automq.com/home?utm_source=seo_inner_link" ref="nofollow noopener noreferrer">AutoMQ</a> today and experience the ultimate power of the next-generation cloud-native Kafka.</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[工程化工具类：实现高效的工具函数库]]></title>    <link>https://juejin.cn/post/7585206549305294911</link>    <guid>https://juejin.cn/post/7585206549305294911</guid>    <pubDate>2025-12-19T07:16:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206549305294911" data-draft-id="7585206549305245759" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="工程化工具类：实现高效的工具函数库"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-12-19T07:16:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024肥宅"/> <meta itemprop="url" content="https://juejin.cn/user/588993964030574"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            工程化工具类：实现高效的工具函数库
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993964030574/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024肥宅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:16:16.000Z" title="Fri Dec 19 2025 07:16:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">引言</h4>
<p>工具函数库是开发中的“瑞士军刀”，它提供了处理常见任务的标准化方法。以Lodash为例，它已成为JavaScript生态中不可或缺的工具，但实际项目中，我们可能还需要定制化的工具库。一个良好的工具函数库应具备模块化、可测试、文档完善和易于维护的特点。本文将引导你从零开始设计和实现一个全面的工具函数库，覆盖从基础函数到高级工程化的全流程。</p>
<h4 data-id="heading-1">一、类似Lodash的工具函数库</h4>
<p>Lodash提供了丰富的实用函数，如数组操作、对象处理、函数式编程等。实现类似库时，我们应关注高频使用场景，并优化性能。</p>
<h5 data-id="heading-2">1.1 核心函数示例</h5>
<ul>
<li><strong>防抖(Debounce):</strong> 限制函数在短时间内频繁触发，适用于搜索输入或窗口调整。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, immediate = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-keyword">let</span> timeout;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;
    <span class="hljs-keyword">const</span> later = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      timeout = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (!immediate) func.<span class="hljs-title function_">apply</span>(context, args);
    };
    <span class="hljs-keyword">const</span> callNow = immediate &amp;&amp; !timeout;
    <span class="hljs-built_in">clearTimeout</span>(timeout);
    timeout = <span class="hljs-built_in">setTimeout</span>(later, wait);
    <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args);
  };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> handleSearch = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">query</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'搜索:'</span>, query);
}, <span class="hljs-number">300</span>);
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">handleSearch</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>));
</code></pre>
<ul>
<li><strong>深拷贝(Deep Clone):</strong> 递归复制对象，避免引用共享。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) {
  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span> obj;
  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);
  <span class="hljs-keyword">const</span> clone = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : {};
  hash.<span class="hljs-title function_">set</span>(obj, clone);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
      clone[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);
    }
  }
  <span class="hljs-keyword">return</span> clone;
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> original = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };
<span class="hljs-keyword">const</span> copied = <span class="hljs-title function_">deepClone</span>(original);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copied.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 2</span>
</code></pre>
<h5 data-id="heading-3">1.2 设计原则</h5>
<ul>
<li>函数应纯净且无副作用。</li>
<li>提供TypeScript类型支持以增强开发体验。</li>
<li>优化性能, 如使用记忆化(Memoization)缓存结果</li>
</ul>
<h4 data-id="heading-4">二、类型判断库</h4>
<p>JavaScript是动态类型语言，类型判断在运行时至关重要。一个健壮的类型判断库可以帮助开发者避免常见错误。</p>
<h5 data-id="heading-5">2.1 基础类型判断</h5>
<p>实现一系列isX函数, 覆盖基本类型和复杂类型。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> isType = {
  <span class="hljs-attr">isString</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>,
  <span class="hljs-attr">isNumber</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'number'</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(val),
  <span class="hljs-attr">isBoolean</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'boolean'</span>,
  <span class="hljs-attr">isUndefined</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val === <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">isNull</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val === <span class="hljs-literal">null</span>,
  <span class="hljs-attr">isObject</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span>,
  <span class="hljs-attr">isArray</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(val),
  <span class="hljs-attr">isFunction</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'function'</span>,
  <span class="hljs-attr">isDate</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>,
  <span class="hljs-attr">isRegExp</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>,
  <span class="hljs-attr">isPromise</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val &amp;&amp; <span class="hljs-keyword">typeof</span> val.<span class="hljs-property">then</span> === <span class="hljs-string">'function'</span>,
  <span class="hljs-attr">isEmpty</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(val) || <span class="hljs-title function_">isString</span>(val)) <span class="hljs-keyword">return</span> val.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(val).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isType.<span class="hljs-title function_">isString</span>(<span class="hljs-string">'hello'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isType.<span class="hljs-title function_">isObject</span>({})); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isType.<span class="hljs-title function_">isEmpty</span>([])); <span class="hljs-comment">// true</span>
</code></pre>
<h5 data-id="heading-6">2.2 进阶应用</h5>
<ul>
<li>联合类型检查：如isNil（检查null或undefined）。</li>
<li>环境检测：isBrowser、isNode，用于区分运行环境。</li>
</ul>
<h4 data-id="heading-7">三、日期时间处理库</h4>
<p>日期和时间处理是业务逻辑中的常见需求，一个友好的日期库可以简化格式化、解析和计算操作。</p>
<h5 data-id="heading-8">3.1 常用函数</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> dateUtils = {
  <span class="hljs-comment">// 格式化日期</span>
  <span class="hljs-attr">formatDate</span>: <span class="hljs-function">(<span class="hljs-params">date, format = <span class="hljs-string">'YYYY-MM-DD HH:mm:ss'</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(date);
    <span class="hljs-keyword">const</span> map = {
      <span class="hljs-attr">YYYY</span>: d.<span class="hljs-title function_">getFullYear</span>(),
      <span class="hljs-attr">MM</span>: <span class="hljs-title class_">String</span>(d.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>),
      <span class="hljs-attr">DD</span>: <span class="hljs-title class_">String</span>(d.<span class="hljs-title function_">getDate</span>()).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>),
      <span class="hljs-attr">HH</span>: <span class="hljs-title class_">String</span>(d.<span class="hljs-title function_">getHours</span>()).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>),
      <span class="hljs-attr">mm</span>: <span class="hljs-title class_">String</span>(d.<span class="hljs-title function_">getMinutes</span>()).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>),
      <span class="hljs-attr">ss</span>: <span class="hljs-title class_">String</span>(d.<span class="hljs-title function_">getSeconds</span>()).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>),
    };
    <span class="hljs-keyword">return</span> format.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/YYYY|MM|DD|HH|mm|ss/g</span>, <span class="hljs-function">(<span class="hljs-params">matched</span>) =&gt;</span> map[matched]);
  },

  <span class="hljs-comment">// 添加天数</span>
  <span class="hljs-attr">addDays</span>: <span class="hljs-function">(<span class="hljs-params">date, days</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(date);
    result.<span class="hljs-title function_">setDate</span>(result.<span class="hljs-title function_">getDate</span>() + days);
    <span class="hljs-keyword">return</span> result;
  },

  <span class="hljs-comment">// 计算日期差（天数）</span>
  <span class="hljs-attr">diffInDays</span>: <span class="hljs-function">(<span class="hljs-params">date1, date2</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(date1);
    <span class="hljs-keyword">const</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(date2);
    <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(d2 - d1);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>));
  },

  <span class="hljs-comment">// 获取相对时间（如“3天前”）</span>
  <span class="hljs-attr">getRelativeTime</span>: <span class="hljs-function">(<span class="hljs-params">date</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
    <span class="hljs-keyword">const</span> past = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(date);
    <span class="hljs-keyword">const</span> diff = now - past;
    <span class="hljs-keyword">const</span> minutes = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / <span class="hljs-number">60000</span>);
    <span class="hljs-keyword">const</span> hours = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / <span class="hljs-number">3600000</span>);
    <span class="hljs-keyword">const</span> days = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / <span class="hljs-number">86400000</span>);
    <span class="hljs-keyword">if</span> (days &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${days}</span>天前`</span>;
    <span class="hljs-keyword">if</span> (hours &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${hours}</span>小时前`</span>;
    <span class="hljs-keyword">if</span> (minutes &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${minutes}</span>分钟前`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'刚刚'</span>;
  }
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateUtils.<span class="hljs-title function_">formatDate</span>(now)); <span class="hljs-comment">// "2023-10-05 14:30:00"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateUtils.<span class="hljs-title function_">addDays</span>(now, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 5天后的日期</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateUtils.<span class="hljs-title function_">diffInDays</span>(<span class="hljs-string">'2023-10-01'</span>, <span class="hljs-string">'2023-10-05'</span>)); <span class="hljs-comment">// 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateUtils.<span class="hljs-title function_">getRelativeTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(now - <span class="hljs-number">300000</span>))); <span class="hljs-comment">// "5分钟前"</span>
</code></pre>
<h5 data-id="heading-9">3.2 拓展功能</h5>
<ul>
<li>时区处理：支持UTC和本地时间转换。</li>
<li>国际化：根据locale格式化日期。</li>
</ul>
<h4 data-id="heading-10">四、数据验证库</h4>
<p>数据验证确保输入符合预期，常用于表单、API请求等场景。一个灵活的验证库应支持链式调用和自定义规则。</p>
<h5 data-id="heading-11">4.1 基本验证器</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> validators = {
  <span class="hljs-attr">isEmail</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-regexp">/^[^\s@]+@[^\s@]+\.[^\s@]+$/</span>.<span class="hljs-title function_">test</span>(val),
  <span class="hljs-attr">isPhone</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-regexp">/^1[3-9]\d{9}$/</span>.<span class="hljs-title function_">test</span>(val), <span class="hljs-comment">// 中国手机号</span>
  <span class="hljs-attr">isRequired</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val !== <span class="hljs-literal">null</span> &amp;&amp; val !== <span class="hljs-literal">undefined</span> &amp;&amp; val !== <span class="hljs-string">''</span>,
  <span class="hljs-attr">minLength</span>: <span class="hljs-function">(<span class="hljs-params">val, min</span>) =&gt;</span> val &amp;&amp; val.<span class="hljs-property">length</span> &gt;= min,
  <span class="hljs-attr">maxLength</span>: <span class="hljs-function">(<span class="hljs-params">val, max</span>) =&gt;</span> val &amp;&amp; val.<span class="hljs-property">length</span> &lt;= max,
  <span class="hljs-attr">isInRange</span>: <span class="hljs-function">(<span class="hljs-params">val, min, max</span>) =&gt;</span> val &gt;= min &amp;&amp; val &lt;= max,
  <span class="hljs-comment">// 自定义正则验证</span>
  <span class="hljs-attr">matchRegex</span>: <span class="hljs-function">(<span class="hljs-params">val, regex</span>) =&gt;</span> regex.<span class="hljs-title function_">test</span>(val),
};

<span class="hljs-comment">// 组合验证函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">data, rules</span>) {
  <span class="hljs-keyword">const</span> errors = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> field <span class="hljs-keyword">in</span> rules) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rule <span class="hljs-keyword">of</span> rules[field]) {
      <span class="hljs-keyword">const</span> [validator, ...args] = rule.<span class="hljs-title function_">split</span>(<span class="hljs-string">':'</span>);
      <span class="hljs-keyword">const</span> value = data[field];
      <span class="hljs-keyword">if</span> (!validators[validator](value, ...args)) {
        errors[field] = <span class="hljs-string">`验证失败: <span class="hljs-subst">${field}</span>`</span>;
        <span class="hljs-keyword">break</span>;
      }
    }
  }
  <span class="hljs-keyword">return</span> errors;
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> data = { <span class="hljs-attr">email</span>: <span class="hljs-string">'test@example.com'</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">'123456'</span> };
<span class="hljs-keyword">const</span> rules = {
  <span class="hljs-attr">email</span>: [<span class="hljs-string">'isEmail'</span>],
  <span class="hljs-attr">password</span>: [<span class="hljs-string">'isRequired'</span>, <span class="hljs-string">'minLength:6'</span>, <span class="hljs-string">'maxLength:20'</span>],
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">validate</span>(data, rules)); <span class="hljs-comment">// {}</span>
</code></pre>
<h5 data-id="heading-12">4.2 进阶特性</h5>
<ul>
<li>异步验证：支持API检查用户名是否重复。</li>
<li>错误消息自定义：提供友好的多语言错误提示。</li>
</ul>
<h4 data-id="heading-13">五、其他工具函数库补充</h4>
<p>除了上述核心类别，实际项目还可能涉及更多工具函数。以下是常见拓展方向，每个可独立成库或集成到主库中。</p>
<h5 data-id="heading-14">5.1 数学计算库</h5>
<p>提供统计、随机数生成等函数，适用于数据分析场景。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> mathUtils = {
  <span class="hljs-comment">// 求和</span>
  <span class="hljs-attr">sum</span>: <span class="hljs-function">(<span class="hljs-params">...numbers</span>) =&gt;</span> numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, num</span>) =&gt;</span> acc + num, <span class="hljs-number">0</span>),
  <span class="hljs-comment">// 平均值</span>
  <span class="hljs-attr">average</span>: <span class="hljs-function">(<span class="hljs-params">...numbers</span>) =&gt;</span> mathUtils.<span class="hljs-title function_">sum</span>(...numbers) / numbers.<span class="hljs-property">length</span>,
  <span class="hljs-comment">// 生成随机整数</span>
  <span class="hljs-attr">randomInt</span>: <span class="hljs-function">(<span class="hljs-params">min, max</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min,
  <span class="hljs-comment">// 标准差</span>
  <span class="hljs-attr">standardDeviation</span>: <span class="hljs-function">(<span class="hljs-params">numbers</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> avg = mathUtils.<span class="hljs-title function_">average</span>(...numbers);
    <span class="hljs-keyword">const</span> squareDiffs = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(num - avg, <span class="hljs-number">2</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(mathUtils.<span class="hljs-title function_">average</span>(...squareDiffs));
  },
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mathUtils.<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mathUtils.<span class="hljs-title function_">randomInt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 1到10之间的随机整数</span>
</code></pre>
<h5 data-id="heading-15">5.2 字符串处理库</h5>
<p>扩展字符串操作，如格式化、加密和编码。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> stringUtils = {
  <span class="hljs-comment">// 截断字符串</span>
  <span class="hljs-attr">truncate</span>: <span class="hljs-function">(<span class="hljs-params">str, length, suffix = <span class="hljs-string">'...'</span></span>) =&gt;</span> 
    str.<span class="hljs-property">length</span> &gt; length ? str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, length) + suffix : str,
  <span class="hljs-comment">// 转驼峰</span>
  <span class="hljs-attr">camelCase</span>: <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> 
    str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[-_\s]+(.)?/g</span>, <span class="hljs-function">(<span class="hljs-params">_, c</span>) =&gt;</span> c ? c.<span class="hljs-title function_">toUpperCase</span>() : <span class="hljs-string">''</span>),
  <span class="hljs-comment">// 基础Base64编码（浏览器环境）</span>
  <span class="hljs-attr">base64Encode</span>: <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> <span class="hljs-title function_">btoa</span>(<span class="hljs-built_in">encodeURIComponent</span>(str)),
  <span class="hljs-attr">base64Decode</span>: <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-title function_">atob</span>(str)),
  <span class="hljs-comment">// 生成UUID（简化版）</span>
  <span class="hljs-attr">uuid</span>: <span class="hljs-function">() =&gt;</span> 
    <span class="hljs-string">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[xy]/g</span>, <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> r = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">16</span> | <span class="hljs-number">0</span>;
      <span class="hljs-keyword">const</span> v = c === <span class="hljs-string">'x'</span> ? r : (r &amp; <span class="hljs-number">0x3</span> | <span class="hljs-number">0x8</span>);
      <span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
    }),
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringUtils.<span class="hljs-title function_">truncate</span>(<span class="hljs-string">'Hello, world!'</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// "Hello..."</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringUtils.<span class="hljs-title function_">camelCase</span>(<span class="hljs-string">'hello-world'</span>)); <span class="hljs-comment">// "helloWorld"</span>
</code></pre>
<h5 data-id="heading-16">5.3 异步处理库</h5>
<p>简化Promise操作，如重试、超时和并发控制。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> asyncUtils = {
  <span class="hljs-comment">// 延迟执行</span>
  <span class="hljs-attr">delay</span>: <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms)),
  <span class="hljs-comment">// 带超时的Promise</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-function">(<span class="hljs-params">promise, ms</span>) =&gt;</span> 
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> 
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'超时'</span>)), ms)
    )]),
  <span class="hljs-comment">// 重试机制</span>
  <span class="hljs-attr">retry</span>: <span class="hljs-keyword">async</span> (fn, retries = <span class="hljs-number">3</span>, delayMs = <span class="hljs-number">1000</span>) =&gt; {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; retries; i++) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>();
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">if</span> (i === retries - <span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> err;
        <span class="hljs-keyword">await</span> asyncUtils.<span class="hljs-title function_">delay</span>(delayMs);
      }
    }
  },
  <span class="hljs-comment">// 并发限制</span>
  <span class="hljs-attr">parallelLimit</span>: <span class="hljs-function">(<span class="hljs-params">tasks, limit</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">while</span> (index &lt; tasks.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">const</span> taskIndex = index++;
        results[taskIndex] = <span class="hljs-keyword">await</span> tasks[taskIndex]();
      }
    };
    <span class="hljs-keyword">const</span> workers = <span class="hljs-title class_">Array</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(limit, tasks.<span class="hljs-property">length</span>)).<span class="hljs-title function_">fill</span>().<span class="hljs-title function_">map</span>(run);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(workers).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> results);
  },
};

<span class="hljs-comment">// 使用示例</span>
asyncUtils.<span class="hljs-title function_">retry</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com'</span>), <span class="hljs-number">3</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'失败:'</span>, err));
</code></pre>
<h5 data-id="heading-17">5.4 缓存工具库</h5>
<p>实现简单缓存机制，提升性能。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCache</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">ttl = <span class="hljs-number">60000</span></span>) { <span class="hljs-comment">// 默认TTL 60秒</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ttl</span> = ttl;
  }

  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, { value, <span class="hljs-attr">expiry</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">ttl</span> });
  }

  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);
    <span class="hljs-keyword">if</span> (!item || item.<span class="hljs-property">expiry</span> &lt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span>;
  }

  <span class="hljs-title function_">clear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">clear</span>();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCache</span>();
cache.<span class="hljs-title function_">set</span>(<span class="hljs-string">'user'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">get</span>(<span class="hljs-string">'user'</span>)); <span class="hljs-comment">// { id: 1, name: 'Alice' }</span>
</code></pre>
<h5 data-id="heading-18">5.5 环境检测库</h5>
<p>识别运行环境，便于条件代码执行。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> envUtils = {
  <span class="hljs-attr">isBrowser</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span> !== <span class="hljs-string">'undefined'</span>,
  <span class="hljs-attr">isNode</span>: <span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">'undefined'</span> &amp;&amp; process.<span class="hljs-property">versions</span> &amp;&amp; process.<span class="hljs-property">versions</span>.<span class="hljs-property">node</span>,
  <span class="hljs-attr">isDevelopment</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'development'</span>,
  <span class="hljs-comment">// 浏览器特性检测</span>
  <span class="hljs-attr">supportsLocalStorage</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!envUtils.<span class="hljs-property">isBrowser</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'test'</span>, <span class="hljs-string">'test'</span>);
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'test'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  },
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">if</span> (envUtils.<span class="hljs-property">isBrowser</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'运行在浏览器中'</span>);
}
</code></pre>
<h5 data-id="heading-19">5.6 性能监控工具</h5>
<p>辅助性能分析和调试。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> perfUtils = {
  <span class="hljs-comment">// 测量函数执行时间</span>
  <span class="hljs-attr">measure</span>: <span class="hljs-function">(<span class="hljs-params">fn, ...args</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fn</span>(...args);
    <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`函数 <span class="hljs-subst">${fn.name}</span> 执行时间: <span class="hljs-subst">${end - start}</span>ms`</span>);
    <span class="hljs-keyword">return</span> result;
  },
  <span class="hljs-comment">// 内存使用快照（Node环境）</span>
  <span class="hljs-attr">memoryUsage</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (envUtils.<span class="hljs-property">isNode</span>) {
      <span class="hljs-keyword">const</span> used = process.<span class="hljs-title function_">memoryUsage</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`内存使用: <span class="hljs-subst">${<span class="hljs-built_in">Math</span>.round(used.heapUsed / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>)}</span>MB`</span>);
    }
  },
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">slowFunction</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);
perfUtils.<span class="hljs-title function_">measure</span>(slowFunction);
</code></pre>
<h5 data-id="heading-20">5.7 错误处理库</h5>
<p>标准化错误处理，提升代码健壮性。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message, code = <span class="hljs-string">'INTERNAL_ERROR'</span></span>) {
    <span class="hljs-variable language_">super</span>(message);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">code</span> = code;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'AppError'</span>;
  }
}

<span class="hljs-keyword">const</span> errorUtils = {
  <span class="hljs-comment">// 包装异步错误</span>
  <span class="hljs-attr">wrapAsync</span>: <span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> 
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(req, res, next)).<span class="hljs-title function_">catch</span>(next),
  <span class="hljs-comment">// 统一错误响应</span>
  <span class="hljs-attr">handleError</span>: <span class="hljs-function">(<span class="hljs-params">err, context = <span class="hljs-string">''</span></span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[<span class="hljs-subst">${context}</span>]`</span>, err);
    <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">AppError</span>) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: err.<span class="hljs-property">message</span>, <span class="hljs-attr">code</span>: err.<span class="hljs-property">code</span> };
    }
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'内部服务器错误'</span>, <span class="hljs-attr">code</span>: <span class="hljs-string">'SERVER_ERROR'</span> };
  },
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppError</span>(<span class="hljs-string">'用户不存在'</span>, <span class="hljs-string">'USER_NOT_FOUND'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errorUtils.<span class="hljs-title function_">handleError</span>(err, <span class="hljs-string">'auth'</span>));
}
</code></pre>
<h5 data-id="heading-21">5.8 国际化工具库</h5>
<p>支持多语言字符串和日期格式化。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> i18nUtils = {
  <span class="hljs-attr">translations</span>: {
    <span class="hljs-attr">en</span>: { <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Hello'</span>, <span class="hljs-attr">dateFormat</span>: <span class="hljs-string">'MM/DD/YYYY'</span> },
    <span class="hljs-attr">zh</span>: { <span class="hljs-attr">greeting</span>: <span class="hljs-string">'你好'</span>, <span class="hljs-attr">dateFormat</span>: <span class="hljs-string">'YYYY年MM月DD日'</span> },
  },
  <span class="hljs-attr">locale</span>: <span class="hljs-string">'en'</span>,

  <span class="hljs-attr">t</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> i18nUtils.<span class="hljs-property">translations</span>[i18nUtils.<span class="hljs-property">locale</span>][key] || key,
  <span class="hljs-attr">setLocale</span>: <span class="hljs-function">(<span class="hljs-params">locale</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (i18nUtils.<span class="hljs-property">translations</span>[locale]) i18nUtils.<span class="hljs-property">locale</span> = locale;
  },
  <span class="hljs-attr">formatDate</span>: <span class="hljs-function">(<span class="hljs-params">date</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> format = i18nUtils.<span class="hljs-title function_">t</span>(<span class="hljs-string">'dateFormat'</span>);
    <span class="hljs-comment">// 复用日期库的formatDate函数</span>
    <span class="hljs-keyword">return</span> dateUtils.<span class="hljs-title function_">formatDate</span>(date, format);
  },
};

<span class="hljs-comment">// 使用示例</span>
i18nUtils.<span class="hljs-title function_">setLocale</span>(<span class="hljs-string">'zh'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i18nUtils.<span class="hljs-title function_">t</span>(<span class="hljs-string">'greeting'</span>)); <span class="hljs-comment">// "你好"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i18nUtils.<span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())); <span class="hljs-comment">// "2023年10月05日"</span>
</code></pre>
<h4 data-id="heading-22">六、工程化实践</h4>
<p>工具函数库的实现不仅在于函数本身，还涉及工程化考虑，以确保其可维护性和可扩展性。</p>
<h5 data-id="heading-23">6.1 模块化设计</h5>
<p>使用ES6模块划分功能，每个类别独立成文件。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 目录结构示例</span>
<span class="hljs-comment">// src/</span>
<span class="hljs-comment">//   index.js          // 主入口</span>
<span class="hljs-comment">//   debounce.js       // 防抖函数</span>
<span class="hljs-comment">//   typeCheck.js      // 类型判断</span>
<span class="hljs-comment">//   dateUtils.js      // 日期处理</span>
<span class="hljs-comment">//   validators.js     // 数据验证</span>
<span class="hljs-comment">//   math/</span>
<span class="hljs-comment">//     statistics.js   // 数学统计</span>
<span class="hljs-comment">//   string/</span>
<span class="hljs-comment">//     format.js       // 字符串格式化</span>
</code></pre>
<h5 data-id="heading-24">6.2 测试驱动开发</h5>
<p>使用Jest等框架编写单元测试，确保函数行为正确。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 测试示例 (debounce.test.js)</span>
<span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'./debounce'</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">'debounce'</span>, <span class="hljs-function">() =&gt;</span> {
  jest.<span class="hljs-title function_">useFakeTimers</span>();
  <span class="hljs-title function_">test</span>(<span class="hljs-string">'应延迟执行函数'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> mockFn = jest.<span class="hljs-title function_">fn</span>();
    <span class="hljs-keyword">const</span> debounced = <span class="hljs-title function_">debounce</span>(mockFn, <span class="hljs-number">100</span>);
    <span class="hljs-title function_">debounced</span>();
    <span class="hljs-title function_">expect</span>(mockFn).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeCalled</span>();
    jest.<span class="hljs-title function_">advanceTimersByTime</span>(<span class="hljs-number">100</span>);
    <span class="hljs-title function_">expect</span>(mockFn).<span class="hljs-title function_">toBeCalled</span>();
  });
});
</code></pre>
<h5 data-id="heading-25">6.3 文档生成</h5>
<p>使用JSDoc注释生成API文档，便于团队使用。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 防抖函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">func</span> - 要防抖的函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">wait</span> - 等待时间（毫秒）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">boolean</span>} <span class="hljs-variable">immediate</span> - 是否立即执行
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 防抖后的函数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, immediate = <span class="hljs-literal">false</span></span>) {
  <span class="hljs-comment">// 实现...</span>
}
</code></pre>
<h5 data-id="heading-26">6.4 构建与打包</h5>
<p>使用Rollup或Webpack打包为UMD、ESM等格式，支持多环境。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// rollup.config.js 示例</span>
<span class="hljs-keyword">import</span> { nodeResolve } <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-node-resolve'</span>;
<span class="hljs-keyword">import</span> commonjs <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-commonjs'</span>;
<span class="hljs-keyword">import</span> terser <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-terser'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: [
    { <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.cjs.js'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'cjs'</span> },
    { <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.esm.js'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'esm'</span> },
    { <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.min.js'</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">'umd'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'MyUtils'</span>, <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">terser</span>()] },
  ],
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">nodeResolve</span>(), <span class="hljs-title function_">commonjs</span>()],
};
</code></pre>
<h5 data-id="heading-27">6.5 发布与维护</h5>
<p>通过npm发布包，遵循语义化版本控制（SemVer）。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 发布命令</span>
npm version patch  <span class="hljs-comment"># 更新补丁版本</span>
npm publish
</code></pre>
<h5 data-id="heading-28">6.6 持续集成</h5>
<p>集成CI/CD工具如GitHub Actions，自动化测试和部署。</p>
<h4 data-id="heading-29">总结</h4>
<p>工具函数库是工程化开发中的基石，它通过封装通用逻辑提升团队效率。本文介绍了从类似Lodash的通用函数到类型判断、日期处理、数据验证等核心类别，并拓展了数学计算、字符串处理、异步工具等补充内容，最后强调了模块化、测试、文档等工程化实践。实现一个高质量的工具函数库需要平衡功能丰富性和维护成本，建议从实际项目需求出发，逐步迭代。通过标准化的工具库，开发者可以更专注于业务逻辑，推动项目快速稳定发展。</p>
<p><strong>总结要点:</strong></p>
<ul>
<li>工具函数库应聚焦高频场景，保持函数纯净和性能优化。</li>
<li>拓展类别可根据项目需要选择，避免过度设计。</li>
<li>工程化实践确保库的可维护性，包括测试、文档和自动化。</li>
</ul>
<p>通过以上步骤，你可以构建一个适应团队需求的工具函数库，提升整体开发体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangGraph 技术详解：基于图结构的 AI 工作流与多智能体编排框架]]></title>    <link>https://juejin.cn/post/7585171571128893476</link>    <guid>https://juejin.cn/post/7585171571128893476</guid>    <pubDate>2025-12-19T07:17:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585171571128893476" data-draft-id="7585171571128795172" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangGraph 技术详解：基于图结构的 AI 工作流与多智能体编排框架"/> <meta itemprop="keywords" content="前端,Python,LangChain"/> <meta itemprop="datePublished" content="2025-12-19T07:17:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程干货铺"/> <meta itemprop="url" content="https://juejin.cn/user/52383084474680"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangGraph 技术详解：基于图结构的 AI 工作流与多智能体编排框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52383084474680/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程干货铺
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:17:47.000Z" title="Fri Dec 19 2025 07:17:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/415b2a85edea49e7bfc6c5f0fb04a5ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733467&amp;x-signature=xT7bvD%2B6hLq4xnn4tA%2FdXIbCS4A%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p>随着大语言模型能力不断增强，AI 应用的复杂度迅速上升。
现实中的 AI 系统，早已不再是“一次 Prompt → 一次回答”的简单模式，而是逐渐演变为：</p>
<ul>
<li>多步骤推理</li>
<li>多 Agent 协作</li>
<li>带条件分支与循环的工作流</li>
<li>需要长期状态管理的系统</li>
</ul>
<p>在这种背景下，<strong>LangGraph</strong> 应运而生。</p>
<h2 data-id="heading-1">一、LangGraph 是什么</h2>
<p><strong>LangGraph 是一个基于图结构（Graph）的 AI 工作流框架，用于构建可控、多步骤、多智能体的 LLM 应用系统。</strong></p>
<p>一句话概括：</p>
<blockquote>
<p><strong>LangGraph 让 AI 应用从“线性调用”升级为“有状态、可回路、可控制的推理图”。</strong></p>
</blockquote>
<p>如果从架构层理解：</p>
<ul>
<li><strong>LangChain</strong> 提供的是构建 LLM 能力的“组件与抽象”</li>
<li><strong>LangGraph</strong> 提供的是组织这些能力的“执行结构与控制模型”</li>
</ul>
<p>LangGraph 的核心价值不在于“调用模型”，而在于<strong>控制模型如何协作、何时执行、是否回退、是否重试、如何流转状态</strong>。</p>
<h2 data-id="heading-2">二、为什么需要 LangGraph</h2>
<p>在复杂 AI 应用中，传统 LangChain 会逐渐暴露一些结构性问题：</p>
<h3 data-id="heading-3">1. 线性 Chain 难以表达真实流程</h3>
<p>LLM 应用往往存在：</p>
<ul>
<li>条件分支</li>
<li>失败重试</li>
<li>多阶段决策</li>
<li>回环修正</li>
</ul>
<p>单向 Chain 在表达这些逻辑时非常笨重。</p>
<h3 data-id="heading-4">2. 多 Agent 协作缺乏统一调度</h3>
<p>当系统中存在多个 Agent（检索、写作、审查、工具执行）时，需要一个<strong>统一的流程控制器</strong>。</p>
<h3 data-id="heading-5">3. 状态管理分散</h3>
<p>上下文、阶段结果、中间结论往往散落在不同 Chain 中，难以统一管理和追踪。</p>
<p>LangGraph 正是为了解决这些问题而设计的。</p>
<h2 data-id="heading-6">三、LangGraph 能做什么</h2>
<p>LangGraph 非常适合以下类型的 AI 系统：</p>
<h3 data-id="heading-7">1. 多智能体协作系统</h3>
<p>例如：</p>
<ul>
<li>Research Agent（检索资料）</li>
<li>Writer Agent（生成内容）</li>
<li>Reviewer Agent（审核与反馈）</li>
<li>Tool Agent（调用外部服务）</li>
</ul>
<p>这些 Agent 在<strong>同一个图中</strong>共享状态、顺序执行、条件流转。</p>
<h3 data-id="heading-8">2. 复杂 AI 工作流</h3>
<p>典型流程示例：</p>
<p>用户输入
→ 知识检索
→ 初步推理
→ 生成草稿
→ 审核判断
→ 通过 → 输出
→ 不通过 → 返回修改</p>
<p>这种流程<strong>天然是图结构，而不是线性结构</strong>。</p>
<h3 data-id="heading-9">3. 构建“可控”的 AI 应用</h3>
<p>LangGraph 可以强制 AI 系统遵循：</p>
<ul>
<li>明确步骤</li>
<li>严格顺序</li>
<li>条件分支</li>
<li>循环与终止条件</li>
<li>工具调用时机</li>
</ul>
<p>非常适合生产级 AI 系统。</p>
<h2 data-id="heading-10">四、LangGraph 的核心概念</h2>
<h3 data-id="heading-11">1. Node（节点）</h3>
<p>Node 是图中的基本执行单元，通常代表：</p>
<ul>
<li>一次 LLM 调用</li>
<li>一次工具调用</li>
<li>一次判断逻辑</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_node</span>(<span class="hljs-params">state</span>):
    draft = llm.invoke(<span class="hljs-string">f"围绕主题写一篇文章：<span class="hljs-subst">{state[<span class="hljs-string">'topic'</span>]}</span>"</span>)
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"draft"</span>: draft.content}
</code></pre>
<h3 data-id="heading-12">2. Edge（边）</h3>
<p>Edge 定义节点之间的执行关系与流转条件。</p>
<pre><code class="hljs language-python" lang="python">graph.add_edge(<span class="hljs-string">"writer"</span>, <span class="hljs-string">"reviewer"</span>)
graph.add_edge(<span class="hljs-string">"reviewer"</span>, <span class="hljs-string">"writer"</span>, condition=needs_revision)
</code></pre>
<h3 data-id="heading-13">3. State（全局状态）</h3>
<p>State 是 Graph 内所有节点共享的数据结构。</p>
<pre><code class="hljs language-python" lang="python">{
  <span class="hljs-string">"topic"</span>: <span class="hljs-string">"..."</span>,
  <span class="hljs-string">"draft"</span>: <span class="hljs-string">"..."</span>,
  <span class="hljs-string">"review"</span>: <span class="hljs-string">"..."</span>,
  <span class="hljs-string">"approved"</span>: false
}
</code></pre>
<p>每个节点都可以<strong>读取或写入 State 的一部分</strong>。</p>
<h3 data-id="heading-14">4. Graph（图）</h3>
<p>Graph 是整个 AI 工作流的核心控制结构。</p>
<pre><code class="hljs language-python" lang="python">graph = StateGraph(State)
graph.add_node(<span class="hljs-string">"writer"</span>, write_node)
graph.add_node(<span class="hljs-string">"reviewer"</span>, review_node)
</code></pre>
<h2 data-id="heading-15">五、LangGraph 最简可运行示例</h2>
<h3 data-id="heading-16">1. 安装</h3>
<pre><code class="hljs language-bash" lang="bash">pip install langgraph langchain-openai
</code></pre>
<h3 data-id="heading-17">2. 定义状态结构</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict

<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    question: <span class="hljs-built_in">str</span>
    answer: <span class="hljs-built_in">str</span>
</code></pre>
<h3 data-id="heading-18">3. 定义节点</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">answer_node</span>(<span class="hljs-params">state: State</span>):
    <span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
    llm = ChatOpenAI(model=<span class="hljs-string">"gpt-4o-mini"</span>)
    result = llm.invoke(state[<span class="hljs-string">"question"</span>])
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"answer"</span>: result.content}
</code></pre>
<h3 data-id="heading-19">4. 构建并编译图</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> StateGraph

graph = StateGraph(State)
graph.add_node(<span class="hljs-string">"answer"</span>, answer_node)
graph.set_entry_point(<span class="hljs-string">"answer"</span>)

app = graph.<span class="hljs-built_in">compile</span>()
</code></pre>
<h3 data-id="heading-20">5. 执行</h3>
<pre><code class="hljs language-python" lang="python">app.invoke({<span class="hljs-string">"question"</span>: <span class="hljs-string">"什么是 LangGraph？"</span>})
</code></pre>
<h2 data-id="heading-21">六、LangChain 与 LangGraph 的关系</h2>
<p>简化对比如下：</p>



































<table><thead><tr><th>维度</th><th>LangChain</th><th>LangGraph</th></tr></thead><tbody><tr><td>定位</td><td>LLM 能力抽象层</td><td>AI 工作流控制层</td></tr><tr><td>核心结构</td><td>Chain</td><td>Graph</td></tr><tr><td>执行方式</td><td>线性</td><td>非线性（分支/循环）</td></tr><tr><td>状态管理</td><td>可选</td><td>强制内建</td></tr><tr><td>多 Agent</td><td>支持但弱</td><td>原生支持</td></tr></tbody></table>
<p>一句话总结：</p>
<blockquote>
<p><strong>LangChain 负责“能力”，LangGraph 负责“秩序”。</strong></p>
</blockquote>
<h2 data-id="heading-22">七、实用案例：多 Agent 写作与审核工作流</h2>
<h3 data-id="heading-23">目标</h3>
<p>构建一个 AI 写作系统，具备以下能力：</p>
<ol>
<li>写作 Agent 生成初稿</li>
<li>审核 Agent 判断质量</li>
<li>不通过则返回修改</li>
<li>通过则输出最终内容</li>
</ol>
<h3 data-id="heading-24">状态定义</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    topic: <span class="hljs-built_in">str</span>
    draft: <span class="hljs-built_in">str</span>
    approved: <span class="hljs-built_in">bool</span>
</code></pre>
<h3 data-id="heading-25">写作节点</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">writer</span>(<span class="hljs-params">state: State</span>):
    llm = ChatOpenAI()
    draft = llm.invoke(<span class="hljs-string">f"围绕主题写文章：<span class="hljs-subst">{state[<span class="hljs-string">'topic'</span>]}</span>"</span>)
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"draft"</span>: draft.content}
</code></pre>
<h3 data-id="heading-26">审核节点</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reviewer</span>(<span class="hljs-params">state: State</span>):
    llm = ChatOpenAI()
    result = llm.invoke(<span class="hljs-string">f"判断文章是否合格：<span class="hljs-subst">{state[<span class="hljs-string">'draft'</span>]}</span>"</span>)
    approved = <span class="hljs-string">"合格"</span> <span class="hljs-keyword">in</span> result.content
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"approved"</span>: approved}
</code></pre>
<h3 data-id="heading-27">构建流程图</h3>
<pre><code class="hljs language-python" lang="python">graph = StateGraph(State)

graph.add_node(<span class="hljs-string">"writer"</span>, writer)
graph.add_node(<span class="hljs-string">"reviewer"</span>, reviewer)

graph.set_entry_point(<span class="hljs-string">"writer"</span>)
graph.add_edge(<span class="hljs-string">"writer"</span>, <span class="hljs-string">"reviewer"</span>)
graph.add_edge(<span class="hljs-string">"reviewer"</span>, <span class="hljs-string">"writer"</span>, condition=<span class="hljs-keyword">lambda</span> s: <span class="hljs-keyword">not</span> s[<span class="hljs-string">"approved"</span>])
</code></pre>
<h3 data-id="heading-28">执行</h3>
<pre><code class="hljs language-python" lang="python">app = graph.<span class="hljs-built_in">compile</span>()
app.invoke({<span class="hljs-string">"topic"</span>: <span class="hljs-string">"LangGraph 的工程价值"</span>})
</code></pre>
<p>这个案例已经具备<strong>真实生产 AI 工作流的雏形</strong>。</p>
<h2 data-id="heading-29">结语</h2>
<p>LangGraph 并不是 LangChain 的替代品，而是它的<strong>结构补全</strong>。</p>
<p>当 AI 应用进入以下阶段：</p>
<ul>
<li>多 Agent</li>
<li>长流程</li>
<li>强控制</li>
<li>可回溯</li>
<li>可演进</li>
</ul>
<p>LangGraph 几乎是必然选择。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e8f30d2b1364959a005758dca4b0f0b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733467&amp;x-signature=xvndkMR0vJPGw2h0zABu6M8ATDo%3D" alt="在这里插入图片描述" loading="lazy"/>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4203d4e270a45a8a2b5dbadec47a52b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733467&amp;x-signature=sY7j8OM5UlwUuEUnmtFMm9iFHLQ%3D" alt="在这里插入图片描述" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain 技术栈全解析：从模型编排到 RAG 实战]]></title>    <link>https://juejin.cn/post/7585138968167088164</link>    <guid>https://juejin.cn/post/7585138968167088164</guid>    <pubDate>2025-12-19T07:16:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585138968167088164" data-draft-id="7585214391827890219" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain 技术栈全解析：从模型编排到 RAG 实战"/> <meta itemprop="keywords" content="前端,LangChain,Python"/> <meta itemprop="datePublished" content="2025-12-19T07:16:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="编程干货铺"/> <meta itemprop="url" content="https://juejin.cn/user/52383084474680"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain 技术栈全解析：从模型编排到 RAG 实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/52383084474680/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    编程干货铺
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:16:41.000Z" title="Fri Dec 19 2025 07:16:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34d91378c1684fe1862186d879886cd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733401&amp;x-signature=%2BUR%2BIetRoN43mSOr0nfx8CNobII%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h2 data-id="heading-0">引言</h2>
<p>随着大语言模型能力的快速演进，真正的技术挑战已经不再是“如何调用模型”，而是：</p>
<ul>
<li>如何组织 Prompt</li>
<li>如何管理上下文</li>
<li>如何接入外部数据</li>
<li>如何构建多步骤推理流程</li>
<li>如何让模型在复杂任务中稳定工作</li>
</ul>
<p>LangChain 正是为解决这些问题而诞生的框架。</p>
<p>它不是一个模型，也不是一个简单的 SDK，而是一个<strong>用于构建 LLM 应用的应用层编排框架</strong>。</p>
<h2 data-id="heading-1">1. LangChain 是什么</h2>
<p>LangChain 是一个用于构建大模型应用（LLM Applications）的开源框架，其核心目标是：</p>
<blockquote>
<p><strong>将模型、提示词、数据源、工具和控制逻辑组织成可复用、可组合、可维护的应用流程。</strong></p>
</blockquote>
<p>在架构层面，LangChain 处于：</p>
<ul>
<li>大模型 API 之上</li>
<li>具体业务逻辑之下</li>
</ul>
<p>它承担的是 <strong>“AI 应用的中间层 / 编排层”</strong> 角色。</p>
<h2 data-id="heading-2">2. LangChain 解决了哪些问题</h2>
<p>在没有 LangChain 的情况下，LLM 应用通常存在以下问题：</p>
<ol>
<li>Prompt 分散在代码中，难以维护</li>
<li>多轮对话上下文不可控</li>
<li>检索、生成、工具调用逻辑耦合严重</li>
<li>难以构建多步骤推理流程</li>
<li>应用无法演进为复杂系统</li>
</ol>
<p>LangChain 的设计目标正是系统性地解决上述问题。</p>
<h2 data-id="heading-3">3. LangChain 的核心抽象模型</h2>
<p>LangChain 的能力建立在一组高度内聚的抽象之上：</p>









































<table><thead><tr><th>抽象</th><th>作用</th></tr></thead><tbody><tr><td>LLM / ChatModel</td><td>大模型统一接口</td></tr><tr><td>PromptTemplate</td><td>结构化提示词</td></tr><tr><td>Chain</td><td>可组合的执行流程</td></tr><tr><td>Memory</td><td>上下文与状态管理</td></tr><tr><td>Retriever</td><td>检索接口</td></tr><tr><td>VectorStore</td><td>向量存储</td></tr><tr><td>Tool</td><td>外部能力封装</td></tr><tr><td>Agent</td><td>推理 + 决策控制器</td></tr></tbody></table>
<p>这些抽象共同构成了 LangChain 的技术骨架。</p>
<h2 data-id="heading-4">4. 安装与基础调用</h2>
<h3 data-id="heading-5">JavaScript</h3>
<pre><code class="hljs language-bash" lang="bash">npm install langchain @langchain/openai
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;

<span class="hljs-keyword">const</span> model = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-string">"gpt-4o-mini"</span>
});

<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> model.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">"用一句话说明 LangChain 的作用"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">content</span>);
</code></pre>
<h3 data-id="heading-6">Python</h3>
<pre><code class="hljs language-bash" lang="bash">pip install langchain langchain-openai
</code></pre>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI

model = ChatOpenAI(model=<span class="hljs-string">"gpt-4o-mini"</span>)
resp = model.invoke(<span class="hljs-string">"用一句话说明 LangChain 的作用"</span>)
<span class="hljs-built_in">print</span>(resp.content)
</code></pre>
<h2 data-id="heading-7">5. PromptTemplate：结构化提示词</h2>
<p>PromptTemplate 用于将 Prompt 从字符串提升为可配置对象。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PromptTemplate</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/prompts"</span>;

<span class="hljs-keyword">const</span> prompt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromptTemplate</span>({
  <span class="hljs-attr">template</span>: <span class="hljs-string">"请解释 {concept} 的核心作用"</span>,
  <span class="hljs-attr">inputVariables</span>: [<span class="hljs-string">"concept"</span>]
});

<span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> prompt.<span class="hljs-title function_">format</span>({ <span class="hljs-attr">concept</span>: <span class="hljs-string">"LangChain"</span> });
</code></pre>
<p>优势在于：</p>
<ul>
<li>参数明确</li>
<li>可复用</li>
<li>易组合</li>
</ul>
<h2 data-id="heading-8">6. Chain：构建可组合的执行流程</h2>
<p>Chain 是 LangChain 的核心执行单元。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LLMChain</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/chains"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;

<span class="hljs-keyword">const</span> chain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LLMChain</span>({
  <span class="hljs-attr">llm</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({ <span class="hljs-attr">model</span>: <span class="hljs-string">"gpt-4o-mini"</span> }),
  prompt
});

<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">invoke</span>({ <span class="hljs-attr">concept</span>: <span class="hljs-string">"Chain 机制"</span> });
</code></pre>
<p>Chain 使得 <strong>Prompt → 模型 → 输出</strong> 成为一个标准化流程单元。</p>
<h2 data-id="heading-9">7. Memory：上下文与状态管理</h2>
<p>Memory 用于控制模型可感知的历史上下文。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ConversationChain</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/chains"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BufferMemory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/memory"</span>;

<span class="hljs-keyword">const</span> chain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConversationChain</span>({
  <span class="hljs-attr">llm</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>(),
  <span class="hljs-attr">memory</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferMemory</span>()
});
</code></pre>
<p>Memory 的存在，使多轮对话和状态管理成为一等能力。</p>
<h2 data-id="heading-10">8. 向量化与检索：RAG 的技术基础</h2>
<p>RAG（Retrieval-Augmented Generation）并不是一个模型，而是一种架构模式。</p>
<p>LangChain 将 RAG 拆解为三个核心组件：</p>
<ol>
<li><strong>Text Splitter</strong>：文本分割</li>
<li><strong>Embedding</strong>：向量化</li>
<li><strong>VectorStore / Retriever</strong>：检索接口</li>
</ol>
<h2 data-id="heading-11">9. LangChain RAG 实战案例</h2>
<p>下面是一个结构完整、可运行的 LangChain RAG 示例（简化版）。</p>
<h3 data-id="heading-12">9.1 文档准备与切分</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">RecursiveCharacterTextSplitter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/text_splitter"</span>;

<span class="hljs-keyword">const</span> text = <span class="hljs-string">`
LangChain 是一个用于构建大语言模型应用的框架，
核心目标是将模型、数据、工具组织成可维护的流程。
`</span>;

<span class="hljs-keyword">const</span> splitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveCharacterTextSplitter</span>({
  <span class="hljs-attr">chunkSize</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">chunkOverlap</span>: <span class="hljs-number">20</span>
});

<span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> splitter.<span class="hljs-title function_">splitText</span>(text);
</code></pre>
<h3 data-id="heading-13">9.2 向量化并存入向量库</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">OpenAIEmbeddings</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryVectorStore</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"langchain/vectorstores/memory"</span>;

<span class="hljs-keyword">const</span> vectorStore = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MemoryVectorStore</span>.<span class="hljs-title function_">fromTexts</span>(
  docs,
  docs.<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> ({})),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAIEmbeddings</span>()
);
</code></pre>
<h3 data-id="heading-14">9.3 基于检索的问答</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> vectorStore.<span class="hljs-title function_">similaritySearch</span>(
  <span class="hljs-string">"LangChain 的核心作用是什么？"</span>,
  <span class="hljs-number">2</span>
);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">pageContent</span>));
</code></pre>
<h3 data-id="heading-15">9.4 结合模型生成最终回答</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;

<span class="hljs-keyword">const</span> context = results.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">pageContent</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>);

<span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>().<span class="hljs-title function_">invoke</span>(
  <span class="hljs-string">`基于以下资料回答问题：\n<span class="hljs-subst">${context}</span>\n\n问题：LangChain 的作用是什么？`</span>
);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(answer.<span class="hljs-property">content</span>);
</code></pre>
<h2 data-id="heading-16">10. Agent 与工具调用（进阶能力）</h2>
<p>LangChain 的 Agent 允许模型在运行时：</p>
<ul>
<li>判断是否需要工具</li>
<li>选择合适的工具</li>
<li>执行并整合结果</li>
</ul>
<p>这是构建复杂 AI 系统的重要基础。</p>
<h2 data-id="heading-17">11. LangChain 的典型应用方向</h2>
<ul>
<li>企业知识库问答（RAG）</li>
<li>智能客服系统</li>
<li>AI 助手与自动化 Agent</li>
<li>多步骤任务执行系统</li>
<li>AI 中台与能力编排层</li>
</ul>
<h2 data-id="heading-18">结语</h2>
<p>LangChain 的价值不在于“帮你写 Prompt”，
而在于 <strong>让大模型应用具备工程结构和系统能力</strong>。</p>
<p>当 LLM 应用从 Demo 走向生产环境，
LangChain 几乎是绕不开的技术栈之一。</p>
<p>如果你正在构建真实的 AI 应用系统，
理解并掌握 LangChain，是非常值得投入的一步。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/821171844b6a4abd9daca23c087ca843~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733401&amp;x-signature=t%2BlH9D0aw1%2FGLxs%2F7KMsGinvAV8%3D" alt="在这里插入图片描述" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d7fe2ec0c944a17a9c76e01962d29b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57yW56iL5bmy6LSn6ZO6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733401&amp;x-signature=dGohuWQhcg7B7gfcZo5N0A6%2FWoA%3D" alt="在这里插入图片描述" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter riverpod 对应Android开发概念理解]]></title>    <link>https://juejin.cn/post/7585130590292492303</link>    <guid>https://juejin.cn/post/7585130590292492303</guid>    <pubDate>2025-12-19T07:26:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585130590292492303" data-draft-id="7585180150254321679" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter riverpod 对应Android开发概念理解"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2025-12-19T07:26:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="麦客奥德彪"/> <meta itemprop="url" content="https://juejin.cn/user/2365804752418232"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter riverpod 对应Android开发概念理解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2365804752418232/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    麦客奥德彪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:26:48.000Z" title="Fri Dec 19 2025 07:26:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🔄 Riverpod vs Android 架构组件对比</h2>
<h3 data-id="heading-1">1. <strong>核心概念对比总览</strong></h3>



























































<table><thead><tr><th>Riverpod</th><th>Android (Jetpack/传统)</th><th>相似度</th><th>说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td><code>ViewModel</code> + <code>LiveData</code></td><td>⭐⭐⭐⭐⭐</td><td>状态管理核心</td></tr><tr><td><code>StateNotifier</code></td><td><code>ViewModel</code></td><td>⭐⭐⭐⭐⭐</td><td>业务逻辑容器</td></tr><tr><td><code>FutureProvider</code></td><td><code>ViewModel</code> + <code>suspend fun</code></td><td>⭐⭐⭐⭐</td><td>异步数据加载</td></tr><tr><td><code>StreamProvider</code></td><td><code>Flow</code> / <code>LiveData</code></td><td>⭐⭐⭐⭐⭐</td><td>响应式数据流</td></tr><tr><td><code>ref.watch()</code></td><td><code>observe()</code> / <code>collectAsState()</code></td><td>⭐⭐⭐⭐⭐</td><td>观察数据变化</td></tr><tr><td><code>ProviderScope</code></td><td><code>ViewModelStoreOwner</code></td><td>⭐⭐⭐⭐</td><td>生命周期管理</td></tr><tr><td><code>autoDispose</code></td><td><code>ViewModel. onCleared()</code></td><td>⭐⭐⭐⭐</td><td>自动清理资源</td></tr><tr><td>Dependency Injection</td><td>Hilt / Dagger</td><td>⭐⭐⭐⭐⭐</td><td>依赖注入</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">📊 详细对比</h2>
<h3 data-id="heading-3">2. <strong>Provider ≈ ViewModel + LiveData</strong></h3>
<h4 data-id="heading-4">🔹 <strong>Riverpod 代码</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// Riverpod Provider</span>
<span class="hljs-keyword">final</span> counterProvider = StateNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;((ref) {
  <span class="hljs-keyword">return</span> Counter();
});

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StateNotifier</span>&lt;<span class="hljs-title">int</span>&gt; </span>{
  Counter() : <span class="hljs-keyword">super</span>(<span class="hljs-number">0</span>);
  
  <span class="hljs-keyword">void</span> increment() =&gt; state++;
  <span class="hljs-keyword">void</span> decrement() =&gt; state--;
}

<span class="hljs-comment">// UI 使用</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> count = ref.watch(counterProvider);
    
    <span class="hljs-keyword">return</span> Column(
      children: [
        Text(<span class="hljs-string">'Count: <span class="hljs-subst">$count</span>'</span>),
        ElevatedButton(
          onPressed: () =&gt; ref.read(counterProvider.notifier).increment(),
          child: Text(<span class="hljs-string">'Increment'</span>),
        ),
      ],
    );
  }
}
</code></pre>
<h4 data-id="heading-5">🔹 <strong>Android 等价代码</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android ViewModel + LiveData</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterViewModel</span> :  <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _count = MutableLiveData(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> count: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = _count
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> {
        _count.value = (_count.value ?: <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span></span> {
        _count.value = (_count.value ?: <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>
    }
}

<span class="hljs-comment">// UI 使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: CounterViewModel <span class="hljs-keyword">by</span> viewModels()
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_counter)
        
        <span class="hljs-comment">// 观察数据变化</span>
        viewModel. count.observe(<span class="hljs-keyword">this</span>) { count -&gt;
            countTextView.text = <span class="hljs-string">"Count: <span class="hljs-variable">$count</span>"</span>
        }
        
        incrementButton.setOnClickListener {
            viewModel.increment()
        }
    }
}
</code></pre>
<h4 data-id="heading-6">🔹 <strong>Jetpack Compose 版本（更相似）</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Compose + ViewModel</span>
<span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">CounterScreen</span><span class="hljs-params">(viewModel: <span class="hljs-type">CounterViewModel</span> = viewModel()</span></span>) {
    <span class="hljs-keyword">val</span> count <span class="hljs-keyword">by</span> viewModel.count. observeAsState(<span class="hljs-number">0</span>)
    
    Column {
        Text(<span class="hljs-string">"Count: <span class="hljs-variable">$count</span>"</span>)
        Button(onClick = { viewModel.increment() }) {
            Text(<span class="hljs-string">"Increment"</span>)
        }
    }
}
</code></pre>
<p><strong>相似点</strong>：</p>
<ul>
<li>✅ 都将业务逻辑与 UI 分离</li>
<li>✅ 都支持自动 UI 更新</li>
<li>✅ 都有生命周期管理</li>
</ul>
<p><strong>差异点</strong>：</p>
<ul>
<li>Riverpod 更轻量，不需要继承特定类</li>
<li>Riverpod 支持更细粒度的依赖管理</li>
</ul>
<hr/>
<h3 data-id="heading-7">3. <strong>FutureProvider ≈ ViewModel + Coroutines</strong></h3>
<h4 data-id="heading-8">🔹 <strong>Riverpod 代码</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// Riverpod FutureProvider</span>
<span class="hljs-keyword">final</span> userProvider = FutureProvider&lt;User&gt;((ref) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(<span class="hljs-string">'https://api.example.com/user'</span>);
  <span class="hljs-keyword">return</span> User.fromJson(response.body);
});

<span class="hljs-comment">// UI 使用</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> userAsync = ref.watch(userProvider);
    
    <span class="hljs-keyword">return</span> userAsync.when(
      loading: () =&gt; CircularProgressIndicator(),
      error: (error, stack) =&gt; Text(<span class="hljs-string">'Error: <span class="hljs-subst">$error</span>'</span>),
      data: (user) =&gt; Text(<span class="hljs-string">'Hello <span class="hljs-subst">${user.name}</span>'</span>),
    );
  }
}
</code></pre>
<h4 data-id="heading-9">🔹 <strong>Android 等价代码</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android ViewModel + Coroutines</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: UserRepository) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _userState = MutableLiveData&lt;UiState&lt;User&gt;&gt;()
    <span class="hljs-keyword">val</span> userState: LiveData&lt;UiState&lt;User&gt;&gt; = _userState
    
    <span class="hljs-keyword">init</span> {
        loadUser()
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            _userState.value = UiState. Loading
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> user = repository.getUser()
                _userState.value = UiState.Success(user)
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _userState.value = UiState.Error(e.message ?: <span class="hljs-string">"Unknown error"</span>)
            }
        }
    }
}

<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UiState</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-keyword">object</span> Loading : UiState&lt;<span class="hljs-built_in">Nothing</span>&gt;()
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: T) : UiState&lt;T&gt;()
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-keyword">val</span> message: String) : UiState&lt;<span class="hljs-built_in">Nothing</span>&gt;()
}

<span class="hljs-comment">// UI 使用</span>
viewModel.userState.observe(<span class="hljs-keyword">this</span>) { state -&gt;
    <span class="hljs-keyword">when</span> (state) {
        <span class="hljs-keyword">is</span> UiState.Loading -&gt; showLoading()
        <span class="hljs-keyword">is</span> UiState.Success -&gt; showUser(state.<span class="hljs-keyword">data</span>)
        <span class="hljs-keyword">is</span> UiState.Error -&gt; showError(state.message)
    }
}
</code></pre>
<p><strong>相似点</strong>：</p>
<ul>
<li>✅ 都处理异步加载状态（loading/success/error）</li>
<li>✅ 都自动管理协程/Future 生命周期</li>
<li>✅ 都支持错误处理</li>
</ul>
<hr/>
<h3 data-id="heading-10">4. <strong>StreamProvider ≈ Flow / LiveData</strong></h3>
<h4 data-id="heading-11">🔹 <strong>Riverpod 代码</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// Riverpod StreamProvider</span>
<span class="hljs-keyword">final</span> messagesProvider = StreamProvider&lt;<span class="hljs-built_in">List</span>&lt;Message&gt;&gt;((ref) {
  <span class="hljs-keyword">return</span> FirebaseFirestore.instance
      .collection(<span class="hljs-string">'messages'</span>)
      .snapshots()
      .map((snapshot) =&gt; snapshot.docs
          .map((doc) =&gt; Message.fromJson(doc.data()))
          .toList());
});

<span class="hljs-comment">// UI 使用</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagesScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> messagesAsync = ref.watch(messagesProvider);
    
    <span class="hljs-keyword">return</span> messagesAsync.when(
      loading: () =&gt; CircularProgressIndicator(),
      error: (error, stack) =&gt; Text(<span class="hljs-string">'Error: <span class="hljs-subst">$error</span>'</span>),
      data: (messages) =&gt; ListView.builder(
        itemCount: messages.length,
        itemBuilder: (context, index) =&gt; Text(messages[index].content),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-12">🔹 <strong>Android 等价代码</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android ViewModel + Flow</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagesViewModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> repository: MessagesRepository
) : ViewModel() {
    <span class="hljs-keyword">val</span> messages:  StateFlow&lt;UiState&lt;List&lt;Message&gt;&gt;&gt; = 
        repository.getMessagesStream()
            .map { UiState.Success(it) }
            .<span class="hljs-keyword">catch</span> { emit(UiState.Error(it.message ?: <span class="hljs-string">"Error"</span>)) }
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>),
                initialValue = UiState.Loading
            )
}

<span class="hljs-comment">// UI 使用 (Compose)</span>
<span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MessagesScreen</span><span class="hljs-params">(viewModel:  <span class="hljs-type">MessagesViewModel</span> = viewModel()</span></span>) {
    <span class="hljs-keyword">val</span> state <span class="hljs-keyword">by</span> viewModel.messages.collectAsState()
    
    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) {
        <span class="hljs-keyword">is</span> UiState.Loading -&gt; CircularProgressIndicator()
        <span class="hljs-keyword">is</span> UiState.Error -&gt; Text(<span class="hljs-string">"Error: <span class="hljs-subst">${currentState.message}</span>"</span>)
        <span class="hljs-keyword">is</span> UiState.Success -&gt; {
            LazyColumn {
                items(currentState.<span class="hljs-keyword">data</span>) { message -&gt;
                    Text(message.content)
                }
            }
        }
    }
}
</code></pre>
<p><strong>相似点</strong>：</p>
<ul>
<li>✅ 都支持响应式数据流</li>
<li>✅ 都自动处理订阅/取消订阅</li>
<li>✅ 都支持数据转换</li>
</ul>
<hr/>
<h3 data-id="heading-13">5. <strong>依赖注入对比</strong></h3>
<h4 data-id="heading-14">🔹 <strong>Riverpod 依赖注入</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 定义依赖</span>
<span class="hljs-keyword">final</span> dioProvider = Provider((ref) =&gt; Dio());

<span class="hljs-keyword">final</span> apiServiceProvider = Provider((ref) {
  <span class="hljs-keyword">final</span> dio = ref.watch(dioProvider);
  <span class="hljs-keyword">return</span> ApiService(dio);
});

<span class="hljs-keyword">final</span> userRepositoryProvider = Provider((ref) {
  <span class="hljs-keyword">final</span> apiService = ref.watch(apiServiceProvider);
  <span class="hljs-keyword">return</span> UserRepository(apiService);
});

<span class="hljs-keyword">final</span> userProvider = FutureProvider((ref) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">final</span> repository = ref.watch(userRepositoryProvider);
  <span class="hljs-keyword">return</span> repository.getUser();
});

<span class="hljs-comment">// 使用</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> userAsync = ref.watch(userProvider);
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<h4 data-id="heading-15">🔹 <strong>Android Hilt 依赖注入</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 定义依赖</span>
<span class="hljs-meta">@Module</span>
<span class="hljs-meta">@InstallIn(SingletonComponent::class)</span>
<span class="hljs-keyword">object</span> NetworkModule {
    <span class="hljs-meta">@Provides</span>
    <span class="hljs-meta">@Singleton</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDio</span><span class="hljs-params">()</span></span>: Dio = Dio()
    
    <span class="hljs-meta">@Provides</span>
    <span class="hljs-meta">@Singleton</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideApiService</span><span class="hljs-params">(dio: <span class="hljs-type">Dio</span>)</span></span>: ApiService = ApiService(dio)
}

<span class="hljs-meta">@Module</span>
<span class="hljs-meta">@InstallIn(SingletonComponent::class)</span>
<span class="hljs-keyword">object</span> RepositoryModule {
    <span class="hljs-meta">@Provides</span>
    <span class="hljs-meta">@Singleton</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideUserRepository</span><span class="hljs-params">(
        apiService: <span class="hljs-type">ApiService</span>
    )</span></span>: UserRepository = UserRepository(apiService)
}

<span class="hljs-comment">// ViewModel 使用</span>
<span class="hljs-meta">@HiltViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepository: UserRepository
) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _user = MutableStateFlow&lt;UiState&lt;User&gt;&gt;(UiState.Loading)
    <span class="hljs-keyword">val</span> user: StateFlow&lt;UiState&lt;User&gt;&gt; = _user
    
    <span class="hljs-keyword">init</span> {
        loadUser()
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> user = userRepository.getUser()
                _user.value = UiState.Success(user)
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _user.value = UiState.Error(e. message ?: <span class="hljs-string">"Error"</span>)
            }
        }
    }
}

<span class="hljs-comment">// Activity 使用</span>
<span class="hljs-meta">@AndroidEntryPoint</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: UserViewModel <span class="hljs-keyword">by</span> viewModels()
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>对比表格</strong>：</p>



































<table><thead><tr><th>特性</th><th>Riverpod</th><th>Hilt/Dagger</th></tr></thead><tbody><tr><td><strong>配置复杂度</strong></td><td>简单</td><td>复杂（需要注解处理器）</td></tr><tr><td><strong>编译时检查</strong></td><td>✅</td><td>✅</td></tr><tr><td><strong>运行时覆盖</strong></td><td>✅ 简单</td><td>⚠️ 复杂</td></tr><tr><td><strong>学习曲线</strong></td><td>平缓</td><td>陡峭</td></tr><tr><td><strong>测试友好度</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-16">6. <strong>生命周期管理对比</strong></h3>
<h4 data-id="heading-17">🔹 <strong>Riverpod autoDispose</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 自动清理</span>
<span class="hljs-keyword">final</span> userProvider = FutureProvider.autoDispose&lt;User&gt;((ref) <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 当没有监听者时自动清理</span>
  <span class="hljs-keyword">final</span> dio = Dio();
  
  ref.onDispose(() {
    dio.close();
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Provider disposed'</span>);
  });
  
  <span class="hljs-keyword">return</span> fetchUser(dio);
});

<span class="hljs-comment">// 保持存活的配置</span>
<span class="hljs-keyword">final</span> cachedUserProvider = FutureProvider.autoDispose&lt;User&gt;((ref) <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 即使没有监听者，也保持 5 秒</span>
  ref.keepAlive();
  
  <span class="hljs-comment">// 或者条件性保持存活</span>
  <span class="hljs-keyword">final</span> link = ref.keepAlive();
  Timer(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">5</span>), () {
    link.close(); <span class="hljs-comment">// 5 秒后允许清理</span>
  });
  
  <span class="hljs-keyword">return</span> fetchUser();
});
</code></pre>
<h4 data-id="heading-18">🔹 <strong>Android ViewModel 生命周期</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dio = Dio()
    
    <span class="hljs-comment">// 自动在 ViewModel 清理时调用</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCleared()
        dio.close()
        println(<span class="hljs-string">"ViewModel cleared"</span>)
    }
}

<span class="hljs-comment">// ViewModel 的生命周期</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: UserViewModel <span class="hljs-keyword">by</span> viewModels()
    <span class="hljs-comment">// ViewModel 在 Activity 配置改变时保持存活</span>
    <span class="hljs-comment">// 在 Activity 最终销毁时清理</span>
}
</code></pre>
<p><strong>生命周期对比</strong>：</p>






























<table><thead><tr><th>场景</th><th>Riverpod</th><th>Android ViewModel</th></tr></thead><tbody><tr><td><strong>配置改变</strong></td><td>保持状态</td><td>保持状态</td></tr><tr><td><strong>页面返回</strong></td><td>自动清理（autoDispose）</td><td>清理</td></tr><tr><td><strong>应用后台</strong></td><td>保持状态</td><td>保持状态</td></tr><tr><td><strong>手动控制</strong></td><td>✅ 灵活</td><td>⚠️ 有限</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-19">7. <strong>完整架构对比</strong></h3>
<h4 data-id="heading-20">🔹 <strong>Riverpod 完整架构</strong></h4>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// ========== 数据层 ==========</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiService</span> </span>{
  <span class="hljs-keyword">final</span> Dio dio;
  ApiService(<span class="hljs-keyword">this</span>.dio);
  
  Future&lt;User&gt; getUser(<span class="hljs-built_in">String</span> id) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/user/<span class="hljs-subst">$id</span>'</span>);
    <span class="hljs-keyword">return</span> User.fromJson(response.data);
  }
}

<span class="hljs-comment">// ========== Repository 层 ==========</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
  <span class="hljs-keyword">final</span> ApiService apiService;
  UserRepository(<span class="hljs-keyword">this</span>.apiService);
  
  Future&lt;User&gt; getUser(<span class="hljs-built_in">String</span> id) =&gt; apiService.getUser(id);
}

<span class="hljs-comment">// ========== Provider 层（依赖注入）==========</span>
<span class="hljs-keyword">final</span> dioProvider = Provider((ref) =&gt; Dio(BaseOptions(
  baseUrl: <span class="hljs-string">'https://api.example.com'</span>,
)));

<span class="hljs-keyword">final</span> apiServiceProvider = Provider((ref) =&gt; 
  ApiService(ref.watch(dioProvider))
);

<span class="hljs-keyword">final</span> userRepositoryProvider = Provider((ref) =&gt; 
  UserRepository(ref.watch(apiServiceProvider))
);

<span class="hljs-comment">// ========== 状态管理层 ==========</span>
<span class="hljs-keyword">final</span> userIdProvider = StateProvider&lt;<span class="hljs-built_in">String</span>&gt;((ref) =&gt; <span class="hljs-string">'123'</span>);

<span class="hljs-keyword">final</span> userProvider = FutureProvider.autoDispose&lt;User&gt;((ref) {
  <span class="hljs-keyword">final</span> repository = ref.watch(userRepositoryProvider);
  <span class="hljs-keyword">final</span> userId = ref.watch(userIdProvider);
  <span class="hljs-keyword">return</span> repository.getUser(userId);
});

<span class="hljs-comment">// ========== UI 层 ==========</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> userAsync = ref.watch(userProvider);
    
    <span class="hljs-keyword">return</span> userAsync. when(
      loading: () =&gt; CircularProgressIndicator(),
      error: (error, stack) =&gt; Text(<span class="hljs-string">'Error: <span class="hljs-subst">$error</span>'</span>),
      data: (user) =&gt; Column(
        children: [
          Text(user.name),
          ElevatedButton(
            onPressed: () {
              <span class="hljs-comment">// 修改 userId 会自动重新加载 user</span>
              ref.read(userIdProvider.notifier).state = <span class="hljs-string">'456'</span>;
            },
            child:  Text(<span class="hljs-string">'Load Another User'</span>),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-21">🔹 <strong>Android 完整架构（MVVM + Hilt）</strong></h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ========== 数据层 ==========</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiService</span> {
    <span class="hljs-meta">@GET(<span class="hljs-string">"/user/{id}"</span>)</span>
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Path(<span class="hljs-string">"id"</span>)</span> id: <span class="hljs-type">String</span>)</span></span>: User
}

<span class="hljs-comment">// ========== Repository 层 ==========</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> apiService: ApiService
) {
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: User = apiService.getUser(id)
}

<span class="hljs-comment">// ========== ViewModel 层 ==========</span>
<span class="hljs-meta">@HiltViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepository: UserRepository
) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _userId = MutableStateFlow(<span class="hljs-string">"123"</span>)
    <span class="hljs-keyword">val</span> userId: StateFlow&lt;String&gt; = _userId
    
    <span class="hljs-keyword">val</span> user: StateFlow&lt;UiState&lt;User&gt;&gt; = userId
        .flatMapLatest { id -&gt;
            flow {
                emit(UiState.Loading)
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">val</span> user = userRepository. getUser(id)
                    emit(UiState.Success(user))
                } <span class="hljs-keyword">catch</span> (e: Exception) {
                    emit(UiState.Error(e.message ?: <span class="hljs-string">"Error"</span>))
                }
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>),
            initialValue = UiState. Loading
        )
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadUser</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span> {
        _userId.value = id
    }
}

<span class="hljs-comment">// ========== UI 层 ==========</span>
<span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">UserScreen</span><span class="hljs-params">(viewModel: <span class="hljs-type">UserViewModel</span> = viewModel()</span></span>) {
    <span class="hljs-keyword">val</span> state <span class="hljs-keyword">by</span> viewModel.user.collectAsState()
    
    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> currentState = state) {
        <span class="hljs-keyword">is</span> UiState.Loading -&gt; CircularProgressIndicator()
        <span class="hljs-keyword">is</span> UiState.Error -&gt; Text(<span class="hljs-string">"Error: <span class="hljs-subst">${currentState.message}</span>"</span>)
        <span class="hljs-keyword">is</span> UiState.Success -&gt; {
            Column {
                Text(currentState. <span class="hljs-keyword">data</span>.name)
                Button(onClick = { viewModel.loadUser(<span class="hljs-string">"456"</span>) }) {
                    Text(<span class="hljs-string">"Load Another User"</span>)
                }
            }
        }
    }
}

<span class="hljs-comment">// ========== 依赖注入配置 ==========</span>
<span class="hljs-meta">@Module</span>
<span class="hljs-meta">@InstallIn(SingletonComponent::class)</span>
<span class="hljs-keyword">object</span> AppModule {
    <span class="hljs-meta">@Provides</span>
    <span class="hljs-meta">@Singleton</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideRetrofit</span><span class="hljs-params">()</span></span>: Retrofit = Retrofit.Builder()
        .baseUrl(<span class="hljs-string">"https://api.example.com"</span>)
        .build()
    
    <span class="hljs-meta">@Provides</span>
    <span class="hljs-meta">@Singleton</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideApiService</span><span class="hljs-params">(retrofit: <span class="hljs-type">Retrofit</span>)</span></span>: ApiService =
        retrofit.create(ApiService::<span class="hljs-keyword">class</span>.java)
}
</code></pre>
<hr/>
<h2 data-id="heading-22">📊 总结对比表</h2>
<h3 data-id="heading-23">8. <strong>使用场景对比</strong></h3>













































<table><thead><tr><th>使用场景</th><th>Riverpod 方案</th><th>Android 方案</th></tr></thead><tbody><tr><td><strong>简单计数器</strong></td><td><code>StateProvider</code></td><td><code>ViewModel</code> + <code>MutableLiveData</code></td></tr><tr><td><strong>API 请求</strong></td><td><code>FutureProvider</code></td><td><code>ViewModel</code> + <code>Coroutines</code> + <code>LiveData/Flow</code></td></tr><tr><td><strong>实时数据流</strong></td><td><code>StreamProvider</code></td><td><code>ViewModel</code> + <code>Flow</code></td></tr><tr><td><strong>复杂状态逻辑</strong></td><td><code>StateNotifierProvider</code></td><td><code>ViewModel</code> + <code>StateFlow</code></td></tr><tr><td><strong>依赖注入</strong></td><td><code>Provider</code> + <code>ref.watch</code></td><td><code>Hilt</code> + <code>@Inject</code></td></tr><tr><td><strong>页面间共享状态</strong></td><td>全局 <code>Provider</code></td><td><code>ViewModel</code> (Activity scope)</td></tr><tr><td><strong>缓存管理</strong></td><td><code>Provider</code> + <code>keepAlive</code></td><td><code>ViewModel</code> + <code>cachedIn</code></td></tr></tbody></table>
<hr/>
<h3 data-id="heading-24">9. <strong>优势对比</strong></h3>








































<table><thead><tr><th>维度</th><th>Riverpod</th><th>Android (Jetpack)</th></tr></thead><tbody><tr><td><strong>学习曲线</strong></td><td>⭐⭐⭐ (中等)</td><td>⭐⭐⭐⭐ (较难，Hilt 复杂)</td></tr><tr><td><strong>配置复杂度</strong></td><td>⭐⭐⭐⭐⭐ (简单)</td><td>⭐⭐ (Hilt 需要大量配置)</td></tr><tr><td><strong>测试友好度</strong></td><td>⭐⭐⭐⭐⭐ (易于 mock)</td><td>⭐⭐⭐⭐ (需要额外工具)</td></tr><tr><td><strong>类型安全</strong></td><td>⭐⭐⭐⭐⭐ (编译时检查)</td><td>⭐⭐⭐⭐⭐ (Kotlin 类型安全)</td></tr><tr><td><strong>性能</strong></td><td>⭐⭐⭐⭐⭐ (细粒度更新)</td><td>⭐⭐⭐⭐ (需手动优化)</td></tr><tr><td><strong>生态系统</strong></td><td>⭐⭐⭐⭐ (快速增长)</td><td>⭐⭐⭐⭐⭐ (成熟完整)</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-25">🎯 结论</h2>
<p><strong>核心相似点</strong>：</p>
<ol>
<li>✅ 都是为了分离 UI 和业务逻辑</li>
<li>✅ 都支持响应式编程</li>
<li>✅ 都有依赖注入机制</li>
<li>✅ 都管理生命周期</li>
</ol>
<p><strong>关键差异</strong>：</p>
<ol>
<li>Riverpod 更轻量、更灵活</li>
<li>Android Jetpack 更成熟、生态更完整</li>
<li>Riverpod 学习曲线更平缓</li>
<li>Hilt 配置更复杂但功能更强大</li>
</ol>
<p><strong>如果你熟悉 Android 开发</strong>：</p>
<ul>
<li><code>Provider</code> = <code>ViewModel</code> + 依赖注入</li>
<li><code>ref.watch()</code> = <code>observe()</code> / <code>collectAsState()</code></li>
<li><code>FutureProvider</code> = <code>ViewModel</code> + <code>suspend fun</code></li>
<li><code>StreamProvider</code> = <code>Flow</code> + <code>collectAsState()</code></li>
</ul>
<p>Riverpod 可以看作是 <strong>"Flutter 版的 ViewModel + Hilt + LiveData/Flow"</strong> 的组合！🎯</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么通用Agent很难实现企业化落地？]]></title>    <link>https://juejin.cn/post/7585139951345532979</link>    <guid>https://juejin.cn/post/7585139951345532979</guid>    <pubDate>2025-12-19T07:30:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585139951345532979" data-draft-id="7585180775704969243" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么通用Agent很难实现企业化落地？"/> <meta itemprop="keywords" content="LLM"/> <meta itemprop="datePublished" content="2025-12-19T07:30:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="智泊AI"/> <meta itemprop="url" content="https://juejin.cn/user/3572727470361578"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么通用Agent很难实现企业化落地？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3572727470361578/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    智泊AI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:30:54.000Z" title="Fri Dec 19 2025 07:30:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>为什么很多项目在Demo演示的时候堪称惊艳，但到真正的企业化落地时却总是翻车？</p>
<p>背后的问题究竟是什么？我们今天一起来看看！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af6c4002c48d489086a66af650cf17e6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm65rOKQUk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734254&amp;x-signature=hdakyz2wuBZ%2BCqDb9uso%2BywFKZI%3D" alt="图片" loading="lazy"/></p>
<p>AI Agent 存在的问题</p>
<p>从模型层面看，核心问题始终围绕着这三个痛点：‌</p>
<p>输出随机性‌（不一致）、‌幻觉‌（不真实）、‌训练数据时效性‌（不及时）。这些本质缺陷还没有解决，而另一个被忽视的问题就是工程落地的复杂性。</p>
<p>很多专家擅长理论推导，误以为开发Agent只需要调用API和设计Prompt。等到实际落地的时候才发现，AI开发仅占30%的精力，剩余70%需要应对复杂的底层适配工作，毕竟大多数企业并不是AI原生架构。</p>
<p>其内部系统异构化严重：部分系统没有开放接口，文档缺失，权限管理混乱，再加上数据隔离和合规要求，这些都为通用Agent设置了难以跨越的技术壁垒。</p>
<p><strong>更多AI大模型学习视频及资源，都在<a href="https://link.juejin.cn?target=https%3A%2F%2Fyuan.zhipoai.cn%2F" target="_blank" title="https://yuan.zhipoai.cn/" ref="nofollow noopener noreferrer">智泊AI</a>。</strong></p>
<p>还有一条红线： 安全合规</p>
<p>在TOB领域深耕多年，尤其是金融、医疗、政务等行业，数据安全与合规性自始至终都是必须坚守的底线。</p>
<p>面对海量企业数据的处理需求，敏感信息的防护、存储架构的可靠性，无不体现系统设计的核心挑战。</p>
<p>此外，大模型作为典型的"黑箱"技术，叠加国内严苛的合规监管要求，使得Agent的每个操作节点都必须满足‌可审计、可验证、可追溯‌的标准，而这恰恰是当前多数Agent系统的技术瓶颈所在。</p>
<p>怎么解决？</p>
<p>我们真正需要的是一个更聪明的通用Agent吗？答案是否定的。我们需要的，是一个拥有完备工程化能力、能与业务系统无缝集成，并满足企业级安全标准的Agent平台。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7da56ca13e94981babbf2c5956308ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm65rOKQUk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734254&amp;x-signature=zuDkMOzD3QnaaMSYA%2BN5HZRpYiM%3D" alt="图片" loading="lazy"/></p>
<p>最近调研了国内厂商的解决方案，金蝶的苍穹Agent平台可以说是典型代表。其方法论并非从底层重构，而是依托30余年企业服务积累的业务经验，将Agent技术深度整合至现有企业管理体系中。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eed14e98d6c0489eaa42a324ec1fd32b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm65rOKQUk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734254&amp;x-signature=fYsBhlEe5fLKkZ7bETqT6ok9t78%3D" alt="图片" loading="lazy"/></p>
<p>核心做了几件事：</p>
<p>一、内置业务模板，解决冷启动问题</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65c3a1d8f11843a2bd16d51d8f0535a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm65rOKQUk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734254&amp;x-signature=NIBykdlRar4z%2FgaKsj0VmuovlnI%3D" alt="图片" loading="lazy"/></p>
<p>能力套件+领域 Know-How = 实际的价值。</p>
<p>以解决方案推荐智能体为例，该智能体依托苍穹Agent平台深度优化的RAG引擎，集成数据预处理、分层分块及名词库等核心功能。</p>
<p>通过精准识别企业行业术语（如将同事称为"同学"），解决企业级场景中指标定义与计算的语义理解难题。苍穹Agent平台通过构建多层语义分析能力，确保智能体能够准确解析企业专属的专业术语，实现检索结果的可信性与针对性。</p>
<p>二、更开放的技术标准</p>
<p>该系统原生集成于ERP/HR等业务平台，数据与权限体系天然贯通。无需额外开发API接口，Agent工具可直接复用既有系统的权限架构。兼容MCP、A2A、Open API等通用标准，为二次开发提供便利。</p>
<p>三、企业级安全：支持私有化部署</p>
<p>对于数据安全需求严格的企业，私有化部署是优选方案，确保数据始终在本地闭环流转。系统具备基于组织架构、岗位职责及个人账户的多层级权限管理体系，并集成敏感信息筛查、机密数据脱敏等深度防护功能。</p>
<p>此类高标准安全能力恰恰是金融行业与政府部门的必备需求，而常规Agent平台往往无法实现同等强度的安全保障。</p>
<p>最后</p>
<p>通用Agent与企业级Agent并非对立选择。通用Agent如同基础建材，更适合具备深厚技术实力的企业自主开发；企业级Agent则如同组装件，能够帮助追求效率的企业规避实施风险。</p>
<p>假以时日，若各类Agent能借助A2A等协议实现协同运作，将形成类似虚拟跨部门协作的高效模式。</p>
<p><strong>更多AI大模型学习视频及资源，都在<a href="https://link.juejin.cn?target=https%3A%2F%2Fyuan.zhipoai.cn%2F" target="_blank" title="https://yuan.zhipoai.cn/" ref="nofollow noopener noreferrer">智泊AI</a>。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么"云计算"能改变世界？——从本地计算到云端服务]]></title>    <link>https://juejin.cn/post/7585222924565725224</link>    <guid>https://juejin.cn/post/7585222924565725224</guid>    <pubDate>2025-12-19T07:33:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585222924565725224" data-draft-id="7585130590292557839" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 为什么&quot;云计算&quot;能改变世界？——从本地计算到云端服务"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T07:33:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="无限大6"/> <meta itemprop="url" content="https://juejin.cn/user/2865758605422890"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             为什么"云计算"能改变世界？——从本地计算到云端服务
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2865758605422890/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    无限大6
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:33:48.000Z" title="Fri Dec 19 2025 07:33:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">☁️ 为什么"云计算"能改变世界？——从本地计算到云端服务 💻</h2>
<blockquote>
<p>大家好，我是无限大，欢迎收看十万个为什么系列文章</p>
<p>希望今天的内容能对大家有所帮助</p>
</blockquote>
<p>今天咱们来聊聊云计算这个"IT界的黑科技"！从笨重的本地服务器到无处不在的云端服务，云计算正在悄悄改变我们的世界。想象一下，你不用再为电脑卡慢发愁，不用再担心数据丢失，随时随地都能访问自己的文件和应用——这就是云计算带来的魔力！</p>
<h3 data-id="heading-1">🤔 核心问题：云计算到底是什么？为什么企业都在上云？</h3>
<p>很多人对云计算的理解还停留在"存数据的网盘"，其实云计算远不止这么简单！它就像一个"超级大脑"，随时随地为你提供计算、存储、网络等各种服务。</p>
<h4 data-id="heading-2">云计算的本质</h4>
<p>云计算是一种<strong>按需提供计算资源的服务模式</strong>，你可以像用电用水一样，需要多少就用多少，用完即走，按量付费。</p>
<h4 data-id="heading-3">为什么企业都在上云？</h4>
<ul>
<li>💸 <strong>省钱省心</strong>：不用自己买服务器，不用雇人维护</li>
<li>📈 <strong>弹性伸缩</strong>：业务高峰期自动扩容，低谷期自动缩容</li>
<li>🔒 <strong>安全可靠</strong>：专业团队维护，99.99%的可用性</li>
<li>🚀 <strong>快速创新</strong>：几分钟部署新应用，抢占市场先机</li>
</ul>
<h3 data-id="heading-4">📜 云计算的"进化史"：从大型机到云端的跨越</h3>
<h4 data-id="heading-5">1. 🖥️ 大型机时代："一机难求"</h4>
<p>20世纪60年代，大型机是计算机的主流。一台大型机价格数百万美元，只有政府和大企业才能买得起。用户通过终端连接到大型机，共享计算资源。</p>
<p>这就像"公共电话亭"，大家排队使用，效率低下。如果你想打电话，得先去电话亭排队，遇到人多的时候，可能要等很久。😂</p>
<h4 data-id="heading-6">2. 💻 PC时代："各自为战"</h4>
<p>20世纪80年代，PC的出现打破了大型机的垄断。每家企业都可以买自己的服务器，建自己的机房。</p>
<p>这就像"每家都装电话"，方便是方便了，但成本很高，而且资源利用率低。很多服务器平时利用率只有10-20%，却要24小时开着，浪费电又浪费钱！</p>
<h4 data-id="heading-7">3. ☁️ 云计算时代："共享经济"</h4>
<p>2006年，AWS推出了EC2和S3服务，标志着云计算时代的到来。2009年，阿里云成立，中国云计算市场开始蓬勃发展。</p>
<p>云计算就像"共享充电宝"，你需要的时候就用，不需要的时候就还，不用自己买充电宝，也不用为充电线发愁。这就是IT界的共享经济！</p>
<h3 data-id="heading-8">🔧 技术原理：云计算的三大核心技术</h3>
<h4 data-id="heading-9">1. 🧙‍♂️ 虚拟化技术："一台变多台"</h4>
<p>虚拟化技术是云计算的核心，它能把一台物理服务器分成多个虚拟服务器，每个虚拟服务器都像一台独立的电脑，可以安装自己的操作系统和软件。</p>
<p><strong>代码实例</strong>：用Python模拟虚拟化过程</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_virtual_machines</span>(<span class="hljs-params">physical_server, vm_configs</span>):
    <span class="hljs-string">"""创建虚拟机"""</span>
    created_vms = []
    remaining_cpu = physical_server[<span class="hljs-string">'cpu'</span>]
    remaining_memory = physical_server[<span class="hljs-string">'memory'</span>]
    remaining_storage = physical_server[<span class="hljs-string">'storage'</span>]
  
    <span class="hljs-keyword">for</span> vm_name, vm_cpu, vm_memory, vm_storage <span class="hljs-keyword">in</span> vm_configs:
        <span class="hljs-keyword">if</span> (vm_cpu &lt;= remaining_cpu <span class="hljs-keyword">and</span> 
            vm_memory &lt;= remaining_memory <span class="hljs-keyword">and</span> 
            vm_storage &lt;= remaining_storage):
            <span class="hljs-comment"># 创建虚拟机</span>
            created_vms.append({
                <span class="hljs-string">'name'</span>: vm_name,
                <span class="hljs-string">'cpu'</span>: vm_cpu,
                <span class="hljs-string">'memory'</span>: vm_memory,
                <span class="hljs-string">'storage'</span>: vm_storage
            })
            <span class="hljs-comment"># 更新剩余资源</span>
            remaining_cpu -= vm_cpu
            remaining_memory -= vm_memory
            remaining_storage -= vm_storage
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 成功创建虚拟机：<span class="hljs-subst">{vm_name}</span> (<span class="hljs-subst">{vm_cpu}</span>核/<span class="hljs-subst">{vm_memory}</span>GB/<span class="hljs-subst">{vm_storage}</span>TB)"</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 资源不足，无法创建虚拟机：<span class="hljs-subst">{vm_name}</span>"</span>)
  
    <span class="hljs-keyword">return</span> created_vms, {
        <span class="hljs-string">'remaining_cpu'</span>: remaining_cpu,
        <span class="hljs-string">'remaining_memory'</span>: remaining_memory,
        <span class="hljs-string">'remaining_storage'</span>: remaining_storage
    }

<span class="hljs-comment"># 测试代码</span>
physical_server = {<span class="hljs-string">'cpu'</span>: <span class="hljs-number">16</span>, <span class="hljs-string">'memory'</span>: <span class="hljs-number">32</span>, <span class="hljs-string">'storage'</span>: <span class="hljs-number">2</span>}  <span class="hljs-comment"># 16核/32GB/2TB</span>

vm_configs = [
    (<span class="hljs-string">'web_server'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.1</span>),
    (<span class="hljs-string">'database_server'</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.5</span>),
    (<span class="hljs-string">'app_server'</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.2</span>),
    (<span class="hljs-string">'test_server'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.1</span>),
    (<span class="hljs-string">'big_data_server'</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 资源不足的情况</span>
]

created_vms, remaining_resources = create_virtual_machines(physical_server, vm_configs)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n📊 剩余资源："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"   CPU：<span class="hljs-subst">{remaining_resources[<span class="hljs-string">'remaining_cpu'</span>]}</span>/<span class="hljs-subst">{physical_server[<span class="hljs-string">'cpu'</span>]}</span> 核"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"   内存：<span class="hljs-subst">{remaining_resources[<span class="hljs-string">'remaining_memory'</span>]}</span>/<span class="hljs-subst">{physical_server[<span class="hljs-string">'memory'</span>]}</span> GB"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"   存储：<span class="hljs-subst">{remaining_resources[<span class="hljs-string">'remaining_storage'</span>]}</span>/<span class="hljs-subst">{physical_server[<span class="hljs-string">'storage'</span>]}</span> TB"</span>)
</code></pre>
<p><strong>运行结果</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">✅ 成功创建虚拟机：web_server (<span class="hljs-number">2</span>核/<span class="hljs-number">4</span>GB/<span class="hljs-number">0.1</span>TB)
✅ 成功创建虚拟机：database_server (<span class="hljs-number">4</span>核/<span class="hljs-number">8</span>GB/<span class="hljs-number">0.5</span>TB)
✅ 成功创建虚拟机：app_server (<span class="hljs-number">4</span>核/<span class="hljs-number">8</span>GB/<span class="hljs-number">0.2</span>TB)
✅ 成功创建虚拟机：test_server (<span class="hljs-number">2</span>核/<span class="hljs-number">4</span>GB/<span class="hljs-number">0.1</span>TB)
❌ 资源不足，无法创建虚拟机：big_data_server

📊 剩余资源：
   CPU：<span class="hljs-number">4</span>/<span class="hljs-number">16</span> 核
   内存：<span class="hljs-number">8</span>/<span class="hljs-number">32</span> GB
   存储：<span class="hljs-number">1.1</span>/<span class="hljs-number">2</span> TB
</code></pre>
<h4 data-id="heading-10">2. 📦 分布式存储："数据不丢失"</h4>
<p>分布式存储把数据分散存储在多个服务器上，即使某个服务器坏了，数据也不会丢失。这就像"把鸡蛋放在多个篮子里"，安全又可靠！</p>
<h4 data-id="heading-11">3. 📈 弹性伸缩："按需调整"</h4>
<p>弹性伸缩能根据业务需求自动调整计算资源。业务高峰期自动扩容，低谷期自动缩容，既保证性能，又节省成本。</p>
<p>这就像"餐厅自动调整服务员数量"——高峰期多招服务员，低谷期减少服务员，既不影响服务质量，又不浪费人力成本！</p>
<h3 data-id="heading-12">📊 趣味对比：本地服务器 vs 云服务器</h3>


















































<table><thead><tr><th>对比项</th><th>本地服务器</th><th>云服务器</th></tr></thead><tbody><tr><td><strong>成本</strong></td><td>一次性投入大（服务器+机房+维护）</td><td>按需付费，成本可控</td></tr><tr><td><strong>部署时间</strong></td><td>数天到数周</td><td>几分钟到几小时</td></tr><tr><td><strong>可靠性</strong></td><td>依赖自己维护，可靠性低</td><td>99.99%可用性，专业团队维护</td></tr><tr><td><strong>扩展性</strong></td><td>需要购买新硬件，周期长</td><td>一键扩容，分钟级响应</td></tr><tr><td><strong>安全性</strong></td><td>依赖自己的安全措施</td><td>多重备份，专业安全团队</td></tr><tr><td><strong>灵活性</strong></td><td>固定配置，无法快速调整</td><td>可随时调整配置</td></tr><tr><td><strong>维护成本</strong></td><td>需要专业IT团队</td><td>几乎不需要维护</td></tr><tr><td><strong>资源利用率</strong></td><td>低（通常10-20%）</td><td>高（按需使用）</td></tr></tbody></table>
<p><strong>数据支撑</strong>：</p>
<ul>
<li>全球云计算市场规模达6000亿美元</li>
<li>90%的企业使用云服务</li>
<li>云服务器比本地服务器成本降低30-50%</li>
</ul>
<h3 data-id="heading-13">🏢 云计算的服务模式：IaaS→PaaS→SaaS</h3>
<p>云计算有三种主要服务模式，被称为"云计算的三驾马车"：</p>

































<table><thead><tr><th>服务模式</th><th>英文全称</th><th>中文名称</th><th>比喻</th><th>例子</th></tr></thead><tbody><tr><td>IaaS</td><td>Infrastructure as a Service</td><td>基础设施即服务</td><td>租毛坯房</td><td>AWS EC2、阿里云ECS</td></tr><tr><td>PaaS</td><td>Platform as a Service</td><td>平台即服务</td><td>租精装修房</td><td>Google App Engine、阿里云PaaS</td></tr><tr><td>SaaS</td><td>Software as a Service</td><td>软件即服务</td><td>住酒店</td><td>钉钉、企业微信、Office 365</td></tr></tbody></table>
<p><strong>趣味解释</strong>：</p>
<ul>
<li><strong>IaaS</strong>：你租了一间毛坯房，需要自己装修、买家具</li>
<li><strong>PaaS</strong>：你租了一间精装修房，直接入住，家具都给你准备好了</li>
<li><strong>SaaS</strong>：你住酒店，什么都不用自己准备，直接拎包入住</li>
</ul>
<h3 data-id="heading-14">🎮 云计算的神奇应用场景</h3>
<h4 data-id="heading-15">1. 🌍 互联网应用</h4>
<p>电商平台在"双十一"期间，流量会暴涨几十倍。如果用本地服务器，需要提前准备大量服务器，平时利用率很低，成本很高。用云计算，可以根据流量自动扩容，成本大大降低！</p>
<h4 data-id="heading-16">2. 📊 大数据分析</h4>
<p>企业用云计算分析用户行为，优化产品设计；政府用云计算分析交通数据，优化交通规划。云计算提供了强大的计算能力，可以快速处理PB级的数据！</p>
<h4 data-id="heading-17">3. 🤖 人工智能</h4>
<p>OpenAI用云计算训练ChatGPT；自动驾驶公司用云计算训练自动驾驶模型。云计算提供了高性能的GPU实例，可以加速AI训练！</p>
<h4 data-id="heading-18">4. 📱 移动应用</h4>
<p>微信小程序的后端就是基于云计算的。开发者可以专注于应用开发，不用关心服务器维护！</p>
<h3 data-id="heading-19">⚠️ 常见误区纠正</h3>
<h4 data-id="heading-20">1. "云计算不安全？"</h4>
<p>很多人担心云计算不安全，其实云计算比本地服务器更安全。云服务商有专业的安全团队，多重备份，抵御攻击。</p>
<p><strong>数据支撑</strong>：云计算的安全事件发生率比本地服务器低70%！</p>
<h4 data-id="heading-21">2. "云计算很贵？"</h4>
<p>云计算看起来是按使用付费，但长期来看，比本地服务器更便宜。因为你不用购买硬件，不用雇人维护，资源利用率更高。</p>
<h4 data-id="heading-22">3. "云计算就是存数据？"</h4>
<p>云计算远不止存数据，还包括计算、数据库、网络、软件等多种服务。它是一个完整的IT基础设施！</p>
<h4 data-id="heading-23">4. "只有大企业才需要云计算？"</h4>
<p>小公司更需要云计算！小公司没有专业的IT团队，没有足够的资金买服务器，云计算可以让小公司用上和大企业一样的IT资源。</p>
<h3 data-id="heading-24">🔮 未来展望：云计算的发展趋势</h3>
<h4 data-id="heading-25">1. 🚀 边缘计算兴起</h4>
<p>边缘计算是指在靠近数据产生的地方进行计算，减少延迟。边缘计算和云计算结合，将成为未来的主流！</p>
<h4 data-id="heading-26">2. 🧠 AI与云计算结合</h4>
<p>AI将融入云计算的各个环节，让云计算更智能。比如，智能调度资源，预测流量变化，自动优化配置！</p>
<h4 data-id="heading-27">3. 🌐 多云战略</h4>
<p>越来越多的企业会采用多云战略，使用多个云服务商的服务，避免供应商锁定！</p>
<h4 data-id="heading-28">4. 📈 行业云发展</h4>
<p>针对特定行业的云服务会越来越多，比如金融云、医疗云、教育云等。这些云服务会提供行业特定的功能和合规性支持！</p>
<h3 data-id="heading-29">🎓 互动小测验：你答对了吗？</h3>



































<table><thead><tr><th>问题</th><th>答案</th><th>你答对了吗？</th></tr></thead><tbody><tr><td>云计算的三种服务模式是什么？</td><td>IaaS、PaaS、SaaS</td><td>✅/❌</td></tr><tr><td>全球云计算市场规模约为多少？</td><td>6000亿美元</td><td>✅/❌</td></tr><tr><td>云计算的核心技术是什么？</td><td>虚拟化、分布式存储、弹性伸缩</td><td>✅/❌</td></tr><tr><td>云服务器的资源利用率通常比本地服务器高吗？</td><td>是的</td><td>✅/❌</td></tr><tr><td>边缘计算的主要优势是什么？</td><td>减少延迟</td><td>✅/❌</td></tr></tbody></table>
<h3 data-id="heading-30">🎯 结语：云计算改变世界</h3>
<p>云计算就像电力一样，改变了我们的生活和工作方式。它让计算资源变得像水电煤一样普及，让小企业也能用上大企业的IT资源，加速了创新和发展。</p>
<p>未来，云计算会继续深入我们的生活，带来更多的便利和创新。让我们一起拥抱云计算时代！</p>
<hr/>
<h3 data-id="heading-31">💬 互动话题</h3>
<ol>
<li>你或你的公司使用云计算吗？使用的是哪种服务？</li>
<li>你觉得云计算最大的优势是什么？</li>
<li>你对云计算的未来有什么期待？</li>
</ol>
<p>快来评论区聊聊你的想法！💬 点赞收藏不迷路，咱们下期继续探索计算机的"十万个为什么"！🎉</p>
<p><strong>关注我</strong>，下期带你解锁更多计算机的"奇葩冷知识"！🤓</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringBoot集成DeepSeek]]></title>    <link>https://juejin.cn/post/7585180150254338063</link>    <guid>https://juejin.cn/post/7585180150254338063</guid>    <pubDate>2025-12-19T07:18:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585180150254338063" data-draft-id="7585130590292443151" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringBoot集成DeepSeek"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T07:18:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户90832460273"/> <meta itemprop="url" content="https://juejin.cn/user/307518986530984"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringBoot集成DeepSeek
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/307518986530984/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户90832460273
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:18:23.000Z" title="Fri Dec 19 2025 07:18:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 AI 兴起的时候，面向的是 Python 开发者，而现在有了 Spring AI，作为Java 开发这也能将 AI 集成进我们的企业级项目中，广泛运用于实际业务，比如智能客服、健康饮食推荐、自动退订订单等等。本文将详细的讲解 SpringBoot 如何集成 DeepSeek 大模型服务，来完成聊天功能。</p>
<h2 data-id="heading-1">项目集成</h2>
<p>截至发稿时间，Spring AI 的最新版本 1.1.2​，要求 Spring Boot 3.4.x 和 3.5.x。</p>
<h3 data-id="heading-2">环境准备</h3>
<ol>
<li>JDK：17+</li>
<li>SpringBoot：3.4+</li>
</ol>
<h3 data-id="heading-3">添加依赖</h3>
<p>引入 deepseek​模型和 webflux​来进行流式响应</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-model-deepseek<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">配置 DeepSeek 模型</h3>
<p>可以自己去官网申请，我这里使用的是<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.siliconflow.cn%2Fi%2F5I4ebAG9" target="_blank" title="https://cloud.siliconflow.cn/i/5I4ebAG9" ref="nofollow noopener noreferrer">硅基流动</a>免费的模型。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">ai:</span>
    <span class="hljs-attr">deepseek:</span>
      <span class="hljs-attr">api-key:</span> <span class="hljs-string">sk-xxxxx</span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">https://api.siliconflow.cn</span>
      <span class="hljs-attr">chat:</span>
        <span class="hljs-attr">options:</span>
          <span class="hljs-attr">model:</span> <span class="hljs-string">xxx</span>
          <span class="hljs-attr">temperature:</span> <span class="hljs-number">0.7</span>
</code></pre>
<p>如果想和笔者使用同样的，可以跳转：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.siliconflow.cn%2Fi%2F5I4ebAG9%25EF%25BC%258C%25E4%25BD%25BF%25E7%2594%25A8%25E5%2585%258D%25E8%25B4%25B9%25E7%259A%2584%25E5%258D%25B3%25E5%258F%25AF%25E3%2580%2582" target="_blank" title="https://cloud.siliconflow.cn/i/5I4ebAG9%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84%E5%8D%B3%E5%8F%AF%E3%80%82" ref="nofollow noopener noreferrer">cloud.siliconflow.cn/i/5I4ebAG9，…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ee6a2ab447645868a5a48c28b0b9903~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=p8Xsc3PDCuO1PerxClgKco7IE40%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-5">实现第一个 AI 对话</h3>
<p>新建控制器，创建/chat/simple​接口，这里的ChatClient​就是通用的聊天客户端，也可以使用 DeepSeek 的 ChatModel​，这里不进行赘述。在这个简单示例中，message​决定了用户消息的内容。该call()​方法向 AI 模型发送请求，然后content()​方法将AI模型的响应作为String​。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping(<span class="hljs-string">"/chat"</span>)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatBotController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

    <span class="hljs-keyword">public</span> ChatBotController(ChatClient.Builder chatClientBuilder) {
        <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    }

    <span class="hljs-meta">@GetMapping(value = <span class="hljs-string">"/simple"</span>)</span>
    <span class="hljs-keyword">public</span> String simple(String message) {
        <span class="hljs-keyword">return</span> chatClient.prompt()
                .user(message)
                .call()
                .content();
    }
}
</code></pre>
<p>调用接口后会一次性响应 AI 的内容。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0d0d78b4295405abbe87bfef5096511~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=cvgYWuz14jB1mdJ307kHqpJe2D4%3D" alt="image.png" loading="lazy"/>
如果内容比较大，体验感就不是很好，接下来我们可以采用流的方式来逐字进行输出。</p>
<h3 data-id="heading-6">流式输出</h3>
<p>跟前面的相比较，将call()​改成了stream()​，告诉 AI 生成字符串的Flux​。并且设置响应的类型为text/event-stream​，前端可以通过EventSource​API轻松监听这个接口。每当收到一个新的数据块，就会触发onmessage​事件，从而实现内容的实时追加显示，创造出类似打字机的效果。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/stream"</span>, produces = <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">TEXT_EVENT_STREAM_VALUE</span>)
<span class="hljs-keyword">public</span> <span class="hljs-title class_">Flux</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">chatStream</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {
    <span class="hljs-keyword">return</span> chatClient.<span class="hljs-title function_">prompt</span>()
            .<span class="hljs-title function_">user</span>(message)
            .<span class="hljs-title function_">stream</span>()
            .<span class="hljs-title function_">content</span>();
}
</code></pre>
<p>这里调用后可以明显看得到不是一次性输出的结果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4448309135e452cbebcddd9c1b55bff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=SnSfCwlt0Bih4SYNenoZh6RXGCY%3D" alt="image.png" loading="lazy"/></p>
<p>大型语言模型（LLM）是无状态的，这意味着它们不会保留之前交互的相关信息。即使告诉了AI你叫什么，它依然在下次对话也会忘记。</p>
<h3 data-id="heading-7">聊天记忆</h3>
<p>Spring AI 会自动配置一个ChatMemory​ 的 bean，您可直接在应用程序中使用。默认情况下，它使用内存存储库来存储消息（InMemoryChatMemoryRepository​）以及MessageWindowChatMemory​来管理对话历史。如果已配置了其他存储库（例如，Cassandra、JDBC 或 Neo4j），Spring AI 将改用该存储库。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Autowired</span>
ChatMemory chatMemory;
</code></pre>
<p>这里我们就直接使用内存来完成聊天的记忆功能。只需要使用advisors​来配置即可：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@GetMapping</span>(value = <span class="hljs-string">"/stream"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;String&gt; chatStream(String message) {
    return chatClient<span class="hljs-selector-class">.prompt</span>()
            <span class="hljs-selector-class">.user</span>(message)
            <span class="hljs-selector-class">.advisors</span>(MessageChatMemoryAdvisor.builder(chatMemory)<span class="hljs-selector-class">.build</span>())
            <span class="hljs-selector-class">.stream</span>()
            <span class="hljs-selector-class">.content</span>();
}
</code></pre>
<p>这样我们的 AI 就有了记忆了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb04b63690cb454483f5fb30382cae6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=kQmZVDoYInzS4y72GuKU0QusgzU%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-8">思考</h3>
<ol>
<li>我们怎么给 AI 预置一个角色？比如让它作为一个智能客服或者作为一个营养师。</li>
<li>如果用户 A 和用户 B 同时对 AI 进行对话，怎么让对话进行隔离？</li>
</ol>
<h2 data-id="heading-9">完整代码</h2>
<p>后续我会整理后将代码放在Gitee：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fleven2018%2Flanjii" target="_blank" title="https://gitee.com/leven2018/lanjii" ref="nofollow noopener noreferrer">lanjii: 开箱即用的 RBAC 权限管理系统。后端基于 Spring Boot3 构建， 集成了 JWT 认证、Spring Security 6、MyBatis-Plus</a></p>
<p>这是一款 MIT 协议可商用的SpringBoot脚手架，拥有完整的权限控制和常用的基础功能。希望大家给个 Star，后面有新的功能和一些 BUG 的修复也会提交到 Gitee。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d52f26656d64b36bc9471d8f13d82ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=IMkDuyeHq%2F%2Bp3jVmNWUjp6sQXm4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39f9acf0df8a4152a5f1dcbf5f19d9f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTA4MzI0NjAyNzM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733503&amp;x-signature=4jsXfJ3zi4pj8qbAQslBV2zmjlg%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-10">小结</h2>
<p>这样一个简单的带有记忆的 AI 聊天功能就开发好了。在实际场景中，我们如何将这个AI 结合到我们的业务中呢？比如如何让用户对话让 AI 检索我们自己的知识库，然后针对客户的问题在我们的知识库来进行回答。又或者让 AI 自动帮退订订单。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Boot + Redis 注解极简教程：5分钟搞定CRUD操作]]></title>    <link>https://juejin.cn/post/7585206549305311295</link>    <guid>https://juejin.cn/post/7585206549305311295</guid>    <pubDate>2025-12-19T07:21:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206549305311295" data-draft-id="7585171571128959012" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Boot + Redis 注解极简教程：5分钟搞定CRUD操作"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-12-19T07:21:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小坏说Java"/> <meta itemprop="url" content="https://juejin.cn/user/3898184413750203"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Boot + Redis 注解极简教程：5分钟搞定CRUD操作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3898184413750203/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小坏说Java
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:21:17.000Z" title="Fri Dec 19 2025 07:21:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Boot 整合 Redis 注解实现简单 CRUD</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RVyYBZE4z%2F%3Fvd_source%3Dd9789da0ed994ac777a822cd5ea4cf30" target="_blank" title="https://www.bilibili.com/video/BV1RVyYBZE4z/?vd_source=d9789da0ed994ac777a822cd5ea4cf30" ref="nofollow noopener noreferrer">零基础全栈开发Java微服务版本实战-后端-前端-运维-实战企业级三个实战项目</a></p>
<h3 data-id="heading-1">一、项目搭建</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RVyYBZE4z%2F%3Fvd_source%3Dd9789da0ed994ac777a822cd5ea4cf30" target="_blank" title="https://www.bilibili.com/video/BV1RVyYBZE4z/?vd_source=d9789da0ed994ac777a822cd5ea4cf30" ref="nofollow noopener noreferrer">零基础全栈开发Java微服务版本实战-后端-前端-运维-实战企业级三个实战项目</a></p>
<h4 data-id="heading-2">1.1 添加依赖</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pom.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Spring Boot Web --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- Spring Boot Redis --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- Lombok --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>
<h4 data-id="heading-3">1.2 配置文件</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># application.yml</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">redis:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>
    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>
    
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
</code></pre>
<h3 data-id="heading-4">二、实体类</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.entity;

<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> org.springframework.<span class="hljs-keyword">data</span>.<span class="hljs-keyword">annotation</span>.Id;
<span class="hljs-keyword">import</span> org.springframework.<span class="hljs-keyword">data</span>.redis.core.RedisHash;
<span class="hljs-keyword">import</span> org.springframework.<span class="hljs-keyword">data</span>.redis.core.index.Indexed;
<span class="hljs-keyword">import</span> java.io.Serializable;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@RedisHash</span>: 声明实体类，value指定Redis中的key前缀
 * 存储格式: user:{id}
 */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@RedisHash(<span class="hljs-string">"user"</span>)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> {
    
    <span class="hljs-meta">@Id</span>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;            <span class="hljs-comment">// 主键</span>
    
    <span class="hljs-meta">@Indexed</span>
    <span class="hljs-keyword">private</span> String username;    <span class="hljs-comment">// 创建索引，可以按username查询</span>
    
    <span class="hljs-keyword">private</span> String email;
    
    <span class="hljs-keyword">private</span> Integer age;
}
</code></pre>
<h3 data-id="heading-5">三、Repository 接口</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.repository;

<span class="hljs-keyword">import</span> com.example.entity.User;
<span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Optional;

<span class="hljs-comment">/**
 * CrudRepository 提供基本的CRUD方法
 * 可以根据方法名自动生成查询
 */</span>
<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CrudRepository</span>&lt;User, Long&gt; {
    
    <span class="hljs-comment">// 根据用户名查询（精确匹配）</span>
    List&lt;User&gt; <span class="hljs-title function_">findByUsername</span><span class="hljs-params">(String username)</span>;
    
    <span class="hljs-comment">// 根据邮箱查询</span>
    Optional&lt;User&gt; <span class="hljs-title function_">findByEmail</span><span class="hljs-params">(String email)</span>;
    
    <span class="hljs-comment">// 根据年龄范围查询</span>
    List&lt;User&gt; <span class="hljs-title function_">findByAgeBetween</span><span class="hljs-params">(Integer minAge, Integer maxAge)</span>;
    
    <span class="hljs-comment">// 删除指定用户名的用户</span>
    Long <span class="hljs-title function_">deleteByUsername</span><span class="hljs-params">(String username)</span>;
}
</code></pre>
<h3 data-id="heading-6">四、Service 层</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RVyYBZE4z%2F%3Fvd_source%3Dd9789da0ed994ac777a822cd5ea4cf30" target="_blank" title="https://www.bilibili.com/video/BV1RVyYBZE4z/?vd_source=d9789da0ed994ac777a822cd5ea4cf30" ref="nofollow noopener noreferrer">零基础全栈开发Java微服务版本实战-后端-前端-运维-实战企业级三个实战项目</a></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.service;

<span class="hljs-keyword">import</span> com.example.entity.User;
<span class="hljs-keyword">import</span> com.example.repository.UserRepository;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;
<span class="hljs-keyword">import</span> org.springframework.cache.<span class="hljs-keyword">annotation</span>.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Optional;

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@CacheConfig(cacheNames = <span class="hljs-string">"user"</span>)</span>  <span class="hljs-comment">// 类级别缓存配置</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
    
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@Cacheable</span>: 查询缓存
     * 1. 先查缓存，有则直接返回
     * 2. 无则执行方法，将结果存入缓存
     */</span>
    <span class="hljs-meta">@Cacheable(key = <span class="hljs-string">"#id"</span>)</span>
    <span class="hljs-keyword">public</span> User findById(<span class="hljs-built_in">Long</span> id) {
        log.info(<span class="hljs-string">"查询数据库，用户ID: {}"</span>, id);
        <span class="hljs-keyword">return</span> userRepository.findById(id).orElse(<span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-comment">/**
     * 查询所有用户
     */</span>
    <span class="hljs-keyword">public</span> List&lt;User&gt; findAll() {
        <span class="hljs-keyword">return</span> (List&lt;User&gt;) userRepository.findAll();
    }
    
    <span class="hljs-comment">/**
     * 根据用户名查询
     */</span>
    <span class="hljs-keyword">public</span> List&lt;User&gt; findByUsername(String username) {
        <span class="hljs-keyword">return</span> userRepository.findByUsername(username);
    }
    
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@CachePut</span>: 更新缓存
     * 每次都会执行方法，并将结果更新到缓存
     */</span>
    <span class="hljs-meta">@CachePut(key = <span class="hljs-string">"#user.id"</span>)</span>
    <span class="hljs-keyword">public</span> User save(User user) {
        log.info(<span class="hljs-string">"保存用户: {}"</span>, user.getUsername());
        <span class="hljs-keyword">return</span> userRepository.save(user);
    }
    
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@CacheEvict</span>: 删除缓存
     * 方法执行后删除指定key的缓存
     */</span>
    <span class="hljs-meta">@CacheEvict(key = <span class="hljs-string">"#id"</span>)</span>
    <span class="hljs-keyword">public</span> void deleteById(<span class="hljs-built_in">Long</span> id) {
        log.info(<span class="hljs-string">"删除用户，ID: {}"</span>, id);
        userRepository.deleteById(id);
    }
    
    <span class="hljs-comment">/**
     * 更新用户
     */</span>
    <span class="hljs-meta">@Caching(
        put = @CachePut(key = <span class="hljs-string">"#user.id"</span>),
        evict = @CacheEvict(key = <span class="hljs-string">"'list'"</span>)  // 清除列表缓存
    )</span>
    <span class="hljs-keyword">public</span> User update(User user) {
        log.info(<span class="hljs-string">"更新用户: {}"</span>, user.getId());
        <span class="hljs-keyword">return</span> userRepository.save(user);
    }
    
    <span class="hljs-comment">/**
     * 缓存用户列表
     */</span>
    <span class="hljs-meta">@Cacheable(key = <span class="hljs-string">"'list'"</span>)</span>
    <span class="hljs-keyword">public</span> List&lt;User&gt; findAllWithCache() {
        log.info(<span class="hljs-string">"查询所有用户（带缓存）"</span>);
        <span class="hljs-keyword">return</span> (List&lt;User&gt;) userRepository.findAll();
    }
}
</code></pre>
<h3 data-id="heading-7">五、Controller 层</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.controller</span>;

<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.entity</span><span class="hljs-selector-class">.User</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.UserService</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.beans</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Autowired</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span>.*;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.List</span>;

@<span class="hljs-selector-tag">RestController</span>
@<span class="hljs-selector-tag">RequestMapping</span>(<span class="hljs-string">"/api/users"</span>)
<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">UserController</span> {
    
    <span class="hljs-variable">@Autowired</span>
    private UserService userService;
    
    <span class="hljs-comment">// 新增用户</span>
    <span class="hljs-variable">@PostMapping</span>
    public User <span class="hljs-built_in">createUser</span>(<span class="hljs-variable">@RequestBody</span> User user) {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.save</span>(user);
    }
    
    <span class="hljs-comment">// 根据ID查询用户</span>
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">getUserById</span>(<span class="hljs-variable">@PathVariable</span> Long id) {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.findById</span>(id);
    }
    
    <span class="hljs-comment">// 查询所有用户</span>
    @<span class="hljs-selector-tag">GetMapping</span>
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">User</span>&gt; <span class="hljs-selector-tag">getAllUsers</span>() {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.findAllWithCache</span>();
    }
    
    <span class="hljs-comment">// 根据用户名查询</span>
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/search"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">User</span>&gt; <span class="hljs-selector-tag">getUserByUsername</span>(<span class="hljs-variable">@RequestParam</span> String username) {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.findByUsername</span>(username);
    }
    
    <span class="hljs-comment">// 更新用户</span>
    @<span class="hljs-selector-tag">PutMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">updateUser</span>(<span class="hljs-variable">@PathVariable</span> Long id, <span class="hljs-variable">@RequestBody</span> User user) {
        <span class="hljs-selector-tag">user</span><span class="hljs-selector-class">.setId</span>(id);
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.update</span>(user);
    }
    
    <span class="hljs-comment">// 删除用户</span>
    @<span class="hljs-selector-tag">DeleteMapping</span>(<span class="hljs-string">"/{id}"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">deleteUser</span>(<span class="hljs-variable">@PathVariable</span> Long id) {
        <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.deleteById</span>(id);
        <span class="hljs-selector-tag">return</span> "删除成功";
    }
}
</code></pre>
<h3 data-id="heading-8">六、主启动类</h3>
<pre><code class="hljs language-typescript" lang="typescript">package com.<span class="hljs-property">example</span>;

<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">EnableCaching</span>;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableCaching</span>  <span class="hljs-comment">// 开启缓存支持</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);
    }
}
</code></pre>
<h3 data-id="heading-9">七、测试示例</h3>
<h4 data-id="heading-10">7.1 使用 Postman 测试</h4>
<h5 data-id="heading-11">1. 新增用户</h5>
<pre><code class="hljs language-bash" lang="bash">POST http://localhost:8080/api/users
Content-Type: application/json

{
    <span class="hljs-string">"username"</span>: <span class="hljs-string">"张三"</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"zhangsan@example.com"</span>,
    <span class="hljs-string">"age"</span>: 25
}
</code></pre>
<h5 data-id="heading-12">2. 查询用户</h5>
<pre><code class="hljs language-bash" lang="bash">GET http://localhost:8080/api/users/1
</code></pre>
<h5 data-id="heading-13">3. 查询所有用户</h5>
<pre><code class="hljs language-bash" lang="bash">GET http://localhost:8080/api/users
</code></pre>
<h5 data-id="heading-14">4. 更新用户</h5>
<pre><code class="hljs language-bash" lang="bash">PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
    <span class="hljs-string">"username"</span>: <span class="hljs-string">"张三"</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"zhangsan_new@example.com"</span>,
    <span class="hljs-string">"age"</span>: 26
}
</code></pre>
<h5 data-id="heading-15">5. 删除用户</h5>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RVyYBZE4z%2F%3Fvd_source%3Dd9789da0ed994ac777a822cd5ea4cf30" target="_blank" title="https://www.bilibili.com/video/BV1RVyYBZE4z/?vd_source=d9789da0ed994ac777a822cd5ea4cf30" ref="nofollow noopener noreferrer">零基础全栈开发Java微服务版本实战-后端-前端-运维-实战企业级三个实战项目</a></p>
<pre><code class="hljs language-bash" lang="bash">DELETE http://localhost:8080/api/users/1
</code></pre>
<h3 data-id="heading-16">八、注解总结</h3>


















































<table><thead><tr><th>注解</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>@RedisHash</code></td><td>实体类映射到Redis Hash</td><td><code>@RedisHash("user")</code></td></tr><tr><td><code>@Id</code></td><td>标记主键字段</td><td><code>@Id private Long id;</code></td></tr><tr><td><code>@Indexed</code></td><td>创建二级索引，支持字段查询</td><td><code>@Indexed private String username;</code></td></tr><tr><td><code>@EnableCaching</code></td><td>启用缓存（主类上）</td><td><code>@EnableCaching</code></td></tr><tr><td><code>@Cacheable</code></td><td>方法结果缓存</td><td><code>@Cacheable(key = "#id")</code></td></tr><tr><td><code>@CachePut</code></td><td>更新缓存</td><td><code>@CachePut(key = "#user.id")</code></td></tr><tr><td><code>@CacheEvict</code></td><td>删除缓存</td><td><code>@CacheEvict(key = "#id")</code></td></tr><tr><td><code>@Caching</code></td><td>组合多个缓存操作</td><td>见上面Service中的update方法</td></tr></tbody></table>
<h3 data-id="heading-17">九、运行效果</h3>
<ol>
<li><strong>第一次查询用户(1)</strong> ：控制台打印日志"查询数据库"</li>
<li><strong>第二次查询用户(1)</strong> ：直接从缓存返回，不打印日志</li>
<li><strong>更新用户(1)</strong> ：更新数据库，并更新缓存</li>
<li><strong>删除用户(1)</strong> ：删除数据库记录，并清除缓存</li>
</ol>
<h3 data-id="heading-18">十、注意事项</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RVyYBZE4z%2F%3Fvd_source%3Dd9789da0ed994ac777a822cd5ea4cf30" target="_blank" title="https://www.bilibili.com/video/BV1RVyYBZE4z/?vd_source=d9789da0ed994ac777a822cd5ea4cf30" ref="nofollow noopener noreferrer">零基础全栈开发Java微服务版本实战-后端-前端-运维-实战企业级三个实战项目</a></p>
<ol>
<li>实体类必须实现 <code>Serializable</code>接口</li>
<li>缓存注解的方法必须是 <code>public</code>的</li>
<li>同一个类内部调用缓存注解的方法不会生效</li>
<li>Redis 需要提前安装并启动</li>
</ol>
<p>这个示例包含了最基本的 Redis 注解 CRUD 操作，可以直接运行使用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线程池用法及原理]]></title>    <link>https://juejin.cn/post/7585130590292623375</link>    <guid>https://juejin.cn/post/7585130590292623375</guid>    <pubDate>2025-12-19T07:36:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585130590292623375" data-draft-id="7585222924565757992" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线程池用法及原理"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T07:36:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨守城规"/> <meta itemprop="url" content="https://juejin.cn/user/501817459614766"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线程池用法及原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/501817459614766/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨守城规
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:36:50.000Z" title="Fri Dec 19 2025 07:36:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、线程池的用法</h2>
<p>简单用法，这里写一个简单的demo</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 线程池</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executePool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException {

    <span class="hljs-comment">// 手动创建线程池</span>
    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(
            <span class="hljs-number">4</span>,
            <span class="hljs-number">4</span>,
            <span class="hljs-number">100</span>, <span class="hljs-comment">// 非核心线程空闲时间</span>
            TimeUnit.MILLISECONDS, <span class="hljs-comment">// 超时单位</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() { <span class="hljs-comment">// 线程工厂</span>
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> {
                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);
                    <span class="hljs-keyword">return</span> thread;
                }
            },
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略</span>
    );

    <span class="hljs-comment">// 执行任务，没有返回值的任务</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        executor.execute(() -&gt; {
            System.out.println(<span class="hljs-string">"没有返回值！！！"</span> + Thread.currentThread());
        });
    }
    
    <span class="hljs-comment">// 执行任务，有返回值的任务</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> executor.submit(() -&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"100"</span>;
    }).get();
    System.out.println(result);

}
</code></pre>
<p>线程池线程大小的设置可以从两方面来说</p>
<p>CPU密集、IO 密集</p>
<p>CPU 密集：核心线程数：CPU 核心数 + 1 【CPU 一直在执行指令，进行大量计算】</p>
<p>IO 密集：核心线程数：CPU 内核数 * 2 【CPU 一直在做 IO 调用】</p>
<p>一般业务上，不会按这个走，业务上有不同的任务，不同的任务用不同的线程池，可能一个服务里面有多个线程池</p>
<h2 data-id="heading-1">二、线程池的核心属性</h2>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// AtomicInteger ，就是一个int，用 CAS 来保证原子性</span>
<span class="hljs-comment">// 高三位表示线程池状态 </span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));

<span class="hljs-comment">// 29</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;

<span class="hljs-comment">// 工作线程最大个数</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;

<span class="hljs-comment">// 线程池的几个状态</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;

<span class="hljs-comment">// 获取线程池状态</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     { <span class="hljs-keyword">return</span> c &amp; ~COUNT_MASK; }
<span class="hljs-comment">// 获取工作线程个数</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  { <span class="hljs-keyword">return</span> c &amp; COUNT_MASK; }
</code></pre>
<h2 data-id="heading-2">三、线程池状态流转</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b710e9df87b9427bb10a5e9be16070f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo5a6I5Z-O6KeE:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734610&amp;x-signature=FvJ1JdjFRj1BCksrX5uMb9bzn6Q%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">四、excute方法</h2>
<p>线程池处理任务的流程，当新任务来了是先放队列还是开辟新的线程处理，都在这个逻辑里</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">execute</span>(Runnable command) {
    <span class="hljs-comment">// 执行的任务为空，抛异常</span>
    if (command == null){
        throw new <span class="hljs-built_in">NullPointerException</span>();
    }
    <span class="hljs-comment">// 拿到 ctl</span>
    int c = ctl<span class="hljs-selector-class">.get</span>();
    <span class="hljs-comment">// 通过c获取工作线程数 判断 是否小于 核心线程数</span>
    if (workerCountOf(c) &lt; corePoolSize) {
        <span class="hljs-comment">// addWorker() 第二个参数 含义：true : 核心线程 false : 代表非核心线程</span>
        if (addWorker(command, true)){
            <span class="hljs-comment">// 添加核心线程执行任务成功 return</span>
            return;
        }
        <span class="hljs-comment">// 添加失败 重新获取 ctl 的值</span>
        c = ctl<span class="hljs-selector-class">.get</span>();
    }
    <span class="hljs-comment">// 判断线程池状态 &lt; Shutdown </span>
    <span class="hljs-comment">// 线程状态为 Running状态的同时，将任务添加进队列 </span>
    if (isRunning(c) &amp;&amp; workQueue<span class="hljs-selector-class">.offer</span>(command)) {
        <span class="hljs-comment">// doublecheck 再次获取 ctl值</span>
        int recheck = ctl<span class="hljs-selector-class">.get</span>();
        <span class="hljs-comment">// 线程池状态非 Running状态 从工作队列移除掉任务</span>
        if (!isRunning(recheck) &amp;&amp; <span class="hljs-built_in">remove</span>(command)){
            <span class="hljs-comment">// 走一波拒绝策略</span>
            <span class="hljs-built_in">reject</span>(command);
        }else if (workerCountOf(recheck) == <span class="hljs-number">0</span>){ <span class="hljs-comment">// 线程池状态是 Running -&gt; 线程池的工作线程数为 0 进这个if分支</span>
            <span class="hljs-comment">// 进这个if还有一个说法：可以将核心线程数设置为0，所有的工作线程都是非核心线程</span>
            <span class="hljs-comment">// 情况二：核心线程数可以通过keepAlive 来销毁，如果此时核心线程刚好被销毁，工作线程可能为 0</span>
            <span class="hljs-comment">// 添加一个非核心线程的空任务 去处理工作队列中的任务</span>
            <span class="hljs-built_in">addWorker</span>(null, false);
        }
    }else if (!addWorker(command, false)){ <span class="hljs-comment">// 启动非核心线程去处理工作队列里的任务失败 ---&gt; 线程满了</span>
        <span class="hljs-comment">// 根据上下条件判断：什么时候进行这个if的条件判断 要么线程池状态不是 Running , 要么 任务添加到队列失败</span>

        <span class="hljs-comment">// 走一波拒绝策略</span>
        <span class="hljs-built_in">reject</span>(command);
    }
}
</code></pre>
<h2 data-id="heading-4">五、addWorker添加工作线程并处理任务</h2>
<p>从这个方法就可以看出，一个线程就是一个 Worker</p>
<p>这个方法分为两大部分：</p>
<p>1、CAS 自增 ctl 工作线程数</p>
<p>2、步骤一成功：new 一个 Worker 处理任务</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
* firstTask : 任务
* core : 是否是核心线程
*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> {
    <span class="hljs-comment">// 下面这个两层的for循环 --&gt; 给ctl线程数 + 1</span>
    retry:
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();;) { <span class="hljs-comment">// 外层循环 --&gt; 校验线程池状态</span>
        <span class="hljs-comment">// 边界校验  线程池状态不是runing 且 [线程池状态至少是 STOP  或者 传进来的任务不是null 或者 任务队列是空]</span>
        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)
            &amp;&amp; (runStateAtLeast(c, STOP)
                || firstTask != <span class="hljs-literal">null</span>
                || workQueue.isEmpty())){
                     <span class="hljs-comment">// 不满足创建新线程的条件 ，直接return</span>
                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

        <span class="hljs-keyword">for</span> (;;) { <span class="hljs-comment">// 内层循环：尝试增加工作线程数</span>

            <span class="hljs-comment">// 工作线程数是否超过阈值（核心线程数 / 最大线程数）</span>
            <span class="hljs-keyword">if</span> (workerCountOf(c)
                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK)){
                    <span class="hljs-comment">// 线程数已达上限，不能再新增</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            <span class="hljs-comment">// CAS 工作线程数自增</span>
            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))
                <span class="hljs-comment">// 跳出外层循环</span>
                <span class="hljs-keyword">break</span> retry;
            
            <span class="hljs-comment">// CAS 失败，重新获取ctl</span>
            c = ctl.get(); 
            <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)) <span class="hljs-comment">// 线程池状态至少是 ShutDown</span>
                <span class="hljs-keyword">continue</span> retry; <span class="hljs-comment">// 继续下一次外层循环，重新进行校验</span>

            <span class="hljs-comment">// 否则 重试 CAS 自增线程数</span>
        }
    }

    <span class="hljs-comment">// 这一部分 ：启动线程处理任务</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 工作线程是否启动</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Worker是否成功加入线程池的管理集合</span>
    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 工作线程默认为null</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// new 一个工作线程出来</span>
        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);
        <span class="hljs-comment">// 拿到thread</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;
        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// 除非自己声明的线程工厂返回的是 null ，否则一定不为 null</span>
            <span class="hljs-comment">// 获取线程池的全局锁</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;
            <span class="hljs-comment">// 之所以要获取锁资源：因为在启动这个线程时，避免线程池状态发生变化 --&gt; 线程池调用shutDown方法时也会获取这个锁</span>
            mainLock.lock();
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 重新获取ctl</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();
                <span class="hljs-comment">// 判断线程池状态</span>
                <span class="hljs-comment">// 场景1：线程池处于RUNNING状态 → 无条件允许</span>
                <span class="hljs-comment">// 场景2：线程池状态&lt;STOP（即SHUTDOWN）且无初始任务 → 允许创建Worker处理队列残留任务</span>
                <span class="hljs-keyword">if</span> (isRunning(c) || (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) {

                    <span class="hljs-comment">// 如果thread不是 new 已经被启动 抛异常</span>
                    <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW){
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();
                    }
                    <span class="hljs-comment">// 将工作线程添加到HashSet中  统一管理  </span>
                    workers.add(w);
                    <span class="hljs-comment">// 工作线程添加成功</span>
                    workerAdded = <span class="hljs-literal">true</span>;
                    <span class="hljs-comment">// 获取工作线程个数，判断是否需要修改最大工作线程数记录【监控用】</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();
                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize){
                        largestPoolSize = s;
                    }
                }
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-comment">// finally 里解锁</span>
                mainLock.unlock();
            }
            <span class="hljs-keyword">if</span> (workerAdded) { <span class="hljs-comment">// 判断工作线程是否添加成功</span>
                <span class="hljs-comment">// 启动线程 实际是调用t.start 来启动线程</span>
                container.start(t);
                <span class="hljs-comment">// 线程启动成功</span>
                workerStarted = <span class="hljs-literal">true</span>;
            }
        }
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-comment">// 判断工作线程是否启动成功</span>
        <span class="hljs-keyword">if</span> (! workerStarted){
            <span class="hljs-comment">// 启动失败，走这 新增工作线程失败</span>
            addWorkerFailed(w);
        }
    }
    <span class="hljs-keyword">return</span> workerStarted;
}



<span class="hljs-comment">// Worker 继承了 AQS ，构造器如下</span>
Worker(Runnable firstTask) {
    setState(-<span class="hljs-number">1</span>); 
    <span class="hljs-built_in">this</span>.firstTask = firstTask;
    <span class="hljs-comment">// 线程工厂获取新线程</span>
    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);
}
</code></pre>
<p>shutDown的时候也会获取全局锁</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02fb4025a61a46e095b60001bc55fb4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo5a6I5Z-O6KeE:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734610&amp;x-signature=wHLKg%2B%2B7fD8hzid0uoF15F9hSsI%3D" alt="" loading="lazy"/></p>
<p>添加工作线程时，之所以要加锁，就是为了防止并发时，线程池的状态被修改</p>
<h2 data-id="heading-5">六、runWorker方法</h2>
<p>在addWorker时，在最终启动线程时，会调用t.start()方法，会执行 Worker里的run()方法，因为 Worker实现了 Runnable接口，重写了run方法，最终会走到worker里的run方法。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c558cab0fa4643b4ae88ed38d90afb57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo5a6I5Z-O6KeE:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734610&amp;x-signature=Vk4Khvv8J2uR3XRyFYZaK7OviS0%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> {
    <span class="hljs-comment">// 调用runWorker</span>
    runWorker(<span class="hljs-keyword">this</span>);
}
</code></pre>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// worker传进来的是this， 当前对象</span>
final void <span class="hljs-built_in">runWorker</span>(Worker w) {
    <span class="hljs-comment">// 拿到当前线程</span>
    Thread wt = Thread<span class="hljs-selector-class">.currentThread</span>();
    <span class="hljs-comment">// 拿到当前携带的第一个任务</span>
    Runnable task = w<span class="hljs-selector-class">.firstTask</span>;
    <span class="hljs-comment">// 将worker中的任务清空，避免重复执行</span>
    w<span class="hljs-selector-class">.firstTask</span> = null;
    w<span class="hljs-selector-class">.unlock</span>(); <span class="hljs-comment">// 解锁</span>
    <span class="hljs-comment">// 是否异常完成，默认为true 表示 任务执行异常</span>
    boolean completedAbruptly = true; 
    try {
        <span class="hljs-comment">// 这是一个循环，task不为空 或者 能从队列里拿到任务，就一直执行</span>
        while (task != null || (task = getTask()) != null) {
            <span class="hljs-comment">// 加锁开始执行 --&gt; 防止线程池停止时中断执行的任务</span>
            w<span class="hljs-selector-class">.lock</span>();
            <span class="hljs-comment">// 再来一个校验 ： 线程池状态至少是 Stop ，但是当前线程还没被中断  就得执行中断</span>
            <span class="hljs-comment">// 线程池 STop 状态，停止执行任何任务</span>
            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; <span class="hljs-built_in">runStateAtLeast</span>(ctl.get(), STOP))) &amp;&amp; !wt<span class="hljs-selector-class">.isInterrupted</span>())
                <span class="hljs-comment">// 当前线程要中断</span>
                wt<span class="hljs-selector-class">.interrupt</span>();
            try {
                <span class="hljs-comment">// 前置钩子 --&gt; 让自己实现</span>
                <span class="hljs-built_in">beforeExecute</span>(wt, task);
                try {
                    <span class="hljs-comment">// 执行任务</span>
                    task<span class="hljs-selector-class">.run</span>();

                    <span class="hljs-comment">// 后置钩子 --&gt; 让自己实现</span>
                    <span class="hljs-built_in">afterExecute</span>(task, null);
                } catch (Throwable ex) {
                    <span class="hljs-built_in">afterExecute</span>(task, ex);
                    throw ex;
                }
            } finally {
                task = null;
                <span class="hljs-comment">// 当前任务完成，就++ 统计完成了多少个任务</span>
                w<span class="hljs-selector-class">.completedTasks</span>++;
                <span class="hljs-comment">// 解锁</span>
                w<span class="hljs-selector-class">.unlock</span>();
            }
        }
        <span class="hljs-comment">// 是否出现异常完成 --&gt; false 正常完成</span>
        completedAbruptly = false;
    } finally {
        <span class="hljs-comment">// 执行线程退出</span>
        <span class="hljs-built_in">processWorkerExit</span>(w, completedAbruptly);
    }
}
</code></pre>
<p>线程池线程复用的关键也在这块：worker启动之后，会一直从队列里取任务，直到没有任务可取才会被销毁。</p>
<h2 data-id="heading-6">七、getTask()取任务</h2>
<p>再接着分析getTask从工作队列里取任务是怎么取的</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 是否超时</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; 

    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-comment">// 获取ctl值</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();

        <span class="hljs-comment">// 线程池状态至少为 ShutDown 并且队列已经空了</span>
        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)
            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
            <span class="hljs-comment">// 对工作线程个数减一</span>
            decrementWorkerCount();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-comment">// 获取工作线程个数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);

        <span class="hljs-comment">// 可超时回收标记：如果工作线程个数 大于 核心线程数 允许超时  --&gt; 说明是非核心线程</span>
        <span class="hljs-comment">// allowCoreThreadTimeOut --&gt; 默认false 允许核心线程数超时退出</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;

        <span class="hljs-comment">// 条件一：工作线程数 大于 最大线程数 或者 非核心线程超时了</span>
        <span class="hljs-comment">// 条件二：工作线程数大于 1 但是 队列空了</span>
        <span class="hljs-comment">// 两个条件同时满足</span>
        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) {
            <span class="hljs-comment">// 对工作线程数减一 直接return</span>
            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            <span class="hljs-comment">// CAS 失败，continue自旋</span>
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 根据time来判断是否可超时回收</span>
            <span class="hljs-comment">// 如果可以超时回收 ，就自己从队列里拉，等待keepAliveTime后仍无任务返回null</span>
            <span class="hljs-comment">// 不可超时回收，调用take，阻塞等待直到拿到任务（核心线程默认行为）</span>
            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();
            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>){
                <span class="hljs-comment">// 从队列里拿到任务 返回</span>
                <span class="hljs-keyword">return</span> r;
            }
            timedOut = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 超时没有拿到，标记为true 下次循环触发退出校验</span>
        } <span class="hljs-keyword">catch</span> (InterruptedException retry) {
            <span class="hljs-comment">// 捕获中断异常，中断不算超时，重置标记，重新循环尝试获取任务</span>
            timedOut = <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p>这个方法整体分为三大块：</p>
<p>一：线程池状态判断 和 任务队列是否为空判断 --&gt; 提前校验</p>
<p>二：判断是否可以超时回收：获取工作线程个数，判断是否是核心线程，核心线程不可超时回收，非核心线程可以超时回收</p>
<p>三：根据是否可以超时回收：非核心线程用poll拉 标记keepAliveTime ，到了时间还没拿到任务返回null。核心线程用take，阻塞等待，直到拿到任务</p>
<h2 data-id="heading-7">八、processWorkerExit执行线程退出</h2>
<pre><code class="hljs language-scss" lang="scss"> <span class="hljs-comment">// w --&gt; worker工作线程</span>
 <span class="hljs-comment">// completedAbruptly --&gt; false正常完成任务 true非正常完成任务</span>
 private void <span class="hljs-built_in">processWorkerExit</span>(Worker w, boolean completedAbruptly) {
        <span class="hljs-comment">// 判断是否正常完成任务</span>
        if (completedAbruptly){
            <span class="hljs-comment">// 非正常完成任务 工作线程数减一</span>
            <span class="hljs-built_in">decrementWorkerCount</span>();
        } 
            
        <span class="hljs-comment">// 获取全局锁</span>
        final ReentrantLock mainLock = this<span class="hljs-selector-class">.mainLock</span>;
        mainLock<span class="hljs-selector-class">.lock</span>();
        try {
            <span class="hljs-comment">// 统计累计完成的任务数</span>
            completedTaskCount += w<span class="hljs-selector-class">.completedTasks</span>;
            <span class="hljs-comment">// 从hashSet中移除掉worker </span>
            workers<span class="hljs-selector-class">.remove</span>(w);
        } finally {
            mainLock<span class="hljs-selector-class">.unlock</span>();
        }

        <span class="hljs-comment">// 尝试终止线程池，线程池状态是否发生变化</span>
        <span class="hljs-built_in">tryTerminate</span>();

        int c = ctl<span class="hljs-selector-class">.get</span>();
        <span class="hljs-comment">// 线程池的状态小于 Stop </span>
        if (runStateLessThan(c, STOP)) {
            <span class="hljs-comment">// 任务正常完成</span>
            if (!completedAbruptly) {
                <span class="hljs-comment">// 判断 队列是否为空，如果队列不为空，判断工作线程是否大于等于 1 如果还有工作线程直接return</span>
                int min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize; <span class="hljs-comment">// 如果核心线程可以超时，那么整个线程池就没有线程可用</span>
                if (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())
                    min = <span class="hljs-number">1</span>;
                if (workerCountOf(c) &gt;= min) <span class="hljs-comment">// 如果还有核心线程在阻塞，直接return</span>
                    return; 
            }
            <span class="hljs-comment">// 如果工作线程为空</span>
            <span class="hljs-comment">// 添加一个非核心空任务的线程来处理队列里的任务</span>
            <span class="hljs-built_in">addWorker</span>(null, false);
        }
}
</code></pre>
<p>线程退出这里分为两大部分：</p>
<p>部分一：从维护的全局 HashSet里移除掉worker + 尝试终止线程池</p>
<p>部分二：线程池的状态如果是 Running/ShutDown，判断任务队列是否为空，不为空，核心线程在阻塞着，return，用核心线程处理，工作线程数为空，添加一个空任务的非核心线程去处理队列里的任务</p>
<h2 data-id="heading-8">九、拒绝策略</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ecd73aae31df4aa1bd86a0f500a71dca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo5a6I5Z-O6KeE:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734610&amp;x-signature=zYXdX4vUMn%2FX%2B6nQJWA%2BeQAhU6U%3D" alt="" loading="lazy"/></p>
<p>就这四个拒绝策略</p>
<h3 data-id="heading-9">9.1、AbortPolicy</h3>
<p>抛出异常</p>
<pre><code class="hljs language-java" lang="java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> {
        <span class="hljs-comment">/**
         * Creates an {<span class="hljs-doctag">@code</span> AbortPolicy}.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> { }

        <span class="hljs-comment">/**
         * Always throws RejectedExecutionException.
         *
         * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed
         * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task
         * <span class="hljs-doctag">@throws</span> RejectedExecutionException always
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">"Task "</span> + r.toString() +
                                                 <span class="hljs-string">" rejected from "</span> +
                                                 e.toString());
        }
    }
</code></pre>
<h3 data-id="heading-10">9.2、DiscardPolicy</h3>
<p>什么也不做，也不抛出异常</p>
<pre><code class="hljs language-java" lang="java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> {
        <span class="hljs-comment">/**
         * Creates a {<span class="hljs-doctag">@code</span> DiscardPolicy}.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> { }

        <span class="hljs-comment">/**
         * Does nothing, which has the effect of discarding task r.
         *
         * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed
         * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> {
        }
    }
</code></pre>
<h3 data-id="heading-11">9.3、DiscardOldestPolicy</h3>
<p>从队列里边扔出一个，把当前任务给执行掉</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> {
        <span class="hljs-comment">/**
         * Creates a {<span class="hljs-doctag">@code</span> DiscardOldestPolicy} for the given executor.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> { }

        <span class="hljs-comment">/**
         * Obtains and ignores the next task that the executor
         * would otherwise execute, if one is immediately available,
         * and then retries execution of task r, unless the executor
         * is shut down, in which case task r is instead discarded.
         *
         * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed
         * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> {
            <span class="hljs-keyword">if</span> (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
        }
    }
</code></pre>
<h3 data-id="heading-12">9.4、CallerRunsPolicy</h3>
<p>谁提交谁执行</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> {
        <span class="hljs-comment">/**
         * Creates a {<span class="hljs-doctag">@code</span> CallerRunsPolicy}.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> { }

        <span class="hljs-comment">/**
         * Executes task r in the caller's thread, unless the executor
         * has been shut down, in which case the task is discarded.
         *
         * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed
         * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> {
            <span class="hljs-keyword">if</span> (!e.isShutdown()) {
                r.run();
            }
        }
    }
</code></pre>
<h2 data-id="heading-13">十、总结</h2>
<p>线程池的源码看完还是很混乱，里面有太多的线程池状态判断以及 Double Check，影响主思路的梳理，现在写一下核心流程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3692896823434e62a9a54347217c26df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo5a6I5Z-O6KeE:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734610&amp;x-signature=PxUNqWkiopMoqHl0XWDEBGemDD4%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Gemini 3.0 科普：Google 这次把 AI 做成“能看懂世界的助手”了]]></title>    <link>https://juejin.cn/post/7585145251843784719</link>    <guid>https://juejin.cn/post/7585145251843784719</guid>    <pubDate>2025-12-19T07:37:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585145251843784719" data-draft-id="7585206349748518964" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Gemini 3.0 科普：Google 这次把 AI 做成“能看懂世界的助手”了"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-12-19T07:37:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="智见AGI"/> <meta itemprop="url" content="https://juejin.cn/user/4145611877132986"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Gemini 3.0 科普：Google 这次把 AI 做成“能看懂世界的助手”了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4145611877132986/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    智见AGI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:37:21.000Z" title="Fri Dec 19 2025 07:37:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>欢迎来到我们的</strong> <strong>「每周技术加速器」</strong> <strong>专栏！</strong></p>
<p>每周五，我们都会围绕一个前沿技术主题，展开一场深度的内部技术分享会。不仅是为了团队内部的碰撞与成长，也希望通过这样的形式，将我们的思考与实践记录、沉淀、分享给更多同行者。</p>
<p>今天，我们就用最简单的语言，带你读懂—— <strong>Gemini 为什么越来越像一个“能观察、能分析、能帮你解决问题”的数字伙伴？</strong></p>
<p>从在我们本期技术分享会上，分享人Zhongmei用一种很朴素的方式解释了 Gemini 3.0 的本质：</p>
<p>“它的目标不是像人，而是能帮我们理解这个世界。”</p>
<p>这句话其实把 Google 做 Gemini 的原因说得非常清楚。</p>
<p><strong>AI 不是只能聊天，它正在学会“看、听、理解世界”</strong></p>
<p>大多数人接触 AI，是从聊天开始的：问 ChatGPT 写文案、写代码、翻译、查资料。</p>
<p>但 Gemini 从第一代开始就不一样，它的目标是：</p>
<p> 让 AI 像人一样拥有多种感官。</p>
<p>比如它能同时处理：</p>
<ul>
<li>一张图</li>
</ul>

<ul>
<li>一个视频</li>
</ul>

<ul>
<li>一段录音</li>
</ul>

<ul>
<li>一份文档</li>
</ul>

<ul>
<li>一段代码</li>
</ul>
<p>就像一个真正“在看世界”的系统。</p>
<p>这也是为什么大家说 Gemini 比较擅长：</p>
<ul>
<li>看图理解内容</li>
</ul>

<ul>
<li>看视频分析事件</li>
</ul>

<ul>
<li>看手机界面推断页面逻辑</li>
</ul>
<p>因为它不是把图当成“图片”，而是当成“一个有逻辑的场景”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/760342e3976f43c28ec8212a1c99f6da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm66KeBQUdJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734640&amp;x-signature=GPYQG3OKF8wLCYKLWniiMJm5Sss%3D" alt="图片" loading="lazy"/></p>
<p>Gemini 3.0在多模态推理任务上的表现对比</p>
<p><strong>那么 Gemini 3.0 具体强在哪里？</strong></p>
<p>不讲概念，我们直接看它最实用的能力：</p>
<p><strong>① 它看图更像“在观察”而不是“识别”</strong></p>
<p>举个例子：</p>
<p>你给它一张手机界面截图，它不仅能读出文字，还能“看懂结构”：</p>
<ul>
<li>哪些是按钮</li>
</ul>

<ul>
<li>哪些是输入框</li>
</ul>

<ul>
<li>页面信息是怎么组织的</li>
</ul>

<ul>
<li>大概能操作哪些功能</li>
</ul>

<ul>
<li>页面之间如何跳转</li>
</ul>
<p>这就像是让 AI 变成了“懂界面的助手”。</p>
<p>对于普通人来说，这意味着：</p>
<ul>
<li>PDF 不用自己找重点</li>
</ul>

<ul>
<li>软件界面能自动说明</li>
</ul>

<ul>
<li>表格、截图都能自动归纳</li>
</ul>
<p>AI 不再只是识别，而是理解。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/69f0772f6aed4d2e879f5bc9c7e1d210~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm66KeBQUdJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734640&amp;x-signature=iBOEsxldM6rRbHFpfAfTML9c2QA%3D" alt="图片" loading="lazy"/></p>
<p>Gemini 原生多模态架构</p>
<p><strong>② 它会把长任务拆成小步骤，一步步做</strong></p>
<p>以前让 AI 做复杂任务，经常出现：</p>
<ul>
<li>说一半忘一半</li>
</ul>

<ul>
<li>逻辑跳过某些步骤</li>
</ul>

<ul>
<li>越写越不对劲</li>
</ul>
<p>Gemini 3.0 改进了逻辑链条，更像在“推理”：</p>
<ul>
<li>我先理解需求</li>
</ul>

<ul>
<li>再拆成步骤</li>
</ul>

<ul>
<li>再逐步执行</li>
</ul>
<p>这对普通人来说意味着：</p>
<p>即使你只能描述一个模糊的目标，它也能帮你从 0 到 1 梳理思路。</p>
<p>比如：</p>
<p>“我想做个旅游计划，但我不知道怎么开始。”</p>
<p>Gemini 会帮你：</p>
<p> 路线 → 时间 →预算 → 风格 → 行程图 → 注意事项，一次搞定。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50ac80dcb2b142808abf966dd69c024a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm66KeBQUdJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734640&amp;x-signature=L6B6Yq9vCVUbFqesGteifuLK%2FxM%3D" alt="图片" loading="lazy"/></p>
<p>Gemini 3.0升级的内部规划层，专为处理复杂任务而设计。</p>
<p><strong>③ 它能一次理解非常长的内容</strong></p>
<p>Gemini 能一次“读”的内容量非常大——相当于：</p>
<ul>
<li>一份几十页方案</li>
</ul>

<ul>
<li>一本厚厚的 PDF</li>
</ul>

<ul>
<li>几十页代码</li>
</ul>

<ul>
<li>一个长视频的全部字幕</li>
</ul>
<p>对于普通用户来说：</p>
<ul>
<li>报告不用自己看完</li>
</ul>

<ul>
<li>项目需求它能全部记住</li>
</ul>

<ul>
<li>长文章能精确提炼</li>
</ul>

<ul>
<li>网课视频能提纲挈领</li>
</ul>
<p>你一句话：“帮我总结这本书。”它真的能一次读完并总结。</p>
<p><strong>用最简单的方式解释 Gemini 的三代进化</strong></p>
<p>我们用人类成长来比喻：</p>
<p><strong>🍼 Gemini 1.0：婴儿 → 学会“看世界”</strong></p>
<ul>
<li>能“看图”“看视频”，但理解不深。</li>
</ul>

<ul>
<li>算是刚有“感官”。</li>
</ul>
<p><strong>🧒 Gemini 2.0 – 2.5：少年 → 开始“会思考”</strong></p>
<ul>
<li>能听懂你说话</li>
</ul>

<ul>
<li>能分析问题</li>
</ul>

<ul>
<li>遇到难题先想再答</li>
</ul>
<p>这时候它开始有“推理”。</p>
<p><strong>🧑‍🎓 Gemini 3.0：青年 → 开始“能独立做事”</strong></p>
<ul>
<li>看到复杂内容不会乱</li>
</ul>

<ul>
<li>遇到长任务能拆解</li>
</ul>

<ul>
<li>看图、视频和文字能一起理解</li>
</ul>
<p>已经开始像一个“能帮你办事”的数字助手了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e7dc81cfd194ada827098c39d2050ce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm66KeBQUdJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734640&amp;x-signature=EE%2FU%2Fcv6dFC2IQALzKoISuVeLnc%3D" alt="图片" loading="lazy"/></p>
<p>Gemini系列技术演进历程</p>
<p><strong>那它和 ChatGPT 有什么区别？</strong></p>
<p>这是大家最关心的问题，我们不从技术说，从“性格”说。</p>
<p>你可以这样理解：</p>
<p>ChatGPT → 稳在流畅、靠谱、听指挥</p>
<p>让它写文案、查资料、做任务，它总能稳稳接住。更像一个 “可靠的万能助手”。</p>
<p>Gemini → 擅长观察、理解、分析</p>
<p>给它图、视频、网页，它能看得很透。更像一个“会分析的助手”。</p>
<p>两者不是“谁强谁弱”，而是“性格不同、擅长点不同”。</p>
<p>未来这两条路可能会越走越近，但目前差异还是明显的。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc43344b6eb6412faee23ce5e00b4582~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pm66KeBQUdJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734640&amp;x-signature=5RQJhnRd%2Fu5yyJ32PlVtuidHUDY%3D" alt="图片" loading="lazy"/></p>
<p>Gemini与ChatGPT的理念差异对比</p>
<p><strong>普通人需要记住的就这三句话：</strong></p>
<p>为了让你更轻松理解，我们用三句最简单的话做人类级总结：</p>
<p><strong>① Gemini 是从“能聊天”进化到“能看懂世界”。</strong></p>
<p>这是它最大的本质差别。</p>
<p><strong>② 它更擅长分析结构、拆解任务、理解图文视频。</strong></p>
<p>适合复杂问题。</p>
<p><strong>③ 它不是单纯变大，而是变得更聪明、更稳定。</strong></p>
<p><strong>未来它能帮我们做什么？（更实际的部分）</strong></p>
<p>这是最值得期待的地方。</p>
<p>普通人可能用它做：</p>
<ul>
<li>看懂报表、文件、PPT</li>
</ul>

<ul>
<li>自动总结视频内容</li>
</ul>

<ul>
<li>软件界面自动讲解</li>
</ul>

<ul>
<li>帮忙规划旅行、活动</li>
</ul>

<ul>
<li>解释截图、图片里的信息</li>
</ul>

<ul>
<li>把一堆资料整理成一套学习笔记</li>
</ul>
<p>对于职场人，它可能成为：</p>
<ul>
<li>你的“分析伙伴”</li>
</ul>

<ul>
<li>你的“文档阅读器”</li>
</ul>

<ul>
<li>你的“信息整理器”</li>
</ul>

<ul>
<li>你的“学习助手”</li>
</ul>
<p>未来 AI 的形态，可能会是一种能观察、能分析、能行动的智能工具，而 Gemini 正朝这个方向走。</p>
<p><strong>结语：AI 的下一步，不是更快，而是更懂</strong></p>
<p>Gemini 3.0 的意义不在于“变得更厉害”，而在于：它让我们看到 AI 开始像一个“能观察世界、能弄清楚问题、能帮我们做事”的系统。</p>
<p>这也是我们这次技术分享最宝贵的部分：AI 不再只是会聊天，而开始具备理解世界的能力。</p>
<p>未来我们还会在技术分享会中持续解读更多最新模型，用最易懂的方式让普通读者也能跟上 AI 技术的脚步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Golang-Data race【AI总结版】]]></title>    <link>https://juejin.cn/post/7585146584893571122</link>    <guid>https://juejin.cn/post/7585146584893571122</guid>    <pubDate>2025-12-19T07:38:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585146584893571122" data-draft-id="7585146584893554738" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Golang-Data race【AI总结版】"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-19T07:38:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="whoops本尊"/> <meta itemprop="url" content="https://juejin.cn/user/712139267381639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Golang-Data race【AI总结版】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139267381639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    whoops本尊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:38:51.000Z" title="Fri Dec 19 2025 07:38:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Data Race的定义</h2>
<p>Data race发生在多个goroutine并发访问同一内存地址，且至少有一个是写操作，且没有使用同步机制（如mutex、channel、atomic操作）。</p>
<h2 data-id="heading-1">具体危害场景</h2>
<h3 data-id="heading-2">1. <strong>空指针异常（Nil Pointer Dereference）</strong></h3>
<p><strong>场景：</strong>  一个goroutine正在初始化指针，另一个goroutine同时读取该指针。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> {
    Data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>
}

<span class="hljs-keyword">var</span> config *Config

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initConfig</span><span class="hljs-params">()</span></span> {
    config = &amp;Config{
        Data: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>),
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getValue</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> {
    <span class="hljs-comment">// DATA RACE: 此时config可能为nil或部分初始化</span>
    <span class="hljs-keyword">if</span> config != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> config.Data[key] <span class="hljs-comment">// 可能触发空指针：config不为nil，但Data可能未初始化</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
}

<span class="hljs-comment">// 并发调用：一个goroutine执行initConfig，另一个执行getValue</span>
</code></pre>
<p><strong>问题：</strong>  由于指令重排和内存可见性问题，<code>config</code>指针可能已经非nil，但内部结构<code>Data</code>仍为nil。</p>
<h3 data-id="heading-3">2. <strong>内存损坏与程序崩溃</strong></h3>
<p><strong>场景：</strong>  并发读写slice或map。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 场景1: Slice并发修改</span>
<span class="hljs-keyword">var</span> data []<span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendData</span><span class="hljs-params">()</span></span> {
    data = <span class="hljs-built_in">append</span>(data, <span class="hljs-number">1</span>) <span class="hljs-comment">// 可能触发slice重新分配内存</span>
}

<span class="hljs-comment">// 并发调用appendData可能导致：</span>
<span class="hljs-comment">// - slice底层数组并发修改</span>
<span class="hljs-comment">// - 访问已释放的内存</span>
<span class="hljs-comment">// - 程序直接崩溃（segmentation fault）</span>

<span class="hljs-comment">// 场景2: Map并发读写（非sync.Map）</span>
m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { m[<span class="hljs-string">"a"</span>] = <span class="hljs-number">1</span> }() <span class="hljs-comment">// 写</span>
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { _ = m[<span class="hljs-string">"a"</span>] }() <span class="hljs-comment">// 读</span>
<span class="hljs-comment">// 可能导致fatal error: concurrent map read and map write</span>
</code></pre>
<h3 data-id="heading-4">3. <strong>逻辑错误与不一致状态</strong></h3>
<p><strong>场景：</strong>  计数器或状态标志的竞争。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> counter <span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> {
    counter++ <span class="hljs-comment">// 非原子操作：实际是读取-修改-写入三步</span>
    <span class="hljs-comment">// 多个goroutine可能读取相同的旧值，导致最终计数小于预期</span>
}

<span class="hljs-comment">// 典型结果：1000个goroutine各增加1次，counter可能只有几百</span>
</code></pre>
<h3 data-id="heading-5">4. <strong>死锁或活锁</strong></h3>
<p><strong>场景：</strong>  竞争条件引发的同步问题。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> ready <span class="hljs-type">bool</span>
<span class="hljs-keyword">var</span> mu sync.Mutex

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> {
    mu.Lock()
    <span class="hljs-keyword">if</span> !ready {
        mu.Unlock()
        <span class="hljs-comment">// 这里ready可能被其他goroutine修改</span>
        time.Sleep(time.Millisecond)
        <span class="hljs-comment">// 重新检查时逻辑可能已失效</span>
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 data-id="heading-6">5. <strong>内存泄漏</strong></h3>
<p><strong>场景：</strong>  竞争导致资源无法正确释放。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> resource *Resource
<span class="hljs-keyword">var</span> inUse <span class="hljs-type">bool</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> !inUse {
        freeResource(resource) <span class="hljs-comment">// 可能在其他goroutine正在使用时释放</span>
    }
}
</code></pre>
<h3 data-id="heading-7">6. <strong>指令重排导致的意外行为</strong></h3>
<p>由于编译器和CPU的优化，代码执行顺序可能与编写顺序不同：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> {
    x = <span class="hljs-number">1</span>
    y = <span class="hljs-number">2</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> {
    a := y
    b := x
    <span class="hljs-comment">// 可能观察到 y=2, x=0（尽管在单线程中x=1一定在y=2之前执行）</span>
}
</code></pre>
<h2 data-id="heading-8">检测与预防措施</h2>
<h3 data-id="heading-9">1. <strong>使用Race Detector</strong></h3>
<pre><code class="hljs language-bash" lang="bash">go run -race main.go
go <span class="hljs-built_in">test</span> -race ./...
</code></pre>
<h3 data-id="heading-10">2. <strong>正确的同步机制</strong></h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 使用Mutex</span>
<span class="hljs-keyword">var</span> mu sync.RWMutex
<span class="hljs-keyword">var</span> data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>

<span class="hljs-comment">// 使用Atomic（适用于简单值）</span>
<span class="hljs-keyword">var</span> count <span class="hljs-type">int64</span>
atomic.AddInt64(&amp;count, <span class="hljs-number">1</span>)

<span class="hljs-comment">// 使用Channel传递所有权</span>
ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Data, <span class="hljs-number">1</span>)
ch &lt;- data <span class="hljs-comment">// 发送者放弃所有权</span>
received := &lt;-ch <span class="hljs-comment">// 接收者获得所有权</span>

<span class="hljs-comment">// 使用sync.Map</span>
<span class="hljs-keyword">var</span> syncMap sync.Map
</code></pre>
<h3 data-id="heading-11">3. <strong>遵循的原则</strong></h3>
<ul>
<li><strong>不要通过共享内存来通信，通过通信来共享内存</strong></li>
<li>尽量将数据限制在单个goroutine中</li>
<li>使用复制或不可变数据</li>
<li>明确所有权转移</li>
</ul>
<h2 data-id="heading-12">典型案例分析</h2>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 危险：共享指针的竞争</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-type">string</span>
}

<span class="hljs-keyword">var</span> currentUser *User

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 部分初始化</span>
    u := &amp;User{}
    currentUser = u <span class="hljs-comment">// 其他goroutine可能看到部分初始化的对象</span>
    u.Name = <span class="hljs-string">"John"</span> <span class="hljs-comment">// 指令重排可能使这行在赋值之后执行</span>
}

<span class="hljs-comment">// 安全方案1：使用mutex保护</span>
<span class="hljs-keyword">var</span> (
    userMu sync.RWMutex
    safeUser *User
)

<span class="hljs-comment">// 安全方案2：通过channel传递完整对象</span>
userChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *User, <span class="hljs-number">1</span>)
</code></pre>
<h2 data-id="heading-13">总结</h2>
<p>Data race在Go中是<strong>未定义行为</strong>（undefined behavior），可能导致：</p>
<ol>
<li><strong>空指针异常</strong> - 最常见的问题之一</li>
<li><strong>内存损坏和程序崩溃</strong> - 最严重的后果</li>
<li><strong>逻辑错误</strong> - 最难调试的问题</li>
<li><strong>安全漏洞</strong> - 在安全关键系统中尤其危险</li>
</ol>
<p><strong>最佳实践</strong>：始终使用race detector进行测试，设计时考虑数据所有权，优先使用channel通信，必要时使用合适的同步原语。记住：Go中的并发错误往往在低负载时潜伏，在高并发时爆发。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【SpringBoot3】Spring Boot 3.0 集成 Mybatis Plus]]></title>    <link>https://juejin.cn/post/7585222924565807144</link>    <guid>https://juejin.cn/post/7585222924565807144</guid>    <pubDate>2025-12-19T07:40:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585222924565807144" data-draft-id="7585222924565790760" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【SpringBoot3】Spring Boot 3.0 集成 Mybatis Plus"/> <meta itemprop="keywords" content="后端,Spring Boot"/> <meta itemprop="datePublished" content="2025-12-19T07:40:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【SpringBoot3】Spring Boot 3.0 集成 Mybatis Plus
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:40:26.000Z" title="Fri Dec 19 2025 07:40:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">一、什么是 Mybatis Plus</h4>
<p>[MyBatis-Plus]（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h5 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>特性</h5>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h4 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>二、Spring Boot 3.0 集成 Mybatis Plus</h4>
<p><strong>1、 添加依赖</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- mybatis plus --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码
1234567891011121314151617181920
</code></pre>
<blockquote>
<p><strong>注意：</strong>  SpringBoot 3.0 需要 mybatis-spring 3.0.X 版本，否则会报如下错误：<br/>
<code>Invalid value type for attribute 'factoryBeanObjectType'‘': java.lang.String</code></p>
</blockquote>
<p><strong>2、配置数据源</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># druid 数据源配置</span>
<span class="hljs-attr">spring.datasource.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/your_db?useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf-<span class="hljs-number">8</span>&amp;allowMultiQueries=<span class="hljs-literal">true</span>&amp;useSSL=<span class="hljs-literal">false</span>&amp;serverTimezone=Asia/Shanghai
<span class="hljs-attr">spring.datasource.username</span>=root
<span class="hljs-attr">spring.datasource.password</span>=password
<span class="hljs-attr">spring.datasource.driver-class-name</span>=com.mysql.cj.jdbc.Driver
<span class="hljs-attr">spring.datasource.type</span>=com.alibaba.druid.pool.DruidDataSource
<span class="hljs-comment"># 初始化大小，最小，最大</span>
<span class="hljs-attr">spring.datasource.druid.initial-size</span>=<span class="hljs-number">5</span>
<span class="hljs-attr">spring.datasource.druid.min-idle</span>=<span class="hljs-number">5</span>
<span class="hljs-attr">spring.datasource.druid.maxActive</span>=<span class="hljs-number">20</span>
<span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span>
<span class="hljs-attr">spring.datasource.druid.timeBetweenEvictionRunsMillis</span>=<span class="hljs-number">60000</span>
<span class="hljs-comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span>
<span class="hljs-attr">spring.datasource.druid.minEvictableIdleTimeMillis</span>=<span class="hljs-number">300000</span>
<span class="hljs-attr">spring.datasource.druid.validationQuery</span>=SELECT <span class="hljs-number">1</span>
<span class="hljs-attr">spring.datasource.druid.testWhileIdle</span>=<span class="hljs-literal">true</span>
<span class="hljs-attr">spring.datasource.druid.testOnBorrow</span>=<span class="hljs-literal">false</span>
<span class="hljs-attr">spring.datasource.druid.testOnReturn</span>=<span class="hljs-literal">false</span>
<span class="hljs-attr">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="hljs-literal">true</span>
<span class="hljs-attr">spring.datasource.druid.web-stat-filter.enabled</span>=<span class="hljs-literal">true</span>
<span class="hljs-attr">spring.datasource.druid.web-stat-filter.url-pattern</span>=/druid/*
<span class="hljs-attr">spring.datasource.druid.filters</span>=stat,wall,slf4j
<span class="hljs-attr">spring.datasource.druid.connectionProperties</span>=druid.stat.mergeSql=<span class="hljs-literal">true</span><span class="hljs-comment">;druid.stat.slowSqlMillis=5000</span>

<span class="hljs-comment"># --- mybatis-plus start</span>
<span class="hljs-attr">mybatis-plus.mapper-locations</span>=classpath:/org/shi9/module/**/xml/*Mapper.xml
<span class="hljs-comment"># 关闭MP3.0自带的banner</span>
<span class="hljs-attr">mybatis-plus.global-config.banner</span>=<span class="hljs-literal">false</span>
<span class="hljs-comment"># 主键类型  0:"数据库ID自增",1:"该类型为未设置主键类型", 2:"用户输入ID",3:"全局唯一ID (数字类型唯一ID)", 4:"全局唯一ID UUID",5:"字符串全局唯一ID (idWorker 的字符串表示)";</span>
<span class="hljs-attr">mybatis-plus.global-config.db-config.id-type</span>=ASSIGN_ID
<span class="hljs-comment"># 返回类型为Map,显示null对应的字段</span>
<span class="hljs-attr">mybatis-plus.configuration.call-setters-on-nulls</span>=<span class="hljs-literal">true</span>
<span class="hljs-comment"># 这个配置会将执行的sql打印出来，在开发或测试的时候可以用</span>
<span class="hljs-attr">mybatis-plus.configuration.log-impl</span>=org.apache.ibatis.logging.stdout.StdOutImpl
<span class="hljs-comment"># --- mybatis-plus end</span>

AI写代码
1234567891011121314151617181920212223242526272829303132333435
</code></pre>
<p><strong>3、创建实体类和 Mapper</strong></p>
<p>创建你的实体类和对应的 Mapper 接口。MyBatis Plus 会自动扫描这些类并为你生成相应的 Mapper 和 SQL 语句。你也可以使用 MyBatis Plus 的 CRUD 操作来简化开发。</p>
<p>这里以<code>SysLog</code>为例</p>
<p>SysLogMapper.xml</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"org.shi9.module.system.mapper.SysLogMapper"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>

AI写代码
1234
</code></pre>
<p>SysLogMapper.java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SysLogMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;SysLog&gt; {
    
}

AI写代码
<span class="hljs-number">1234</span>
</code></pre>
<p><strong>4、编写 Service 类</strong></p>
<pre><code class="hljs language-scala" lang="scala">public interface <span class="hljs-type">ISysLogService</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">IService</span>&lt;<span class="hljs-type">SysLog</span>&gt; {
    
}

<span class="hljs-meta">@Service</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;SysLogMapper</span>, <span class="hljs-title">SysLog&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">ISysLogService</span> </span>{
    
}

<span class="hljs-type">AI</span>写代码
<span class="hljs-number">12345678</span>
</code></pre>
<p><strong>5、编写测试类</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Slf4j</span>
<span class="hljs-variable">@SpringBootTest</span>
public class SysLogServiceTest {
    <span class="hljs-variable">@Autowired</span>
    private ISysLogService sysLogService;

    <span class="hljs-variable">@Test</span>
    public void <span class="hljs-built_in">findTotal</span>(){
        <span class="hljs-selector-tag">Long</span> <span class="hljs-selector-tag">total</span> = <span class="hljs-selector-tag">sysLogService</span><span class="hljs-selector-class">.count</span>();
        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(total);
    }
}

<span class="hljs-selector-tag">AI</span>写代码
<span class="hljs-number">123456789101112</span>
</code></pre>
<h4 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>三、Mybatis Plus 查询示例</h4>
<h5 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1、普通查询</h5>
<p>以下是使用 MyBatis Plus 进行查询的示例：</p>
<ol>
<li><strong>根据主键查询单个结果</strong></li>
</ol>
<p>使用 <code>selectById</code> 方法查询单个结果：</p>
<pre><code class="hljs language-ini" lang="ini">User <span class="hljs-attr">user</span> = userMapper.selectById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>

AI写代码
1
</code></pre>
<ol start="2">
<li><strong>查询多条记录</strong></li>
</ol>
<p>使用 <code>selectList</code> 方法查询多条记录：</p>
<pre><code class="hljs language-ini" lang="ini">List&lt;User&gt; <span class="hljs-attr">users</span> = userMapper.selectList(null)<span class="hljs-comment">;</span>

AI写代码
1
</code></pre>
<ol start="3">
<li><strong>使用 QueryWrapper 进行查询</strong></li>
</ol>
<p>可以使用 <code>QueryWrapper</code> 对查询条件进行组装：</p>
<pre><code class="hljs language-ini" lang="ini">QueryWrapper&lt;User&gt; <span class="hljs-attr">queryWrapper</span> = new QueryWrapper&lt;&gt;()<span class="hljs-comment">;</span>
queryWrapper.eq("name", "John").lt("age", 30)<span class="hljs-comment">;</span>
List&lt;User&gt; <span class="hljs-attr">userList</span> = userMapper.selectList(queryWrapper)<span class="hljs-comment">;</span>

AI写代码
123
</code></pre>
<ol start="4">
<li><strong>分页查询</strong></li>
</ol>
<p>使用 <code>Page</code> 类进行分页查询：</p>
<pre><code class="hljs language-ini" lang="ini">Page&lt;User&gt; <span class="hljs-attr">page</span> = new Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">; // 第1页，每页显示10条记录</span>
QueryWrapper&lt;User&gt; <span class="hljs-attr">queryWrapper</span> = new QueryWrapper&lt;&gt;()<span class="hljs-comment">;</span>
queryWrapper.eq("name", "John")<span class="hljs-comment">;</span>
page.setFilter(queryWrapper)<span class="hljs-comment">;</span>
Page&lt;User&gt; <span class="hljs-attr">result</span> = userMapper.selectPage(page, null)<span class="hljs-comment">;</span>

AI写代码
12345
</code></pre>
<ol start="5">
<li><strong>模糊查询</strong></li>
</ol>
<p>使用 <code>like</code> 方法进行模糊查询：</p>
<pre><code class="hljs language-ini" lang="ini">QueryWrapper&lt;User&gt; <span class="hljs-attr">queryWrapper</span> = new QueryWrapper&lt;&gt;()<span class="hljs-comment">;</span>
queryWrapper.like("name", "Jo")<span class="hljs-comment">;</span>
List&lt;User&gt; <span class="hljs-attr">userList</span> = userMapper.selectList(queryWrapper)<span class="hljs-comment">;</span>

AI写代码
123
</code></pre>
<ol start="6">
<li><strong>排序查询</strong></li>
</ol>
<p>使用 <code>orderBy</code> 方法进行排序查询：</p>
<pre><code class="hljs language-ini" lang="ini">QueryWrapper&lt;User&gt; <span class="hljs-attr">queryWrapper</span> = new QueryWrapper&lt;&gt;()<span class="hljs-comment">;</span>
queryWrapper.orderByDesc("age")<span class="hljs-comment">;</span>
List&lt;User&gt; <span class="hljs-attr">userList</span> = userMapper.selectList(queryWrapper)<span class="hljs-comment">;</span>

AI写代码
123
</code></pre>
<ol start="7">
<li><strong>聚合查询</strong></li>
</ol>
<p>使用 <code>groupBy</code> 和 <code>sum</code>、<code>count</code> 等方法进行聚合查询：</p>
<pre><code class="hljs language-ini" lang="ini">QueryWrapper&lt;User&gt; <span class="hljs-attr">queryWrapper</span> = new QueryWrapper&lt;&gt;()<span class="hljs-comment">;</span>
queryWrapper.groupBy("age")<span class="hljs-comment">;</span>
Long <span class="hljs-attr">totalCount</span> = userMapper.selectSum(queryWrapper, <span class="hljs-string">"age"</span>)<span class="hljs-comment">;</span>

AI写代码
123
</code></pre>
<ol start="8">
<li><strong>自定义 SQL</strong></li>
</ol>
<p>使用 <code>@Select</code> 注解自定义 SQL 语句：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Select</span>(<span class="hljs-string">"SELECT * FROM user WHERE age &gt; #{age}"</span>)
List&lt;User&gt; <span class="hljs-built_in">selectUsersByAge</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">"age"</span>) Integer age);

<span class="hljs-selector-tag">AI</span>写代码
<span class="hljs-number">12</span>
</code></pre>
<p>这些示例只是 MyBatis Plus 提供的一些常见查询方法的冰山一角。MyBatis Plus 还提供了很多其他功能和扩展，可以根据需要进行配置和使用。同时，MyBatis Plus 还支持与其他组件的集成，例如分页插件、乐观锁插件等，可以帮助你更加高效地进行数据库操作。</p>
<h5 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2、分页查询</h5>
<p>MyBatis Plus 支持分页功能，可以通过配置分页插件来实现。分页插件可以帮助我们自动处理分页相关的 SQL 语句，简化分页逻辑。以下是使用分页插件的步骤：</p>
<p><strong>1、配置分页插件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> {
    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();
    <span class="hljs-comment">// 配置分页插件</span>
    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());
    <span class="hljs-comment">// 增加@Version乐观锁支持</span>
    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>());
    <span class="hljs-keyword">return</span> interceptor;
}

AI写代码
<span class="hljs-number">123456789</span>
</code></pre>
<p><strong>2. 使用分页插件</strong></p>
<p>在 Mapper 接口或 XML 映射文件中使用分页插件提供的查询方法进行分页查询。例如：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Select</span>(<span class="hljs-string">"SELECT * FROM user WHERE 1=1"</span>)
Page&lt;User&gt; <span class="hljs-built_in">selectUserPage</span>(Page&lt;User&gt; page);

<span class="hljs-selector-tag">AI</span>写代码
<span class="hljs-number">12</span>
</code></pre>
<p>在查询方法上使用 <code>Page</code> 参数，MyBatis Plus 会自动处理分页相关的 SQL 语句，返回包含分页信息的 <code>Page</code> 对象。你可以根据需要配置查询条件、排序规则等。</p>
<p><strong>3. 处理分页结果</strong></p>
<p>根据返回的 <code>Page</code> 对象，你可以获取当前页的数据、总记录数、总页数等信息，进行相应的业务处理。例如：</p>
<pre><code class="hljs language-ini" lang="ini">Page&lt;User&gt; <span class="hljs-attr">page</span> = userMapper.selectUserPage(new Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<span class="hljs-comment">; // 第1页，每页显示10条记录</span>
List&lt;User&gt; <span class="hljs-attr">userList</span> = page.getRecords()<span class="hljs-comment">; // 当前页的数据列表</span>
int <span class="hljs-attr">totalCount</span> = page.getTotal()<span class="hljs-comment">; // 总记录数</span>
int <span class="hljs-attr">totalPage</span> = page.getPages()<span class="hljs-comment">; // 总页数</span>

AI写代码
1234
</code></pre>
<p>通过这些步骤，你可以在 MyBatis Plus 中配置和使用分页插件，简化分页逻辑，提高开发效率。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深拷贝 structuredClone 与 JSON 方法作用及比较]]></title>    <link>https://juejin.cn/post/7585406229151465510</link>    <guid>https://juejin.cn/post/7585406229151465510</guid>    <pubDate>2025-12-19T07:36:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585406229151465510" data-draft-id="7585146584893538354" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深拷贝 structuredClone 与 JSON 方法作用及比较"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T07:36:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="DEMO派"/> <meta itemprop="url" content="https://juejin.cn/user/2314902384159147"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深拷贝 structuredClone 与 JSON 方法作用及比较
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2314902384159147/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    DEMO派
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:36:21.000Z" title="Fri Dec 19 2025 07:36:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">structuredClone 与 JSON.parse(JSON.stringify()) 方法</h2>
<p><strong>概述</strong>
两者都用于深拷贝对象，但存在重要差异：</p>
<ol>
<li>structuredClone()
现代浏览器 API，专为克隆设计
优势：
✅ 支持循环引用</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };
obj.<span class="hljs-property">self</span> = obj;
<span class="hljs-keyword">const</span> cloned = <span class="hljs-title function_">structuredClone</span>(obj); <span class="hljs-comment">// 正常工作</span>
</code></pre>
<p>✅ 支持更多数据类型：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Map</span>、<span class="hljs-title class_">Set</span>

<span class="hljs-title class_">Date</span>（保持对象类型）

<span class="hljs-title class_">RegExp</span>（保持对象类型）

<span class="hljs-title class_">ArrayBuffer</span>、<span class="hljs-title class_">TypedArray</span>

<span class="hljs-title class_">Blob</span>、<span class="hljs-title class_">File</span>

<span class="hljs-title class_">Error</span> 类型（部分浏览器）
</code></pre>
<p>✅ 保持原型链（部分对象类型）</p>
<p>✅ 更高效（专门优化的算法）</p>
<p><strong>限制：</strong>
❌ 不支持函数</p>
<p>❌ 不支持 DOM 节点</p>
<p>❌ 不支持 Symbol 属性</p>
<p>❌ IE 不支持</p>
<ol start="2">
<li>JSON.parse(JSON.stringify())
传统方法，通过 JSON 序列化实现</li>
</ol>
<p><strong>优势：</strong>
✅ 广泛兼容（包括旧浏览器）</p>
<p>✅ 简单易用</p>
<p><strong>限制：</strong>
❌ 不支持循环引用</p>
<pre><code class="hljs language-javascript" lang="javascript">javascript
<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };
obj.<span class="hljs-property">self</span> = obj;
<span class="hljs-keyword">const</span> cloned = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// 报错</span>
</code></pre>
<p>❌ 数据类型丢失严重：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Date</span> → 字符串

<span class="hljs-title class_">Map</span>/<span class="hljs-title class_">Set</span> → 空对象 {}

<span class="hljs-title class_">RegExp</span> → 空对象 {}

<span class="hljs-title class_">Function</span> → 被移除

<span class="hljs-literal">undefined</span> → 被移除

<span class="hljs-title class_">NaN</span>/<span class="hljs-title class_">Infinity</span> → <span class="hljs-literal">null</span>

<span class="hljs-title class_">Symbol</span> → 被移除
</code></pre>
<p>❌ 原型链丢失（全部变为普通对象）</p>
<p><strong>性能对比</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 基准测试示例</span>
<span class="hljs-keyword">const</span> obj = { <span class="hljs-comment">/* 大型复杂对象 */</span> };

<span class="hljs-comment">// structuredClone 通常更快</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'structuredClone'</span>);
<span class="hljs-title function_">structuredClone</span>(obj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'structuredClone'</span>);

<span class="hljs-comment">// JSON 方法较慢</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'JSON方法'</span>);
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'JSON方法'</span>);

<span class="hljs-keyword">const</span> original = {
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>]]),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/gi</span>,
  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'test'</span>),
  <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">nan</span>: <span class="hljs-title class_">NaN</span>
};

<span class="hljs-comment">// structuredClone</span>
<span class="hljs-keyword">const</span> clone1 = <span class="hljs-title function_">structuredClone</span>(original);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clone1.<span class="hljs-property">date</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clone1.<span class="hljs-property">set</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>); <span class="hljs-comment">// true</span>
<span class="hljs-comment">// clone1.fn === undefined</span>

<span class="hljs-comment">// JSON 方法</span>
<span class="hljs-keyword">const</span> clone2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(original));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> clone2.<span class="hljs-property">date</span>); <span class="hljs-comment">// "string"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clone2.<span class="hljs-property">set</span>); <span class="hljs-comment">// {}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clone2.<span class="hljs-property">fn</span>); <span class="hljs-comment">// undefined</span>
</code></pre>
<p><strong>选择建议</strong>
<strong>使用 structuredClone 当</strong>：
需要支持循环引用</p>
<p>需要保持特殊对象类型（Date、Map、Set等）</p>
<p>在现代浏览器/Node.js（≥17）环境中</p>
<p>处理复杂对象结构</p>
<p><strong>使用 JSON 方法 当：</strong>
只需要简单的数据对象（无特殊类型）</p>
<p>不需要支持循环引用</p>
<p>需要兼容旧环境</p>
<p>明确知道对象只包含 JSON 安全的数据</p>
<p><strong>其他替代方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 第三方库</span>
<span class="hljs-keyword">import</span> cloneDeep <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/cloneDeep'</span>;

<span class="hljs-comment">// 自定义深拷贝函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) {
  <span class="hljs-comment">// 处理循环引用和复杂类型</span>
}
</code></pre>
<p><strong>总结表格</strong></p>























































<table><thead><tr><th>特性</th><th><code>structuredClone</code></th><th><code>JSON.parse(JSON.stringify())</code></th></tr></thead><tbody><tr><td><strong>循环引用</strong></td><td>✅ 支持</td><td>❌ 报错（抛出 TypeError）</td></tr><tr><td><strong>Date 对象</strong></td><td>✅ 保持 Date 类型</td><td>❌ 转为 ISO 格式字符串</td></tr><tr><td><strong>Map/Set</strong></td><td>✅ 保持 Map/Set 类型</td><td>❌ 转为空对象 {}</td></tr><tr><td><strong>函数</strong></td><td>❌ 不支持（抛出 DOMException）</td><td>❌ 被移除</td></tr><tr><td><strong>undefined</strong></td><td>✅ 支持</td><td>❌ 被移除</td></tr><tr><td><strong>Symbol</strong></td><td>❌ 不支持（抛出 DOMException）</td><td>❌ 被移除</td></tr><tr><td><strong>原型链</strong></td><td>✅ 部分保持（仅限可克隆对象）</td><td>❌ 完全丢失</td></tr><tr><td><strong>性能</strong></td><td>✅ 较优（原生实现）</td><td>❌ 较慢（需序列化和解析）</td></tr><tr><td><strong>兼容性</strong></td><td>现代浏览器（Chrome 98+、Firefox 94+）</td><td>所有浏览器（包括旧版 IE）</td></tr></tbody></table>
<h3 data-id="heading-1">补充说明：</h3>
<ol>
<li>
<p><strong>循环引用示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span> };
obj.<span class="hljs-property">self</span> = obj;
<span class="hljs-title function_">structuredClone</span>(obj); <span class="hljs-comment">// 正常克隆</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj); <span class="hljs-comment">// 报错：Converting circular structure to JSON</span>
</code></pre>
</li>
<li>
<p><strong>Date 对象处理差异</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
<span class="hljs-title function_">structuredClone</span>(date) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// true</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(date)) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// false</span>
</code></pre>
</li>
<li>
<p><strong>Map/Set 的特殊处理</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>]]);
<span class="hljs-title function_">structuredClone</span>(map) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>; <span class="hljs-comment">// true</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(map)); <span class="hljs-comment">// {}</span>
</code></pre>
</li>
<li>
<p><strong>性能对比场景</strong>：</p>
<ul>
<li>对于 1MB 大小的对象：
<ul>
<li><code>structuredClone</code> 耗时约 15ms</li>
<li><code>JSON</code> 方法耗时约 35ms（含序列化和解析）</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>原型链保留范围</strong>：</p>
<ul>
<li><code>structuredClone</code> 会保留内置对象（如 Array）的原型链</li>
<li>自定义类的原型链会被扁平化为普通对象
推荐：在现代应用中使用 structuredClone()，为更复杂的场景准备备选方案。</li>
</ul>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f71c580a048c4066ac2bc513a4909df3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgREVNT-a0vg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734581&amp;x-signature=KRZUEjhzfay8595SPZRywTVSUB4%3D" alt="在这里插入图片描述" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite Proxy到底是咋个工作嘞？]]></title>    <link>https://juejin.cn/post/7585206549305475135</link>    <guid>https://juejin.cn/post/7585206549305475135</guid>    <pubDate>2025-12-19T07:39:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206549305475135" data-draft-id="7585206549305425983" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite Proxy到底是咋个工作嘞？"/> <meta itemprop="keywords" content="axios,Vite"/> <meta itemprop="datePublished" content="2025-12-19T07:39:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="白哥学前端"/> <meta itemprop="url" content="https://juejin.cn/user/430664288573789"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite Proxy到底是咋个工作嘞？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664288573789/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    白哥学前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:39:55.000Z" title="Fri Dec 19 2025 07:39:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>proxy 要不要写、rewrite 要不要写、axios 的请求路径该怎么写？我好乱啊！！！</p>
</blockquote>
<p>你是不是也经常遇到类似的问题，搞不清路径到底该咋个写，今天就让你学个明明白白的。</p>
<h2 data-id="heading-0">一、先用一句话说清 Proxy 在干嘛</h2>
<blockquote>
<p><strong>Vite Proxy = 本地开发时的“请求中转站”</strong></p>
</blockquote>
<p>它做的事情只有一件：</p>
<blockquote>
<p><strong>把浏览器发给本地的请求，偷偷转发到真正的后端服务器</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-1">为什么需要它？</h3>
<p>因为浏览器有 <strong>跨域限制</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">前端：http:<span class="hljs-comment">//localhost:5173</span>
后端：http:<span class="hljs-comment">//192.168.110.220:8888</span>
</code></pre>
<blockquote>
<p>err:直接请求会被浏览器拦掉</p>
</blockquote>
<p>Proxy 的作用就是：<br/>
<strong>浏览器只跟 Vite 说话，Vite 去跟后端说话，通俗来讲，就是vite中封装的Proxy是个媒婆，你跟后端是相亲的，你的话需要通过媒婆来传递给后端。</strong></p>
<hr/>
<h2 data-id="heading-2">二、Proxy 的工作流程（一定要理解）</h2>
<p>假设你在浏览器里请求：</p>
<pre><code class="hljs language-bash" lang="bash">http://localhost:5173/api/csr/generate
</code></pre>
<p>Vite Proxy 做的事是：</p>
<pre><code class="hljs language-bash" lang="bash">浏览器
  ↓
Vite 开发服务器（localhost:5173）
  ↓（匹配 /api 规则）
代理转发
  ↓
真正后端（192.168.110.220:8888）
</code></pre>
<p>⚠️ 重点：<br/>
<strong>Proxy 只在「开发环境」生效，生产环境完全无效</strong></p>
<hr/>
<h2 data-id="heading-3">三、Proxy 配置里最重要的 3 个东西</h2>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">proxy:</span> {
  <span class="hljs-string">'/api'</span><span class="hljs-string">:</span> {
    <span class="hljs-attr">target:</span> <span class="hljs-string">'http://192.168.110.220:8888'</span>,
    <span class="hljs-attr">changeOrigin:</span> <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rewrite:</span> <span class="hljs-string">...</span>
  },
}
</code></pre>
<p>我们一个一个讲。</p>
<hr/>
<h3 data-id="heading-4">1. <code>/api</code> ——「拦谁」</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-string">'/api'</span>
</code></pre>
<p>意思是：</p>
<blockquote>
<p><strong>只要请求路径是以 <code>/api</code> 开头的，才走代理</strong></p>
</blockquote>
<p>例如：</p>

























<table><thead><tr><th>请求路径</th><th>是否走代理</th></tr></thead><tbody><tr><td><code>/api/csr/generate</code></td><td>✅</td></tr><tr><td><code>/api/user/login</code></td><td>✅</td></tr><tr><td><code>/csr/generate</code></td><td>❌</td></tr><tr><td><code>/login</code></td><td>❌</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-5">2. <code>target</code> ——「转给谁」</h3>
<pre><code class="hljs language-rust" lang="rust">target: <span class="hljs-symbol">'http</span>:<span class="hljs-comment">//192.168.110.220:8888'</span>
</code></pre>
<p>意思是：</p>
<blockquote>
<p><strong>最终请求会发给哪个后端服务器</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-6">3.<code>rewrite</code> ——「要不要改路径」</h3>
<p>这是<strong>最容易迷糊的地方</strong>，但其实逻辑非常简单。</p>
<hr/>
<h2 data-id="heading-7">四、rewrite 的本质（一句话）</h2>
<blockquote>
<p><strong>rewrite = 把“前端请求路径”改成“后端能识别的路径”</strong></p>
</blockquote>
<p>如果前端路径和后端路径 <strong>一模一样</strong>：</p>
<blockquote>
<p>❌ 不需要 rewrite</p>
</blockquote>
<p>如果不一样：</p>
<blockquote>
<p>✅ 才需要 rewrite</p>
</blockquote>
<hr/>
<h2 data-id="heading-8">五、最重要的前提：先搞清“后端真实接口长什么样”</h2>
<p>我们用你真实的接口来讲：</p>
<pre><code class="hljs language-ruby" lang="ruby">后端真实接口：
<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/192.168.110.220:8888/api</span><span class="hljs-regexp">/csr/generate</span>
</code></pre>
<p>👉 注意：<br/>
<strong><code>/api</code> 是后端接口的一部分</strong></p>
<hr/>
<h2 data-id="heading-9">六、场景一（最推荐）：<code>/api</code> 只是前端代理前缀</h2>
<h3 data-id="heading-10">场景描述</h3>
<pre><code class="hljs language-bash" lang="bash">后端接口：/csr/generate
前端想统一写：/api/xxx
</code></pre>
<h3 data-id="heading-11">正确配置</h3>
<h4 data-id="heading-12">vite.config.ts</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-attr">proxy</span>: {
  <span class="hljs-string">'/api'</span>: {
    <span class="hljs-attr">target</span>: <span class="hljs-string">'http://192.168.110.220:8888'</span>,
    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rewrite</span>: <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^/</span>api/, <span class="hljs-string">''</span>),
  },
},
</code></pre>
<h4 data-id="heading-13">axios</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// baseURL</span>
<span class="hljs-string">'/api'</span>

<span class="hljs-comment">// 请求</span>
api.<span class="hljs-built_in">post</span>(<span class="hljs-string">'/csr/generate'</span>)
</code></pre>
<h3 data-id="heading-14">实际发生的事</h3>
<pre><code class="hljs language-bash" lang="bash">/api/csr/generate
↓ rewrite
/csr/generate
↓
192.168.110.220:8888/csr/generate
</code></pre>
<p>✅ rewrite <strong>有意义</strong></p>
<hr/>
<h2 data-id="heading-15">七、场景二（⭐你现在的真实场景）：<code>/api</code> 是后端真实路径</h2>
<h3 data-id="heading-16">场景描述</h3>
<pre><code class="hljs language-bash" lang="bash">后端接口：/api/csr/generate
前端请求：/api/csr/generate
</code></pre>
<p>👉 <strong>前后端路径完全一致</strong></p>
<hr/>
<h3 data-id="heading-17">正确配置（最简单、最不容易出错）</h3>
<h4 data-id="heading-18">vite.config.ts</h4>
<pre><code class="hljs language-arduino" lang="arduino">proxy: {
  <span class="hljs-string">'/api'</span>: {
    target: <span class="hljs-string">'http://192.168.110.220:8888'</span>,
    changeOrigin: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// ❌ 不写 rewrite</span>
  },
},
</code></pre>
<h4 data-id="heading-19">axios</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// baseURL</span>
<span class="hljs-string">'/api'</span>

<span class="hljs-comment">// 请求</span>
api.<span class="hljs-built_in">post</span>(<span class="hljs-string">'/csr/generate'</span>)
</code></pre>
<hr/>
<h3 data-id="heading-20">实际请求路径</h3>
<pre><code class="hljs language-bash" lang="bash">localhost:5173/api/csr/generate
↓
192.168.110.220:8888/api/csr/generate
</code></pre>
<p>✅ 完全正确<br/>
✅ 不多、不少<br/>
✅ 不 404</p>
<hr/>
<h2 data-id="heading-21">八、为什么 <code>rewrite: replace(/^/api/, '/api')</code> 没意义？</h2>
<p>我们来算一遍：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-string">'/api/csr/generate'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^/</span>api/, <span class="hljs-string">'/api'</span>)
</code></pre>
<p>结果还是：</p>
<pre><code class="hljs language-bash" lang="bash">/api/csr/generate
</code></pre>
<p>👉 <strong>路径根本没变</strong></p>
<p>所以：</p>
<ul>
<li>✔️ 写了不报错</li>
<li>❌ 但等于没写</li>
<li>❌ 还容易误导别人</li>
</ul>
<hr/>
<h2 data-id="heading-22">九、axios 和 proxy 配合的“黄金规则”</h2>
<h3 data-id="heading-23">一句话口诀（非常重要）</h3>
<blockquote>
<p><strong>baseURL 里有 <code>/api</code>，请求路径里就不要再写 <code>/api</code></strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-24">正确示例</h3>
<pre><code class="hljs language-css" lang="css">baseURL: <span class="hljs-string">'/api'</span>
api.<span class="hljs-built_in">post</span>(<span class="hljs-string">'/csr/generate'</span>)
</code></pre>
<hr/>
<h3 data-id="heading-25">错误示例（最常见 404 来源）</h3>
<pre><code class="hljs language-arduino" lang="arduino">baseURL: <span class="hljs-string">'/api'</span>
api.<span class="hljs-built_in">post</span>(<span class="hljs-string">'/api/csr/generate'</span>) <span class="hljs-comment">// ❌</span>
</code></pre>
<p>实际请求变成：</p>
<pre><code class="hljs language-bash" lang="bash">/api/api/csr/generate
</code></pre>
<hr/>
<h2 data-id="heading-26">十、不同配置组合对照表（建议收藏）</h2>

























<table><thead><tr><th>baseURL</th><th>axios 请求</th><th>实际请求</th></tr></thead><tbody><tr><td><code>/api</code></td><td><code>/csr/generate</code></td><td><code>/api/csr/generate</code> ✅</td></tr><tr><td><code>/api</code></td><td><code>/api/csr/generate</code></td><td><code>/api/api/csr/generate</code> ❌</td></tr><tr><td><code>/</code></td><td><code>/api/csr/generate</code></td><td><code>/api/csr/generate</code> ✅</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-27">十一、完整推荐模板（开发 + 生产）</h2>
<h3 data-id="heading-28"><code>.env.development</code></h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_API_BASE_URL</span>=/api
</code></pre>
<h3 data-id="heading-29"><code>.env.production</code></h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_API_BASE_URL</span>=http://<span class="hljs-number">192.168</span>.<span class="hljs-number">110.220</span>:<span class="hljs-number">8888</span>
</code></pre>
<h3 data-id="heading-30">axios 封装</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,
})
</code></pre>
<hr/>
<h2 data-id="heading-31">十二、最后用一句大白话收尾</h2>
<blockquote>
<p><strong>Proxy 不神秘，它只是帮你“改地址”；<br/>
axios 不复杂，它只是“拼路径”；<br/>
你只要分清：<br/>
👉 <code>/api</code> 是不是后端真实路径，<br/>
👉 rewrite 就永远不会再写错。</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript性能优化由浅入深]]></title>    <link>https://juejin.cn/post/7585180775705198619</link>    <guid>https://juejin.cn/post/7585180775705198619</guid>    <pubDate>2025-12-19T07:40:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585180775705198619" data-draft-id="7585406229151481894" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript性能优化由浅入深"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T07:40:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="DEMO派"/> <meta itemprop="url" content="https://juejin.cn/user/2314902384159147"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript性能优化由浅入深
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2314902384159147/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    DEMO派
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:40:12.000Z" title="Fri Dec 19 2025 07:40:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>目录</p>
<ol>
<li>
<p>基础优化技巧</p>
</li>
<li>
<p>中级优化策略</p>
</li>
<li>
<p>高级优化方法</p>
</li>
<li>
<p>具体示例与效果对比</p>
</li>
<li>
<p>工具与最佳实践</p>
</li>
</ol>
<p>1 . 基础优化技巧
1.1 变量作用域优化
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processItems</span>(<span class="hljs-params">items</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-comment">// 每次循环都重新计算length</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items[i]);
  }
}
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processItems</span>(<span class="hljs-params">items</span>) {
  <span class="hljs-keyword">const</span> length = items.<span class="hljs-property">length</span>; <span class="hljs-comment">// 缓存length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items[i]);
  }
}
</code></pre>
<p><em><strong>效果对比： 在10,000个元素的数组中，性能提升约15-20%</strong></em></p>
<p>1.2 减少DOM操作
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateList</span>(<span class="hljs-params">items</span>) {
  <span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'list'</span>);
  list.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>; <span class="hljs-comment">// 清空列表</span>
  
  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>);
    li.<span class="hljs-property">textContent</span> = item;
    list.<span class="hljs-title function_">appendChild</span>(li); <span class="hljs-comment">// 每次循环都操作DOM</span>
  });
}
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateList</span>(<span class="hljs-params">items</span>) {
  <span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'list'</span>);
  <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>(); <span class="hljs-comment">// 使用文档片段</span>
  
  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>);
    li.<span class="hljs-property">textContent</span> = item;
    fragment.<span class="hljs-title function_">appendChild</span>(li);
  });
  
  list.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
  list.<span class="hljs-title function_">appendChild</span>(fragment); <span class="hljs-comment">// 一次性插入DOM</span>
}
</code></pre>
<p><em><strong>效果对比： 在1000个列表项中，性能提升约60-70%</strong></em></p>
<p>1.3 事件委托
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 为每个按钮添加事件监听器</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.btn'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">btn</span> =&gt;</span> {
  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleClick);
});
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用事件委托</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-title function_">matches</span>(<span class="hljs-string">'.btn'</span>)) {
    <span class="hljs-title function_">handleClick</span>(event);
  }
});
</code></pre>
<p><em><strong>效果对比： 在100个按钮的场景中，内存使用减少约80%，初始化速度提升90%</strong></em></p>
<ol start="2">
<li>中级优化策略
2.1 防抖与节流</li>
</ol>
<p>优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 窗口滚动时频繁执行</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Scroll event fired'</span>);
  <span class="hljs-comment">// 复杂计算...</span>
});
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用节流</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, limit</span>) {
  <span class="hljs-keyword">let</span> inThrottle;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;
    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>;
    <span class="hljs-keyword">if</span> (!inThrottle) {
      func.<span class="hljs-title function_">apply</span>(context, args);
      inThrottle = <span class="hljs-literal">true</span>;
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> inThrottle = <span class="hljs-literal">false</span>, limit);
    }
  };
}

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Throttled scroll event'</span>);
  <span class="hljs-comment">// 复杂计算...</span>
}, <span class="hljs-number">100</span>));
</code></pre>
<p><em><strong>效果对比： 滚动事件处理频率减少90%，CPU使用率降低70%</strong></em></p>
<p>2.2 循环优化
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用forEach（函数调用开销）</span>
array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
  <span class="hljs-title function_">process</span>(item);
});
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用for循环（最快）</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) {
  <span class="hljs-title function_">process</span>(array[i]);
}

<span class="hljs-comment">// 或者使用for-of（可读性好，性能接近for循环）</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) {
  <span class="hljs-title function_">process</span>(item);
}
</code></pre>
<p><em><strong>性能对比测试结果：
数组大小: 1,000,000个元素
forEach: 45ms
for循环: 12ms
for-of: 15ms</strong></em></p>
<p>2.3 使用Web Workers处理CPU密集型任务
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 主线程执行复杂计算</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculatePrimes</span>(<span class="hljs-params">max</span>) {
  <span class="hljs-keyword">const</span> primes = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= max; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(i)) primes.<span class="hljs-title function_">push</span>(i);
  }
  <span class="hljs-keyword">return</span> primes;
}

<span class="hljs-comment">// 这会阻塞UI</span>
<span class="hljs-keyword">const</span> primes = <span class="hljs-title function_">calculatePrimes</span>(<span class="hljs-number">1000000</span>);
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'prime-worker.js'</span>);

worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Primes calculated:'</span>, event.<span class="hljs-property">data</span>);
};

worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-number">1000000</span>);

<span class="hljs-comment">// prime-worker.js</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">const</span> max = event.<span class="hljs-property">data</span>;
  <span class="hljs-keyword">const</span> primes = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= max; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(i)) primes.<span class="hljs-title function_">push</span>(i);
  }
  self.<span class="hljs-title function_">postMessage</span>(primes);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(num); i++) {
    <span class="hljs-keyword">if</span> (num % i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">1</span>;
}
</code></pre>
<p><em><strong>效果对比： UI响应性从完全阻塞变为无阻塞，用户体验显著提升</strong></em></p>
<ol start="3">
<li>高级优化方法
3.1 内存管理与垃圾回收</li>
</ol>
<p>优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 内存泄漏示例</span>
<span class="hljs-keyword">let</span> elements = [];

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createElements</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
    <span class="hljs-keyword">const</span> element = {
      <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'data'</span>),
      <span class="hljs-attr">dom</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>)
    };
    elements.<span class="hljs-title function_">push</span>(element);
    <span class="hljs-comment">// 但从未清除</span>
  }
}
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用WeakMap避免内存泄漏</span>
<span class="hljs-keyword">const</span> elementMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createElements</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
    <span class="hljs-keyword">const</span> element = {
      <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'data'</span>)
    };
    <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    elementMap.<span class="hljs-title function_">set</span>(dom, element);
    
    <span class="hljs-comment">// 当DOM元素被移除时，对应的element会自动被垃圾回收</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(dom);
  }
}

<span class="hljs-comment">// 手动清理不再需要的引用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"/>) {
  elementMap = <span class="hljs-literal">null</span>;
}
</code></pre>
<p>3.2 使用requestAnimationFrame优化动画
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用setTimeout动画</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"/>) {
  element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = (<span class="hljs-built_in">parseInt</span>(element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;
  <span class="hljs-built_in">setTimeout</span>(animate, <span class="hljs-number">16</span>); <span class="hljs-comment">// 约60fps</span>
}
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用requestAnimationFrame</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"/>) {
  element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = (<span class="hljs-built_in">parseInt</span>(element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;
  <span class="hljs-title function_">requestAnimationFrame</span>(animate);
}
</code></pre>
<p><em><strong>效果对比：
帧率更稳定：60fps vs 不确定的帧率
省电：当页面不可见时自动暂停
同步浏览器重绘，避免布局抖动</strong></em></p>
<p>3.3 代码分割与懒加载
优化前：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 一次性加载所有代码</span>
<span class="hljs-keyword">import</span> { featureA } <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/a'</span>;
<span class="hljs-keyword">import</span> { featureB } <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/b'</span>;
<span class="hljs-keyword">import</span> { featureC } <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/c'</span>;

<span class="hljs-comment">// 即使用户不会用到所有功能，也会全部加载</span>
</code></pre>
<p>优化后：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 动态导入（懒加载）</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'btn-feature-a'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { featureA } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./features/a'</span>);
  <span class="hljs-title function_">featureA</span>();
});

<span class="hljs-comment">// 基于路由的代码分割（使用React示例）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/Home'</span>));
<span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/About'</span>));
</code></pre>
<p><em><strong>效果对比： 初始加载时间减少40-60%，首次内容渲染时间缩短</strong></em></p>
<ol start="4">
<li>具体性能对比示例
4.1 字符串拼接优化</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 测试不同字符串拼接方法的性能</span>
<span class="hljs-keyword">const</span> testCount = <span class="hljs-number">10000</span>;

<span class="hljs-comment">// 方法1: + 操作符</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'加号拼接'</span>);
<span class="hljs-keyword">let</span> str1 = <span class="hljs-string">''</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; testCount; i++) {
  str1 += <span class="hljs-string">'test'</span> + i;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'加号拼接'</span>);

<span class="hljs-comment">// 方法2: 数组join</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'数组join'</span>);
<span class="hljs-keyword">let</span> arr = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; testCount; i++) {
  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'test'</span> + i);
}
<span class="hljs-keyword">let</span> str2 = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'数组join'</span>);

<span class="hljs-comment">// 方法3: 模板字符串</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'模板字符串'</span>);
<span class="hljs-keyword">let</span> str3 = <span class="hljs-string">''</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; testCount; i++) {
  str3 = <span class="hljs-string">`<span class="hljs-subst">${str3}</span>test<span class="hljs-subst">${i}</span>`</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'模板字符串'</span>);
</code></pre>
<p><em><strong>测试结果（Chrome 浏览器）：
加号拼接: 2.1ms
数组join: 1.8ms
模板字符串: 2.3ms</strong></em></p>
<p>4.2 查找算法优化</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在大型数组中查找元素</span>
<span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({
  <span class="hljs-attr">id</span>: i,
  <span class="hljs-attr">value</span>: <span class="hljs-string">`item-<span class="hljs-subst">${i}</span>`</span>
}));

<span class="hljs-comment">// 方法1: find</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'Array.find'</span>);
<span class="hljs-keyword">const</span> result1 = largeArray.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === <span class="hljs-number">999999</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'Array.find'</span>);

<span class="hljs-comment">// 方法2: 使用Map</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'Map创建'</span>);
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(largeArray.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item.<span class="hljs-property">id</span>, item]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'Map创建'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'Map查找'</span>);
<span class="hljs-keyword">const</span> result2 = map.<span class="hljs-title function_">get</span>(<span class="hljs-number">999999</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'Map查找'</span>);

<span class="hljs-comment">// 方法3: 对象索引</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'对象创建'</span>);
<span class="hljs-keyword">const</span> obj = {};
largeArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
  obj[item.<span class="hljs-property">id</span>] = item;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'对象创建'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'对象查找'</span>);
<span class="hljs-keyword">const</span> result3 = obj[<span class="hljs-number">999999</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'对象查找'</span>);
</code></pre>
<p><em><strong>测试结果：
Array.find: 8.5ms
Map创建: 65ms
Map查找: 0.02ms
对象创建: 45ms
对象查找: 0.01ms
结论：多次查找时，使用Map或对象索引性能更好</strong></em></p>
<ol start="5">
<li>工具与最佳实践
5.1 性能分析工具</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用console.time和console.timeEnd进行简单性能分析</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'处理数据'</span>);
<span class="hljs-comment">// 执行复杂操作</span>
<span class="hljs-title function_">processLargeData</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'处理数据'</span>);

<span class="hljs-comment">// 使用Performance API进行更精确的测量</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">measurePerformance</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();
  
  <span class="hljs-comment">// 执行需要测量的代码</span>
  <span class="hljs-title function_">expensiveOperation</span>();
  
  <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`操作耗时: <span class="hljs-subst">${(end - start).toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
}

<span class="hljs-comment">// 使用PerformanceObserver监控性能指标</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${entry.name}</span>: <span class="hljs-subst">${entry.duration}</span>ms`</span>);
  }
});

observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'measure'</span>, <span class="hljs-string">'longtask'</span>] });
</code></pre>
<p>5.2 最佳实践总结</p>
<p>测量优先：在优化前使用性能分析工具</p>
<p>渐进优化：先解决瓶颈最大的问题</p>
<p>代码可读性：不要过度优化牺牲代码可维护性</p>
<p>缓存策略：合理使用缓存减少重复计算</p>
<p>异步处理：使用Promise、async/await避免阻塞</p>
<p>资源优化：压缩代码、图片，使用CDN</p>
<p>监控与警报：持续监控关键性能指标</p>
<p>5.3 现代JavaScript优化特性</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用WebAssembly处理性能关键部分</span>
<span class="hljs-comment">// 使用Intersection Observer进行懒加载</span>
<span class="hljs-comment">// 使用Resize Observer替代resize事件</span>
<span class="hljs-comment">// 使用Mutation Observer优化DOM变更监测</span>
<span class="hljs-comment">// 使用Service Workers进行缓存和离线支持</span>
</code></pre>
<p><strong>总结：
JavaScript性能优化是一个多层次的工程，需要：
基础层：掌握语言特性和浏览器原理
应用层：合理设计架构和算法
工具层：使用合适的工具进行测量和监控
持续优化：性能优化是持续过程，不是一次性任务
记住黄金法则：先测量，后优化；优先解决瓶颈，避免过度优化。正确的优化应该基于实际性能数据和用户体验指标，而不是猜测。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c2d7b9a0ff7445780e9455fbfaf6327~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgREVNT-a0vg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766734812&amp;x-signature=ZP%2BfEyX8v9uTxFJ%2ByhzXPIcugdQ%3D" alt="在这里插入图片描述" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Windows平台下CMake工程中使用protobuf]]></title>    <link>https://juejin.cn/post/7585121055037571122</link>    <guid>https://juejin.cn/post/7585121055037571122</guid>    <pubDate>2025-12-19T07:42:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585121055037571122" data-draft-id="7585084491896651802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Windows平台下CMake工程中使用protobuf"/> <meta itemprop="keywords" content="C++,CMake"/> <meta itemprop="datePublished" content="2025-12-19T07:42:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="微笑倾城"/> <meta itemprop="url" content="https://juejin.cn/user/465848663278045"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Windows平台下CMake工程中使用protobuf
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/465848663278045/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    微笑倾城
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:42:48.000Z" title="Fri Dec 19 2025 07:42:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Windows平台下的CMake工程中使用protobuf</h2>
<p>本文档介绍如何在Windows平台下的CMake工程中正确配置和使用Protobuf库，解决链接错误问题。</p>
<p>本文在以下环境中使用<code>静态</code>链接库测试通过：</p>
<h3 data-id="heading-1">环境配置</h3>
<ul>
<li>Windows 10</li>
<li>Visual Studio 2026</li>
<li>CMake 4.1.1-msvc1</li>
<li>Ninja 1.12.1</li>
<li>Clang 21.1.5</li>
<li>Protobuf 33.2</li>
</ul>
<p>注：以上的CMake版本是Visual Studio 2026自带的版本。在环境变量添加以下配置即可：
<code>&lt;VisualStudio 2026 安装目录&gt;/Common7/IDE/CommonExtensions/Microsoft/CMake/CMake/bin</code>。</p>
<h3 data-id="heading-2">操作步骤</h3>
<h4 data-id="heading-3">一、初始化Protobuf配置</h4>
<p>本文使用源码编译配置Protobuf库。</p>
<ol>
<li>下载Protobuf源码<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Freleases" target="_blank" title="https://github.com/protocolbuffers/protobuf/releases" ref="nofollow noopener noreferrer">Protobuf 33.2</a> 选择下载 <code>protobuf-33.2.zip</code>。</li>
<li>解压 <code>protobuf-33.2.zip</code>。</li>
<li>在解压后的<code>protobuf-33.2</code>目录下，创建 <code>build.bat</code> 写入以下内容，然后执行这个脚本。</li>
</ol>
<pre><code class="hljs language-bat" lang="bat">@echo off
cmake ./ ^
  -B build ^
  -G "Ninja" ^
  -D CMAKE_C_COMPILER=clang ^
  -D CMAKE_CXX_COMPILER=clang++ ^
  -D protobuf_BUILD_TESTS=OFF ^
  -D CMAKE_BUILD_TYPE=Release ^
  -D CMAKE_INSTALL_PREFIX=./install ^
  -D CMAKE_CXX_STANDARD=17 ^
  -D CMAKE_CXX_STANDARD_REQUIRED=ON

cmake --build build --config Release

cmake --install build
</code></pre>
<ol start="4">
<li>
<p>编译完成之后，会在 <code>protobuf-33.2/install</code> 目录下，会生成 <code>bin</code>、<code>include</code>、<code>lib</code> 三个目录。里面包括<code>Protobuf的头文件</code>、<code>库文件</code>和 <code>protoc</code> 编译工具等。</p>
</li>
<li>
<p>将<code>protobuf-33.2/install/bin</code> 目录添加到环境变量中，即可全局使用 <code>protoc</code> 编译工具。</p>
</li>
</ol>
<h4 data-id="heading-4">二、在CMake工程中使用Protobuf库</h4>
<ol start="0">
<li>
<p>注意设置工程<code>CMAKE_BUILD_TYPE</code>为<code>Release</code>, 保持和Protobuf库的编译类型一致。</p>
</li>
<li>
<p>在CMakeLists.txt 头部添加 <code>cmake_policy(SET CMP0091 NEW)</code> 来设置新的CMake策略。</p>
</li>
</ol>
<pre><code class="hljs language-cmake" lang="cmake"># 在 project() 之前添加；主要是为了能成功设置 CMAKE_MSVC_RUNTIME_LIBRARY
cmake_policy(SET CMP0091 NEW)

# 在 project() 之后设置 CMAKE_MSVC_RUNTIME_LIBRARY 解决 RuntimeLibrary 链接错误
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;")
else()
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded")
endif()

# 设置 C++ 标准为 C++17 因为 Protobuf 依赖 Absl 库，而 Absl 库要求 C++17 标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 添加 protobuf 相关配置
# 设置 Protobuf 库的搜索路径 请替换为你自己的完整安装路径
set(CMAKE_PREFIX_PATH "D:/protobuf-33.2/install")

# 查找Protobuf及Protobuf所依赖的包
find_package(Protobuf REQUIRED)
# 以下两个都是Protobuf所依赖的库
find_package(Absl REQUIRED)
find_package(utf8_range REQUIRED)


# 链接utf8_range库 解决Protobuf链接错误
target_link_libraries(${PROJECT_NAME} utf8_range::utf8_range)

# 链接Absl库 解决Protobuf链接错误
target_link_libraries(${PROJECT_NAME} absl::check absl::log_flags absl::statusor)

# 链接Protobuf库
target_link_libraries(${PROJECT_NAME} ${Protobuf_LIBRARIES})
</code></pre>
<p>注: 直接链接<code>Protobuf</code>库, 会有链接错误，必须要链接<code>utf8_range</code>和<code>Absl</code>库。</p>
<ol start="2">
<li>编译工程，即可成功使用Protobuf库。</li>
</ol>
<h3 data-id="heading-5">三、写在最后</h3>
<ol>
<li>以上配置仅适用于Windows平台下的CMake工程。</li>
<li>也可以使用其他的编译器，如MSVC等，需要确保编译<code>Protobuf</code>库和<code>使用Protobuf</code>的工程都使用相同的编译器。参考编译bat脚本</li>
</ol>
<pre><code class="hljs language-bat" lang="bat">cmake ./ ^
  -B build ^
  -G "Visual Studio 18 2026" ^
  -D protobuf_BUILD_TESTS=OFF ^
  -D CMAKE_BUILD_TYPE=Release ^
  -D CMAKE_INSTALL_PREFIX=./install ^
  -D CMAKE_CXX_STANDARD=17 ^
  -D CMAKE_CXX_STANDARD_REQUIRED=ON

cmake --build build --config Release

cmake --install build
</code></pre>
<ol start="3">
<li>过程中可以遇到以下错误：</li>
</ol>
<ul>
<li>RuntimeLibrary 不匹配错误：</li>
</ul>
<pre><code class="hljs language-txt" lang="txt">[build] lld-link: error: /failifmismatch: mismatch detected for 'RuntimeLibrary':
[build] &gt;&gt;&gt; CMakeFiles/test_cpp.dir/cpp/test.pb.cc.obj has value MD_DynamicRelease
[build] &gt;&gt;&gt; protobuf.lib(message.cc.obj) has value MT_StaticRelease
</code></pre>
<p>主要检查工程<code>cmake_policy</code>和<code>CMAKE_MSVC_RUNTIME_LIBRARY</code>是否正确设置；<a href="https://link.juejin.cn?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fvariable%2FCMAKE_MSVC_RUNTIME_LIBRARY.html" target="_blank" title="https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html" ref="nofollow noopener noreferrer">参考文档</a><br/>
其他版本的<code>cmake</code>参考对应版本设置<code>cmake_policy</code>即可。</p>
<ul>
<li>Protobuf链接错误：</li>
</ul>
<pre><code class="hljs language-txt" lang="txt">lld-link: error: undefined symbol: utf8_range_IsValid
[build] &gt;&gt;&gt; referenced by protobuf.lib(generated_message_tctable_lite.cc.obj):(public: static char const * __cdecl google::protobuf::internal::TcParser::FastUS1(class google::protobuf::MessageLite *, char const *, class google::protobuf::internal::ParseContext *, struct google::protobuf::internal::TcFieldData, struct google::protobuf::internal::TcParseTableBase const *, unsigned __int64))

[build] lld-link: error: undefined symbol: public: void __cdecl absl::lts_20250512::status_internal::StatusRep::Unref(void) const
[build] &gt;&gt;&gt; referenced by CMakeFiles/test_cpp.dir/cpp/main.cpp.obj:(main)
[build] &gt;&gt;&gt; referenced by CMakeFiles/test_cpp.dir/cpp/main.cpp.obj:(public: __cdecl absl::lts_20250512::Status::~Status(void))
</code></pre>
<p>主要检查工程是否链接了<code>utf8_range</code>和<code>Absl</code>的相关库。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[swift中的知识总结（一）]]></title>    <link>https://juejin.cn/post/7585180775705067547</link>    <guid>https://juejin.cn/post/7585180775705067547</guid>    <pubDate>2025-12-19T07:23:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585180775705067547" data-draft-id="7585085798808993819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="swift中的知识总结（一）"/> <meta itemprop="keywords" content="iOS,Swift"/> <meta itemprop="datePublished" content="2025-12-19T07:23:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="崽崽长肉肉"/> <meta itemprop="url" content="https://juejin.cn/user/993614240687117"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            swift中的知识总结（一）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614240687117/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    崽崽长肉肉
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:23:37.000Z" title="Fri Dec 19 2025 07:23:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、associatedtype的用法</h2>
<p>在swift中，<code>泛型T</code>是一个非常强大的特性，它允许我们编写灵活且可复用的代码。而当我们在 <code>协议（Protocol）</code> 中需要使用泛型时，<code>associatedtype</code> 就派上了用场。</p>
<p>在 Swift 的协议中，我们无法直接使用<code>泛型 &lt;T&gt;</code>，但可以使用 <code>associatedtype</code> 关键字来声明一个<code>占位类型</code>，让协议在不确定具体类型的情况下仍然能够正常使用。</p>
<h4 data-id="heading-1">1、让协议支持不同数据类型的</h4>
<pre><code class="hljs language-js" lang="js">protocol <span class="hljs-title class_">SomeProtocol</span> {
    associatedtype <span class="hljs-title class_">SomeType</span> <span class="hljs-comment">// 声明一个占位类型 SomeType，但不指定具体类型。</span>
    func <span class="hljs-title function_">doSomething</span>(<span class="hljs-keyword">with</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">SomeType</span>)
}

<span class="hljs-comment">// Int类型</span>
protocol <span class="hljs-title class_">SomeProtocol</span> {
    associatedtype <span class="hljs-title class_">Item</span>
    mutating func <span class="hljs-title function_">doSomething</span>(<span class="hljs-keyword">with</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">Item</span>)
    func <span class="hljs-title function_">getItem</span>(at <span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Item</span>
}

struct <span class="hljs-title class_">ContainerDemo</span>: <span class="hljs-title class_">SomeProtocol</span> {

    typealias <span class="hljs-title class_">Item</span> = <span class="hljs-title class_">Int</span> <span class="hljs-comment">// 指定Item为Int类型</span>
    private <span class="hljs-keyword">var</span> <span class="hljs-attr">items</span>: [<span class="hljs-title class_">Int</span>] = []

    mutating func <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-keyword">with</span> value: Int</span>) {
        items.<span class="hljs-title function_">append</span>(value)
        <span class="hljs-title function_">print</span>(value)
    }

    func <span class="hljs-title function_">getItem</span>(at <span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Int</span> {
        <span class="hljs-keyword">return</span> items[index]
    }
}

<span class="hljs-comment">// String类型</span>
struct <span class="hljs-title class_">StringContainer</span>: <span class="hljs-title class_">SomeProtocol</span> {

    typealias <span class="hljs-title class_">Item</span> = <span class="hljs-title class_">String</span>
    private <span class="hljs-keyword">var</span> <span class="hljs-attr">items</span>: [<span class="hljs-title class_">String</span>] = []

    mutating func <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-keyword">with</span> value: <span class="hljs-built_in">String</span></span>) {
        items.<span class="hljs-title function_">append</span>(value)
    }

    func <span class="hljs-title function_">getItem</span>(at <span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">return</span> items[index]
    }
}

protocol <span class="hljs-title class_">StackProtocol</span> {
    associatedtype <span class="hljs-title class_">Element</span>
    mutating func <span class="hljs-title function_">push</span>(_ <span class="hljs-attr">item</span>: <span class="hljs-title class_">Element</span>)
    mutating func <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-title class_">Element</span>?
}

struct <span class="hljs-title class_">IntStack</span>: <span class="hljs-title class_">StackProtocol</span> {

    typealias <span class="hljs-title class_">Element</span> = <span class="hljs-title class_">Int</span>
    private <span class="hljs-keyword">var</span> <span class="hljs-attr">stacks</span>: [<span class="hljs-title class_">Int</span>] = []

    mutating func <span class="hljs-title function_">push</span>(<span class="hljs-params">_ item: Int</span>) {
        stacks.<span class="hljs-title function_">append</span>(item)
    }

    mutating func <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-title class_">Int</span>? {
        <span class="hljs-keyword">return</span> stacks.<span class="hljs-title function_">popLast</span>()
    }
}
</code></pre>
<h4 data-id="heading-2">2、使用where关键词限定类型</h4>
<p>有时候希望<code>assocaitedtype</code>只能是<strong>某种类型的子类或实现了某个协议</strong>。可以使用<code>where关键字</code>进行类型约束</p>
<pre><code class="hljs language-js" lang="js">protocol <span class="hljs-title class_">Summable</span> {
    associatedtype <span class="hljs-title class_">Number</span>: <span class="hljs-title class_">Numeric</span> <span class="hljs-comment">// 限定Number必须是Numeric协议的子类型（ Int、Double）</span>
     func <span class="hljs-title function_">sum</span>(<span class="hljs-attr">a</span>: <span class="hljs-title class_">Number</span>,<span class="hljs-attr">b</span>: <span class="hljs-title class_">Number</span>) -&gt; <span class="hljs-title class_">Number</span>
}

struct <span class="hljs-attr">myIntergerAddr</span>: <span class="hljs-title class_">Summable</span> {
     func <span class="hljs-title function_">sum</span>(<span class="hljs-attr">a</span>: <span class="hljs-title class_">Int</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Int</span> {
        <span class="hljs-keyword">return</span> a + b
    }
}

<span class="hljs-comment">// 使用泛型结构体遵循协议</span>
struct myGenericSatck&lt;T&gt;: <span class="hljs-title class_">StackProtocol</span> {
    
    private <span class="hljs-keyword">var</span> <span class="hljs-attr">elements</span>: [T] = []
    <span class="hljs-keyword">var</span> <span class="hljs-attr">isEmpty</span>: <span class="hljs-title class_">Bool</span> {<span class="hljs-keyword">return</span> elements.<span class="hljs-property">isEmpty</span>}
    <span class="hljs-keyword">var</span> <span class="hljs-attr">count</span>: <span class="hljs-title class_">Int</span> {<span class="hljs-keyword">return</span> elements.<span class="hljs-property">count</span>}

    mutating func <span class="hljs-title function_">push</span>(<span class="hljs-params">_ item: T</span>) {
        elements.<span class="hljs-title function_">append</span>(item)
    }

    mutating func <span class="hljs-title function_">pop</span>() -&gt; T? {
        <span class="hljs-keyword">return</span> elements.<span class="hljs-title function_">popLast</span>()
    }
}
</code></pre>
<h4 data-id="heading-3">3、<strong>associatedtype 与泛型的区别</strong></h4>






























<table><thead><tr><th><strong>比较项</strong></th><th>associatedtype <strong>（协议中的泛型）</strong></th><th><strong>普通泛型</strong> </th></tr></thead><tbody><tr><td>适用范围</td><td>只能用于 <strong>协议</strong></td><td>可用于 <strong>类、结构体、函数</strong></td></tr><tr><td>作用</td><td>让协议支持不确定的类型，由实现者决定具体类型</td><td>让类型/函数支持泛型</td></tr><tr><td>例子</td><td>protocol Container { associatedtype Item }</td><td>struct Stack {}</td></tr><tr><td>限制</td><td>只能用于协议，不能直接实例化</td><td>适用于所有类型</td></tr></tbody></table>
<h4 data-id="heading-4">4、什么时候使用 associatedtype</h4>
<ul>
<li><strong>当你需要创建一个通用的协议，但不想限定某个具体类型时。</strong></li>
<li><strong>当不同的实现类需要指定不同的数据类型时。</strong></li>
<li><strong>当你希望协议中的某些类型参数具备类型约束时（如 where 关键字）。</strong></li>
</ul>
<h2 data-id="heading-5">二、Subscript下标的用法</h2>
<ul>
<li>
<p>是一种访问集合、列表或序列中元素成员的快捷方式。它允许你通过下标语法（使用方括号 <code>[]</code>）来访问实例中的数据，而不需要调用方法。</p>
</li>
<li>
<p>使用<code>Subscript</code>可以给任意类型（枚举、结构体、类）增加下标功能。</p>
</li>
<li>
<p><code>subscript</code>的语法类似于实例方法，计算属性，本质就是方法</p>
</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// demo1</span>
struct <span class="hljs-title class_">TimesTable</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">multiplier</span>: <span class="hljs-title class_">Int</span>

    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Int</span> {
        <span class="hljs-keyword">return</span> multiplier * index
    }
}

<span class="hljs-keyword">let</span> threeTimesTable = <span class="hljs-title class_">TimesTable</span>(<span class="hljs-attr">multiplier</span>: <span class="hljs-number">3</span>)
<span class="hljs-title function_">print</span>(threeTimesTable[<span class="hljs-number">6</span>])  <span class="hljs-comment">// 输出: 18</span>
    
<span class="hljs-comment">// demo2</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPoint</span> {
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0.0</span>
    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt;<span class="hljs-title class_">Double</span> {
        set {
            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> {
                x = newValue
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span> {
                y = newValue
            }
        }

        get {
            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">return</span> x
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> y
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        }
    }
}
 <span class="hljs-keyword">var</span> mmpoint = <span class="hljs-title class_">MyPoint</span>()
  mmpoint[<span class="hljs-number">0</span>] = <span class="hljs-number">11.1</span>
  mmpoint[<span class="hljs-number">1</span>] = <span class="hljs-number">22.2</span>

  <span class="hljs-title function_">print</span>(mmpoint.<span class="hljs-property">x</span>)
  <span class="hljs-title function_">print</span>(mmpoint.<span class="hljs-property">y</span>)
  <span class="hljs-title function_">print</span>(mmpoint[<span class="hljs-number">0</span>])
  <span class="hljs-title function_">print</span>(mmpoint[<span class="hljs-number">1</span>])
    
  <span class="hljs-comment">// dem3</span>
    struct <span class="hljs-title class_">Container</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">items</span>: [<span class="hljs-title class_">Int</span>] = []
    
    <span class="hljs-comment">// 单个整数下标</span>
    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Int</span> {
        <span class="hljs-keyword">return</span> items[index]
    }
    
    <span class="hljs-comment">// 范围下标</span>
    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">range</span>: <span class="hljs-title class_">Range</span>&lt;<span class="hljs-title class_">Int</span>&gt;) -&gt; [<span class="hljs-title class_">Int</span>] {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>(items[range])
    }
    
    <span class="hljs-comment">// 可变参数下标</span>
    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">indices</span>: <span class="hljs-title class_">Int</span>...) -&gt; [<span class="hljs-title class_">Int</span>] {
        <span class="hljs-keyword">return</span> indices.<span class="hljs-property">map</span> { items[$0] }
    }
}
</code></pre>
<blockquote>
<p><strong>1、subscript中定义的返回值类型决定了</strong><br/>
<strong>2、get方法的返回值类型 set方法中的newvalue的类型</strong></p>
<p><strong>3、subscript可以接受多个参数，并且类型任意</strong></p>
<p><strong>4、subscript可以没有set方法，但是必须要有get方法，如果只有get方法，可以省略get关键字</strong></p>
<p><strong>5、可以设置参数标签</strong></p>
<p><strong>6、下标可以是类型方法</strong></p>
</blockquote>
<h2 data-id="heading-6">三、swift中的迭代机制Sequence、collection、Iterator、AsyncSequence</h2>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e774473b08e495a8eaeaa39c18a3e1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bS95bS96ZW_6IKJ6IKJ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766733816&amp;x-signature=EinxcS3KZWK14Lg%2FbdKVKQgMGNM%3D" alt="image.png" width="70%" loading="lazy"/>
<p>在swift中，<code>Sequence</code>是一个协议，表示可以被逐一遍历的有序集合。一个符合<code>Sequence</code>协议的类型可以使用<code>for-in</code>循环迭代其所有元素。</p>
<p><code>Sequence</code>是swift集合类型（<code>Array，Dictionary、set</code>等）的基础协议，许多高级功能如：map、filter、 reduce都依赖于它</p>
<h4 data-id="heading-7">常见的 Sequence 类型</h4>
<p>许多 Swift 标准库类型都符合 Sequence 协议，例如：</p>
<p><strong><code>Array</code></strong>：一个有序的集合。</p>
<p><strong><code>Set</code></strong>：一个无序、唯一的集合。</p>
<p><strong><code>Dictionary</code></strong>：键值对集合。</p>
<p><strong><code>Range</code></strong>：连续的整数范围。</p>
<p><strong><code>String</code></strong>：一个字符序列。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/// Sequence的核心定义</span>
public protocol <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-comment">/// 表示序列中元素的类型。</span>
    associatedtype <span class="hljs-title class_">Element</span>
    associatedtype <span class="hljs-title class_">Iterator</span>: <span class="hljs-title class_">IteratorProtocol</span> where <span class="hljs-title class_">Iterator</span>.<span class="hljs-property">Element</span> == <span class="hljs-title class_">Element</span>
    <span class="hljs-comment">/// 返回一个迭代器对象，该对象遵循 IteratorProtocol 协议，并提供逐一访问元素的功能。</span>
    func <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-title class_">Iterator</span>
}

public protocol <span class="hljs-title class_">IteratorProtocol</span> {
    associatedtype <span class="hljs-title class_">Element</span>
    <span class="hljs-comment">/// 每次调用时返回序列的下一个元素；如果没有更多元素可用，则返回 nil。</span>
    mutating func <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-title class_">Element</span>?
}
</code></pre>
<p>总结：</p>
<p>1.<code>Sequence</code>只承诺“能生成迭代器”，不能保证反复便利，也不保证有count</p>
<p>2.迭代器几乎总是是<code>struct</code>：值语义保证“复制一份就从头开始”，不会意外共享状态</p>
<p>3.单趟序列完全合法；第二次<code>makeIterator()</code>可以返回空迭代器</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 可以创建自己的类型并使符合Sequence协议，只需要实现makeIterator()方法，并返回一个符合IteratorProtocol的迭代器</span>
<span class="hljs-comment">// 自定义一个从n倒数到0的序列</span>
struct <span class="hljs-attr">myCountDownDemo</span>: <span class="hljs-title class_">Sequence</span> {
    
    <span class="hljs-keyword">let</span> <span class="hljs-attr">start</span>: <span class="hljs-title class_">Int</span>
    func <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-title class_">Iterator</span> {
        <span class="hljs-title class_">Iterator</span>(<span class="hljs-attr">current</span>: start)
    }

    struct <span class="hljs-title class_">Iterator</span>: <span class="hljs-title class_">IteratorProtocol</span> {
        <span class="hljs-keyword">var</span> <span class="hljs-attr">current</span>: <span class="hljs-title class_">Int</span>
    
        mutating func <span class="hljs-title function_">nex</span>() -&gt; <span class="hljs-title class_">Int</span>? {
            guard current &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> {<span class="hljs-keyword">return</span> nil}
            defer {current -= <span class="hljs-number">1</span>}
            <span class="hljs-keyword">return</span> current
        }
    }
}
<span class="hljs-comment">// 调用了myArr.makeIterator()拿到一个迭代器 反复调用iterator.next() 返回的可选值解包后赋值给item</span>
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-title function_">myCountDownDemo</span>(<span class="hljs-params">start: <span class="hljs-number">3</span></span>) {
     <span class="hljs-title function_">print</span>(n)
}

<span class="hljs-keyword">let</span> myArr = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> myArr {
    <span class="hljs-title function_">print</span>(item)
}
<span class="hljs-comment">// for in 实际执行的是</span>
<span class="hljs-keyword">var</span> iterator = myArr.<span class="hljs-title function_">makeIterator</span>()
<span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> element = iterator.<span class="hljs-title function_">next</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">print</span>(element)
}
    
<span class="hljs-comment">// collection可以额外保证：多次遍历且顺序稳定，提供count、endIndex、下标访问，支持切片、前缀、后缀等默认实现</span>
<span class="hljs-comment">// 三种安全写法</span>

<span class="hljs-comment">// 方法一</span>
todoItems.<span class="hljs-property">removeAll</span>{$0 == <span class="hljs-string">"B"</span>}

<span class="hljs-comment">// 方法二 先记下索引，后删除</span>
<span class="hljs-keyword">let</span> indexsToRemove = todoItems.<span class="hljs-property">indices</span>.<span class="hljs-property">filter</span>{todoItems[$0] == <span class="hljs-string">"B"</span>}
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexsToRemove.<span class="hljs-title function_">reversed</span>(<span class="hljs-params"/>) {
    todoItems.<span class="hljs-title function_">remove</span>(<span class="hljs-attr">at</span>: i)
}

<span class="hljs-comment">// 方法三</span>
todoItems = todoItems.<span class="hljs-property">filter</span>{$0 != <span class="hljs-string">"B"</span>}
<span class="hljs-comment">//map</span>
<span class="hljs-keyword">var</span> numbersArr = [<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
<span class="hljs-keyword">let</span> squares = numbersArr.<span class="hljs-property">map</span>{$0 * $0}
<span class="hljs-title function_">print</span>(squares) <span class="hljs-comment">// 输出 [9,36,64]</span>

<span class="hljs-comment">// filter过滤列表中的元素</span>
<span class="hljs-keyword">let</span> eventNumbers = numbersArr.<span class="hljs-property">filter</span>{ $0 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>}
<span class="hljs-title function_">print</span>(eventNumbers) <span class="hljs-comment">// 输出[6，8]</span>

<span class="hljs-comment">// reduce将列表中所有元素组合成一个值</span>
<span class="hljs-keyword">let</span> sum = numbersArr.<span class="hljs-title function_">reduce</span>(<span class="hljs-number">0</span> , +)
<span class="hljs-title function_">print</span>(sum) <span class="hljs-comment">// 输出17</span>

<span class="hljs-comment">// forEach对列表中的每个元素执行操作</span>
numbersArr.<span class="hljs-property">forEach</span>{<span class="hljs-title function_">print</span>($0)}
</code></pre>





























<table><thead><tr><th>协议</th><th>核心能力</th><th>特点与限制</th><th>常见实现</th></tr></thead><tbody><tr><td><strong>IteratorProtocol</strong></td><td>通过 <code>next()</code> 方法<strong>单向、一次性地</strong>提供下一个元素<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4ba91e5c35b6" target="_blank" title="https://www.jianshu.com/p/4ba91e5c35b6" ref="nofollow noopener noreferrer"/><a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td><td>只进不退，遍历后即消耗<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4ba91e5c35b6" target="_blank" title="https://www.jianshu.com/p/4ba91e5c35b6" ref="nofollow noopener noreferrer"/>。是所有迭代的基础。</td><td>通常作为 <code>Sequence</code> 的一部分实现，很少直接使用。</td></tr><tr><td><strong>Sequence</strong></td><td>可进行<strong>顺序迭代</strong>（如 <code>for-in</code> 循环），支持 <code>map</code>、<code>filter</code>、<code>reduce</code> 等操作<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4ba91e5c35b6" target="_blank" title="https://www.jianshu.com/p/4ba91e5c35b6" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Facademy.realm.io%2Fcn%2Fposts%2Ftry-swift-soroush-khanlou-sequence-collection" target="_blank" title="https://academy.realm.io/cn/posts/try-swift-soroush-khanlou-sequence-collection" ref="nofollow noopener noreferrer"/><a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td><td><strong>不一定可多次遍历</strong>，不保证通过下标访问元素<a href="https://link.juejin.cn?target=https%3A%2F%2Facademy.realm.io%2Fcn%2Fposts%2Ftry-swift-soroush-khanlou-sequence-collection" target="_blank" title="https://academy.realm.io/cn/posts/try-swift-soroush-khanlou-sequence-collection" ref="nofollow noopener noreferrer"/><a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td><td>有限序列（如数组迭代器）、无限序列（如斐波那契数列生成器）<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4ba91e5c35b6" target="_blank" title="https://www.jianshu.com/p/4ba91e5c35b6" ref="nofollow noopener noreferrer"/><a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td></tr><tr><td><strong>Collection</strong></td><td>在 <code>Sequence</code> 基础上，<strong>可多次、非破坏性</strong>访问，并支持通过<strong>下标索引</strong>访问任意有效位置的元素<a href="https://link.juejin.cn?target=https%3A%2F%2Facademy.realm.io%2Fcn%2Fposts%2Ftry-swift-soroush-khanlou-sequence-collection" target="_blank" title="https://academy.realm.io/cn/posts/try-swift-soroush-khanlou-sequence-collection" ref="nofollow noopener noreferrer"/><a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td><td>必须是<strong>有限</strong>的，并且索引操作的时间复杂度有明确规定（如 <code>startIndex</code>、<code>endIndex</code>）<a href="https://juejin.cn/post/7034536528940367909" target="_blank" title="https://juejin.cn/post/7034536528940367909"/>。</td><td><strong>Array</strong>、<strong>String</strong>、<strong>Dictionary</strong>、<strong>Set</strong> 以及自定义的集合类型。</td></tr></tbody></table>
<h4 data-id="heading-8"><strong>AsyncSequence</strong>​ 是 Swift 并发模型的重要部分，特别适合处理：</h4>
<ul>
<li>异步数据流（网络请求、文件读取）</li>
<li>实时数据（传感器数据、消息推送）</li>
<li>分页或懒加载数据</li>
<li>长时间运行的数据生成任务</li>
</ul>
<p>而 <strong>Sequence</strong>​ 更适合：</p>
<ul>
<li>内存中的集合操作</li>
<li>同步数据处理</li>
<li>简单的数据转换</li>
</ul>
<p>选择依据：如果你的数据源是异步的或会产生延迟，使用 <strong>AsyncSequence</strong>；如果数据是同步可用的，使用 <strong>Sequence</strong>。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// demo1</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Foundation</span>

<span class="hljs-comment">// 自定义异步序列</span>
struct <span class="hljs-title class_">AsyncCountdown</span>: <span class="hljs-title class_">AsyncSequence</span> {
    typealias <span class="hljs-title class_">Element</span> = <span class="hljs-title class_">Int</span>
    
    <span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-title class_">Int</span>
    
    <span class="hljs-comment">// 必须实现 makeAsyncIterator()</span>
    func <span class="hljs-title function_">makeAsyncIterator</span>() -&gt; <span class="hljs-title class_">AsyncIterator</span> {
        <span class="hljs-title class_">AsyncIterator</span>(<span class="hljs-attr">count</span>: count)
    }
    
    <span class="hljs-comment">// 异步迭代器</span>
    struct <span class="hljs-title class_">AsyncIterator</span>: <span class="hljs-title class_">AsyncIteratorProtocol</span> {
        <span class="hljs-keyword">var</span> <span class="hljs-attr">count</span>: <span class="hljs-title class_">Int</span>
        
        <span class="hljs-comment">// 注意：next() 是异步的！</span>
        mutating func <span class="hljs-title function_">next</span>() <span class="hljs-keyword">async</span> -&gt; <span class="hljs-title class_">Int</span>? {
            guard count &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> nil }
            
            <span class="hljs-comment">// 模拟异步等待</span>
            <span class="hljs-keyword">await</span> <span class="hljs-title class_">Task</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">1_000_000_000</span>)  <span class="hljs-comment">// 等待1秒</span>
            
            <span class="hljs-keyword">let</span> value = count
            count -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> value
        }
    }
}

<span class="hljs-comment">// demo2</span>
<span class="hljs-comment">// 模拟从网络获取分页数据</span>
struct <span class="hljs-title class_">PaginatedAPISequence</span>: <span class="hljs-title class_">AsyncSequence</span> {
    typealias <span class="hljs-title class_">Element</span> = [<span class="hljs-title class_">String</span>]
    
    <span class="hljs-keyword">let</span> <span class="hljs-attr">totalPages</span>: <span class="hljs-title class_">Int</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">delay</span>: <span class="hljs-title class_">UInt64</span>
    
    func <span class="hljs-title function_">makeAsyncIterator</span>() -&gt; <span class="hljs-title class_">AsyncIterator</span> {
        <span class="hljs-title class_">AsyncIterator</span>(<span class="hljs-attr">totalPages</span>: totalPages, <span class="hljs-attr">delay</span>: delay)
    }
    
    struct <span class="hljs-title class_">AsyncIterator</span>: <span class="hljs-title class_">AsyncIteratorProtocol</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-attr">totalPages</span>: <span class="hljs-title class_">Int</span>
        <span class="hljs-keyword">let</span> <span class="hljs-attr">delay</span>: <span class="hljs-title class_">UInt64</span>
        <span class="hljs-keyword">var</span> currentPage = <span class="hljs-number">0</span>
        
        mutating func <span class="hljs-title function_">next</span>() <span class="hljs-keyword">async</span> throws -&gt; [<span class="hljs-title class_">String</span>]? {
            guard currentPage &lt; totalPages <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> nil }
            
            <span class="hljs-comment">// 模拟网络延迟</span>
            <span class="hljs-keyword">await</span> <span class="hljs-title class_">Task</span>.<span class="hljs-title function_">sleep</span>(delay)
            
            <span class="hljs-comment">// 模拟获取数据</span>
            <span class="hljs-keyword">let</span> items = (<span class="hljs-number">0.</span>.&lt;<span class="hljs-number">10</span>).<span class="hljs-property">map</span> { <span class="hljs-string">"Item \(currentPage * 10 + $0)"</span> }
            currentPage += <span class="hljs-number">1</span>
            
            <span class="hljs-keyword">return</span> items
        }
    }
}

<span class="hljs-comment">// 使用</span>
func <span class="hljs-title function_">fetchPaginatedData</span>() <span class="hljs-keyword">async</span> throws {
    <span class="hljs-keyword">let</span> pageSize = <span class="hljs-number">10</span>
    <span class="hljs-keyword">let</span> apiSequence = <span class="hljs-title class_">PaginatedAPISequence</span>(<span class="hljs-attr">totalPages</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">500_000_000</span>)
    
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> page <span class="hljs-keyword">in</span> apiSequence {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"收到页面数据: \(page.count) 条"</span>)
        <span class="hljs-comment">// 处理数据...</span>
    }
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[企微接口h5调用问题记录]]></title>    <link>https://juejin.cn/post/7585138968167301156</link>    <guid>https://juejin.cn/post/7585138968167301156</guid>    <pubDate>2025-12-19T07:45:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585138968167301156" data-draft-id="7585206549305458751" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="企微接口h5调用问题记录"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-19T07:45:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端小黑屋"/> <meta itemprop="url" content="https://juejin.cn/user/4476867078793198"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            企微接口h5调用问题记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4476867078793198/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端小黑屋
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:45:13.000Z" title="Fri Dec 19 2025 07:45:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">ww.register 配置和回调</h3>
<h4 data-id="heading-1">一种是getConfigSignature，一种是getAgentConfigSignature</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.work.weixin.qq.com%2Fdocument%2Fpath%2F94325" target="_blank" title="https://developer.work.weixin.qq.com/document/path/94325" ref="nofollow noopener noreferrer">ww.register</a> <strong>agentConfig的作用</strong>
config注入的是企业的身份与权限，而agentConfig注入的是应用的身份与权限。尤其是当调用者为第三方服务商时，通过config无法准确区分出调用者是哪个第三方应用，而在部分场景下，又必须严谨区分出第三方应用的身份，此时即需要通过agentConfig来注入应用的身份信息。</p>
<h3 data-id="heading-2">接口的权限配置</h3>
<p>ww.getCurExternalContact no permission
在企微的配置</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2dae89ccb49542b795c9466855b73621~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6buR5bGL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766735547&amp;x-signature=o7xeAOtUm9mXvpK4%2BBFB9CMEpwM%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">SDK 接口在 苹果和安卓的生效问题</h3>























<table><thead><tr><th align="left">函数</th><th align="left">安卓</th><th align="left">苹果</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">window.close</td><td align="left">不可用window.close， 需要通过 ww.closeWindow 才能关闭</td><td align="left">可以通过 window.close 关闭</td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.work.weixin.qq.com%2Fdocument%2Fpath%2F100598" target="_blank" title="https://developer.work.weixin.qq.com/document/path/100598" ref="nofollow noopener noreferrer">ww.closeWindow 关闭当前窗口</a></td></tr><tr><td align="left">ww.hideOptionMenu<br/>ww.hideMenuItems</td><td align="left">在安卓上无法隐藏 设置字体 和 refresh 刷新 的按钮</td><td align="left">在ios上可以隐藏刷新</td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.work.weixin.qq.com%2Fdocument%2Fpath%2F90541" target="_blank" title="https://developer.work.weixin.qq.com/document/path/90541" ref="nofollow noopener noreferrer">所有菜单 </a></td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🎉 TinySearchBox 重磅更新：支持 Vue2，一次满足我的所有需求！]]></title>    <link>https://juejin.cn/post/7585121055037653042</link>    <guid>https://juejin.cn/post/7585121055037653042</guid>    <pubDate>2025-12-19T07:48:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585121055037653042" data-draft-id="7585146584893472818" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🎉 TinySearchBox 重磅更新：支持 Vue2，一次满足我的所有需求！"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2025-12-19T07:48:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OpenTiny社区"/> <meta itemprop="url" content="https://juejin.cn/user/3808325101432983"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🎉 TinySearchBox 重磅更新：支持 Vue2，一次满足我的所有需求！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808325101432983/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OpenTiny社区
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T07:48:05.000Z" title="Fri Dec 19 2025 07:48:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>"一次编写，到处运行"</strong> —— 这次我们真的做到了！🎊</p>
</blockquote>
<h2 data-id="heading-0">📢 重大更新</h2>
<p>经过团队的努力，<strong>TinySearchBox</strong> 再度重构！采用全新的<strong>Renderless架构</strong>（实现原理下期给大家详细介绍），<strong>TinySearchBox</strong> 现在正式支持：</p>
<ul>
<li>✅ <strong>一套代码，两个版本</strong>， <strong>Vue 2</strong> 和 <strong>Vue 3</strong> 双版本支持</li>
</ul>
<p>这意味着什么？<strong>无论你的项目是 Vue 2 还是 Vue 3，TinySearchBox 都能完美适配！</strong></p>
<h2 data-id="heading-1">🚀 快速开始</h2>
<h3 data-id="heading-2">Vue 3 项目</h3>
<pre><code class="hljs language-bash" lang="bash">npm install @opentiny/vue-search-box@3.27.1
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;tiny-search-box v-model="tags" :items="items" /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'
import TinySearchBox from '@opentiny/vue-search-box'

const tags = ref([])
const items = ref([
  {
    label: '名称',
    field: 'name',
    options: [
      { label: '选项1' },
      { label: '选项2' }
    ]
  }
])
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-3">Vue 2 项目</h3>
<pre><code class="hljs language-bash" lang="bash">npm install @opentiny/vue-search-box@2.27.1
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;tiny-search-box v-model="tags" :items="items" /&gt;
&lt;/template&gt;

&lt;script&gt;
import TinySearchBox from '@opentiny/vue-search-box'

export default {
  components: {
    TinySearchBox
  },
  data() {
    return {
      tags: [],
      items: [
        {
          label: '名称',
          field: 'name',
          options: [
            { label: '选项1' },
            { label: '选项2' }
          ]
        }
      ]
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 data-id="heading-4">📦 版本说明</h2>
<h3 data-id="heading-5">包名和版本对应表</h3>























<table><thead><tr><th>包名</th><th>Vue 版本</th><th>主题风格</th><th>版本号</th></tr></thead><tbody><tr><td><code>@opentiny/vue-search-box</code></td><td>Vue 3</td><td>普通主题</td><td>3.27.1</td></tr><tr><td><code>@opentiny/vue-search-box</code></td><td>Vue 2</td><td>普通主题</td><td>2.27.1</td></tr></tbody></table>
<p><strong>选择指南</strong>：</p>
<ul>
<li>🎯 <strong>Vue 3 项目</strong>：使用 <code>3.27.1</code> 版本</li>
<li>🎯 <strong>Vue 2 项目</strong>：使用 <code>2.27.1</code> 版本</li>
</ul>
<h2 data-id="heading-6">🛠️ 技术实现：Renderless 架构</h2>
<h3 data-id="heading-7">🤔 为什么能做到"一套代码，两个版本"？</h3>
<p>答案就是：<strong>Renderless 架构</strong>！</p>
<h3 data-id="heading-8">核心思路</h3>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────┐
│     一套源代码 (src/)                │
│  - index<span class="hljs-selector-class">.ts</span> (入口)                  │
│  - pc<span class="hljs-selector-class">.vue</span> (模板)                    │
│  - renderless<span class="hljs-selector-class">.ts</span> (逻辑)             │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   构建时适配 (vite.config.*.ts)      │
│  - vue2<span class="hljs-selector-class">.ts</span> → Vue <span class="hljs-number">2</span> 构建             │
│  - vue3<span class="hljs-selector-class">.ts</span> → Vue <span class="hljs-number">3</span> 构建             │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   两个独立包 (dist/)                 │
│  - vue2/                            │
│  - vue3/                            │
└─────────────────────────────────────┘

</code></pre>
<h3 data-id="heading-9">关键技术点</h3>
<h4 data-id="heading-10">1. <strong>@opentiny/vue-common - 兼容层魔法</strong></h4>
<p><code>vue-common</code> 是核心兼容层，它：</p>
<ul>
<li>提供统一的 API（<code>defineComponent</code>、<code>setup</code>、<code>reactive</code> 等）</li>
<li>自动适配 Vue 2 和 Vue 3 的差异</li>
<li>让开发者无需关心底层实现</li>
</ul>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 在 renderless.ts 中</span>
<span class="hljs-keyword">import</span> { defineComponent, setup } <span class="hljs-keyword">from</span> <span class="hljs-string">'@opentiny/vue-common'</span>

<span class="hljs-comment">// 这个代码在 Vue 2 和 Vue 3 中都能运行！</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">renderless</span> = (<span class="hljs-params">props, hooks, context</span>) =&gt; {
  <span class="hljs-keyword">const</span> { reactive, computed, watch } = hooks
  <span class="hljs-comment">// ... 业务逻辑</span>
}
</code></pre>
<h4 data-id="heading-11">2. <strong>逻辑与模板分离</strong></h4>
<ul>
<li><strong>模板层</strong>（<code>pc.vue</code>）：只负责 UI 展示</li>
<li><strong>逻辑层</strong>（<code>renderless.ts</code>）：处理所有业务逻辑</li>
<li><strong>入口层</strong>（<code>index.ts</code>）：统一对外接口</li>
</ul>
<p>这样的设计让：</p>
<ul>
<li>逻辑可以在不同版本间复用</li>
<li>模板可以根据版本调整</li>
<li>代码组织更清晰</li>
</ul>
<h4 data-id="heading-12">3. <strong>构建时适配</strong></h4>
<p>通过不同的 Vite 配置，在构建时：</p>
<ul>
<li><strong>Vue 2 版本</strong>：使用 <code>vite-plugin-vue2</code> 和 Vue 2 运行时</li>
<li><strong>Vue 3 版本</strong>：使用 <code>@vitejs/plugin-vue</code> 和 Vue 3 运行时</li>
</ul>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// vite.config.vue2.ts</span>
<span class="hljs-keyword">import</span> vue2 <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-vue2'</span>
<span class="hljs-comment">// 使用 Vue 2 构建</span>

<span class="hljs-comment">// vite.config.vue3.ts</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
<span class="hljs-comment">// 使用 Vue 3 构建</span>
</code></pre>
<h4 data-id="heading-13">4. <strong>样式系统</strong></h4>
<ul>
<li><strong>普通主题</strong>：使用 Less，编译为 CSS</li>
</ul>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// theme/index.less - 普通主题</span>
<span class="hljs-selector-class">.tv-search-box</span> {
  <span class="hljs-comment">// 传统样式</span>
}
</code></pre>
<h2 data-id="heading-14">💡 实现方案详解</h2>
<h3 data-id="heading-15">方案架构图</h3>
<pre><code class="hljs language-bash" lang="bash">源代码层
├── src/
│   ├── index.ts          <span class="hljs-comment"># 组件入口</span>
│   ├── pc.vue            <span class="hljs-comment"># 模板（UI）</span>
│   ├── renderless.ts     <span class="hljs-comment"># 逻辑（业务）</span>
│   └── composables/      <span class="hljs-comment"># 功能模块</span>
│
构建配置层
├── vite.config.vue2.ts           <span class="hljs-comment"># Vue 2 构建</span>
└── vite.config.vue3.ts       <span class="hljs-comment"># Vue 3 构建</span>
│
样式层
└── theme/            <span class="hljs-comment"># 主题样式</span>
    └── index.less
│
输出层
└── dist/
    ├── vue2/            <span class="hljs-comment"># Vue 2 包</span>
    └── vue3/            <span class="hljs-comment"># Vue 3 包</span>

</code></pre>
<h3 data-id="heading-16">关键技术实现</h3>
<h4 data-id="heading-17">1. Renderless 架构</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">renderless</span> = (<span class="hljs-params">
  props,                    <span class="hljs-comment">// 组件属性</span>
  hooks,                    <span class="hljs-comment">// Vue 响应式 API（来自 vue-common）</span>
  context                   <span class="hljs-comment">// 上下文（emit, nextTick, vm 等）</span>
</span>) =&gt; {
  <span class="hljs-comment">// 业务逻辑</span>
  <span class="hljs-keyword">return</span> api                <span class="hljs-comment">// 返回给模板使用的 API</span>
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>hooks</code> 来自 <code>vue-common</code>，自动适配 Vue 2/3</li>
<li><code>context</code> 统一了 Vue 2/3 的差异（如 <code>emit</code>、<code>slots</code>）</li>
<li>返回的 <code>api</code> 对象会被注入到模板中</li>
</ul>
<h4 data-id="heading-18">2. 模板连接</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- pc.vue --&gt;
&lt;script lang="ts"&gt;
import { defineComponent, setup } from '@opentiny/vue-common'
import { renderless, api } from './renderless'

export default defineComponent({
  setup(props, context) {
    // 关键：通过 setup 连接 renderless
    return setup({ props, context, renderless, api })
  }
})
&lt;/script&gt;
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>setup</code> 函数来自 <code>vue-common</code></li>
<li>自动处理 Vue 2/3 的差异</li>
<li>将 <code>renderless</code> 返回的 API 注入到模板</li>
</ul>
<h2 data-id="heading-19">🎯 使用场景</h2>
<h3 data-id="heading-20">场景 1：Vue 2 老项目升级</h3>
<p><strong>问题</strong>：你的项目还在用 Vue 2，但想用现代化的搜索组件？</p>
<p><strong>解决方案</strong>：直接安装 Vue 2 版本！</p>
<pre><code class="hljs language-bash" lang="bash">npm install @opentiny/vue-search-box@2.27.1
</code></pre>
<p>无需升级 Vue，无需重构代码，<strong>开箱即用</strong>！</p>
<h3 data-id="heading-21">场景 2：Vue 3 新项目</h3>
<p><strong>问题</strong>：新项目想用最新的技术栈？</p>
<p><strong>解决方案</strong>：使用 Vue 3 版本！</p>
<pre><code class="hljs language-bash" lang="bash">npm install @opentiny/vue-search-box@3.27.1
</code></pre>
<p>享受 Vue 3 的性能优势和 Composition API！</p>
<h2 data-id="heading-22">🔥 核心优势</h2>
<h3 data-id="heading-23">1. <strong>真正的"一次编写，到处运行"</strong></h3>
<ul>
<li>✅ 一套源代码</li>
<li>✅ 两个构建版本</li>
<li>✅ 零代码差异</li>
</ul>
<h3 data-id="heading-24">2. <strong>完美的兼容性</strong></h3>
<ul>
<li>✅ Vue 2.6.14+ 支持</li>
<li>✅ Vue 3.x 支持</li>
<li>✅ TypeScript 支持</li>
<li>✅ 完整的类型定义</li>
</ul>
<h3 data-id="heading-25">3. <strong>灵活的主题系统</strong></h3>
<ul>
<li>✅ 主题：经典企业级风格</li>
<li>✅ 支持样式定制</li>
</ul>
<h3 data-id="heading-26">4. <strong>优秀的开发体验</strong></h3>
<ul>
<li>✅ 完整的 TypeScript 类型</li>
<li>✅ 详细的文档和示例</li>
<li>✅ 丰富的 API</li>
<li>✅ 活跃的社区支持</li>
</ul>
<h2 data-id="heading-27">📚 文档资源</h2>
<ul>
<li>📖 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopentiny.github.io%2Ftiny-search-box%2Fguide%2Fusage" target="_blank" title="https://opentiny.github.io/tiny-search-box/guide/usage" ref="nofollow noopener noreferrer">使用指南</a></li>
<li>💻 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopentiny.github.io%2Ftiny-search-box%2Fexamples%2Fbasic-usage" target="_blank" title="https://opentiny.github.io/tiny-search-box/examples/basic-usage" ref="nofollow noopener noreferrer">在线示例</a></li>
</ul>
<h2 data-id="heading-28">🎊 总结</h2>
<p><strong>TinySearchBox</strong> 现在真正做到了：</p>
<ul>
<li>🎯 <strong>Vue 2 和 Vue 3 全支持</strong> - 维护成本低，兼容性高</li>
<li>💪 <strong>Renderless 架构</strong> - 代码组织清晰，易于扩展</li>
</ul>
<p><strong>还在等什么？赶紧试试吧！</strong> 🎉</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Vue 3 项目</span>
npm install @opentiny/vue-search-box@3.27.1

<span class="hljs-comment"># Vue 2 项目</span>
npm install @opentiny/vue-search-box@2.27.1
</code></pre>
<h2 data-id="heading-29">🤝 贡献与反馈</h2>
<ul>
<li>🐛 发现问题？<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-search-box%2Fissues" target="_blank" title="https://github.com/opentiny/tiny-search-box/issues" ref="nofollow noopener noreferrer">提交 Issue</a></li>
<li>💡 有好的想法？<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-search-box%2Fpulls" target="_blank" title="https://github.com/opentiny/tiny-search-box/pulls" ref="nofollow noopener noreferrer">提交 PR</a></li>
<li>⭐ 觉得不错？给个 Star 吧！</li>
</ul>
<p><strong>Happy Coding! 🎉</strong></p>
<blockquote>
<p>记住：选择 TinySearchBox，就是选择了<strong>兼容性</strong>、<strong>灵活性</strong>和<strong>可维护性</strong>！</p>
</blockquote>
<h2 data-id="heading-30">关于OpenTiny</h2>
<p>欢迎加入 OpenTiny 开源社区。添加微信小助手：opentiny-official 一起参与交流前端技术～</p>
<p>OpenTiny 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopentiny.design" target="_blank" title="https://opentiny.design" ref="nofollow noopener noreferrer">opentiny.design</a><br/>
OpenTiny 代码仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny" target="_blank" title="https://github.com/opentiny" ref="nofollow noopener noreferrer">github.com/opentiny</a><br/>
TinyVue 源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank" title="https://github.com/opentiny/tiny-vue" ref="nofollow noopener noreferrer">github.com/opentiny/ti…</a><br/>
TinyEngine 源码： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank" title="https://github.com/opentiny/tiny-engine" ref="nofollow noopener noreferrer">github.com/opentiny/ti…</a></p>
<p>欢迎进入代码仓库 Star🌟TinyEngine、TinyVue、TinyNG、TinyCLI、TinyEditor~
如果你也想要共建，可以进入代码仓库，找到 good first issue 标签，一起参与开源贡献~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小程序直播挂件Pendant问题]]></title>    <link>https://juejin.cn/post/7585214391828135979</link>    <guid>https://juejin.cn/post/7585214391828135979</guid>    <pubDate>2025-12-19T08:01:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585214391828135979" data-draft-id="7585138968167333924" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小程序直播挂件Pendant问题"/> <meta itemprop="keywords" content="前端,微信小程序,直播"/> <meta itemprop="datePublished" content="2025-12-19T08:01:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端小黑屋"/> <meta itemprop="url" content="https://juejin.cn/user/4476867078793198"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小程序直播挂件Pendant问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4476867078793198/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端小黑屋
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T08:01:40.000Z" title="Fri Dec 19 2025 08:01:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">问题1: Taro 框架在 项目打包时有时会丢失值</h2>
<p>在项目中，Taro V3.5 运行打包命令后会有问题，Pendant组件的传值可能会失效</p>













<table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>type</td><td>默认为 0，可选<br/>0. 显示直播、预告、商品讲解、回放其中之一的挂件；<br/>1. 只显示直播的挂件；<br/>2. 只显示预告的挂件；<br/>3. 只显示商品讲解的挂件；<br/>4. 只显示回放的挂件</td></tr></tbody></table>
<p>我们项目需求是 type 为1时，只展示“直播中”这个类型的挂件；
代码中已经定义了 type 是 1，正常打包时，只在直播中才展示挂件，符合预期；
但是有时候打包出来，会展示回放内容，即此时 type 为 1 并没有传过去，取了默认值；</p>
<p>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fplatform-capabilities%2Findustry%2Fliveplayer%2Fpendant.html" target="_blank" title="https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/liveplayer/pendant.html" ref="nofollow noopener noreferrer">小程序直播挂件</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/408d5d62af12431d8dec4d55820741e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6buR5bGL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736100&amp;x-signature=1LDtWIya4JqpZ5R2GOgP0K0OcnE%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7194d8e8625e4a37a62576b0f86b4ce2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6buR5bGL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736100&amp;x-signature=Bt1fcD6WxK6H4QtFBANtKGnB8EQ%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-1">临时解决方案</h4>
<p>通过更新 LivePendant 组件的<strong>代码文件</strong>，触发重新编译或打包，此时可以有效解决</p>
<ol>
<li>增加 npm run append-space 脚本命令，每次打包前先在该文件最后添加空格</li>
<li>增加命令 <code>"build:weapp": "npm run append-space &amp; taro build --type weapp"</code>
触发重新打包，此时打包出来的文件 99%概率是正常的，但是如果再次运行打包，可能会出现异常。</li>
</ol>
<h3 data-id="heading-2">最终解决方案</h3>
<p>升级 Node 18 + Taro v3.6.31</p>
<h2 data-id="heading-3">问题2： iOS无法关闭直播小窗口</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52746fa9d5ef42d2aa6787d68c63a72a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5bCP6buR5bGL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766736100&amp;x-signature=JNJxHCuew8i96WCpKBuTMLaoeOY%3D" alt="image.png" loading="lazy"/></p>
<ol>
<li>
<p>Pendanet 组件参数设置失效：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fcommunity%2Fdevelop%2Fdoc%2F0006c4dbd305f8030851f41046b800" target="_blank" title="https://developers.weixin.qq.com/community/develop/doc/0006c4dbd305f8030851f41046b800" ref="nofollow noopener noreferrer">close-picture-in-picture-mode参数设置在iOS上不生效</a></p>
</li>
<li>
<p>在直播链接后的参数也不生效：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fcommunity%2Fdevelop%2Fdoc%2F0002ce5ce287c03c19a3370676bc00" target="_blank" title="https://developers.weixin.qq.com/community/develop/doc/0002ce5ce287c03c19a3370676bc00" ref="nofollow noopener noreferrer">直播跳转的链接在ios 环境有些参数不生效</a></p>
</li>
</ol>
<p>以上均是iOS端出现的问题，需要微信APP修复，但官方未有任何的修改回复</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[给你的Ida插上翅膀]]></title>    <link>https://juejin.cn/post/7585206349748092980</link>    <guid>https://juejin.cn/post/7585206349748092980</guid>    <pubDate>2025-12-19T06:42:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585206349748092980" data-draft-id="7585180150250930191" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="给你的Ida插上翅膀"/> <meta itemprop="keywords" content="安全,逆向"/> <meta itemprop="datePublished" content="2025-12-19T06:42:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="奋飞安全"/> <meta itemprop="url" content="https://juejin.cn/user/3148642844684638"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            给你的Ida插上翅膀
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3148642844684638/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    奋飞安全
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-19T06:42:53.000Z" title="Fri Dec 19 2025 06:42:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-19
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、目标</h2>
<p>“小x同学，把0x1011218f 的函数中的花指令去除掉”。</p>
<p>最近飞哥已经陷入到AI中无法自拔，感觉以后古法分析都快要成非遗了，以后的标题都得是"传承三十年，古法纯手工去花指令，定位关键算法"。</p>
<h2 data-id="heading-1">二、步骤</h2>
<h3 data-id="heading-2">你的Ida Python在哪里？</h3>
<p>首先你得知道你的ida python是谁？ 在哪里？</p>
<p>原则一，不要用系统的python，不然你乱七八糟装一堆包，把系统的python干坏了，就废了，最好创建一个虚拟环境，这个python只给ida用</p>
<p>/Applications/IDA Professional 9.1.app/Contents/MacOS</p>
<p>目录下面找到 idapyswitch</p>
<pre><code class="hljs language-bash" lang="bash">fenfei@fenfei-Mac-Studio MacOS % ./idapyswitch 
The following Python installations were found:
    <span class="hljs-comment">#0: 3.13.0 ('') (/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/Python)</span>
    <span class="hljs-comment">#1: 3.12.0 ('') (/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/Python)</span>
    <span class="hljs-comment">#2: 3.11.0 ('') (/opt/homebrew/Cellar/python@3.11/3.11.12/Frameworks/Python.framework/Versions/3.11/Python)</span>
    <span class="hljs-comment">#3: 3.10.0 ('') (/opt/homebrew/Cellar/python@3.10/3.10.17/Frameworks/Python.framework/Versions/3.10/Python)</span>
    <span class="hljs-comment">#4: 3.9.0 ('') (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Python3)</span>
    <span class="hljs-comment">#5: 3.9.0 ('') (/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/Python3)</span>
Please pick a number between 0 and 5 (default: 0)
</code></pre>
<p>可以看到 我现在ida 用的是 py3.13</p>
<p>然后使用 conda 装个虚拟环境，然后里面也装python3.13</p>
<pre><code class="hljs language-bash" lang="bash">conda create -n ida_env python=3.13
</code></pre>
<p>修改
/Applications/IDA Professional 9.1.app/Contents/MacOS/python/init.py</p>
<p>增加一行
sys.path.append("/opt/miniconda3/envs/ida_env/lib/python3.13/site-packages")</p>
<p>恭喜你，从此以后你的ida python就专款专用了</p>
<p><strong>💡 TIP</strong><br/>
从ida  File -&gt; Script command... 执行
import sys
print(sys.path)</p>
<p>可以确认一下你的配置是否正确，</p>
<h3 data-id="heading-3">插上翅膀</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmrexodia%2Fida-pro-mcp" target="_blank" title="https://github.com/mrexodia/ida-pro-mcp" ref="nofollow noopener noreferrer">github.com/mrexodia/id…</a></p>
<p>mcp是什么？这个得问ai</p>
<p>MCP 一般指的是 Model Context Protocol（模型上下文协议）。</p>
<p>一句话版理解（先看这个）</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">MCP</span> = 给 AI 规定的一套“插件 / 外挂接口标准”
</code></pre>
<p>就像：</p>
<ul>
<li>USB 是硬件接口标准</li>
<li>HTTP 是网络接口标准</li>
<li>MCP 是 AI 调用外部能力的接口标准</li>
</ul>
<p>其实你就理解成，ida mcp 可以让AI ide 直接操作你的ida</p>
<p>我们开始安装 ida mcp</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 进入ida专用py环境</span>
conda activate ida_env
pip uninstall ida-pro-mcp
pip install https://github.com/mrexodia/ida-pro-mcp/archive/refs/heads/main.zip
ida-pro-mcp --install
</code></pre>
<p>ok了， 安装完毕， 打开 ida ，找个样本反编译，然后 Edit -&gt; Plugins -&gt; MCP</p>
<pre><code class="hljs language-bash" lang="bash">[MCP] Server started:
  Streamable HTTP: http://127.0.0.1:13337/mcp
  SSE: http://127.0.0.1:13337/sse
  Config: http://127.0.0.1:13337/config.html
</code></pre>
<p>这就是启动成功，</p>
<p><strong>💡 TIP</strong><br/>
有时候端口会是  13338 ,根据实际情况配置 AI IDE</p>
<h3 data-id="heading-4">配置AI IDE</h3>
<p>打开你常用的 AI IDE， 包括不限于 Cursor / CodeGeeX / Trae / Codebuddy</p>
<p>配置 MCP</p>
<pre><code class="hljs language-bash" lang="bash">{<span class="hljs-string">"mcpServers"</span>:{<span class="hljs-string">"ida"</span>:{<span class="hljs-string">"transport"</span>:<span class="hljs-string">"sse"</span>,<span class="hljs-string">"url"</span>:<span class="hljs-string">"http://127.0.0.1:13337/sse"</span>,<span class="hljs-string">"alwaysAllow"</span>:[<span class="hljs-string">"idb_meta"</span>,<span class="hljs-string">"list_funcs"</span>,<span class="hljs-string">"disasm"</span>,<span class="hljs-string">"decompile"</span>,<span class="hljs-string">"lookup_funcs"</span>,<span class="hljs-string">"analyze_funcs"</span>,<span class="hljs-string">"get_bytes"</span>]}}}
</code></pre>
<p>出来这个效果</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ebe25d8097e436f9efee081bd5e185d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWL6aOe5a6J5YWo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766731373&amp;x-signature=PBKSNAWMURJJalZbO6fSe2R5uHw%3D" alt="idamcp" loading="lazy"/></p>
<p>可以开始了</p>
<pre><code class="hljs language-bash" lang="bash">
从ida mcp中，请把 0x101159B88 函数的花指令去掉

从ida mcp中，请帮我分析一下 xid 是如何生成的， 生成frida hook 脚本 跟踪一下。

</code></pre>
<p>嗯 真香</p>
<h2 data-id="heading-5">三、总结</h2>
<p>感觉ai进步了，以前红极一时的 AI Prompt 没那么重要了，反正我说的 AI 基本都能听懂。</p>
<p>古法纯手工还有没有意义？ 有个网友说过 <strong>你不会的别指望 ai 会，你能用 ai 搞出来是因为你会</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/165a3aa8d9264f9391111cfa154b70c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWL6aOe5a6J5YWo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766731373&amp;x-signature=oqmeVu%2B5R1N0uZymREVFEH4eFzI%3D" alt="ffshow" loading="lazy"/>
<strong>插上翅膀的人是天使，插上翅膀的老鼠是蝙蝠</strong></p>
<p><strong>💡 TIP</strong><br/>
: 本文的目的只有一个就是学习更多的逆向技巧和思路，如果有人利用本文技术去进行非法商业获取利益带来的法律责任都是操作者自己承担，和本文以及作者没关系.</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++程序崩溃时内存泄漏的真相]]></title>    <link>https://juejin.cn/post/7585022810180550719</link>    <guid>https://juejin.cn/post/7585022810180550719</guid>    <pubDate>2025-12-18T11:29:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585022810180550719" data-draft-id="7585031571889700907" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++程序崩溃时内存泄漏的真相"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-18T11:29:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++程序崩溃时内存泄漏的真相
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T11:29:12.000Z" title="Thu Dec 18 2025 11:29:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>想象这样一个场景：你的C++程序在运行过程中突然崩溃了——可能是段错误、除零异常，或是某个未处理的异常。程序申请的大量堆内存还未来得及释放。作为一名负责任的程序员，你不禁要问：这些内存算泄漏了吗？它们还能被系统回收重用吗？更重要的是，我们该如何防止这种情况发生？</p>
<p>本文将深入探讨这个问题的本质，并提供一套完整的防护策略。</p>
<h2 data-id="heading-0">第一部分：崩溃时的内存处理</h2>
<h3 data-id="heading-1">虚拟内存系统的基本原理</h3>
<p>现代操作系统使用虚拟内存系统为每个进程提供独立的地址空间。当程序分配内存时，实际发生的是虚拟地址到物理页的映射。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    subgraph "进程A的视角"
        A1[代码段]
        A2[数据段]
        A3[堆段 - 分配的内存]
        A4[栈段]
        A5[共享库]
    end
    
    subgraph "进程B的视角"
        B1[代码段]
        B2[数据段]
        B3[堆段]
        B4[栈段]
        B5[共享库]
    end
    
    subgraph "操作系统内核"
        MMU[内存管理单元 MMU]
        PT[页表 Page Tables]
    end
    
    subgraph "物理内存"
        P1[页框 1]
        P2[页框 2]
        P3[页框 3]
        P4[页框 4]
        P5[页框 5]
    end
    
    A3 --&gt; MMU
    B3 --&gt; MMU
    MMU --&gt; PT
    PT --&gt; P3
    PT --&gt; P5
</code></pre>
<p><strong>上图展示了关键概念</strong>：每个进程拥有独立的虚拟地址空间，通过MMU和页表映射到物理内存。当进程终止时，操作系统只需要清除页表项，物理页就可以被重用。</p>
<h3 data-id="heading-2">操作系统视角：内存管理的双重标准</h3>
<p><strong>从程序员的角度看</strong>，这无疑是内存泄漏——程序未能遵循"谁申请谁释放"的基本原则。但在操作系统层面，情况则完全不同。</p>
<p>现代操作系统为每个进程维护独立的虚拟地址空间。当进程崩溃时，操作系统内核会执行以下清理操作：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 操作系统内核的伪代码逻辑</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">terminate_process</span><span class="hljs-params">(Process* proc)</span> </span>{
    <span class="hljs-comment">// 1. 释放所有用户态堆内存</span>
    <span class="hljs-built_in">release_user_heap_memory</span>(proc-&gt;heap);
    
    <span class="hljs-comment">// 2. 释放虚拟地址空间</span>
    <span class="hljs-built_in">free_page_tables</span>(proc-&gt;page_tables);
    
    <span class="hljs-comment">// 3. 释放其他系统资源</span>
    <span class="hljs-built_in">close_all_handles</span>(proc-&gt;handles);
    <span class="hljs-built_in">release_locks</span>(proc-&gt;locks);
    
    <span class="hljs-comment">// 4. 从进程表中移除</span>
    <span class="hljs-built_in">remove_from_process_table</span>(proc);
}
</code></pre>
<h3 data-id="heading-3">内存回收的时间线</h3>
<p>让我们通过时间线理解内存的完整生命周期：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">timeline
    title 内存生命周期与崩溃影响
    section 正常流程
        程序启动 : 进程创建虚拟地址空间
        内存申请 : new/malloc调用系统API
        内存使用 : 读写操作
        内存释放 : delete/free归还内存
        程序退出 : 系统回收剩余资源
    
    section 崩溃流程
        程序启动 : 进程创建虚拟地址空间
        内存申请 : new/malloc调用系统API
        内存使用 : 读写操作
        发生崩溃 : 段错误/除零等
        系统接管 : 内核终止进程
        强制回收 : 释放所有进程资源
</code></pre>
<h3 data-id="heading-4">不同类型资源的行为差异</h3>
<p>并非所有资源在崩溃时的表现都相同：</p>















































<table><thead><tr><th>资源类型</th><th>崩溃后是否自动释放</th><th>潜在风险</th><th>清理机制</th></tr></thead><tbody><tr><td>普通堆内存</td><td>✅ 是</td><td>无</td><td>操作系统自动回收</td></tr><tr><td>内存映射文件</td><td>✅ 是</td><td>文件可能处于不一致状态</td><td>系统取消映射</td></tr><tr><td>共享内存</td><td>❌ 否</td><td>持久化存在直到显式删除</td><td>需要shm_unlink</td></tr><tr><td>文件句柄</td><td>✅ 是</td><td>可能延迟关闭</td><td>内核强制关闭</td></tr><tr><td>互斥锁/信号量</td><td>⚠️ 部分</td><td>可能保持锁定状态</td><td>取决于系统实现</td></tr><tr><td>网络连接</td><td>✅ 是</td><td>TCP连接会超时关闭</td><td>发送RST包</td></tr></tbody></table>
<h2 data-id="heading-5">第二部分：崩溃泄漏的实际影响</h2>
<h3 data-id="heading-6">短期影响 vs 长期影响</h3>
<p><strong>短期影响（进程存活时）：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaking_function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span>* memory_block1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];  <span class="hljs-comment">// 泄漏点1</span>
    <span class="hljs-keyword">if</span> (some_condition) {
        <span class="hljs-type">int</span>* memory_block2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">200</span>];  <span class="hljs-comment">// 泄漏点2</span>
        <span class="hljs-built_in">crash_here</span>();  <span class="hljs-comment">// 在此处崩溃</span>
        <span class="hljs-keyword">delete</span>[] memory_block2;  <span class="hljs-comment">// 永远不会执行</span>
    }
    <span class="hljs-keyword">delete</span>[] memory_block1;  <span class="hljs-comment">// 永远不会执行</span>
}

<span class="hljs-comment">// 此时内存仍在进程的堆中，无法被同一进程的其他部分重用</span>
</code></pre>
<p><strong>长期影响（进程终止后）：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 程序A崩溃后</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">program_A</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">char</span>* big_memory = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];  <span class="hljs-comment">// 100MB</span>
    <span class="hljs-built_in">cause_segfault</span>();  <span class="hljs-comment">// 崩溃</span>
}

<span class="hljs-comment">// 程序B可以安全使用这些内存</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">program_B</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 操作系统已将程序A的内存标记为可用</span>
    <span class="hljs-comment">// 新的分配请求可能重用这些物理页</span>
    <span class="hljs-type">char</span>* reused_memory = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>];
}
</code></pre>
<h3 data-id="heading-7">隐藏的危险：资源泄漏的连锁反应</h3>
<p>尽管操作系统会回收内存，但某些资源泄漏可能导致更严重的问题：</p>
<ol>
<li><strong>文件系统锁泄漏</strong></li>
</ol>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_file</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"critical.lock"</span>, std::ios::binary)</span></span>;
    file.<span class="hljs-built_in">write</span>(<span class="hljs-string">"LOCKED"</span>, <span class="hljs-number">6</span>);
    file.<span class="hljs-built_in">flush</span>();
    
    <span class="hljs-comment">// 如果在这里崩溃，文件可能保持打开状态</span>
    <span class="hljs-comment">// 其他进程无法访问该文件</span>
    <span class="hljs-built_in">risky_operation</span>();
    
    <span class="hljs-comment">// 正常关闭</span>
    file.<span class="hljs-built_in">close</span>();
    std::<span class="hljs-built_in">remove</span>(<span class="hljs-string">"critical.lock"</span>);
}
</code></pre>
<ol start="2">
<li><strong>数据库事务未提交</strong></li>
</ol>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_database</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">begin_transaction</span>();
    <span class="hljs-built_in">execute_query</span>(<span class="hljs-string">"UPDATE accounts SET balance = balance - 100 WHERE id = 1"</span>);
    
    <span class="hljs-comment">// 崩溃！事务未提交也未回滚</span>
    <span class="hljs-built_in">crash_somehow</span>();
    
    <span class="hljs-comment">// 数据库可能保持锁定状态</span>
    <span class="hljs-built_in">commit_transaction</span>();  <span class="hljs-comment">// 永远不会执行</span>
}
</code></pre>
<h2 data-id="heading-8">第三部分：防护策略的多层防御体系</h2>
<h3 data-id="heading-9">第一层：RAII——C++的内存安全基石</h3>
<p><strong>Resource Acquisition Is Initialization（资源获取即初始化）</strong> 是C++防止资源泄漏的根本范式：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 传统危险方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">risky_operation</span><span class="hljs-params">()</span> </span>{
    Resource* res1 = <span class="hljs-built_in">acquire_resource</span>();
    Resource* res2 = <span class="hljs-built_in">acquire_resource</span>();  <span class="hljs-comment">// 可能抛出异常</span>
    
    <span class="hljs-comment">// 如果上面抛出异常，res1就泄漏了</span>
    <span class="hljs-built_in">use_resources</span>(res1, res2);
    
    <span class="hljs-built_in">release_resource</span>(res1);
    <span class="hljs-built_in">release_resource</span>(res2);  <span class="hljs-comment">// 可能永远不会执行</span>
}

<span class="hljs-comment">// RAII安全方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_operation</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 使用智能指针立即获得所有权</span>
    <span class="hljs-keyword">auto</span> res1 = std::<span class="hljs-built_in">unique_ptr</span>&lt;Resource&gt;(<span class="hljs-built_in">acquire_resource</span>());
    <span class="hljs-keyword">auto</span> res2 = std::<span class="hljs-built_in">unique_ptr</span>&lt;Resource&gt;(<span class="hljs-built_in">acquire_resource</span>());
    
    <span class="hljs-comment">// 即使抛出异常，栈展开时也会调用析构函数</span>
    <span class="hljs-built_in">use_resources</span>(res1.<span class="hljs-built_in">get</span>(), res2.<span class="hljs-built_in">get</span>());
    
    <span class="hljs-comment">// 不需要手动释放！</span>
}
</code></pre>
<h3 data-id="heading-10">第二层：智能指针的明智选择</h3>
<p>针对不同场景选择合适的智能指针：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 独占所有权，明确的生命周期</span>
    std::unique_ptr&lt;DatabaseConnection&gt; db_conn;
    
    <span class="hljs-comment">// 共享所有权，多个组件使用</span>
    std::shared_ptr&lt;Configuration&gt; config;
    
    <span class="hljs-comment">// 观察者，不拥有所有权</span>
    std::weak_ptr&lt;Cache&gt; cache_ref;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Application</span>() {
        <span class="hljs-comment">// 工厂函数确保异常安全</span>
        db_conn = Database::<span class="hljs-built_in">create_connection</span>();
        config = std::<span class="hljs-built_in">make_shared</span>&lt;Configuration&gt;();
        
        <span class="hljs-comment">// 即使构造函数中抛出异常，已分配的资源也会自动释放</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_data</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 局部智能指针</span>
        <span class="hljs-keyword">auto</span> buffer = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(BUFFER_SIZE);
        
        <span class="hljs-comment">// 将所有权传递给函数</span>
        <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">transform_data</span>(std::<span class="hljs-built_in">move</span>(buffer));
        
        <span class="hljs-comment">// buffer现在为空，result拥有内存所有权</span>
        <span class="hljs-comment">// 如果这里崩溃，result的析构函数会被调用</span>
    }
};
</code></pre>
<h3 data-id="heading-11">第三层：异常安全的代码设计</h3>
<p>遵循异常安全的基本保证：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionSafeResourceManager</span> {
    std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; resources;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 基本保证：发生异常时，对象处于有效状态</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_resource</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> new_res = std::<span class="hljs-built_in">make_unique</span>&lt;Resource&gt;();
        
        <span class="hljs-comment">// 先完成所有可能失败的操作</span>
        new_res-&gt;<span class="hljs-built_in">initialize</span>();
        
        <span class="hljs-comment">// 只有这时才修改状态</span>
        resources.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(new_res));
    }
    
    <span class="hljs-comment">// 强保证：要么成功，要么完全回滚</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transactional_update</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 创建所有新资源</span>
        <span class="hljs-keyword">auto</span> new_res1 = std::<span class="hljs-built_in">make_unique</span>&lt;Resource&gt;();
        <span class="hljs-keyword">auto</span> new_res2 = std::<span class="hljs-built_in">make_unique</span>&lt;Resource&gt;();
        
        new_res1-&gt;<span class="hljs-built_in">initialize</span>();
        new_res2-&gt;<span class="hljs-built_in">initialize</span>();
        
        <span class="hljs-comment">// 准备回滚点</span>
        <span class="hljs-keyword">auto</span> old_resources = std::<span class="hljs-built_in">move</span>(resources);
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 替换资源</span>
            resources.<span class="hljs-built_in">clear</span>();
            resources.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(new_res1));
            resources.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(new_res2));
            
            <span class="hljs-comment">// 提交，如果失败则catch中恢复</span>
        } <span class="hljs-built_in">catch</span> (...) {
            <span class="hljs-comment">// 恢复旧状态</span>
            resources = std::<span class="hljs-built_in">move</span>(old_resources);
            <span class="hljs-keyword">throw</span>;
        }
    }
};
</code></pre>
<h3 data-id="heading-12">第四层：信号处理与优雅终止</h3>
<p>捕获致命信号进行清理：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmergencyCleanup</span> {
    <span class="hljs-type">static</span> std::vector&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; cleanup_handlers;
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> cleanup_done;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">register_handler</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; handler)</span> </span>{
        cleanup_handlers.<span class="hljs-built_in">push_back</span>(handler);
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">emergency_cleanup</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (cleanup_done) <span class="hljs-keyword">return</span>;
        cleanup_done = <span class="hljs-literal">true</span>;
        
        std::cerr &lt;&lt; <span class="hljs-string">"\n=== 执行紧急清理 ==="</span> &lt;&lt; std::endl;
        
        <span class="hljs-comment">// 逆序清理（后进先出）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = cleanup_handlers.<span class="hljs-built_in">rbegin</span>(); 
             it != cleanup_handlers.<span class="hljs-built_in">rend</span>(); ++it) {
            <span class="hljs-keyword">try</span> {
                (*it)();
            } <span class="hljs-built_in">catch</span> (...) {
                <span class="hljs-comment">// 忽略清理过程中的异常</span>
            }
        }
        
        std::cerr &lt;&lt; <span class="hljs-string">"=== 清理完成 ==="</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// RAII包装器，自动注册</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedHandler</span> {
        std::function&lt;<span class="hljs-type">void</span>()&gt; handler;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">ScopedHandler</span>(std::function&lt;<span class="hljs-built_in">void</span>()&gt; h) : <span class="hljs-built_in">handler</span>(h) {
            <span class="hljs-built_in">register_handler</span>(h);
        }
        
        ~<span class="hljs-built_in">ScopedHandler</span>() {
            <span class="hljs-comment">// 正常退出时也需要清理</span>
            <span class="hljs-keyword">if</span> (!cleanup_done) {
                <span class="hljs-keyword">try</span> { <span class="hljs-built_in">handler</span>(); } <span class="hljs-built_in">catch</span> (...) {}
            }
        }
    };
};

<span class="hljs-comment">// 信号处理函数</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>{
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* signal_name = <span class="hljs-literal">nullptr</span>;
    
    <span class="hljs-keyword">switch</span>(sig) {
        <span class="hljs-keyword">case</span> SIGSEGV: signal_name = <span class="hljs-string">"SIGSEGV (段错误)"</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> SIGFPE: signal_name = <span class="hljs-string">"SIGFPE (算术异常)"</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> SIGILL: signal_name = <span class="hljs-string">"SIGILL (非法指令)"</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> SIGABRT: signal_name = <span class="hljs-string">"SIGABRT (程序中止)"</span>; <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>: signal_name = <span class="hljs-string">"未知信号"</span>; <span class="hljs-keyword">break</span>;
    }
    
    std::cerr &lt;&lt; <span class="hljs-string">"\n⚠️  接收到信号: "</span> &lt;&lt; signal_name 
              &lt;&lt; <span class="hljs-string">" ("</span> &lt;&lt; sig &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 执行紧急清理</span>
    EmergencyCleanup::<span class="hljs-built_in">emergency_cleanup</span>();
    
    <span class="hljs-comment">// 恢复默认处理并重新抛出</span>
    <span class="hljs-built_in">signal</span>(sig, SIG_DFL);
    <span class="hljs-built_in">raise</span>(sig);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_signal_handlers</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">signal</span>(SIGSEGV, signal_handler);
    <span class="hljs-built_in">signal</span>(SIGFPE, signal_handler);
    <span class="hljs-built_in">signal</span>(SIGILL, signal_handler);
    <span class="hljs-built_in">signal</span>(SIGABRT, signal_handler);
    <span class="hljs-comment">// 注意：SIGKILL和SIGSTOP不能被捕获</span>
}
</code></pre>
<h3 data-id="heading-13">第五层：进程隔离与沙箱模式</h3>
<p>将可能崩溃的代码隔离到子进程中：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">IsolatedProcess</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;
    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">run</span><span class="hljs-params">(Func&amp;&amp; func)</span> -&gt; std::optional&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(func())</span>&gt; </span>{
        <span class="hljs-comment">// 创建管道用于结果通信</span>
        <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipefd) == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"创建管道失败"</span>);
        }
        
        <span class="hljs-type">pid_t</span> pid = fork();
        
        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// 子进程</span>
            <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭读端</span>
            
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">func</span>();
                
                <span class="hljs-comment">// 序列化结果</span>
                std::ostringstream oss;
                <span class="hljs-comment">// 这里需要根据实际类型实现序列化</span>
                <span class="hljs-comment">// write_result_to_stream(oss, result);</span>
                
                std::string serialized = oss.<span class="hljs-built_in">str</span>();
                <span class="hljs-type">size_t</span> size = serialized.<span class="hljs-built_in">size</span>();
                
                <span class="hljs-comment">// 发送结果大小</span>
                <span class="hljs-built_in">write</span>(pipefd[<span class="hljs-number">1</span>], &amp;size, <span class="hljs-built_in">sizeof</span>(size));
                <span class="hljs-comment">// 发送结果数据</span>
                <span class="hljs-built_in">write</span>(pipefd[<span class="hljs-number">1</span>], serialized.<span class="hljs-built_in">data</span>(), size);
                
                <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
                _exit(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 使用_exit避免atexit处理</span>
                
            } <span class="hljs-built_in">catch</span> (...) {
                <span class="hljs-comment">// 子进程中的异常，通过特殊值表示</span>
                <span class="hljs-type">size_t</span> error_marker = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">-1</span>);
                <span class="hljs-built_in">write</span>(pipefd[<span class="hljs-number">1</span>], &amp;error_marker, <span class="hljs-built_in">sizeof</span>(error_marker));
                <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);
                _exit(<span class="hljs-number">1</span>);
            }
            
        } <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 父进程</span>
            <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 关闭写端</span>
            
            <span class="hljs-type">int</span> status;
            <span class="hljs-built_in">waitpid</span>(pid, &amp;status, <span class="hljs-number">0</span>);
            
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WIFEXITED</span>(status) &amp;&amp; <span class="hljs-built_in">WEXITSTATUS</span>(status) == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 读取结果</span>
                <span class="hljs-type">size_t</span> result_size;
                <span class="hljs-built_in">read</span>(pipefd[<span class="hljs-number">0</span>], &amp;result_size, <span class="hljs-built_in">sizeof</span>(result_size));
                
                <span class="hljs-keyword">if</span> (result_size != <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">-1</span>)) {
                    <span class="hljs-function">std::string <span class="hljs-title">serialized</span><span class="hljs-params">(result_size, <span class="hljs-string">'\0'</span>)</span></span>;
                    <span class="hljs-built_in">read</span>(pipefd[<span class="hljs-number">0</span>], serialized.<span class="hljs-built_in">data</span>(), result_size);
                    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
                    
                    <span class="hljs-comment">// 反序列化结果</span>
                    <span class="hljs-comment">// return deserialize_result(serialized);</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"子进程执行失败"</span>);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);
                std::cerr &lt;&lt; <span class="hljs-string">"子进程异常终止"</span> &lt;&lt; std::endl;
                <span class="hljs-comment">// 父进程资源安全，可以继续运行</span>
            }
        }
        
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;
    }
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main_program</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 父进程保持安全</span>
    std::unique_ptr&lt;MainResource&gt; main_res = <span class="hljs-built_in">acquire_main_resource</span>();
    
    <span class="hljs-comment">// 危险操作在子进程中执行</span>
    <span class="hljs-keyword">auto</span> result = IsolatedProcess::<span class="hljs-built_in">run</span>([]() {
        std::unique_ptr&lt;DangerousResource&gt; danger = <span class="hljs-built_in">create_dangerous_resource</span>();
        <span class="hljs-keyword">return</span> danger-&gt;<span class="hljs-built_in">risky_operation</span>();  <span class="hljs-comment">// 可能崩溃</span>
    });
    
    <span class="hljs-comment">// 即使子进程崩溃，父进程继续运行</span>
    <span class="hljs-keyword">if</span> (result) {
        <span class="hljs-built_in">process_result</span>(*result);
    }
}
</code></pre>
<h3 data-id="heading-14">第六层：防御性编程与检查机制</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefensiveProgrammer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 边界检查</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;
    <span class="hljs-type">static</span> <span class="hljs-keyword">typename</span> Container::reference <span class="hljs-title">safe_access</span><span class="hljs-params">(
        Container&amp; container, 
        <span class="hljs-type">size_t</span> index,
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* context = <span class="hljs-literal">nullptr</span>)</span> </span>{
        
        <span class="hljs-keyword">if</span> (index &gt;= container.<span class="hljs-built_in">size</span>()) {
            std::string msg = <span class="hljs-string">"索引越界: "</span>;
            msg += std::<span class="hljs-built_in">to_string</span>(index);
            msg += <span class="hljs-string">" &gt;= "</span>;
            msg += std::<span class="hljs-built_in">to_string</span>(container.<span class="hljs-built_in">size</span>());
            <span class="hljs-keyword">if</span> (context) {
                msg += <span class="hljs-string">" (在 "</span>;
                msg += context;
                msg += <span class="hljs-string">" 中)"</span>;
            }
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(msg);  <span class="hljs-comment">// 抛出异常而非崩溃</span>
        }
        
        <span class="hljs-keyword">return</span> container[index];
    }
    
    <span class="hljs-comment">// 空指针检查</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">static</span> T* <span class="hljs-title">check_not_null</span><span class="hljs-params">(T* ptr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">nullptr</span>) {
            std::string msg = <span class="hljs-string">"空指针访问"</span>;
            <span class="hljs-keyword">if</span> (name) {
                msg += <span class="hljs-string">": "</span>;
                msg += name;
            }
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(msg);
        }
        <span class="hljs-keyword">return</span> ptr;
    }
    
    <span class="hljs-comment">// 资源使用检查点</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Checkpoint</span> {
        <span class="hljs-type">size_t</span> initial_memory_usage;
        std::vector&lt;std::string&gt; warnings;
        
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">Checkpoint</span>() {
            <span class="hljs-comment">// 记录初始状态</span>
            <span class="hljs-comment">// initial_memory_usage = get_current_memory_usage();</span>
        }
        
        ~<span class="hljs-built_in">Checkpoint</span>() {
            <span class="hljs-comment">// 检查资源泄漏</span>
            <span class="hljs-comment">// size_t current = get_current_memory_usage();</span>
            <span class="hljs-comment">// if (current &gt; initial_memory_usage + THRESHOLD) {</span>
            <span class="hljs-comment">//     log_warning("潜在的内存泄漏");</span>
            <span class="hljs-comment">// }</span>
            
            <span class="hljs-keyword">if</span> (!warnings.<span class="hljs-built_in">empty</span>()) {
                std::cerr &lt;&lt; <span class="hljs-string">"检查点警告:"</span> &lt;&lt; std::endl;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; w : warnings) {
                    std::cerr &lt;&lt; <span class="hljs-string">"  - "</span> &lt;&lt; w &lt;&lt; std::endl;
                }
            }
        }
        
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_warning</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; warning)</span> </span>{
            warnings.<span class="hljs-built_in">push_back</span>(warning);
        }
    };
};

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defensive_function</span><span class="hljs-params">()</span> </span>{
    DefensiveProgrammer::Checkpoint checkpoint;
    
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;
    
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 安全访问</span>
        <span class="hljs-type">int</span> value = DefensiveProgrammer::<span class="hljs-built_in">safe_access</span>(data, <span class="hljs-number">150</span>, <span class="hljs-string">"defensive_function"</span>);
        <span class="hljs-comment">// 不会执行到这里</span>
    } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span class="hljs-string">"捕获异常: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
        <span class="hljs-comment">// 优雅处理，而不是崩溃</span>
        checkpoint.<span class="hljs-built_in">add_warning</span>(e.<span class="hljs-built_in">what</span>());
    }
}
</code></pre>
<h2 data-id="heading-15">第四部分：实战架构设计模式</h2>
<h3 data-id="heading-16">模式1：事务性资源管理</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Resource&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionalResource</span> {
    std::unique_ptr&lt;Resource&gt; current;
    std::unique_ptr&lt;Resource&gt; backup;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">begin_transaction</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>{
        <span class="hljs-comment">// 创建新资源但不立即生效</span>
        backup = std::<span class="hljs-built_in">move</span>(current);
        current = std::<span class="hljs-built_in">make_unique</span>&lt;Resource&gt;(std::forward&lt;Args&gt;(args)...);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 提交事务，丢弃备份</span>
        backup.<span class="hljs-built_in">reset</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 回滚到之前的状态</span>
        current = std::<span class="hljs-built_in">move</span>(backup);
    }
    
    <span class="hljs-function">Resource&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!current) {
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"没有活动的资源"</span>);
        }
        <span class="hljs-keyword">return</span> *current;
    }
    
    <span class="hljs-comment">// 确保即使崩溃，资源也能被清理</span>
    ~<span class="hljs-built_in">TransactionalResource</span>() {
        <span class="hljs-comment">// 智能指针自动清理</span>
    }
};
</code></pre>
<h3 data-id="heading-17">模式2：资源所有权传递链</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OwnershipChain</span> {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        std::unique_ptr&lt;<span class="hljs-type">void</span>, <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>*)&gt; resource;
        std::unique_ptr&lt;Node&gt; next;
        
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deleter&gt;
        <span class="hljs-title">Node</span><span class="hljs-params">(T* ptr, Deleter d)</span> 
            : resource(ptr, [d](void* p) {</span> <span class="hljs-built_in">d</span>(<span class="hljs-built_in">static_cast</span>&lt;T*&gt;(p)); }) {}
    };
    
    std::unique_ptr&lt;Node&gt; head;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Deleter&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(T* resource, Deleter deleter)</span> </span>{
        <span class="hljs-keyword">auto</span> new_node = std::<span class="hljs-built_in">make_unique</span>&lt;Node&gt;(resource, deleter);
        new_node-&gt;next = std::<span class="hljs-built_in">move</span>(head);
        head = std::<span class="hljs-built_in">move</span>(new_node);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_all</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 逆序释放所有资源</span>
        <span class="hljs-keyword">while</span> (head) {
            head = std::<span class="hljs-built_in">move</span>(head-&gt;next);
        }
    }
    
    ~<span class="hljs-built_in">OwnershipChain</span>() {
        <span class="hljs-built_in">release_all</span>();
    }
    
    <span class="hljs-comment">// 防止拷贝</span>
    <span class="hljs-built_in">OwnershipChain</span>(<span class="hljs-type">const</span> OwnershipChain&amp;) = <span class="hljs-keyword">delete</span>;
    OwnershipChain&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> OwnershipChain&amp;) = <span class="hljs-keyword">delete</span>;
    
    <span class="hljs-comment">// 允许移动</span>
    <span class="hljs-built_in">OwnershipChain</span>(OwnershipChain&amp;&amp;) = <span class="hljs-keyword">default</span>;
    OwnershipChain&amp; <span class="hljs-keyword">operator</span>=(OwnershipChain&amp;&amp;) = <span class="hljs-keyword">default</span>;
};
</code></pre>
<h2 data-id="heading-18">第五部分：工具链支持</h2>
<h3 data-id="heading-19">静态分析工具配置</h3>
<pre><code class="hljs language-cmake" lang="cmake"># CMakeLists.txt中的配置示例
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
    # 启用所有警告
    add_compile_options(-Wall -Wextra -Wpedantic)
    
    # 内存相关警告
    add_compile_options(-Wmemory-leak)
    add_compile_options(-Wdelete-non-virtual-dtor)
    
    # 开启静态分析
    if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        add_compile_options(-fsanitize=address)
        add_compile_options(-fsanitize=leak)
        add_compile_options(-fsanitize=undefined)
    endif()
endif()

# 使用Clang-Tidy
find_program(CLANG_TIDY_EXE NAMES "clang-tidy")
if(CLANG_TIDY_EXE)
    set(CMAKE_CXX_CLANG_TIDY 
        "${CLANG_TIDY_EXE};-checks=*;-warnings-as-errors=*")
endif()
</code></pre>
<h3 data-id="heading-20">动态分析脚本</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># memory_check.sh</span>

<span class="hljs-comment"># 使用Valgrind检查内存泄漏</span>
valgrind --tool=memcheck \
         --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=<span class="hljs-built_in">yes</span> \
         --verbose \
         --log-file=valgrind-out.txt \
         ./my_program

<span class="hljs-comment"># 使用AddressSanitizer</span>
<span class="hljs-built_in">export</span> ASAN_OPTIONS=<span class="hljs-string">"detect_leaks=1:halt_on_error=0"</span>
./my_program_asan

<span class="hljs-comment"># 生成内存分析报告</span>
heaptrack ./my_program
heaptrack_print heaptrack.my_program.*.gz &gt; memory_report.txt
</code></pre>
<h2 data-id="heading-21">结论</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap
  root(防御性编程最佳实践)
    
    输入验证
      参数检查
        "验证所有函数参数"
        "检查null指针"
        "验证数值范围"
      数据验证
        "验证输入数据格式"
        "检查数据完整性"
        "消毒用户输入"
    
    内存安全
      分配安全
        "检查分配大小"
        "验证分配结果"
        "处理分配失败"
      访问安全
        "边界检查"
        "类型安全"
        "对齐检查"
      释放安全
        "避免双重释放"
        "跟踪所有权"
        "使用RAII"
    
    异常安全
      基本保证
        "确保不泄漏资源"
        "保持对象有效性"
        "允许状态改变"
      强保证
        "提交或回滚"
        "事务性操作"
        "异常中立"
      不抛保证
        "关键操作不抛异常"
        "使用noexcept"
        "简化错误处理"
    
    状态管理
      前置条件
        "验证操作前提"
        "检查对象状态"
        "验证环境条件"
      后置条件
        "验证操作结果"
        "检查不变量"
        "确保状态一致"
      不变式
        "维护类不变量"
        "验证数据完整性"
        "检查逻辑约束"
    
    资源管理
      获取即初始化
        "RAII模式"
        "构造函数中获取"
        "析构函数中释放"
      所有权明确
        "明确资源所有权"
        "使用智能指针"
        "避免共享所有权"
      生命周期管理
        "控制对象生命周期"
        "使用作用域管理"
        "及时释放资源"
</code></pre>
<p>通过本文的探讨，我们可以得出以下关键结论：</p>
<ol>
<li>
<p><strong>操作系统会回收崩溃进程的内存</strong>，但这不应成为代码质量低下的借口。</p>
</li>
<li>
<p><strong>RAII是C++内存安全的基石</strong>，应成为每个C++程序员的本能思维方式。</p>
</li>
<li>
<p><strong>多层防御策略</strong>比单一方案更有效：</p>
<ul>
<li>第一层：RAII和智能指针</li>
<li>第二层：异常安全设计</li>
<li>第三层：信号处理和优雅终止</li>
<li>第四层：进程隔离和沙箱</li>
<li>第五层：防御性编程</li>
</ul>
</li>
<li>
<p><strong>工具链的恰当使用</strong>可以提前发现潜在问题。</p>
</li>
</ol>
<p>最终，防止崩溃导致的内存泄漏不仅是技术问题，更是工程 discipline 的体现。优秀的C++程序员应该：</p>
<ul>
<li>默认使用智能指针而非裸指针</li>
<li>优先选择栈对象而非堆对象</li>
<li>为所有资源编写RAII包装器</li>
<li>设计异常安全的接口</li>
<li>使用静态和动态分析工具</li>
</ul>
<p>记住：操作系统会为你的崩溃"兜底"，但良好的编程习惯能让你的程序更加健壮、可维护。在资源管理和内存安全方面，永远不要依赖操作系统的清理机制，而是要确保你的代码在任何情况下都能正确管理自己的资源。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Mybatis Plus 主键生成器实现思路分析]]></title>    <link>https://juejin.cn/post/7584730804515291179</link>    <guid>https://juejin.cn/post/7584730804515291179</guid>    <pubDate>2025-12-18T04:07:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584730804515291179" data-draft-id="7584730804515258411" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Mybatis Plus 主键生成器实现思路分析"/> <meta itemprop="keywords" content="MyBatis,Spring Boot,数据库"/> <meta itemprop="datePublished" content="2025-12-18T04:07:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Jaising666"/> <meta itemprop="url" content="https://juejin.cn/user/2418581311850301"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Mybatis Plus 主键生成器实现思路分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2418581311850301/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Jaising666
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T04:07:05.000Z" title="Thu Dec 18 2025 04:07:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>上一篇我们看到了 <a href="https://juejin.cn/post/7510053996137611300" target="_blank" title="https://juejin.cn/post/7510053996137611300">Mybatis 拦截器在多租户场景下的使用</a>，这次继续看下在主键生成场景下的应用。</p>
<h2 data-id="heading-0">一、背景与问题</h2>
<p>在使用 MyBatis-Plus 开发时，通常使用 <code>@TableId(type = IdType.AUTO)</code> 注解来实现主键自动生成。这种方式依赖数据库的自增特性，在 MySQL 等主流数据库上运行良好。</p>
<p>然而，当项目迁移到 OpenGauss 数据库时，遇到了兼容性问题：</p>
<ul>
<li><strong>问题现象</strong>：INSERT 操作时 ID 字段为 NULL，导致插入失败</li>
<li><strong>根本原因</strong>：OpenGauss 使用 PostgreSQL 的序列（Sequence）机制，而非自增字段</li>
<li><strong>技术限制</strong>：OpenGauss 驱动对 MyBatis-Plus 的 <code>IdType.AUTO</code> 支持不完善</li>
</ul>
<h3 data-id="heading-1">数据库主键生成机制对比</h3>
<h4 data-id="heading-2">MySQL 自增主键 (AUTO_INCREMENT)</h4>
<p>MySQL 使用 <code>AUTO_INCREMENT</code> 属性实现主键自动生成：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- MySQL 表结构</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (
    id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)
);

<span class="hljs-comment">-- 插入时无需指定ID</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'张三'</span>);
<span class="hljs-comment">-- MySQL 自动生成 id = 1</span>
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>在表结构中定义自增属性</li>
<li>INSERT 时可以省略主键字段</li>
<li>数据库引擎自动分配递增的ID值</li>
<li>MyBatis-Plus 的 <code>IdType.AUTO</code> 直接支持</li>
</ul>
<h4 data-id="heading-3">PostgreSQL/OpenGauss 序列机制 (SEQUENCE)</h4>
<p>PostgreSQL 系列数据库使用序列对象生成主键：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建序列</span>
<span class="hljs-keyword">CREATE</span> SEQUENCE user_id_seq <span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> <span class="hljs-number">1</span> INCREMENT <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">-- 创建表（不使用AUTO_INCREMENT）</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (
    id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> nextval(<span class="hljs-string">'user_id_seq'</span>) <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)
);

<span class="hljs-comment">-- 插入方式1：使用默认值</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'张三'</span>);

<span class="hljs-comment">-- 插入方式2：显式调用序列</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, name) <span class="hljs-keyword">VALUES</span> (nextval(<span class="hljs-string">'user_id_seq'</span>), <span class="hljs-string">'李四'</span>);
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>序列是独立的数据库对象，与表分离</li>
<li>需要显式调用 <code>nextval()</code> 函数获取下一个值</li>
<li>支持更灵活的配置（起始值、步长、缓存等）</li>
<li>可以被多个表共享</li>
</ul>
<h4 data-id="heading-4">MyBatis-Plus 兼容性问题</h4>
<p>MyBatis-Plus 的 <code>IdType.AUTO</code> 设计主要针对 MySQL 的自增机制：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// MyBatis-Plus 期望的行为</span>
<span class="hljs-meta">@TableId(type = IdType.AUTO)</span>
<span class="hljs-keyword">private</span> Long id;

<span class="hljs-comment">// 生成的 INSERT SQL（MySQL）</span>
INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (?)
<span class="hljs-comment">// MySQL 自动填充 id 字段</span>

<span class="hljs-comment">// 在 PostgreSQL/OpenGauss 中的问题</span>
INSERT INTO <span class="hljs-title function_">user</span> <span class="hljs-params">(name)</span> VALUES (?)
<span class="hljs-comment">// 没有调用 nextval()，id 字段为 NULL，违反主键约束</span>
</code></pre>
<p><strong>失效原因：</strong></p>
<ol>
<li><strong>SQL 生成差异</strong>：MyBatis-Plus 生成的 INSERT 语句不包含序列调用</li>
<li><strong>驱动支持不足</strong>：OpenGauss 驱动无法自动识别并调用对应的序列</li>
<li><strong>框架假设</strong>：MyBatis-Plus 假设数据库会自动处理主键生成，但 PostgreSQL 需要显式操作</li>
</ol>
<p>为解决这个问题，项目采用了自定义 MyBatis 拦截器的方案，在 INSERT 操作前自动从数据库序列获取 ID 值。</p>
<h2 data-id="heading-5">二、MyBatis 拦截器机制</h2>
<h3 data-id="heading-6">拦截器工作原理</h3>
<p>MyBatis 提供了插件（Plugin）机制，允许在 SQL 执行的关键节点进行拦截和增强。拦截器基于 JDK 动态代理实现，可以拦截以下四种对象的方法：</p>






























<table><thead><tr><th>拦截对象</th><th>作用</th><th>常见拦截方法</th></tr></thead><tbody><tr><td>Executor</td><td>SQL 执行器</td><td>update, query, commit, rollback</td></tr><tr><td>StatementHandler</td><td>SQL 语句处理器</td><td>prepare, parameterize, batch, update, query</td></tr><tr><td>ParameterHandler</td><td>参数处理器</td><td>getParameterObject, setParameters</td></tr><tr><td>ResultSetHandler</td><td>结果集处理器</td><td>handleResultSets, handleOutputParameters</td></tr></tbody></table>
<h3 data-id="heading-7">拦截器执行流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant App as Application
    participant MyBatis
    participant Interceptor
    participant Executor
    participant DB as Database
    
    App-&gt;&gt;MyBatis: Execute Mapper method
    MyBatis-&gt;&gt;Interceptor: Call intercept()
    Interceptor-&gt;&gt;Interceptor: Pre-processing
    Interceptor-&gt;&gt;Executor: invocation.proceed()
    Executor-&gt;&gt;DB: Execute SQL
    DB--&gt;&gt;Executor: Return result
    Executor--&gt;&gt;Interceptor: Return result
    Interceptor-&gt;&gt;Interceptor: Post-processing
    Interceptor--&gt;&gt;MyBatis: Return final result
    MyBatis--&gt;&gt;App: Return result
</code></pre>
<h3 data-id="heading-8">拦截器接口定义</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-comment">// 拦截目标方法的执行</span>
    Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;
    
    <span class="hljs-comment">// 为目标对象创建代理</span>
    Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span>;
    
    <span class="hljs-comment">// 设置拦截器属性</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span>;
}
</code></pre>
<h2 data-id="heading-9">三、ID 主键生成拦截器实现</h2>
<h3 data-id="heading-10">整体架构</h3>
<p>项目中的 ID 主键生成方案由三个核心组件构成：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[INSERT Operation] --&gt; B[AutoIdGeneratorInterceptor]
    B --&gt; C{Check @TableId}
    C --&gt;|type=AUTO| D{ID is null?}
    C --&gt;|Other types| E[Skip processing]
    D --&gt;|Yes| F[PostgresSequenceGenerator]
    D --&gt;|No| E
    F --&gt; G[Get table name]
    G --&gt; H[Build sequence name]
    H --&gt; I[Execute SELECT nextval]
    I --&gt; J[Set ID field value]
    J --&gt; K[Continue INSERT]
    E --&gt; K
</code></pre>
<h3 data-id="heading-11">组件 1：AutoIdGeneratorInterceptor</h3>
<p><strong>核心职责：</strong></p>
<ul>
<li>拦截所有 INSERT 操作</li>
<li>检查实体类的 <code>@TableId</code> 注解配置</li>
<li>为 <code>IdType.AUTO</code> 类型且值为 null 的字段生成 ID</li>
</ul>
<p><strong>核心实现：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoIdGeneratorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];
        <span class="hljs-type">Object</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> invocation.getArgs()[<span class="hljs-number">1</span>];
        
        <span class="hljs-comment">// 只处理INSERT操作</span>
        <span class="hljs-keyword">if</span> (SqlCommandType.INSERT.equals(ms.getSqlCommandType())) {
            <span class="hljs-comment">// 反射检查@TableId(type=AUTO)字段，如果为null调用PostgresSequenceGenerator的nextId生成ID</span>
            processEntity(parameter);
        }
        
        <span class="hljs-keyword">return</span> invocation.proceed();
    }
}
</code></pre>
<p><strong>关键技术点：</strong></p>
<ol>
<li><strong>拦截 Executor.update 方法</strong>：INSERT/UPDATE/DELETE 都会调用此方法，通过 <code>SqlCommandType</code> 区分操作类型</li>
<li><strong>反射访问字段</strong>：使用 <code>field.setAccessible(true)</code> 访问私有字段</li>
<li><strong>注解检查</strong>：只处理 <code>@TableId(type = IdType.AUTO)</code> 标注的字段</li>
<li><strong>空值判断</strong>：仅在 ID 为 null 时生成，避免覆盖已有值</li>
</ol>
<h3 data-id="heading-12">组件 2：PostgresSequenceGenerator</h3>
<p><strong>核心职责：</strong></p>
<ul>
<li>根据实体类确定数据库表名</li>
<li>按约定构造序列名（<code>{table_name}_id_seq</code>）</li>
<li>执行 SQL 获取序列的下一个值</li>
</ul>
<p><strong>核心实现：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostgresSequenceGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IKeyGenerator</span> {
    
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">nextId</span><span class="hljs-params">(Object entity)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> getTableName(entity);
        <span class="hljs-type">String</span> <span class="hljs-variable">sequenceName</span> <span class="hljs-operator">=</span> tableName + <span class="hljs-string">"_id_seq"</span>;
        
        <span class="hljs-comment">// OpenGauss要求nextval()参数为常量，不能使用PreparedStatement</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT nextval('"</span> + sequenceName + <span class="hljs-string">"')"</span>;
        
        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();
             <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();
             <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql)) {
            <span class="hljs-keyword">return</span> rs.next() ? rs.getLong(<span class="hljs-number">1</span>) : <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Failed to generate ID from sequence"</span>, e);
        }
    }
}
</code></pre>
<p><strong>关键技术点：</strong></p>
<ol>
<li><strong>表名获取策略</strong>：优先使用 <code>@TableName</code> 注解，否则根据类名转换</li>
<li><strong>SQL 注入防护</strong>：序列名必须匹配 <code>^[a-zA-Z0-9_]+$</code> 正则表达式</li>
<li><strong>OpenGauss 兼容性</strong>：使用 <code>Statement</code> 而非 <code>PreparedStatement</code>，因为 OpenGauss 要求 <code>nextval()</code> 参数为常量</li>
</ol>
<h4 data-id="heading-13">序列机制深入解析</h4>
<p><strong>序列的创建与管理：</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建序列（OpenGauss）</span>
<span class="hljs-keyword">CREATE</span> SEQUENCE xxx_id_seq
    <span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> <span class="hljs-number">1</span>          <span class="hljs-comment">-- 起始值</span>
    INCREMENT <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>        <span class="hljs-comment">-- 步长</span>
    MINVALUE <span class="hljs-number">1</span>           <span class="hljs-comment">-- 最小值</span>
    MAXVALUE <span class="hljs-number">9223372036854775807</span>  <span class="hljs-comment">-- 最大值（BIGINT最大值）</span>
    CACHE <span class="hljs-number">1</span>              <span class="hljs-comment">-- 缓存大小</span>
    <span class="hljs-keyword">NO</span> <span class="hljs-keyword">CYCLE</span>;            <span class="hljs-comment">-- 不循环</span>

<span class="hljs-comment">-- 查看序列信息</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.sequences 
<span class="hljs-keyword">WHERE</span> sequence_name <span class="hljs-operator">=</span> <span class="hljs-string">'xxx_id_seq'</span>;

<span class="hljs-comment">-- 获取序列当前值（不消耗）</span>
<span class="hljs-keyword">SELECT</span> currval(<span class="hljs-string">'xxx_id_seq'</span>);

<span class="hljs-comment">-- 获取序列下一个值（消耗一个值）</span>
<span class="hljs-keyword">SELECT</span> nextval(<span class="hljs-string">'xxx_id_seq'</span>);

<span class="hljs-comment">-- 设置序列当前值</span>
<span class="hljs-keyword">SELECT</span> setval(<span class="hljs-string">'xxx_id_seq'</span>, <span class="hljs-number">1000</span>);
</code></pre>
<p><strong>序列 vs 自增字段对比：</strong></p>








































<table><thead><tr><th>特性</th><th>PostgreSQL 序列</th><th>MySQL 自增</th></tr></thead><tbody><tr><td>独立性</td><td>独立对象，可被多表共享</td><td>绑定到特定表的特定列</td></tr><tr><td>灵活性</td><td>支持复杂配置（步长、缓存等）</td><td>配置选项有限</td></tr><tr><td>性能</td><td>可配置缓存提升性能</td><td>数据库引擎优化</td></tr><tr><td>事务安全</td><td>序列值不会因事务回滚而回收</td><td>自增值可能因回滚产生间隙</td></tr><tr><td>跨表使用</td><td>一个序列可供多个表使用</td><td>每个表独立的自增计数器</td></tr><tr><td>重置操作</td><td>可以随时重置序列值</td><td>需要 ALTER TABLE 操作</td></tr></tbody></table>
<p><strong>OpenGauss 特殊限制：</strong></p>
<p>OpenGauss 对序列操作有特殊要求，这也是 MyBatis-Plus 兼容性问题的根源：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ❌ 错误：OpenGauss 不支持参数化的 nextval()</span>
<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">"SELECT nextval(?)"</span>);
ps.setString(<span class="hljs-number">1</span>, <span class="hljs-string">"user_id_seq"</span>);

<span class="hljs-comment">// ✅ 正确：必须使用字符串常量</span>
<span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();
<span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(<span class="hljs-string">"SELECT nextval('user_id_seq')"</span>);
</code></pre>
<p>这个限制要求我们：</p>
<ul>
<li>必须在 SQL 中硬编码序列名</li>
<li>需要严格验证序列名防止 SQL 注入</li>
<li>无法使用 MyBatis 的参数绑定机制</li>
</ul>
<h3 data-id="heading-14">组件 3：MybatisPlusConfig</h3>
<p><strong>核心职责：</strong></p>
<ul>
<li>在 Spring 容器初始化后注册拦截器</li>
<li>支持多数据源场景，为每个 <code>SqlSessionFactory</code> 注册拦截器</li>
</ul>
<p><strong>核心实现：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> {
    
    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 为所有SqlSessionFactory注册拦截器</span>
        <span class="hljs-keyword">for</span> (SqlSessionFactory factory : sqlSessionFactoryList) {
            <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> factory.getConfiguration();
            <span class="hljs-keyword">if</span> (!config.getInterceptors().contains(autoIdGeneratorInterceptor)) {
                config.addInterceptor(autoIdGeneratorInterceptor);
            }
        }
    }
}
</code></pre>
<p><strong>关键技术点：</strong></p>
<ol>
<li><strong>@PostConstruct 时机</strong>：确保在 Spring 容器初始化后、应用启动前注册拦截器</li>
<li><strong>多数据源支持</strong>：遍历所有 <code>SqlSessionFactory</code> 实例，逐一注册</li>
<li><strong>重复注册检查</strong>：避免同一个拦截器被重复注册</li>
<li><strong>注入 List</strong>：Spring 会自动注入所有 <code>SqlSessionFactory</code> 类型的 Bean</li>
</ol>
<h2 data-id="heading-15">四、使用方式</h2>
<h3 data-id="heading-16">实体类配置</h3>
<p>使用标准的 MyBatis-Plus 注解即可，无需额外配置：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@TableName("xxx")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xxx</span> {
    
    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span>
    <span class="hljs-keyword">private</span> Long id;
}
</code></pre>
<h3 data-id="heading-17">数据库序列创建</h3>
<p>确保数据库中存在对应的序列：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建序列（如果不存在）</span>
<span class="hljs-keyword">CREATE</span> SEQUENCE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> xxx_id_seq
    <span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> <span class="hljs-number">1</span>
    INCREMENT <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">NO</span> MINVALUE
    <span class="hljs-keyword">NO</span> MAXVALUE
    CACHE <span class="hljs-number">1</span>;

<span class="hljs-comment">-- 设置序列的当前值（可选）</span>
<span class="hljs-keyword">SELECT</span> setval(<span class="hljs-string">'xxx_id_seq'</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">false</span>);
</code></pre>
<h3 data-id="heading-18">Mapper 接口</h3>
<p>无需特殊处理，使用标准的 MyBatis-Plus 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">xxxMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;xxx&gt; {
    <span class="hljs-comment">// 继承BaseMapper即可，无需额外配置</span>
}
</code></pre>
<h3 data-id="heading-19">Service 层调用</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCategory</span><span class="hljs-params">(String categoryName)</span> {
    <span class="hljs-type">xxx</span> <span class="hljs-variable">category</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xxx</span>();
    category.setCategoryName(categoryName);
    <span class="hljs-comment">// 无需手动设置ID，拦截器会自动生成</span>
    
    categoryMapper.insert(category);
    <span class="hljs-comment">// 插入后，category.getId() 已经有值</span>
}
</code></pre>
<h2 data-id="heading-20">五、技术方案对比</h2>
<h3 data-id="heading-21">主键生成方案对比</h3>






















































<table><thead><tr><th>方案</th><th>实现方式</th><th>优势</th><th>劣势</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库自增</td><td>AUTO_INCREMENT</td><td>简单，性能好</td><td>分布式问题，迁移困难</td><td>单机MySQL应用</td></tr><tr><td>MyBatis-Plus AUTO</td><td>@TableId(type=AUTO)</td><td>配置简单，框架支持</td><td>数据库兼容性问题</td><td>标准MySQL/PostgreSQL</td></tr><tr><td>自定义拦截器</td><td>Interceptor + Sequence</td><td>完全控制，兼容性好</td><td>实现复杂，需维护</td><td>特殊数据库、复杂规则</td></tr><tr><td>UUID</td><td>UUID.randomUUID()</td><td>全局唯一，无依赖</td><td>存储空间大，无序</td><td>分布式系统</td></tr><tr><td>雪花算法</td><td>Snowflake</td><td>高性能，趋势递增</td><td>依赖时钟，配置复杂</td><td>高并发分布式系统</td></tr><tr><td>Redis自增</td><td>INCR命令</td><td>高性能，集中管理</td><td>依赖Redis，单点问题</td><td>中小规模分布式</td></tr></tbody></table>
<h3 data-id="heading-22">拦截器方案 vs MyBatis-Plus 原生方案</h3>








































<table><thead><tr><th>对比维度</th><th>自定义拦截器</th><th>MyBatis-Plus 原生</th></tr></thead><tbody><tr><td>数据库兼容性</td><td>✅ 支持 OpenGauss 等魔改数据库</td><td>⚠️ 部分数据库不支持</td></tr><tr><td>实现复杂度</td><td>⚠️ 需要编写拦截器代码</td><td>✅ 配置即可使用</td></tr><tr><td>灵活性</td><td>✅ 可自定义生成逻辑</td><td>❌ 依赖框架实现</td></tr><tr><td>性能开销</td><td>⚠️ 每次INSERT额外查询序列</td><td>✅ 数据库原生支持</td></tr><tr><td>维护成本</td><td>⚠️ 需要维护拦截器代码</td><td>✅ 框架统一维护</td></tr><tr><td>调试难度</td><td>⚠️ 需要理解拦截器机制</td><td>✅ 问题较少</td></tr></tbody></table>
<h2 data-id="heading-23">六、注意事项与最佳实践</h2>
<h3 data-id="heading-24">1. SQL 注入防护</h3>
<p>序列名必须进行严格验证：<code>sequenceName.matches("^[a-zA-Z0-9_]+$")</code>，避免直接拼接用户输入。</p>
<h3 data-id="heading-25">2. 性能考虑</h3>
<p>每次 INSERT 都会额外执行一次序列查询，高并发场景需要：</p>
<ul>
<li>使用高性能连接池（HikariCP）</li>
<li>考虑批量获取序列值并缓存</li>
<li>监控序列查询的响应时间</li>
</ul>
<h3 data-id="heading-26">3. 事务一致性</h3>
<p>序列生成在 INSERT 事务外执行，事务回滚时序列值会被消耗，导致序列不连续。这是序列机制的正常行为，不影响数据一致性。</p>
<h3 data-id="heading-27">4. 多数据源场景</h3>
<p>拦截器会自动为所有 SqlSessionFactory 注册，需确保每个数据源的表都有对应的序列。</p>
<h3 data-id="heading-28">5. 序列命名约定</h3>
<p>统一使用 <code>{table_name}_id_seq</code> 格式，如 <code>xxx_id_seq</code>。</p>
<h2 data-id="heading-29">七、常见问题排查</h2>
<h3 data-id="heading-30">问题 1：ID 仍然为 NULL</h3>
<p><strong>可能原因：</strong></p>
<ol>
<li>拦截器未正确注册</li>
<li>实体类注解配置错误</li>
<li>数据库序列不存在</li>
</ol>
<p><strong>排查步骤：</strong></p>
<ol>
<li>检查拦截器是否注册：查看 Configuration.getInterceptors() 列表</li>
<li>检查实体类注解：确保 <code>@TableId(type = IdType.AUTO)</code></li>
<li>检查数据库序列：<code>SELECT * FROM information_schema.sequences WHERE sequence_name = 'table_id_seq'</code></li>
</ol>
<h3 data-id="heading-31">问题 2：序列不存在错误</h3>
<p><strong>错误信息：</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">ERROR:</span> relation <span class="hljs-string">"xxx_id_seq"</span> does <span class="hljs-built_in">not</span> exist
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建缺失的序列</span>
<span class="hljs-keyword">CREATE</span> SEQUENCE xxx_id_seq <span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">-- 或者批量创建所有表的序列</span>
DO $$
<span class="hljs-keyword">DECLARE</span>
    r RECORD;
<span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">FOR</span> r <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SELECT</span> tablename <span class="hljs-keyword">FROM</span> pg_tables <span class="hljs-keyword">WHERE</span> schemaname <span class="hljs-operator">=</span> <span class="hljs-string">'public'</span>
    LOOP
        <span class="hljs-keyword">EXECUTE</span> format(<span class="hljs-string">'CREATE SEQUENCE IF NOT EXISTS %I_id_seq'</span>, r.tablename);
    <span class="hljs-keyword">END</span> LOOP;
<span class="hljs-keyword">END</span> $$;
</code></pre>
<h3 data-id="heading-32">问题 3：性能下降</h3>
<p><strong>现象：</strong> INSERT 操作变慢</p>
<p><strong>分析：</strong></p>
<ul>
<li>每次 INSERT 额外执行一次序列查询</li>
<li>数据库连接池配置不当</li>
<li>序列缓存设置过小</li>
</ul>
<p><strong>优化方案：</strong></p>
<ol>
<li>增加序列缓存：<code>ALTER SEQUENCE table_id_seq CACHE 100</code></li>
<li>优化连接池配置：调整 HikariCP 的 maximum-pool-size 和 minimum-idle</li>
<li>考虑批量获取序列值并缓存，减少数据库交互</li>
</ol>
<h2 data-id="heading-33">八、总结</h2>
<p>自定义 MyBatis 拦截器实现主键自动生成是一种灵活且强大的解决方案，特别适用于：</p>
<ol>
<li><strong>数据库兼容性问题</strong>：如 OpenGauss、达梦等国产数据库</li>
<li><strong>复杂 ID 生成规则</strong>：需要自定义生成逻辑的场景</li>
<li><strong>框架限制</strong>：MyBatis-Plus 原生方案无法满足需求</li>
</ol>
<p><strong>核心优势：</strong></p>
<ul>
<li>✅ 完全控制 ID 生成逻辑</li>
<li>✅ 良好的数据库兼容性</li>
<li>✅ 对业务代码透明，无侵入</li>
</ul>
<p><strong>需要注意：</strong></p>
<ul>
<li>⚠️ 实现和维护成本较高</li>
<li>⚠️ 性能开销需要评估</li>
<li>⚠️ 需要理解 MyBatis 拦截器机制</li>
</ul>
<p>通过合理的设计和实现，自定义拦截器可以成为解决特定场景问题的有效工具。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[打破 IK 分词“架构陷阱”——阿里云 ES Serverless 索引级词典的完美热更新实践]]></title>    <link>https://juejin.cn/post/7585024562216239144</link>    <guid>https://juejin.cn/post/7585024562216239144</guid>    <pubDate>2025-12-18T10:41:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585024562216239144" data-draft-id="7584997357445529640" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="打破 IK 分词“架构陷阱”——阿里云 ES Serverless 索引级词典的完美热更新实践"/> <meta itemprop="keywords" content="搜索引擎"/> <meta itemprop="datePublished" content="2025-12-18T10:41:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云大数据AI技术"/> <meta itemprop="url" content="https://juejin.cn/user/2414974667341287"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            打破 IK 分词“架构陷阱”——阿里云 ES Serverless 索引级词典的完美热更新实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2414974667341287/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云大数据AI技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T10:41:52.000Z" title="Thu Dec 18 2025 10:41:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    14
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在做过 Elasticsearch 中文搜索研发的同学中，IK 分词器几乎是标配。它简单、高效，覆盖了大多数中文业务场景，被广泛用于电商、资讯、社区等搜索系统。然而，在一些业务场景中，IK 分词器可能会带来意想不到的线上事故，尤其是在大促、热词高峰等对搜索稳定性要求极高的时期。本文将通过一个真实事故的复盘，解析开源 IK 分词器架构设计中的不足，并介绍阿里云 ES Serverless 如何通过“索引级词典”能力，彻底解决热更新引发的搜索错配问题。</p>
<h2 data-id="heading-0">一、事故复盘：一次常规操作，引发 P0 事故</h2>
<h3 data-id="heading-1">背景</h3>
<p>某电商平台大促前夕，运营发现网络热梗 “哈基米”（指代猫咪/宠物）的搜索量飙升。由于 IK 默认词典中没有该词，查询时会被切分为 [哈, 基, 米] ——导致召回了大量无关商品，转化极低。运营立即提出需求：必须让“哈基米”精确匹配相关商品。</p>
<h3 data-id="heading-2">操作过程</h3>
<p>“标准”的变更：</p>
<ul>
<li>
<p>在已有词典中新增词组“哈基米”，并触发了集群所有节点的热更新。</p>
</li>
<li>
<p>_analyze 接口验证通过：哈基米 已被正确识别为一个完整 Term。</p>
</li>
</ul>
<h3 data-id="heading-3">事故发生</h3>
<p>然而，就在词典热更新完成的那一瞬间，线上的实时搜索崩了</p>
<ul>
<li>
<p>新数据（正常）： 刚刚上架的“哈基米”商品能搜到。</p>
</li>
<li>
<p>旧数据（消失）：之前写入的所有包含“哈基米”描述的存量商品，全部搜不到了！</p>
</li>
</ul>
<p>原因却扑朔迷离——没有改动索引，却瞬间导致存量数据全部失效。</p>
<p>**结果：**本来想提升用户体验，结果搜索挂了，GMV 跌了，一次常规优化演变成了 P0 级线上事故。</p>
<p><img src="https://static001.geekbang.org/infoq/95/954cf36bf961711d6f68a306830c061b.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">二、深度解析：IK词典热更新的“时空错乱”</h2>
<p>为什么会这样？这并非 ES 的 Bug，而是 开源 IK 插件的设计机制 与 倒排索引特性 之间的一次正面碰撞。</p>
<h3 data-id="heading-5">核心冲突：动态词典 vs 静态索引</h3>
<ul>
<li>IK 插件的“全局单例”机制（The Global Singleton）：</li>
</ul>
<p>IK 分词器采用全局共享词典的实现策略。这意味着，一旦触发热更新，整个集群上所有使用 IK 的索引（无论新旧）都会立即、强制使用新词典进行查询分词。这是一个“牵一发而动全身”的操作。</p>
<ul>
<li>ES 索引的“不可变”特性（The Immutable Index）：</li>
</ul>
<p>当写入文档时，其字段内容经过分词后，生成的 Term 被写入倒排索引。数据一旦写入，生成的倒排索引（Term）就被“固化”了。</p>
<p>这就是冲突的根源： 你为了“未来”的数据（新热词）更新了全局词典，却无意中破坏了“过去”数据的查询匹配逻辑。</p>
<h3 data-id="heading-6">错位图解：拿着新地图找旧地址</h3>
<p>让我们清晰地梳理下事故发生的过程：</p>
<ul>
<li>
<p>热更新前（旧词典）： “哈基米”被切分为 [哈, 基, 米] 三个单字存入倒排索引。</p>
</li>
<li>
<p>热更新后（新词典）： 当“哈基米”被加入到词典后，搜索词“哈基米”被解析为整体 Term [哈基米]。</p>
</li>
</ul>
<p><strong>结果：</strong></p>
<p>拿着新 Term 哈基米 去找旧索引里的单字 哈、基、米 完全匹配不上！这就像是“时空错乱”：你拿着今天的新地图（新词典），去导航昨天的旧城市（旧索引），路早就变了，当然找不到目的地。</p>
<p><img src="https://static001.geekbang.org/infoq/8a/8a3d5ee507c7cd5dc922760c900f443c.webp" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">三、传统解法：三种“续命”方案</h2>
<p>在搜索系统里，词典版本错配是一类高频且棘手的问题：</p>
<ul>
<li>
<p>一旦新词典上线，而索引里的数据仍是按旧分词规则建立，搜索便可能非预期的异常。</p>
</li>
<li>
<p>对用户而言，表现是老数据匹配结果异常，之前可以搜索到的数据全部“消失”了。</p>
</li>
<li>
<p>对运维而言，要保证 新词典配置 与 索引数据分词结果 同步，需要在“性能、体验、成本”之间做艰难平衡。</p>
</li>
</ul>
<p>为缓解这一问题，业内常用三种方案来给业务“续命”——即在不彻底停机的情况下，尽量让新词生效并维持线上查询稳定。</p>
<p>三种常用方案详情如下：</p>
<p><img src="https://static001.geekbang.org/infoq/76/76e10fb814964f244208b6dd4fe75343.png" alt="" loading="lazy"/></p>
<p>然而，这些方案无一能够同时做到：</p>
<ul>
<li>
<p>无感热更新：让用户完全察觉不到后台切换过程</p>
</li>
<li>
<p>精准匹配新词：新热词即刻命中，不受旧分词影响</p>
</li>
<li>
<p>不影响存量数据搜索：老数据搜索结果保持稳定无偏差</p>
</li>
</ul>
<p>正因为如此，我们需要寻找一种既能让词典版本与数据版本完美对齐，又不会牺牲线上可用性的全新解法。</p>
<h2 data-id="heading-8">四、阿里云 ES Serverless 破局：索引级词典隔离</h2>
<p>所以，为了解决开源 IK 插件的“全局单例”词典机制导致的冲突，阿里云 ES Serverless 通过在内核层面的改造，推出 “集群-索引-分词器”三级词典配置体系：</p>
<h3 data-id="heading-9">多级词典体系设计</h3>
<p>该体系将词典的控制权从“集群/节点级”下放，允许在不同层级进行精细化配置，并遵循明确的优先级规则：分词器级别 &gt; 索引级别 &gt; 集群（租户）级别。</p>
<ul>
<li>
<p>集群级（Cluster-level）：由管控平台统一下发基础词典，保障全集群（租户）基础词汇一致性，优先级最低。</p>
</li>
<li>
<p>索引级（Index-level）：为每个索引绑定专属扩展词典和停用词典，精准解决“时空错位”问题的关键。</p>
</li>
<li>
<p>分词器级（Analyzer-level）：为索引内的某个自定义分词器配置专用词典，满足特定字段的特殊分词需求，优先级最高。</p>
</li>
</ul>
<p>典型场景示例：对 实时新增热词 场景，“索引级别词典”能力提供了完美的解决方案，可为不同索引绑定不同版本，例如：</p>
<ul>
<li>
<p>product_v1 → dict_v1</p>
</li>
<li>
<p>product_v2 → dict_v2</p>
</li>
</ul>
<p>它们可在同一集群内互不干扰、并行存在，让新旧版本词典同时在线，彻底解决“新旧不兼容”的时空错乱问题。</p>
<h3 data-id="heading-10">热更新无感流程</h3>
<p>以“哈基米”为例：</p>
<ul>
<li>
<p>Step 1 隔离运行</p>
</li>
<li>
<p>product_v1（绑定别名product_alias） 仍用旧词典 dict_v1。</p>
</li>
<li>
<p>线上用户查询不受影响，存量数据照常匹配。</p>
</li>
<li>
<p>Step 2 构建新索引</p>
</li>
<li>
<p>新建 product_v2 并绑定含“哈基米”的 dict_v2。</p>
</li>
<li>
<p>用离线链路或 _reindex 将数据写入新索引。</p>
</li>
<li>
<p>建议：</p>
</li>
</ul>
<p>对于大规模业务，建议直接复用 T+1 离线链路（如 DTS/ODPS/Flink），将数据重新灌入 product_v2。这是最标准、最高效的做法。</p>
<ul>
<li>
<p>Step 3 原子切换流量</p>
</li>
<li>
<p>数据追平后，将product_v2 绑定到 product_alias ，同时下掉product_v1，实现流量的原子切换。</p>
</li>
</ul>
<h3 data-id="heading-11">效果</h3>
<p>通过这一套 多级词典 + 流量原子切换 的组合拳，我们实现了 词典版本与数据版本的完美对齐：</p>
<ul>
<li>零中断：</li>
</ul>
<p>更新全程用户无感，整个更新和切换过程对线上用户完全透明，没有服务中断或查询失败的窗口。</p>
<ul>
<li>精准匹配：</li>
</ul>
<p>流量切换后，新词即刻生效，新旧数据查询逻辑对齐，搜索“哈基米”立刻精准命中，且整个过程没有任何“查询断层”或“服务闪断”。</p>
<ul>
<li>弹性支持：</li>
</ul>
<p>结合 Serverless 的自动扩缩容，应对大促算力峰值。</p>
<p><img src="https://static001.geekbang.org/infoq/c8/c8d79eb50eeb0bcd214e2b192070e78d.webp" alt="" loading="lazy"/></p>
<h3 data-id="heading-12">额外优势：内核优化的隐性收益</h3>
<p>除了索引级词典，Serverless 版本还具有以下优势：</p>
<ul>
<li>
<p>避免词典脑裂：保证集群内节点词典统一。</p>
</li>
<li>
<p>无感升级：同步开源 IK 与原生 ES 新特性。这些能力让你的热词更新从一件“高风险运维操作”，变成稳定、安全的日常操作。</p>
</li>
</ul>
<h2 data-id="heading-13">五、附录</h2>
<h3 data-id="heading-14">“休克疗法”更新指南</h3>
<p>假设线上的索引是 product_v1。</p>
<p><strong>a. 准备阶段：更新词典并验证词典是否生效</strong></p>
<p>ⅰ. 更新 IK 远程词典，加入词组“哈基米”。</p>
<p>ⅱ. 等待词典加载完成，并测试新词组是否生效。</p>
<p><strong>b. 执行阶段：索引数据更新</strong></p>
<p>ⅰ. 选择业务低峰期（如凌晨），调用 _update_by_query API，对索引中全部数据进行更新。</p>
<pre><code class="hljs language-ini" lang="ini">POST /product_v1/_update_by_query?<span class="hljs-attr">refresh</span>=<span class="hljs-literal">true</span>&amp;conflicts=proceed

<span class="hljs-comment"># 如果使用异步方式，可以通过以下命令查看任务状态</span>
GET /_tasks?<span class="hljs-attr">detailed</span>=<span class="hljs-literal">true</span>&amp;actions=*update_by_query*
</code></pre>
<p><strong>c. 验证阶段：验证分词是否生效</strong></p>
<p>ⅰ. 待 <code>_update_by_query</code> 任务完成后，可以通过<code>termvectors</code>来查看实际索引的词。</p>
<pre><code class="hljs language-bash" lang="bash">GET /product_v1/_termvectors/{<span class="hljs-built_in">id</span>}
</code></pre>
<h3 data-id="heading-15">传统方案“打补丁”实操指</h3>
<p>为“哈基米”紧急上线同义词补丁</p>
<p><strong>a. 准备阶段：在词典中新增“哈基米”，定义带同义词的查询分词器</strong></p>
<p>ⅰ. 通过 <code>PUT /_settings</code> API，加入 <code>synonym_graph</code> 过滤器和使用它的新分词器。</p>
<pre><code class="hljs language-bash" lang="bash">PUT /product_v1/_settings
{
  <span class="hljs-string">"analysis"</span>: {
    <span class="hljs-string">"filter"</span>: {
      <span class="hljs-string">"my_synonym_graph"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"synonym_graph"</span>,
        <span class="hljs-string">"synonyms"</span>: [
          // 核心规则：将新词映射回旧的切分结果
          <span class="hljs-string">"哈基米, 哈 基 米"</span>
        ]
      }
    },
    <span class="hljs-string">"analyzer"</span>: {
      <span class="hljs-string">"my_search_analyzer"</span>: {
        <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"ik_smart"</span>,
        <span class="hljs-string">"filter"</span>: [ <span class="hljs-string">"my_synonym_graph"</span> ]
      }
    }
  }
}
</code></pre>
<p><strong>b. 应用阶段：将同义词规则应用到索引字段，并更新 Mapping</strong></p>
<p>ⅰ. 最后，更新字段的 <code>mapping</code>，指定在查询时使用我们新定义的 <code>my_search_analyzer</code>。</p>
<pre><code class="hljs language-json" lang="json">PUT /product_v1/_mapping
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"content"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"text"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"analyzer"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ik_max_word"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 写入时保持原样，分词为[哈,基,米]</span>
      <span class="hljs-attr">"search_analyzer"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my_search_analyzer"</span> <span class="hljs-comment">// 查询时应用同义词补丁</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>c. 效果</strong>：完成以上操作后，搜索“哈基米”就能匹配到包含 <code>哈</code> <code>基</code> <code>米</code> 的旧文档了。</p>
<h3 data-id="heading-16">Serverless 配置实操</h3>
<p><strong>前提</strong>：已经在 Serverless 控制台上传词典，词典ID标识为 <code>dict_v1</code> 和 <code>dict_v2</code></p>
<h4 data-id="heading-17">Step 1： 线上服务稳定运行</h4>
<p>在创建索引 <code>product_v``1</code> 时，为其指定词典 <code>dict_v1</code>（如在创建索引时未指定词典，也可以通过PUT {index}/_settings REST API配置）</p>
<pre><code class="hljs language-bash" lang="bash">PUT /product_v1
{
  <span class="hljs-string">"settings"</span>: {
    <span class="hljs-string">"number_of_shards"</span>: 5,
    <span class="hljs-string">"number_of_replicas"</span>: 1,
    <span class="hljs-string">"ik.extra_dict_ids"</span>: <span class="hljs-string">"dict-v1"</span>
  },
  <span class="hljs-string">"mappings"</span>: {
    <span class="hljs-string">"properties"</span>: {
      <span class="hljs-string">"content"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>,
        <span class="hljs-string">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,
        <span class="hljs-string">"search_analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>
      }
    }
  }
}

或

PUT /product_v1/_settings
{
  <span class="hljs-string">"index"</span>:{
     <span class="hljs-string">"ik.extra_dict_ids"</span>: <span class="hljs-string">"dict-v1"</span>
  }
}
</code></pre>
<p>将别名 <code>product_alias</code> 指向索引 <code>product_v1</code></p>
<pre><code class="hljs language-bash" lang="bash">POST /_aliases
{
  <span class="hljs-string">"actions"</span>: [
    { <span class="hljs-string">"add"</span>:    { <span class="hljs-string">"index"</span>: <span class="hljs-string">"product_v1"</span>, <span class="hljs-string">"alias"</span>: <span class="hljs-string">"product_alias"</span>, <span class="hljs-string">"is_write_index"</span>: <span class="hljs-literal">true</span> } }
  ]
}
</code></pre>
<p>批量写入数据</p>
<pre><code class="hljs language-css" lang="css">PUT product_alias/_bulk
{"index": {"_id": <span class="hljs-number">1</span>}}
{"<span class="hljs-attribute">content</span>": <span class="hljs-string">"哈雷彗星"</span>}
{"index": {"_id": <span class="hljs-number">2</span>}}
{"<span class="hljs-attribute">content</span>": <span class="hljs-string">"基础版本人工智能"</span>}
{"index": {"_id": <span class="hljs-number">3</span>}}
{"<span class="hljs-attribute">content</span>": <span class="hljs-string">"米是一种食物"</span>}
{"index": {"_id": <span class="hljs-number">5</span>}}
{"<span class="hljs-attribute">content</span>": <span class="hljs-string">"哈基米是猫咪"</span>}
</code></pre>
<p><code>product_v1</code> 将使用词典 <code>dict_v1</code> 运行。</p>
<pre><code class="hljs language-bash" lang="bash">GET product_alias/_search
{
  <span class="hljs-string">"query"</span>: {
    <span class="hljs-string">"match"</span>: {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"哈基米"</span>
    }
  }
}
</code></pre>
<p><img src="https://static001.geekbang.org/infoq/28/2853b14c8fba08b1a2d96bdbc5c52b2c.png" alt="" loading="lazy"/></p>
<h4 data-id="heading-18">Step 2： 安全、无感的引入新词典</h4>
<p>创建包含“哈基米”词组的新词典 <code>dict_v2</code>，新建索引 <code>product_v2</code>，并为其指定新词典</p>
<pre><code class="hljs language-css" lang="css">PUT product_v2
{
  "settings": {
    "number_of_shards": <span class="hljs-number">5</span>,
    <span class="hljs-string">"number_of_replicas"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"ik.extra_dict_ids"</span>: <span class="hljs-string">"dict-v2"</span>
  },
  "mappings": {
    "properties": {
      "<span class="hljs-attribute">content</span>": {
        "type": <span class="hljs-string">"text"</span>,
        <span class="hljs-string">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,
        <span class="hljs-string">"search_analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>
      }
    }
  }
}
</code></pre>
<p>通过 API <code>_reindex</code> 将 <code>product_v1</code> 索引中的数据更新到 <code>product_v2</code> 中。</p>
<pre><code class="hljs language-json" lang="json">POST _reindex
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"product_v1"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dest"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"index"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"product_v2"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>然后将别名 <code>product_alias</code> 指向索引 <code>product_v2</code></p>
<pre><code class="hljs language-bash" lang="bash">POST /_aliases
{
  <span class="hljs-string">"actions"</span>: [
    { <span class="hljs-string">"remove"</span>:    { <span class="hljs-string">"index"</span>: <span class="hljs-string">"product_v1"</span>, <span class="hljs-string">"alias"</span>: <span class="hljs-string">"product_alias"</span> } },
    { <span class="hljs-string">"add"</span>:    { <span class="hljs-string">"index"</span>: <span class="hljs-string">"product_v2"</span>, <span class="hljs-string">"alias"</span>: <span class="hljs-string">"product_alias"</span>, <span class="hljs-string">"is_write_index"</span>: <span class="hljs-literal">true</span> } }
  ]
}
</code></pre>
<p>由于 <code>products_v2</code> 已经绑定了新词典，所有新写入的数据都会正确地将“哈基米”索引为一个完整的 Term。</p>
<p>此时查询结果如下：</p>
<p><img src="https://static001.geekbang.org/infoq/b3/b32137a217b1b1892db1d455acaececa.png" alt="" loading="lazy"/></p>
<h2 data-id="heading-19">六、结尾</h2>
<p>开源 IK 分词器的节点级全局词典机制，在动态热更新场景下，与 ES 的静态倒排索引天然冲突。传统解法要么牺牲业务连续性，要么增加运维成本。</p>
<p>阿里云 ES Serverless 通过 “索引级词典” 架构，彻底消除了这一冲突，实现：</p>
<ul>
<li>
<p>新旧数据版本的无缝兼容</p>
</li>
<li>
<p>热更新过程的全程透明</p>
</li>
<li>
<p>集群资源的最大化利用</p>
</li>
</ul>
<p><strong>告别“配置地狱”，回归业务价值！不再让一次简单的热词更新，变成线上事故。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[6000字技术向拆解 “大晓机器人”携手火山引擎多模态数据湖探索视频处理新路径]]></title>    <link>https://juejin.cn/post/7584817405227843625</link>    <guid>https://juejin.cn/post/7584817405227843625</guid>    <pubDate>2025-12-18T06:19:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584817405227843625" data-draft-id="7584724634173898815" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="6000字技术向拆解 “大晓机器人”携手火山引擎多模态数据湖探索视频处理新路径"/> <meta itemprop="keywords" content="大数据"/> <meta itemprop="datePublished" content="2025-12-18T06:19:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="字节跳动数据平台"/> <meta itemprop="url" content="https://juejin.cn/user/2159881542179624"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            6000字技术向拆解 “大晓机器人”携手火山引擎多模态数据湖探索视频处理新路径
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2159881542179624/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    字节跳动数据平台
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T06:19:07.000Z" title="Thu Dec 18 2025 06:19:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>国内具身智能领域又迎来重磅消息。</p>
<p>12月18日，“大晓机器人”正式亮相，作为行业级“具身超级大脑”，“大晓机器人”将以全新研发范式、全新数据采集范式，以及性能领先全球的“开悟”世界模型3.0（Kairos 3.0），精准剖析并响应当前阶段行业在技术突破和商业落地的双重诉求，将前沿技术转化为可落地、可复用的解决方案。</p>
<p>同步发布的还有“具身超级大脑模组A1”，通过搭载首创纯视觉无图端到端VLA具身智能模型，让具身智能摆脱了预先地图采集的依赖，能够快速适应复杂的陌生环境——基于这项能力，“大晓机器人”将与国内领先的智能企业达成战略合作，在安防、巡检等工业场景率先部署机器狗。</p>
<p>“大晓机器人”将前沿高新技术转化为可被企业、行业快速落地且易于 复用的通用能力，助力企业、行业在AI时代持续繁荣。</p>
<p>同时，“大晓机器人”也以积极态度拥抱行业合作，与火山引擎开展联合探索，进一步提升在大模型领域的创新力：如结合了火山引擎多模态数据湖解决方案的开悟世界模型3.0，可以有效解决传统单机多脚本模式的链路分散、I/O负载重、资源利用率低、稳定性差、扩展不足等问题。</p>
<p>本文将核心探讨“大晓机器人”与火山引擎，聚焦千万小时级的视频数据处理场景，如何通过多模态数据湖解决方案中的LAS AI数据湖产品，跑通最佳实践全链路，实现开发投入侧和资源利用侧的双重提效。</p>
<h2 data-id="heading-1">背景</h2>
<p>图片随着具身智能的进一步发展，视频数据正在进入“千万小时”时代，而数据处理规模的变大带来是处理框架的升级。</p>
<p>以具身智能机器狗的工业巡检场景为例，一台机器狗通常搭载多路全景摄像头与深度相机，在持续执行巡检任务时，单天产生的视频数据量即可达到数百GB。在规模化部署机器狗集群的背景下，每月积累的视频数据甚至能突破千万小时。</p>
<p>面对如此海量的数据，传统单机、脚本式的处理流程已经难以为继，千万小时视频不是“多加几台机器”就能处理好的问题。</p>
<p>那如何在保证稳定性、可扩展性的前提下，高效处理千万小时的视频数据？在本文中，我们分享如何利用Daft@火山引擎AI数据湖-Las 搭建大规模的分布式视频处理 Pipeline。</p>
<h2 data-id="heading-2">LAS AI 数据湖</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a13de838537345e8a119016abd802ca4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=oQDuahdIvfJ3GTARMqBrWIfaTnw%3D" alt="" loading="lazy"/></p>
<p>LAS AI 数据湖产品是火山引擎为企业适应AI Agent时代推出的新一代多模态场景解决方案，孵化于字节跳动大模型训练场景，面向多模态数据场景，提供湖存储、湖管理、湖计算三大能力、通过“湖存储Lance+湖计算Daft”为核心要素，针对性解决视频、图片等非结构化数据处理的痛点。</p>
<h2 data-id="heading-3">业务场景</h2>
<p>以典型【具身场景】的视频处理链路如下图所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b0fe63550a4583823c361532de176c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=xTQI8YXcpjG%2B5qjSyYSuxJz2%2FN4%3D" alt="" loading="lazy"/></p>
<p>这是一条典型的多阶段视频 ETL 处理链路，每个环节都伴随着异构资源使用、I/O 压力与数据依赖。</p>
<h2 data-id="heading-4">架构升级</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f6d755010174863829e00222c79bfec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=%2BREZKg%2F0EPO0NVx3eK3lIShrIhg%3D" alt="" loading="lazy"/></p>
<p>升级前后的收益对比</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38654ee2964b4516b635c79911cccae3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=ei9hhtUYrYhDS%2FpX1EMfYUFU%2BH4%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">实现细节</h2>
<p>图片在历史方案中，单机多脚本通过中间文件衔接的方式，瓶颈明显：</p>
<p>链路分散：分镜、视频解码&amp;抽帧、过滤、caption生产等步骤往往由不同脚本实现，难以统一管理</p>
<p>I/O 负载沉重：每个步骤都可能产生大量中间文件（临时视频、帧图像、日志等），磁盘与网络经常成为瓶颈</p>
<p>资源利用率差：脚本通常是单视频串行处理，很难充分利用多核或多机资源，更无法灵活按需分配资源</p>
<p>稳定性差：步骤之间缺乏明确的依赖管理机制，一旦某一环出现异常，整个 Pipeline 可能无法恢复</p>
<p>难以扩展：当数据规模从“几百小时”突然增长到“几万、几十万小时”时，链路通常要被“推倒重来”</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01e76700163a4d0e8702b22f44ee8412~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=puL3ERdA4u3Vdcy%2FJN7v7ORQrRk%3D" alt="" loading="lazy"/></p>
<p>而我们基于LAS AI数据湖产品中内置的计算框架Daft，将整个流程统一抽象为一条 DataFrame 计算链路，配合 Ray 等执行后端实现 批量并行、资源充分利用的执行方式，既保留了 Python 写法的灵活性，又兼顾了工程上的可扩展性。</p>
<ul>
<li>从TOS读取千万小时的视频数据</li>
<li>使用PySceneDetect做场景检测，再使用FFmpeg做视频分割，得到分镜后视频片段</li>
<li>对每个视频片段做解码和抽帧，得到可以直接输入模型的clip数据</li>
<li>调用模型对视频做模糊度、美学等打分，过滤不符合条件的视频</li>
<li>对过滤后的视频，调用VLM生成Caption</li>
</ul>
<h2 data-id="heading-6">准备工作</h2>
<p>安装依赖包</p>
<pre><code class="hljs language-arduino" lang="arduino">pip install <span class="hljs-string">"daft[ray]"</span> scenedetect torch torchvision ray PIL transformers vllm qwen_vl_utils
</code></pre>
<h2 data-id="heading-7">步骤1：视频分镜</h2>
<h3 data-id="heading-8">场景检测</h3>
<p>在具身智能机器狗的工业巡检场景中，原始视频通常是长时间连续录制的，其中包含大量语义不同的片段：例如检查管道阀门状态、经过车间走廊、上下楼梯、识别设备指示灯异常、遇到地面障碍物（如工具箱）、通过狭窄通道等。</p>
<p>为了让后续的抽帧、滤波、Caption 等处理更加准确和高效，我们首先对视频进行 场景检测（Shot Detection），将长视频划分成若干语义相对完整的分镜片段。</p>
<p>我们使用 PySceneDetect 对视频内容变化进行检测，它通过以下方式来判断场景切换的位置：</p>
<p>亮度直方图变换</p>
<p>逐帧内容差异（Content Difference）</p>
<p>阈值跳变（Threshold Detector）</p>
<p>通过识别这些边界，我们能够将原始视频精准切割成多个分镜（Scene）。每个分镜都更短、更独立，也更适合作为后续模型的输入单元。</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">detect_scenes</span>(self, video_path):
    # 检测场景
    video = <span class="hljs-built_in">open_video</span>(video_path)
    scene_manager.<span class="hljs-built_in">detect_scenes</span>(video)
    scenes = []
    for start, end in scene_manager.<span class="hljs-built_in">get_scene_list</span>():
        scenes.<span class="hljs-built_in">append</span>((start.<span class="hljs-built_in">get_seconds</span>(), end.<span class="hljs-built_in">get_seconds</span>())
    return scenes
</code></pre>
<h3 data-id="heading-9">过滤过短片段</h3>
<p>在完成场景检测后，我们会对检测到的分镜进行一次质量过滤，丢弃时长不足 4 秒的片段。 之所以进行这一步，是因为过短的场景往往存在以下问题：</p>
<ul>
<li>内容不稳定：可能是瞬时曝光变化、抖动、短暂遮挡导致的误检</li>
<li>语义不完整：不足以形成一个可理解的视频语义单元</li>
<li>模型输入质量差：抽帧数量不足会影响模糊度判定、美学评估、Caption 效果</li>
<li>会降低 Pipeline 吞吐：大量短场景会导致频繁的解码与 FFmpeg 调用，反而增加 overhead</li>
</ul>
<p>因此，基于经验与实验，我们选择将 时长小于 4 秒的场景过滤掉，只保留具有完整语义与足够帧数的有效片段，使后续处理更加稳定、可控，也能显著提升模型推理质量。</p>
<h3 data-id="heading-10">场景切分</h3>
<p>在完成 PySceneDetect 的场景检测后，我们会得到每个分镜的起止时间（timecode）。接下来，需要根据这些时间段将原始视频拆分成多个独立的 clip。</p>
<p>这一步我们使用 FFmpeg 进行切分，它的优势是：</p>
<ul>
<li>切分精准：可按精确时间戳（-ss / -to）截取片段</li>
<li>无损处理：通过 -c:v copy 直接拷贝视频流，无需重新编码</li>
<li>速度极快：I/O 速度远大于编码速度，几乎可以线性扩展到多进程</li>
<li>稳定可靠：FFmpeg 对各种编码格式（H264/H265/MPEG4）兼容性最好</li>
</ul>
<p>切分后的每个 clip 都是一个独立的视频文件，具有清晰的语义边界，也成为后续“解码抽帧 → 质量过滤 → Caption”的基础输入单元。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_split_and_save_scene</span>(<span class="hljs-params">self, scene, video_path, output_dir</span>):
    cmd = [
        <span class="hljs-string">"ffmpeg"</span>,
        <span class="hljs-string">"-loglevel"</span>, <span class="hljs-string">"error"</span>,
        <span class="hljs-string">"-ss"</span>, <span class="hljs-built_in">str</span>(start_sec),
        <span class="hljs-string">"-to"</span>, <span class="hljs-built_in">str</span>(end_sec),
        <span class="hljs-string">"-i"</span>, video_path,
        <span class="hljs-string">"-c"</span>, <span class="hljs-string">"copy"</span>,
        clip_path
    ]
    
    <span class="hljs-keyword">return</span> clip_path
</code></pre>
<h3 data-id="heading-11">Daft Explode 增大并发粒度</h3>
<p>一个长视频在经过场景检测后往往会被切分成多个场景片段。为提升整体吞吐与资源利用率，我们将“场景检测”和“视频切分”拆分为两个独立的 UDF。</p>
<p>在场景检测阶段，我们将原始的视频级数据展开为场景片段级的数据，使每个场景片段都成为独立的数据行。随后，借助 Daft 的分布式任务调度和并发执行能力，实现大规模的并行视频切分操作。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b782d950721c42ee9f2cd10c0098567f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=I0SKmHDS9qIfAbAyHkebNEbISoA%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2223947b6e944e19a6480978a3740c5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=Lisns0lFpbbwUFJx7%2BAi54xtTnw%3D" alt="" loading="lazy"/></p>
<p>图片这种设计能够充分利用多核 CPU 的并行能力，显著提升长视频处理效率，同时避免因个别超长视频导致的数据倾斜问题，从而确保整体作业在大规模数据集上也能保持稳定的处理性能。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> daft

<span class="hljs-meta">@daft.udf(<span class="hljs-params">return_dtype=daft.DataType.<span class="hljs-built_in">list</span>(<span class="hljs-params">daft.DataType.<span class="hljs-built_in">list</span>(<span class="hljs-params">daft.DataType.float64(<span class="hljs-params"/>)</span>)</span>)</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneDetectionUDF</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init</span>(<span class="hljs-params">self, min_duration=<span class="hljs-number">4</span></span>):
        self.min_duration = min_duration

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, video_path_series</span>):
        results = []
        video_paths = video_path_series.to_pylist()
        <span class="hljs-keyword">for</span> video_path <span class="hljs-keyword">in</span> video_paths:
            scenes = self.detect_scenes(video_path)
            scenes = self.filter_scenes(scenes, self.min_duration)
            results.append(scenes)
        <span class="hljs-keyword">return</span> results
</code></pre>

<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> daft

<span class="hljs-meta">@daft.udf(<span class="hljs-params">return_dtype=daft.DataType.string(<span class="hljs-params"/>)</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoSplitUDF</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, output_dir: <span class="hljs-built_in">str</span></span>):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, video_path_series, scene_series</span>):
        results = []
        <span class="hljs-keyword">for</span> video_path, scene <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(video_path_series.to_pylist(), scene_series.to_pylist()):
            <span class="hljs-comment"># 镜头切分</span>
            clip_path = self._split_and_save_scene(video_path, scene, self.output_dir)
            results.append(clip_path)
        <span class="hljs-keyword">return</span> results
</code></pre>
<h2 data-id="heading-12">步骤2:视频滤波</h2>
<p>在完成视频分镜之后，我们已经将长时间连续录制的视频拆分为结构更清晰、语义更加独立的 clip。然而，具身场景中海量的原始视频仍然存在大量无效或质量较差的片段，例如：</p>
<ul>
<li>模糊抖动导致的不可用画面</li>
<li>强光/逆光造成的过曝、欠曝</li>
<li>无主体的空景（空荡的车间走廊、无人值守的设备待机区域、未放置任何物品的空旷仓库通道）</li>
<li>画质极低、噪点严重的片段</li>
<li>场景过暗或完全黑屏</li>
</ul>
<p>如果将这些低质量数据直接送入后续模型（例如 Caption、场景理解或训练数据集），不仅会浪费大量 GPU 资源，也会影响模型表现。因此，在大规模视频处理 Pipeline 中，“视频滤波”是确保数据质量的关键步骤。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21c87f1f5f4b46e1adf38233b223ac9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=5hCJAYWbJXoDTbp4tm4UaV27lZA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">图片解码抽帧</h3>
<p>在对视频输入模型进行推理之前，我们首先需要将视频内容从压缩编码格式转换为可供模型处理的图片帧。 这一步由两部分组成：解码（Decode）和抽帧（Sampling），是整个视频处理最关键的基础操作。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> daft

<span class="hljs-meta">@daft.udf(<span class="hljs-params">return_dtype=daft.DataType.struct(<span class="hljs-params">{
    <span class="hljs-string">"clip_path"</span>: daft.DataType.string(<span class="hljs-params"/>),
    <span class="hljs-string">"frame_paths"</span>: daft.DataType.<span class="hljs-built_in">list</span>(<span class="hljs-params">daft.DataType.string(<span class="hljs-params"/>)</span>)
}</span>), num_cpus=<span class="hljs-number">10</span>, concurrency=<span class="hljs-number">100</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameSamplerUDF</span>:
    <span class="hljs-string">"""
    帧采样UDF, 从视频clip中采样帧并保存
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_frames: <span class="hljs-built_in">int</span> = <span class="hljs-number">8</span>, output_dir: <span class="hljs-built_in">str</span> = <span class="hljs-string">"./frames"</span></span>):
        self.max_frames = max_frames
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, clip_path_series</span>):
        results = []
        <span class="hljs-keyword">for</span> clip_path <span class="hljs-keyword">in</span> clip_path_series.to_pylist():
            <span class="hljs-comment"># 采样帧</span>
            frame_paths = self._sample_frames(clip_path)
            results.append({<span class="hljs-string">"clip_path"</span>: clip_path,<span class="hljs-string">"frame_paths"</span>: frame_paths})
        <span class="hljs-keyword">return</span> results
</code></pre>
<h3 data-id="heading-14">视频打分&amp;过滤</h3>
<p>在完成“解码抽帧”后，我们会得到 clip 的一系列代表性帧。接下来，需要利用模型对这些帧进行质量评估，以判断该视频片段是否值得进入后续高成本的 Caption 或训练数据构建阶段。</p>
<p>这一环节就是 视频滤波的核心 —— 基于模型的质量评分（Scoring）与过滤（Filtering）。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> daft

<span class="hljs-meta">@daft.udf(<span class="hljs-params">return_dtype=daft.DataType.struct(<span class="hljs-params">{<span class="hljs-string">"clip_path"</span>: daft.DataType.string(<span class="hljs-params"/>), <span class="hljs-string">"passed"</span>: daft.DataType.<span class="hljs-built_in">bool</span>(<span class="hljs-params"/>), <span class="hljs-string">"scores"</span>: daft.DataType.python(<span class="hljs-params"/>)}</span>), num_gpus=<span class="hljs-number">0.2</span>, num_cpus=<span class="hljs-number">10</span>, concurrency=<span class="hljs-number">200</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameFilterUDF</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, target_size: <span class="hljs-built_in">tuple</span> = (<span class="hljs-params"><span class="hljs-number">320</span>, <span class="hljs-number">320</span></span>), threshold: <span class="hljs-built_in">float</span> = <span class="hljs-number">100.0</span></span>):
        ...
        <span class="hljs-comment"># 加载模型</span>
        self.model = self._load_model()
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, frames_data_series</span>):
        results = []
        <span class="hljs-keyword">for</span> frames_data <span class="hljs-keyword">in</span> frames_data_series.to_pylist():
            result = self._score_predict(frame_data)
            results.append(result)
        <span class="hljs-keyword">return</span> results
</code></pre>
<h2 data-id="heading-15">步骤3：视频理解&amp;Caption</h2>
<p>图片在经历「分镜 → 解码抽帧 → 质量过滤」之后，我们最终保留下来的 clip 都是 语义稳定、画质合格、可读性强的高质量视频片段。这些片段将进入整个 Pipeline 的第三个核心阶段：视频理解与 Caption 生成。</p>
<p>Caption 生成的目标，是让模型能够自动为每个视频片段生成一段自然语言描述，使视频从“未结构化视觉数据”变成“可检索、可索引、可训练的语义数据”。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd6c45bcf95942e68a85a70b1d609d1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=eXRqQedeD%2BcRhXgw9RL%2F9g42h%2B0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-16">Caption强化</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> daft

<span class="hljs-meta">@daft.udf(<span class="hljs-params">return_dtype=daft.DataType.string(<span class="hljs-params"/>), num_gpus=<span class="hljs-number">1</span>, num_cpus=<span class="hljs-number">20</span>, concurrency=<span class="hljs-number">800</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCaptionUDF</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model_path</span>):
        self.model = self._load_caption_model(model_path)
        self.prompt = <span class="hljs-string">"""基于上述理解，用一段简洁自然的语言描述当前视频场景。不要加入无法从视频判断的内容。请先理解视频片段的具身智能巡检场景，再生成一段客观准确的说明。分析内容包括：
  - 环境类型与结构（如车间/仓库/管道区、空间结构是否为狭窄通道/楼梯、设施布局）
  - 周围对象（设备、障碍物、环境元素）的相对位置和状态（如阀门开关状态、指示灯颜色、地面杂物位置）
  - 关键标识与异常（如设备状态标识、安全警示标识、设施异常情况）
  - 环境条件（光照、地面状况、空间约束）
  - 重要动态变化或潜在风险（如设备状态变化、新出现的障碍物、机器狗自身姿态变化）
基于上述理解，用一段简洁自然的语言描述当前视频场景。不要加入无法从视频判断的内容。"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, frames_data_series</span>):
        frames_data_list = frames_data_series.to_pylist()

        <span class="hljs-keyword">for</span> frame_data <span class="hljs-keyword">in</span> frames_data_list:
            <span class="hljs-comment"># 生成描述</span>
            caption = self._generate_caption(frame_data)
            results.append(caption)
        <span class="hljs-keyword">return</span> results
</code></pre>
<h2 data-id="heading-17">步骤4：Daft的Pipeline流式调度</h2>
<p>图片在前面的三个步骤（分镜、滤波、Caption）中，我们已经拆解了千万小时视频处理的三个关键能力。但真正让整个系统具备“工程落地能力”的，是最后一步 —— 通过 Daft on Ray 将所有步骤串联成一条高吞吐、可扩展的流式处理 Pipeline。</p>
<ul>
<li>初始化Ray Cluster</li>
<li>配置 Daft 使用 Ray 作为执行引擎</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">import daft

def main():
    """完整视频处理Pipeline"""  
    daft.context.set_runner_ray()
    
    <span class="hljs-comment"># 从TOS扫描.mp4视频文件</span>
    <span class="hljs-attr">io_config</span> = IOConfig(s3=S3Config(...))
    <span class="hljs-attr">s3_path</span> = <span class="hljs-string">"s3://bucket/test_path/**/*.mp4"</span>
    <span class="hljs-attr">output_s3_path</span> = <span class="hljs-string">"s3://bucket/output/parquet/"</span>
    <span class="hljs-attr">df</span> = daft.from_glob_path(s3_path, io_config=io_config).select(<span class="hljs-string">'path'</span>).with_column_renamed(<span class="hljs-string">'path'</span>, <span class="hljs-string">'video_path'</span>)
    <span class="hljs-comment"># 步骤1: 场景检测</span>
    <span class="hljs-attr">df</span> = df.with_column(<span class="hljs-string">"scene_list"</span>, scene_detect_udf(col(<span class="hljs-string">"video_path"</span>)))
    <span class="hljs-comment"># 将数据从视频维度展开到镜头维度</span>
    <span class="hljs-attr">df</span> = df.explode(col(<span class="hljs-string">"scene_list"</span>))
    <span class="hljs-attr">df</span> = df.with_column(<span class="hljs-string">"clip_path"</span>, video_split_udf(col(<span class="hljs-string">"video_path"</span>), col(<span class="hljs-string">"scene_list"</span>))) <span class="hljs-comment"># 步骤2：视频切分</span>
    <span class="hljs-attr">df</span> = df.with_column(<span class="hljs-string">"frames"</span>, frame_sampler_udf(col(<span class="hljs-string">"clip_path"</span>))) <span class="hljs-comment"># 步骤3: 帧采样</span>
    <span class="hljs-attr">df</span> = df.with_column(<span class="hljs-string">"filtered"</span>, frame_filter_udf(col(<span class="hljs-string">"frames"</span>))) <span class="hljs-comment"># 步骤4: 视频滤波</span>
    <span class="hljs-attr">df</span> = df.with_column(<span class="hljs-string">"caption"</span>, caption_udf(col(<span class="hljs-string">'frames'</span>))) <span class="hljs-comment"># 步骤5: 视频描述生成</span>
    <span class="hljs-comment"># 结果保存到parquet，上传到TOS</span>
    df.write_parquet(output_s3_path, <span class="hljs-attr">io_config</span>=io_config)
</code></pre>
<h2 data-id="heading-18">步骤5：GPU任务的Checkpoint</h2>
<p>图片在大规模分布式视频处理场景中，单次 Pipeline 运行往往持续数天甚至数周；链路中包含大量 GPU 推理、视频解码与分布式写入操作，运行时间本身即具有 长周期、阶段性累积 的特点。同时，工程中不可避免会出现以下情况：</p>
<ul>
<li>运行时间过长，需要人工“暂停 / 校准 / 调参”</li>
<li>中途需要进行集群扩容 / 缩容 / 升级</li>
<li>模型版本变更，需要从某个 stage 重新开始</li>
<li>调度策略需要动态调整（batch size、并行度、concurrency）</li>
<li>资源成本过高，需要中断以切换到低峰时段运行</li>
</ul>
<p>因此，该系统的 Pipeline 必须具备 可控中断 → 可恢复执行 的能力。为此，我们基于Parquet append-only 设计了Checkpoint 机制，并在每个阶段启动时通过 Anti Join 自动过滤已完成任务。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function">def <span class="hljs-title">generate_resume_result_daft</span>(<span class="hljs-params">input_df, processed_df, join_key</span>):
    <span class="hljs-keyword">if</span> processed_df <span class="hljs-keyword">is</span> None:
        <span class="hljs-keyword">return</span> input_df
    
    <span class="hljs-keyword">if</span> join_key <span class="hljs-keyword">is</span> None:
        <span class="hljs-keyword">return</span> input_df
    
    processed_df</span> = processed_df.<span class="hljs-keyword">select</span>(join_key).distinct()
    filtered_df = input_df.<span class="hljs-keyword">join</span>(processed_df, <span class="hljs-keyword">on</span>=join_key, how=<span class="hljs-string">'anti'</span>)
    <span class="hljs-keyword">return</span> filtered_df
</code></pre>
<h2 data-id="heading-19">Daft优化实践</h2>
<h3 data-id="heading-20">实践1：CPU使用超100%的情况，Daft为何还能加速</h3>
<p>前期在使用视频分镜场景中CPU利用率已经到了100%，但是集成了Daft之后端到端的处理依然收获了20%的收益。</p>
<p>这里主要的原因是 OMP_NUM_THREADS 环境变量的隔离带来的影响</p>
<p>在处理或者推理过程中，经常会用到Pytorch 或者Numpy的库，内置会用OMP_NUM_THREADS来控制线程池的大小，如果没有显示控制该环境变量，默认每个进程都会利用节点上的所有的cores，会带来资源争抢，带来线程上下文切换成本比较高</p>
<p>所以这里设置的num_cpus的为一个合理值就显得比较重要</p>
<p>如果 actor 内部使用多线程库（如 numpy、PyTorch）：配置 num_cpus=30 会让这些库使用更多线程（OMP_NUM_THREADS=30），可能提高单个 actor 的性能，但也可能导致线程竞争。</p>
<p>如果 actor 是单线程或 I/O 密集型：配置 num_cpus=1 或 num_cpus=10 对实际性能影响不大，但 num_cpus=1 可以让更多 actor 并发运行，提高整体吞吐量。</p>
<h3 data-id="heading-21">实践2：视频类型如何能够做到ZeroCopy</h3>
<p>Daft使用的Arrow类型作为算子间的传递形式，Arrow可以实现ZeroCopy能力，减少数据在不同算子之间的传递成本，但是Arrow只是支持固定类型的Type，如果是一个Python的复杂类型还是需要面临着拷贝，所以在这里将视频的数据内容转换为了Tensor类型，Tensor类型是原生可支持的Arrow类型（前提是size比较小的视频或者图片）</p>
<p>Note：这里有个Tradeoff，如果是比较小视频，如果想达成同一个视频会同时被多个数据流算子处理，则需要被显示的拷贝到不同的算子中，尽量增大处理并发， 如果是大视频，则尽量将算子Fusion，然后减少视频的多次拷贝</p>
<h3 data-id="heading-22">实践3：在Daft场景中如何增大吞吐</h3>
<p>Daft执行侧在算子间传递数据时支持有序和无序两种</p>
<p>无序更有利于高吞吐的场景，例如数据处理同时写回某个数据源中。</p>
<p>有序则会发生在show这种小数据量数据探查的 场景以及本身算子要求有序的场景例如 TopN，Order等算子</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9434178ad9a4495d97504f9a6b2715a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=gyqKCQmpogQm4wSv5bvt9oy36C0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-23">实践4：视频分镜步骤的分布式加速</h3>
<p>在千万小时视频处理中，分镜（场景切分） 是非常关键的前置步骤，会直接影响后续解码、抽帧、过滤、Caption 的处理成本。一个长视频往往有多个场景，需要切分为多个视频片段，单进程串行处理会成为整个 Pipeline 的第一道性能瓶颈。在大规模数据下，处理速度会迅速跌入不可接受的范围。</p>
<p>为提升整体吞吐，我们将分镜流程拆分为两个阶段，并通过 数据打散（Daft的explode函数）+ 分布式并发 实现加速：</p>
<p>在场景检测阶段，我们将原始的视频级数据展开为场景片段级的数据，使每个场景片段都成为独立的数据行</p>
<p>随后，借助 Daft 的分布式任务调度和并发执行能力，实现大规模的并行视频切分操作</p>
<p>这种模式将处理粒度从“视频级”提升到“场景级”，有效消除长视频带来的数据倾斜问题，使切分吞吐量随可用 CPU 核数近似线性增长，大幅提升整体视频处理 Pipeline 的性能与稳定性。</p>
<h3 data-id="heading-24">实践5：基于Daft解耦解码/抽帧与 GPU 推理，构建异步流水线提升GPU使用率</h3>
<p>在大规模视频处理中，一个常见的性能瓶颈来自于 解码/抽帧与 GPU 推理强耦合。</p>
<p>如果按照传统方式执行：</p>
<ul>
<li>解码一段视频</li>
<li>抽帧</li>
<li>把帧送入 GPU 做模型推理</li>
<li>再返回 CPU 等下一段解码</li>
</ul>
<p>这将导致 GPU 很长时间处于“等待 CPU 准备数据”状态，而不是持续推理。 在千万小时视频规模下，这种串行方式会让 GPU 实际利用率跌到 20%–40%，极大浪费算力资源。</p>
<p>因此，我们将解码/抽帧的任务单独抽成一个UDF，与下游的滤波和Caption生成的GPU推理任务解耦开，通过Daft的流式调度能力，消除了串行场景下 IO/CPU处理 与 GPU推理 的等待关系，使得GPU算子能够源源不断的获取数据进行推理。</p>
<h2 data-id="heading-25">最终效果</h2>
<p>图片经过以上优化，CPU和GPU的资源使用率都有显著提升</p>
<p>CPU 利用率显著提升：由原先的 40%~60% 波动状态提升至 稳定满载（100%）运行</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1ee6f4a2f98241e0b89d8165a1d98a04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=Ft3QI8wiaAnG3zoq2aU2snR7GkM%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58a68dae633d4df3be14f3a8093f732f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=3hU0TwbZ2UR4tnqbYJLbPYdruEE%3D" alt="" loading="lazy"/></p>
<p>GPU 利用率显著提升：由原先因等待 I/O 而长期处于低负载状态，提升至 稳定 90%+ 的高利用率区间</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1aae8bc9e5f4451ac52833634a90e96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=dn9dp7dBrYKXWgS0K8BJ1PMExgA%3D" alt="" loading="lazy"/><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb558c6cc0d44275a81b1822f92108fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2X6IqC6Lez5Yqo5pWw5o2u5bmz5Y-w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766643547&amp;x-signature=jZy7uqQQjxFV3ZLQosFMlJK6ajI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-26">总结</h2>
<p>图片图片在本次合作中，“大晓机器人”依托专业技术沉淀，专注于世界模型工具链的构建与应用，其技术范围涵盖物理AI数据闭环、生成式世界引擎及闭环仿真等等；火山引擎多模态数据湖解决方案则基于LAS AI数据湖产品，充分发挥在多模态数据预处理领域的优势，为“大晓机器人”的整个研发体系构建了坚实的技术基座。</p>
<p>通过“云+模型”的深度协同，“大晓机器人”携手火山引擎已经跑通传统脚本式处理在扩展性、稳定性、吞吐上的攻克路径，为企业和行业带来面向海量视频数据的“通用基础设施”解决方案，帮助包括具身智能、智能驾驶等在内的多个涉及视频处理的技术领域，实现研发和资源双重提效。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android AI解放生产力（二）：认识MCP以及配置config.toml]]></title>    <link>https://juejin.cn/post/7585019819192270858</link>    <guid>https://juejin.cn/post/7585019819192270858</guid>    <pubDate>2025-12-18T08:48:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585019819192270858" data-draft-id="7584758215701250086" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android AI解放生产力（二）：认识MCP以及配置config.toml"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-12-18T08:48:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TimeFine"/> <meta itemprop="url" content="https://juejin.cn/user/3913917123802615"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android AI解放生产力（二）：认识MCP以及配置config.toml
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917123802615/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TimeFine
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T08:48:09.000Z" title="Thu Dec 18 2025 08:48:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    39
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>上一篇的准备工作做好后还不能开始干活，需要做一些配置工作。</p>
<h2 data-id="heading-0">一、认识MCP</h2>
<p>下面介绍的都是会用到的MCP。这些MCP都是配置到config.toml文件，后面会给出。</p>
<h3 data-id="heading-1">1、sequential-thinking（结构化推理/分步思考 MCP）</h3>
<p><strong>Sequential Thinking MCP</strong> 是一种为 AI 提供 <em>逐步结构化分析和分解思路</em> 的服务。它不是简单返回一个结果，而是帮助模型：</p>
<ul>
<li>把复杂任务分成多个 <em>思考步骤</em>**</li>
<li>按顺序推进、检查和修正每一步的输出</li>
<li>支持 <em>思维分支</em>（explore alternative strategies）</li>
<li>提供可解释的 <em>中间思考状态</em> 和 <strong>反思能力</strong></li>
</ul>
<p>这种 MCP 特别适合解决需要规划、设计、策略推敲等场景，比如：</p>
<p>✔ 复杂需求拆解</p>
<p>✔ 系统设计分析</p>
<p>✔ 有多个可能方案且需要比较优化</p>
<p>✔ 自我修正和深度探索的任务</p>
<p>它弥补了传统 LLM 一次性输出的局限，让思考过程显式化，有助于降低错误概率和提高可靠性。</p>
<p><strong>这个MCP不需要显示调用。</strong></p>
<p>(👆🏻AI写的，我总结的没这么好)</p>
<h3 data-id="heading-2">2、context7（实时文档/代码示例检索 MCP）</h3>
<p>Context7 MCP 的核心目标是让 AI 获得 最新、最准确、与库版本匹配 的官方文档和代码示例：</p>
<ul>
<li>在实际编码时动态检索官方文档。</li>
<li>避免 LLM 因训练数据滞后而生成过时/错误的 API 调用</li>
<li>减少所谓的 “幻觉代码”</li>
</ul>
<p>换句话说，它给大语言模型装上了一副 实时文档眼镜，让模型在生成代码时能够：</p>
<ul>
<li>获取最新发布版本的库文档</li>
<li>查询函数签名和参数说明</li>
<li>拿到真实可用示例代码</li>
</ul>
<p>这对 AI 编程助手非常重要，可以显著提高生成代码的正确率和可运行性。</p>
<p>(👆🏻AI写的，我总结的没这么好)</p>
<p>使用方法就是在提示词最后加上<code>use context7</code>。例如：AWS MQTT的连接方式？use context7</p>
<p>在使用context7的时候，如果github上面有一些不太出名的项目，你希望context7也支持它，非常简单：</p>
<p>1.去<a href="https://link.juejin.cn?target=https%3A%2F%2Fcontext7.com%2F" target="_blank" title="https://context7.com/" ref="nofollow noopener noreferrer">Context7 - Up-to-date documentation for LLMs and A...</a>官网，点击右上角的绿色Add &gt;Docs</p>
<p>2.在github url输入框里面填入github地址</p>
<p>3.等待context7后端解析完毕，即可在mcp里面享受项目的文档和使用案例详解。</p>
<p><strong>这个MCP除了显示调用，最好配合skill（下一篇会讲到）来使用。</strong></p>
<h3 data-id="heading-3">3、serena（语义代码检索 &amp; 精准编辑 MCP）</h3>
<p>Serena MCP 是一个功能更强、更像 IDE 工具的 MCP 服务器，实现了 语义级代码搜索与编辑能力：</p>
<p>它不仅仅是提供文档、还能够：</p>
<ul>
<li>对代码进行 语义级检索（不是简单关键词搜索）</li>
<li>理解项目中符号、函数定义、引用关系</li>
<li>识别变量、类型和依赖结构</li>
<li>提供类似 IDE 的 代码导航、引用查找、重构建议</li>
<li>结合 LLM 提供更精确的代码修改和补丁生成</li>
</ul>
<p>它可视为让客户端（如 Codex CLI、Claude Desktop、Cursor 等）变得像一个有 IDE 能力的伙伴，而不是单纯语言模型。Serena 的 MCP 输出更接近 代码理解 + 编辑 而不仅是文本/文档查询。</p>
<p>⚠ 注意：Serena 需要 uvx 工具（现代 Python 包管理器）来启动，并且配置和依赖相对比前两个更复杂一些。</p>
<p>(👆🏻AI写的，我总结的没这么好)</p>
<p>建议在<code>AGENTS.md</code>文件的最前面加入一句话显示开启Serena：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">## 显示激活Serena MCP
- IMPORTANT: If `serena.activate_project` has not been called <span class="hljs-keyword">in</span> the context, then call it once first.
</code></pre>
<p>另外开启Serena后，项目的根目录会多一个<code>.serena</code>的文件夹，一般建议加入git忽略文件。</p>
<h2 data-id="heading-4">二、认识config.toml文件</h2>
<p><code>config.toml</code>文件其实就是Codex的配置文件，打开方式(Mac)就是搜索<code>~/.codex/config.toml</code>找到这个文件打开即可。下面介绍一些需要添加的配置：</p>
<h3 data-id="heading-5">1、打开codex联网能力</h3>
<pre><code class="hljs language-kotlin" lang="kotlin">[features]
# 让codex有联网查询能力
web_search_request = <span class="hljs-literal">true</span>
</code></pre>
<h3 data-id="heading-6">2、打开skills能力</h3>
<pre><code class="hljs language-kotlin" lang="kotlin">[features]
# 打开skills能力
skills = <span class="hljs-literal">true</span>
</code></pre>
<h3 data-id="heading-7">3、其他</h3>
<p>其他例如沙箱模式，指定模型等，因人而异，建议有这些需求的时候问AI吧。</p>
<h2 data-id="heading-8">三、配置MCP和config.toml文件</h2>
<p>MCP就是配置在config.toml文件中的，下面是一份config.toml文件供参考：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">model = <span class="hljs-string">"gpt-5.1-codex-max"</span>
model_reasoning_effort = <span class="hljs-string">"high"</span>

# 顶层全局默认：只读 + 从不升级
sandbox_mode    = <span class="hljs-string">"read-only"</span>
approval_policy = <span class="hljs-string">"never"</span>
trust_level = <span class="hljs-string">"untrusted"</span>


[features]
# 让codex有联网查询能力
web_search_request = <span class="hljs-literal">true</span>
# 打开skills能力
skills = <span class="hljs-literal">true</span>


[projects.<span class="hljs-string">"/Users/river"</span>]


[projects.<span class="hljs-string">"具体项目根路径。cd 进根目录开启codex就会生成"</span>]
# 如果你想让这个项目也继承只读，就不要在这里把 trust_level 改成 trusted，改成trusted codex可以修改你的项目文件，下面被注释掉了
# trust_level = <span class="hljs-string">"trusted"</span>


# Figma MCP
[mcp_servers.figma_local]
url = <span class="hljs-string">"http://127.0.0.1:3845/mcp"</span>
startup_timeout_sec = <span class="hljs-number">20</span>
tool_timeout_sec = <span class="hljs-number">60</span>

# sequential-thinking MCP
[mcp_servers.sequential-thinking]
command = <span class="hljs-string">"npx"</span>
args = [<span class="hljs-string">"-y"</span>, <span class="hljs-string">"@modelcontextprotocol/server-sequential-thinking"</span>]
startup_timeout_ms = <span class="hljs-number">20000</span>

# context7 MCP
[mcp_servers.context7]
command = <span class="hljs-string">"npx"</span>
args = [<span class="hljs-string">"-y"</span>, <span class="hljs-string">"@upstash/context7-mcp"</span>]
startup_timeout_ms = <span class="hljs-number">20000</span>

# serena MCP
[mcp_servers.serena]
command = <span class="hljs-string">"uvx"</span>
args = [<span class="hljs-string">"--from"</span>, <span class="hljs-string">"git+https://github.com/oraios/serena"</span>,
        <span class="hljs-string">"serena"</span>, <span class="hljs-string">"start-mcp-server"</span>, <span class="hljs-string">"--context"</span>, <span class="hljs-string">"codex"</span>]
startup_timeout_ms = <span class="hljs-number">20000</span>

        
</code></pre>
<p>AI怎么用，怎么放权看个人，比如你只想让它只读，这样没有风险，但也很大程度上限制了AI的能力，如果允许AI写的话，请在git版本管理中好好审查AI修改后的代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Tauri (20)——为什么 NSPanel 窗口不能用官方 API 全屏？]]></title>    <link>https://juejin.cn/post/7585006378533453866</link>    <guid>https://juejin.cn/post/7585006378533453866</guid>    <pubDate>2025-12-18T11:45:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7585006378533453866" data-draft-id="7585006378533437482" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Tauri (20)——为什么 NSPanel 窗口不能用官方 API 全屏？"/> <meta itemprop="keywords" content="前端,APP,macOS"/> <meta itemprop="datePublished" content="2025-12-18T11:45:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨夜寻晴天"/> <meta itemprop="url" content="https://juejin.cn/user/1943592288391496"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Tauri (20)——为什么 NSPanel 窗口不能用官方 API 全屏？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592288391496/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨夜寻晴天
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T11:45:27.000Z" title="Thu Dec 18 2025 11:45:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在基于 Electron 或 Tauri 开发 macOS 桌面应用时，我们经常会遇到一种特殊的窗口类型：<code>NSPanel</code>。它通常用于 spotlight 搜索栏、悬浮工具条等场景。然而，当我们想给这种“小窗口”加上全屏能力（比如玩游戏、看大图）时，往往会撞上一堵墙：<strong>官方的全屏 API 对 <code>NSPanel</code> 并不友好，甚至直接失效。</strong></p>
<h2 data-id="heading-0">项目背景：Coco AI</h2>
<p>我们在构建 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fcoco.rs%2Fen" target="_blank" title="https://coco.rs/en" ref="nofollow noopener noreferrer">Coco AI</a></strong> —— 这款集成了统一搜索、协作与 AI 助手的跨平台桌面生产力工具时，遇到了一个有趣的技术挑战。</p>
<p>Coco AI 强大的<strong>插件系统</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fcoco.rs%2Fen%2Fintegration%2Fextensions" target="_blank" title="https://coco.rs/en/integration/extensions" ref="nofollow noopener noreferrer">Extensions</a>）允许用户在应用内直接运行各种工具（如小游戏、可视化图表、Web 应用等）。为了保持轻量和随手即用的体验，Coco 默认使用类似于 Spotlight 的悬浮窗（<code>NSPanel</code>）展示。但当用户想要沉浸式地使用插件（比如玩个小游戏）时，默认的小窗口就显得局促了。</p>
<p>我们希望实现的效果是：<strong>平时召之即来挥之即去，需要时一键变身全屏工作台。</strong></p>
<p>然而，官方的窗口 API 在 <code>NSPanel</code> 上却频频“翻车”。今天就来复盘一下我们是如何在 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fcoco-app" target="_blank" title="https://github.com/infinilabs/coco-app" ref="nofollow noopener noreferrer">Coco App</a></strong> 中解决这个问题的。</p>
<h2 data-id="heading-1">应用场景：一个嵌入式小游戏窗口</h2>
<p>假设我们在开发一个类似于 Spotlight 的启动器，平时它是一个悬浮在屏幕中央的小框。但我们允许用户通过插件系统加载一个网页（比如 HTML5 游戏）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5914df02df0415aab4b30f57d30d747~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5aSc5a-75pm05aSp:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766663126&amp;x-signature=pTynOxy0q0Y7x5ruvhRu6hup%2BHE%3D" alt="image.png" loading="lazy"/></p>
<p><strong>需求很直接：</strong></p>
<ol>
<li>默认窗口大小固定（如 1200x900）。</li>
<li>用户点击“全屏”按钮，窗口瞬间铺满当前屏幕。</li>
<li>再次点击，恢复原状。</li>
</ol>
<p><strong>技术栈：</strong></p>
<ul>
<li><strong>Tauri</strong> (Rust + WebView)</li>
<li><strong>Frontend</strong>: React + TypeScript</li>
<li><strong>Window Type</strong>: <code>NSPanel</code> (macOS)</li>
</ul>
<h2 data-id="heading-2">遇到的坑：NSPanel 与 <code>setFullscreen</code> 的爱恨情仇</h2>
<p>在普通的 <code>NSWindow</code> 中，调用 Tauri 的 <code>window.setFullscreen(true)</code> 或 Electron 的 <code>setFullScreen(true)</code>，系统会自动创建一个新的 Space，把窗口平铺进去，非常优雅。</p>
<p>但 Coco AI 为了追求“极致的快速启动与无感交互”，使用了 <code>NSPanel</code> 并设置了较高的窗口层级。当我们试图对它调用标准全屏 API 时：</p>
<ol>
<li><strong>系统动画冲突</strong>：由于没有标准标题栏，系统全屏动画可能会导致窗口消失、闪烁甚至错位。</li>
<li><strong>多屏支持噩梦</strong>：用户在副屏唤起 Coco AI，点击全屏，结果窗口直接飞回了主屏。</li>
<li><strong>状态不可逆</strong>：退出全屏后，窗口焦点和层级可能回不到原来的状态，打断了用户的心流。</li>
</ol>
<p>简单来说，官方 API 是给 <strong>“标准应用窗口”</strong> 设计的，并不适配我们这种 <strong>“灵动挂件”</strong>。</p>
<h2 data-id="heading-3">解决方案：手动接管窗口布局</h2>
<p>既然系统 API 不懂我们的心，我们就自己动手，“伪造”一个全屏效果。通过 <strong>“手动计算 + 逻辑坐标转换”</strong> 来优雅解决这个问题。</p>
<h3 data-id="heading-4">核心原理</h3>
<ol>
<li><strong>精准定位</strong>：获取当前鼠标所在的显示器（Monitor），确保“在哪里唤起，就在哪里全屏”。</li>
<li><strong>坐标系转换</strong>：macOS 使用逻辑像素（Logical Pixel），而底层屏幕信息往往是物理像素（Physical Pixel），必须通过 <code>scaleFactor</code> 进行转换，否则窗口会巨大无比或只有四分之一大。</li>
<li><strong>暴力美学</strong>：直接修改窗口的 <code>x, y, width, height</code>，使其完美覆盖目标屏幕的 Bounds。</li>
<li><strong>状态快照</strong>：在变身前，记住原来的位置和大小，以便随时缩回那个熟悉的“小框框”。</li>
</ol>
<h3 data-id="heading-5">Coco AI 的实现代码</h3>
<p>以下是我们在 <code>ViewExtension.tsx</code> 中的核心实现逻辑。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> applyFullscreen = <span class="hljs-title function_">useCallback</span>(
  <span class="hljs-keyword">async</span> (<span class="hljs-attr">next</span>: <span class="hljs-built_in">boolean</span>) =&gt; {
    <span class="hljs-keyword">if</span> (next) {
      <span class="hljs-comment">// 1. 状态快照：保存当前位置、大小、是否可调整</span>
      <span class="hljs-keyword">const</span> size = <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">getWindowSize</span>();
      <span class="hljs-keyword">const</span> resizable = <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">isWindowResizable</span>();
      <span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">getWindowPosition</span>();
      
      fullscreenPrevRef.<span class="hljs-property">current</span> = {
        <span class="hljs-attr">width</span>: size.<span class="hljs-property">width</span>,
        <span class="hljs-attr">height</span>: size.<span class="hljs-property">height</span>,
        resizable,
        <span class="hljs-attr">x</span>: pos.<span class="hljs-property">x</span>,
        <span class="hljs-attr">y</span>: pos.<span class="hljs-property">y</span>,
      };

      <span class="hljs-comment">// 2. 针对 macOS + Tauri (NSPanel) 的特殊处理</span>
      <span class="hljs-keyword">if</span> (isMac &amp;&amp; isTauri) {
        <span class="hljs-comment">// 关键步：获取鼠标所在的屏幕，实现“原位全屏”</span>
        <span class="hljs-keyword">const</span> monitor = <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">getMonitorFromCursor</span>();

        <span class="hljs-keyword">if</span> (!monitor) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">getCurrentWebviewWindow</span>();
        <span class="hljs-keyword">const</span> factor = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scaleFactor</span>();

        <span class="hljs-comment">// 3. 坐标转换：物理像素 -&gt; 逻辑像素</span>
        <span class="hljs-keyword">const</span> { size, position } = monitor;
        <span class="hljs-keyword">const</span> { width, height } = size.<span class="hljs-title function_">toLogical</span>(factor);
        <span class="hljs-keyword">const</span> { x, y } = position.<span class="hljs-title function_">toLogical</span>(factor);

        <span class="hljs-comment">// 4. 手动铺满屏幕</span>
        <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowSize</span>(width, height);
        <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowPosition</span>(x, y);
        <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowResizable</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 全屏模式下通常允许调整</span>
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">recomputeScale</span>(); <span class="hljs-comment">// 调整内部 Web 内容的缩放比例</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 其他平台使用标准 API 即可</span>
        <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowFullscreen</span>(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">recomputeScale</span>();
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 5. 退出全屏：恢复如初</span>
      <span class="hljs-keyword">if</span> (!isMac) {
        <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowFullscreen</span>(<span class="hljs-literal">false</span>);
      }
      <span class="hljs-comment">// 从配置或默认值恢复大小</span>
      <span class="hljs-keyword">const</span> nextWidth = ui?.<span class="hljs-property">width</span> ?? <span class="hljs-variable constant_">DEFAULT_VIEW_WIDTH</span>;
      <span class="hljs-keyword">const</span> nextHeight = ui?.<span class="hljs-property">height</span> ?? <span class="hljs-variable constant_">DEFAULT_VIEW_HEIGHT</span>;
      
      <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowSize</span>(nextWidth, nextHeight);
      <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">setWindowResizable</span>(ui?.<span class="hljs-property">resizable</span> ?? <span class="hljs-literal">true</span>);
      
      <span class="hljs-comment">// 关键步：居中回原来的屏幕</span>
      <span class="hljs-keyword">await</span> platformAdapter.<span class="hljs-title function_">centerOnCurrentMonitor</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">recomputeScale</span>();
      
      <span class="hljs-comment">// 6. 焦点修复（防止操作中断）</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        iframeRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">focus</span>();
      }, <span class="hljs-number">0</span>);
    }
  },
  [ui, recomputeScale]
);
</code></pre>
<h3 data-id="heading-6">为什么这样做体验更好？</h3>
<ul>
<li><strong>瞬时响应</strong>：没有了系统全屏动画的拖泥带水，点击即全屏。</li>
<li><strong>多屏友好</strong>：完美支持多显示器环境，不再发生“窗口瞬移”的灵异事件。</li>
<li><strong>UI 自由度</strong>：保留了我们自定义的 UI 控件，不受系统标题栏的干扰。</li>
</ul>
<h2 data-id="heading-7">小结</h2>
<p>在开发 <strong>Coco AI</strong> 的过程中，我们始终坚持 <strong>“不因为技术限制而妥协用户体验”</strong> 。虽然手动管理窗口状态比调用一个 API 麻烦得多，但为了让用户在使用插件时能有丝滑的体验，这一切都是值得的。</p>
<p>如果你对我们的技术栈（Rust + Tauri + React）感兴趣，或者想体验一下这个“既能小巧悬浮，又能全屏沉浸”的生产力工具，欢迎访问我们的 GitHub 仓库和官网：</p>
<ul>
<li><strong>GitHub</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfinilabs%2Fcoco-app" target="_blank" title="https://github.com/infinilabs/coco-app" ref="nofollow noopener noreferrer">github.com/infinilabs/…</a></li>
<li><strong>Website</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fcoco.rs%2F" target="_blank" title="https://coco.rs/" ref="nofollow noopener noreferrer">coco.rs/en</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[node_modules 太胖？用 Node.js 原生功能给依赖做一次大扫除]]></title>    <link>https://juejin.cn/post/7584807992032002090</link>    <guid>https://juejin.cn/post/7584807992032002090</guid>    <pubDate>2025-12-18T10:18:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584807992032002090" data-draft-id="7584807992031985706" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="node_modules 太胖？用 Node.js 原生功能给依赖做一次大扫除"/> <meta itemprop="keywords" content="Node.js,前端,后端"/> <meta itemprop="datePublished" content="2025-12-18T10:18:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            node_modules 太胖？用 Node.js 原生功能给依赖做一次大扫除
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T10:18:57.000Z" title="Thu Dec 18 2025 10:18:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">node_modules 太胖？用 Node.js 原生功能给依赖做一次大扫除</h2>
<p>写 Node.js 项目的时候，<code>package.json</code> 里的依赖列表是不是越来越长？</p>
<p>装个 <code>node-fetch</code> 发请求，装个 <code>uuid</code> 生成 ID，装个 <code>dotenv</code> 读环境变量，装个 <code>chalk</code> 输出彩色日志……每个包都不大，但加起来就是一堆。</p>
<p>问题是：</p>
<ul>
<li>依赖多了，供应链风险就大了（还记得 left-pad 事件吗？）</li>
<li><code>node_modules</code> 越来越臃肿</li>
<li>版本冲突和兼容性问题时不时冒出来</li>
</ul>
<p>好消息是，Node.js 这几年一直在把常用功能收编进核心模块。很多以前必须装包才能用的东西，现在原生就有了。</p>
<p>这篇文章整理了 15 个可以被 Node.js 原生功能替代的 npm 包，按使用频率排序，看看哪些依赖可以从你的项目里删掉。</p>
<h3 data-id="heading-1">1. <code>fetch()</code> 替代 <code>node-fetch</code></h3>
<p>这个应该是用得最多的了。</p>
<p>以前 Node.js 没有 <code>fetch</code>，想发 HTTP 请求要么用 <code>http</code> 模块自己封装，要么装 <code>node-fetch</code>。现在不用了：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js 18+ 原生支持</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.github.com/repos/nodejs/node'</span>);
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">stargazers_count</span>);
</code></pre>
<ul>
<li>v17.5.0 实验性引入</li>
<li>v18.0.0 稳定</li>
</ul>
<p>API 和浏览器的 <code>fetch</code> 一样，代码可以前后端通用。</p>
<h3 data-id="heading-2">2. <code>crypto.randomUUID()</code> 替代 <code>uuid</code></h3>
<p>生成 UUID 是个很常见的需求，以前都用 <code>uuid</code> 包：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> { v4 <span class="hljs-keyword">as</span> uuidv4 } <span class="hljs-keyword">from</span> <span class="hljs-string">'uuid'</span>;
<span class="hljs-keyword">const</span> id = <span class="hljs-title function_">uuidv4</span>();

<span class="hljs-comment">// 现在（Node.js 14.17.0+）</span>
<span class="hljs-keyword">import</span> { randomUUID } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:crypto'</span>;
<span class="hljs-keyword">const</span> id = <span class="hljs-title function_">randomUUID</span>();
<span class="hljs-comment">// 输出类似：'1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'</span>
</code></pre>
<p>少装一个包，还不用担心 <code>uuid</code> 的版本兼容问题。</p>
<h3 data-id="heading-3">3. <code>--env-file</code> 替代 <code>dotenv</code></h3>
<p>读 <code>.env</code> 文件是几乎每个项目都要做的事，以前必须装 <code>dotenv</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">API_KEY</span>);
</code></pre>
<p>现在可以用命令行参数：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Node.js 20.10.0+</span>
node --env-file=.<span class="hljs-built_in">env</span> app.js
</code></pre>
<p>不用写任何代码，环境变量直接加载到 <code>process.env</code>。</p>
<p>要注意的是，<code>--env-file</code> 功能比 <code>dotenv</code> 简单，不支持变量展开（<code>${VAR}</code>）和多行值。如果你的 <code>.env</code> 文件比较复杂，可能还是得用 <code>dotenv</code>。</p>
<h3 data-id="heading-4">4. <code>fs.rm({ recursive: true })</code> 替代 <code>rimraf</code></h3>
<p>删除目录及其所有内容，以前用 <code>rimraf</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> rimraf <span class="hljs-keyword">from</span> <span class="hljs-string">'rimraf'</span>;
rimraf.<span class="hljs-title function_">sync</span>(<span class="hljs-string">'dist'</span>);

<span class="hljs-comment">// 现在（Node.js 12.10.0+）</span>
<span class="hljs-keyword">import</span> { rm } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs/promises'</span>;
<span class="hljs-keyword">await</span> <span class="hljs-title function_">rm</span>(<span class="hljs-string">'dist'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p><code>force: true</code> 表示目录不存在时不报错，和 <code>rm -rf</code> 行为一致。</p>
<h3 data-id="heading-5">5. <code>fs.mkdir({ recursive: true })</code> 替代 <code>mkdirp</code></h3>
<p>创建嵌套目录：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">'mkdirp'</span>;
mkdirp.<span class="hljs-title function_">sync</span>(<span class="hljs-string">'path/to/nested/dir'</span>);

<span class="hljs-comment">// 现在（Node.js 10.12.0+）</span>
<span class="hljs-keyword">import</span> { mkdir } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs/promises'</span>;
<span class="hljs-keyword">await</span> <span class="hljs-title function_">mkdir</span>(<span class="hljs-string">'path/to/nested/dir'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>这个功能加得比较早，很多项目可能已经在用了。</p>
<h3 data-id="heading-6">6. <code>node:test</code> 替代测试框架</h3>
<p>Node.js 现在有内置的测试模块：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:test'</span>;
<span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'node:assert'</span>;

<span class="hljs-title function_">test</span>(<span class="hljs-string">'加法测试'</span>, <span class="hljs-function">() =&gt;</span> {
  assert.<span class="hljs-title function_">strictEqual</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
});

<span class="hljs-title function_">test</span>(<span class="hljs-string">'异步测试'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);
  assert.<span class="hljs-title function_">strictEqual</span>(result, <span class="hljs-number">42</span>);
});
</code></pre>
<p>运行：</p>
<pre><code class="hljs language-bash" lang="bash">node --<span class="hljs-built_in">test</span>
</code></pre>
<ul>
<li>v18.0.0 实验性引入</li>
<li>v20.0.0 稳定</li>
</ul>
<p>对于模块级别的单元测试够用了。但如果是大型应用，需要 mock、覆盖率报告、并行执行等功能，Jest 或 Vitest 还是更合适。</p>
<h3 data-id="heading-7">7. <code>util.styleText()</code> 替代 <code>chalk</code></h3>
<p>终端彩色输出：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">red</span>(<span class="hljs-string">'Error!'</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-property">green</span>.<span class="hljs-title function_">bold</span>(<span class="hljs-string">'Success!'</span>));

<span class="hljs-comment">// 现在（Node.js 20.12.0+，v22.17.0 稳定）</span>
<span class="hljs-keyword">import</span> { styleText } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:util'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">styleText</span>(<span class="hljs-string">'red'</span>, <span class="hljs-string">'Error!'</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">styleText</span>([<span class="hljs-string">'green'</span>, <span class="hljs-string">'bold'</span>], <span class="hljs-string">'Success!'</span>));
</code></pre>
<p>支持的样式包括：<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>bold</code>、<code>italic</code>、<code>underline</code> 等。</p>
<h3 data-id="heading-8">8. <code>util.stripVTControlCharacters()</code> 替代 <code>strip-ansi</code></h3>
<p>去除 ANSI 转义字符（彩色输出的控制码）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { stripVTControlCharacters } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:util'</span>;

<span class="hljs-keyword">const</span> colored = <span class="hljs-string">'\x1b[31mError\x1b[0m'</span>;
<span class="hljs-keyword">const</span> plain = <span class="hljs-title function_">stripVTControlCharacters</span>(colored);
<span class="hljs-comment">// plain === 'Error'</span>
</code></pre>
<p>在写日志到文件或者做字符串比较时很有用。</p>
<h3 data-id="heading-9">9. <code>fs.glob()</code> 替代 <code>glob</code></h3>
<p>文件匹配：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 以前</span>
<span class="hljs-keyword">import</span> { glob } <span class="hljs-keyword">from</span> <span class="hljs-string">'glob'</span>;
<span class="hljs-keyword">const</span> files = <span class="hljs-keyword">await</span> <span class="hljs-title function_">glob</span>(<span class="hljs-string">'**/*.js'</span>);

<span class="hljs-comment">// 现在（Node.js 22.0.0+）</span>
<span class="hljs-keyword">import</span> { glob } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs/promises'</span>;
<span class="hljs-keyword">const</span> files = <span class="hljs-keyword">await</span> <span class="hljs-title function_">glob</span>(<span class="hljs-string">'**/*.js'</span>);
</code></pre>
<p>API 基本一致，迁移成本很低。</p>
<h3 data-id="heading-10">10. <code>atob</code> / <code>btoa</code> 替代 Base64 polyfill</h3>
<p>Base64 编解码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js 20+ 全局可用</span>
<span class="hljs-keyword">const</span> encoded = <span class="hljs-title function_">btoa</span>(<span class="hljs-string">'hello world'</span>);
<span class="hljs-comment">// 'aGVsbG8gd29ybGQ='</span>

<span class="hljs-keyword">const</span> decoded = <span class="hljs-title function_">atob</span>(encoded);
<span class="hljs-comment">// 'hello world'</span>
</code></pre>
<p>和浏览器 API 一致，写同构代码更方便了。</p>
<h3 data-id="heading-11">11. <code>WebSocket</code> 替代 <code>ws</code>（客户端场景）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js 21.0.0+（实验性）</span>
<span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">'wss://echo.websocket.org'</span>);

ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'open'</span>, <span class="hljs-function">() =&gt;</span> {
  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">'Hello'</span>);
});

ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received:'</span>, event.<span class="hljs-property">data</span>);
});
</code></pre>
<p>目前还是实验性的，而且只适合客户端场景。写 WebSocket 服务端，<code>ws</code> 包还是标准选择。</p>
<h3 data-id="heading-12">12. <code>node:sqlite</code> 替代 <code>sqlite3</code> / <code>better-sqlite3</code></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 实验性功能</span>
<span class="hljs-keyword">import</span> { open } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:sqlite'</span>;

<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">open</span>(<span class="hljs-string">':memory:'</span>);
<span class="hljs-keyword">await</span> db.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)'</span>);
<span class="hljs-keyword">await</span> db.<span class="hljs-title function_">run</span>(<span class="hljs-string">'INSERT INTO users (name) VALUES (?)'</span>, <span class="hljs-string">'Alice'</span>);
<span class="hljs-keyword">const</span> row = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">get</span>(<span class="hljs-string">'SELECT * FROM users WHERE id = ?'</span>, <span class="hljs-number">1</span>);
</code></pre>
<p>最大的好处是不用编译原生模块了。<code>sqlite3</code> 和 <code>better-sqlite3</code> 都需要 node-gyp 编译，在某些环境下会遇到各种问题。</p>
<p>目前还是实验性的，生产环境建议观望。</p>
<h3 data-id="heading-13">13. <code>EventTarget</code> 替代 <code>event-target-shim</code></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js 15.0.0+ 全局可用</span>
<span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventTarget</span>();

target.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">detail</span>);
});

target.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">'message'</span>, { <span class="hljs-attr">detail</span>: <span class="hljs-string">'hello'</span> }));
</code></pre>
<p>和浏览器 API 一致。</p>
<h3 data-id="heading-14">14. <code>URLPattern</code> 替代 <code>url-pattern</code></h3>
<p>路由匹配：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Node.js 20.0.0+（实验性）</span>
<span class="hljs-keyword">const</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLPattern</span>({ <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/users/:id'</span> });

<span class="hljs-keyword">const</span> result = pattern.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'https://example.com/users/123'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">pathname</span>.<span class="hljs-property">groups</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// '123'</span>
</code></pre>
<p>对于简单的路由匹配场景够用，但目前还是实验性的。</p>
<h3 data-id="heading-15">15. <code>--experimental-strip-types</code> 运行 TypeScript</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Node.js 21.0.0+（实验性）</span>
node --experimental-strip-types app.ts
</code></pre>
<p>这个功能只是去掉类型注解，不做类型检查，也不支持一些 TypeScript 特有的语法（如 <code>enum</code>、<code>namespace</code>）。</p>
<p>适合快速运行 <code>.ts</code> 文件做原型或测试，但不能替代完整的 TypeScript 工具链。</p>
<h3 data-id="heading-16">哪些可以直接用，哪些再等等？</h3>






































































<table><thead><tr><th>功能</th><th>状态</th><th>建议</th></tr></thead><tbody><tr><td><code>fetch()</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>crypto.randomUUID()</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>--env-file</code></td><td>实验性</td><td>简单场景可用</td></tr><tr><td><code>fs.rm/mkdir</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>node:test</code></td><td>稳定</td><td>模块测试可用</td></tr><tr><td><code>util.styleText()</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>fs.glob()</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>atob/btoa</code></td><td>稳定</td><td>直接用</td></tr><tr><td><code>WebSocket</code></td><td>实验性</td><td>客户端可用</td></tr><tr><td><code>node:sqlite</code></td><td>实验性</td><td>观望</td></tr><tr><td><code>URLPattern</code></td><td>实验性</td><td>观望</td></tr><tr><td>TypeScript 支持</td><td>实验性</td><td>原型/测试可用</td></tr></tbody></table>
<h3 data-id="heading-17">迁移建议</h3>
<ol>
<li>
<p><strong>先查版本</strong>：确认你的 Node.js 版本支持这些功能。<code>node -v</code> 看一下。</p>
</li>
<li>
<p><strong>渐进式迁移</strong>：不用一次全换，哪个包用得多、问题多，先换哪个。</p>
</li>
<li>
<p><strong>实验性功能谨慎使用</strong>：标记为实验性的功能，API 可能会变，生产环境慎用。</p>
</li>
<li>
<p><strong>保留复杂场景的包</strong>：如果你需要 <code>dotenv</code> 的变量展开、<code>chalk</code> 的链式调用、Jest 的完整测试能力，继续用包也没问题。原生功能是多了个选择，不是必须替换。</p>
</li>
</ol>
<p>依赖少了，项目就干净了。供应链安全、启动速度、维护成本，都能受益。</p>
<h3 data-id="heading-18">参考</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnodesource.com%2Fblog%2Fnodejs-features-replacing-npm-packages" target="_blank" title="https://nodesource.com/blog/nodejs-features-replacing-npm-packages" ref="nofollow noopener noreferrer">nodesource.com/blog/nodejs…</a></li>
</ul>
<hr/>
<p>如果你觉得这篇文章有帮助，欢迎关注我的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i" target="_blank" title="https://github.com/tt-a1i" ref="nofollow noopener noreferrer">GitHub</a>，下面是我的一些开源项目：</p>
<p><strong>Claude Code Skills</strong>（按需加载，意图自动识别，不浪费 token，<a href="https://juejin.cn/post/7578714735307735066" target="_blank" title="https://juejin.cn/post/7578714735307735066">介绍文章</a>）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fcode-review-skill" target="_blank" title="https://github.com/tt-a1i/code-review-skill" ref="nofollow noopener noreferrer">code-review-skill</a> - 代码审查技能，覆盖 React 19、Vue 3、TypeScript、Rust 等约 9000 行规则（<a href="https://juejin.cn/post/7578709098255908902" target="_blank" title="https://juejin.cn/post/7578709098255908902">详细介绍</a>）</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2F5-whys-skill" target="_blank" title="https://github.com/tt-a1i/5-whys-skill" ref="nofollow noopener noreferrer">5-whys-skill</a> - 5 Whys 根因分析，说"找根因"自动激活</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Ffirst-principles-skill" target="_blank" title="https://github.com/tt-a1i/first-principles-skill" ref="nofollow noopener noreferrer">first-principles-skill</a> - 第一性原理思考，适合架构设计和技术选型</li>
</ul>
<p><strong>全栈项目</strong>（适合学习现代技术栈）：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fprompt-vault" target="_blank" title="https://github.com/tt-a1i/prompt-vault" ref="nofollow noopener noreferrer">prompt-vault</a> - Prompt 管理器，用的都是最新的技术栈，适合用来学习了解最新的前端全栈开发范式：Next.js 15 + React 19 + tRPC 11 + Supabase 全栈示例，clone 下来配个免费 Supabase 就能跑</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftt-a1i%2Fchat_edit" target="_blank" title="https://github.com/tt-a1i/chat_edit" ref="nofollow noopener noreferrer">chat_edit</a> - 双模式 AI 应用（聊天+富文本编辑），Vue 3.5 + TypeScript + Vite 5 + Quill 2.0 + IndexedDB</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浏览器网络请求 API：全面解析与高级封装(1)]]></title>    <link>https://juejin.cn/post/7584861353804070948</link>    <guid>https://juejin.cn/post/7584861353804070948</guid>    <pubDate>2025-12-18T07:42:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584861353804070948" data-draft-id="7584759201073102889" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浏览器网络请求 API：全面解析与高级封装(1)"/> <meta itemprop="keywords" content="前端,WebSocket,axios"/> <meta itemprop="datePublished" content="2025-12-18T07:42:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="1024肥宅"/> <meta itemprop="url" content="https://juejin.cn/user/588993964030574"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浏览器网络请求 API：全面解析与高级封装(1)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993964030574/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    1024肥宅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-18T07:42:40.000Z" title="Thu Dec 18 2025 07:42:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-18
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">引言</h4>
<p>在现代Web开发中，网络请求是实现前后端数据交互的核心技术。从基础的XMLHttpRequest到现代的Fetch API，再到功能丰富的WebSocket，浏览器提供了多种网络通信机制。本文将全面深入探讨浏览器网络请求相关的API，提供高级封装方案，并涵盖实际开发中的各种复杂场景。</p>
<h4 data-id="heading-1">一、现代网络请求API概览</h4>
<h5 data-id="heading-2">1.1 从XMLHttpRequest到Fetch API</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkAPIEvolution</span> {
  <span class="hljs-comment">// 传统的XMLHttpRequest实现</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">xhrRequest</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
      <span class="hljs-keyword">const</span> {
        method = <span class="hljs-string">'GET'</span>,
        headers = {},
        data = <span class="hljs-literal">null</span>,
        timeout = <span class="hljs-number">0</span>,
        responseType = <span class="hljs-string">''</span>
      } = options;
      
      xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-literal">true</span>);
      
      <span class="hljs-comment">// 设置请求头</span>
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
        xhr.<span class="hljs-title function_">setRequestHeader</span>(key, value);
      });
      
      <span class="hljs-comment">// 设置响应类型</span>
      <span class="hljs-keyword">if</span> (responseType) {
        xhr.<span class="hljs-property">responseType</span> = responseType;
      }
      
      <span class="hljs-comment">// 设置超时</span>
      xhr.<span class="hljs-property">timeout</span> = timeout;
      
      <span class="hljs-comment">// 事件处理</span>
      xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
          <span class="hljs-keyword">let</span> response;
          
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">responseType</span> === <span class="hljs-string">'json'</span>) {
              response = xhr.<span class="hljs-property">response</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">responseType</span> === <span class="hljs-string">'blob'</span>) {
              response = xhr.<span class="hljs-property">response</span>;
            } <span class="hljs-keyword">else</span> {
              response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);
            }
          } <span class="hljs-keyword">catch</span> (e) {
            response = xhr.<span class="hljs-property">responseText</span>;
          }
          
          <span class="hljs-title function_">resolve</span>({
            <span class="hljs-attr">data</span>: response,
            <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>,
            <span class="hljs-attr">statusText</span>: xhr.<span class="hljs-property">statusText</span>,
            <span class="hljs-attr">headers</span>: xhr.<span class="hljs-title function_">getAllResponseHeaders</span>()
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${xhr.status}</span>: <span class="hljs-subst">${xhr.statusText}</span>`</span>));
        }
      };
      
      xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network error'</span>));
      };
      
      xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Request timeout'</span>));
      };
      
      xhr.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">lengthComputable</span>) {
          <span class="hljs-keyword">const</span> percentComplete = (event.<span class="hljs-property">loaded</span> / event.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload progress: <span class="hljs-subst">${percentComplete.toFixed(<span class="hljs-number">2</span>)}</span>%`</span>);
        }
      };
      
      xhr.<span class="hljs-title function_">send</span>(data);
    });
  }
  
  <span class="hljs-comment">// Fetch API基础实现</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchRequest</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      method = <span class="hljs-string">'GET'</span>,
      headers = {},
      body = <span class="hljs-literal">null</span>,
      timeout = <span class="hljs-number">30000</span>,
      credentials = <span class="hljs-string">'same-origin'</span>,
      mode = <span class="hljs-string">'cors'</span>,
      cache = <span class="hljs-string">'default'</span>,
      redirect = <span class="hljs-string">'follow'</span>,
      referrer = <span class="hljs-string">'client'</span>
    } = options;
    
    <span class="hljs-comment">// 创建AbortController用于超时控制</span>
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
    <span class="hljs-keyword">const</span> signal = controller.<span class="hljs-property">signal</span>;
    
    <span class="hljs-comment">// 设置超时</span>
    <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      controller.<span class="hljs-title function_">abort</span>();
    }, timeout);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, {
        method,
        headers,
        body,
        credentials,
        mode,
        cache,
        redirect,
        referrer,
        signal
      });
      
      <span class="hljs-built_in">clearTimeout</span>(timeoutId);
      
      <span class="hljs-comment">// 检查响应状态</span>
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span>);
      }
      
      <span class="hljs-comment">// 根据Content-Type解析响应</span>
      <span class="hljs-keyword">const</span> contentType = response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'content-type'</span>);
      <span class="hljs-keyword">let</span> data;
      
      <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'application/json'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'text/'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'multipart/form-data'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">formData</span>();
      } <span class="hljs-keyword">else</span> {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();
      }
      
      <span class="hljs-keyword">return</span> {
        data,
        <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span>,
        <span class="hljs-attr">statusText</span>: response.<span class="hljs-property">statusText</span>,
        <span class="hljs-attr">headers</span>: response.<span class="hljs-property">headers</span>,
        response
      };
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">clearTimeout</span>(timeoutId);
      
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Request timeout'</span>);
      }
      
      <span class="hljs-keyword">throw</span> error;
    }
  }
  
  <span class="hljs-comment">// 性能对比</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">performanceComparison</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> testUrl = <span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>;
    <span class="hljs-keyword">const</span> iterations = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">const</span> results = {
      <span class="hljs-attr">xhr</span>: { <span class="hljs-attr">times</span>: [], <span class="hljs-attr">avg</span>: <span class="hljs-number">0</span> },
      <span class="hljs-attr">fetch</span>: { <span class="hljs-attr">times</span>: [], <span class="hljs-attr">avg</span>: <span class="hljs-number">0</span> }
    };
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Starting performance comparison...'</span>);
    
    <span class="hljs-comment">// 测试XHR</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) {
      <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">xhrRequest</span>(testUrl);
      <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
      results.<span class="hljs-property">xhr</span>.<span class="hljs-property">times</span>.<span class="hljs-title function_">push</span>(end - start);
    }
    
    <span class="hljs-comment">// 测试Fetch</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) {
      <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchRequest</span>(testUrl);
      <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
      results.<span class="hljs-property">fetch</span>.<span class="hljs-property">times</span>.<span class="hljs-title function_">push</span>(end - start);
    }
    
    <span class="hljs-comment">// 计算平均值</span>
    results.<span class="hljs-property">xhr</span>.<span class="hljs-property">avg</span> = results.<span class="hljs-property">xhr</span>.<span class="hljs-property">times</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>) / iterations;
    results.<span class="hljs-property">fetch</span>.<span class="hljs-property">avg</span> = results.<span class="hljs-property">fetch</span>.<span class="hljs-property">times</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>) / iterations;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Performance results:'</span>, results);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`XHR average: <span class="hljs-subst">${results.xhr.avg.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Fetch average: <span class="hljs-subst">${results.fetch.avg.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
    
    <span class="hljs-keyword">return</span> results;
  }
}
</code></pre>
<h5 data-id="heading-3">1.2 Fetch API的局限性及解决方案</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FetchLimitations</span> {
  <span class="hljs-comment">// 处理Fetch不支持的特性</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getFetchPolyfills</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> polyfills = {};
    
    <span class="hljs-comment">// 1. 进度监控</span>
    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'upload'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">''</span>))) {
      polyfills.<span class="hljs-property">progress</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">url, options = {}</span>) {
        <span class="hljs-keyword">const</span> { onProgress, ...fetchOptions } = options;
        
        <span class="hljs-comment">// 使用XHR来获取进度</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
          
          xhr.<span class="hljs-title function_">open</span>(options.<span class="hljs-property">method</span> || <span class="hljs-string">'GET'</span>, url);
          
          <span class="hljs-comment">// 设置请求头</span>
          <span class="hljs-keyword">if</span> (options.<span class="hljs-property">headers</span>) {
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(options.<span class="hljs-property">headers</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
              xhr.<span class="hljs-title function_">setRequestHeader</span>(key, value);
            });
          }
          
          <span class="hljs-comment">// 进度事件</span>
          <span class="hljs-keyword">if</span> (onProgress) {
            xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = onProgress;
            xhr.<span class="hljs-property">onprogress</span> = onProgress;
          }
          
          xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
              <span class="hljs-keyword">let</span> data;
              
              <span class="hljs-keyword">try</span> {
                data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);
              } <span class="hljs-keyword">catch</span> {
                data = xhr.<span class="hljs-property">responseText</span>;
              }
              
              <span class="hljs-title function_">resolve</span>({
                data,
                <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>,
                <span class="hljs-attr">statusText</span>: xhr.<span class="hljs-property">statusText</span>
              });
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${xhr.status}</span>`</span>));
            }
          };
          
          xhr.<span class="hljs-property">onerror</span> = reject;
          xhr.<span class="hljs-property">ontimeout</span> = reject;
          
          xhr.<span class="hljs-title function_">send</span>(options.<span class="hljs-property">body</span>);
        });
      };
    }
    
    <span class="hljs-comment">// 2. 超时处理</span>
    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'timeout'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">''</span>))) {
      polyfills.<span class="hljs-property">timeout</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url, options = {}</span>) {
        <span class="hljs-keyword">const</span> { timeout = <span class="hljs-number">30000</span>, ...fetchOptions } = options;
        <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
        <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), timeout);
        
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, { ...fetchOptions, <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> })
          .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timeoutId));
      };
    }
    
    <span class="hljs-comment">// 3. 请求取消</span>
    polyfills.<span class="hljs-property">cancelable</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url, options = {}</span>) {
      <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
      <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">fetch</span>(url, { ...options, <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> });
      
      <span class="hljs-keyword">return</span> {
        promise,
        <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>()
      };
    };
    
    <span class="hljs-keyword">return</span> polyfills;
  }
  
  <span class="hljs-comment">// 处理流式响应</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleStreamResponse</span>(<span class="hljs-params">url, onChunk, onComplete</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
      <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
      <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();
      <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
      
      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
        
        <span class="hljs-keyword">if</span> (done) {
          <span class="hljs-keyword">if</span> (onComplete) <span class="hljs-title function_">onComplete</span>(result);
          <span class="hljs-keyword">break</span>;
        }
        
        <span class="hljs-comment">// 处理chunk</span>
        <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });
        result += chunk;
        
        <span class="hljs-keyword">if</span> (onChunk) <span class="hljs-title function_">onChunk</span>(chunk, result);
      }
      
      <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> error;
    }
  }
  
  <span class="hljs-comment">// 处理大文件上传</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadLargeFile</span>(<span class="hljs-params">url, file, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 1MB chunks</span>
      onProgress,
      onComplete,
      onError
    } = options;
    
    <span class="hljs-comment">// 创建FormData</span>
    <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
    formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'file'</span>, file);
    formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'fileName'</span>, file.<span class="hljs-property">name</span>);
    formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'fileSize'</span>, file.<span class="hljs-property">size</span>);
    formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'chunkSize'</span>, chunkSize);
    formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'totalChunks'</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(file.<span class="hljs-property">size</span> / chunkSize));
    
    <span class="hljs-comment">// 如果文件很大，使用分片上传</span>
    <span class="hljs-keyword">if</span> (file.<span class="hljs-property">size</span> &gt; chunkSize) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uploadInChunks</span>(url, file, {
        chunkSize,
        onProgress,
        onComplete,
        onError
      });
    }
    
    <span class="hljs-comment">// 普通上传</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
      <span class="hljs-attr">body</span>: formData
    });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadInChunks</span>(<span class="hljs-params">url, file, options</span>) {
    <span class="hljs-keyword">const</span> {
      chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>,
      onProgress,
      onComplete,
      onError
    } = options;
    
    <span class="hljs-keyword">const</span> totalChunks = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(file.<span class="hljs-property">size</span> / chunkSize);
    <span class="hljs-keyword">const</span> fileId = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>)}</span>`</span>;
    <span class="hljs-keyword">let</span> uploadedChunks = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// 上传每个分片</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> chunkIndex = <span class="hljs-number">0</span>; chunkIndex &lt; totalChunks; chunkIndex++) {
      <span class="hljs-keyword">const</span> start = chunkIndex * chunkSize;
      <span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(start + chunkSize, file.<span class="hljs-property">size</span>);
      <span class="hljs-keyword">const</span> chunk = file.<span class="hljs-title function_">slice</span>(start, end);
      
      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'fileId'</span>, fileId);
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'chunk'</span>, chunk);
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'chunkIndex'</span>, chunkIndex);
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'totalChunks'</span>, totalChunks);
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'fileName'</span>, file.<span class="hljs-property">name</span>);
      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'fileSize'</span>, file.<span class="hljs-property">size</span>);
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`<span class="hljs-subst">${url}</span>/chunk`</span>, {
          <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
          <span class="hljs-attr">body</span>: formData
        });
        
        <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Chunk <span class="hljs-subst">${chunkIndex}</span> upload failed`</span>);
        }
        
        uploadedChunks++;
        
        <span class="hljs-comment">// 报告进度</span>
        <span class="hljs-keyword">if</span> (onProgress) {
          <span class="hljs-keyword">const</span> progress = (uploadedChunks / totalChunks) * <span class="hljs-number">100</span>;
          <span class="hljs-title function_">onProgress</span>(progress, chunkIndex, totalChunks);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">if</span> (onError) <span class="hljs-title function_">onError</span>(error, chunkIndex);
        <span class="hljs-keyword">throw</span> error;
      }
    }
    
    <span class="hljs-comment">// 所有分片上传完成，合并文件</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`<span class="hljs-subst">${url}</span>/merge`</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
        },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
          fileId,
          <span class="hljs-attr">fileName</span>: file.<span class="hljs-property">name</span>,
          totalChunks
        })
      });
      
      <span class="hljs-keyword">if</span> (onComplete) <span class="hljs-title function_">onComplete</span>(response);
      <span class="hljs-keyword">return</span> response;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (onError) <span class="hljs-title function_">onError</span>(error);
      <span class="hljs-keyword">throw</span> error;
    }
  }
}
</code></pre>
<h4 data-id="heading-4">二、增强型Fetch封装</h4>
<h5 data-id="heading-5">2.1 完整的HTTP客户端实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClient</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">baseURL = <span class="hljs-string">''</span>, defaultOptions = {}</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseURL</span> = baseURL;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultOptions</span> = {
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        ...defaultOptions.<span class="hljs-property">headers</span>
      },
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">30000</span>,
      <span class="hljs-attr">credentials</span>: <span class="hljs-string">'include'</span>,
      <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span>,
      ...defaultOptions
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span> = {
      <span class="hljs-attr">request</span>: [],
      <span class="hljs-attr">response</span>: [],
      <span class="hljs-attr">error</span>: []
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequests</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryConfig</span> = {
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">retryDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">retryOn</span>: [<span class="hljs-number">408</span>, <span class="hljs-number">429</span>, <span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>]
    };
    
    <span class="hljs-comment">// 初始化请求队列</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxConcurrent</span> = <span class="hljs-number">6</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span> = <span class="hljs-number">0</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();
  }
  
  <span class="hljs-title function_">init</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 添加默认拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addDefaultInterceptors</span>();
  }
  
  <span class="hljs-title function_">addDefaultInterceptors</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 请求拦截器：添加认证token</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-keyword">async</span> (config) =&gt; {
        <span class="hljs-comment">// 从localStorage或cookie获取token</span>
        <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'auth_token'</span>) || 
                      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCookie</span>(<span class="hljs-string">'auth_token'</span>);
        
        <span class="hljs-keyword">if</span> (token) {
          config.<span class="hljs-property">headers</span> = {
            ...config.<span class="hljs-property">headers</span>,
            <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
          };
        }
        
        <span class="hljs-comment">// 添加请求时间戳防止缓存</span>
        <span class="hljs-keyword">if</span> (config.<span class="hljs-property">method</span>?.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">'get'</span>) {
          <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(config.<span class="hljs-property">url</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>);
          url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'_t'</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());
          config.<span class="hljs-property">url</span> = url.<span class="hljs-title function_">toString</span>();
        }
        
        <span class="hljs-keyword">return</span> config;
      }
    );
    
    <span class="hljs-comment">// 响应拦截器：处理通用错误</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,
      <span class="hljs-keyword">async</span> (error) =&gt; {
        <span class="hljs-comment">// 处理认证失败</span>
        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {
          <span class="hljs-comment">// 刷新token或跳转到登录页</span>
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleUnauthorized</span>();
        }
        
        <span class="hljs-comment">// 处理服务器错误</span>
        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">500</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Server error:'</span>, error);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
      }
    );
  }
  
  <span class="hljs-comment">// 核心请求方法</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">const</span> requestId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateRequestId</span>(url, options);
    
    <span class="hljs-comment">// 检查是否已有相同的请求在处理中</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequests</span>.<span class="hljs-title function_">has</span>(requestId)) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequests</span>.<span class="hljs-title function_">get</span>(requestId);
    }
    
    <span class="hljs-comment">// 合并配置</span>
    <span class="hljs-keyword">const</span> config = {
      <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseURL</span> ? <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.baseURL}</span><span class="hljs-subst">${url}</span>`</span> : url,
      ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultOptions</span>,
      ...options
    };
    
    <span class="hljs-comment">// 执行请求拦截器</span>
    <span class="hljs-keyword">let</span> processedConfig = config;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> interceptor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>) {
      processedConfig = <span class="hljs-keyword">await</span> <span class="hljs-title function_">interceptor</span>(processedConfig);
    }
    
    <span class="hljs-comment">// 创建请求Promise</span>
    <span class="hljs-keyword">const</span> requestPromise = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeRequest</span>(processedConfig, requestId);
    
    <span class="hljs-comment">// 存储pending请求</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequests</span>.<span class="hljs-title function_">set</span>(requestId, requestPromise);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> requestPromise;
      
      <span class="hljs-comment">// 执行响应拦截器</span>
      <span class="hljs-keyword">let</span> processedResponse = response;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> interceptor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>) {
        processedResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">interceptor</span>(processedResponse);
      }
      
      <span class="hljs-keyword">return</span> processedResponse;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 执行错误拦截器</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> interceptor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">error</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">interceptor</span>(error, processedConfig);
      }
      
      <span class="hljs-keyword">throw</span> error;
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-comment">// 清理pending请求</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequests</span>.<span class="hljs-title function_">delete</span>(requestId);
    }
  }
  
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">executeRequest</span>(<span class="hljs-params">config, requestId</span>) {
    <span class="hljs-keyword">const</span> {
      url,
      method = <span class="hljs-string">'GET'</span>,
      headers,
      body,
      timeout,
      signal,
      <span class="hljs-attr">cache</span>: cacheOption,
      ...restOptions
    } = config;
    
    <span class="hljs-comment">// 检查缓存</span>
    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">'GET'</span> &amp;&amp; cacheOption) {
      <span class="hljs-keyword">const</span> cached = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getFromCache</span>(url, cacheOption);
      <span class="hljs-keyword">if</span> (cached) {
        <span class="hljs-keyword">return</span> cached;
      }
    }
    
    <span class="hljs-comment">// 创建AbortController用于超时控制</span>
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
    <span class="hljs-keyword">const</span> abortSignal = signal || controller.<span class="hljs-property">signal</span>;
    
    <span class="hljs-comment">// 设置超时</span>
    <span class="hljs-keyword">const</span> timeoutId = timeout ? <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      controller.<span class="hljs-title function_">abort</span>();
    }, timeout) : <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> fetchOptions = {
        method,
        headers,
        <span class="hljs-attr">signal</span>: abortSignal,
        ...restOptions
      };
      
      <span class="hljs-comment">// 处理请求体</span>
      <span class="hljs-keyword">if</span> (body) {
        <span class="hljs-keyword">if</span> (body <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FormData</span> || body <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">URLSearchParams</span>) {
          fetchOptions.<span class="hljs-property">body</span> = body;
          <span class="hljs-comment">// FormData会自己设置Content-Type</span>
          <span class="hljs-keyword">if</span> (fetchOptions.<span class="hljs-property">headers</span> &amp;&amp; fetchOptions.<span class="hljs-property">headers</span>[<span class="hljs-string">'Content-Type'</span>]) {
            <span class="hljs-keyword">delete</span> fetchOptions.<span class="hljs-property">headers</span>[<span class="hljs-string">'Content-Type'</span>];
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> body === <span class="hljs-string">'object'</span>) {
          fetchOptions.<span class="hljs-property">body</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(body);
        } <span class="hljs-keyword">else</span> {
          fetchOptions.<span class="hljs-property">body</span> = body;
        }
      }
      
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, fetchOptions);
      
      <span class="hljs-comment">// 清除超时定时器</span>
      <span class="hljs-keyword">if</span> (timeoutId) <span class="hljs-built_in">clearTimeout</span>(timeoutId);
      
      <span class="hljs-comment">// 解析响应</span>
      <span class="hljs-keyword">const</span> contentType = response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'content-type'</span>);
      <span class="hljs-keyword">let</span> data;
      
      <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'application/json'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'text/'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentType.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'multipart/form-data'</span>)) {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">formData</span>();
      } <span class="hljs-keyword">else</span> {
        data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();
      }
      
      <span class="hljs-keyword">const</span> result = {
        data,
        <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span>,
        <span class="hljs-attr">statusText</span>: response.<span class="hljs-property">statusText</span>,
        <span class="hljs-attr">headers</span>: response.<span class="hljs-property">headers</span>,
        config,
        requestId
      };
      
      <span class="hljs-comment">// 缓存响应</span>
      <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">'GET'</span> &amp;&amp; cacheOption &amp;&amp; response.<span class="hljs-property">ok</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setCache</span>(url, result, cacheOption);
      }
      
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createError</span>(response, data, config);
      }
      
      <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 清除超时定时器</span>
      <span class="hljs-keyword">if</span> (timeoutId) <span class="hljs-built_in">clearTimeout</span>(timeoutId);
      
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createError</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">'Request timeout'</span>, config);
      }
      
      <span class="hljs-keyword">throw</span> error;
    }
  }
  
  <span class="hljs-comment">// 创建错误对象</span>
  <span class="hljs-title function_">createError</span>(<span class="hljs-params">response, data, config</span>) {
    <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      response ? <span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span> : <span class="hljs-string">'Network Error'</span>
    );
    
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(error, {
      config,
      <span class="hljs-attr">response</span>: response ? {
        data,
        <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span>,
        <span class="hljs-attr">statusText</span>: response.<span class="hljs-property">statusText</span>,
        <span class="hljs-attr">headers</span>: response.<span class="hljs-property">headers</span>
      } : <span class="hljs-literal">null</span>,
      <span class="hljs-attr">isHttpError</span>: <span class="hljs-literal">true</span>
    });
    
    <span class="hljs-keyword">return</span> error;
  }
  
  <span class="hljs-comment">// 生成请求ID</span>
  <span class="hljs-title function_">generateRequestId</span>(<span class="hljs-params">url, options</span>) {
    <span class="hljs-keyword">const</span> { method = <span class="hljs-string">'GET'</span>, body } = options;
    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> bodyHash = body ? <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashString</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(body)) : <span class="hljs-string">''</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${method}</span>_<span class="hljs-subst">${url}</span>_<span class="hljs-subst">${bodyHash}</span>_<span class="hljs-subst">${timestamp}</span>`</span>;
  }
  
  <span class="hljs-comment">// 简单的字符串哈希</span>
  <span class="hljs-title function_">hashString</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> char = str.<span class="hljs-title function_">charCodeAt</span>(i);
      hash = ((hash &lt;&lt; <span class="hljs-number">5</span>) - hash) + char;
      hash = hash &amp; hash;
    }
    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>);
  }
  
  <span class="hljs-comment">// HTTP方法快捷方式</span>
  <span class="hljs-title function_">get</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span> });
  }
  
  <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: data });
  }
  
  <span class="hljs-title function_">put</span>(<span class="hljs-params">url, data, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>, <span class="hljs-attr">body</span>: data });
  }
  
  <span class="hljs-title function_">patch</span>(<span class="hljs-params">url, data, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'PATCH'</span>, <span class="hljs-attr">body</span>: data });
  }
  
  <span class="hljs-title function_">delete</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span> });
  }
  
  <span class="hljs-title function_">head</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'HEAD'</span> });
  }
  
  <span class="hljs-title function_">options</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'OPTIONS'</span> });
  }
  
  <span class="hljs-comment">// 拦截器管理</span>
  interceptors = {
    <span class="hljs-attr">request</span>: {
      <span class="hljs-attr">handlers</span>: [],
      <span class="hljs-title function_">use</span>(<span class="hljs-params">handler</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">push</span>(handler);
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">indexOf</span>(handler);
          <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        };
      },
      <span class="hljs-title function_">eject</span>(<span class="hljs-params">handler</span>) {
        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">indexOf</span>(handler);
        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
      }
    },
    <span class="hljs-attr">response</span>: {
      <span class="hljs-attr">handlers</span>: [],
      <span class="hljs-title function_">use</span>(<span class="hljs-params">onFulfilled, onRejected</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">push</span>({ onFulfilled, onRejected });
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> 
            h.<span class="hljs-property">onFulfilled</span> === onFulfilled &amp;&amp; h.<span class="hljs-property">onRejected</span> === onRejected
          );
          <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        };
      },
      <span class="hljs-title function_">eject</span>(<span class="hljs-params">handler</span>) {
        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> 
          h.<span class="hljs-property">onFulfilled</span> === handler.<span class="hljs-property">onFulfilled</span> &amp;&amp; 
          h.<span class="hljs-property">onRejected</span> === handler.<span class="hljs-property">onRejected</span>
        );
        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
      }
    },
    <span class="hljs-attr">error</span>: {
      <span class="hljs-attr">handlers</span>: [],
      <span class="hljs-title function_">use</span>(<span class="hljs-params">handler</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">push</span>(handler);
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">indexOf</span>(handler);
          <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        };
      },
      <span class="hljs-title function_">eject</span>(<span class="hljs-params">handler</span>) {
        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">indexOf</span>(handler);
        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
      }
    }
  };
  
  <span class="hljs-comment">// 缓存管理</span>
  <span class="hljs-title function_">getFromCache</span>(<span class="hljs-params">url, cacheOption</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(url)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">const</span> cached = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(url);
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-comment">// 检查是否过期</span>
    <span class="hljs-keyword">if</span> (cacheOption === <span class="hljs-string">'no-cache'</span> || 
        (cached.<span class="hljs-property">expiry</span> &amp;&amp; cached.<span class="hljs-property">expiry</span> &lt; now)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(url);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    
    <span class="hljs-keyword">return</span> cached.<span class="hljs-property">data</span>;
  }
  
  <span class="hljs-title function_">setCache</span>(<span class="hljs-params">url, data, cacheOption</span>) {
    <span class="hljs-keyword">let</span> expiry = <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cacheOption === <span class="hljs-string">'number'</span>) {
      expiry = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + cacheOption; <span class="hljs-comment">// 毫秒</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cacheOption === <span class="hljs-string">'short'</span>) {
      expiry = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + (<span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 5分钟</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cacheOption === <span class="hljs-string">'long'</span>) {
      expiry = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1小时</span>
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(url, { data, expiry });
    
    <span class="hljs-comment">// 清理过期缓存</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupCache</span>();
  }
  
  <span class="hljs-title function_">cleanupCache</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [url, cached] <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">entries</span>()) {
      <span class="hljs-keyword">if</span> (cached.<span class="hljs-property">expiry</span> &amp;&amp; cached.<span class="hljs-property">expiry</span> &lt; now) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(url);
      }
    }
  }
  
  <span class="hljs-comment">// 清除缓存</span>
  <span class="hljs-title function_">clearCache</span>(<span class="hljs-params">url = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-keyword">if</span> (url) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(url);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">clear</span>();
    }
  }
  
  <span class="hljs-comment">// 从cookie获取值</span>
  <span class="hljs-title function_">getCookie</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">const</span> match = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">match</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">'(^| )'</span> + name + <span class="hljs-string">'=([^;]+)'</span>));
    <span class="hljs-keyword">return</span> match ? <span class="hljs-built_in">decodeURIComponent</span>(match[<span class="hljs-number">2</span>]) : <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-comment">// 处理未授权</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleUnauthorized</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 尝试刷新token</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> refreshToken = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'refresh_token'</span>);
      <span class="hljs-keyword">if</span> (refreshToken) {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/auth/refresh'</span>, {
          <span class="hljs-attr">refresh_token</span>: refreshToken
        });
        
        <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">access_token</span>) {
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'auth_token'</span>, response.<span class="hljs-property">data</span>.<span class="hljs-property">access_token</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 刷新失败，清除本地认证信息</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'auth_token'</span>);
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'refresh_token'</span>);
      
      <span class="hljs-comment">// 跳转到登录页</span>
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 批量请求</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">requests</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(requests);
  }
  
  <span class="hljs-comment">// 请求并发控制</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">spread</span>(<span class="hljs-params">requests, maxConcurrent = <span class="hljs-variable language_">this</span>.maxConcurrent</span>) {
    <span class="hljs-keyword">const</span> results = [];
    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">runNext</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (index &gt;= requests.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;
      
      <span class="hljs-keyword">const</span> currentIndex = index++;
      <span class="hljs-keyword">const</span> request = requests[currentIndex];
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>();
        results[currentIndex] = { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: result };
      } <span class="hljs-keyword">catch</span> (error) {
        results[currentIndex] = { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: error };
      }
      
      <span class="hljs-comment">// 递归执行下一个</span>
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">runNext</span>();
    };
    
    <span class="hljs-comment">// 创建并发执行器</span>
    <span class="hljs-keyword">const</span> concurrentPromises = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxConcurrent, requests.<span class="hljs-property">length</span>); i++) {
      concurrentPromises.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">runNext</span>());
    }
    
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(concurrentPromises);
    <span class="hljs-keyword">return</span> results;
  }
}
</code></pre>
<h5 data-id="heading-6">2.2 请求拦截器的高级实现</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedInterceptor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">httpClient</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span> = httpClient;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupAdvancedInterceptors</span>();
  }
  
  <span class="hljs-title function_">setupAdvancedInterceptors</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 1. 请求节流/防抖拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addThrottleInterceptor</span>();
    
    <span class="hljs-comment">// 2. 请求合并拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addBatchInterceptor</span>();
    
    <span class="hljs-comment">// 3. 请求重试拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addRetryInterceptor</span>();
    
    <span class="hljs-comment">// 4. 请求缓存拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addCacheInterceptor</span>();
    
    <span class="hljs-comment">// 5. 请求日志拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addLoggingInterceptor</span>();
    
    <span class="hljs-comment">// 6. 性能监控拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addPerformanceInterceptor</span>();
  }
  
  <span class="hljs-title function_">addThrottleInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> requestTimestamps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> requestQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-keyword">async</span> (config) =&gt; {
        <span class="hljs-keyword">const</span> { throttle = <span class="hljs-literal">false</span>, debounce = <span class="hljs-literal">false</span>, delay = <span class="hljs-number">1000</span> } = config;
        
        <span class="hljs-keyword">if</span> (!throttle &amp;&amp; !debounce) <span class="hljs-keyword">return</span> config;
        
        <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">`<span class="hljs-subst">${config.method}</span>_<span class="hljs-subst">${config.url}</span>`</span>;
        
        <span class="hljs-comment">// 节流处理</span>
        <span class="hljs-keyword">if</span> (throttle) {
          <span class="hljs-keyword">const</span> lastRequestTime = requestTimestamps.<span class="hljs-title function_">get</span>(requestKey) || <span class="hljs-number">0</span>;
          <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
          
          <span class="hljs-keyword">if</span> (now - lastRequestTime &lt; delay) {
            <span class="hljs-comment">// 仍在节流期内，延迟请求</span>
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
              <span class="hljs-built_in">setTimeout</span>(resolve, delay - (now - lastRequestTime));
            });
          }
          
          requestTimestamps.<span class="hljs-title function_">set</span>(requestKey, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());
        }
        
        <span class="hljs-comment">// 防抖处理</span>
        <span class="hljs-keyword">if</span> (debounce) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
            <span class="hljs-comment">// 清除之前的定时器</span>
            <span class="hljs-keyword">if</span> (requestQueue.<span class="hljs-title function_">has</span>(requestKey)) {
              <span class="hljs-built_in">clearTimeout</span>(requestQueue.<span class="hljs-title function_">get</span>(requestKey));
            }
            
            <span class="hljs-comment">// 设置新的定时器</span>
            <span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
              requestQueue.<span class="hljs-title function_">delete</span>(requestKey);
              <span class="hljs-title function_">resolve</span>(config);
            }, delay);
            
            requestQueue.<span class="hljs-title function_">set</span>(requestKey, timerId);
          });
        }
        
        <span class="hljs-keyword">return</span> config;
      }
    );
  }
  
  <span class="hljs-title function_">addBatchInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> batchRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BATCH_DELAY</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 100ms批处理窗口</span>
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> { batch = <span class="hljs-literal">false</span>, batchKey } = config;
        
        <span class="hljs-keyword">if</span> (!batch) <span class="hljs-keyword">return</span> config;
        
        <span class="hljs-keyword">const</span> key = batchKey || config.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">'?'</span>)[<span class="hljs-number">0</span>];
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (!batchRequests.<span class="hljs-title function_">has</span>(key)) {
            batchRequests.<span class="hljs-title function_">set</span>(key, {
              <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-attr">requests</span>: []
            });
          }
          
          <span class="hljs-keyword">const</span> batchInfo = batchRequests.<span class="hljs-title function_">get</span>(key);
          batchInfo.<span class="hljs-property">requests</span>.<span class="hljs-title function_">push</span>({ config, resolve });
          
          <span class="hljs-comment">// 清除之前的定时器</span>
          <span class="hljs-keyword">if</span> (batchInfo.<span class="hljs-property">timer</span>) {
            <span class="hljs-built_in">clearTimeout</span>(batchInfo.<span class="hljs-property">timer</span>);
          }
          
          <span class="hljs-comment">// 设置新的定时器</span>
          batchInfo.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">const</span> requests = batchInfo.<span class="hljs-property">requests</span>;
            batchRequests.<span class="hljs-title function_">delete</span>(key);
            
            <span class="hljs-comment">// 合并请求</span>
            <span class="hljs-keyword">const</span> mergedConfig = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeBatchRequests</span>(requests);
            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-title function_">request</span>(mergedConfig.<span class="hljs-property">url</span>, mergedConfig);
            
            <span class="hljs-comment">// 分发响应</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">distributeBatchResponse</span>(requests, response);
          }, <span class="hljs-variable constant_">BATCH_DELAY</span>);
        });
      }
    );
  }
  
  <span class="hljs-title function_">mergeBatchRequests</span>(<span class="hljs-params">requests</span>) {
    <span class="hljs-comment">// 简单示例：合并GET请求参数</span>
    <span class="hljs-keyword">const</span> firstConfig = requests[<span class="hljs-number">0</span>].<span class="hljs-property">config</span>;
    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(firstConfig.<span class="hljs-property">url</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>);
    
    <span class="hljs-comment">// 收集所有请求的参数</span>
    <span class="hljs-keyword">const</span> allParams = [];
    requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ config }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> requestUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(config.<span class="hljs-property">url</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>);
      <span class="hljs-keyword">const</span> params = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(requestUrl.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">entries</span>());
      allParams.<span class="hljs-title function_">push</span>(params);
    });
    
    <span class="hljs-comment">// 设置批处理参数</span>
    url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'batch'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(allParams));
    
    <span class="hljs-keyword">return</span> {
      ...firstConfig,
      <span class="hljs-attr">url</span>: url.<span class="hljs-title function_">toString</span>(),
      <span class="hljs-attr">batch</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 防止递归</span>
    };
  }
  
  <span class="hljs-title function_">distributeBatchResponse</span>(<span class="hljs-params">requests, batchResponse</span>) {
    <span class="hljs-comment">// 这里需要根据实际API的批处理响应格式来分发</span>
    <span class="hljs-comment">// 假设API返回数组，顺序对应请求顺序</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(batchResponse.<span class="hljs-property">data</span>)) {
      requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ resolve }, index</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> individualResponse = {
          ...batchResponse,
          <span class="hljs-attr">data</span>: batchResponse.<span class="hljs-property">data</span>[index]
        };
        <span class="hljs-title function_">resolve</span>(individualResponse);
      });
    }
  }
  
  <span class="hljs-title function_">addRetryInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,
      <span class="hljs-keyword">async</span> (error) =&gt; {
        <span class="hljs-keyword">const</span> config = error.<span class="hljs-property">config</span> || {};
        <span class="hljs-keyword">const</span> { retry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">retryConfig</span>, __retryCount = <span class="hljs-number">0</span> } = config;
        
        <span class="hljs-comment">// 检查是否应该重试</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">shouldRetry</span>(error, retry, __retryCount)) {
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
        }
        
        <span class="hljs-comment">// 增加重试计数</span>
        config.<span class="hljs-property">__retryCount</span> = __retryCount + <span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// 计算延迟时间（指数退避）</span>
        <span class="hljs-keyword">const</span> delay = retry.<span class="hljs-property">retryDelay</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, __retryCount);
        
        <span class="hljs-comment">// 等待延迟时间</span>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, delay));
        
        <span class="hljs-comment">// 重试请求</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-title function_">request</span>(config.<span class="hljs-property">url</span>, config);
      }
    );
  }
  
  <span class="hljs-title function_">shouldRetry</span>(<span class="hljs-params">error, retryConfig, retryCount</span>) {
    <span class="hljs-comment">// 检查最大重试次数</span>
    <span class="hljs-keyword">if</span> (retryCount &gt;= retryConfig.<span class="hljs-property">maxRetries</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-comment">// 检查错误类型</span>
    <span class="hljs-keyword">if</span> (!error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// 网络错误应该重试</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-comment">// 检查状态码</span>
    <span class="hljs-keyword">const</span> status = error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>;
    <span class="hljs-keyword">return</span> retryConfig.<span class="hljs-property">retryOn</span>.<span class="hljs-title function_">includes</span>(status);
  }
  
  <span class="hljs-title function_">addCacheInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> { cache = <span class="hljs-literal">false</span>, forceRefresh = <span class="hljs-literal">false</span> } = config;
        
        <span class="hljs-keyword">if</span> (!cache || forceRefresh) <span class="hljs-keyword">return</span> config;
        
        <span class="hljs-comment">// 检查内存缓存</span>
        <span class="hljs-keyword">const</span> cached = <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-title function_">getFromCache</span>(config.<span class="hljs-property">url</span>, cache);
        <span class="hljs-keyword">if</span> (cached) {
          <span class="hljs-comment">// 返回缓存的响应，不再发送请求</span>
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>({
            config,
            <span class="hljs-attr">response</span>: cached,
            <span class="hljs-attr">isCacheHit</span>: <span class="hljs-literal">true</span>
          });
        }
        
        <span class="hljs-keyword">return</span> config;
      }
    );
    
    <span class="hljs-comment">// 处理缓存命中</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,
      <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">isCacheHit</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(error.<span class="hljs-property">response</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
      }
    );
  }
  
  <span class="hljs-title function_">addLoggingInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 请求日志</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">`🌐 Request: <span class="hljs-subst">${config.method}</span> <span class="hljs-subst">${config.url}</span>`</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Config:'</span>, config);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
        
        <span class="hljs-comment">// 添加请求时间戳</span>
        config.<span class="hljs-property">__startTime</span> = performance.<span class="hljs-title function_">now</span>();
        
        <span class="hljs-keyword">return</span> config;
      }
    );
    
    <span class="hljs-comment">// 响应日志</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> duration = performance.<span class="hljs-title function_">now</span>() - response.<span class="hljs-property">config</span>.<span class="hljs-property">__startTime</span>;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">`✅ Response: <span class="hljs-subst">${response.status}</span> <span class="hljs-subst">${response.config.url}</span>`</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Response:'</span>, response);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Duration: <span class="hljs-subst">${duration.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
        
        <span class="hljs-comment">// 发送性能数据到监控系统</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendMetrics</span>({
          <span class="hljs-attr">url</span>: response.<span class="hljs-property">config</span>.<span class="hljs-property">url</span>,
          <span class="hljs-attr">method</span>: response.<span class="hljs-property">config</span>.<span class="hljs-property">method</span>,
          <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span>,
          duration,
          <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
        });
        
        <span class="hljs-keyword">return</span> response;
      },
      <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> duration = error.<span class="hljs-property">config</span> ? 
          performance.<span class="hljs-title function_">now</span>() - error.<span class="hljs-property">config</span>.<span class="hljs-property">__startTime</span> : <span class="hljs-number">0</span>;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">`❌ Error: <span class="hljs-subst">${error.config?.url}</span>`</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Error:'</span>, error);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Duration: <span class="hljs-subst">${duration.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();
        
        <span class="hljs-comment">// 发送错误数据到监控系统</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendErrorMetrics</span>({
          <span class="hljs-attr">url</span>: error.<span class="hljs-property">config</span>?.<span class="hljs-property">url</span>,
          <span class="hljs-attr">method</span>: error.<span class="hljs-property">config</span>?.<span class="hljs-property">method</span>,
          <span class="hljs-attr">status</span>: error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span>,
          duration,
          <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>,
          <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
        });
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
      }
    );
  }
  
  <span class="hljs-title function_">addPerformanceInterceptor</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> performanceData = [];
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX_PERFORMANCE_ENTRIES</span> = <span class="hljs-number">100</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
        <span class="hljs-comment">// 使用Performance API标记请求开始</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">mark</span>) {
          <span class="hljs-keyword">const</span> markName = <span class="hljs-string">`request_start_<span class="hljs-subst">${config.url.replace(/[^a-z0-<span class="hljs-number">9</span>]/gi, <span class="hljs-string">'_'</span>)}</span>`</span>;
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-title function_">mark</span>(markName);
          config.<span class="hljs-property">__performanceMark</span> = markName;
        }
        
        <span class="hljs-keyword">return</span> config;
      }
    );
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
      <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-comment">// 测量请求性能</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span> &amp;&amp; response.<span class="hljs-property">config</span>.<span class="hljs-property">__performanceMark</span>) {
          <span class="hljs-keyword">const</span> markName = response.<span class="hljs-property">config</span>.<span class="hljs-property">__performanceMark</span>;
          <span class="hljs-keyword">const</span> measureName = <span class="hljs-string">`request_<span class="hljs-subst">${response.config.url.replace(/[^a-z0-<span class="hljs-number">9</span>]/gi, <span class="hljs-string">'_'</span>)}</span>`</span>;
          
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-title function_">mark</span>(<span class="hljs-string">`<span class="hljs-subst">${markName}</span>_end`</span>);
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-title function_">measure</span>(
            measureName,
            markName,
            <span class="hljs-string">`<span class="hljs-subst">${markName}</span>_end`</span>
          );
          
          <span class="hljs-comment">// 获取测量结果</span>
          <span class="hljs-keyword">const</span> measures = <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-title function_">getEntriesByName</span>(measureName);
          <span class="hljs-keyword">if</span> (measures.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">const</span> measure = measures[<span class="hljs-number">0</span>];
            
            performanceData.<span class="hljs-title function_">push</span>({
              <span class="hljs-attr">url</span>: response.<span class="hljs-property">config</span>.<span class="hljs-property">url</span>,
              <span class="hljs-attr">duration</span>: measure.<span class="hljs-property">duration</span>,
              <span class="hljs-attr">startTime</span>: measure.<span class="hljs-property">startTime</span>,
              <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
            });
            
            <span class="hljs-comment">// 限制数据大小</span>
            <span class="hljs-keyword">if</span> (performanceData.<span class="hljs-property">length</span> &gt; <span class="hljs-variable constant_">MAX_PERFORMANCE_ENTRIES</span>) {
              performanceData.<span class="hljs-title function_">shift</span>();
            }
          }
        }
        
        <span class="hljs-keyword">return</span> response;
      }
    );
  }
  
  <span class="hljs-title function_">sendMetrics</span>(<span class="hljs-params">metric</span>) {
    <span class="hljs-comment">// 发送到监控系统（例如：Google Analytics，自建监控等）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">gtag</span>) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">gtag</span>(<span class="hljs-string">'event'</span>, <span class="hljs-string">'request_completed'</span>, metric);
    }
    
    <span class="hljs-comment">// 或者发送到后端</span>
    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">sendBeacon</span>) {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(metric)], { <span class="hljs-attr">type</span>: <span class="hljs-string">'application/json'</span> });
      navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">'/api/metrics'</span>, data);
    }
  }
  
  <span class="hljs-title function_">sendErrorMetrics</span>(<span class="hljs-params">errorMetric</span>) {
    <span class="hljs-comment">// 发送错误监控</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">Rollbar</span>) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">Rollbar</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'HTTP Request Error'</span>, errorMetric);
    }
    
    <span class="hljs-comment">// 发送到后端</span>
    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">sendBeacon</span>) {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(errorMetric)], { <span class="hljs-attr">type</span>: <span class="hljs-string">'application/json'</span> });
      navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">'/api/errors'</span>, data);
    }
  }
  
  <span class="hljs-comment">// 获取性能报告</span>
  <span class="hljs-title function_">getPerformanceReport</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> totalRequests = performanceData.<span class="hljs-property">length</span>;
    
    <span class="hljs-keyword">if</span> (totalRequests === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">averageDuration</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">totalRequests</span>: <span class="hljs-number">0</span> };
    }
    
    <span class="hljs-keyword">const</span> totalDuration = performanceData.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, entry</span>) =&gt;</span> sum + entry.<span class="hljs-property">duration</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> averageDuration = totalDuration / totalRequests;
    
    <span class="hljs-comment">// 按URL分组</span>
    <span class="hljs-keyword">const</span> urlStats = {};
    performanceData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!urlStats[entry.<span class="hljs-property">url</span>]) {
        urlStats[entry.<span class="hljs-property">url</span>] = {
          <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">totalDuration</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">durations</span>: []
        };
      }
      
      urlStats[entry.<span class="hljs-property">url</span>].<span class="hljs-property">count</span>++;
      urlStats[entry.<span class="hljs-property">url</span>].<span class="hljs-property">totalDuration</span> += entry.<span class="hljs-property">duration</span>;
      urlStats[entry.<span class="hljs-property">url</span>].<span class="hljs-property">durations</span>.<span class="hljs-title function_">push</span>(entry.<span class="hljs-property">duration</span>);
    });
    
    <span class="hljs-comment">// 计算每个URL的平均值</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(urlStats).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> stats = urlStats[url];
      stats.<span class="hljs-property">averageDuration</span> = stats.<span class="hljs-property">totalDuration</span> / stats.<span class="hljs-property">count</span>;
      
      <span class="hljs-comment">// 计算p95</span>
      stats.<span class="hljs-property">durations</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
      <span class="hljs-keyword">const</span> p95Index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(stats.<span class="hljs-property">durations</span>.<span class="hljs-property">length</span> * <span class="hljs-number">0.95</span>);
      stats.<span class="hljs-property">p95</span> = stats.<span class="hljs-property">durations</span>[p95Index];
    });
    
    <span class="hljs-keyword">return</span> {
      totalRequests,
      averageDuration,
      urlStats,
      <span class="hljs-attr">recentRequests</span>: performanceData.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">10</span>)
    };
  }
}
</code></pre>
<h4 data-id="heading-7">三、请求取消与并发控制</h4>
<h5 data-id="heading-8">3.1 高级请求取消机制</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestCancellation</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelSources</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  }
  
  <span class="hljs-comment">// 创建取消令牌</span>
  <span class="hljs-title function_">createCancelToken</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> source = {
      <span class="hljs-attr">token</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">cancel</span>: <span class="hljs-literal">null</span>
    };
    
    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      source.<span class="hljs-property">cancel</span> = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellationError</span>(reason || <span class="hljs-string">'Request cancelled'</span>));
      };
    });
    
    source.<span class="hljs-property">token</span> = token;
    <span class="hljs-keyword">const</span> tokenId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateTokenId</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelSources</span>.<span class="hljs-title function_">set</span>(tokenId, source);
    
    <span class="hljs-keyword">return</span> {
      token,
      <span class="hljs-attr">cancel</span>: source.<span class="hljs-property">cancel</span>,
      tokenId
    };
  }
  
  <span class="hljs-comment">// 为请求添加取消支持</span>
  <span class="hljs-title function_">withCancellation</span>(<span class="hljs-params">requestPromise, cancelToken, requestId</span>) {
    <span class="hljs-keyword">if</span> (!cancelToken) <span class="hljs-keyword">return</span> requestPromise;
    
    <span class="hljs-keyword">const</span> abortController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
    <span class="hljs-keyword">const</span> signal = abortController.<span class="hljs-property">signal</span>;
    
    <span class="hljs-comment">// 包装请求以支持取消</span>
    <span class="hljs-keyword">const</span> wrappedPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([
      requestPromise,
      cancelToken.<span class="hljs-title function_">then</span>(
        <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellationError</span>(<span class="hljs-string">'Request cancelled by token'</span>))),
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {
        signal.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'abort'</span>, <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellationError</span>(<span class="hljs-string">'Request aborted'</span>));
        });
      })
    ]);
    
    <span class="hljs-comment">// 存储取消控制器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span>.<span class="hljs-title function_">set</span>(requestId, abortController);
    
    <span class="hljs-comment">// 清理函数</span>
    wrappedPromise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span>.<span class="hljs-title function_">delete</span>(requestId);
    });
    
    <span class="hljs-keyword">return</span> wrappedPromise;
  }
  
  <span class="hljs-comment">// 取消特定请求</span>
  <span class="hljs-title function_">cancelRequest</span>(<span class="hljs-params">requestId, reason</span>) {
    <span class="hljs-keyword">const</span> controller = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span>.<span class="hljs-title function_">get</span>(requestId);
    <span class="hljs-keyword">if</span> (controller) {
      controller.<span class="hljs-title function_">abort</span>(reason);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span>.<span class="hljs-title function_">delete</span>(requestId);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 取消一组请求</span>
  <span class="hljs-title function_">cancelGroup</span>(<span class="hljs-params">groupId, reason</span>) {
    <span class="hljs-keyword">const</span> group = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">get</span>(groupId);
    <span class="hljs-keyword">if</span> (!group) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    group.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">requestId</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelRequest</span>(requestId, reason);
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">delete</span>(groupId);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  
  <span class="hljs-comment">// 取消所有请求</span>
  <span class="hljs-title function_">cancelAll</span>(<span class="hljs-params">reason</span>) {
    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelTokens</span>.<span class="hljs-title function_">keys</span>()).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">requestId</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelRequest</span>(requestId, reason);
    });
    
    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">keys</span>()).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">groupId</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelGroup</span>(groupId, reason);
    });
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  
  <span class="hljs-comment">// 将请求添加到组</span>
  <span class="hljs-title function_">addToGroup</span>(<span class="hljs-params">requestId, groupId</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">has</span>(groupId)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">set</span>(groupId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">get</span>(groupId).<span class="hljs-title function_">add</span>(requestId);
    
    <span class="hljs-comment">// 返回移除函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> group = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">get</span>(groupId);
      <span class="hljs-keyword">if</span> (group) {
        group.<span class="hljs-title function_">delete</span>(requestId);
        <span class="hljs-keyword">if</span> (group.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">delete</span>(groupId);
        }
      }
    };
  }
  
  <span class="hljs-comment">// 生成令牌ID</span>
  <span class="hljs-title function_">generateTokenId</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`token_<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>_<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>;
  }
  
  <span class="hljs-comment">// 创建竞速请求（第一个成功或全部失败）</span>
  <span class="hljs-title function_">createRace</span>(<span class="hljs-params">requests, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      cancelPrevious = <span class="hljs-literal">true</span>,
      groupId = <span class="hljs-string">`race_<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>
    } = options;
    
    <span class="hljs-comment">// 如果取消之前的请求</span>
    <span class="hljs-keyword">if</span> (cancelPrevious) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelGroup</span>(groupId, <span class="hljs-string">'Superseded by new request'</span>);
    }
    
    <span class="hljs-keyword">const</span> racePromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(requests);
    
    <span class="hljs-comment">// 为每个请求添加到组</span>
    requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">request, index</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> requestId = <span class="hljs-string">`<span class="hljs-subst">${groupId}</span>_<span class="hljs-subst">${index}</span>`</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addToGroup</span>(requestId, groupId);
      
      <span class="hljs-comment">// 请求完成后从组中移除</span>
      request.<span class="hljs-title function_">then</span>(
        <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeFromGroup</span>(requestId, groupId),
        <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeFromGroup</span>(requestId, groupId)
      );
    });
    
    <span class="hljs-keyword">return</span> racePromise;
  }
  
  <span class="hljs-comment">// 从组中移除请求</span>
  <span class="hljs-title function_">removeFromGroup</span>(<span class="hljs-params">requestId, groupId</span>) {
    <span class="hljs-keyword">const</span> group = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">get</span>(groupId);
    <span class="hljs-keyword">if</span> (group) {
      group.<span class="hljs-title function_">delete</span>(requestId);
      <span class="hljs-keyword">if</span> (group.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestGroups</span>.<span class="hljs-title function_">delete</span>(groupId);
      }
    }
  }
  
  <span class="hljs-comment">// 创建请求池</span>
  <span class="hljs-title function_">createRequestPool</span>(<span class="hljs-params">maxConcurrent = <span class="hljs-number">5</span></span>) {
    <span class="hljs-keyword">const</span> queue = [];
    <span class="hljs-keyword">let</span> activeCount = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">runNext</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (activeCount &gt;= maxConcurrent || queue.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span>;
      }
      
      activeCount++;
      <span class="hljs-keyword">const</span> { request, resolve, reject } = queue.<span class="hljs-title function_">shift</span>();
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>();
        <span class="hljs-title function_">resolve</span>(result);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-title function_">reject</span>(error);
      } <span class="hljs-keyword">finally</span> {
        activeCount--;
        <span class="hljs-title function_">runNext</span>();
      }
    };
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">enqueue</span> = (<span class="hljs-params">request</span>) =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        queue.<span class="hljs-title function_">push</span>({ request, resolve, reject });
        <span class="hljs-title function_">runNext</span>();
      });
    };
    
    <span class="hljs-keyword">return</span> {
      enqueue,
      <span class="hljs-attr">getQueueSize</span>: <span class="hljs-function">() =&gt;</span> queue.<span class="hljs-property">length</span>,
      <span class="hljs-attr">getActiveCount</span>: <span class="hljs-function">() =&gt;</span> activeCount
    };
  }
  
  <span class="hljs-comment">// 批量请求的并发控制</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">batchWithConcurrency</span>(<span class="hljs-params">requests, concurrency = <span class="hljs-number">3</span></span>) {
    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(requests.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">let</span> currentIndex = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">executeNext</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (currentIndex &gt;= requests.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;
      
      <span class="hljs-keyword">const</span> index = currentIndex++;
      <span class="hljs-keyword">const</span> request = requests[index];
      
      <span class="hljs-keyword">try</span> {
        results[index] = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>();
      } <span class="hljs-keyword">catch</span> (error) {
        results[index] = error;
      }
      
      <span class="hljs-comment">// 执行下一个</span>
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeNext</span>();
    };
    
    <span class="hljs-comment">// 创建并发的执行器</span>
    <span class="hljs-keyword">const</span> concurrentPromises = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(concurrency, requests.<span class="hljs-property">length</span>); i++) {
      concurrentPromises.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">executeNext</span>());
    }
    
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(concurrentPromises);
    <span class="hljs-keyword">return</span> results;
  }
}

<span class="hljs-comment">// 自定义取消错误</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestCancellationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message = <span class="hljs-string">'Request cancelled'</span></span>) {
    <span class="hljs-variable language_">super</span>(message);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'RequestCancellationError'</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isCancelled</span> = <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CancellationExample</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">demonstrate</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> cancellation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellation</span>();
    
    <span class="hljs-comment">// 创建取消令牌</span>
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">token</span>: cancelToken, cancel } = cancellation.<span class="hljs-title function_">createCancelToken</span>();
    
    <span class="hljs-comment">// 创建请求</span>
    <span class="hljs-keyword">const</span> request1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data1'</span>);
    <span class="hljs-keyword">const</span> request2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data2'</span>);
    
    <span class="hljs-comment">// 包装请求以支持取消</span>
    <span class="hljs-keyword">const</span> cancellableRequest1 = cancellation.<span class="hljs-title function_">withCancellation</span>(
      request1,
      cancelToken,
      <span class="hljs-string">'request_1'</span>
    );
    
    <span class="hljs-keyword">const</span> cancellableRequest2 = cancellation.<span class="hljs-title function_">withCancellation</span>(
      request2,
      cancelToken,
      <span class="hljs-string">'request_2'</span>
    );
    
    <span class="hljs-comment">// 将请求添加到组</span>
    cancellation.<span class="hljs-title function_">addToGroup</span>(<span class="hljs-string">'request_1'</span>, <span class="hljs-string">'data_fetch_group'</span>);
    cancellation.<span class="hljs-title function_">addToGroup</span>(<span class="hljs-string">'request_2'</span>, <span class="hljs-string">'data_fetch_group'</span>);
    
    <span class="hljs-comment">// 模拟3秒后取消所有请求</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      cancellation.<span class="hljs-title function_">cancelGroup</span>(<span class="hljs-string">'data_fetch_group'</span>, <span class="hljs-string">'User cancelled'</span>);
    }, <span class="hljs-number">3000</span>);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
        cancellableRequest1,
        cancellableRequest2
      ]);
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Requests completed:'</span>, results);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">isCancelled</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Requests were cancelled:'</span>, error.<span class="hljs-property">message</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Request failed:'</span>, error);
      }
    }
    
    <span class="hljs-comment">// 使用请求池</span>
    <span class="hljs-keyword">const</span> pool = cancellation.<span class="hljs-title function_">createRequestPool</span>(<span class="hljs-number">2</span>);
    
    <span class="hljs-keyword">const</span> requests = [
      <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/item/1'</span>),
      <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/item/2'</span>),
      <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/item/3'</span>),
      <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/item/4'</span>),
      <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/item/5'</span>)
    ];
    
    <span class="hljs-keyword">const</span> poolResults = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
      requests.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">request</span> =&gt;</span> pool.<span class="hljs-title function_">enqueue</span>(request))
    );
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pool results:'</span>, poolResults);
  }
}
</code></pre>
<h5 data-id="heading-9">3.2 智能请求调度器</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelligentRequestScheduler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = {}</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = {
      <span class="hljs-attr">maxConcurrent</span>: <span class="hljs-number">6</span>,
      <span class="hljs-attr">priorityLevels</span>: [<span class="hljs-string">'high'</span>, <span class="hljs-string">'normal'</span>, <span class="hljs-string">'low'</span>],
      <span class="hljs-attr">retryEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">cacheEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">offlineQueueEnabled</span>: <span class="hljs-literal">true</span>,
      ...options
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span> = {
      <span class="hljs-attr">high</span>: [],
      <span class="hljs-attr">normal</span>: [],
      <span class="hljs-attr">low</span>: []
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestCache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> = navigator.<span class="hljs-property">onLine</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();
  }
  
  <span class="hljs-title function_">init</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 监听网络状态</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'online'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processOfflineQueue</span>();
    });
    
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'offline'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> = <span class="hljs-literal">false</span>;
    });
    
    <span class="hljs-comment">// 启动调度器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startScheduler</span>();
    
    <span class="hljs-comment">// 初始化重试策略</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initRetryStrategies</span>();
  }
  
  <span class="hljs-title function_">startScheduler</span>(<span class="hljs-params"/>) {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processQueues</span>();
    }, <span class="hljs-number">100</span>); <span class="hljs-comment">// 每100ms处理一次队列</span>
  }
  
  <span class="hljs-title function_">initRetryStrategies</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 默认重试策略</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'default'</span>, {
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">baseDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">maxDelay</span>: <span class="hljs-number">10000</span>,
      <span class="hljs-attr">backoffMultiplier</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">retryableStatuses</span>: [<span class="hljs-number">408</span>, <span class="hljs-number">429</span>, <span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>],
      <span class="hljs-attr">retryableErrors</span>: [<span class="hljs-string">'ECONNABORTED'</span>, <span class="hljs-string">'ETIMEDOUT'</span>, <span class="hljs-string">'NETWORK_ERROR'</span>]
    });
    
    <span class="hljs-comment">// 关键请求的重试策略</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'critical'</span>, {
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">5</span>,
      <span class="hljs-attr">baseDelay</span>: <span class="hljs-number">500</span>,
      <span class="hljs-attr">maxDelay</span>: <span class="hljs-number">30000</span>,
      <span class="hljs-attr">backoffMultiplier</span>: <span class="hljs-number">1.5</span>,
      <span class="hljs-attr">retryableStatuses</span>: [<span class="hljs-number">408</span>, <span class="hljs-number">429</span>, <span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>, <span class="hljs-number">502</span>],
      <span class="hljs-attr">retryableErrors</span>: [<span class="hljs-string">'ECONNABORTED'</span>, <span class="hljs-string">'ETIMEDOUT'</span>, <span class="hljs-string">'NETWORK_ERROR'</span>]
    });
    
    <span class="hljs-comment">// 非关键请求的重试策略</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'non-critical'</span>, {
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">baseDelay</span>: <span class="hljs-number">2000</span>,
      <span class="hljs-attr">maxDelay</span>: <span class="hljs-number">5000</span>,
      <span class="hljs-attr">backoffMultiplier</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">retryableStatuses</span>: [<span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>],
      <span class="hljs-attr">retryableErrors</span>: [<span class="hljs-string">'NETWORK_ERROR'</span>]
    });
  }
  
  <span class="hljs-comment">// 调度请求</span>
  <span class="hljs-title function_">schedule</span>(<span class="hljs-params">request, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      priority = <span class="hljs-string">'normal'</span>,
      retryStrategy = <span class="hljs-string">'default'</span>,
      cacheKey = <span class="hljs-literal">null</span>,
      offlineFallback = <span class="hljs-literal">false</span>,
      timeout = <span class="hljs-number">30000</span>,
      group = <span class="hljs-literal">null</span>
    } = options;
    
    <span class="hljs-keyword">const</span> requestId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateRequestId</span>(request, options);
    <span class="hljs-keyword">const</span> requestInfo = {
      <span class="hljs-attr">id</span>: requestId,
      request,
      options,
      priority,
      retryStrategy,
      cacheKey,
      offlineFallback,
      timeout,
      group,
      <span class="hljs-attr">status</span>: <span class="hljs-string">'pending'</span>,
      <span class="hljs-attr">retryCount</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">createdAt</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
      <span class="hljs-attr">scheduledAt</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">completedAt</span>: <span class="hljs-literal">null</span>
    };
    
    <span class="hljs-comment">// 检查缓存</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">cacheEnabled</span> &amp;&amp; cacheKey) {
      <span class="hljs-keyword">const</span> cached = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestCache</span>.<span class="hljs-title function_">get</span>(cacheKey);
      <span class="hljs-keyword">if</span> (cached &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isCacheExpired</span>(cached)) {
        requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'cached'</span>;
        requestInfo.<span class="hljs-property">result</span> = cached.<span class="hljs-property">data</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(cached.<span class="hljs-property">data</span>);
      }
    }
    
    <span class="hljs-comment">// 添加到相应优先级的队列</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>[priority].<span class="hljs-title function_">push</span>(requestInfo);
    
    <span class="hljs-comment">// 如果是离线状态且启用了离线队列</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">offlineQueueEnabled</span> &amp;&amp; offlineFallback) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-title function_">push</span>(requestInfo);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Offline - request queued'</span>));
    }
    
    <span class="hljs-comment">// 返回Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      requestInfo.<span class="hljs-property">resolve</span> = resolve;
      requestInfo.<span class="hljs-property">reject</span> = reject;
      
      <span class="hljs-comment">// 记录请求统计</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">recordRequestStat</span>(requestInfo);
    });
  }
  
  <span class="hljs-comment">// 处理队列</span>
  <span class="hljs-title function_">processQueues</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 检查是否有空闲槽位</span>
    <span class="hljs-keyword">const</span> availableSlots = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxConcurrent</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span>.<span class="hljs-property">size</span>;
    <span class="hljs-keyword">if</span> (availableSlots &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// 按优先级处理队列</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> priority <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">priorityLevels</span>) {
      <span class="hljs-keyword">const</span> queue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>[priority];
      
      <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; availableSlots &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> requestInfo = queue.<span class="hljs-title function_">shift</span>();
        
        <span class="hljs-comment">// 跳过已取消的请求</span>
        <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">status</span> === <span class="hljs-string">'cancelled'</span>) <span class="hljs-keyword">continue</span>;
        
        <span class="hljs-comment">// 标记为调度中</span>
        requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'scheduled'</span>;
        requestInfo.<span class="hljs-property">scheduledAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        
        <span class="hljs-comment">// 执行请求</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeRequest</span>(requestInfo);
      }
    }
  }
  
  <span class="hljs-comment">// 执行请求</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">executeRequest</span>(<span class="hljs-params">requestInfo</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span>.<span class="hljs-title function_">add</span>(requestInfo.<span class="hljs-property">id</span>);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 设置超时</span>
      <span class="hljs-keyword">const</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Request timeout after <span class="hljs-subst">${requestInfo.timeout}</span>ms`</span>));
        }, requestInfo.<span class="hljs-property">timeout</span>);
      });
      
      <span class="hljs-comment">// 执行请求</span>
      <span class="hljs-keyword">const</span> requestPromise = requestInfo.<span class="hljs-title function_">request</span>();
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([requestPromise, timeoutPromise]);
      
      <span class="hljs-comment">// 请求成功</span>
      requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'completed'</span>;
      requestInfo.<span class="hljs-property">completedAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      requestInfo.<span class="hljs-property">result</span> = result;
      
      <span class="hljs-comment">// 缓存结果</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">cacheEnabled</span> &amp;&amp; requestInfo.<span class="hljs-property">cacheKey</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestCache</span>.<span class="hljs-title function_">set</span>(requestInfo.<span class="hljs-property">cacheKey</span>, {
          <span class="hljs-attr">data</span>: result,
          <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
          <span class="hljs-attr">ttl</span>: requestInfo.<span class="hljs-property">options</span>.<span class="hljs-property">cacheTTL</span> || <span class="hljs-number">300000</span> <span class="hljs-comment">// 默认5分钟</span>
        });
      }
      
      <span class="hljs-comment">// 解析Promise</span>
      <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">resolve</span>) {
        requestInfo.<span class="hljs-title function_">resolve</span>(result);
      }
      
      <span class="hljs-comment">// 清理</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupRequest</span>(requestInfo);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 处理错误</span>
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequestError</span>(requestInfo, error);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span>.<span class="hljs-title function_">delete</span>(requestInfo.<span class="hljs-property">id</span>);
    }
  }
  
  <span class="hljs-comment">// 处理请求错误</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleRequestError</span>(<span class="hljs-params">requestInfo, error</span>) {
    requestInfo.<span class="hljs-property">lastError</span> = error;
    
    <span class="hljs-comment">// 检查是否需要重试</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">retryEnabled</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">shouldRetry</span>(requestInfo, error)) {
      requestInfo.<span class="hljs-property">retryCount</span>++;
      requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'retrying'</span>;
      
      <span class="hljs-comment">// 计算重试延迟</span>
      <span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateRetryDelay</span>(requestInfo);
      
      <span class="hljs-comment">// 延迟后重新加入队列</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'pending'</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>[requestInfo.<span class="hljs-property">priority</span>].<span class="hljs-title function_">push</span>(requestInfo);
      }, delay);
      
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 重试次数用完或不需要重试</span>
    requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'failed'</span>;
    requestInfo.<span class="hljs-property">completedAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-comment">// 如果是离线相关错误，加入离线队列</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> &amp;&amp; requestInfo.<span class="hljs-property">offlineFallback</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-title function_">push</span>(requestInfo);
    }
    
    <span class="hljs-comment">// 拒绝Promise</span>
    <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">reject</span>) {
      requestInfo.<span class="hljs-title function_">reject</span>(error);
    }
    
    <span class="hljs-comment">// 清理</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupRequest</span>(requestInfo);
  }
  
  <span class="hljs-comment">// 检查是否需要重试</span>
  <span class="hljs-title function_">shouldRetry</span>(<span class="hljs-params">requestInfo, error</span>) {
    <span class="hljs-keyword">const</span> strategy = <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">get</span>(requestInfo.<span class="hljs-property">retryStrategy</span>) || 
                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'default'</span>);
    
    <span class="hljs-comment">// 检查重试次数</span>
    <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">retryCount</span> &gt;= strategy.<span class="hljs-property">maxRetries</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 检查错误类型</span>
    <span class="hljs-keyword">const</span> errorType = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getErrorType</span>(error);
    
    <span class="hljs-keyword">if</span> (strategy.<span class="hljs-property">retryableErrors</span>.<span class="hljs-title function_">includes</span>(errorType)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-comment">// 检查HTTP状态码</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) {
      <span class="hljs-keyword">return</span> strategy.<span class="hljs-property">retryableStatuses</span>.<span class="hljs-title function_">includes</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 计算重试延迟（指数退避）</span>
  <span class="hljs-title function_">calculateRetryDelay</span>(<span class="hljs-params">requestInfo</span>) {
    <span class="hljs-keyword">const</span> strategy = <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">get</span>(requestInfo.<span class="hljs-property">retryStrategy</span>) || 
                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryStrategies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'default'</span>);
    
    <span class="hljs-keyword">const</span> baseDelay = strategy.<span class="hljs-property">baseDelay</span>;
    <span class="hljs-keyword">const</span> multiplier = strategy.<span class="hljs-property">backoffMultiplier</span>;
    <span class="hljs-keyword">const</span> maxDelay = strategy.<span class="hljs-property">maxDelay</span>;
    
    <span class="hljs-keyword">const</span> delay = baseDelay * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(multiplier, requestInfo.<span class="hljs-property">retryCount</span> - <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 添加随机抖动（防止惊群效应）</span>
    <span class="hljs-keyword">const</span> jitter = delay * <span class="hljs-number">0.1</span> * (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(delay + jitter, maxDelay);
  }
  
  <span class="hljs-comment">// 处理离线队列</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">processOfflineQueue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Processing <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.offlineQueue.length}</span> queued offline requests`</span>);
    
    <span class="hljs-comment">// 复制队列并清空原队列</span>
    <span class="hljs-keyword">const</span> queueToProcess = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span> = [];
    
    <span class="hljs-comment">// 处理队列中的请求</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> requestInfo <span class="hljs-keyword">of</span> queueToProcess) {
      requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'pending'</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>[requestInfo.<span class="hljs-property">priority</span>].<span class="hljs-title function_">push</span>(requestInfo);
    }
  }
  
  <span class="hljs-comment">// 清理请求</span>
  <span class="hljs-title function_">cleanupRequest</span>(<span class="hljs-params">requestInfo</span>) {
    <span class="hljs-comment">// 更新统计信息</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateRequestStats</span>(requestInfo);
    
    <span class="hljs-comment">// 从统计中移除旧记录</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupOldStats</span>();
  }
  
  <span class="hljs-comment">// 记录请求统计</span>
  <span class="hljs-title function_">recordRequestStat</span>(<span class="hljs-params">requestInfo</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">has</span>(requestInfo.<span class="hljs-property">id</span>)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">set</span>(requestInfo.<span class="hljs-property">id</span>, {
        <span class="hljs-attr">id</span>: requestInfo.<span class="hljs-property">id</span>,
        <span class="hljs-attr">priority</span>: requestInfo.<span class="hljs-property">priority</span>,
        <span class="hljs-attr">createdAt</span>: requestInfo.<span class="hljs-property">createdAt</span>,
        <span class="hljs-attr">completedAt</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">duration</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">'pending'</span>,
        <span class="hljs-attr">retryCount</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">group</span>: requestInfo.<span class="hljs-property">group</span>
      });
    }
  }
  
  <span class="hljs-comment">// 更新请求统计</span>
  <span class="hljs-title function_">updateRequestStats</span>(<span class="hljs-params">requestInfo</span>) {
    <span class="hljs-keyword">const</span> stat = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">get</span>(requestInfo.<span class="hljs-property">id</span>);
    <span class="hljs-keyword">if</span> (stat) {
      stat.<span class="hljs-property">status</span> = requestInfo.<span class="hljs-property">status</span>;
      stat.<span class="hljs-property">retryCount</span> = requestInfo.<span class="hljs-property">retryCount</span>;
      stat.<span class="hljs-property">completedAt</span> = requestInfo.<span class="hljs-property">completedAt</span>;
      
      <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">completedAt</span> &amp;&amp; requestInfo.<span class="hljs-property">createdAt</span>) {
        stat.<span class="hljs-property">duration</span> = requestInfo.<span class="hljs-property">completedAt</span> - requestInfo.<span class="hljs-property">createdAt</span>;
      }
    }
  }
  
  <span class="hljs-comment">// 清理旧统计</span>
  <span class="hljs-title function_">cleanupOldStats</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> oneHourAgo = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [id, stat] <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">entries</span>()) {
      <span class="hljs-keyword">if</span> (stat.<span class="hljs-property">createdAt</span> &lt; oneHourAgo) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">delete</span>(id);
      }
    }
  }
  
  <span class="hljs-comment">// 生成请求ID</span>
  <span class="hljs-title function_">generateRequestId</span>(<span class="hljs-params">request, options</span>) {
    <span class="hljs-keyword">const</span> requestString = request.<span class="hljs-title function_">toString</span>();
    <span class="hljs-keyword">const</span> optionsString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(options);
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">`req_<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>_<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.hashString(requestString + optionsString)}</span>`</span>;
  }
  
  <span class="hljs-comment">// 简单的哈希函数</span>
  <span class="hljs-title function_">hashString</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> char = str.<span class="hljs-title function_">charCodeAt</span>(i);
      hash = ((hash &lt;&lt; <span class="hljs-number">5</span>) - hash) + char;
      hash = hash &amp; hash;
    }
    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>);
  }
  
  <span class="hljs-comment">// 获取错误类型</span>
  <span class="hljs-title function_">getErrorType</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span>) <span class="hljs-keyword">return</span> error.<span class="hljs-property">code</span>;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span>) <span class="hljs-keyword">return</span> error.<span class="hljs-property">name</span>;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">message</span> &amp;&amp; error.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'timeout'</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">'ETIMEDOUT'</span>;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">message</span> &amp;&amp; error.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'network'</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">'NETWORK_ERROR'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'UNKNOWN_ERROR'</span>;
  }
  
  <span class="hljs-comment">// 检查缓存是否过期</span>
  <span class="hljs-title function_">isCacheExpired</span>(<span class="hljs-params">cacheEntry</span>) {
    <span class="hljs-keyword">if</span> (!cacheEntry.<span class="hljs-property">ttl</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt; cacheEntry.<span class="hljs-property">timestamp</span> + cacheEntry.<span class="hljs-property">ttl</span>;
  }
  
  <span class="hljs-comment">// 获取调度器状态</span>
  <span class="hljs-title function_">getStatus</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>)
      .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, queue</span>) =&gt;</span> sum + queue.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">const</span> stats = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestStats</span>.<span class="hljs-title function_">values</span>());
    
    <span class="hljs-keyword">const</span> successCount = stats.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">status</span> === <span class="hljs-string">'completed'</span>).<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> failedCount = stats.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">status</span> === <span class="hljs-string">'failed'</span>).<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> retryCount = stats.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, s</span>) =&gt;</span> sum + s.<span class="hljs-property">retryCount</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> avgDuration = stats
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">duration</span>)
      .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, s</span>) =&gt;</span> sum + s.<span class="hljs-property">duration</span>, <span class="hljs-number">0</span>) / 
      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>, stats.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">duration</span>).<span class="hljs-property">length</span>);
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">isOnline</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isOnline</span>,
      <span class="hljs-attr">activeRequests</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeRequests</span>.<span class="hljs-property">size</span>,
      pendingRequests,
      <span class="hljs-attr">offlineQueue</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-property">length</span>,
      <span class="hljs-attr">cacheSize</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestCache</span>.<span class="hljs-property">size</span>,
      <span class="hljs-attr">totalProcessed</span>: stats.<span class="hljs-property">length</span>,
      <span class="hljs-attr">successRate</span>: stats.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? (successCount / stats.<span class="hljs-property">length</span>) * <span class="hljs-number">100</span> : <span class="hljs-number">0</span>,
      <span class="hljs-attr">averageRetries</span>: stats.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? (retryCount / stats.<span class="hljs-property">length</span>) : <span class="hljs-number">0</span>,
      <span class="hljs-attr">averageDuration</span>: avgDuration,
      <span class="hljs-attr">queueSizes</span>: {
        <span class="hljs-attr">high</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>.<span class="hljs-property">high</span>.<span class="hljs-property">length</span>,
        <span class="hljs-attr">normal</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>.<span class="hljs-property">normal</span>.<span class="hljs-property">length</span>,
        <span class="hljs-attr">low</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>.<span class="hljs-property">low</span>.<span class="hljs-property">length</span>
      }
    };
  }
  
  <span class="hljs-comment">// 取消请求</span>
  <span class="hljs-title function_">cancelRequest</span>(<span class="hljs-params">requestId</span>) {
    <span class="hljs-comment">// 查找并标记请求为取消状态</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> priority <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">priorityLevels</span>) {
      <span class="hljs-keyword">const</span> queue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queues</span>[priority];
      <span class="hljs-keyword">const</span> index = queue.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span> req.<span class="hljs-property">id</span> === requestId);
      
      <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">const</span> requestInfo = queue[index];
        requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'cancelled'</span>;
        
        <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">reject</span>) {
          requestInfo.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellationError</span>(<span class="hljs-string">'Request cancelled'</span>));
        }
        
        queue.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }
    
    <span class="hljs-comment">// 检查离线队列</span>
    <span class="hljs-keyword">const</span> offlineIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span> req.<span class="hljs-property">id</span> === requestId);
    <span class="hljs-keyword">if</span> (offlineIndex !== -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> requestInfo = <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>[offlineIndex];
      requestInfo.<span class="hljs-property">status</span> = <span class="hljs-string">'cancelled'</span>;
      
      <span class="hljs-keyword">if</span> (requestInfo.<span class="hljs-property">reject</span>) {
        requestInfo.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCancellationError</span>(<span class="hljs-string">'Request cancelled'</span>));
      }
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">offlineQueue</span>.<span class="hljs-title function_">splice</span>(offlineIndex, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 清空缓存</span>
  <span class="hljs-title function_">clearCache</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestCache</span>.<span class="hljs-title function_">clear</span>();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulerExample</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">demonstrate</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelligentRequestScheduler</span>({
      <span class="hljs-attr">maxConcurrent</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">priorityLevels</span>: [<span class="hljs-string">'high'</span>, <span class="hljs-string">'normal'</span>, <span class="hljs-string">'low'</span>]
    });
    
    <span class="hljs-comment">// 创建一些请求函数</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">createRequest</span> = (<span class="hljs-params">id, delay = <span class="hljs-number">1000</span></span>) =&gt; <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Starting request <span class="hljs-subst">${id}</span>`</span>);
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, delay));
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Completed request <span class="hljs-subst">${id}</span>`</span>);
      <span class="hljs-keyword">return</span> { id, <span class="hljs-attr">data</span>: <span class="hljs-string">`Result from request <span class="hljs-subst">${id}</span>`</span> };
    };
    
    <span class="hljs-comment">// 调度不同优先级的请求</span>
    <span class="hljs-keyword">const</span> requests = [
      scheduler.<span class="hljs-title function_">schedule</span>(<span class="hljs-title function_">createRequest</span>(<span class="hljs-string">'high_1'</span>, <span class="hljs-number">500</span>), {
        <span class="hljs-attr">priority</span>: <span class="hljs-string">'high'</span>,
        <span class="hljs-attr">retryStrategy</span>: <span class="hljs-string">'critical'</span>,
        <span class="hljs-attr">cacheKey</span>: <span class="hljs-string">'request_high_1'</span>
      }),
      
      scheduler.<span class="hljs-title function_">schedule</span>(<span class="hljs-title function_">createRequest</span>(<span class="hljs-string">'normal_1'</span>, <span class="hljs-number">1000</span>), {
        <span class="hljs-attr">priority</span>: <span class="hljs-string">'normal'</span>,
        <span class="hljs-attr">cacheKey</span>: <span class="hljs-string">'request_normal_1'</span>
      }),
      
      scheduler.<span class="hljs-title function_">schedule</span>(<span class="hljs-title function_">createRequest</span>(<span class="hljs-string">'low_1'</span>, <span class="hljs-number">1500</span>), {
        <span class="hljs-attr">priority</span>: <span class="hljs-string">'low'</span>,
        <span class="hljs-attr">retryStrategy</span>: <span class="hljs-string">'non-critical'</span>
      }),
      
      scheduler.<span class="hljs-title function_">schedule</span>(<span class="hljs-title function_">createRequest</span>(<span class="hljs-string">'high_2'</span>, <span class="hljs-number">200</span>), {
        <span class="hljs-attr">priority</span>: <span class="hljs-string">'high'</span>,
        <span class="hljs-attr">offlineFallback</span>: <span class="hljs-literal">true</span>
      })
    ];
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(requests);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'All requests completed:'</span>, results);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Some requests failed:'</span>, error);
    }
    
    <span class="hljs-comment">// 获取调度器状态</span>
    <span class="hljs-keyword">const</span> status = scheduler.<span class="hljs-title function_">getStatus</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Scheduler status:'</span>, status);
    
    <span class="hljs-keyword">return</span> scheduler;
  }
}
</code></pre>
<h4 data-id="heading-10">四、WebSocket高级封装</h4>
<h5 data-id="heading-11">4.1 完整的WebSocket客户端</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketClient</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = {
      <span class="hljs-attr">protocols</span>: [],
      <span class="hljs-attr">reconnect</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">maxReconnectAttempts</span>: <span class="hljs-number">5</span>,
      <span class="hljs-attr">reconnectDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">heartbeatEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">heartbeatInterval</span>: <span class="hljs-number">30000</span>,
      <span class="hljs-attr">autoConnect</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">binaryType</span>: <span class="hljs-string">'blob'</span>,
      ...options
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimeout</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span> = <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 事件类型</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span> = {
      <span class="hljs-attr">OPEN</span>: <span class="hljs-string">'open'</span>,
      <span class="hljs-attr">CLOSE</span>: <span class="hljs-string">'close'</span>,
      <span class="hljs-attr">MESSAGE</span>: <span class="hljs-string">'message'</span>,
      <span class="hljs-attr">ERROR</span>: <span class="hljs-string">'error'</span>,
      <span class="hljs-attr">RECONNECT</span>: <span class="hljs-string">'reconnect'</span>,
      <span class="hljs-attr">HEARTBEAT</span>: <span class="hljs-string">'heartbeat'</span>
    };
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">autoConnect</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>();
    }
  }
  
  <span class="hljs-comment">// 连接WebSocket</span>
  <span class="hljs-title function_">connect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'WebSocket is already connected or connecting'</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">protocols</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">binaryType</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">binaryType</span>;
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupEventListeners</span>();
      
      <span class="hljs-comment">// 设置连接超时</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'WebSocket connection timeout'</span>);
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleConnectionError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Connection timeout'</span>));
        }
      }, <span class="hljs-number">10000</span>);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleConnectionError</span>(error);
    }
  }
  
  <span class="hljs-comment">// 设置事件监听器</span>
  <span class="hljs-title function_">setupEventListeners</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onopen</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> = <span class="hljs-number">0</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateConnectionId</span>();
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`WebSocket connected: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.url}</span>`</span>);
      
      <span class="hljs-comment">// 触发open事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">OPEN</span>, {
        <span class="hljs-attr">connectionId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span>,
        event
      });
      
      <span class="hljs-comment">// 启动心跳检测</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">heartbeatEnabled</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startHeartbeat</span>();
      }
      
      <span class="hljs-comment">// 发送队列中的消息</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">flushMessageQueue</span>();
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onclose</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`WebSocket closed: <span class="hljs-subst">${event.code}</span> <span class="hljs-subst">${event.reason}</span>`</span>);
      
      <span class="hljs-comment">// 触发close事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">CLOSE</span>, {
        <span class="hljs-attr">code</span>: event.<span class="hljs-property">code</span>,
        <span class="hljs-attr">reason</span>: event.<span class="hljs-property">reason</span>,
        <span class="hljs-attr">wasClean</span>: event.<span class="hljs-property">wasClean</span>,
        <span class="hljs-attr">connectionId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span>
      });
      
      <span class="hljs-comment">// 停止心跳检测</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopHeartbeat</span>();
      
      <span class="hljs-comment">// 尝试重连</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">reconnect</span> &amp;&amp; !event.<span class="hljs-property">wasClean</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attemptReconnect</span>();
      }
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-comment">// 处理心跳响应</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isHeartbeatMessage</span>(event.<span class="hljs-property">data</span>)) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">HEARTBEAT</span>, { <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-comment">// 触发message事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">MESSAGE</span>, {
        <span class="hljs-attr">data</span>: event.<span class="hljs-property">data</span>,
        <span class="hljs-attr">origin</span>: event.<span class="hljs-property">origin</span>,
        <span class="hljs-attr">connectionId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span>,
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      });
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket error:'</span>, event);
      
      <span class="hljs-comment">// 触发error事件</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">ERROR</span>, {
        <span class="hljs-attr">error</span>: event,
        <span class="hljs-attr">connectionId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span>
      });
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleConnectionError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'WebSocket error'</span>));
    };
  }
  
  <span class="hljs-comment">// 发送消息</span>
  <span class="hljs-title function_">send</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      queueIfNotConnected = <span class="hljs-literal">true</span>,
      retry = <span class="hljs-literal">false</span>,
      maxRetries = <span class="hljs-number">3</span>,
      retryDelay = <span class="hljs-number">1000</span>
    } = options;
    
    <span class="hljs-comment">// 如果未连接且允许排队</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> &amp;&amp; queueIfNotConnected) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span>.<span class="hljs-title function_">push</span>({ data, options, <span class="hljs-attr">retryCount</span>: <span class="hljs-number">0</span> });
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'WebSocket not connected, message queued'</span>));
    }
    
    <span class="hljs-comment">// 如果未连接且不允许排队</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> &amp;&amp; !queueIfNotConnected) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'WebSocket not connected'</span>));
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">send</span>(data);
        <span class="hljs-title function_">resolve</span>();
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">if</span> (retry &amp;&amp; (options.<span class="hljs-property">retryCount</span> || <span class="hljs-number">0</span>) &lt; maxRetries) {
          <span class="hljs-keyword">const</span> retryCount = (options.<span class="hljs-property">retryCount</span> || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
          
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(data, { ...options, retryCount })
              .<span class="hljs-title function_">then</span>(resolve)
              .<span class="hljs-title function_">catch</span>(reject);
          }, retryDelay);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">reject</span>(error);
        }
      }
    });
  }
  
  <span class="hljs-comment">// 发送JSON消息</span>
  <span class="hljs-title function_">sendJson</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(jsonString, options);
  }
  
  <span class="hljs-comment">// 发送带请求-响应模式的消息</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">sendWithResponse</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      timeout = <span class="hljs-number">30000</span>,
      responseType = <span class="hljs-string">'json'</span>
    } = options;
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 生成唯一的消息ID</span>
      <span class="hljs-keyword">const</span> messageId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateMessageId</span>();
      
      <span class="hljs-comment">// 创建超时定时器</span>
      <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(messageId);
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Response timeout'</span>));
      }, timeout);
      
      <span class="hljs-comment">// 监听特定消息ID的响应</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">once</span>(messageId, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-built_in">clearTimeout</span>(timeoutId);
        
        <span class="hljs-comment">// 根据类型解析响应</span>
        <span class="hljs-keyword">let</span> parsedResponse;
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (responseType === <span class="hljs-string">'json'</span>) {
            parsedResponse = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">data</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (responseType === <span class="hljs-string">'text'</span>) {
            parsedResponse = response.<span class="hljs-property">data</span>;
          } <span class="hljs-keyword">else</span> {
            parsedResponse = response.<span class="hljs-property">data</span>;
          }
          
          <span class="hljs-title function_">resolve</span>(parsedResponse);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to parse response: <span class="hljs-subst">${error.message}</span>`</span>));
        }
      });
      
      <span class="hljs-comment">// 发送消息（包含消息ID）</span>
      <span class="hljs-keyword">const</span> message = {
        <span class="hljs-attr">id</span>: messageId,
        data,
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      };
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendJson</span>(message).<span class="hljs-title function_">catch</span>(reject);
    });
  }
  
  <span class="hljs-comment">// 发送RPC调用</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">method, params, options = {}</span>) {
    <span class="hljs-keyword">const</span> rpcRequest = {
      <span class="hljs-attr">jsonrpc</span>: <span class="hljs-string">'2.0'</span>,
      method,
      params,
      <span class="hljs-attr">id</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateMessageId</span>()
    };
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendWithResponse</span>(rpcRequest, options);
  }
  
  <span class="hljs-comment">// 发送二进制数据</span>
  <span class="hljs-title function_">sendBinary</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">let</span> binaryData;
    
    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>) {
      binaryData = data;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Blob</span>) {
      binaryData = data;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ArrayBuffer</span>.<span class="hljs-title function_">isView</span>(data)) {
      binaryData = data.<span class="hljs-property">buffer</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unsupported binary data type'</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(binaryData, options);
  }
  
  <span class="hljs-comment">// 处理连接错误</span>
  <span class="hljs-title function_">handleConnectionError</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket connection error:'</span>, error);
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">reconnect</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attemptReconnect</span>();
    }
  }
  
  <span class="hljs-comment">// 尝试重连</span>
  <span class="hljs-title function_">attemptReconnect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxReconnectAttempts</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Max reconnection attempts reached'</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span>++;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Attempting to reconnect (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.reconnectAttempts}</span>/<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.options.maxReconnectAttempts}</span>)...`</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EVENTS</span>.<span class="hljs-property">RECONNECT</span>, {
      <span class="hljs-attr">attempt</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span>,
      <span class="hljs-attr">maxAttempts</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxReconnectAttempts</span>
    });
    
    <span class="hljs-comment">// 计算重连延迟（指数退避）</span>
    <span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">reconnectDelay</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span> - <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 添加随机抖动</span>
    <span class="hljs-keyword">const</span> jitter = delay * <span class="hljs-number">0.1</span> * (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimeout</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>();
    }, delay + jitter);
  }
  
  <span class="hljs-comment">// 启动心跳检测</span>
  <span class="hljs-title function_">startHeartbeat</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span>) {
      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span>);
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">'__HEARTBEAT__'</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'Heartbeat failed:'</span>, error);
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleConnectionError</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Heartbeat failed'</span>));
        });
      }
    }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">heartbeatInterval</span>);
  }
  
  <span class="hljs-comment">// 停止心跳检测</span>
  <span class="hljs-title function_">stopHeartbeat</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span>) {
      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">heartbeatInterval</span> = <span class="hljs-literal">null</span>;
    }
  }
  
  <span class="hljs-comment">// 检查是否是心跳消息</span>
  <span class="hljs-title function_">isHeartbeatMessage</span>(<span class="hljs-params">data</span>) {
    <span class="hljs-keyword">return</span> data === <span class="hljs-string">'__HEARTBEAT__'</span> || data === <span class="hljs-string">'__HEARTBEAT_RESPONSE__'</span>;
  }
  
  <span class="hljs-comment">// 清空消息队列</span>
  <span class="hljs-title function_">flushMessageQueue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> { data, options, retryCount } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span>.<span class="hljs-title function_">shift</span>();
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(data, { ...options, retryCount }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'Failed to send queued message:'</span>, error);
      });
    }
  }
  
  <span class="hljs-comment">// 断开连接</span>
  <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">code = <span class="hljs-number">1000</span>, reason = <span class="hljs-string">'Normal closure'</span></span>) {
    <span class="hljs-comment">// 清除重连定时器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimeout</span>) {
      <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimeout</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectTimeout</span> = <span class="hljs-literal">null</span>;
    }
    
    <span class="hljs-comment">// 停止心跳检测</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopHeartbeat</span>();
    
    <span class="hljs-comment">// 关闭WebSocket</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">close</span>(code, reason);
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 事件监听</span>
  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, listener</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(event)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">set</span>(event, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(event).<span class="hljs-title function_">add</span>(listener);
    
    <span class="hljs-comment">// 返回取消监听的函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, listener);
  }
  
  <span class="hljs-comment">// 一次性事件监听</span>
  <span class="hljs-title function_">once</span>(<span class="hljs-params">event, listener</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onceListener</span> = (<span class="hljs-params">...args</span>) =&gt; {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, onceListener);
      <span class="hljs-title function_">listener</span>(...args);
    };
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(event, onceListener);
  }
  
  <span class="hljs-comment">// 移除事件监听</span>
  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, listener</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(event)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(event).<span class="hljs-title function_">delete</span>(listener);
      
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(event).<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">delete</span>(event);
      }
    }
  }
  
  <span class="hljs-comment">// 触发事件</span>
  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(event)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(event).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">listener</span>(data);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error in event listener for "<span class="hljs-subst">${event}</span>":`</span>, error);
        }
      });
    }
    
    <span class="hljs-comment">// 触发通配符监听器</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'*'</span>)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'*'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">listener</span>(event, data);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error in wildcard event listener:'</span>, error);
        }
      });
    }
  }
  
  <span class="hljs-comment">// 生成连接ID</span>
  <span class="hljs-title function_">generateConnectionId</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`conn_<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>_<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>;
  }
  
  <span class="hljs-comment">// 生成消息ID</span>
  <span class="hljs-title function_">generateMessageId</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`msg_<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>_<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>;
  }
  
  <span class="hljs-comment">// 获取连接状态</span>
  <span class="hljs-title function_">getStatus</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span>,
      <span class="hljs-attr">isConnected</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnected</span>,
      <span class="hljs-attr">isConnecting</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span>,
      <span class="hljs-attr">connectionId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionId</span>,
      <span class="hljs-attr">reconnectAttempts</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">reconnectAttempts</span>,
      <span class="hljs-attr">maxReconnectAttempts</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxReconnectAttempts</span>,
      <span class="hljs-attr">queuedMessages</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span>.<span class="hljs-property">length</span>,
      <span class="hljs-attr">binaryType</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">binaryType</span>
    };
  }
  
  <span class="hljs-comment">// 设置二进制类型</span>
  <span class="hljs-title function_">setBinaryType</span>(<span class="hljs-params">binaryType</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">binaryType</span> = binaryType;
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">binaryType</span> = binaryType;
    }
  }
}

<span class="hljs-comment">// WebSocket管理类（多连接管理）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketManager</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultOptions</span> = {
      <span class="hljs-attr">reconnect</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">maxReconnectAttempts</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">reconnectDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">heartbeatEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">heartbeatInterval</span>: <span class="hljs-number">30000</span>
    };
  }
  
  <span class="hljs-comment">// 创建连接</span>
  <span class="hljs-title function_">createConnection</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">const</span> connectionId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateConnectionId</span>(url);
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">has</span>(connectionId)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Connection already exists: <span class="hljs-subst">${connectionId}</span>`</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">get</span>(connectionId);
    }
    
    <span class="hljs-keyword">const</span> mergedOptions = { ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultOptions</span>, ...options };
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketClient</span>(url, mergedOptions);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">set</span>(connectionId, client);
    
    <span class="hljs-comment">// 监听连接关闭事件以清理</span>
    client.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 可以在这里执行清理操作</span>
    });
    
    <span class="hljs-keyword">return</span> client;
  }
  
  <span class="hljs-comment">// 获取连接</span>
  <span class="hljs-title function_">getConnection</span>(<span class="hljs-params">connectionId</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">get</span>(connectionId);
  }
  
  <span class="hljs-comment">// 关闭连接</span>
  <span class="hljs-title function_">closeConnection</span>(<span class="hljs-params">connectionId, code = <span class="hljs-number">1000</span>, reason = <span class="hljs-string">'Normal closure'</span></span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">get</span>(connectionId);
    
    <span class="hljs-keyword">if</span> (client) {
      client.<span class="hljs-title function_">disconnect</span>(code, reason);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">delete</span>(connectionId);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  
  <span class="hljs-comment">// 关闭所有连接</span>
  <span class="hljs-title function_">closeAllConnections</span>(<span class="hljs-params">code = <span class="hljs-number">1000</span>, reason = <span class="hljs-string">'Normal closure'</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">client, connectionId</span>) =&gt;</span> {
      client.<span class="hljs-title function_">disconnect</span>(code, reason);
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">clear</span>();
  }
  
  <span class="hljs-comment">// 广播消息到所有连接</span>
  <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> promises = [];
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (client.<span class="hljs-property">isConnected</span>) {
        promises.<span class="hljs-title function_">push</span>(client.<span class="hljs-title function_">send</span>(data, options));
      }
    });
    
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises);
  }
  
  <span class="hljs-comment">// 生成连接ID</span>
  <span class="hljs-title function_">generateConnectionId</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(url);
    <span class="hljs-keyword">const</span> host = urlObj.<span class="hljs-property">host</span>;
    <span class="hljs-keyword">const</span> path = urlObj.<span class="hljs-property">pathname</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${host}</span><span class="hljs-subst">${path}</span>`</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[^a-z0-9]/gi</span>, <span class="hljs-string">'_'</span>);
  }
  
  <span class="hljs-comment">// 获取连接状态</span>
  <span class="hljs-title function_">getStatus</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> status = {
      <span class="hljs-attr">totalConnections</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-property">size</span>,
      <span class="hljs-attr">connectedConnections</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">connectingConnections</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">connections</span>: []
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">connections</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">client, connectionId</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> clientStatus = client.<span class="hljs-title function_">getStatus</span>();
      
      <span class="hljs-keyword">if</span> (clientStatus.<span class="hljs-property">isConnected</span>) {
        status.<span class="hljs-property">connectedConnections</span>++;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clientStatus.<span class="hljs-property">isConnecting</span>) {
        status.<span class="hljs-property">connectingConnections</span>++;
      }
      
      status.<span class="hljs-property">connections</span>.<span class="hljs-title function_">push</span>({
        connectionId,
        ...clientStatus
      });
    });
    
    <span class="hljs-keyword">return</span> status;
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketExample</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">demonstrate</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 创建WebSocket客户端</span>
    <span class="hljs-keyword">const</span> wsClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketClient</span>(<span class="hljs-string">'wss://echo.websocket.org'</span>, {
      <span class="hljs-attr">reconnect</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">maxReconnectAttempts</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">heartbeatEnabled</span>: <span class="hljs-literal">true</span>
    });
    
    <span class="hljs-comment">// 监听事件</span>
    wsClient.<span class="hljs-title function_">on</span>(<span class="hljs-string">'open'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket opened:'</span>, event.<span class="hljs-property">connectionId</span>);
      
      <span class="hljs-comment">// 发送消息</span>
      wsClient.<span class="hljs-title function_">sendJson</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'greeting'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello WebSocket!'</span> });
    });
    
    wsClient.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received message:'</span>, event.<span class="hljs-property">data</span>);
    });
    
    wsClient.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket closed:'</span>, event.<span class="hljs-property">code</span>, event.<span class="hljs-property">reason</span>);
    });
    
    wsClient.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket error:'</span>, event.<span class="hljs-property">error</span>);
    });
    
    <span class="hljs-comment">// 发送请求-响应模式的消息</span>
    wsClient.<span class="hljs-title function_">sendWithResponse</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'ping'</span> })
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Response:'</span>, response))
      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Request failed:'</span>, error));
    
    <span class="hljs-comment">// 获取状态</span>
    <span class="hljs-keyword">const</span> status = wsClient.<span class="hljs-title function_">getStatus</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket status:'</span>, status);
    
    <span class="hljs-keyword">return</span> wsClient;
  }
}
</code></pre>
<h5 data-id="heading-12">4.2 WebSocket重连与消息可靠性</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReliableWebSocket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">WebSocketClient</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-keyword">const</span> defaultOptions = {
      <span class="hljs-attr">messageRetention</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">maxMessageQueueSize</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">messageExpiry</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 5分钟</span>
      <span class="hljs-attr">deliveryGuarantee</span>: <span class="hljs-string">'at-least-once'</span>, <span class="hljs-comment">// 'at-most-once', 'at-least-once', 'exactly-once'</span>
      <span class="hljs-attr">requireAcknowledgement</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">acknowledgementTimeout</span>: <span class="hljs-number">5000</span>,
      ...options
    };
    
    <span class="hljs-variable language_">super</span>(url, defaultOptions);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageSequence</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastAcknowledgedSequence</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-comment">// 设置消息确认监听</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupAcknowledgementListener</span>();
  }
  
  <span class="hljs-comment">// 发送可靠消息</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">sendReliable</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> {
      requireAcknowledgement = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">requireAcknowledgement</span>,
      acknowledgementTimeout = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">acknowledgementTimeout</span>,
      maxRetries = <span class="hljs-number">3</span>,
      retryDelay = <span class="hljs-number">1000</span>
    } = options;
    
    <span class="hljs-comment">// 生成消息ID和序列号</span>
    <span class="hljs-keyword">const</span> messageId = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateMessageId</span>();
    <span class="hljs-keyword">const</span> sequenceNumber = <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageSequence</span>++;
    
    <span class="hljs-comment">// 创建消息对象</span>
    <span class="hljs-keyword">const</span> message = {
      <span class="hljs-attr">id</span>: messageId,
      <span class="hljs-attr">seq</span>: sequenceNumber,
      data,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
      <span class="hljs-attr">retryCount</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">status</span>: <span class="hljs-string">'pending'</span>
    };
    
    <span class="hljs-comment">// 如果需要确认，添加到待处理消息列表</span>
    <span class="hljs-keyword">if</span> (requireAcknowledgement) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">set</span>(messageId, message);
      
      <span class="hljs-comment">// 设置确认超时</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setAcknowledgementTimeout</span>(messageId, acknowledgementTimeout);
    }
    
    <span class="hljs-comment">// 封装发送的消息</span>
    <span class="hljs-keyword">const</span> wrappedMessage = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'data'</span>,
      <span class="hljs-attr">reliable</span>: requireAcknowledgement,
      messageId,
      sequenceNumber,
      data
    };
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendJson</span>(wrappedMessage);
      message.<span class="hljs-property">status</span> = <span class="hljs-string">'sent'</span>;
      
      <span class="hljs-comment">// 如果需要确认，等待确认</span>
      <span class="hljs-keyword">if</span> (requireAcknowledgement) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">waitForAcknowledgement</span>(messageId, acknowledgementTimeout);
      }
      
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>({ messageId, <span class="hljs-attr">status</span>: <span class="hljs-string">'sent'</span> });
    } <span class="hljs-keyword">catch</span> (error) {
      message.<span class="hljs-property">status</span> = <span class="hljs-string">'failed'</span>;
      message.<span class="hljs-property">error</span> = error;
      
      <span class="hljs-comment">// 重试逻辑</span>
      <span class="hljs-keyword">if</span> (maxRetries &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">retrySendReliable</span>(message, {
          maxRetries,
          retryDelay,
          requireAcknowledgement
        });
      }
      
      <span class="hljs-keyword">throw</span> error;
    }
  }
  
  <span class="hljs-comment">// 等待消息确认</span>
  <span class="hljs-title function_">waitForAcknowledgement</span>(<span class="hljs-params">messageId, timeout</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-comment">// 检查是否已经确认</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>.<span class="hljs-title function_">has</span>(messageId)) {
        <span class="hljs-title function_">resolve</span>({ messageId, <span class="hljs-attr">status</span>: <span class="hljs-string">'acknowledged'</span> });
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-comment">// 设置超时</span>
      <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> message = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">get</span>(messageId);
        
        <span class="hljs-keyword">if</span> (message) {
          message.<span class="hljs-property">status</span> = <span class="hljs-string">'timeout'</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">delete</span>(messageId);
        }
        
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Acknowledgement timeout for message <span class="hljs-subst">${messageId}</span>`</span>));
      }, timeout);
      
      <span class="hljs-comment">// 监听确认事件</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">acknowledgementListener</span> = (<span class="hljs-params">ack</span>) =&gt; {
        <span class="hljs-keyword">if</span> (ack.<span class="hljs-property">messageId</span> === messageId) {
          <span class="hljs-built_in">clearTimeout</span>(timeoutId);
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">'acknowledgement'</span>, acknowledgementListener);
          <span class="hljs-title function_">resolve</span>({ messageId, <span class="hljs-attr">status</span>: <span class="hljs-string">'acknowledged'</span> });
        }
      };
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'acknowledgement'</span>, acknowledgementListener);
    });
  }
  
  <span class="hljs-comment">// 重试发送可靠消息</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">retrySendReliable</span>(<span class="hljs-params">message, options</span>) {
    <span class="hljs-keyword">const</span> {
      maxRetries,
      retryDelay,
      requireAcknowledgement
    } = options;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attempt = <span class="hljs-number">1</span>; attempt &lt;= maxRetries; attempt++) {
      message.<span class="hljs-property">retryCount</span> = attempt;
      message.<span class="hljs-property">status</span> = <span class="hljs-string">'retrying'</span>;
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Retrying message <span class="hljs-subst">${message.id}</span> (attempt <span class="hljs-subst">${attempt}</span>/<span class="hljs-subst">${maxRetries}</span>)`</span>);
      
      <span class="hljs-comment">// 等待重试延迟</span>
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, retryDelay * attempt));
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> wrappedMessage = {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'data'</span>,
          <span class="hljs-attr">reliable</span>: requireAcknowledgement,
          <span class="hljs-attr">messageId</span>: message.<span class="hljs-property">id</span>,
          <span class="hljs-attr">sequenceNumber</span>: message.<span class="hljs-property">seq</span>,
          <span class="hljs-attr">data</span>: message.<span class="hljs-property">data</span>,
          <span class="hljs-attr">retry</span>: attempt
        };
        
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendJson</span>(wrappedMessage);
        message.<span class="hljs-property">status</span> = <span class="hljs-string">'sent'</span>;
        
        <span class="hljs-comment">// 如果需要确认，等待确认</span>
        <span class="hljs-keyword">if</span> (requireAcknowledgement) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">waitForAcknowledgement</span>(
            message.<span class="hljs-property">id</span>,
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">acknowledgementTimeout</span>
          );
          
          <span class="hljs-keyword">return</span> result;
        }
        
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">messageId</span>: message.<span class="hljs-property">id</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">'sent'</span> };
      } <span class="hljs-keyword">catch</span> (error) {
        message.<span class="hljs-property">status</span> = <span class="hljs-string">'failed'</span>;
        message.<span class="hljs-property">error</span> = error;
        
        <span class="hljs-keyword">if</span> (attempt === maxRetries) {
          <span class="hljs-keyword">throw</span> error;
        }
      }
    }
    
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to send message after <span class="hljs-subst">${maxRetries}</span> retries`</span>);
  }
  
  <span class="hljs-comment">// 设置确认超时</span>
  <span class="hljs-title function_">setAcknowledgementTimeout</span>(<span class="hljs-params">messageId, timeout</span>) {
    <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> message = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">get</span>(messageId);
      
      <span class="hljs-keyword">if</span> (message &amp;&amp; message.<span class="hljs-property">status</span> !== <span class="hljs-string">'acknowledged'</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Acknowledgement timeout for message <span class="hljs-subst">${messageId}</span>`</span>);
        
        <span class="hljs-comment">// 触发超时事件</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'acknowledgement_timeout'</span>, {
          messageId,
          message,
          <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
        });
        
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">delete</span>(messageId);
      }
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">delete</span>(messageId);
    }, timeout);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">set</span>(messageId, timeoutId);
  }
  
  <span class="hljs-comment">// 清理确认超时</span>
  <span class="hljs-title function_">clearAcknowledgementTimeout</span>(<span class="hljs-params">messageId</span>) {
    <span class="hljs-keyword">const</span> timeoutId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">get</span>(messageId);
    
    <span class="hljs-keyword">if</span> (timeoutId) {
      <span class="hljs-built_in">clearTimeout</span>(timeoutId);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">delete</span>(messageId);
    }
  }
  
  <span class="hljs-comment">// 设置消息确认监听器</span>
  <span class="hljs-title function_">setupAcknowledgementListener</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 监听确认消息</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> message = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
        
        <span class="hljs-keyword">if</span> (message.<span class="hljs-property">type</span> === <span class="hljs-string">'acknowledgement'</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleAcknowledgement</span>(message);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.<span class="hljs-property">type</span> === <span class="hljs-string">'data'</span> &amp;&amp; message.<span class="hljs-property">reliable</span>) {
          <span class="hljs-comment">// 收到可靠消息，发送确认</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendAcknowledgement</span>(message.<span class="hljs-property">messageId</span>, message.<span class="hljs-property">sequenceNumber</span>);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-comment">// 不是JSON消息，忽略</span>
      }
    });
    
    <span class="hljs-comment">// 监听连接打开事件，重新发送未确认的消息</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'open'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resendUnacknowledgedMessages</span>();
    });
  }
  
  <span class="hljs-comment">// 处理确认消息</span>
  <span class="hljs-title function_">handleAcknowledgement</span>(<span class="hljs-params">ackMessage</span>) {
    <span class="hljs-keyword">const</span> { messageId, sequenceNumber } = ackMessage;
    
    <span class="hljs-comment">// 清理确认超时</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">clearAcknowledgementTimeout</span>(messageId);
    
    <span class="hljs-comment">// 更新最后确认的序列号</span>
    <span class="hljs-keyword">if</span> (sequenceNumber &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastAcknowledgedSequence</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastAcknowledgedSequence</span> = sequenceNumber;
    }
    
    <span class="hljs-comment">// 从待处理消息中移除</span>
    <span class="hljs-keyword">const</span> message = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">get</span>(messageId);
    <span class="hljs-keyword">if</span> (message) {
      message.<span class="hljs-property">status</span> = <span class="hljs-string">'acknowledged'</span>;
      message.<span class="hljs-property">acknowledgedAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">delete</span>(messageId);
    }
    
    <span class="hljs-comment">// 添加到已确认消息集合</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>.<span class="hljs-title function_">add</span>(messageId);
    
    <span class="hljs-comment">// 触发确认事件</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'acknowledgement'</span>, {
      messageId,
      sequenceNumber,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
      message
    });
    
    <span class="hljs-comment">// 清理过期的已确认消息</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupAcknowledgedMessages</span>();
  }
  
  <span class="hljs-comment">// 发送确认消息</span>
  <span class="hljs-title function_">sendAcknowledgement</span>(<span class="hljs-params">messageId, sequenceNumber</span>) {
    <span class="hljs-keyword">const</span> ackMessage = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'acknowledgement'</span>,
      messageId,
      sequenceNumber,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendJson</span>(ackMessage).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'Failed to send acknowledgement:'</span>, error);
    });
  }
  
  <span class="hljs-comment">// 重新发送未确认的消息</span>
  <span class="hljs-title function_">resendUnacknowledgedMessages</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> unacknowledged = [];
    
    <span class="hljs-comment">// 收集未确认的消息</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">message, messageId</span>) =&gt;</span> {
      <span class="hljs-comment">// 检查消息是否过期</span>
      <span class="hljs-keyword">if</span> (now - message.<span class="hljs-property">timestamp</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">messageExpiry</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message <span class="hljs-subst">${messageId}</span> expired, removing`</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">delete</span>(messageId);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">clearAcknowledgementTimeout</span>(messageId);
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-comment">// 检查消息是否需要重发</span>
      <span class="hljs-keyword">if</span> (message.<span class="hljs-property">status</span> === <span class="hljs-string">'sent'</span> || message.<span class="hljs-property">status</span> === <span class="hljs-string">'pending'</span>) {
        unacknowledged.<span class="hljs-title function_">push</span>(message);
      }
    });
    
    <span class="hljs-comment">// 重新发送未确认的消息</span>
    unacknowledged.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Resending unacknowledged message <span class="hljs-subst">${message.id}</span>`</span>);
      
      <span class="hljs-keyword">const</span> wrappedMessage = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'data'</span>,
        <span class="hljs-attr">reliable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">messageId</span>: message.<span class="hljs-property">id</span>,
        <span class="hljs-attr">sequenceNumber</span>: message.<span class="hljs-property">seq</span>,
        <span class="hljs-attr">data</span>: message.<span class="hljs-property">data</span>,
        <span class="hljs-attr">resent</span>: <span class="hljs-literal">true</span>
      };
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendJson</span>(wrappedMessage).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Failed to resend message <span class="hljs-subst">${message.id}</span>:`</span>, error);
      });
    });
  }
  
  <span class="hljs-comment">// 清理已确认的消息</span>
  <span class="hljs-title function_">cleanupAcknowledgedMessages</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> maxSize = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 最多保留1000个已确认消息</span>
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>.<span class="hljs-property">size</span> &gt; maxSize) {
      <span class="hljs-comment">// 转换为数组，排序，删除最旧的</span>
      <span class="hljs-keyword">const</span> sorted = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>)
        .<span class="hljs-title function_">slice</span>(-maxSize);
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(sorted);
    }
  }
  
  <span class="hljs-comment">// 覆盖父类的send方法，添加可靠性支持</span>
  <span class="hljs-title function_">send</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> { reliable = <span class="hljs-literal">false</span>, ...sendOptions } = options;
    
    <span class="hljs-keyword">if</span> (reliable) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendReliable</span>(data, sendOptions);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">send</span>(data, sendOptions);
  }
  
  <span class="hljs-comment">// 覆盖父类的sendJson方法</span>
  <span class="hljs-title function_">sendJson</span>(<span class="hljs-params">data, options = {}</span>) {
    <span class="hljs-keyword">const</span> { reliable = <span class="hljs-literal">false</span>, ...sendOptions } = options;
    
    <span class="hljs-keyword">if</span> (reliable) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendReliable</span>(data, sendOptions);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sendJson</span>(data, sendOptions);
  }
  
  <span class="hljs-comment">// 获取可靠消息统计</span>
  <span class="hljs-title function_">getReliabilityStats</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">let</span> pendingCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> acknowledgedCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> failedCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> expiredCount = <span class="hljs-number">0</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (now - message.<span class="hljs-property">timestamp</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">messageExpiry</span>) {
        expiredCount++;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.<span class="hljs-property">status</span> === <span class="hljs-string">'acknowledged'</span>) {
        acknowledgedCount++;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.<span class="hljs-property">status</span> === <span class="hljs-string">'failed'</span>) {
        failedCount++;
      } <span class="hljs-keyword">else</span> {
        pendingCount++;
      }
    });
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">pendingMessages</span>: pendingCount,
      <span class="hljs-attr">acknowledgedMessages</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>.<span class="hljs-property">size</span>,
      <span class="hljs-attr">failedMessages</span>: failedCount,
      <span class="hljs-attr">expiredMessages</span>: expiredCount,
      <span class="hljs-attr">totalSentMessages</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageSequence</span>,
      <span class="hljs-attr">lastAcknowledgedSequence</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastAcknowledgedSequence</span>,
      <span class="hljs-attr">messageQueueSize</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span>.<span class="hljs-property">length</span>,
      <span class="hljs-attr">acknowledgementTimeouts</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-property">size</span>
    };
  }
  
  <span class="hljs-comment">// 清理所有待处理消息</span>
  <span class="hljs-title function_">cleanupAllMessages</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingMessages</span>.<span class="hljs-title function_">clear</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgedMessages</span>.<span class="hljs-title function_">clear</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageQueue</span> = [];
    
    <span class="hljs-comment">// 清理所有超时定时器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">timeoutId</span> =&gt;</span> {
      <span class="hljs-built_in">clearTimeout</span>(timeoutId);
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acknowledgementTimeouts</span>.<span class="hljs-title function_">clear</span>();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReliableWebSocketExample</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">demonstrate</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 创建可靠WebSocket客户端</span>
    <span class="hljs-keyword">const</span> reliableWs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReliableWebSocket</span>(<span class="hljs-string">'wss://echo.websocket.org'</span>, {
      <span class="hljs-attr">requireAcknowledgement</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">acknowledgementTimeout</span>: <span class="hljs-number">3000</span>,
      <span class="hljs-attr">messageExpiry</span>: <span class="hljs-number">60000</span>, <span class="hljs-comment">// 1分钟</span>
      <span class="hljs-attr">reconnect</span>: <span class="hljs-literal">true</span>
    });
    
    <span class="hljs-comment">// 监听确认事件</span>
    reliableWs.<span class="hljs-title function_">on</span>(<span class="hljs-string">'acknowledgement'</span>, <span class="hljs-function">(<span class="hljs-params">ack</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Message acknowledged:'</span>, ack.<span class="hljs-property">messageId</span>);
    });
    
    reliableWs.<span class="hljs-title function_">on</span>(<span class="hljs-string">'acknowledgement_timeout'</span>, <span class="hljs-function">(<span class="hljs-params">timeout</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'Acknowledgement timeout:'</span>, timeout.<span class="hljs-property">messageId</span>);
    });
    
    <span class="hljs-comment">// 发送可靠消息</span>
    reliableWs.<span class="hljs-title function_">sendReliable</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'test'</span>, <span class="hljs-attr">data</span>: <span class="hljs-string">'Hello reliable WebSocket!'</span> })
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Reliable message sent and acknowledged:'</span>, result);
      })
      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed to send reliable message:'</span>, error);
      });
    
    <span class="hljs-comment">// 获取可靠性统计</span>
    <span class="hljs-keyword">const</span> stats = reliableWs.<span class="hljs-title function_">getReliabilityStats</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Reliability stats:'</span>, stats);
    
    <span class="hljs-keyword">return</span> reliableWs;
  }
}
</code></pre>
<p>继续阅读 <a href="https://juejin.cn/post/7584807992031051818" target="_blank" title="https://juejin.cn/post/7584807992031051818"># 浏览器网络请求 API：全面解析与高级封装(2)</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>