<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[使用 Ollama 本地模型与 Spring AI Alibaba]]></title>    <link>https://juejin.cn/post/7572453554331451392</link>    <guid>https://juejin.cn/post/7572453554331451392</guid>    <pubDate>2025-11-15T07:33:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572453554331451392" data-draft-id="7572453554330894336" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 Ollama 本地模型与 Spring AI Alibaba"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-15T07:33:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大象席地抽烟"/> <meta itemprop="url" content="https://juejin.cn/user/3104676567599207"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 Ollama 本地模型与 Spring AI Alibaba
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3104676567599207/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大象席地抽烟
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T07:33:02.000Z" title="Sat Nov 15 2025 07:33:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://juejin.cn/post/7570271574348152841" target="_blank" title="https://juejin.cn/post/7570271574348152841">Spring AI RAG 体验项目</a>中使用的是阿里云的模型，嵌入、推理和排序要调用阿里云的服务。本例尝试本地搭建ollama，跑一些开源的模型。</p>
<p>ollama号称大模型领域的docker。用来做验证或者跑一些经过蒸馏/量化的轻量模型、搭建问答机器人知识库，够用了。</p>
<p>整体步骤是：（1）安装ollama，相当于安装docker （2）ollama中拉取模型，相当于docker拉取镜像进行并运行 （3）验证ollama中的模型（4）写一个spring ai应用，该应用调用ollama中跑的模型。</p>
<p>本例代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhouruibest%2Follama-rag1" target="_blank" title="https://github.com/zhouruibest/ollama-rag1" ref="nofollow noopener noreferrer">github.com/zhouruibest…</a></p>
<h2 data-id="heading-0">1. 安装ollama</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2F" target="_blank" title="https://ollama.com/" ref="nofollow noopener noreferrer">ollama</a>被设计用来单机运行的。可以用到Window上的显卡。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/039a48af52304f639dbb27b17b869b89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn6LGh5bit5Zyw5oq954Of:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763796782&amp;x-signature=rndutIDSoNdCcQE4%2BA3ungEAZkY%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">2. 拉取模型</h2>
<p>windows powershell中</p>
<pre><code class="hljs language-sh" lang="sh">ollama pull deepseek-r1:8b
ollama pull nomic-embed-text:latest
</code></pre>
<h2 data-id="heading-2">3. 验证</h2>
<p>ollama默认监听本地11434端口，spring ai应用就是访问这个地址。用curl测一下：</p>
<pre><code class="hljs language-sh" lang="sh">curl http://localhost:11434/api/generate -d <span class="hljs-string">'{
  "model": "deepseek-r1:8b",
  "prompt": "请介绍一下AI的发展历史"
}'</span>


curl http://localhost:11434/api/embed -d <span class="hljs-string">'{
  "model": "nomic-embed-text:latest",
  "input": "这是一段需要转换为向量的文本"
}'</span>
</code></pre>
<p>命令行中显示不友好。也可以用Open-WebUI（web 页面工具，镜像是 ghcr.io/open-webui/open-webui:main） ，在页面验证。 这里用了它的国内的镜像。推荐一个镜像同步网站 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocker.aityp.com%2F%25E3%2580%2582" target="_blank" title="https://docker.aityp.com/%E3%80%82" ref="nofollow noopener noreferrer">docker.aityp.com/。</a></p>
<pre><code class="hljs language-bash" lang="bash">docker run -d -p 3000:8080 \
  --add-host=host.docker.internal:host-gateway \
  -e OLLAMA_BASE_URL=http://host.docker.internal:11434 \  <span class="hljs-comment"># 指定了ollama的服务地址</span>
  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/ghcr.io/open-webui/open-webui:main
</code></pre>
<h2 data-id="heading-3">4. spring ai 应用</h2>
<p>本例是在 <a href="https://juejin.cn/post/7570271574348152841" target="_blank" title="https://juejin.cn/post/7570271574348152841">Spring AI RAG 体验项目</a> 的基础上改的。</p>
<h3 data-id="heading-4">配置</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">handbook</span>
  <span class="hljs-attr">autoconfigure:</span>
    <span class="hljs-attr">exclude:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">org.springframework.ai.autoconfigure.vectorstore.milvus.MilvusVectorStoreAutoConfiguration</span>
  <span class="hljs-attr">ai:</span>
    <span class="hljs-attr">dashscope:</span>
      <span class="hljs-attr">api-key:</span> <span class="hljs-string">${MY_APP_API_KEY}</span>        <span class="hljs-comment"># 项目中还有 spring-ai-alibaba-starter启动器，方便切回去</span>
    <span class="hljs-attr">ollama:</span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:11434</span>  <span class="hljs-comment"># Ollama 服务地址，默认是这个端口号</span>
      <span class="hljs-attr">chat:</span>
        <span class="hljs-attr">model:</span> <span class="hljs-string">deepseek-r1:8b</span>           <span class="hljs-comment"># 指定要使用的推理模型，这个3060Ti还能跑起来</span>
      <span class="hljs-attr">embedding:</span>
        <span class="hljs-attr">model:</span> <span class="hljs-string">nomic-embed-text:latest</span>  <span class="hljs-comment"># 文本嵌入模型，维度768</span>

<span class="hljs-attr">initKnowledge:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否初始化到向量数据库。只运行回次就行</span>
<span class="hljs-attr">milvus:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">mydevcvm</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">19530</span>
  <span class="hljs-attr">token:</span> <span class="hljs-string">"root:Milvus"</span>
  <span class="hljs-attr">database:</span> <span class="hljs-string">"default"</span> <span class="hljs-comment"># 使用默认的</span>
  <span class="hljs-attr">collection:</span> <span class="hljs-string">"ollamarag1"</span>
  <span class="hljs-attr">initializeSchema:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># milvus中的database要先创建好。collection可以不用创建；这个字段第一次为true，以后运行为false</span>
</code></pre>
<h3 data-id="heading-5">向量数据库</h3>
<p><code>nomic-embed-text:latest</code> 的向量维度是<strong>768</strong>而非 1536</p>
<p>为了方便改回去，项目还引入了 spring-ai-alibaba-starter启动器 和相关的配置。因此会有两个Chat Model和Embedding Model，所以要用 <code>@Qualifier("ollamaEmbeddingModel")</code>和 <code>@Qualifier("ollamaChatModel")</code>指定一下。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// VectorStoreConfig.java</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> VectorStore <span class="hljs-title function_">vectorStore</span><span class="hljs-params">(MilvusServiceClient milvusClient, <span class="hljs-meta">@Qualifier("ollamaEmbeddingModel")</span> EmbeddingModel embeddingModel)</span> {
    <span class="hljs-keyword">return</span> MilvusVectorStore.builder(milvusClient, embeddingModel) <span class="hljs-comment">//  嵌入模型实例，用于将文本转换为向量表示</span>
            .collectionName(collection).databaseName(database).embeddingDimension(<span class="hljs-number">768</span>) 
            .indexType(IndexType.IVF_FLAT) <span class="hljs-comment">// 设置为IVF_FLAT（倒排文件Flat索引），是一种常用的近似最近邻搜索索引</span>
            .metricType(MetricType.COSINE).batchingStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenCountBatchingStrategy</span>()).initializeSchema(initializeSchema).build();
    }
</code></pre>
<h3 data-id="heading-6">嵌入并存储向量数据库</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// KnowledgeInitializer.java</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KnowledgeInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> {
    <span class="hljs-meta">@Value("${initKnowledge}")</span>
    <span class="hljs-keyword">private</span> Boolean initKnowledge;

    <span class="hljs-meta">@Value("classpath:/docs/handbook.pdf")</span>
    <span class="hljs-keyword">private</span> Resource springAiResource;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> VectorStore vectorStore;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(KnowledgeInitializer.class);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (!initKnowledge) {
            logger.info(<span class="hljs-string">"initKnowledge is false, skip init"</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 1. parse document</span>
        <span class="hljs-type">DocumentReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PagePdfDocumentReader</span>(springAiResource);
        List&lt;Document&gt; documents = reader.get();
        logger.info(<span class="hljs-string">"{} documents loaded"</span>, documents.size());

        <span class="hljs-comment">// 2. split trunks</span>
        List&lt;Document&gt; splitDocuments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenTextSplitter</span>().apply(documents);
        logger.info(<span class="hljs-string">"{} documents split"</span>, splitDocuments.size());

        <span class="hljs-comment">// 3. create embedding and store to vector store</span>
        logger.info(<span class="hljs-string">"create embedding and save to vector store"</span>);
        vectorStore.add(splitDocuments);

    }
}
</code></pre>
<h3 data-id="heading-7">rag service</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// AIRagService</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AIRagService</span> {
    <span class="hljs-comment">// 引入 system prompt tmpl</span>
    <span class="hljs-meta">@Value("classpath:/docs/system-qa.st")</span>
    <span class="hljs-keyword">private</span> Resource systemResource;

    <span class="hljs-comment">// 注入相关 bean 实例</span>
    <span class="hljs-meta">@Qualifier("ollamaChatModel")</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ChatModel ragChatModel;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> VectorStore vectorStore;

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPromptTemplate</span><span class="hljs-params">(Resource systemResource)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> systemResource.getContentAsString(StandardCharsets.UTF_8);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);
        }
    }

    <span class="hljs-comment">// 文本过滤，增强向量检索精度    private static final String textField = "content";</span>
    <span class="hljs-comment">// ......</span>
    <span class="hljs-keyword">public</span> Flux&lt;String&gt; <span class="hljs-title function_">retrieve</span><span class="hljs-params">(String prompt)</span> {
        <span class="hljs-comment">// 加载 prompt tmpl</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">promptTemplate</span> <span class="hljs-operator">=</span> getPromptTemplate(systemResource);
        <span class="hljs-comment">// 启用混合搜索，包括嵌入和全文搜索</span>
        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">searchRequest</span> <span class="hljs-operator">=</span> SearchRequest.builder().topK(<span class="hljs-number">4</span>).similarityThresholdAll().build();
        <span class="hljs-comment">// build chatClient，发起大模型服务调用。</span>
        <span class="hljs-keyword">return</span> ChatClient.builder(ragChatModel).build().prompt().advisors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QuestionAnswerAdvisor</span>(vectorStore, searchRequest, promptTemplate)).user(prompt).stream().content();
    }
}
</code></pre>
<h3 data-id="heading-8">访问验证</h3>
<p>浏览器地址栏输入：<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8080%2Frag%2F%3Fmessage%3D%25E7%258E%25B0%25E5%259C%25A8%25E6%2588%2591%25E4%25BB%25AC%25E8%25BA%25AB%25E8%25BE%25B9%25E4%25B8%2580%25E4%25BA%259B%25E8%2580%2581%25E5%25B9%25B4%25E4%25BA%25BA%25E6%2584%259F%25E6%259F%2593%25E5%2590%258E%25E7%2597%2585%25E6%2583%2585%25E5%25B0%25B1%25E5%25BE%2588%25E9%2587%258D%25EF%25BC%258C%25E9%2582%25A3%25E6%2598%25AF%25E4%25B8%258D%25E6%2598%25AF%25E8%2580%2581%25E5%25B9%25B4%25E4%25BA%25BA%25E6%2584%259F%25E6%259F%2593%25E5%2590%258E%25E4%25B8%2580%25E5%25AE%259A%25E4%25BC%259A%25E8%25B5%25B0%25E5%2590%2591%25E9%2587%258D%25E7%2597%2587%25E5%2592%258C%25E5%258D%25B1%25E9%2587%258D%25E7%2597%2587" target="_blank" title="http://localhost:8080/rag/?message=%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E8%BA%AB%E8%BE%B9%E4%B8%80%E4%BA%9B%E8%80%81%E5%B9%B4%E4%BA%BA%E6%84%9F%E6%9F%93%E5%90%8E%E7%97%85%E6%83%85%E5%B0%B1%E5%BE%88%E9%87%8D%EF%BC%8C%E9%82%A3%E6%98%AF%E4%B8%8D%E6%98%AF%E8%80%81%E5%B9%B4%E4%BA%BA%E6%84%9F%E6%9F%93%E5%90%8E%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%B5%B0%E5%90%91%E9%87%8D%E7%97%87%E5%92%8C%E5%8D%B1%E9%87%8D%E7%97%87" ref="nofollow noopener noreferrer">http://localhost:8080/rag/?message=现在我们身边一些老年人感染后病情就很重，那是不是老年人感染后一定会走向重症和危重症</a></p>
<pre><code class="hljs language-markdown" lang="markdown">这是一个非常关心的问题，但答案<span class="hljs-strong">**并不简单，也不是绝对的“是”或“否”**</span>。

老年人感染新冠病毒后，<span class="hljs-strong">**发展为重症和危重症的风险确实比年轻健康人群要高得多**</span>，但这<span class="hljs-strong">**并不意味着所有**</span>老年人感染后都会必然走向重症和危重症。感染后的严重程度受到多种因素的影响，主要包括：

<span class="hljs-bullet">1.</span>  <span class="hljs-strong">**年龄**</span>：年龄越大，风险通常越高。高龄老人（尤其是80岁以上）风险最高。
<span class="hljs-bullet">2.</span>  <span class="hljs-strong">**基础健康状况**</span>：<span class="hljs-strong">**合并症**</span>是最重要的风险因素。患有<span class="hljs-strong">**心血管疾病、糖尿病、慢性肺病、免疫缺陷、癌症、慢性肾病、肥胖**</span>等基础疾病，以及<span class="hljs-strong">**免疫功能低下**</span>的老年人，感染后发展为重症的风险显著增加。
<span class="hljs-bullet">3.</span>  <span class="hljs-strong">**疫苗接种情况**</span>：完成疫苗（包括加强针）接种，特别是有效疫苗，可以显著降低重症和死亡风险。
<span class="hljs-bullet">4.</span>  <span class="hljs-strong">**感染的病毒毒株和变种**</span>：不同毒株的致病力和传播性不同，感染不同毒株的风险和严重程度也会有所差异。
<span class="hljs-bullet">5.</span>  <span class="hljs-strong">**感染时的身体状况和免疫反应**</span>：个体对病毒的反应不同，有些老人即使有基础病，但感染时状态较好，免疫系统反应适当，也可能相对较轻。
<span class="hljs-bullet">6.</span>  <span class="hljs-strong">**医疗支持**</span>：及时的医疗干预、氧疗、抗病毒药物（如Paxlovid）和有效的支持治疗可以显著改善预后，避免走向危重症。

<span class="hljs-strong">**总结来说：**</span>

<span class="hljs-bullet">*</span>   老年人是<span class="hljs-strong">**感染后发展为重症的高危人群**</span>，这是毋庸置疑的。
<span class="hljs-bullet">*</span>   <span class="hljs-strong">**但是，个体差异很大**</span>。并非所有老年人都会经历同样的严重程度。很多老年人在感染后可能只是出现类似感冒或流感的症状。
<span class="hljs-bullet">*</span>   <span class="hljs-strong">**关键在于预防和早期干预**</span>。通过接种疫苗、做好防护、管理基础疾病、以及在出现症状时及时就医，可以大大降低老年人走向重症和危重症的风险。

因此，与其说“老年人感染后一定会走向重症”，不如说“<span class="hljs-strong">**老年人感染新冠病毒后，有很高的风险发展为重症，特别是那些有基础疾病和免疫功能低下的老人**</span>”。我们需要对老年人群给予特别的关注和保护。
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SQL 语句左连接右连接内连接如何使用，区别是什么？]]></title>    <link>https://juejin.cn/post/7572485825705607177</link>    <guid>https://juejin.cn/post/7572485825705607177</guid>    <pubDate>2025-11-15T08:12:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572485825705607177" data-draft-id="7572510909445210162" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SQL 语句左连接右连接内连接如何使用，区别是什么？"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-15T08:12:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员小假"/> <meta itemprop="url" content="https://juejin.cn/user/2285197690931932"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SQL 语句左连接右连接内连接如何使用，区别是什么？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2285197690931932/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员小假
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T08:12:39.000Z" title="Sat Nov 15 2025 08:12:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h3 data-id="heading-0"> 核心概念</h3>
<p>连接（JOIN）用于根据两个或多个表中的列之间的关系，从这些表中查询数据。为了更直观地理解，我们假设有两个表：</p>
<p><code>员工表 (Employees)</code></p>






























<table><thead><tr><th/><th/><th/></tr></thead><tbody><tr><td>employee_id</td><td>name</td><td>department_id</td></tr><tr><td>1</td><td>张三</td><td>101</td></tr><tr><td>2</td><td>李四</td><td>102</td></tr><tr><td>3</td><td>王五</td><td>NULL</td></tr></tbody></table>
<p><code>部门表 (Departments)</code></p>

























<table><thead><tr><th/><th/></tr></thead><tbody><tr><td>department_id</td><td>department_name</td></tr><tr><td>101</td><td>技术部</td></tr><tr><td>102</td><td>销售部</td></tr><tr><td>103</td><td>市场部</td></tr></tbody></table>
<h3 data-id="heading-1">内连接 (INNER JOIN)</h3>
<p><strong>定义</strong>：只返回两个表中<strong>连接条件匹配</strong>的记录。</p>
<p><strong>结果</strong>：两个表的<strong>交集</strong>部分。</p>
<p><strong>使用场景</strong>：当你只想查看在两边表中都有对应信息的记录时。例如，查询所有有部门的员工及其部门信息。</p>
<p><strong>SQL语句</strong>：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    e.name,
    d.department_name
<span class="hljs-keyword">FROM</span> 
    Employees e
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 
    Departments d <span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>查询结果</strong>：</p>





















<table><thead><tr><th/><th/></tr></thead><tbody><tr><td>name</td><td>department_name</td></tr><tr><td>张三</td><td>技术部</td></tr><tr><td>李四</td><td>销售部</td></tr></tbody></table>
<p><strong>注意</strong>：员工“王五”的<code>department_id</code>为NULL，在部门表中找不到匹配项，所以没有出现。部门“市场部”在员工表中没有对应的员工，所以也没有出现。</p>
<h3 data-id="heading-2">左外连接 (LEFT JOIN / LEFT OUTER JOIN)</h3>
<p><strong>定义</strong>：返回<strong>左表 (FROM子句中的表)</strong> 的所有记录，以及右表中连接条件匹配的记录。如果右表没有匹配的记录，则结果集中右表的部分返回NULL。</p>
<p><strong>结果</strong>：左表的全集 + 右表的匹配部分。</p>
<p><strong>使用场景</strong>：当你需要左表的所有记录，无论它们在右表中是否有对应项。例如，列出所有员工，并显示他们所在的部门（即使某些员工没有部门）。</p>
<p><strong>SQL语句</strong>：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    e.name,
    d.department_name
<span class="hljs-keyword">FROM</span> 
    Employees e
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 
    Departments d <span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>查询结果</strong>：</p>

























<table><thead><tr><th/><th/></tr></thead><tbody><tr><td>name</td><td>department_name</td></tr><tr><td>张三</td><td>技术部</td></tr><tr><td>李四</td><td>销售部</td></tr><tr><td>王五</td><td>NULL</td></tr></tbody></table>
<p><strong>注意</strong>：员工“王五”被包含在结果中，但因为他不属于任何部门，所以<code>department_name</code>为NULL。</p>
<h3 data-id="heading-3">右外连接 (RIGHT JOIN / RIGHT OUTER JOIN)</h3>
<p><strong>定义</strong>：与左连接相反。返回<strong>右表 (JOIN子句中的表)</strong> 的所有记录，以及左表中连接条件匹配的记录。如果左表没有匹配的记录，则结果集中左表的部分返回NULL。</p>
<p><strong>结果</strong>：右表的全集 + 左表的匹配部分。</p>
<p><strong>使用场景</strong>：当你需要右表的所有记录，无论它们在左表中是否有对应项。例如，列出所有部门，并显示部门里的员工（即使某些部门没有员工）。</p>
<p><strong>SQL语句</strong>：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    e.name,
    d.department_name
<span class="hljs-keyword">FROM</span> 
    Employees e
<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> 
    Departments d <span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>查询结果</strong>：</p>

























<table><thead><tr><th/><th/></tr></thead><tbody><tr><td>name</td><td>department_name</td></tr><tr><td>张三</td><td>技术部</td></tr><tr><td>李四</td><td>销售部</td></tr><tr><td>NULL</td><td>市场部</td></tr></tbody></table>
<p><strong>注意</strong>：部门“市场部”被包含在结果中，但因为该部门没有员工，所以<code>name</code>为NULL。</p>
<h3 data-id="heading-4">全外连接 (FULL OUTER JOIN)</h3>
<p><strong>定义</strong>：返回左表和右表中的所有记录。当某一行在另一个表中没有匹配行时，另一个表的部分将返回NULL。如果表之间有匹配的行，则返回匹配行。</p>
<p><strong>结果</strong>：两个表的<strong>并集</strong>。</p>
<p><strong>使用场景</strong>：当你需要看到两个表的所有数据，无论它们是否匹配。例如，生成一个包含所有员工和所有部门的完整列表。</p>
<p><strong>SQL语句</strong>：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">-- 注意：MySQL不支持FULL OUTER <span class="hljs-keyword">JOIN</span>，但可用LEFT <span class="hljs-keyword">JOIN</span>和RIGHT <span class="hljs-keyword">JOIN</span>的UNION来实现
<span class="hljs-keyword">SELECT</span> 
    e.name,
    d.department_name
<span class="hljs-keyword">FROM</span> 
    Employees e
LEFT <span class="hljs-keyword">JOIN</span> 
    Departments d <span class="hljs-keyword">ON</span> e.department_id = d.department_id

UNION

<span class="hljs-keyword">SELECT</span> 
    e.name,
    d.department_name
<span class="hljs-keyword">FROM</span> 
    Employees e
RIGHT <span class="hljs-keyword">JOIN</span> 
    Departments d <span class="hljs-keyword">ON</span> e.department_id = d.department_id;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>查询结果</strong>：</p>





























<table><thead><tr><th/><th/></tr></thead><tbody><tr><td>name</td><td>department_name</td></tr><tr><td>张三</td><td>技术部</td></tr><tr><td>李四</td><td>销售部</td></tr><tr><td>王五</td><td>NULL</td></tr><tr><td>NULL</td><td>市场部</td></tr></tbody></table>
<p><strong>注意</strong>：这个结果包含了左连接和右连接的所有记录。</p>
<h3 data-id="heading-5">总结与区别</h3>









































<table><thead><tr><th/><th/><th/><th/></tr></thead><tbody><tr><td>连接类型</td><td>关键字</td><td>描述</td><td>结果集（基于示例）</td></tr><tr><td><strong>内连接</strong></td><td><code>INNER JOIN</code></td><td>只返回两个表<strong>匹配</strong>的记录。</td><td>张三(技术部), 李四(销售部)</td></tr><tr><td><strong>左连接</strong></td><td><code>LEFT JOIN</code></td><td>返回<strong>左表全部</strong>记录 + <strong>右表匹配</strong>的记录。</td><td>张三(技术部), 李四(销售部), 王五(NULL)</td></tr><tr><td><strong>右连接</strong></td><td><code>RIGHT JOIN</code></td><td>返回<strong>右表全部</strong>记录 + <strong>左表匹配</strong>的记录。</td><td>张三(技术部), 李四(销售部), NULL(市场部)</td></tr><tr><td><strong>全外连接</strong></td><td><code>FULL OUTER JOIN</code></td><td>返回<strong>左右两表全部</strong>记录。</td><td>张三(技术部), 李四(销售部), 王五(NULL), NULL(市场部)</td></tr></tbody></table>
<h3 data-id="heading-6">记忆技巧</h3>
<p>可以借助<strong>韦恩图 (Venn Diagram)</strong> 来记忆：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66db546d314b41d788e324d9e0ecfd77~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY5bCP5YGH:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763799234&amp;x-signature=qw26b1izjK8EM8M61YInrbqmr%2Fo%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[学习React-DnD：核心组件与Hooks]]></title>    <link>https://juejin.cn/post/7572405211442135083</link>    <guid>https://juejin.cn/post/7572405211442135083</guid>    <pubDate>2025-11-15T07:37:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572405211442135083" data-draft-id="7572465262738948115" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="学习React-DnD：核心组件与Hooks"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-15T07:37:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wect"/> <meta itemprop="url" content="https://juejin.cn/user/4185164878720068"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            学习React-DnD：核心组件与Hooks
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185164878720068/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wect
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T07:37:16.000Z" title="Sat Nov 15 2025 07:37:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>上一篇我们完成了React-DnD的环境搭建，通过安装依赖和全局注入后端，让整个应用具备了拖放能力的基础。这一篇，我们将深入React-DnD的核心——那些支撑起拖放功能的组件和Hooks。从全局管理的DndProvider，到定义拖动源的useDrag、拖放目标的useDrop，每一个都至关重要。掌握它们，你就能轻松实现各种复杂的拖放场景。</p>
<p>在开始之前，先明确一个核心逻辑：React-DnD通过“组件提供上下文 + Hooks连接组件”的模式工作。DndProvider作为上下文提供者，为所有子组件传递拖放能力；而useDrag、useDrop等Hooks则负责将普通组件“改造”为拖动源或拖放目标，实现具体的交互逻辑。下面我们逐个拆解。</p>
<h2 data-id="heading-0">一、核心组件：拖放能力的“基石”</h2>
<p>React-DnD的组件数量不多，但每一个都是构建拖放功能的关键。其中DndProvider是必用组件，DragPreviewImage则用于优化拖动体验，我们重点讲解这两个。</p>
<h3 data-id="heading-1">1. DndProvider：拖放上下文的“提供者”</h3>
<p>如果把React-DnD的拖放能力比作“水电”，那么DndProvider就是“水电总闸”。它负责将拖放后端的能力注入到整个应用，让所有子组件都能共享这份能力。上一篇我们已经在入口文件中用过它，现在来深入理解它的核心作用和配置项。</p>
<h4 data-id="heading-2">核心作用</h4>
<p>DndProvider的本质是一个React上下文（Context）的提供者，它会创建一个拖放上下文，并将后端（如HTML5Backend）的功能传递给所有子组件。这样一来，子组件通过useDrag、useDrop等Hooks就能直接获取拖放能力，无需单独配置后端。</p>
<p>如果不使用DndProvider包裹应用，后续编写拖动源或拖放目标时会直接报错——组件找不到拖放上下文，就像没接水电的房子无法使用电器一样。</p>
<h4 data-id="heading-3">关键配置项</h4>
<p>DndProvider的配置项不多，但每一个都有明确的用途，其中backend是必填项，其他为可选项。</p>
<ul>
<li><strong>backend（必填）</strong> ：React-DnD的后端引擎，负责处理原生DOM事件（如鼠标拖动、悬停），并将其转化为React-DnD能识别的逻辑。我们开发PC端应用时，基本都使用官方提供的react-dnd-html5-backend；如果是移动端，则可以使用react-dnd-touch-backend。</li>
<li><strong>context（可选）</strong> ：用于配置后端的上下文对象，具体用法取决于你使用的后端实现。一般情况下，使用默认配置即可，无需额外设置。</li>
<li><strong>options（可选）</strong> ：用于配置后端的选项对象，同样依赖于后端实现。例如，某些后端支持配置拖动的延迟时间、触摸反馈等，都可以通过这个参数传递。</li>
</ul>
<h4 data-id="heading-4">实战示例（回顾与强化）</h4>
<p>在入口文件src/index.js中，我们用DndProvider包裹整个App组件，并注入HTML5Backend。这里再强调一下核心代码的逻辑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;
<span class="hljs-comment">// 导入 DndProvider 和 HTML5Backend</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DndProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HTML5Backend</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd-html5-backend'</span>;

<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
root.<span class="hljs-title function_">render</span>(
  <span class="hljs-comment">// 用DndProvider包裹App，注入后端</span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DndProvider</span> <span class="hljs-attr">backend</span>=<span class="hljs-string">{HTML5Backend}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">DndProvider</span>&gt;</span></span>
);
</code></pre>
<p>这里的关键是将HTML5Backend作为backend属性传递给DndProvider，这样整个应用的子组件都能使用拖放能力了。</p>
<h3 data-id="heading-5">2. DragPreviewImage：自定义拖动预览的“工具”</h3>
<p>默认情况下，拖动元素时，浏览器会生成一个该元素的“快照”作为拖动预览。但在实际开发中，我们可能需要自定义预览效果（比如拖动时显示一个简化的图标，而不是整个元素），这时候就需要用到DragPreviewImage组件。</p>
<h4 data-id="heading-6">核心作用</h4>
<p>DragPreviewImage组件用于将一张HTML图像元素（img）渲染为拖动时的预览效果，替代浏览器默认的预览快照。它需要配合useDrag钩子的拖动预览连接器使用。</p>
<h4 data-id="heading-7">关键配置项</h4>
<p>DragPreviewImage只有一个必填配置项：connect。</p>
<ul>
<li><strong>connect（必填）</strong> ：拖动预览的连接器函数，来自useDrag钩子的返回值。它的作用是将自定义的预览图像与拖动操作关联起来，让浏览器在拖动时显示这张图像。</li>
</ul>
<h4 data-id="heading-8">实战示例</h4>
<p>下面的例子中，我们创建一个可拖动的任务卡片，拖动时显示一张自定义的预览图片：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useDrag } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DragPreviewImage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;
<span class="hljs-comment">// 导入自定义预览图片</span>
<span class="hljs-keyword">import</span> taskPreview <span class="hljs-keyword">from</span> <span class="hljs-string">'./task-preview.png'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TaskCard</span>(<span class="hljs-params">{ id, title }</span>) {
  <span class="hljs-comment">// 从useDrag中获取拖动预览连接器</span>
  <span class="hljs-keyword">const</span> [, dragSourceRef, dragPreviewRef] = <span class="hljs-title function_">useDrag</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'TASK'</span>,
    <span class="hljs-attr">item</span>: { id, title }
  });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dragSourceRef}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">16</span>, <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>', <span class="hljs-attr">margin:</span> <span class="hljs-attr">8</span> }}&gt;</span>
      {/* 关联自定义预览图片 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">DragPreviewImage</span> <span class="hljs-attr">connect</span>=<span class="hljs-string">{dragPreviewRef}</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{taskPreview}</span> /&gt;</span>
      {title}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TaskCard</span>;
</code></pre>
<p>这里的核心逻辑是：从useDrag的返回值中获取dragPreviewRef（拖动预览连接器），然后将其传递给DragPreviewImage的connect属性，同时通过src属性指定自定义预览图片的路径。这样，拖动TaskCard时，就会显示taskPreview.png这张图片作为预览效果。</p>
<h2 data-id="heading-9">二、核心Hooks：拖放交互的“实现者”</h2>
<p>如果说组件是React-DnD的“骨架”，那么Hooks就是“肌肉”——它们负责实现具体的拖放交互逻辑。React-DnD提供了多个实用Hooks，其中useDrag（定义拖动源）、useDrop（定义拖放目标）是最常用的两个，useDragLayer和useDragDropManager则用于更复杂的场景。</p>
<h3 data-id="heading-10">1. useDrag：让组件成为“拖动源”</h3>
<p>useDrag是将普通React组件转化为“拖动源”的核心钩子。通过向它传递一个规范对象（spec），我们可以声明性地描述拖动源的类型、拖动的数据、拖动过程中的回调等。</p>
<h4 data-id="heading-11">基本用法：参数与返回值</h4>
<p>useDrag的用法可以总结为“传入spec配置，返回三个核心对象”，具体如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [collectedProps, dragSourceRef, dragPreviewRef] = <span class="hljs-title function_">useDrag</span>(spec, deps);
</code></pre>
<h5 data-id="heading-12">参数说明</h5>
<ul>
<li><strong>spec（必填）</strong> ：规范对象或返回规范对象的函数，用于配置拖动源的核心逻辑。这是useDrag的核心，我们后面会详细拆解其成员。</li>
<li><strong>deps（可选）</strong> ：依赖关系数组，用于备忘录化（类似React的useMemo）。如果spec是函数，deps默认是空数组；如果spec是对象，deps默认是包含spec的数组。当deps中的值发生变化时，useDrag会重新计算spec配置。</li>
</ul>
<h5 data-id="heading-13">返回值说明</h5>
<p>useDrag返回一个包含三个元素的数组，每个元素都有明确的用途：</p>
<ul>
<li><strong>collectedProps（索引0）</strong> ：从collect函数中收集的属性对象。collect函数用于从拖放监控器（monitor）中获取拖动状态（如是否正在拖动），并将其转化为组件的props。如果没有定义collect函数，返回空对象。</li>
<li><strong>dragSourceRef（索引1）</strong> ：拖动源的连接器函数，必须绑定到组件的DOM元素上。它的作用是告诉React-DnD“哪个元素是可拖动的”，如果不绑定，组件将无法被拖动。</li>
<li><strong>dragPreviewRef（索引2）</strong> ：拖动预览的连接器函数，用于关联自定义的拖动预览（如DragPreviewImage组件）。如果不需要自定义预览，可以忽略它。</li>
</ul>
<h4 data-id="heading-14">核心：spec规范对象详解</h4>
<p>spec对象是useDrag的灵魂，它定义了拖动源的所有行为。其中type和item是必填项，其他为可选项。</p>
<h5 data-id="heading-15">必填成员</h5>
<ul>
<li><strong>type（必填）</strong> ：字符串或符号（Symbol），用于标识拖动源的类型。只有注册了相同类型的拖放目标（useDrop），才会对该拖动源的拖放操作做出反应。这是React-DnD实现“拖动源与目标匹配”的核心机制。例如，我们可以将任务卡片的type设为'TASK'，将任务列表的accept设为'TASK'，这样任务卡片就能拖放到任务列表中。</li>
<li><strong>item（必填）</strong> ：描述拖动数据的对象，或返回该对象的函数。这是拖动源传递给拖放目标的“核心数据”，也是两者之间唯一的通信桥梁。 如果是对象，应只包含拖放目标需要的最小数据（如id、名称），避免传递复杂引用（比如整个组件实例），否则会导致拖动源和目标过度耦合。</li>
<li>如果是函数，会在拖动操作开始时执行，并返回上述对象。如果返回null，拖动操作会被取消。</li>
</ul>
<h5 data-id="heading-16">可选成员（回调与配置）</h5>
<p><strong>end(item, monitor)（可选）</strong> ：拖动操作结束时触发的回调函数，无论拖动是否成功（比如拖到目标后释放，或拖到无效区域释放），都会执行。</p>
<ul>
<li>
<p>item：拖动的核心数据（与spec.item一致）。</p>
</li>
<li>
<p>monitor：拖放监控器，用于获取拖动状态（如monitor.didDrop()可以判断拖放是否被目标接受，monitor.getDropResult()可以获取目标返回的结果）。</p>
</li>
<li>
<p>常用场景：拖动结束后更新数据（如将任务从“待办”列表移到“已办”列表）。</p>
</li>
</ul>
<p><strong>canDrag(monitor)（可选）</strong> ：用于判断当前组件是否允许被拖动。返回true则允许拖动，返回false则禁止。 monitor：拖放监控器，可以通过monitor.getItem()获取拖动数据，结合组件props判断是否允许拖动（如某些任务卡片不允许被拖动）。</p>
<p>注意： 不能在该函数中调用monitor.canDrag()，否则会导致死循环。</p>
<p><strong>isDragging(monitor)（可选）</strong> ：用于自定义“是否正在拖动”的判断逻辑。默认情况下，只有启动拖动的组件会被视为“正在拖动”。 常用场景：当有多个相同类型的组件时（如多个任务卡片），通过item.id与组件props.id对比，确保只有当前拖动的组件显示“拖动中”的样式。</p>
<p>示例：return monitor.getItem().id === props.id;</p>
<p><strong>collect(monitor, props)（可选）</strong> ：收集函数，用于从监控器中获取拖动状态，并转化为组件的props。返回的对象会作为useDrag的第一个返回值（collectedProps）传递给组件。</p>
<p>常用监控器方法：monitor.isDragging()（是否正在拖动）、monitor.getInitialClientOffset()（拖动开始时的鼠标位置）等。</p>
<p>示例：(monitor) =&gt; ({ isDragging: monitor.isDragging() })</p>
<h4 data-id="heading-17">useDrag实战：可拖动的任务卡片</h4>
<p>结合上面的知识点，我们实现一个完整的可拖动任务卡片组件，包含拖动状态判断、拖动结束回调等功能：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// DraggableTask.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useDrag } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;

<span class="hljs-comment">// 定义拖动类型（建议用Symbol避免冲突）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TASK_TYPE</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'TASK'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DraggableTask</span>(<span class="hljs-params">{ id, title, onDragEnd }</span>) {
  <span class="hljs-keyword">const</span> [collectedProps, dragSourceRef] = <span class="hljs-title function_">useDrag</span>({
    <span class="hljs-comment">// 拖动类型</span>
    <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TASK_TYPE</span>,
    <span class="hljs-comment">// 拖动数据（只传递必要的id和title）</span>
    <span class="hljs-attr">item</span>: <span class="hljs-function">() =&gt;</span> ({ id, title }),
    <span class="hljs-comment">// 拖动结束回调</span>
    <span class="hljs-attr">end</span>: <span class="hljs-function">(<span class="hljs-params">item, monitor</span>) =&gt;</span> {
      <span class="hljs-comment">// 判断拖放是否被目标接受</span>
      <span class="hljs-keyword">if</span> (monitor.<span class="hljs-title function_">didDrop</span>()) {
        <span class="hljs-comment">// 获取目标返回的结果（如目标列表的id）</span>
        <span class="hljs-keyword">const</span> dropResult = monitor.<span class="hljs-title function_">getDropResult</span>();
        <span class="hljs-comment">// 调用父组件方法更新数据</span>
        <span class="hljs-title function_">onDragEnd</span>(item.<span class="hljs-property">id</span>, dropResult.<span class="hljs-property">listId</span>);
      }
    },
    <span class="hljs-comment">// 收集拖动状态</span>
    <span class="hljs-attr">collect</span>: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> ({
      <span class="hljs-attr">isDragging</span>: monitor.<span class="hljs-title function_">isDragging</span>()
    }),
    <span class="hljs-comment">// 只有id为偶数的任务可以拖动（示例）</span>
    <span class="hljs-attr">canDrag</span>: <span class="hljs-function">() =&gt;</span> id % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>
  });

  <span class="hljs-comment">// 根据拖动状态设置样式（拖动时半透明）</span>
  <span class="hljs-keyword">const</span> cardStyle = {
    <span class="hljs-attr">padding</span>: <span class="hljs-number">16</span>,
    <span class="hljs-attr">border</span>: <span class="hljs-string">'1px solid #ccc'</span>,
    <span class="hljs-attr">margin</span>: <span class="hljs-number">8</span>,
    <span class="hljs-attr">opacity</span>: collectedProps.<span class="hljs-property">isDragging</span> ? <span class="hljs-number">0.5</span> : <span class="hljs-number">1</span>,
    <span class="hljs-attr">cursor</span>: collectedProps.<span class="hljs-property">isDragging</span> ? <span class="hljs-string">'grabbing'</span> : <span class="hljs-string">'grab'</span>
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dragSourceRef}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{cardStyle}</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DraggableTask</span>;
</code></pre>
<p>这个例子中，我们实现了以下功能：</p>
<ul>
<li>只有id为偶数的任务卡片可以被拖动（canDrag配置）。</li>
<li>拖动时卡片显示半透明效果（通过collect获取isDragging状态，动态设置opacity）。</li>
<li>拖动结束后，根据拖放结果调用父组件的onDragEnd方法更新数据（end回调）。</li>
</ul>
<h3 data-id="heading-18">2. useDrop：让组件成为“拖放目标”</h3>
<p>useDrag负责“发起”拖放，useDrop则负责“接收”拖放——它将普通组件转化为“拖放目标”，用于接收拖动源传递的数据，并处理拖放相关的逻辑（如悬停、接收拖放）。</p>
<h4 data-id="heading-19">基本用法：参数与返回值</h4>
<p>useDrop的用法与useDrag类似，都是“传入spec配置，返回核心对象”，具体如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [collectedProps, dropTargetRef] = <span class="hljs-title function_">useDrop</span>(spec, deps);
</code></pre>
<h5 data-id="heading-20">参数说明</h5>
<ul>
<li><strong>spec（必填）</strong> ：规范对象或返回规范对象的函数，用于配置拖放目标的核心逻辑，是useDrop的核心。</li>
<li><strong>deps（可选）</strong> ：依赖关系数组，作用与useDrag的deps一致，用于备忘录化。</li>
</ul>
<h5 data-id="heading-21">返回值说明</h5>
<p>useDrop返回一个包含两个元素的数组：</p>
<ul>
<li><strong>collectedProps（索引0）</strong> ：从collect函数中收集的属性对象，与useDrag的collectedProps类似，用于获取拖放状态（如是否有元素悬停在目标上）。</li>
<li><strong>dropTargetRef（索引1）</strong> ：拖放目标的连接器函数，必须绑定到组件的DOM元素上，告诉React-DnD“哪个元素是拖放目标”。</li>
</ul>
<h4 data-id="heading-22">核心：spec规范对象详解</h4>
<p>useDrop的spec对象与useDrag类似，但核心关注点是“接收拖放”，其中accept是必填项。</p>
<h5 data-id="heading-23">必填成员</h5>
<ul>
<li><strong>accept（必填）</strong> ：用于指定当前拖放目标可以接受的拖动源类型，与useDrag的type对应。它可以是字符串、符号，也可以是包含多个类型的数组。
<ul>
<li>示例：<code>accept: TASK_TYPE</code>（接受类型为TASK_TYPE的拖动源）。</li>
<li>示例：<code>accept: [TASK_TYPE, PROJECT_TYPE]</code>（接受两种类型的拖动源）。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-24">可选成员（回调与配置）</h5>
<p><strong>drop(item, monitor)（可选）</strong> ：当兼容类型的拖动源在目标上<strong>释放时</strong>触发的回调函数，是处理拖放逻辑的核心。</p>
<ul>
<li>item：拖动源传递的核心数据（与useDrag的spec.item一致）。</li>
<li>monitor：拖放监控器，可以通过monitor.isOver({ shallow: true })判断是否是直接悬停（而非嵌套目标）。</li>
<li>返回值：可以返回一个对象，该对象会作为拖放结果，通过monitor.getDropResult()传递给拖动源的end回调。</li>
<li>常用场景：接收拖动的任务数据，将其添加到当前列表中。</li>
</ul>
<p><strong>hover(item, monitor)（可选）</strong> ：当拖动源悬停在目标上时<strong>持续</strong>触发的回调函数（即使鼠标不动也会触发）。 常用场景：实现“拖入时高亮目标”“拖动排序”等交互（如在列表中拖动任务时，调整任务的位置）。</p>
<p>注意：即使canDrop返回false，该函数也会触发，可以通过monitor.canDrop()判断当前是否允许接收拖放。</p>
<p><strong>canDrop(item, monitor)（可选）</strong> ：用于判断当前目标是否允许接收该拖动源的数据。返回true则允许，返回false则禁止。 示例：根据拖动源的id判断是否允许接收（如禁止将任务拖放到自己所在的列表）。</p>
<p>注意：不能在该函数中调用monitor.canDrop()。</p>
<p><strong>collect(monitor, props)（可选）</strong> ：收集函数，用于从监控器中获取拖放状态，转化为组件的props。 常用监控器方法：monitor.isOver()（是否有元素悬停）、monitor.canDrop()（是否允许接收拖放）等。</p>
<p>示例：(monitor) =&gt; ({ isOver: monitor.isOver(), canDrop: monitor.canDrop() })</p>
<h4 data-id="heading-25">useDrop实战：可接收任务的列表</h4>
<p>结合useDrag的任务卡片，我们实现一个可接收任务的列表组件，包含悬停高亮、接收任务等功能：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// TaskList.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useDrop } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">TASK_TYPE</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./DraggableTask'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TaskList</span>(<span class="hljs-params">{ id, title, tasks, onAddTask }</span>) {
  <span class="hljs-keyword">const</span> [collectedProps, dropTargetRef] = <span class="hljs-title function_">useDrop</span>({
    <span class="hljs-comment">// 接受TASK_TYPE类型的拖动源</span>
    <span class="hljs-attr">accept</span>: <span class="hljs-variable constant_">TASK_TYPE</span>,
    <span class="hljs-comment">// 接收拖放时的回调</span>
    <span class="hljs-attr">drop</span>: <span class="hljs-function">(<span class="hljs-params">item, monitor</span>) =&gt;</span> {
      <span class="hljs-comment">// 调用父组件方法，将任务添加到当前列表</span>
      <span class="hljs-title function_">onAddTask</span>(id, item);
      <span class="hljs-comment">// 返回拖放结果，传递给拖动源</span>
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">listId</span>: id };
    },
    <span class="hljs-comment">// 悬停时的回调</span>
    <span class="hljs-attr">hover</span>: <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      <span class="hljs-comment">// 可以在这里实现拖动排序逻辑（如调整任务在列表中的位置）</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`任务 <span class="hljs-subst">${item.id}</span> 悬停在 <span class="hljs-subst">${title}</span> 列表上`</span>);
    },
    <span class="hljs-comment">// 收集拖放状态</span>
    <span class="hljs-attr">collect</span>: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> ({
      <span class="hljs-attr">isOver</span>: monitor.<span class="hljs-title function_">isOver</span>(),
      <span class="hljs-attr">canDrop</span>: monitor.<span class="hljs-title function_">canDrop</span>()
    })
  });

  <span class="hljs-comment">// 根据悬停状态和是否允许拖放设置样式</span>
  <span class="hljs-keyword">const</span> listStyle = {
    <span class="hljs-attr">padding</span>: <span class="hljs-number">16</span>,
    <span class="hljs-attr">border</span>: collectedProps.<span class="hljs-property">isOver</span> &amp;&amp; collectedProps.<span class="hljs-property">canDrop</span> 
      ? <span class="hljs-string">'2px solid #2196F3'</span> 
      : <span class="hljs-string">'1px solid #eee'</span>,
    <span class="hljs-attr">margin</span>: <span class="hljs-number">16</span>,
    <span class="hljs-attr">minHeight</span>: <span class="hljs-number">200</span>
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dropTargetRef}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{listStyle}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      {tasks.map(task =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{task.id}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span>, <span class="hljs-attr">borderBottom:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">eee</span>' }}&gt;</span>
          {task.title}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TaskList</span>;
</code></pre>
<p>这个例子中，我们实现了以下功能：</p>
<ul>
<li>列表只接受TASK_TYPE类型的拖动源（accept配置）。</li>
<li>当任务卡片悬停在列表上且允许拖放时，列表边框变为蓝色高亮（通过collect获取isOver和canDrop状态）。</li>
<li>接收任务卡片后，调用父组件的onAddTask方法将任务添加到当前列表，并返回列表id给拖动源。</li>
</ul>
<h3 data-id="heading-26">3. 其他实用Hooks：应对复杂场景</h3>
<p>除了useDrag和useDrop，React-DnD还提供了两个用于复杂场景的Hooks：useDragLayer和useDragDropManager。</p>
<h4 data-id="heading-27">useDragLayer：自定义全局拖动层</h4>
<p>当需要实现超越单个组件的拖动预览（如拖动时显示一个覆盖整个页面的提示）时，useDragLayer就派上用场了。它可以创建一个独立于拖动源和目标的“全局拖动层”，不受其他组件的样式影响。</p>
<h5 data-id="heading-28">核心用法</h5>
<p>useDragLayer只接收一个必填参数collect（收集函数），返回从collect函数中获取的属性对象。collect函数的作用是从监控器中获取拖动状态，用于渲染拖动层的内容。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// CustomDragLayer.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useDragLayer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomDragLayer</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 收集拖动状态</span>
  <span class="hljs-keyword">const</span> { item, isDragging } = <span class="hljs-title function_">useDragLayer</span>(<span class="hljs-function"><span class="hljs-params">monitor</span> =&gt;</span> ({
    <span class="hljs-attr">item</span>: monitor.<span class="hljs-title function_">getItem</span>(),
    <span class="hljs-attr">isDragging</span>: monitor.<span class="hljs-title function_">isDragging</span>()
  }));

  <span class="hljs-comment">// 没有拖动时不渲染</span>
  <span class="hljs-keyword">if</span> (!isDragging) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 拖动时显示自定义提示</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
      <span class="hljs-attr">position:</span> '<span class="hljs-attr">fixed</span>',
      <span class="hljs-attr">zIndex:</span> <span class="hljs-attr">9999</span>,
      <span class="hljs-attr">pointerEvents:</span> '<span class="hljs-attr">none</span>',
      <span class="hljs-attr">left:</span> <span class="hljs-attr">0</span>,
      <span class="hljs-attr">top:</span> <span class="hljs-attr">0</span>,
      <span class="hljs-attr">width:</span> '<span class="hljs-attr">100</span>%',
      <span class="hljs-attr">height:</span> '<span class="hljs-attr">100</span>%',
      <span class="hljs-attr">display:</span> '<span class="hljs-attr">flex</span>',
      <span class="hljs-attr">alignItems:</span> '<span class="hljs-attr">center</span>',
      <span class="hljs-attr">justifyContent:</span> '<span class="hljs-attr">center</span>'
    }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">20</span>, <span class="hljs-attr">backgroundColor:</span> '<span class="hljs-attr">rgba</span>(<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">0.7</span>)', <span class="hljs-attr">color:</span> '<span class="hljs-attr">white</span>' }}&gt;</span>
        正在拖动：{item.title}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CustomDragLayer</span>;
</code></pre>
<p>这个自定义拖动层会在拖动时显示一个居中的提示框，显示当前拖动的任务标题，且不会影响其他组件的交互（pointerEvents: 'none'确保点击事件能穿透到下层组件）。</p>
<h4 data-id="heading-29">useDragDropManager：获取拖放管理器实例</h4>
<p>DragDropManager是React-DnD的核心单例对象，包含了拖放系统的状态、监控器、后端等核心资源。useDragDropManager钩子用于获取这个实例，一般用于自定义后端或高级扩展场景（如手动触发拖放事件）。</p>
<h5 data-id="heading-30">基本用法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { useDragDropManager } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AdvancedComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> manager = <span class="hljs-title function_">useDragDropManager</span>();
  <span class="hljs-comment">// 可以通过manager获取监控器、后端等资源</span>
  <span class="hljs-keyword">const</span> monitor = manager.<span class="hljs-title function_">getMonitor</span>();

  <span class="hljs-comment">// 高级用法：手动监听拖动状态变化</span>
  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> unsubscribe = monitor.<span class="hljs-title function_">subscribeToStateChange</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'拖放状态变化：'</span>, monitor.<span class="hljs-title function_">isDragging</span>());
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unsubscribe</span>();
  }, [monitor]);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>高级扩展组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>对于大多数普通开发场景，我们很少会直接使用useDragDropManager，除非需要深度定制React-DnD的行为。</p>
<h2 data-id="heading-31">三、总结</h2>
<p>这一篇我们深入讲解了React-DnD的核心组件和Hooks，核心要点总结如下：</p>
<ul>
<li><strong>组件</strong>：DndProvider是基础（提供拖放上下文），DragPreviewImage用于自定义预览。</li>
<li><strong>Hooks</strong>：useDrag定义拖动源，useDrop定义拖放目标，两者通过type和accept匹配；useDragLayer用于全局预览，useDragDropManager用于高级扩展。</li>
<li><strong>核心逻辑</strong>：拖动源通过item传递数据，拖放目标通过drop接收数据，两者通过monitor实现状态通信。</li>
</ul>
<p>掌握了这些内容，你已经能实现大多数常见的拖放场景了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Rust RefCell 多线程读为什么也panic了？]]></title>    <link>https://juejin.cn/post/7572459757107003446</link>    <guid>https://juejin.cn/post/7572459757107003446</guid>    <pubDate>2025-11-15T08:36:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459757107003446" data-draft-id="7572408522438770723" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Rust RefCell 多线程读为什么也panic了？"/> <meta itemprop="keywords" content="Rust,Swift"/> <meta itemprop="datePublished" content="2025-11-15T08:36:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="非专业程序员"/> <meta itemprop="url" content="https://juejin.cn/user/1968539883540688"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Rust RefCell 多线程读为什么也panic了？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1968539883540688/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    非专业程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T08:36:01.000Z" title="Sat Nov 15 2025 08:36:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是最近实战中遇到的一个小知识点，没理解之前觉得「不可能」，反应过来之后，觉得自己很蠢🤣，借本文记录下。</p>
<p>看一段复现代码：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyRefCell</span>&lt;T&gt;(RefCell&lt;T&gt;);

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyRefCell</span>&lt;T&gt; {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">shared</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">MyRefCell</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0usize</span>)));

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">s</span> = shared.<span class="hljs-title function_ invoke__">clone</span>();
        handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span> * (i % <span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>));
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">r</span> = s.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">borrow</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">r</span> = s.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">borrow_mut</span>();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"thread {} read {}"</span>, i, *r);
        }));
    }

    <span class="hljs-keyword">for</span> <span class="hljs-variable">h</span> <span class="hljs-keyword">in</span> handles {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">_</span> = h.<span class="hljs-title function_ invoke__">join</span>();
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"done"</span>);
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdb1d630973d4253920f3296f26817bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2e5LiT5Lia56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763800560&amp;x-signature=M8csQtTR9rxEkrcsXq1ZrsHWAeA%3D" alt="" loading="lazy"/></p>
<p><strong>​多线程读一个RefCell封装的变量，却发生了panic，原因是：​</strong>​**<code>already mutably borrowed: BorrowError</code>**</p>
<p>即 RefCell修饰的变量在borrow时检测到已经borrow_mut了，但是代码里其实<strong>没有borrow_mut</strong>的地方，就很神奇。</p>
<p>另一个迷惑的地方是，<strong>多线程读变量居然也是不安全的，也会panic。</strong></p>
<p>或许有小伙伴不理解RefCell，这里简单介绍下：</p>
<p>Rust的借用检查一般在编译期，即一个可变借用（<code>&amp;mut T</code>）同时只能存在一个，不可变借用（<code>&amp;T</code>）和可变借用不能共存；但在实际场景中，借用关系往往很难在编译期满足，这时候就可以用RefCell，RefCell提供两个操作符：<code>borrow()</code>和<code>borrow_mut()</code>，支持在​<strong>运行时检查借用关系</strong>​，如果运行时违法借用规则，会panic。</p>
<p>在我们的代码中，其实​<strong>没有违反借用规则</strong>​，因为我们只有不可变借用，但还是panic了，为什么呢？</p>
<p>原因在于RefCell <code>borrow()</code> 的​<strong>底层实现不是原子的</strong>​，看着是多线程读，其实内部存在写操作，变成了​<strong>隐藏的多线程写</strong>​，如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ed85f258d854f608e62b3ec7d6254b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2e5LiT5Lia56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763800560&amp;x-signature=CR4KnxcSgDtIEN%2FUIjlGtibM7%2BM%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbc012ca460c4a6e8e1980076cb7e110~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Z2e5LiT5Lia56iL5bqP5ZGY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763800560&amp;x-signature=LEINKxr%2BFBLaUVq08kJqi83vzOU%3D" alt="" loading="lazy"/></p>
<p>可以看出<code>borrow()</code>和<code>borrow_mut()</code>内部实现存在写操作，多线程访问时，flag 状态管理可能出错，导致panic。</p>
<p><strong>同样的问题，在Swift中，如果是多线程读一个变量，是安全的吗？</strong></p>
<p>答案我们将在公众号「非专业程序员Ping」的下一期文章揭晓，欢迎订阅交流！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Rust ndarray 高性能计算：从元素操作到矩阵运算的优化实践]]></title>    <link>https://juejin.cn/post/7572524368876355619</link>    <guid>https://juejin.cn/post/7572524368876355619</guid>    <pubDate>2025-11-15T08:05:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572524368876355619" data-draft-id="7572454929144365091" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Rust ndarray 高性能计算：从元素操作到矩阵运算的优化实践"/> <meta itemprop="keywords" content="Rust,人工智能,笔记"/> <meta itemprop="datePublished" content="2025-11-15T08:05:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="受之以蒙"/> <meta itemprop="url" content="https://juejin.cn/user/4186572019737624"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Rust ndarray 高性能计算：从元素操作到矩阵运算的优化实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4186572019737624/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    受之以蒙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T08:05:42.000Z" title="Sat Nov 15 2025 08:05:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Rust ndarray 高性能计算：从元素操作到矩阵运算的优化实践</h2>
<h3 data-id="heading-1">一、迭代与映射：用 mapv 释放元素级处理潜力</h3>
<p>在 Rust 的 <code>ndarray</code> 库中，迭代与映射是对数组元素进行操作的基础。</p>
<p>通过灵活运用这些操作，可以高效地处理数组中的每个元素，实现各种复杂的数据处理任务。</p>
<h4 data-id="heading-2">1.1 mapv 基础：逐元素映射与类型转换</h4>
<p><code>mapv</code>是 <code>ndarray</code> 中高效的元素级映射工具，接收闭包作为参数，返回与原数组维度相同的新数组。与惰性的<code>map</code>不同，<code>mapv</code>立即分配内存并计算结果，适合需要新数组的场景。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">sensor_readings</span> = array![<span class="hljs-number">102.3</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">511.5</span>, <span class="hljs-number">1023.0f64</span>];

    <span class="hljs-comment">// 使用 mapv 进行归一化</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">normalized</span> = sensor_readings.<span class="hljs-title function_ invoke__">mapv</span>(|x| x / <span class="hljs-number">1023.0</span>);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"原始读数: \n{}"</span>, sensor_readings);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"归一化后: \n{}"</span>, normalized);

    <span class="hljs-comment">// 也可以执行更复杂的操作，比如 Sigmoid</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">activations</span> = normalized.<span class="hljs-title function_ invoke__">mapv</span>(|x| <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + (-x).<span class="hljs-title function_ invoke__">exp</span>()));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"激活值: \n{}"</span>, activations);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">原始读数:
[102.3, 0, 511.5, 1023]
归一化后:
[0.09999999999999999, 0, 0.5, 1]
激活值:
[0.5249791874789399, 0.5, 0.6224593312018546, 0.7310585786300049]
</code></pre>
<p>在具身智能场景中，当处理传感器数据时，<code>mapv</code>可用于对传感器读数进行预处理。</p>
<p>比如，将温度传感器的原始读数从摄氏度转换为华氏度，或者对压力传感器数据进行校准。</p>
<h4 data-id="heading-3">1.2 并行加速：par_mapv_inplace 应对大规模数据</h4>
<p>借助 rayon 库，<code>par_mapv_inplace</code>支持多核并行处理，显著提升计算密集型任务效率（需启用<code>rayon</code>特性）。</p>
<p><code>par_mapv_inplace</code> 被称之为<strong>就地并行修改</strong>， 是 <code>ndarray</code> 提供的最直接的并行 <code>map</code> 方法。它会启动一个线程池，并行地修改数组中的每一个元素，不返回任何东西 (())。</p>
<p>Cargo.toml配置：</p>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">ndarray</span> = { version = <span class="hljs-string">"0.17.1"</span>, features = [<span class="hljs-string">"rayon"</span>] }
</code></pre>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::Array3;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">matrix</span> =
        Array3::<span class="hljs-title function_ invoke__">from_shape_vec</span>((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1.0f64</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span>]).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-comment">// 并行计算每个元素的平方</span>
    matrix.<span class="hljs-title function_ invoke__">par_mapv_inplace</span>(|x| x.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"并行计算值: \n{}"</span>, matrix);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">并行计算值:
[[[1, 4],
  [9, 16]],

 [[25, 36],
  [49, 64]]]
</code></pre>
<h3 data-id="heading-4">二、元素级运算：简洁高效的逐元素操作</h3>
<p>元素级运算是 <code>ndarray</code> 的核心功能之一，它允许我们对数组中的每个元素进行操作，而无需显式的循环。</p>
<p>这种向量化的操作方式不仅提高了代码的简洁性，还显著提升了执行效率。</p>
<h4 data-id="heading-5">2.1 基础算术运算：运算符与函数双支持</h4>
<p><code>ndarray</code> 支持直接使用<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>进行元素级运算，操作简单直观，代码可读性强。这些运算符会自动应用到数组的每个元素上，生成一个新的数组。</p>
<p>同时，<code>ndarray</code> 也提供了<code>add</code>、<code>sub</code>、<code>mul</code>、<code>div</code>等函数来实现相同的运算。使用函数形式可以在一些需要更灵活操作的场景中，确保类型安全和更好的错误处理。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;
<span class="hljs-keyword">use</span> std::ops::Mul;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b</span> = array![[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a_clone</span> = a.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b_clone</span> = b.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-comment">// 使用运算符进行元素级加法</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">c</span> = a + b;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"相加: \n{}"</span>, c);

    <span class="hljs-comment">// 使用函数进行元素级乘法</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">d</span> = a_clone.<span class="hljs-title function_ invoke__">mul</span>(&amp;b_clone);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"相乘: \n{}"</span>, d);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">相加:
[[8, 10, 12],
 [14, 16, 18]]
相乘:
[[7, 16, 27],
 [40, 55, 72]]
</code></pre>
<h4 data-id="heading-6">2.2 数学函数应用：从基础到复杂运算</h4>
<p><code>ndarray</code> 支持<code>sqrt</code>、<code>sin</code>、<code>cos</code>等丰富的数学函数，这些函数可以直接作用于数组的每个元素，避免了手动迭代数组来应用这些函数的繁琐过程。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::prelude::*;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![<span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">9.0</span>];
    <span class="hljs-comment">// 计算每个元素的平方根</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">sqrt</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"平方根: \n{}"</span>, b);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">angles</span> = array![<span class="hljs-number">0.0</span>, std::<span class="hljs-type">f64</span>::consts::PI / <span class="hljs-number">2.0</span>, std::<span class="hljs-type">f64</span>::consts::PI];
    <span class="hljs-comment">// 计算每个角度的正弦值</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">sines</span> = angles.<span class="hljs-title function_ invoke__">sin</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"正弦值: \n{}"</span>, sines);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">平方根:
[1, 2, 3]
正弦值:
[0, 1, 0.00000000000000012246467991473532]
</code></pre>
<h3 data-id="heading-7">三、广播机制：维度适配的隐形助手</h3>
<p>在 <code>ndarray</code> 的世界里，广播机制是一种强大而又神奇的特性，它允许不同形状的数组在进行运算时自动适配维度，大大简化了代码的编写。</p>
<h4 data-id="heading-8">3.1 广播规则：从后缘维度对齐到自动扩展</h4>
<p><code>ndarray</code> 广播遵循「后缘对齐」原则，当两个数组进行运算时，如果它们的维度数不同，<code>ndarray</code> 会在较小数组的前面补 1，使其维度数与较大数组相同。</p>
<p>例如，一个形状为 (5, 3) 的数组与一个形状为 (3,) 的数组进行广播时，形状为 (3,) 的数组会被视为 (1, 3)，然后再与 (5, 3) 进行对齐，最终广播为 (5, 3)。</p>
<p>在维度对齐后，单维度（长度为 1）的维度会自动复制扩展，以匹配另一个数组的维度。这种扩展是逻辑上的，无需显式的数据复制，因此效率非常高。</p>
<h4 data-id="heading-9">3.2 实战场景：环境常数广播与状态计算</h4>
<p>在具身智能的应用中，将环境常数广播到所有状态向量是一个常见的需求。</p>
<p>假设我们有一个机器人，它在不同的状态下需要考虑重力加速度的影响。重力加速度是一个常数，我们可以将其广播到机器人的所有状态向量上，从而在计算中考虑重力的作用。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// 定义重力加速度 (1,)</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">gravity</span> = array![<span class="hljs-number">9.81</span>]; 

    <span class="hljs-comment">// 假设机器人有三个状态，每个状态包含位置和速度信息 (3, 2, 2)</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">states</span> = array![
        [[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>]],
        [[<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>], [<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>]],
        [[<span class="hljs-number">4.0</span>, <span class="hljs-number">4.0</span>], [<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>]]
    ]; 

    <span class="hljs-comment">// 将重力加速度广播到所有状态向量上</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">new_states</span> = states + gravity; 
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"New states:\n {:?}"</span>, new_states); 
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">New states:
 [[[9.81, 9.81],
  [10.81, 10.81]],

 [[11.81, 11.81],
  [12.81, 12.81]],

 [[13.81, 13.81],
  [14.81, 14.81]]], shape=[3, 2, 2], strides=[4, 2, 1], layout=Cc (0x5), const ndim=3
</code></pre>
<p>在这个例子中，<code>gravity</code>是一个形状为 (1,) 的数组，<code>states</code>是一个形状为 (3, 2, 2) 的数组。通过广播机制，<code>gravity</code>会自动扩展为 (3, 2, 2) 的形状，与<code>states</code>进行匹配，然后进行元素级加法运算。</p>
<h3 data-id="heading-10">四、连接与堆叠：灵活组合多维数据</h3>
<p>在处理多维数据时，我们常常需要将多个数组合并成一个更大的数组，或者将一个数组分割成多个小数组。ndarray 提供了<code>stack</code>和<code>concatenate</code>函数来满足这些需求，它们在具身智能中也有着广泛的应用，比如在批量生成控制信号时，就需要将多个控制信号数组合并成一个大的数组。</p>
<h4 data-id="heading-11">4.1 concatenate：沿现有轴连接数组</h4>
<p><code>concatenate</code>函数是沿指定轴连接数组，它允许输入数组在其他轴上的形状一致，只有连接轴上的长度可以不同。这使得<code>concatenate</code>在合并具有不同长度但相同结构的数据时非常灵活。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;
<span class="hljs-keyword">use</span> ndarray::Axis;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b</span> = array![[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];

    <span class="hljs-comment">// 沿轴0连接数组</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">c</span> = ndarray::<span class="hljs-title function_ invoke__">concatenate</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">0</span>), &amp;[a.<span class="hljs-title function_ invoke__">view</span>(), b.<span class="hljs-title function_ invoke__">view</span>()]).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"concatenate axis0:\n {:?}"</span>, c);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">d</span> = array![[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]];
    <span class="hljs-comment">// 沿轴1连接数组</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">e</span> = ndarray::<span class="hljs-title function_ invoke__">concatenate</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>), &amp;[a.<span class="hljs-title function_ invoke__">view</span>(), d.<span class="hljs-title function_ invoke__">view</span>()]).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"concatenate axis1:\n {:?}"</span>, e);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">concatenate axis0:
 [[1, 2],
 [3, 4],
 [5, 6]], shape=[3, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2
concatenate axis1:
 [[1, 2, 7, 8],
 [3, 4, 9, 10]], shape=[2, 4], strides=[1, 2], layout=Ff (0xa), const ndim=2
</code></pre>
<p>在实际应用中，当我们需要将不同时间段的传感器数据连接起来时，<code>concatenate</code>就派上用场了。</p>
<p>比如，一个机器人在不同时间段采集到的位置数据，我们可以使用<code>concatenate</code>将这些数据按时间顺序连接起来，以便分析机器人的运动轨迹。</p>
<h4 data-id="heading-12">4.2 stack：新增维度堆叠数组</h4>
<p><code>stack</code>函数用于在指定轴上堆叠数组，生成一个更高维度的新数组。它要求所有输入数组的形状必须一致，否则会导致错误。通过<code>stack</code>，我们可以轻松地将多个相同形状的数组合并成一个更高维度的数组，这在处理多个样本的相同特征数据时非常有用。</p>
<p>堆叠 (stack) 在概念上，完全等同于以下两步操作：</p>
<ul>
<li>
<p>“Reshape” (增加维度): 先把你要堆叠的每一个数组，在你指定的 Axis 位置上，增加一个大小为 1 的新维度。</p>
</li>
<li>
<p>“Concatenate” (拼接): 然后，沿着那个刚刚新增的 Axis，把这些“升维”后的数组拼接起来。</p>
</li>
</ul>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b</span> = array![<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];

    <span class="hljs-comment">// 在新轴（轴0）上堆叠数组</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">c</span> = ndarray::<span class="hljs-title function_ invoke__">stack</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">0</span>), &amp;[a.<span class="hljs-title function_ invoke__">view</span>(), b.<span class="hljs-title function_ invoke__">view</span>()]).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"stack axis0:\n {:?}"</span>, c);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a_2d</span> = a.<span class="hljs-title function_ invoke__">insert_axis</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// (3,1)</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b_2d</span> = b.<span class="hljs-title function_ invoke__">insert_axis</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// (3,1)</span>
    <span class="hljs-comment">// 在轴1上堆叠数组, 先升维 （3，1）-&gt; (3, 1, 1), 然后在轴1上拼接</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">d</span> = ndarray::<span class="hljs-title function_ invoke__">stack</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>), &amp;[a_2d.<span class="hljs-title function_ invoke__">view</span>(), b_2d.<span class="hljs-title function_ invoke__">view</span>()]).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"stack axis1:\n {:?}"</span>, d);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">stack axis0:
 [[1, 2, 3],
 [4, 5, 6]], shape=[2, 3], strides=[3, 1], layout=Cc (0x5), const ndim=2
stack axis1:
 [[[1],
  [4]],

 [[2],
  [5]],

 [[3],
  [6]]], shape=[3, 2, 1], strides=[1, 3, 1], layout=Ff (0xa), const ndim=3
</code></pre>
<h3 data-id="heading-13">五、聚合与沿轴操作：数据降维与统计</h3>
<p>在数据分析和科学计算中，聚合操作是对数据进行总结和概括的重要手段。<code>ndarray</code> 提供了丰富的聚合函数，如<code>sum</code>、<code>mean</code>等，这些函数可以快速计算数组的总和、平均值等统计量。</p>
<p>同时，通过指定轴参数，我们还可以沿特定的维度进行聚合操作，实现数据的降维与分析。</p>
<h4 data-id="heading-14">5.1 基础聚合：sum、mean 快速统计</h4>
<p><code>sum</code>和<code>mean</code>是最常用的聚合函数之一，它们可以直接对数组进行操作，返回一个标量结果，表示整个数组的总和或平均值。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

    <span class="hljs-comment">// 计算数组的总和</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">sum</span> = a.<span class="hljs-title function_ invoke__">sum</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"sum:\n {:?}"</span>, sum);

    <span class="hljs-comment">// 计算数组的平均值</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">mean</span> = a.<span class="hljs-title function_ invoke__">mean</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"mean:\n {:?}"</span>, mean); 
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">sum:
 15
mean:
 3.0
</code></pre>
<h4 data-id="heading-15">5.2 沿轴计算：按维度聚合数据</h4>
<p>通过<code>axis</code>参数，我们可以指定聚合操作沿哪个轴进行，从而实现按维度聚合数据。在处理多维数据时非常有用，可以快速获取不同维度上的统计信息。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;
<span class="hljs-keyword">use</span> ndarray::Axis;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">matrix</span> = array![[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];

    <span class="hljs-comment">// 计算每列的总和（轴0）</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">column_sums</span> = matrix.<span class="hljs-title function_ invoke__">sum_axis</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">0</span>));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"column_sums:\n {:?}"</span>, column_sums);

    <span class="hljs-comment">// 计算每行的平均值（轴1）</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">row_means</span> = matrix.<span class="hljs-title function_ invoke__">mean_axis</span>(<span class="hljs-title function_ invoke__">Axis</span>(<span class="hljs-number">1</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"row_means:\n {:?}"</span>, row_means);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">column_sums:
 [5, 7, 9], shape=[3], strides=[1], layout=CFcf (0xf), const ndim=1
row_means:
 [2, 5], shape=[2], strides=[1], layout=CFcf (0xf), const ndim=1
</code></pre>
<h3 data-id="heading-16">六、矩阵代数：ndarray-linalg 与线性代数基础</h3>
<p>在人工智能的算法实现中，矩阵代数是不可或缺的一部分。<code>ndarray</code> 库本身提供了基本的矩阵乘法操作，而 <code>ndarray-linalg</code> 库则进一步扩展了其线性代数功能，为解决复杂的数学问题提供了强大的工具。</p>
<h4 data-id="heading-17">6.1 矩阵乘法：.dot () 与维度匹配</h4>
<p>在 <code>ndarray</code> 中，使用<code>.dot()</code>方法执行矩阵乘法，它严格遵循线性代数中的维度规则。对于两个矩阵<code>A</code>和<code>B</code>，只有当<code>A</code>的列数等于<code>B</code>的行数时，矩阵乘法<code>A.dot(B)</code>才是有效的。</p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">a</span> = array![[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">b</span> = array![[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]];

    <span class="hljs-comment">// 执行矩阵乘法</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">c</span> = a.<span class="hljs-title function_ invoke__">dot</span>(&amp;b);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"dot:\n {:?}"</span>, c);
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-shell" lang="shell">dot:
 [[19, 22],
 [43, 50]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2
</code></pre>
<h4 data-id="heading-18">6.2 ndarray-linalg 扩展：特征值、矩阵分解</h4>
<p><code>ndarray-linalg</code>库为 <code>ndarray</code> 提供了丰富的线性代数扩展，包括矩阵求逆、奇异值分解（SVD）、特征值计算等高级操作。</p>
<p>这些功能在人工智能中对于解决复杂的优化和估计问题非常关键。</p>
<p>Cargo.toml 配置：</p>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">ndarray</span> = { version = <span class="hljs-string">"0.17.1"</span> }
<span class="hljs-attr">ndarray-linalg</span> = <span class="hljs-string">"0.18.0"</span>
</code></pre>
<p>需要额外安装 <code>openblas</code>，地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOpenMathLib%2FOpenBLAS" target="_blank" title="https://github.com/OpenMathLib/OpenBLAS" ref="nofollow noopener noreferrer">github.com/OpenMathLib…</a></p>
<pre><code class="hljs language-rust" lang="rust">
<span class="hljs-keyword">use</span> ndarray::array;
<span class="hljs-keyword">use</span> ndarray_linalg::Inverse;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">matrix</span> = array![
        [<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>],
        [<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>]
    ];

    <span class="hljs-comment">// 求矩阵的逆</span>
    <span class="hljs-keyword">match</span> matrix.<span class="hljs-title function_ invoke__">inv</span>() {
        <span class="hljs-title function_ invoke__">Ok</span>(inverse) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Inverse matrix: {:?}"</span>, inverse); 
        }
        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Error: {}"</span>, e); 
        }
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="hljs language-shell" lang="shell">Inverse matrix:
 [[-2.0, 1.0],
 [1.5, -0.5]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2
</code></pre>
<h3 data-id="heading-19">总结：ndarray 助力智能系统高效计算</h3>
<p>Rust ndarray 凭借元素级操作的简洁性、广播机制的智能维度适配、线性代数的高效支持，成为AI与具身智能开发的得力工具。</p>
<p>无论是传感器数据的实时处理，还是复杂算法的矩阵运算，<code>ndarray</code> 都能在保证内存安全的同时，提供接近原生的性能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter3.38 带来了什么]]></title>    <link>https://juejin.cn/post/7572301616167436297</link>    <guid>https://juejin.cn/post/7572301616167436297</guid>    <pubDate>2025-11-14T00:58:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572301616167436297" data-draft-id="7572012699626815515" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter3.38 带来了什么"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-14T00:58:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JarvanMo"/> <meta itemprop="url" content="https://juejin.cn/user/2348212565845704"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter3.38 带来了什么
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2348212565845704/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JarvanMo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T00:58:42.000Z" title="Fri Nov 14 2025 00:58:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Flutter 3.38 最近发布了，带来了很多新功能和改进。这次发布包含了来自 <strong>145 位</strong> 独立贡献者的 <strong>825 次</strong> 总提交，其中有 <strong>37 位</strong> 是首次贡献者。让我们深入了解一下这次发布的内容。</p>
<h2 data-id="heading-0">Dot shorthands</h2>
<p>在 Dart 3.10 + Flutter 3.38 中开始默认支持 Dot shorthands ，通过 Dot shorthands 可以使可以通过允许您省略 Dart 能够推断出来的类型，从而减少样板代码，例如使用 .start 而不是 MainAxisAlignment.start ：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// With shorthands</span>
Column(
  mainAxisAlignment: .start,
  crossAxisAlignment: .center,
  children: [ <span class="hljs-comment">/* ... */</span> ],
),

<span class="hljs-comment">// Without shorthands</span>
Column(
  mainAxisAlignment: MainAxisAlignment.start,
  crossAxisAlignment: CrossAxisAlignment.center,
  children: [ <span class="hljs-comment">/* … */</span> ],
),
</code></pre>
<p>这对于<strong>命名构造函数</strong>也同样适用，如<code>.all</code>而不是<code>EdgeInsets.all</code>：</p>
<pre><code class="hljs language-dart" lang="dart">Padding(
  padding: .all(<span class="hljs-number">8.0</span>),
  child: Text(<span class="hljs-string">'Hello world'</span>),
),
</code></pre>
<h2 data-id="heading-1">💻 Web 开发配置与功能增强</h2>
<hr/>
<h3 data-id="heading-2">Web 开发配置文件</h3>
<p><code>flutter run</code> 命令现在支持一个用于 <strong>Web 设置的配置文件</strong>。您可以在项目根目录下的 <code>web_dev_config.yaml</code> 文件中指定 <strong>主机 (host)、端口 (port)、证书 (certificate)</strong> 和 <strong>请求头信息 (header)</strong>。将此文件提交到版本控制，确保团队中的所有成员都使用相同的设置进行调试。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">"0.0.0.0"</span> <span class="hljs-comment"># Defines the binding address &lt;string&gt;</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># Specifies the port &lt;int&gt; for the development server</span>
  <span class="hljs-attr">https:</span>
    <span class="hljs-attr">cert-path:</span> <span class="hljs-string">"/path/to/cert.pem"</span> <span class="hljs-comment"># Path &lt;string&gt; to your TLS certificate</span>
    <span class="hljs-attr">cert-key-path:</span> <span class="hljs-string">"/path/to/key.pem"</span> <span class="hljs-comment"># Path &lt;string&gt; to TLS certificate key</span>
</code></pre>
<ul>
<li>更多信息，请参阅<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Fplatform-integration%2Fweb%2Fweb-dev-config-file" target="_blank" title="https://docs.flutter.dev/platform-integration/web/web-dev-config-file" ref="nofollow noopener noreferrer">设置 Web 开发配置文件</a>。</li>
</ul>
<h3 data-id="heading-3">Web 开发代理设置</h3>
<p>除了现有的命令行标志外，Web 开发配置文件现在还支持新的<strong>代理设置 (proxy settings)</strong>。</p>
<ul>
<li>代理设置允许将特定路径的请求转发到另一个服务器。这使得开发连接到同一主机上动态端点的 Web 客户端更加容易。</li>
</ul>
<pre><code class="hljs language-dart" lang="dart">server:
  proxy:
    - target: <span class="hljs-string">"http://localhost:5000/"</span> # Base URL &lt;string&gt; of your backend
      prefix: <span class="hljs-string">"/users/"</span> # Path &lt;string&gt;
    - target: <span class="hljs-string">"http://localhost:3000/"</span>
      prefix: <span class="hljs-string">"/data/"</span>
      replace: <span class="hljs-string">"/report/"</span> # Replacement &lt;string&gt; of path <span class="hljs-keyword">in</span> redirected URL (optional)
    - target: <span class="hljs-string">"http://localhost:4000/"</span>
      prefix: <span class="hljs-string">"/products/"</span>
      replace: <span class="hljs-string">""</span>
</code></pre>
<ul>
<li>有关代理设置的详细信息，也请参阅<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Fplatform-integration%2Fweb%2Fweb-dev-config-file" target="_blank" title="https://docs.flutter.dev/platform-integration/web/web-dev-config-file" ref="nofollow noopener noreferrer">设置 Web 开发配置文件</a>。</li>
</ul>
<h3 data-id="heading-4">Web 上的热重载扩展支持</h3>
<ul>
<li>当使用 <code>-d web-server</code> 运行并在浏览器中打开 Flutter 应用链接时，<strong>有状态热重载 (Stateful hot reload)</strong> 现在<strong>默认启用</strong>。这甚至可以同时连接多个浏览器。</li>
<li>与 <code>-d chrome</code> 一样，此功能可以使用 <code>--no-web-experimental-hot-reload</code> 标志临时禁用。但此禁用功能将在未来版本中移除，因此，如果您在开发工作流程中遇到问题，请使用 Dart 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdart-lang%2Fsdk%2Fissues%2Fnew%3Ftemplate%3D5_web_hot_reload.yml" target="_blank" title="https://github.com/dart-lang/sdk/issues/new?template=5_web_hot_reload.yml" ref="nofollow noopener noreferrer">web 热重载问题模板</a> 提交 Bug。</li>
<li>更多信息，请参阅<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Fplatform-integration%2Fweb%2Fbuilding%23hot-reload-web" target="_blank" title="https://docs.flutter.dev/platform-integration/web/building#hot-reload-web" ref="nofollow noopener noreferrer">Web 上的热重载文档</a>。</li>
</ul>
<hr/>
<h2 data-id="heading-5">🏗️ Framework更新</h2>
<p>本次发布包含了Framework中的许多强大的新功能和改进，使开发者能够对高级 UI、导航和平台交互有更精细的控制。</p>
<h3 data-id="heading-6">强大的 UI 浮层控制</h3>
<p>开发者在使用 <strong><code>OverlayPortal</code></strong> 创建弹出窗口、对话框和其他浮动 UI 元素时，现在拥有更大的能力。</p>
<ul>
<li>通过 <code>OverlayPortal.overlayChildLayoutBuilder</code> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174239" target="_blank" title="https://github.com/flutter/flutter/pull/174239" ref="nofollow noopener noreferrer">#174239</a>)，现在可以在 Widget 树中任何向上的 <strong><code>Overlay</code></strong> 中渲染子 Widget，这使得显示应用范围的通知或需要跳出其父 Widget 布局限制的 UI 变得更容易。这可以更灵活地显示弹出、对话框、通知等 UI ，例如：</li>
</ul>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_OverlayPortalExampleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">OverlayPortalExample</span>&gt; </span>{
  <span class="hljs-keyword">final</span> OverlayPortalController _controller = OverlayPortalController();
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(<span class="hljs-string">'OverlayPortal'</span>)),
      body: Center(
        child: OverlayPortal.overlayChildLayoutBuilder(
          controller: _controller,
          <span class="hljs-comment">/// <span class="markdown"><span class="hljs-strong">****</span>可以配置 root<span class="hljs-strong">****</span></span></span>
          overlayLocation: OverlayChildLocation.rootOverlay,
          child: ElevatedButton(
            onPressed: () =&gt; _controller.toggle(),
            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'点我显示浮层'</span>),
          ),
          overlayChildBuilder: (context, info) {
            <span class="hljs-keyword">return</span> Material(
              elevation: <span class="hljs-number">6</span>,
              color: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(<span class="hljs-number">8</span>),
              ),
              child: Container(
                padding: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">16</span>),
                child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'这是一个浮层'</span>),
              ),
            );
          },
        ),
      ),
    );
  }
}
</code></pre>
<ul>
<li>底层方法 <code>Overlay.of</code> 也得到了增强，使其更加健壮和高效 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174315" target="_blank" title="https://github.com/flutter/flutter/pull/174315" ref="nofollow noopener noreferrer">#174315</a>)。</li>
</ul>
<h3 data-id="heading-7">现代化 Android 导航体验</h3>
<ul>
<li>为了提供更现代的 Android 导航体验，<strong>预测性返回手势路由过渡 (predictive back route transitions)</strong> 现在在 <strong><code>MaterialApp</code></strong> 中<strong>默认启用</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173860" target="_blank" title="https://github.com/flutter/flutter/pull/173860" ref="nofollow noopener noreferrer">#173860</a>)。当用户执行返回手势时，他们会看到主屏幕的预览，当前路由则随之动画移出。</li>
<li>此外，默认的页面过渡效果已从 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmain-api.flutter.dev%2Fflutter%2Fmaterial%2FFadeForwardsPageTransitionsBuilder-class.html" target="_blank" title="https://main-api.flutter.dev/flutter/material/FadeForwardsPageTransitionsBuilder-class.html" ref="nofollow noopener noreferrer">ZoomPageTransitionsBuilder</a> 更新为 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmain-api.flutter.dev%2Fflutter%2Fmaterial%2FZoomPageTransitionsBuilder-class.html" target="_blank" title="https://main-api.flutter.dev/flutter/material/ZoomPageTransitionsBuilder-class.html" ref="nofollow noopener noreferrer">FadeForwardsPageTransitionsBuilder</a>，以反映原生的行为。</li>
</ul>
<h3 data-id="heading-8">桌面集成深化</h3>
<ul>
<li>在 <strong>Windows</strong> 上，开发者现在可以访问已连接显示器的列表，并查询每个显示器的详细属性，例如<strong>分辨率、刷新率和物理尺寸</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F164460" target="_blank" title="https://github.com/flutter/flutter/pull/164460" ref="nofollow noopener noreferrer">#164460</a>)。这使得创建具有复杂窗口管理功能的应用程序成为可能。</li>
</ul>
<h3 data-id="heading-9">框架稳定性与 Web UI 优化</h3>
<ul>
<li>框架本身现在更具弹性。Widget 生命周期回调（例如 <code>didUpdateWidget</code>）中发生的错误现在得到更优雅的处理，防止它们在元素树中引发连锁故障 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173148" target="_blank" title="https://github.com/flutter/flutter/pull/173148" ref="nofollow noopener noreferrer">#173148</a>)。</li>
<li><strong><code>ResizeImage</code></strong> 现在正确地实现了相等性 (equality)，确保相同的 <code>ResizeImage</code> 提供者被视为相同，从而使图像缓存和比较更具可预测性 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F172643" target="_blank" title="https://github.com/flutter/flutter/pull/172643" ref="nofollow noopener noreferrer">#172643</a>)。</li>
<li>在 Web 上，UI 优化仍在继续：<strong><code>RSuperellipse</code></strong> 的一个 Bug 已修复，防止角半径大于 Widget 本身时出现渲染错误；在这种情况下，它将按预期被处理以生成<strong>药丸形状 (pill shape)</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F172254" target="_blank" title="https://github.com/flutter/flutter/pull/172254" ref="nofollow noopener noreferrer">#172254</a>)。</li>
</ul>
<h3 data-id="heading-10">国际化支持增强</h3>
<ul>
<li>检测浏览器首选区域设置 (locale) 的功能现在更可靠。引擎现在使用标准的 <strong><code>Intl.Locale</code> Web API</strong> 来解析浏览器语言，取代了先前手动且更脆弱的实现 (#172964)。这一变化为全球用户带来了更可靠的区域设置检测和更好的体验。</li>
</ul>
<h3 data-id="heading-11">Android 特定 Bug 修复</h3>
<ul>
<li>一个主要影响带有硬件键盘的 <strong>Samsung 设备</strong>的 Android 特定 Bug (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F171973" target="_blank" title="https://github.com/flutter/flutter/pull/171973" ref="nofollow noopener noreferrer">#171973</a>) 已解决。
<ul>
<li>此前，用户与 <code>TextField</code> 交互后，Android 输入法编辑器 (IME) 可能会陷入陈旧状态。这导致 IME 错误地拦截 “Enter” 或 “Space” 键，阻止非文本 Widget（如 <code>Checkbox</code> 或 <code>Radio</code> 按钮）接收事件。</li>
<li>修复确保在文本连接关闭时，<strong><code>InputMethodManager</code></strong> 正确重置，清除 IME 的陈旧状态，并恢复用户可预测的硬件键盘交互。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-12">🎨 Material 和 Cupertino 更新</h2>
<p>Material 和 Cupertino 库持续发展，侧重于 API 一致性和优化的用户体验。本次发布带来了重大的 API 迁移、新的 Widget 功能和众多改进，使构建美观、实用的 UI 更加简单。</p>
<h3 data-id="heading-13"><code>WidgetState</code> 迁移</h3>
<ul>
<li>在弃用 <code>MaterialState</code> 的基础上，本次发布继续向更统一的 <strong><code>WidgetState</code></strong> 进行内部迁移。</li>
<li>这提供了一种一致、富有表现力的方式来定义 Widget 在不同交互状态（例如：按下、悬停或禁用）下的外观，对现有应用程序<strong>无需更改</strong>。</li>
<li>此迁移已应用于各种 Widget 及其主题，包括 <code>IconButton</code>、<code>ElevatedButton</code>、<code>Checkbox</code> 和 <code>Switch</code> (#173893)。</li>
<li>新的 API 还增加了功能和灵活性；例如，<code>IconButton</code> 现在包含一个 <strong><code>statesController</code></strong> 属性 (#169821)，允许通过编程方式控制其视觉状态，为更自定义和交互式的设计打开了大门。</li>
</ul>
<h3 data-id="heading-14">新功能和便捷 API</h3>
<ul>
<li><strong><code>Badge.count</code></strong> 构造函数现在包含一个 <strong><code>maxCount</code></strong> 参数 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F171054" target="_blank" title="https://github.com/flutter/flutter/pull/171054" ref="nofollow noopener noreferrer">#171054</a>)，可以轻松限制显示计数（例如，显示 “99+” 而不是 “100”）。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28bf755e0f414bdf9f11612cfc115acf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=ufG%2FNaMxdlCl%2BLYsnjl5uA85IDs%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-15">👆 手势控制与平台优化</h2>
<hr/>
<h3 data-id="heading-16">Material 和 Cupertino 组件改进</h3>
<ul>
<li>为了更精细的<strong>手势控制</strong>，<code>InkWell</code> Widget 现在新增了一个 <strong><code>onLongPressUp</code></strong> 回调 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173221" target="_blank" title="https://github.com/flutter/flutter/pull/173221" ref="nofollow noopener noreferrer">#173221</a>)，这对于触发仅在用户抬起手指时才完成的动作非常有用。</li>
<li><strong>Cupertino 库</strong>继续致力于提高 iOS 的保真度：
<ul>
<li><code>CupertinoSlidingSegmentedControl</code> 增加了一个 <strong><code>isMomentary</code></strong> 属性 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F164262" target="_blank" title="https://github.com/flutter/flutter/pull/164262" ref="nofollow noopener noreferrer">#164262</a>)，允许控件触发动作而无需持久保持选择状态。</li>
<li>为了更好地匹配原生 iOS 行为，<code>CupertinoSheet</code> 在完全展开时向上拖动时，现在具有一个微妙的 <strong>“拉伸”效果 (subtle “stretch” effect)</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F168547" target="_blank" title="https://github.com/flutter/flutter/pull/168547" ref="nofollow noopener noreferrer">#168547</a>)。</li>
</ul>
</li>
<li>核心组件的行为也得到了完善：
<ul>
<li>修复了 <code>DropdownMenuFormField</code>，使其在表单重置时能正确清空其文本字段 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174937" target="_blank" title="https://github.com/flutter/flutter/pull/174937" ref="nofollow noopener noreferrer">#174937</a>)。</li>
<li>对 <code>SegmentedButton</code> 进行了更新，以改进焦点处理 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173953" target="_blank" title="https://github.com/flutter/flutter/pull/173953" ref="nofollow noopener noreferrer">#173953</a>) 并确保其边框正确反映 Widget 的状态 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F172754" target="_blank" title="https://github.com/flutter/flutter/pull/172754" ref="nofollow noopener noreferrer">#172754</a>)。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-17">🔗 Material 与 Cupertino 解耦（Decoupling）规划</h2>
<p>我们一直在规划将 <strong>Material 和 Cupertino 库从框架中解耦</strong>。以下是关于最近发布的设计文档的一些讨论：</p>






























<table><thead><tr><th align="left">主题</th><th align="left">状态</th><th align="left">详情</th></tr></thead><tbody><tr><td align="left">改进 <code>flutter/packages</code> 的发布流程 (包含解耦后的 Material 和 Cupertino)</td><td align="left"><strong>已决定</strong></td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fu%2F1%2Fd%2F18kjoP-4LAXEllugVOQRg6vZELyD6MuxlKilLD4lFxSY%2Fedit" target="_blank" title="https://docs.google.com/document/u/1/d/18kjoP-4LAXEllugVOQRg6vZELyD6MuxlKilLD4lFxSY/edit" ref="nofollow noopener noreferrer">First-Party Package Release Strategy</a> <br/> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1jUoFaawutbYsCI5oY3pDP_l-xpv6FhDKlcI1-EoT02s%2Fedit%3Ftab%3Dt.0" target="_blank" title="https://docs.google.com/document/d/1jUoFaawutbYsCI5oY3pDP_l-xpv6FhDKlcI1-EoT02s/edit?tab=t.0" ref="nofollow noopener noreferrer">Batch Release One Pager (PUBLICLY SHARED)</a></td></tr><tr><td align="left">颜色和点速记 (<code>Colors</code> and dot shorthands)</td><td align="left"><strong>已决定</strong></td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1y38TN9AUTyd0eTbu4kx4FiNgfsLDPvWvi92Fv5HWFjQ%2Fedit%3Ftab%3Dt.0%23heading%3Dh.pub7jnop54q0" target="_blank" title="https://docs.google.com/document/d/1y38TN9AUTyd0eTbu4kx4FiNgfsLDPvWvi92Fv5HWFjQ/edit?tab=t.0#heading=h.pub7jnop54q0" ref="nofollow noopener noreferrer">A Basic Color Set for Flutter (PUBLICLY SHARED)</a></td></tr><tr><td align="left">解耦测试 (Decoupling tests)</td><td align="left"><strong>进行中</strong></td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1UHxALQqCbmgjnM1RNV9xE2pK3IGyx-UktGX1D7hYCjs%2Fedit%3Ftab%3Dt.0" target="_blank" title="https://docs.google.com/document/d/1UHxALQqCbmgjnM1RNV9xE2pK3IGyx-UktGX1D7hYCjs/edit?tab=t.0" ref="nofollow noopener noreferrer">Decoupling Framework Tests (PUBLICLY SHARED)</a> <br/> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F177028" target="_blank" title="https://github.com/flutter/flutter/issues/177028" ref="nofollow noopener noreferrer">Issue #177028</a></td></tr><tr><td align="left">文本 (Text)</td><td align="left"><strong>讨论中</strong></td><td align="left"><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1X50eQ-T-XW4B8-P1V21fJ0z2N_8s-gE8T_t7Q4tQ5y4%2Fedit" target="_blank" title="https://docs.google.com/document/d/1X50eQ-T-XW4B8-P1V21fJ0z2N_8s-gE8T_t7Q4tQ5y4/edit" ref="nofollow noopener noreferrer">Flutter Decoupling Design From Text (PUBLICLY SHARED)</a></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-18">📜 滚动 (Scrolling): 更健壮和可预测的 Slivers</h2>
<p>本次发布带来了多项修复，使得构建复杂的滚动布局（尤其是使用 <strong><code>SliverMainAxisGroup</code></strong> 和 <strong><code>SliverCrossAxisGroup</code></strong> 的布局）更加<strong>健壮和可预测</strong>。</p>
<ul>
<li>开发者在使用这些 Widget 对多个 Slivers 进行分组时，会发现<strong>手势处理现在更可靠</strong>。对这些组内 Slivers 上的点击和其他指针事件的命中测试现在计算正确，确保用户交互按预期进行 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174265" target="_blank" title="https://github.com/flutter/flutter/pull/174265" ref="nofollow noopener noreferrer">#174265</a>)。</li>
<li>其他几项修复有助于 <strong><code>SliverMainAxisGroup</code></strong> 内更精确的滚动行为：
<ul>
<li>解决了使用固定头部 (pinned header) 时的<strong>过度滚动问题</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173349" target="_blank" title="https://github.com/flutter/flutter/pull/173349" ref="nofollow noopener noreferrer">#173349</a>)。</li>
<li>调用 <strong><code>showOnScreen</code></strong> 以显示一个 Sliver 现在可以正常工作 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F171339" target="_blank" title="https://github.com/flutter/flutter/pull/171339" ref="nofollow noopener noreferrer">#171339</a>)。</li>
<li>内部滚动偏移量的计算更精确 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174369" target="_blank" title="https://github.com/flutter/flutter/pull/174369" ref="nofollow noopener noreferrer">#174369</a>)。</li>
</ul>
</li>
<li>对于构建自定义滚动视图的开发者，新的 <strong><code>SliverGrid.list</code></strong> 构造函数 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173925" target="_blank" title="https://github.com/flutter/flutter/pull/173925" ref="nofollow noopener noreferrer">#173925</a>) 提供了一种从简单子 Widget 列表创建网格的更清晰方法。</li>
<li>本次发布还改进了复杂布局中键盘和 D-pad 用户的<strong>焦点导航</strong>。在具有不同滚动轴的嵌套滚动视图中（例如垂直列表中的水平轮播图），定向焦点导航现在更可预测，防止焦点意外地在不同部分之间跳转 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F172875" target="_blank" title="https://github.com/flutter/flutter/pull/172875" ref="nofollow noopener noreferrer">#172875</a>)。</li>
</ul>
<hr/>
<h2 data-id="heading-19">♿ Accessibility: 为所有用户提供更包容的体验</h2>
<p>使应用程序对所有用户都可访问是 Flutter 框架的基石。本次发布通过提供更多的<strong>编程控制</strong>、<strong>改善国际用户的体验</strong>以及<strong>优化核心 Widget 的辅助功能</strong>，继续履行这一承诺。</p>
<ul>
<li>对于构建复杂应用的开发者，本次发布引入了通过使用 <strong><code>WidgetsFlutterBinding.instance.ensureSemantics</code></strong> 来<strong>在 iOS 上默认开启辅助功能</strong>的能力 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174163" target="_blank" title="https://github.com/flutter/flutter/pull/174163" ref="nofollow noopener noreferrer">#174163</a>)。</li>
<li>调试辅助功能问题现在更容易了，因为 <strong><code>debugDumpSemanticsTree</code></strong> 包含了额外的<strong>文本输入验证结果信息</strong>，有助于更快地诊断问题 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174677" target="_blank" title="https://github.com/flutter/flutter/pull/174677" ref="nofollow noopener noreferrer">#174677</a>)。</li>
<li>对于基于 Sliver 的滚动视图中的高级辅助功能，现在可以使用新的 <strong><code>SliverSemantics</code></strong> Widget (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F167300" target="_blank" title="https://github.com/flutter/flutter/pull/167300" ref="nofollow noopener noreferrer">#167300</a>)。
<ul>
<li>就像现有的 <code>Semantics</code> Widget 一样，开发者可以在 <code>CustomScrollView</code> 中使用 <code>SliverSemantics</code> 来用特定的语义信息<strong>注解 (annotate)</strong> Sliver 树的一部分。</li>
<li>这对于为屏幕阅读器注解头部、分配语义角色和添加描述性标签特别有用，为用户提供更易理解和可访问的体验。</li>
</ul>
</li>
<li>核心 Widget 的辅助功能也在继续完善：
<ul>
<li><strong><code>CupertinoExpansionTile</code></strong> 现在<strong>默认可访问</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F174480" target="_blank" title="https://github.com/flutter/flutter/pull/174480" ref="nofollow noopener noreferrer">#174480</a>)。</li>
<li><strong><code>AutoComplete</code></strong> Widget 现在会向用户<strong>宣布搜索结果的状态</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F173480" target="_blank" title="https://github.com/flutter/flutter/pull/173480" ref="nofollow noopener noreferrer">#173480</a>)。</li>
<li>其他改进，例如 <strong><code>TimePicker</code></strong> 中更大的触摸目标 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F170060" target="_blank" title="https://github.com/flutter/flutter/pull/170060" ref="nofollow noopener noreferrer">#170060</a>)，有助于提供更易于访问的开箱即用体验。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-20">🍏 iOS 平台支持与迁移</h2>
<h3 data-id="heading-21">平台支持</h3>
<p>我们很高兴地确认 Flutter <strong>完全支持最新的平台版本</strong>：<strong>iOS 26、Xcode 26 和 macOS 26</strong>（均于 9 月发布）。这确保您可以立即在 Apple 最新的操作系统和工具链上开始开发和测试您的应用。</p>
<h3 data-id="heading-22">部署流程改进</h3>
<p>您可能已经注意到，Flutter 在上一个版本中为 iOS 开发者带来了重大的<strong>生活质量改进 (quality-of-life improvement)</strong>，解决了长期困扰用户的一个问题：使用 <code>flutter run</code> 在真机上运行 Flutter 应用时，要求 Xcode 应用程序<strong>自动启动</strong>。</p>
<ul>
<li>我们引入了一种新的部署方法，使用 <strong>Xcode 26 命令行工具 <code>devicectl</code></strong> 进行应用程序安装、启动和调试。</li>
<li>这一转变<strong>消除了在部署过程中调用 Xcode 应用程序的需要</strong>，在大多数情况下仅依赖于命令行 Xcode 构建工具。</li>
<li>此前，此功能依赖于 Xcode 自动化，但在 Xcode 26 上变得不稳定和不可靠，尤其是在连续执行命令时。如果您现在正在为最新的 Apple 版本进行开发，我们<strong>强烈建议</strong>您将 Flutter 更新到 <strong>3.38 或更高版本</strong>。</li>
<li>如果您遇到问题，可以使用 <code>flutter config --no-enable-lldb-debugging</code> 禁用此部署方法，并<strong>提交问题</strong>让我们知道！</li>
</ul>
<h3 data-id="heading-23"><code>UIScene</code> 生命周期迁移</h3>
<p>Flutter 3.38 包含了对 Apple 强制要求的 <strong><code>UIScene</code> 生命周期</strong>的关键支持。</p>
<ul>
<li>这是继 Apple 在 WWDC25 上宣布**“在 iOS 26 之后的版本中，任何使用最新 SDK 构建的 UIKit 应用都将被要求使用 <code>UIScene</code> 生命周期，否则将无法启动”**之后，一项关键的、<strong>前瞻性的更新</strong>。</li>
<li>为了确保您的 iOS Flutter 应用程序在未来的 iOS 版本上保持兼容并成功启动，<strong>需要进行迁移</strong>。</li>
</ul>
<h3 data-id="heading-24">📱 迁移 Flutter 应用</h3>
<p>所有现有的 iOS Flutter 应用都必须迁移到新的生命周期。您有两种途径完成此迁移：</p>
<ol>
<li><strong>手动迁移：</strong> 遵循 Flutter 网站上提供的<strong>手动迁移说明</strong>。</li>
<li><strong>自动迁移（实验性）：</strong> 启用一个实验性功能来自动处理迁移。此功能将在未来版本中默认启用。运行以下命令：
flutter config --enable-ios-scene-lifecycle-migration</li>
</ol>
<h3 data-id="heading-25">迁移 Flutter 插件</h3>
<p>依赖于<strong>应用生命周期事件</strong>的 Flutter 插件<strong>必须</strong>更新以使用 <code>UIScene</code> 生命周期事件。插件开发者应参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Frelease%2Fbreaking-changes%2Fuiscenedelegate%23migration-guide-for-flutter-plugins" target="_blank" title="https://docs.flutter.dev/release/breaking-changes/uiscenedelegate#migration-guide-for-flutter-plugins" ref="nofollow noopener noreferrer">迁移指南</a>。尚未迁移的插件将在未来版本中显示警告。</p>
<h3 data-id="heading-26">迁移嵌入式 Flutter (可选)</h3>
<p>对于将 Flutter 嵌入到原生宿主应用程序的项目，迁移是<strong>可选但强烈推荐</strong>的。采用 Flutter 新的 <code>UIScene</code> API（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Frelease%2Fbreaking-changes%2Fuiscenedelegate%23migration-guide-for-adding-flutter-to-existing-app-add-to-app" target="_blank" title="https://docs.flutter.dev/release/breaking-changes/uiscenedelegate#migration-guide-for-adding-flutter-to-existing-app-add-to-app" ref="nofollow noopener noreferrer">使用添加到应用迁移指南</a>）可为您的插件启用场景生命周期事件，确保与 Flutter 生态系统的兼容性。</p>
<hr/>
<h2 data-id="heading-27">🤖 Android 平台更新</h2>
<hr/>
<h3 data-id="heading-28">16KB 页面大小兼容性</h3>
<p>升级到 Flutter 3.38 是为 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fguide%2Fpractices%2Fpage-sizes" target="_blank" title="https://developer.android.com/guide/practices/page-sizes" ref="nofollow noopener noreferrer">Google Play 16 KB 页面大小兼容性要求</a>做准备的关键步骤。</p>
<ul>
<li>从 <strong>2025 年 11 月 1 日</strong>起，面向 Android 15 及更高版本的应用必须支持 16 KB 页面。</li>
<li>这一变化确保您的应用在高内存设备上正确运行，并提供高达 <strong>30% 更快的启动速度</strong>等性能优势。</li>
<li>Flutter 3.38 将默认的 Android <code>ndkVersion</code> 更新为 <strong>NDK r28</strong>，这是原生代码实现 16 KB 支持所需正确对齐的<strong>最低要求</strong>。</li>
</ul>
<h3 data-id="heading-29">内存泄漏修复</h3>
<p>Flutter 3.38 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F173770" target="_blank" title="https://github.com/flutter/flutter/issues/173770" ref="nofollow noopener noreferrer">修复</a>了一个影响所有 Android 上的 Flutter 应用的<strong>重要内存泄漏问题</strong>。此问题（在 3.29.0 中引入）发生在 <strong>Activities 因开发者设置或系统低内存而被销毁时</strong>。</p>
<h3 data-id="heading-30">Android 依赖项更新</h3>
<p>确定适用于您的应用的 Android 依赖项（包括 Gradle、Android Gradle Plugin (AGP)、Kotlin Gradle Plugin (KGP)、Java 等）的正确版本组合通常是一个挑战。对于 Flutter 3.38 版本，我们在持续集成 (CI) 环境中测试并确认了与以下 Android 依赖项的兼容性：</p>
<ul>
<li><strong>Java 17：</strong> Flutter 3.38 中进行 Android 开发所需的<strong>最低版本</strong>。</li>
<li><strong>KGP 2.2.20：</strong> 工具链<strong>已知和支持的最大</strong> Kotlin Gradle Plugin 版本。</li>
<li><strong>AGP 8.11.1：</strong> 与 KGP 2.2.20 <strong>兼容的最新</strong> Android Gradle Plugin 版本。</li>
<li><strong>Gradle 8.14：</strong> 此版本适用于所选的 Java、KGP 和 AGP 版本。请注意，Gradle <strong>8.13</strong> 是 AGP 8.11.1 所需的<strong>最低版本</strong>。</li>
</ul>
<p>为确保您的应用在 Flutter 版本之间无缝过渡，我们强烈建议您在构建文件中使用 Flutter SDK 提供的 API 级别变量。此版本的配置值为：</p>
<ul>
<li><code>flutter.compileSdkVersion</code> (<strong>API 36</strong>)</li>
<li><code>flutter.targetSdkVersion</code> (<strong>API 36</strong>)</li>
<li><code>flutter.minSdkVersion</code> (<strong>API 24</strong>) 或更高版本</li>
</ul>
<hr/>
<h2 data-id="heading-31">⚙️ 引擎（Engine）更新</h2>
<hr/>
<h3 data-id="heading-32">性能叠加层 (Performance overlay)</h3>
<p>性能叠加层已重构以提高效率，<strong>减少了其在 Skia 和 Impeller 后端上的渲染时间</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F176364" target="_blank" title="https://github.com/flutter/flutter/issues/176364" ref="nofollow noopener noreferrer">#176364</a>)。这意味着您可以获得更准确的性能数据，且开销更小。</p>
<h3 data-id="heading-33">Vulkan 和 OpenGL ES</h3>
<p>对 <strong>Vulkan</strong> 和 <strong>OpenGL ES</strong> 后端进行了大量修复和改进，提高了在更广泛设备上的稳定性和性能。这包括更好地处理<strong>管线缓存</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F176322" target="_blank" title="https://github.com/flutter/flutter/issues/176322" ref="nofollow noopener noreferrer">#176322</a>)、<strong>围栏等待器</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F173085" target="_blank" title="https://github.com/flutter/flutter/issues/173085" ref="nofollow noopener noreferrer">#173085</a>) 和<strong>图像布局转换</strong> (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F173884" target="_blank" title="https://github.com/flutter/flutter/issues/173884" ref="nofollow noopener noreferrer">#173884</a>)。</p>
<h3 data-id="heading-34">渲染器统一</h3>
<p>继续努力统一 <strong>CanvasKit</strong> 和 <strong>Skwasm</strong> 渲染器。本次发布包括大量的重构，以在这两者之间<strong>共享更多代码</strong>，这将有助于未来带来更一致的体验和更快的开发速度 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F174588" target="_blank" title="https://github.com/flutter/flutter/issues/174588" ref="nofollow noopener noreferrer">#174588</a>)。</p>
<h3 data-id="heading-35">线程合并</h3>
<blockquote>
<p><strong>注意⚠️注意⚠️注意⚠️</strong>
从 iOS 和 Android 中移除了退出线程合并的能力**（即不再支持可选退出）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-36">🛠️ DevTools 和 IDEs</h2>
<hr/>
<h3 data-id="heading-37">实验性 Widget 预览 - 更新</h3>
<p>Flutter 3.35 引入了 <strong>Widget 预览</strong>，这是一项准备好接受社区早期反馈的实验性功能。Flutter 3.38 版本带来了对 Widget 预览的重大改进，包括：</p>
<ul>
<li><strong>IDE 集成：</strong> <strong>VSCode</strong> 和 <strong>IntelliJ / Android Studio</strong> 插件都已更新，初步支持 Widget 预览。您现在可以直接在 <strong>IDE 内</strong>查看预览，以获得更无缝的开发体验。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d728ba17e06442bb38420bcbcd48bf6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=CNHXJHMSJzzzHiKxeU4Cu8cyyik%3D" alt="image.png" loading="lazy"/>
当在 IDE 中使用时，<strong>Widget 预览环境</strong>默认配置为根据<strong>当前选定的源文件</strong>来过滤显示的预览：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3f9fbbbb8834d3ca2afe558476acfe4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=Cxfo6TyPibXKDUOGxg29AGpuu2A%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><strong>Widget 预览环境主题和控制改进</strong>： Widget 预览环境现在支持浅色和深色模式，以及自定义 IDE 配色方案，以匹配您的开发环境。Widget 预览环境中的控件也已调整为占用更少的空间，为渲染预览留出更多可用空间。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f07d7d59d214f9a90393a0dbcaafaec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=QCgBsxiAD0%2FNZXQHBSnSHAbAhe8%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p><strong>预览可扩展性：</strong> <strong><code>Preview</code> 标注类</strong>不再被标记为 <strong><code>final</code></strong>，现在可以被扩展以创建<strong>自定义 <code>Preview</code> 标注</strong>，从而减少常见预览类型的样板代码。</p>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8009e1453ad2481c98931ee35fdf0a2c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=NxQhzN9ddQLYdOeQMtPdfaQTunY%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>多重预览支持 (MultiPreview support):</strong> 一个新的 <strong><code>MultiPreview</code> 基类</strong>允许您从单个自定义标注中创建<strong>多个预览变体</strong>。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/67be286c177c40c9ad637261cf5775d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=CsfEfKGAawm7Jl1EIVZCAcR%2BnxE%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>预览分组（Preview groups）：</strong> <code>Preview</code> 类中新增了一个 <strong><code>group</code> 参数</strong>，允许将相关的预览进行<strong>分组</strong>。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05e5021b6af047f3ad60336207db8307~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmFydmFuTW8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763686722&amp;x-signature=aVA4U39pAy1kCgWYoADbwDhz34c%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><strong>减少 <code>@Preview</code> 标注参数限制：</strong></p>
<ul>
<li><strong>私有常量</strong>现在被支持作为 <code>@Preview</code> 标注的参数。</li>
<li><strong>函数参数</strong>（如 <code>wrapper</code> 和 <code>theme</code>）仍然要求具有公共的、静态可访问的名称。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-38">🚧 Widget 预览（实验性）- 未来计划与反馈</h2>
<p>Widget 预览仍然是一个<strong>实验性功能</strong>，您的反馈对于塑造其未来至关重要。API 和用户体验尚未稳定，将根据我们从您那里获得的学习进行更改。</p>
<p>基于早期的反馈，计划进行更多增强，以改进 Widget 预览体验，包括：</p>
<ul>
<li><strong>Flutter DevTools Widget Inspector 支持：</strong> Widget Inspector 正在更新，以支持在 Widget 预览环境中<strong>检查预览</strong>。我们计划将 Inspector 直接嵌入到 Widget 预览器中，使其无论在何种开发环境中都易于访问。</li>
<li><strong>IDE 中的多项目支持：</strong> Widget 预览器目前仅支持显示包含在<strong>单个项目或 Pub 工作区</strong>中的预览。我们正在积极研究支持具有多个 Flutter 项目的 IDE 会话的选项（问题 [#173550]）。</li>
<li><strong>启动性能改进：</strong> 正在调查性能改进的机会，以减少初始启动时间，包括：
<ul>
<li>在首次运行后<strong>启动预编译的 Widget 预览环境</strong>。</li>
<li><strong>并行化预览检测逻辑</strong>，以更好地处理大型项目。</li>
</ul>
</li>
</ul>
<p><strong>开始使用：</strong></p>
<ul>
<li><strong>阅读文档：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Ftools%2Fwidget-previewer" target="_blank" title="https://docs.flutter.dev/tools/widget-previewer" ref="nofollow noopener noreferrer">Flutter Widget Previews 入门 (实验性)</a></li>
<li><strong>提供反馈：</strong> 在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2Fnew%2Fchoose" target="_blank" title="https://github.com/flutter/flutter/issues/new/choose" ref="nofollow noopener noreferrer">Flutter GitHub 仓库</a>中提交问题和功能请求。</li>
<li><strong>了解更多：</strong> 要进行技术深入探讨，请参阅 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fgo%2Fwidget-previews-architecture" target="_blank" title="https://flutter.dev/go/widget-previews-architecture" ref="nofollow noopener noreferrer">Flutter Widget Previews 架构文档</a>。</li>
</ul>
<blockquote>
<p><strong>重要提示：</strong> 存在一个已知问题，即在执行 <code>flutter pub get</code> 后，Widget 预览器可能会崩溃或停止更新。如果您遇到此问题，请在您的项目中运行 <code>flutter pub get</code> 并<strong>重启您的 IDE</strong>。详见 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F178317" target="_blank" title="https://github.com/flutter/flutter/issues/178317" ref="nofollow noopener noreferrer">#178317</a>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-39">💻 DevTools 更新</h2>
<p>Flutter 3.38 包含了对用户在 2025 年 DevTools 用户调查中提出的<strong>一些主要痛点</strong>的修复，包括：</p>
<ul>
<li><strong>网络面板 (Network Panel) 改进：</strong>
<ul>
<li>使人更容易理解面板<strong>何时正在记录网络流量</strong>。(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F9495" target="_blank" title="https://github.com/flutter/devtools/pull/9495" ref="nofollow noopener noreferrer">#9495</a>)</li>
<li>修复了<strong>复制粘贴网络请求</strong>的问题。(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F9472" target="_blank" title="https://github.com/flutter/devtools/pull/9472" ref="nofollow noopener noreferrer">#9472</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F9482" target="_blank" title="https://github.com/flutter/devtools/pull/9482" ref="nofollow noopener noreferrer">#9482</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F9485" target="_blank" title="https://github.com/flutter/devtools/pull/9485" ref="nofollow noopener noreferrer">#9485</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F8588" target="_blank" title="https://github.com/flutter/devtools/pull/8588" ref="nofollow noopener noreferrer">#8588</a>)</li>
</ul>
</li>
<li><strong>Flutter Inspector 修复：</strong>
<ul>
<li>修复了一个错误，即选择一个 Widget 有时会打开<strong>底层的框架源代码</strong>而不是用户的源代码。(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F176530" target="_blank" title="https://github.com/flutter/flutter/issues/176530" ref="nofollow noopener noreferrer">#176530</a>)</li>
<li>修复了一个偶尔阻止与 Inspector 面板<strong>顶部按钮交互</strong>的错误。(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F9327" target="_blank" title="https://github.com/flutter/devtools/pull/9327" ref="nofollow noopener noreferrer">#9327</a>)</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-40">🚫 弃用和破坏性更改</h2>
<p>本次发布包括几项重要的<strong>弃用</strong>和<strong>破坏性更改</strong>，作为持续现代化和改进 Flutter 框架努力的一部分。</p>
<ul>
<li><strong>构建和工具链关键更改：</strong> 可能会影响自定义构建脚本。
<ul>
<li>Flutter SDK 根目录下的 <strong><code>version</code> 文件已被移除</strong>，取而代之的是位于 <code>bin/cache</code> 中的新文件 <strong><code>flutter.version.json</code></strong> (#172793)。</li>
<li>此外，<strong><code>AssetManifest.json</code> 文件不再默认生成</strong> (#172594)。</li>
</ul>
</li>
<li><strong>其他值得注意的更改包括：</strong>
<ul>
<li>为了更可预测的行为，包含 <strong>Action（操作）的 <code>SnackBar</code> 将不再自动关闭</strong> (#173084)。</li>
<li><strong><code>OverlayPortal.targetsRootOverlay</code> 构造函数已弃用</strong>，取而代之的是更灵活的 <code>OverlayPortal(overlayLocation: OverlayChildLocation.rootOverlay)</code>。</li>
<li><code>CupertinoDynamicColor</code> 上的几个属性（例如 <code>withAlpha</code> 和 <code>withOpacity</code>）现已<strong>弃用</strong>，推荐使用标准的 <code>Color</code> 方法 (#171160)。</li>
<li>Flutter 3.38 要求 <strong>Java 17 作为 Android 的最低版本</strong>，与 <code>Gradle 8.14</code>（2025 年 7 月发布）的最低要求相匹配。</li>
</ul>
</li>
</ul>
<p>有关这些和其他更改的更多详细信息和迁移指南，请查阅<strong>破坏性更改页面</strong>。</p>
<h2 data-id="heading-41">结束语</h2>
<p>Flutter 3.38 专注于让您的日常开发<strong>更快、更愉快</strong>。这些增强功能旨在简化您的构建方式。我们非常感谢为本次发布做出贡献的每一位社区成员的辛勤工作和反馈。</p>
<p>要获取所有更改的完整列表，请务必查看详细的<strong>破坏性更改和发布说明</strong>。要免费提升您的生产力，只需运行 <code>flutter upgrade</code>！</p>
<p>您已经使用上了flutter 3.38了呢还是打算继续等等？反正我先用为敬。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[qinkun的缓存机制也有弊端，建议官方加个参数控制]]></title>    <link>https://juejin.cn/post/7572141390857437184</link>    <guid>https://juejin.cn/post/7572141390857437184</guid>    <pubDate>2025-11-14T05:54:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572141390857437184" data-draft-id="7572141390857355264" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="qinkun的缓存机制也有弊端，建议官方加个参数控制"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-14T05:54:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="石小石Orz"/> <meta itemprop="url" content="https://juejin.cn/user/660148845294712"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            qinkun的缓存机制也有弊端，建议官方加个参数控制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/660148845294712/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    石小石Orz
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T05:54:49.000Z" title="Fri Nov 14 2025 05:54:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    37
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>公司前端基于qiankun架构，主应用通过qiankun加载子应用，子应用也可能通过qiankun继续加载子应用，反复套娃。经过测试，不断打开子应用后，会导致内存不断上上。通过<strong>快照分析</strong>，发现内存升高的元凶是qiankun内置的# <code>import-html-entry</code>。</p>
<h2 data-id="heading-0"><code>import-html-entry</code> 的作用是什么</h2>
<p><code>import-html-entry</code> 是 qiankun / single-spa 微前端生态的核心模块之一，用来：</p>
<p>加载远程 HTML 入口文件（entry HTML），并提取出其中的 <strong>JS / CSS / 静态资源</strong>，然后按需执行或注入。</p>
<p>比如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { importEntry } <span class="hljs-keyword">from</span> <span class="hljs-string">'import-html-entry'</span>;

<span class="hljs-keyword">const</span> { execScripts } = <span class="hljs-keyword">await</span> importEntry(<span class="hljs-string">'https://wwww.石小石.com/'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-built_in">exports</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">execScripts</span>(<span class="hljs-variable language_">window</span>);
</code></pre>
<p>简单来说，<code>import-html-entry</code> 负责做三件事：</p>
<p><strong>下载远程 HTML 文件</strong></p>
<ul>
<li>使用 <code>fetch(url)</code> 请求远程 HTML。</li>
<li>解析 HTML 中的 <code>&lt;script&gt;</code> 与 <code>&lt;link&gt;</code> 标签。</li>
</ul>
<p><strong>提取资源并缓存</strong></p>
<ul>
<li>提取脚本与样式资源 URL。</li>
<li>通过自定义逻辑加载（并缓存）外部脚本与样式内容。</li>
<li>将 <code>&lt;link&gt;</code> 替换为内联 <code>&lt;style&gt;</code>，提升加载性能。</li>
</ul>
<p><strong>执行脚本</strong></p>
<ul>
<li>通过 <code>eval</code> 在隔离作用域中执行 JS（防止污染主应用的 window）。</li>
<li>支持 <code>proxy</code> 代理对象（qiankun 沙箱核心）。</li>
<li>支持同步、异步脚本的加载与执行顺序。</li>
</ul>
<h2 data-id="heading-1">核心源码</h2>
<p>它的 源码中包含这些关键函数：</p>





































<table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td><code>importHTML(url, opts)</code></td><td>主入口，加载远程 HTML</td></tr><tr><td><code>processTpl</code></td><td>解析 HTML 模板，提取 script/link</td></tr><tr><td><code>_getExternalScripts</code></td><td>加载并缓存 JS</td></tr><tr><td><code>_getExternalStyleSheets</code></td><td>加载并缓存 CSS</td></tr><tr><td><code>_execScripts</code></td><td>按顺序执行脚本</td></tr><tr><td><code>getExecutableScript</code></td><td>包装脚本为沙箱可执行代码</td></tr><tr><td><code>evalCode</code></td><td>实际执行脚本（带缓存）</td></tr></tbody></table>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d15c7fdf3934c71b9dd3ec6df5a8d9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=zXynr25cjT9elBT4AowH2Iu2TwA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">缓存机制</h2>
<p><code>import-html-entry</code> 内部维护了四个全局缓存对象， 这些缓存的目的是 <strong>在同一个浏览器会话中</strong>，当多个子应用或同一个子应用多次加载同一个 URL 时，避免重复网络请求，从而加快微前端加载速度。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> styleCache = {};    <span class="hljs-comment">// 样式字符缓存</span>
<span class="hljs-keyword">var</span> scriptCache = {};   <span class="hljs-comment">// js字符缓存</span>
<span class="hljs-keyword">var</span> embedHTMLCache = {};<span class="hljs-comment">// html字符缓存</span>
<span class="hljs-keyword">var</span> evalCache = {};     <span class="hljs-comment">// 编译后的脚本缓存</span>
</code></pre>
<p>styleCache对应源码：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/defb9b5ef19e454bafcf764484954996~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=sxBkGYTWeMxzD1rtth6Kuodgz84%3D" alt="" loading="lazy"/></p>
<p>scriptCache对应源码：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fbad9bdf25c47fc9a6749bde4708b57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=vl9BHtCQ7sdnzsmUfhpffyGxViE%3D" alt="" loading="lazy"/></p>
<p>embedHTMLCache对应源码：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/edb39ab801534a1995e5463272564844~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=gx8ne3rFE7Cgx5fDaue1zdIBieo%3D" alt="" loading="lazy"/></p>
<p>evalCache对应源码：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b4a81fc3e804d7f9381634ff94d55ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=9Dd%2BhxqLI1kxuemkaG815qsq4%2Bs%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">缓存机制在子应用多开频繁销毁创建场景中的弊端</h2>
<p>在单实例的 <strong>qiankun 架构</strong> 中，<code>import-html-entry</code> 的缓存仅会存在一份，对内存的占用影响有限，缓存带来的性能收益相对较高。<br/>
但如果系统存在大量qiankun加载子应用的场景，比如要频繁打开若干子应用（类似于菜单），子应用需要频繁打开销毁（tab切换等），同时其内部的部分功能模块又会再次通过 <code>qiankun</code> 动态加载子应用。这种嵌套加载结构会导致 <code>import-html-entry</code> 在多个层级重复缓存资源，即使资源内容相同，也会被多次存储。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8dd52ac49dc84c40bc67d7d4d21ba135~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-z5bCP55-zT3J6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763710132&amp;x-signature=m5wBawS8ny0QZ5wLlQseUMx%2BFwY%3D" alt="" loading="lazy"/></p>
<p>因此，子应用的频繁打开与卸载，会导致内存占用持续增长，从而引发明显的性能下降（国产CPU可能更明显）。</p>
<p>因此，<strong>移除或禁用</strong> <code>import-html-entry</code> <strong>的缓存机制</strong>，能极大缓解内存泄漏问题，<strong>提升系统在复杂场景下的运行性能与稳定性</strong>。</p>
<h2 data-id="heading-4">优化方案</h2>



































<table><thead><tr><th>缓存名</th><th>缓存内容</th><th>缓存目的</th><th>禁用影响</th></tr></thead><tbody><tr><td><strong>styleCache</strong></td><td>每个 CSS 链接的内容（文本）</td><td>避免重复请求相同样式文件</td><td>每次重新请求 CSS（但浏览器会命中协商缓存，影响极小）</td></tr><tr><td><strong>scriptCache</strong></td><td>每个 JS 链接的内容（文本）</td><td>避免重复请求相同脚本文件</td><td>每次重新请求 JS（命中浏览器缓存，影响较小）</td></tr><tr><td><strong>embedHTMLCache</strong></td><td>整个 HTML 模板字符串</td><td>避免重复请求入口 HTML 文件</td><td>每次重新请求入口文件，性能略降</td></tr><tr><td><strong>evalCache</strong></td><td>每个脚本的已编译函数 <code>(function(){...})</code></td><td><strong>避免多次 eval 编译同一脚本字符串</strong>，提升运行性能</td><td>每次都重新 eval 解析 JS 字符串，会略微影响性能（CPU 负担）</td></tr></tbody></table>
<p>浏览器自带的协商缓存已能高效复用 HTML、JS、CSS 资源，因此禁用 <code>import-html-entry</code> 的缓存逻辑几乎不影响加载性能。<br/>
<code>evalCache</code> 的移除可能短暂增加 CPU 开销降低性能，但整体影响可能较小，需要综合评估。</p>
<p><strong>通过在 qiankun 集成层中移除多余缓存，可有效降低内存占用，缓解泄漏问题，并显著提升系统性能与稳定性。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[还在死磕模板语法？Vue渲染函数+JSX让你开发效率翻倍！]]></title>    <link>https://juejin.cn/post/7572087162230194218</link>    <guid>https://juejin.cn/post/7572087162230194218</guid>    <pubDate>2025-11-13T23:28:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572087162230194218" data-draft-id="7572087162230177834" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="还在死磕模板语法？Vue渲染函数+JSX让你开发效率翻倍！"/> <meta itemprop="keywords" content="Vue.js,JavaScript,前端"/> <meta itemprop="datePublished" content="2025-11-13T23:28:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="良山有风来"/> <meta itemprop="url" content="https://juejin.cn/user/3940246036939358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            还在死磕模板语法？Vue渲染函数+JSX让你开发效率翻倍！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3940246036939358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    良山有风来
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-13T23:28:49.000Z" title="Thu Nov 13 2025 23:28:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    30
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">开篇：被模板限制的烦恼时刻</h2>
<p>你是不是也遇到过这样的场景？产品经理拿着设计稿过来，说要做一个超级灵活的动态表单，每个字段的类型、验证规则、布局方式都可能随时变化。你看着那复杂的条件渲染，心里默默计算着要写多少v-if、v-switch，还有那些嵌套很深的组件结构，光是想想就头大。</p>
<p>或者，你需要封装一个高度可复用的业务组件，但使用模板时总觉得有些逻辑表达起来不够直接，尤其是在处理动态组件、递归组件这些高级用法时，模板语法显得有点力不从心。</p>
<p>别担心，今天我要跟你分享的Vue渲染函数和JSX，就是专门为解决这些问题而生的利器。它们能让你在Vue开发中拥有更大的灵活性，特别是在那些模板难以应对的动态场景里。</p>
<p>学完今天的内容，你会掌握如何用JSX写出更简洁直观的组件代码，理解渲染函数的工作原理，还能在实际项目中灵活运用这些技术解决复杂问题。</p>
<h2 data-id="heading-1">为什么需要超越模板？</h2>
<p>先来说说模板的局限性。Vue的模板语法确实很友好，声明式、易上手，但在处理特别复杂的动态逻辑时，模板会变得冗长且难以维护。</p>
<p>想象一下这样的需求：根据后端返回的配置对象，动态渲染一个完整的页面结构。配置里可能包含按钮、输入框、表格等各种组件，还有它们之间的嵌套关系。用模板的话，你可能要写一大堆v-if和动态组件，代码可读性直线下降。</p>
<p>这时候渲染函数和JSX的优势就体现出来了。它们本质上都是JavaScript，能够利用JS完整的编程能力来表达组件结构。循环、条件判断、递归，这些在JS里都很自然，但在模板里就需要各种指令配合。</p>
<p>不过要说明的是，我并不是说模板不好。在大多数常规场景下，模板依然是最佳选择。只有在真正需要更大灵活性的动态场景中，才需要考虑使用渲染函数或JSX。</p>
<h2 data-id="heading-2">初识渲染函数：用JavaScript描述UI</h2>
<p>先来看一个最简单的例子。平时我们用模板写一个按钮组件可能是这样的：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"['btn', `btn-${type}`]"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span>&gt;</span>
    {{ text }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>如果用渲染函数来写，会是这样：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'type'</span>, <span class="hljs-string">'text'</span>],
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">'click'</span>)
    }
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(
      <span class="hljs-string">'button'</span>,
      {
        <span class="hljs-attr">class</span>: [<span class="hljs-string">'btn'</span>, <span class="hljs-string">`btn-<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.type}</span>`</span>],
        <span class="hljs-attr">on</span>: {
          <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>
        }
      },
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>
    )
  }
}
</code></pre>
<p>这里的<code>h</code>函数是创建虚拟DOM节点的工具，它接收三个参数：标签名、数据对象、子节点。数据对象可以包含class、style、props、on等属性。</p>
<p>可能你会觉得，这看起来比模板复杂啊？别急，这只是一个入门示例。当逻辑变得复杂时，渲染函数的优势才会真正显现。</p>
<h2 data-id="heading-3">JSX：更直观的写法</h2>
<p>如果你觉得上面的渲染函数写法还是有些抽象，那么JSX可能会让你眼前一亮。JSX是一种JavaScript的语法扩展，它让我们能在JS中写类似HTML的结构。</p>
<p>同样的按钮组件，用JSX来写：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'type'</span>, <span class="hljs-string">'text'</span>],
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">'click'</span>)
    }
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
        <span class="hljs-attr">class</span>=<span class="hljs-string">{[</span>'<span class="hljs-attr">btn</span>', `<span class="hljs-attr">btn-</span>${<span class="hljs-attr">this.type</span>}`]}
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>
      &gt;</span>
        {this.text}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>是不是感觉亲切多了？JSX让渲染函数的写法更加直观，特别是对于有React经验的开发者来说，几乎可以无缝切换。</p>
<p>要在Vue项目中使用JSX，你需要配置相应的Babel插件。现在主流的Vue脚手架工具都支持这个功能，配置起来也很简单。</p>
<h2 data-id="heading-4">动态场景实战：可配置表单渲染器</h2>
<p>让我们来看一个真实的业务场景。假设我们要做一个动态表单渲染器，根据JSON配置来渲染不同的表单字段。</p>
<p>首先定义配置结构：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> formConfig = [
  {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'username'</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-string">'用户名'</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'请输入用户名'</span>
  },
  {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'gender'</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-string">'性别'</span>,
    <span class="hljs-attr">options</span>: [
      { <span class="hljs-attr">label</span>: <span class="hljs-string">'男'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'male'</span> },
      { <span class="hljs-attr">label</span>: <span class="hljs-string">'女'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'female'</span> }
    ]
  },
  {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'checkbox'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'hobbies'</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-string">'兴趣爱好'</span>,
    <span class="hljs-attr">options</span>: [
      { <span class="hljs-attr">label</span>: <span class="hljs-string">'读书'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'reading'</span> },
      { <span class="hljs-attr">label</span>: <span class="hljs-string">'运动'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'sports'</span> }
    ]
  }
]
</code></pre>
<p>如果用模板来实现，可能会是这样：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-renderer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"field in config"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"field.name"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>{{ field.label }}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">v-if</span>=<span class="hljs-string">"field.type === 'input'"</span>
        <span class="hljs-attr">:type</span>=<span class="hljs-string">"field.type"</span>
        <span class="hljs-attr">:name</span>=<span class="hljs-string">"field.name"</span>
        <span class="hljs-attr">:required</span>=<span class="hljs-string">"field.required"</span>
        <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">"field.placeholder"</span>
        <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData[field.name]"</span>
      &gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">select</span>
        <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"field.type === 'select'"</span>
        <span class="hljs-attr">:name</span>=<span class="hljs-string">"field.name"</span>
        <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData[field.name]"</span>
      &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>
          <span class="hljs-attr">v-for</span>=<span class="hljs-string">"option in field.options"</span>
          <span class="hljs-attr">:key</span>=<span class="hljs-string">"option.value"</span>
          <span class="hljs-attr">:value</span>=<span class="hljs-string">"option.value"</span>
        &gt;</span>
          {{ option.label }}
        <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"field.type === 'checkbox'"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>
          <span class="hljs-attr">v-for</span>=<span class="hljs-string">"option in field.options"</span>
          <span class="hljs-attr">:key</span>=<span class="hljs-string">"option.value"</span>
        &gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
            <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
            <span class="hljs-attr">:value</span>=<span class="hljs-string">"option.value"</span>
            <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData[field.name]"</span>
          &gt;</span>
          {{ option.label }}
        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>可以看到，模板里有很多条件判断，代码结构比较复杂。现在来看看用JSX如何实现：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'config'</span>],
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">formData</span>: {}
    }
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">renderField</span> = (<span class="hljs-params">field</span>) =&gt; {
      <span class="hljs-keyword">const</span> commonProps = {
        <span class="hljs-attr">name</span>: field.<span class="hljs-property">name</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>[field.<span class="hljs-property">name</span>],
        <span class="hljs-attr">onInput</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">formData</span>[field.<span class="hljs-property">name</span>] = value
        }
      }

      <span class="hljs-keyword">switch</span> (field.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
          <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
              {<span class="hljs-attr">...commonProps</span>}
              <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
              <span class="hljs-attr">required</span>=<span class="hljs-string">{field.required}</span>
              <span class="hljs-attr">placeholder</span>=<span class="hljs-string">{field.placeholder}</span>
            /&gt;</span></span>
          )
        
        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> {<span class="hljs-attr">...commonProps</span>}&gt;</span>
              {field.options.map(option =&gt; (
                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{option.value}</span>&gt;</span>
                  {option.label}
                <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
              ))}
            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span>
          )
        
        <span class="hljs-keyword">case</span> <span class="hljs-string">'checkbox'</span>:
          <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
              {field.options.map(option =&gt; (
                <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
                    <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
                    <span class="hljs-attr">value</span>=<span class="hljs-string">{option.value}</span>
                    <span class="hljs-attr">checked</span>=<span class="hljs-string">{this.formData[field.name]?.includes(option.value)}</span>
                    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
                      const values = this.formData[field.name] || []
                      if (e.target.checked) {
                        this.formData[field.name] = [...values, option.value]
                      } else {
                        this.formData[field.name] = values.filter(v =&gt; v !== option.value)
                      }
                    }}
                  /&gt;
                  {option.label}
                <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
              ))}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
          )
        
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
      }
    }

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-renderer"</span>&gt;</span>
        {this.config.map(field =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{field.name}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>{field.label}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            {renderField(field)}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>用JSX实现的代码结构更清晰，逻辑更集中。特别是当表单字段类型增多时，只需要在switch语句中添加新的case即可，扩展性更好。</p>
<h2 data-id="heading-5">高级技巧：递归组件与动态组件</h2>
<p>渲染函数和JSX在处理递归组件和动态组件时尤其强大。比如我们要实现一个无限级嵌套的树形组件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'TreeNode'</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">node</span>: <span class="hljs-title class_">Object</span>
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">renderNode</span> = (<span class="hljs-params">node</span>) =&gt; {
      <span class="hljs-comment">// 如果有子节点，递归渲染</span>
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-node"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"node-content"</span>&gt;</span>{node.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"children"</span>&gt;</span>
              {node.children.map(child =&gt; (
                <span class="hljs-tag">&lt;<span class="hljs-name">TreeNode</span> <span class="hljs-attr">node</span>=<span class="hljs-string">{child}</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{child.id}</span> /&gt;</span>
              ))}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
      }
      
      <span class="hljs-comment">// 叶子节点</span>
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-node leaf"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"node-content"</span>&gt;</span>{node.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      )
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>)
  }
}
</code></pre>
<p>在JSX中，我们可以直接使用组件名来引用当前组件，实现递归渲染。这在模板中虽然也能实现，但写起来会比较别扭。</p>
<p>再看动态组件的例子。假设我们需要根据数据类型动态选择不同的展示组件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> componentMap = {
  <span class="hljs-attr">text</span>: <span class="hljs-title class_">TextDisplay</span>,
  <span class="hljs-attr">image</span>: <span class="hljs-title class_">ImageDisplay</span>,
  <span class="hljs-attr">video</span>: <span class="hljs-title class_">VideoDisplay</span>,
  <span class="hljs-attr">chart</span>: <span class="hljs-title class_">ChartDisplay</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'data'</span>],
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">DynamicComponent</span> = componentMap[<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">type</span>]
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">DynamicComponent</span>) {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>未知数据类型<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    }

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DynamicComponent</span> 
        <span class="hljs-attr">data</span>=<span class="hljs-string">{this.data}</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"data-display"</span>
      /&gt;</span></span>
    )
  }
}
</code></pre>
<p>这种动态组件的选择逻辑在JSX中表达得非常自然，如果要用模板的话，需要配合<code>&lt;component :is="componentType"&gt;</code>语法，但在复杂逻辑下不如JSX直观。</p>
<h2 data-id="heading-6">性能优化与最佳实践</h2>
<p>使用渲染函数和JSX时，有几个性能优化的要点需要注意。</p>
<p>首先是正确的使用key。在循环渲染元素时，一定要提供稳定且唯一的key：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {this.items.map(item =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p>其次是避免不必要的重新渲染。在复杂的渲染函数中，可以合理使用计算属性和方法来缓存一些中间结果：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'items'</span>],
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">processedItems</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 复杂的处理逻辑放在计算属性中</span>
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({
        ...item,
        <span class="hljs-attr">processed</span>: <span class="hljs-literal">true</span>
      }))
    }
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {this.processedItems.map(item =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>另外，在JSX中正确使用插槽。Vue的插槽在JSX中有对应的写法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 定义带插槽的组件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-header"</span>&gt;</span>
          {this.$slots.header}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-body"</span>&gt;</span>
          {this.$slots.default}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-footer"</span>&gt;</span>
          {this.$slots.footer}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}

<span class="hljs-comment">// 使用带插槽的组件</span>
<span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是主要内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"footer"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span>
  )
}
</code></pre>
<h2 data-id="heading-7">与Composition API的完美结合</h2>
<p>在Vue 3的Composition API中，渲染函数和JSX的配合更加默契。我们可以在setup函数中直接返回渲染函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'items'</span>],
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-keyword">const</span> searchQuery = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
    
    <span class="hljs-keyword">const</span> filteredItems = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> props.<span class="hljs-property">items</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>
        item.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(searchQuery.<span class="hljs-property">value</span>)
      )
    })
    
    <span class="hljs-comment">// 直接返回渲染函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
          <span class="hljs-attr">vModel</span>=<span class="hljs-string">{searchQuery.value}</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"搜索..."</span>
        /&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          {filteredItems.value.map(item =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>这种写法让逻辑和UI更加紧密地结合在一起，代码的组织方式更加灵活。</p>
<h2 data-id="heading-8">实战：封装一个高级表格组件</h2>
<p>让我们用JSX封装一个功能丰富的高级表格组件，支持动态列、排序、筛选等功能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">data</span>: <span class="hljs-title class_">Array</span>,
    <span class="hljs-attr">columns</span>: <span class="hljs-title class_">Array</span>,
    <span class="hljs-attr">sortable</span>: <span class="hljs-title class_">Boolean</span>
  },
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">sortKey</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">sortOrder</span>: <span class="hljs-string">'asc'</span>,
      <span class="hljs-attr">filters</span>: {}
    }
  },
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">processedData</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">let</span> result = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>]
      
      <span class="hljs-comment">// 应用筛选</span>
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filters</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (value) {
          result = result.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> 
            <span class="hljs-title class_">String</span>(item[key]).<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">includes</span>(value.<span class="hljs-title function_">toLowerCase</span>())
          )
        }
      })
      
      <span class="hljs-comment">// 应用排序</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortKey</span>) {
        result.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> aVal = a[<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortKey</span>]
          <span class="hljs-keyword">const</span> bVal = b[<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortKey</span>]
          <span class="hljs-keyword">const</span> modifier = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortOrder</span> === <span class="hljs-string">'asc'</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>
          
          <span class="hljs-keyword">if</span> (aVal &lt; bVal) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> * modifier
          <span class="hljs-keyword">if</span> (aVal &gt; bVal) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * modifier
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        })
      }
      
      <span class="hljs-keyword">return</span> result
    }
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">handleSort</span>(<span class="hljs-params">key</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortKey</span> === key) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortOrder</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortOrder</span> === <span class="hljs-string">'asc'</span> ? <span class="hljs-string">'desc'</span> : <span class="hljs-string">'asc'</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortKey</span> = key
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortOrder</span> = <span class="hljs-string">'asc'</span>
      }
    },
    
    <span class="hljs-title function_">handleFilter</span>(<span class="hljs-params">key, value</span>) {
      <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filters</span>, key, value)
    }
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"advanced-table"</span>&gt;</span>
        {/* 表头 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table-header"</span>&gt;</span>
          {this.columns.map(column =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"header-cell"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{column.key}</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{column.title}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
              
              {/* 排序按钮 */}
              {this.sortable &amp;&amp; (
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
                  <span class="hljs-attr">class</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">sort-btn</span> ${<span class="hljs-attr">this.sortKey</span> === <span class="hljs-string">column.key</span> ? '<span class="hljs-attr">active</span>' <span class="hljs-attr">:</span> ''}`}
                  <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.handleSort(column.key)}
                &gt;
                  {this.sortKey === column.key &amp;&amp; this.sortOrder === 'asc' ? '↑' : '↓'}
                <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
              )}
              
              {/* 筛选输入框 */}
              <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
                <span class="hljs-attr">class</span>=<span class="hljs-string">"filter-input"</span>
                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"筛选..."</span>
                <span class="hljs-attr">value</span>=<span class="hljs-string">{this.filters[column.key]</span> || ''}
                <span class="hljs-attr">onInput</span>=<span class="hljs-string">{(e)</span> =&gt;</span> this.handleFilter(column.key, e.target.value)}
              /&gt;
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        {/* 表格内容 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table-body"</span>&gt;</span>
          {this.processedData.map((row, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table-row"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>
              {this.columns.map(column =&gt; (
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table-cell"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{column.key}</span>&gt;</span>
                  {column.render ? column.render(row) : row[column.key]}
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              ))}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>这个表格组件展示了JSX在复杂组件封装中的强大能力。我们可以很灵活地控制渲染逻辑，实现各种动态功能。</p>
<h2 data-id="heading-9">什么时候该用，什么时候不该用</h2>
<p>虽然渲染函数和JSX很强大，但并不是所有场景都适合使用。这里给你一些实用的建议：</p>
<p><strong>推荐使用渲染函数/JSX的场景：</strong></p>
<ul>
<li>需要高度动态的组件结构</li>
<li>复杂的条件渲染逻辑</li>
<li>递归组件</li>
<li>基于运行时条件动态选择组件</li>
<li>需要更大编程灵活性的高级组件库</li>
</ul>
<p><strong>不推荐使用的场景：</strong></p>
<ul>
<li>简单的静态布局</li>
<li>团队对JSX不熟悉</li>
<li>需要设计师或非技术人员参与模板修改</li>
<li>已经用模板写得很好的常规业务组件</li>
</ul>
<p>记住，技术选型的核心是选择合适的工具解决问题，而不是追求最新最潮的技术。</p>
<h2 data-id="heading-10">从模板平滑迁移到JSX</h2>
<p>如果你决定在项目中尝试JSX，这里有一些平滑迁移的建议：</p>
<p>首先，可以从一些简单的组件开始尝试。比如先找一个逻辑比较复杂的组件，用JSX重写，感受一下差异。</p>
<p>其次，充分利用Vue Devtools。JSX组件在Devtools中的调试体验和模板组件基本一致，你可以正常查看组件层次、props、状态等信息。</p>
<p>另外，建立团队的代码规范。JSX给了我们更大的灵活性，但也需要相应的规范来保证代码质量。比如规定何时使用JSX、代码组织方式等。</p>
<p>最后，记住模板和JSX可以共存。你不需要一次性重写所有组件，可以在同一个项目中混合使用，根据每个组件的特性选择合适的技术。</p>
<h2 data-id="heading-11">结尾：拥抱更灵活的Vue开发方式</h2>
<p>今天我们深入探讨了Vue渲染函数和JSX在动态场景中的应用。从基础的语法到高级的实战技巧，相信你已经感受到了这种开发方式的魅力。</p>
<p>记住，模板、渲染函数、JSX都是Vue生态中的重要组成部分，它们各有适用的场景。作为开发者，我们的目标是掌握各种工具，然后在合适的场景选择合适的技术。</p>
<p>JSX和渲染函数不是要取代模板，而是为我们提供了另一种解决问题的思路。当模板遇到瓶颈时，知道还有这样一条路可以走，这才是最重要的。</p>
<p>现在，你是否已经在想自己的哪个项目可以用上这些技术了？欢迎在评论区分享你的想法和问题，我们一起探讨Vue开发的更多可能性！</p>
<p>下次再见，希望你已经准备好用更灵活的方式编写Vue组件了！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[HTML&CSS&JS：赛博木鱼]]></title>    <link>https://juejin.cn/post/7572087162230751274</link>    <guid>https://juejin.cn/post/7572087162230751274</guid>    <pubDate>2025-11-14T01:55:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572087162230751274" data-draft-id="7572039006530158628" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="HTML&amp;CSS&amp;JS：赛博木鱼"/> <meta itemprop="keywords" content="前端,JavaScript,CSS"/> <meta itemprop="datePublished" content="2025-11-14T01:55:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端Hardy"/> <meta itemprop="url" content="https://juejin.cn/user/4222572710333816"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            HTML&amp;CSS&amp;JS：赛博木鱼
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222572710333816/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端Hardy
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T01:55:56.000Z" title="Fri Nov 14 2025 01:55:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>用 HTML + CSS + JS 打造一个禅意十足的互动小应用——赛博木鱼， 本文将拆解其核心实现逻辑，带你从 0 到 1 理解 “敲木鱼” 背后的技术细节。</p>
<hr/>
<p><em>大家复制代码时，可能会因格式转换出现错乱，导致样式失效。建议先少量复制代码进行测试，若未能解决问题，私信回复源码两字，我会发送完整的压缩包给你。</em></p>
<h2 data-id="heading-0">演示效果</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/703f4fd06e564ce6b23921cd28061eff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uvSGFyZHk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763690156&amp;x-signature=0%2F%2FXjvad3gBM0YDFnAwIWDaLgtg%3D" alt="演示效果" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/517eb4d61f4a4044a48d85980ddb1764~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uvSGFyZHk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763690156&amp;x-signature=HZAGS0yG4w1CEpn6VGhbhbDlElg%3D" alt="演示效果" loading="lazy"/></p>
<h2 data-id="heading-1">HTML&amp;CSS</h2>
<pre><code class="hljs language-html" lang="html">
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>赛博木鱼<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#121212</span>;
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Kaiti SC'</span>, <span class="hljs-string">'PingFang SC'</span>, sans-serif;
            <span class="hljs-attribute">display</span>: flex;
            <span class="hljs-attribute">flex-direction</span>: column;
            <span class="hljs-attribute">align-items</span>: center;
            <span class="hljs-attribute">justify-content</span>: center;
            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;
            <span class="hljs-attribute">overflow</span>: hidden;
        }

        <span class="hljs-selector-class">.title-container</span> {
            <span class="hljs-attribute">text-align</span>: center;
            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;
        }

        <span class="hljs-selector-class">.main-title</span> {
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6vw</span>;
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Kaiti SC'</span>, sans-serif;
            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">180deg</span>,
                <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">176</span>, <span class="hljs-number">103</span>, <span class="hljs-number">0.05</span>) <span class="hljs-number">0%</span>,
                <span class="hljs-built_in">rgba</span>(<span class="hljs-number">115</span>, <span class="hljs-number">55</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.02</span>) <span class="hljs-number">100%</span>);
            <span class="hljs-attribute">background-clip</span>: text;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span>;
        }

        <span class="hljs-selector-class">.score-container</span> {
            <span class="hljs-attribute">text-align</span>: center;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-selector-class">.score</span> {
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10vh</span>;
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'PingFang SC'</span>, sans-serif;
            <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">900</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
        }

        <span class="hljs-selector-class">.description</span> {
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">5vh</span>;
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'PingFang SC'</span>, sans-serif;
            <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;
        }

        <span class="hljs-selector-class">.wooden-fish-container</span> {
            <span class="hljs-attribute">position</span>: relative;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
            <span class="hljs-attribute">display</span>: flex;
            <span class="hljs-attribute">justify-content</span>: center;
            <span class="hljs-attribute">align-items</span>: center;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-selector-class">.wooden-fish</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">284px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">236px</span>;
            <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.1s</span> ease;
        }

        <span class="hljs-selector-class">.mallet</span> {
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">right</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">119px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">69px</span>;
            <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.1s</span> ease;
            <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;
        }

        <span class="hljs-selector-class">.floating-text</span> {
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">top</span>: -<span class="hljs-number">50px</span>;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'PingFang SC'</span>, sans-serif;
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span>;
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;
            <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">pointer-events</span>: none;
            <span class="hljs-attribute">animation</span>: floatUp <span class="hljs-number">0.4s</span> ease-out forwards;
        }

        <span class="hljs-keyword">@keyframes</span> floatUp {
            <span class="hljs-number">0%</span> {
                <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
                <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);
            }
            <span class="hljs-number">100%</span> {
                <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
                <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">60px</span>);
            }
        }

        <span class="hljs-selector-class">.bottom-text</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Kaiti SC'</span>, sans-serif;
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;
            <span class="hljs-attribute">text-align</span>: center;
            <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-title"</span>&gt;</span>赛博木鱼<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"score-container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"score"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"score"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"description"</span>&gt;</span>功德<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wooden-fish-container"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fishContainer"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://img.alicdn.com/imgextra/i3/O1CN012CO0YU1VSfNs506ZS_!!6000000002652-2-tps-284-236.png"</span>
             <span class="hljs-attr">alt</span>=<span class="hljs-string">"木鱼"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wooden-fish"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"woodenFish"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://img.alicdn.com/imgextra/i1/O1CN01tKb5Et1aSjWRjCHK3_!!6000000003329-2-tps-119-69.png"</span>
             <span class="hljs-attr">alt</span>=<span class="hljs-string">"锤子"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mallet"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mallet"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom-text"</span>&gt;</span>轻敲木鱼，细悟赛博真经。<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clickSound"</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">"auto"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://qianwen.alicdn.com/resource/qiaomuyu.mp3"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"audio/mpeg"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> scoreElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'score'</span>);
        <span class="hljs-keyword">const</span> woodenFish = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'woodenFish'</span>);
        <span class="hljs-keyword">const</span> mallet = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'mallet'</span>);
        <span class="hljs-keyword">const</span> fishContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'fishContainer'</span>);
        <span class="hljs-keyword">const</span> clickSound = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'clickSound'</span>);

        fishContainer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
            <span class="hljs-comment">// 播放音效</span>
            clickSound.<span class="hljs-property">currentTime</span> = <span class="hljs-number">0</span>;
            clickSound.<span class="hljs-title function_">play</span>();

            <span class="hljs-comment">// 锤子旋转动画</span>
            mallet.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'rotate(-25deg)'</span>;
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                mallet.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'rotate(0deg)'</span>;
            }, <span class="hljs-number">100</span>);

            <span class="hljs-comment">// 木鱼放大动画</span>
            woodenFish.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'scale(1.1)'</span>;
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                woodenFish.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'scale(1)'</span>;
            }, <span class="hljs-number">100</span>);

            <span class="hljs-comment">// 增加分数</span>
            score++;
            scoreElement.<span class="hljs-property">textContent</span> = score;

            <span class="hljs-comment">// 创建漂浮文字</span>
            <span class="hljs-keyword">const</span> floatingText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
            floatingText.<span class="hljs-property">className</span> = <span class="hljs-string">'floating-text'</span>;
            floatingText.<span class="hljs-property">textContent</span> = <span class="hljs-string">'功德+1'</span>;
            fishContainer.<span class="hljs-title function_">appendChild</span>(floatingText);

            <span class="hljs-comment">// 移除漂浮文字</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                floatingText.<span class="hljs-title function_">remove</span>();
            }, <span class="hljs-number">400</span>);
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>




</code></pre>
<h2 data-id="heading-2">HTML</h2>
<ul>
<li>title-container：标题容器：承载 “赛博木鱼” 主标题，通过居中布局突出视觉核心</li>
<li>score-container：分数展示区：包含 “功德数” 和 “功德” 描述，是用户交互的核心反馈载体</li>
<li>wooden-fish-container：交互核心容器</li>
<li>wooden-fish：木鱼图片：通过 CDN 引入资源，无需本地存储，是点击交互的视觉核心</li>
<li>mallet：锤子图片：绝对定位在木鱼右上方，点击时通过旋转动画模拟 “敲击” 动作</li>
<li>clickSound：音效载体：预加载木鱼敲击音效（preload="auto"），点击时触发播放，增强沉浸感</li>
<li>floating-text：动态生成元素：点击时创建 “功德 + 1” 漂浮文字，完成交互反馈闭环</li>
</ul>
<h2 data-id="heading-3">CSS</h2>
<ul>
<li>.mallet：点击时锤子绕右上角旋转 25 度，模拟 “敲下去” 的动作，100 毫秒快速回弹</li>
<li>.wooden-fish：点击时木鱼轻微放大 1.1 倍，模拟 “被敲击后的震动”，与锤子动作同步：</li>
<li>.floating-text：自动向上淡出，营造“功德升天”的视觉效果。</li>
</ul>
<h2 data-id="heading-4">JavaScript</h2>
<ol>
<li>初始化变量：获取 DOM 元素与状态</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>; <span class="hljs-comment">// 功德数初始值</span>
<span class="hljs-keyword">const</span> scoreElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'score'</span>); <span class="hljs-comment">// 分数显示元素</span>
<span class="hljs-keyword">const</span> woodenFish = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'woodenFish'</span>); <span class="hljs-comment">// 木鱼元素</span>
<span class="hljs-keyword">const</span> mallet = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'mallet'</span>); <span class="hljs-comment">// 锤子元素</span>
<span class="hljs-keyword">const</span> fishContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'fishContainer'</span>); <span class="hljs-comment">// 交互容器</span>
<span class="hljs-keyword">const</span> clickSound = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'clickSound'</span>); <span class="hljs-comment">// 音效元素</span>
</code></pre>
<p>通过 getElementById 获取核心交互元素，提前定义功德数状态。</p>
<ol start="2">
<li>核心交互：点击事件处理</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">fishContainer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// 1. 播放敲击音效（每次点击从头播放，支持连续敲击）</span>
    clickSound.<span class="hljs-property">currentTime</span> = <span class="hljs-number">0</span>;
    clickSound.<span class="hljs-title function_">play</span>();

    <span class="hljs-comment">// 2. 锤子旋转动画：敲下→回弹</span>
    mallet.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'rotate(-25deg)'</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        mallet.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'rotate(0deg)'</span>;
    }, <span class="hljs-number">100</span>);

    <span class="hljs-comment">// 3. 木鱼缩放动画：放大→还原</span>
    woodenFish.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'scale(1.1)'</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        woodenFish.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">'scale(1)'</span>;
    }, <span class="hljs-number">100</span>);

    <span class="hljs-comment">// 4. 功德数累加与更新</span>
    score++;
    scoreElement.<span class="hljs-property">textContent</span> = score;

    <span class="hljs-comment">// 5. 生成“功德+1”漂浮文字</span>
    <span class="hljs-keyword">const</span> floatingText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    floatingText.<span class="hljs-property">className</span> = <span class="hljs-string">'floating-text'</span>;
    floatingText.<span class="hljs-property">textContent</span> = <span class="hljs-string">'功德+1'</span>;
    fishContainer.<span class="hljs-title function_">appendChild</span>(floatingText);

    <span class="hljs-comment">// 6. 动画结束后移除文字（避免DOM堆积）</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        floatingText.<span class="hljs-title function_">remove</span>();
    }, <span class="hljs-number">400</span>);
});
</code></pre>
<ol start="3">
<li>关键技术点拆解</li>
</ol>
<p><strong>音效重置</strong>：clickSound.currentTime = 0 确保连续点击时音效不叠加，每次都是完整的 “敲击声”；</p>
<p><strong>动画同步</strong>：锤子旋转和木鱼缩放的过渡时长（0.1s）与定时器延迟（100ms）一致，动作协调；</p>
<p><strong>DOM 优化</strong>：漂浮文字动画结束后通过 remove()移除，避免页面 DOM 元素过多导致性能问题；</p>
<p><strong>无依赖设计</strong>：不使用任何框架，仅原生 API，兼容性覆盖所有现代浏览器。</p>
<hr/>
<p><em>各位互联网搭子，要是这篇文章成功引起了你的注意，别犹豫，<strong>关注、点赞、评论、分享走一波</strong>，让我们把这份默契延续下去，一起在知识的海洋里乘风破浪！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[高并发订单去重：布隆过滤器过滤已存在订单号的实战方案]]></title>    <link>https://juejin.cn/post/7572048000301252649</link>    <guid>https://juejin.cn/post/7572048000301252649</guid>    <pubDate>2025-11-14T02:35:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572048000301252649" data-draft-id="7572052559822372870" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="高并发订单去重：布隆过滤器过滤已存在订单号的实战方案"/> <meta itemprop="keywords" content="后端,分布式"/> <meta itemprop="datePublished" content="2025-11-14T02:35:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="回家路上绕了弯"/> <meta itemprop="url" content="https://juejin.cn/user/536217404587134"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            高并发订单去重：布隆过滤器过滤已存在订单号的实战方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/536217404587134/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    回家路上绕了弯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T02:35:03.000Z" title="Fri Nov 14 2025 02:35:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">高并发订单去重：布隆过滤器过滤已存在订单号的实战方案</h2>
<p>在电商秒杀、支付交易、物流下单等场景中，“判断订单号是否已存在” 是高频操作 —— 比如防止用户重复提交订单、避免分布式系统生成重复订单 ID、拦截缓存穿透查询。但当订单量突破亿级时，传统方案（查数据库、查 Redis Set）会因 “内存占用大”“查询慢” 失效，而布隆过滤器（Bloom Filter）凭借 “低内存、高吞吐、O (1) 查询” 的特性，成为这类场景的最优解。</p>
<p>本文将从 “原理→适配→实现→落地” 四层，完整讲解如何用布隆过滤器解决订单号去重问题，尤其聚焦订单场景的特殊需求与避坑点。</p>
<h3 data-id="heading-1">一、先搞懂：为什么订单场景需要布隆过滤器？</h3>
<p>在讲实现前，先明确传统方案的痛点与布隆过滤器的优势，避免 “为了用技术而用技术”。</p>
<h4 data-id="heading-2">1. 传统订单号判重方案的瓶颈</h4>

























<table><thead><tr><th>方案</th><th>实现逻辑</th><th>亿级订单场景的痛点</th></tr></thead><tbody><tr><td>数据库唯一索引</td><td>订单表加order_id唯一索引，插入时判断是否冲突</td><td>写入时需磁盘 IO，高并发下锁等待严重，插入延迟超 100ms</td></tr><tr><td>Redis Set</td><td>将已存在订单号存入 Redis Set，判断用SISMEMBER</td><td>亿级订单号需占用约 1GB 内存（每个 String 订单号按 16 字节算），成本高</td></tr><tr><td>本地 HashMap</td><td>单机内存存储订单号，判断containsKey</td><td>分布式场景下无法共享数据，节点间数据不一致</td></tr></tbody></table>
<h4 data-id="heading-3">2. 布隆过滤器的核心优势（适配订单场景）</h4>
<p>布隆过滤器是一种 “空间高效的概率型数据结构”，核心优势恰好匹配订单号判重需求：</p>
<ul>
<li><strong>超低成本内存</strong>：存储亿级订单号仅需约 100MB 内存（传统 Redis Set 需 1GB+），降低 90% 内存占用；</li>
</ul>

<ul>
<li><strong>极致查询性能</strong>：判断订单号是否存在仅需 3-5 次哈希计算，耗时 &lt; 1ms，支撑百万 QPS；</li>
</ul>

<ul>
<li><strong>支持海量数据</strong>：理论上可存储无限量数据（仅受位数组大小限制），无需分库分表；</li>
</ul>

<ul>
<li><strong>天然防缓存穿透</strong>：对 “不存在的订单号” 直接在过滤器层拦截，避免穿透到数据库。</li>
</ul>
<p><strong>注意</strong>：布隆过滤器有 “误判率”（判断为存在的订单号，实际可能不存在），但无 “漏判率”（判断为不存在的订单号，实际一定不存在）—— 这对订单场景完全可控（误判可通过数据库二次校验解决）。</p>
<h3 data-id="heading-4">二、布隆过滤器原理：3 分钟看懂核心逻辑</h3>
<p>布隆过滤器的原理很简单，核心是 “<strong>多哈希函数 + 位数组</strong>”，用 “概率换空间”：</p>
<h4 data-id="heading-5">1. 核心结构</h4>
<ul>
<li><strong>位数组（Bit Array）</strong> ：初始时所有位都是 0（比如长度为 10 的位数组：[0,0,0,0,0,0,0,0,0,0]）；</li>
</ul>

<ul>
<li><strong>多个哈希函数（Hash Function）</strong> ：比如 3 个独立的哈希函数（h1, h2, h3），每个函数能将订单号映射为位数组的一个索引。</li>
</ul>
<h4 data-id="heading-6">2. 两个核心操作</h4>
<h5 data-id="heading-7">（1）添加订单号（Add）</h5>
<p>以订单号ORDER123为例：</p>
<ol>
<li>用 3 个哈希函数分别计算ORDER123的哈希值，映射为位数组的 3 个索引（如 h1=2, h2=5, h3=7）；</li>
</ol>

<ol start="2">
<li>将位数组中这 3 个索引的位从 0 设为 1（此时数组变为：[0,0,1,0,0,1,0,1,0,0]）。</li>
</ol>
<h5 data-id="heading-8">（2）判断订单号是否存在（Contains）</h5>
<p>同样以ORDER123为例：</p>
<ol>
<li>用相同的 3 个哈希函数计算索引（h1=2, h2=5, h3=7）；</li>
</ol>

<ol start="2">
<li>检查位数组中这 3 个索引的位是否<strong>全部为 1</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li>全部为 1：判断 “可能存在”（有一定误判率）；</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>至少一个为 0：判断 “一定不存在”（无漏判）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-9">3. 订单场景关键特性解读</h4>
<ul>
<li><strong>误判率</strong>：因不同订单号可能映射到相同的索引位（哈希碰撞），导致 “不存在的订单号被判断为存在”。误判率可通过 “增大位数组长度”“增加哈希函数数量” 降低（如亿级订单号，误判率可控制在 0.1% 以下）；</li>
</ul>

<ul>
<li><strong>不支持删除</strong>：位数组的位是 “0→1” 的单向操作，无法删除（删除会影响其他订单号的判断）—— 这对订单场景影响不大（订单号一旦生成，很少需要 “从判重池中删除”）；</li>
</ul>

<ul>
<li><strong>无漏判率</strong>：只要订单号未添加过，其映射的索引位必有至少一个为 0，确保 “不存在的订单号一定被拦截”。</li>
</ul>
<h3 data-id="heading-10">三、订单号场景布隆过滤器设计：参数与适配</h3>
<p>布隆过滤器的性能与误判率完全依赖参数设计，需结合订单号的业务特性（如订单号格式、预计数量、误判容忍度）定制。</p>
<h4 data-id="heading-11">1. 订单号特性分析</h4>
<ul>
<li><strong>唯一性</strong>：订单号全局唯一（如20251115123456789，18 位数字 + 时间戳）；</li>
</ul>

<ul>
<li><strong>数量规模</strong>：预计 1 年内生成 1 亿个订单（需按 2 亿预留，避免位数组过早满）；</li>
</ul>

<ul>
<li><strong>误判容忍度</strong>：误判率≤0.1%（误判会导致 “不存在的订单号被拦截”，影响用户体验，需严格控制）；</li>
</ul>

<ul>
<li><strong>查询频率</strong>：每秒查询 10 万次（秒杀场景可能达百万 QPS）。</li>
</ul>
<h4 data-id="heading-12">2. 核心参数计算（关键！）</h4>
<p>布隆过滤器的核心参数有 3 个：<strong>位数组长度（m）</strong> 、<strong>哈希函数数量（k）</strong> 、<strong>预计元素数量（n）</strong> 、<strong>误判率（p）</strong> 。四者满足以下公式：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">m</span> = - (n * ln p) / (ln <span class="hljs-number">2</span>)^<span class="hljs-number">2</span>  （位数组长度）
<span class="hljs-attr">k</span> = (m / n) * ln <span class="hljs-number">2</span>            （哈希函数数量）
</code></pre>
<h5 data-id="heading-13">订单场景参数计算示例（n=2 亿，p=0.1%）：</h5>
<ul>
<li>代入公式计算：</li>
</ul>

<ul>
<li>
<ul>
<li>m ≈ - (2e8 * ln 0.001) / (ln 2)^2 ≈ 2.88e9 位 → 约 360MB（1GB=8e9 位）；</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>k ≈ (2.88e9 / 2e8) * 0.693 ≈ 10 个哈希函数。</li>
</ul>
</li>
</ul>
<h5 data-id="heading-14">结论：</h5>
<p>用 “360MB 位数组 + 10 个哈希函数”，可存储 2 亿个订单号，误判率控制在 0.1% 以下 —— 完全满足订单场景需求，且内存成本极低。</p>
<h4 data-id="heading-15">3. 订单号适配：哈希函数选择</h4>
<p>订单号通常是字符串或长整数，需选择 “分布均匀、碰撞率低” 的哈希函数，避免因哈希函数不佳导致误判率升高。推荐选择：</p>
<ul>
<li><strong>MurmurHash3</strong>：速度快、分布均匀，支持 32 位 / 64 位哈希值（适合字符串型订单号）；</li>
</ul>

<ul>
<li><strong>CRC32</strong>：计算快，适合短订单号（如 16 位以内）；</li>
</ul>

<ul>
<li><strong>组合哈希</strong>：用多个不同类型的哈希函数（如 MurmurHash3+CRC32），进一步降低碰撞率。</li>
</ul>
<p><strong>注意</strong>：添加与查询必须使用<strong>完全相同的哈希函数</strong>，否则会导致判断结果错误。</p>
<h3 data-id="heading-16">四、实现方案：单机与分布式（附代码）</h3>
<p>订单系统分为 “单机” 和 “分布式” 场景，布隆过滤器的实现方案不同，需分别适配。</p>
<h4 data-id="heading-17">1. 单机场景：Guava BloomFilter（快速落地）</h4>
<p>适合 “单服务、订单量≤1 亿” 的场景（如小型电商、内部订单系统），直接用 Google Guava 的 BloomFilter 实现，无需额外部署组件。</p>
<h5 data-id="heading-18">（1）依赖引入（Maven）</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>32.1.3-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 选择最新稳定版 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h5 data-id="heading-19">（2）核心代码实现（订单号判重）</h5>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> com.google.common.base.Charsets;
<span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;
<span class="hljs-keyword">import</span> com.google.common.hash.Funnel;
<span class="hljs-keyword">import</span> com.google.common.hash.HashFunction;
<span class="hljs-keyword">import</span> com.google.common.hash.Hashing;
<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;
<span class="hljs-comment">/**
 * 单机版订单号布隆过滤器（Guava实现）
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderBloomFilter</span> {
    <span class="hljs-comment">// 布隆过滤器实例（单例，避免重复创建）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> BloomFilter&lt;<span class="hljs-type">String</span>&gt; ORDER_BLOOM_FILTER;
    
    <span class="hljs-comment">// 订单号漏斗（定义如何将订单号转换为哈希输入，需与哈希函数匹配）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> Funnel&lt;<span class="hljs-type">String</span>&gt; ORDER_FUNNEL = (orderId, into) -&gt; into.<span class="hljs-built_in">putString</span>(orderId, Charsets.UTF_8);
    
    <span class="hljs-comment">// 静态初始化：按参数创建布隆过滤器</span>
    <span class="hljs-type">static</span> {
        <span class="hljs-type">long</span> expectedInsertions = <span class="hljs-number">200</span>_000_000; <span class="hljs-comment">// 预计插入2亿个订单号</span>
        <span class="hljs-type">double</span> fpp = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// 误判率0.1%</span>
        <span class="hljs-comment">// 创建布隆过滤器（使用MurmurHash3哈希函数）</span>
        ORDER_BLOOM_FILTER = BloomFilter.<span class="hljs-built_in">create</span>(ORDER_FUNNEL, expectedInsertions, fpp);
    }
    
    <span class="hljs-comment">// 禁止外部实例化</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">OrderBloomFilter</span><span class="hljs-params">()</span> </span>{}
    
    <span class="hljs-comment">/**
     * 添加订单号到布隆过滤器
     * @param orderId 订单号
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">addOrderId</span><span class="hljs-params">(<span class="hljs-type">String</span> orderId)</span> </span>{
        <span class="hljs-keyword">if</span> (orderId == null || orderId.<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-string">"订单号不能为空"</span>);
        }
        ORDER_BLOOM_FILTER.<span class="hljs-built_in">put</span>(orderId);
    }
    
    <span class="hljs-comment">/**
     * 判断订单号是否可能存在（true=可能存在，false=一定不存在）
     * @param orderId 订单号
     * @return 存在性判断
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">mightContainOrderId</span><span class="hljs-params">(<span class="hljs-type">String</span> orderId)</span> </span>{
        <span class="hljs-keyword">if</span> (orderId == null || orderId.<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> ORDER_BLOOM_FILTER.<span class="hljs-built_in">mightContain</span>(orderId);
    }
    
    <span class="hljs-comment">// 测试示例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>{
        <span class="hljs-type">String</span> orderId1 = <span class="hljs-string">"20251115123456789"</span>;
        <span class="hljs-type">String</span> orderId2 = <span class="hljs-string">"20251115987654321"</span>;
        
        <span class="hljs-comment">// 添加orderId1</span>
        OrderBloomFilter.<span class="hljs-built_in">addOrderId</span>(orderId1);
        
        <span class="hljs-comment">// 判断存在性</span>
        System.out.<span class="hljs-built_in">println</span>(OrderBloomFilter.<span class="hljs-built_in">mightContainOrderId</span>(orderId1)); <span class="hljs-comment">// true（存在）</span>
        System.out.<span class="hljs-built_in">println</span>(OrderBloomFilter.<span class="hljs-built_in">mightContainOrderId</span>(orderId2)); <span class="hljs-comment">// false（不存在）</span>
    }
}
</code></pre>
<h5 data-id="heading-20">（3）订单判重流程整合</h5>
<p>将布隆过滤器嵌入订单创建流程，实现 “先过滤，再校验”：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 订单服务（整合布隆过滤器）
 */</span>
<span class="hljs-keyword">@Service</span>
public class OrderService {
    <span class="hljs-keyword">@Autowired</span>
    private OrderMapper orderMapper; <span class="hljs-comment">// 订单数据库DAO</span>
    
    <span class="hljs-comment">/**
     * 创建订单（先布隆过滤器过滤，再数据库校验）
     */</span>
    public String <span class="hljs-built_in">createOrder</span>(OrderDTO orderDTO) {
        String orderId = <span class="hljs-built_in">generateOrderId</span>(); <span class="hljs-comment">// 生成订单号</span>
        
        <span class="hljs-comment">// 步骤1：布隆过滤器快速判断</span>
        if (OrderBloomFilter.mightContainOrderId(orderId)) {
            <span class="hljs-comment">// 步骤2：可能存在，查数据库二次校验（解决误判）</span>
            OrderDO existOrder = orderMapper<span class="hljs-selector-class">.selectByOrderId</span>(orderId);
            if (existOrder != null) {
                throw new <span class="hljs-built_in">BusinessException</span>("订单号已存在，请勿重复提交");
            }
        }
        
        <span class="hljs-comment">// 步骤3：订单不存在，创建订单</span>
        OrderDO orderDO = <span class="hljs-built_in">convertToOrderDO</span>(orderDTO, orderId);
        orderMapper<span class="hljs-selector-class">.insert</span>(orderDO);
        
        <span class="hljs-comment">// 步骤4：将新订单号添加到布隆过滤器</span>
        OrderBloomFilter<span class="hljs-selector-class">.addOrderId</span>(orderId);
        
        return orderId;
    }
    
    <span class="hljs-comment">// 生成订单号（时间戳+随机数，确保唯一）</span>
    private String <span class="hljs-built_in">generateOrderId</span>() {
        return new <span class="hljs-built_in">SimpleDateFormat</span>("yyyyMMddHHmmss")<span class="hljs-selector-class">.format</span>(new Date()) 
                + RandomUtils<span class="hljs-selector-class">.nextInt</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">9999</span>);
    }
}
</code></pre>
<h4 data-id="heading-21">2. 分布式场景：Redis 布隆过滤器（高可用）</h4>
<p>适合 “多服务、分布式订单系统”（如大型电商、支付平台），需用 Redis 布隆过滤器实现 “跨服务数据共享”（Redis Cluster 支持分布式部署，避免单点故障）。</p>
<p>Redis 4.0 + 通过redisbloom模块支持布隆过滤器，提供BF.ADD（添加）、BF.EXISTS（判断）、BF.RESERVE（初始化）等命令。</p>
<h5 data-id="heading-22">（1）Redis 布隆过滤器初始化（关键参数）</h5>
<p>先通过BF.RESERVE命令初始化过滤器（按订单场景参数）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># BF.RESERVE key error_rate capacity [EXPANSION expansion]</span>
<span class="hljs-comment"># key=order_bloom_filter，error_rate=0.001（误判率），capacity=200000000（预计2亿订单）</span>
BF.RESERVE order_bloom_filter 0.001 200000000
</code></pre>
<ul>
<li>EXPANSION：可选参数，当位数组满时，新扩展的位数组大小是原数组的倍数（默认 2），避免频繁扩容。</li>
</ul>
<h5 data-id="heading-23">（2）Java 代码实现（Spring Boot 整合）</h5>
<p>引入 Redis 依赖，用RedisTemplate调用 Redis 布隆过滤器命令：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> javax.annotation.Resource;
<span class="hljs-comment">/**
 * 分布式订单号布隆过滤器（Redis实现）
 */</span>
@Component
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisOrderBloomFilter</span> {
    <span class="hljs-comment">// Redis布隆过滤器key</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> ORDER_BLOOM_KEY = <span class="hljs-string">"order:bloom:filter"</span>;
    <span class="hljs-comment">// 误判率（与Redis初始化时一致）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> ERROR_RATE = <span class="hljs-number">0.001</span>;
    <span class="hljs-comment">// 预计订单数量（与Redis初始化时一致）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> EXPECTED_ORDER_COUNT = <span class="hljs-number">200</span>_000_000;
    
    @Resource
    <span class="hljs-keyword">private</span> RedisTemplate&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; redisTemplate;
    
    <span class="hljs-comment">/**
     * 初始化Redis布隆过滤器（项目启动时执行一次）
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">initBloomFilter</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 判断过滤器是否已存在，不存在则初始化</span>
        Boolean exists = redisTemplate.<span class="hljs-built_in">hasKey</span>(ORDER_BLOOM_KEY);
        <span class="hljs-keyword">if</span> (Boolean.FALSE.<span class="hljs-built_in">equals</span>(exists)) {
            <span class="hljs-comment">// 调用BF.RESERVE命令初始化</span>
            redisTemplate.<span class="hljs-built_in">execute</span>((connection) -&gt; {
                <span class="hljs-type">byte</span>[] key = ORDER_BLOOM_KEY.<span class="hljs-built_in">getBytes</span>();
                <span class="hljs-keyword">return</span> connection.<span class="hljs-built_in">execute</span>(<span class="hljs-string">"BF.RESERVE"</span>, 
                        key, 
                        <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(ERROR_RATE).<span class="hljs-built_in">getBytes</span>(), 
                        <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(EXPECTED_ORDER_COUNT).<span class="hljs-built_in">getBytes</span>());
            }, <span class="hljs-literal">true</span>);
        }
    }
    
    <span class="hljs-comment">/**
     * 添加订单号到Redis布隆过滤器
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">addOrderId</span><span class="hljs-params">(<span class="hljs-type">String</span> orderId)</span> </span>{
        <span class="hljs-keyword">if</span> (orderId == null || orderId.<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 调用BF.ADD命令添加</span>
        redisTemplate.<span class="hljs-built_in">execute</span>((connection) -&gt; {
            <span class="hljs-type">byte</span>[] key = ORDER_BLOOM_KEY.<span class="hljs-built_in">getBytes</span>();
            <span class="hljs-type">byte</span>[] value = orderId.<span class="hljs-built_in">getBytes</span>();
            <span class="hljs-keyword">return</span> connection.<span class="hljs-built_in">execute</span>(<span class="hljs-string">"BF.ADD"</span>, key, value);
        }, <span class="hljs-literal">true</span>);
    }
    
    <span class="hljs-comment">/**
     * 判断订单号是否可能存在
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">mightContainOrderId</span><span class="hljs-params">(<span class="hljs-type">String</span> orderId)</span> </span>{
        <span class="hljs-keyword">if</span> (orderId == null || orderId.<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-comment">// 调用BF.EXISTS命令判断</span>
        <span class="hljs-keyword">return</span> (Boolean) redisTemplate.<span class="hljs-built_in">execute</span>((connection) -&gt; {
            <span class="hljs-type">byte</span>[] key = ORDER_BLOOM_KEY.<span class="hljs-built_in">getBytes</span>();
            <span class="hljs-type">byte</span>[] value = orderId.<span class="hljs-built_in">getBytes</span>();
            <span class="hljs-keyword">return</span> connection.<span class="hljs-built_in">execute</span>(<span class="hljs-string">"BF.EXISTS"</span>, key, value);
        }, <span class="hljs-literal">true</span>);
    }
}
</code></pre>
<h5 data-id="heading-24">（3）分布式订单判重流程</h5>
<p>与单机场景类似，但需注意 “分布式一致性”（多服务同时添加订单号，需确保 Redis 操作原子性）：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Service</span>
public class DistributedOrderService {
    <span class="hljs-keyword">@Autowired</span>
    private OrderMapper orderMapper;
    
    <span class="hljs-keyword">@Autowired</span>
    private RedisOrderBloomFilter redisOrderBloomFilter;
    
    <span class="hljs-keyword">@Autowired</span>
    private RedissonClient redissonClient; <span class="hljs-comment">// 分布式锁，确保订单创建原子性</span>
    
    public String <span class="hljs-built_in">createOrder</span>(OrderDTO orderDTO) {
        String orderId = <span class="hljs-built_in">generateOrderId</span>();
        <span class="hljs-comment">// 分布式锁：避免同一订单号被多个服务同时创建（双重保险）</span>
        RLock lock = redissonClient<span class="hljs-selector-class">.getLock</span>("order:create:" + orderId);
        lock<span class="hljs-selector-class">.lock</span>(<span class="hljs-number">5</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 锁超时5秒</span>
        
        try {
            <span class="hljs-comment">// 步骤1：Redis布隆过滤器判断</span>
            if (redisOrderBloomFilter.mightContainOrderId(orderId)) {
                <span class="hljs-comment">// 步骤2：数据库二次校验</span>
                OrderDO existOrder = orderMapper<span class="hljs-selector-class">.selectByOrderId</span>(orderId);
                if (existOrder != null) {
                    throw new <span class="hljs-built_in">BusinessException</span>("订单号已存在");
                }
            }
            
            <span class="hljs-comment">// 步骤3：创建订单</span>
            OrderDO orderDO = <span class="hljs-built_in">convertToOrderDO</span>(orderDTO, orderId);
            orderMapper<span class="hljs-selector-class">.insert</span>(orderDO);
            
            <span class="hljs-comment">// 步骤4：添加到Redis布隆过滤器（Redis操作是原子的）</span>
            redisOrderBloomFilter<span class="hljs-selector-class">.addOrderId</span>(orderId);
            
            return orderId;
        } finally {
            lock<span class="hljs-selector-class">.unlock</span>(); <span class="hljs-comment">// 释放锁</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-25">五、工程落地避坑：订单场景特殊问题解决</h3>
<p>布隆过滤器在订单场景的落地中，会遇到 “误判影响”“数据持久化”“过期订单处理” 等问题，需针对性解决。</p>
<h4 data-id="heading-26">1. 误判率控制：避免影响用户体验</h4>
<p>误判会导致 “不存在的订单号被判断为存在”，进而触发数据库校验 —— 虽然不影响正确性，但会增加数据库压力。解决方案：</p>
<ul>
<li><strong>参数精细化</strong>：按 “预计订单量的 2 倍” 设计位数组（避免位数组过早满，导致误判率升高）；</li>
</ul>

<ul>
<li><strong>分层校验</strong>：对 “高频查询的订单号”（如最近 1 天的订单），额外存入 Redis Set，优先查 Redis Set，再查布隆过滤器（降低数据库校验频率）；</li>
</ul>

<ul>
<li><strong>误判监控</strong>：统计 “布隆过滤器判断存在，但数据库实际不存在” 的次数（误判次数），当误判率超过阈值（如 0.5%）时，触发告警并扩容位数组。</li>
</ul>
<h4 data-id="heading-27">2. 数据持久化：避免 Redis 重启丢失</h4>
<p>Redis 布隆过滤器的数据默认存在内存中，Redis 重启后会丢失 —— 导致 “已存在的订单号被判断为不存在”，引发重复创建。解决方案：</p>
<ul>
<li><strong>Redis 持久化</strong>：开启 Redis 的 RDB（定时快照）+ AOF（日志）持久化，确保 Redis 重启后数据恢复；</li>
</ul>

<ul>
<li><strong>冷加载</strong>：项目启动时，从数据库读取 “所有已存在的订单号”，批量添加到布隆过滤器（注意：亿级订单号冷加载需分批处理，避免阻塞服务启动）；</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">// 冷加载示例（分批读取，每次1000条）
public void loadHistoryOrderIds() {
    long <span class="hljs-attr">total</span> = orderMapper.countAll()<span class="hljs-comment">;</span>
    long <span class="hljs-attr">batchSize</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;</span>
    long <span class="hljs-attr">batchNum</span> = (total + batchSize - <span class="hljs-number">1</span>) / batchSize<span class="hljs-comment">;</span>
    
    for (long <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; batchNum; i++) {</span>
        List&lt;String&gt; <span class="hljs-attr">orderIds</span> = orderMapper.selectOrderIdByPage(i * batchSize, batchSize)<span class="hljs-comment">;</span>
        for (String orderId : orderIds) {
            redisOrderBloomFilter.addOrderId(orderId)<span class="hljs-comment">;</span>
        }
        // 每批加载后休眠100ms，避免压垮Redis
        try {
            Thread.sleep(100)<span class="hljs-comment">;</span>
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt()<span class="hljs-comment">;</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-28">3. 过期订单处理：避免位数组膨胀</h4>
<p>订单号一旦生成，很少需要删除，但 “超期未支付的订单”（如 24 小时未支付自动取消）是否需要从布隆过滤器中删除？—— 因布隆过滤器不支持删除，解决方案：</p>
<ul>
<li><strong>分时段布隆过滤器</strong>：按 “天” 创建布隆过滤器（如order:bloom:filter:20251115），只保留最近 30 天的订单号；</li>
</ul>

<ul>
<li><strong>查询时多过滤器判断</strong>：判断订单号是否存在时，查询 “当天 + 近 30 天” 的所有过滤器，只要有一个过滤器判断 “可能存在”，就进行数据库校验；</li>
</ul>

<ul>
<li><strong>过期过滤器清理</strong>：每天凌晨删除 “30 天前” 的过滤器（如DEL order:bloom:filter:20251015），避免 Redis 内存膨胀。</li>
</ul>
<h4 data-id="heading-29">4. 高并发安全：避免竞态条件</h4>
<p>分布式场景下，多个服务同时创建同一订单号，可能导致 “布隆过滤器未添加，但数据库已插入”（竞态条件）。解决方案：</p>
<ul>
<li><strong>分布式锁</strong>：如前文代码，用 Redisson 分布式锁锁定 “订单号”，确保同一订单号的创建操作串行执行；</li>
</ul>

<ul>
<li><strong>数据库唯一索引</strong>：在order_id字段加唯一索引，即使布隆过滤器失效，数据库也能拦截重复插入（最后一道防线）。</li>
</ul>
<h3 data-id="heading-30">六、方案对比与选型建议</h3>

































<table><thead><tr><th>场景</th><th>推荐方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>单机 / 小订单量</td><td>Guava BloomFilter</td><td>无额外依赖，部署简单，延迟低</td><td>不支持分布式，内存受限</td><td>内部系统、订单量≤1 亿</td></tr><tr><td>分布式 / 大订单量</td><td>Redis 布隆过滤器</td><td>分布式共享，高可用，支持海量数据</td><td>依赖 Redis，延迟略高（~1ms）</td><td>电商、支付平台、订单量≥1 亿</td></tr><tr><td>超大规模 / 低延迟</td><td>Redis 布隆 Filter + 本地缓存</td><td>兼顾分布式与低延迟</td><td>实现复杂，需同步本地与 Redis</td><td>秒杀、高频下单场景</td></tr></tbody></table>
<h3 data-id="heading-31">总结</h3>
<p>用布隆过滤器过滤已存在订单号的核心是 “<strong>用概率换空间，用二次校验补误判</strong>”：</p>
<ul>
<li>原理上，通过 “多哈希函数 + 位数组” 实现高效判重，无漏判、低内存；</li>
</ul>

<ul>
<li>实现上，单机用 Guava 快速落地，分布式用 Redis 布隆过滤器保证共享；</li>
</ul>

<ul>
<li>落地时，重点解决 “误判率控制”“数据持久化”“分布式安全” 三大问题，结合数据库唯一索引做最后防线。</li>
</ul>
<p>对订单场景而言，布隆过滤器不是 “替代数据库 / Redis”，而是 “前置过滤层”—— 通过拦截 99.9% 的 “不存在订单号查询”，大幅降低数据库压力，支撑高并发订单创建。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite 5.x 开发模式启动流程分析]]></title>    <link>https://juejin.cn/post/7572459217811243071</link>    <guid>https://juejin.cn/post/7572459217811243071</guid>    <pubDate>2025-11-15T06:42:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459217811243071" data-draft-id="7572485825705263113" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite 5.x 开发模式启动流程分析"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-15T06:42:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拿不拿铁19"/> <meta itemprop="url" content="https://juejin.cn/user/3417747845299064"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite 5.x 开发模式启动流程分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3417747845299064/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拿不拿铁19
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T06:42:33.000Z" title="Sat Nov 15 2025 06:42:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读28分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vite 5.x 开发模式启动流程分析</h2>
<p>Vite 作为新一代前端构建工具，其核心优势在于开发模式下的<strong>极速启动</strong>和<strong>热模块替换（HMR）<strong>能力。与 Webpack 等传统构建工具的“先打包再启动”模式不同，Vite 基于 ES 模块（ESM）的原生支持，采用“按需编译”策略，大幅提升开发体验。本文将详细拆解 Vite 5.x 版本在开发模式下的</strong>首次启动流程</strong>和<strong>代码更新流程</strong> <strong>。</strong></p>
<h3 data-id="heading-1">一、核心前置知识</h3>
<p>在分析流程前，需明确 Vite 开发模式的两个核心设计：</p>
<ol>
<li>
<p><strong>原生 ESM 支持</strong>：现代浏览器已原生支持 <code>import</code>/<code>export</code>，Vite 直接将项目源码以 ESM 格式交给浏览器，避免传统构建工具的全量打包过程。</p>
</li>
<li>
<p><strong>按需编译</strong>：仅当浏览器请求某个模块时，Vite 才会对该模块进行编译（如 TypeScript 转 JS、Sass 转 CSS 等），而非启动时编译所有文件。</p>
</li>
<li>
<p><strong>依赖预构建</strong>：对第三方依赖（如 <code>node_modules</code> 中的包）进行预构建，将非 ESM 格式的依赖转为 ESM 格式，并合并重复依赖，减少请求次数。</p>
</li>
</ol>
<h3 data-id="heading-2">二、首次启动流程（开发模式）</h3>
<p>首次启动是指项目从“未运行”到“浏览器可访问”的完整过程，核心分为「依赖预构建」「服务启动」「页面请求与模块编译」三个阶段，共 8 个关键步骤。以下以 Vue 3 + TypeScript 项目（初始化命令：<code>npm create vite@latest my-vue-app -- --template vue-ts</code>）为例进行说明。</p>
<h4 data-id="heading-3">阶段 1：依赖预构建（启动前的准备）</h4>
<p>依赖预构建是 Vite 首次启动的核心优化步骤，目的是解决第三方依赖的兼容性和性能问题，仅在首次启动或依赖变动时执行。</p>
<h5 data-id="heading-4">步骤 1：解析依赖图谱</h5>
<p>Vite 启动时会先读取项目根目录的 <code>package.json</code>，识别 <code>dependencies</code> 中的第三方依赖（如 <code>vue</code>、<code>@vue/compiler-sfc</code> 等），并通过 <code>esbuild</code> 快速解析这些依赖的依赖图谱（即依赖的依赖，如 <code>vue</code> 依赖的 <code>@vue/runtime-core</code>）。解析完成后，会生成依赖关系数据并暂存于内存，同时为后续预构建产物生成提供依据，最终体现在预构建阶段输出的 <code>node_modules/.vite/_metadata.json</code> 缓存文件中。</p>
<p><strong>示</strong> <strong>例</strong>：在 Vue 3 项目中，Vite 会解析出 <code>vue</code> 及其关联的运行时、编译器等子依赖，形成完整的依赖链。该依赖链信息会被记录到 <code>_metadata.json</code> 的 <code>dependencyGraph</code> 字段中，示例如下：</p>
<pre><code class="hljs language-json" lang="json">
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencyGraph"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@vue/runtime-core"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"@vue/runtime-dom"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"createApp"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"ref"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"reactive"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_modules/.vite/deps/vue.js"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vue-router"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"vue"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"createRouter"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_modules/.vite/deps/vue-router.js"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"optimized"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"src"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_modules/vue/dist/vue.runtime.esm-bundler.js"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node_modules/.vite/deps/vue.js"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"hash"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1a2b3c"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>该缓存文件中的依赖图谱信息，会用于后续启动时快速校验依赖是否变动（如子依赖版本更新会导致 <code>dependencyGraph</code> 变化），从而决定是否需要重新执行预构建。</p>
<h5 data-id="heading-5">步骤 2：预构建非 ESM 依赖</h5>
<p>部分第三方依赖（如一些老的 npm 包）仍采用 CommonJS 格式（<code>module.exports</code>/<code>require</code>），浏览器无法直接识别。Vite 会通过 <code>esbuild</code> 将这些非 ESM 依赖转为 ESM 格式。</p>
<p><strong>示</strong> <strong>例</strong>：若项目中引入了采用 CommonJS 格式的 <code>lodash@4.17.21</code>，Vite 会将其编译为 ESM 格式，生成可被浏览器直接导入的代码：</p>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-comment">// 编译前（CommonJS）</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">debounce</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">func, wait</span>) { ... }
};

<span class="hljs-comment">// 编译后（ESM）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) { ... };
</code></pre>
<h5 data-id="heading-6">步骤 3：生成预构建产物</h5>
<p>预构建后的依赖产物会被存入项目根目录的 <code>node_modules/.vite/deps</code> 目录中（Vite 2.x 为 <code>node_modules/.vite</code>，Vite 3.x 及以上版本统一迁移至 <code>deps</code> 子目录），同时生成 <code>node_modules/.vite/_metadata.json</code> 缓存文件（替代旧版本的 <code>deps_cache.json</code>），用于后续启动时判断依赖是否变动（若未变动则跳过预构建）。</p>
<p><strong>示例</strong>：<code>node_modules/.vite/</code> <code>deps/</code> <code>vue.js</code> 即为 <code>vue</code> 预构建后的 ESM 产物，可直接被浏览器导入。</p>
<h5 data-id="heading-7">步骤 4：合并重复依赖（ deduplication ）</h5>
<p>若多个依赖同时依赖某个子依赖（如 <code>vue-router</code> 和 <code>pinia</code> 都依赖 <code>vue</code>），Vite 会将重复的子依赖合并为一个模块，避免浏览器重复请求。</p>
<p><strong>示</strong> <strong>例</strong>：<code>vue-router@4</code> 和 <code>pinia@2</code> 均依赖 <code>vue@3</code>，预构建时会将 <code>vue</code> 抽离为单独模块，供两者共同引用。具体引用逻辑如下：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">// 1. 预构建前：vue-router 和 pinia 各自内部引用 vue</span>
<span class="hljs-comment">// vue-router 内部代码（简化）</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./node_modules/vue/dist/vue.runtime.esm-bundler.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRouter</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* 依赖 Vue 实现逻辑 */</span> }

<span class="hljs-comment">// pinia 内部代码（简化）</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./node_modules/vue/dist/vue.runtime.esm-bundler.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPinia</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* 依赖 Vue 实现逻辑 */</span> }

<span class="hljs-comment">// 2. 预构建后：合并为共同引用预构建的 vue 模块</span>
<span class="hljs-comment">// 预构建产物：node_modules/.vite/deps/vue.js（单独模块，Vite 5.x 路径）</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 预构建后 vue-router 产物（简化）</span>
<span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'/node_modules/.vite/deps/vue.js?v=1a2b3c'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRouter</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* 依赖共享的 Vue API 实现逻辑 */</span> }

<span class="hljs-comment">// 预构建后 pinia 产物（简化）</span>
<span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'/node_modules/.vite/deps/vue.js?v=1a2b3c'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPinia</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* 依赖共享的 Vue API 实现逻辑 */</span> }
</code></pre>
<p>通过合并，浏览器仅需请求一次 <code>/node_modules/.vite/deps/vue.js</code> 即可满足两个依赖的需求，避免了重复请求导致的性能损耗。</p>
<h5 data-id="heading-8"/>
<h4 data-id="heading-9">阶段 2：开发服务器启动</h4>
<p>依赖预构建完成后，Vite 会启动一个基于 <code>connect</code> 的开发服务器，用于处理浏览器的请求、提供模块编译服务和 HMR 支持。</p>
<h5 data-id="heading-10">步骤 5：初始化服务器配置</h5>
<p>Vite 读取项目中的 <code>vite.config.ts</code>（或 <code>.js</code>）配置文件，初始化服务器参数，如端口（默认 5173）、代理（<code>server.proxy</code>）、跨域（<code>server.cors</code>）等。</p>
<p><strong>示</strong> <strong>例</strong>：若配置了代理解决跨域问题：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">'/api'</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://localhost:3000'</span>, <span class="hljs-comment">// 后端服务地址</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">''</span>)
      }
    }
  }
});
</code></pre>
<p>Vite 会将服务器的 <code>/api</code> 路径请求代理到 <code>http://localhost:3000</code>。</p>
<h5 data-id="heading-11">步骤 6：启动服务器并监听端口</h5>
<p>基于 <code>connect</code> 启动 HTTP 服务器，监听配置的端口（默认 5173），同时注册一系列核心中间件。从本质上来说，中间件是<strong>拦截并处理 HTTP 请求的“管道式”函数</strong>——浏览器的请求会按顺序流经各个中间件，每个中间件完成特定职责（如编译、缓存、代理）后，要么将请求传递给下一个中间件，要么直接返回响应结果，类似工厂流水线中“各司其职、依次处理”的工序。其核心特性是“职责单一”和“顺序执行”，通过组合不同中间件实现复杂的请求处理逻辑，也让功能扩展更灵活（如新增预处理语法支持时，仅需添加对应编译中间件）。</p>
<p>为更直观理解中间件的“管道式”工作逻辑，以下通过模拟 Vite 核心中间件的简化代码，展示请求从接收至响应的流转过程（基于 connect 中间件机制）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 模拟 Vite 开发服务器中间件管道（简化版）</span>
<span class="hljs-keyword">import</span> connect <span class="hljs-keyword">from</span> <span class="hljs-string">'connect'</span>;
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">connect</span>(); <span class="hljs-comment">// 创建 connect 服务器实例</span>

<span class="hljs-comment">// 1. 日志中间件（模拟请求入口记录）</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[请求接收] <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()}</span> - <span class="hljs-subst">${req.url}</span>`</span>);
  <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 调用 next() 传递给下一个中间件</span>
});

<span class="hljs-comment">// 2. 静态资源中间件（模拟处理图片等静态资源）</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> staticExts = [<span class="hljs-string">'.png'</span>, <span class="hljs-string">'.jpg'</span>, <span class="hljs-string">'.svg'</span>];
  <span class="hljs-keyword">const</span> isStatic = staticExts.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">ext</span> =&gt;</span> req.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(ext));
  <span class="hljs-keyword">if</span> (isStatic) {
    <span class="hljs-comment">// 模拟读取静态文件并返回</span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'image/svg+xml'</span> });
    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'&lt;svg width="100" height="100"&gt;&lt;circle cx="50" cy="50" r="40" fill="#42b983"/&gt;&lt;/svg&gt;'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 非静态资源，传递给下一个中间件</span>
  }
});

<span class="hljs-comment">// 3. 模块编译中间件（模拟处理 .vue 模块）</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.vue'</span>)) {
    <span class="hljs-comment">// 模拟 Vue 组件编译：模板转渲染函数 + 脚本处理</span>
    <span class="hljs-keyword">const</span> componentName = req.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">'/'</span>).<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-string">'.vue'</span>, <span class="hljs-string">''</span>);
    <span class="hljs-keyword">const</span> compiledCode = <span class="hljs-string">`
      import { h } from '/node_modules/.vite/deps/vue.js';
      export default {
        name: '<span class="hljs-subst">${componentName}</span>',
        render() { return h('div', '编译后的<span class="hljs-subst">${componentName}</span>组件'); }
      }
    `</span>;
    <span class="hljs-comment">// 返回编译后的 ESM 代码</span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/javascript'</span> });
    res.<span class="hljs-title function_">end</span>(compiledCode);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 非 .vue 模块，传递给下一个中间件</span>
  }
});

<span class="hljs-comment">// 4. 错误处理中间件（捕获后续中间件抛出的错误）</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[请求错误] <span class="hljs-subst">${err.message}</span>`</span>);
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">500</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`服务器错误：<span class="hljs-subst">${err.message}</span>`</span>);
});

<span class="hljs-comment">// 启动服务器</span>
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5173</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开发服务器启动：http://localhost:5173'</span>);
});
</code></pre>
<p>上述代码核心逻辑与 Vite 实际中间件机制一致：</p>
<ul>
<li>
<p>通过 <code>app.use()</code> 按顺序注册中间件，请求会依次流经日志→静态资源→模块编译中间件；</p>
</li>
<li>
<p>每个中间件通过 <code>next()</code> 传递请求，若能处理当前请求（如静态资源中间件处理 .svg 请求）则直接返回响应；</p>
</li>
<li>
<p>错误处理中间件通过特殊的四参数函数定义，可捕获前序中间件抛出的异常并统一处理。</p>
</li>
</ul>
<p>核心中间件及其作用如下：</p>
<ul>
<li>
<p><strong>HMR 中间件（热更新中间件）</strong>：核心作用是建立并维护 WebSocket 长连接，实时向浏览器推送文件变更通知（如代码修改、新增文件），同时接收浏览器的 HMR 状态反馈；当检测到无法热更新的场景时，触发全页刷新逻辑。</p>
</li>
<li>
<p><strong>模块编译中间件</strong>：开发模式的核心中间件，负责拦截浏览器对模块的请求（如 .ts、.vue、.scss 文件），调用对应处理器（如 esbuild、@vitejs/plugin-vue）完成编译、转译和路径重写，将处理后的 ESM 代码或 CSS 内容返回给浏览器；同时会缓存编译结果到内存，提升重复请求的响应速度。</p>
</li>
<li>
<p><strong>静态资源中间件</strong>：处理图片、字体、JSON 等静态资源的请求，直接读取项目根目录下的静态文件并返回；支持对小资源（如小于 4KB 的图片）自动转为 Base64 编码，减少 HTTP 请求次数。</p>
</li>
<li>
<p><strong>HTML 处理中间件</strong>：专门处理入口 HTML 文件（index.html）的请求，完成脚本标签改造（补充 type="module"、注入 /@vite/client）、环境变量注入等操作，确保返回的 HTML 能正确触发后续模块请求。</p>
</li>
<li>
<p><strong>代理中间件</strong>：根据 vite.config.ts 中的 server.proxy 配置，将特定路径的请求（如 /api）转发到目标服务器（如后端开发服务），并处理跨域相关的请求头（如 changeOrigin），解决前端开发中的跨域问题。</p>
</li>
<li>
<p><strong>缓存控制中间件</strong>：为不同类型的响应设置合理的缓存策略，例如对预构建产物（node_modules/.vite/deps 下的文件）添加强缓存头，对源码编译后的模块添加协商缓存头，平衡缓存效率与更新及时性。</p>
</li>
<li>
<p><strong>错误处理中间件</strong>：捕获请求处理过程中的异常（如模块编译失败、文件不存在），将错误信息格式化（如转为友好的页面级错误提示或控制台日志）后返回给浏览器，帮助开发者快速定位问题。</p>
</li>
</ul>
<p>这些中间件按“请求接收→缓存校验→静态资源判断→模块编译/代理转发→热更新通知→响应返回”的流程协同工作，确保开发模式下的请求处理高效且可靠。</p>
<p><strong>示例</strong>：启动成功后，终端会输出以下信息，提示服务器已就绪，所有中间件均已完成初始化：</p>
<pre><code class="hljs language-bash" lang="bash">  VITE v5.0.0 ready <span class="hljs-keyword">in</span> 300 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show <span class="hljs-built_in">help</span>
</code></pre>
<h4 data-id="heading-12">阶段 3：页面请求与模块编译</h4>
<p>服务器启动后，需等待用户在浏览器中访问地址（如 <code>http://localhost:5173</code>），才会触发后续的页面渲染和模块编译流程（按需编译的核心体现）。</p>
<h5 data-id="heading-13">步骤 7：处理入口 HTML 请求</h5>
<p>当用户在浏览器中访问服务器地址时，浏览器首先请求项目的入口 HTML 文件（默认是 <code>index.html</code>）。Vite 会读取根目录的 <code>index.html</code>，并对其中的 <code>script</code> 标签进行改造：将指向源码的 <code>src</code> 路径改为服务器可识别的绝对路径，确保未添加 <code>type="module"</code> 标识时自动补充（因原生 ESM 需该标识才能被浏览器解析），同时注入热更新相关的客户端脚本（<code>/@vite/client</code>），为后续 HMR 功能做准备。</p>
<p><strong>示例</strong>：项目根目录原始 <code>index.html</code> 内容：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite.svg"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + Vue + TS<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.ts"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>示例</strong>：Vite 处理后返回给浏览器的 HTML 内容（关键改造处标红）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite.svg"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + Vue + TS<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/@vite/client"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.ts"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h5 data-id="heading-14">步骤 8：编译入口模块并处理依赖路径</h5>
<p>当浏览器通过处理后的 <code>index.html</code> 发起入口模块请求（如 <code>/src/main.ts</code>）时，Vite 的模块编译中间件会拦截该请求，按“类型识别→语法转译→路径重写→返回结果”的完整流程处理，核心依托 <code>esbuild</code> 实现毫秒级编译。</p>
<h6 data-id="heading-15">1. 模块类型识别与处理逻辑匹配</h6>
<p>Vite 通过请求路径的后缀（如 <code>.ts</code>）快速识别模块类型，自动匹配预设处理逻辑：TypeScript 模块默认使用内置 <code>esbuild</code> 转译器，Vue 组件依赖 <code>@vitejs/plugin-vue</code>，样式文件则根据后缀匹配 Sass/LESS 等预处理插件（若已配置）。</p>
<h6 data-id="heading-16">2. 语法转译与依赖路径重写</h6>
<p>这是入口模块编译的核心环节，针对 TypeScript 模块主要完成两项工作：</p>
<ul>
<li>
<p><strong>语法转译</strong>：<code>esbuild</code> 仅对 TypeScript 进行语法层面转译，剔除类型注解、接口定义等 TS 特有语法，保留 ES6+ 语法（现代浏览器已原生支持），不执行类型检查（类型校验交给 IDE 或 <code>tsc --noEmit</code> 单独执行，提升编译速度）；</p>
</li>
<li>
<p><strong>依赖路径重写</strong>：将源码中第三方依赖的简洁路径（如 <code>import { createApp } from 'vue'</code>）重写为预构建产物的绝对路径（如 <code>/node_modules/.vite/vue.js?v=1a2b3c</code>），既避免浏览器直接访问 <code>node_modules</code> 目录的权限问题，又通过 <code>v=1a2b3c</code> 这类缓存标识实现后续更新的缓存失效控制。</p>
</li>
</ul>
<p><strong>示例：main.ts 编译前后对比</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 编译前（项目源码：src/main.ts）</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)

<span class="hljs-comment">// 编译后（Vite 返回给浏览器的 ESM 代码）</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'/node_modules/.vite/vue.js?v=1a2b3c'</span> <span class="hljs-comment">// 重写预构建产物路径</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span> <span class="hljs-comment">// 相对路径保留，将触发后续样式请求</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span> <span class="hljs-comment">// Vue 组件路径，将触发后续组件请求</span>

<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h6 data-id="heading-17">3. 结果返回与依赖请求触发</h6>
<p>Vite 将编译后的 ESM 代码通过 HTTP 响应返回给浏览器，浏览器解析该代码时，会立即识别到 <code>./style.css</code> 和 <code>./App.vue</code> 两个未加载的依赖，自动向 Vite 服务器发起新的请求，由此进入依赖模块的递归编译流程。</p>
<h5 data-id="heading-18">步骤 9：递归编译依赖模块（按需编译核心体现）</h5>
<p>Vite 的“按需编译”核心就体现在递归处理依赖请求的过程中——仅当浏览器请求某个依赖时才对其编译，而非启动时全量编译所有文件。以下针对前端项目中最常见的两类依赖模块，详细说明编译流程：</p>
<h6 data-id="heading-19">1. Vue 单文件组件（SFC）编译（以 App.vue 为例）</h6>
<p>当浏览器请求 <code>/src/App.vue</code> 时，<code>@vitejs/plugin-vue</code> 插件会主导编译过程，将 SFC 拆分为模板、脚本、样式三部分分别处理后再组合为 ESM 模块：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 编译前（项目源码：src/App.vue） --&gt;
&lt;script setup lang="ts"&gt;
import HelloWorld from './components/HelloWorld.vue'
&lt;/script&gt;

&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;HelloWorld msg="Hello Vite + Vue" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.app {
  text-align: center;
  padding: 2rem;
  background: #f5f5f5;
}
&lt;/style&gt;
</code></pre>
<p><strong>编译核心步骤</strong>：</p>
<ol>
<li>
<p><strong>模板编译</strong>：将<code>&lt;template&gt;</code>标签中的HTML结构转为Vue可执行的渲染函数（render函数），例如上述模板会转为<code>() =&gt; h('div', { class: 'app' }, [h(HelloWorld, { msg: 'Hello Vite + Vue' })])</code>；</p>
</li>
<li>
<p><strong>脚本编译</strong>：对<code>&lt;script setup lang="ts"&gt;</code>语法糖进行解糖处理，转为普通ESM导出格式，同时重写HelloWorld组件的引入路径；</p>
</li>
<li>
<p><strong>样式编译</strong>：为<code>&lt;style scoped&gt;</code>中的样式规则添加作用域哈希（如.app转为.app_123abc），避免组件间样式污染，同时生成独立的样式请求路径（如<code>/src/App.vue?v=1a2b3c&amp;type=style&amp;scoped</code>）；</p>
</li>
<li>
<p><strong>组合导出</strong>：将编译后的模板（渲染函数）、脚本（组件逻辑）、样式（请求路径）整合为一个ESM模块，返回给浏览器并触发<code>HelloWorld.vue</code>和样式文件的后续请求。</p>
</li>
</ol>
<p><strong>编译后简化代码</strong> <strong>示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-comment">// 导入预构建依赖和子组件</span>
<span class="hljs-keyword">import</span> { defineComponent, h } <span class="hljs-keyword">from</span> <span class="hljs-string">'/node_modules/.vite/vue.js?v=1a2b3c'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/HelloWorld.vue'</span>
<span class="hljs-comment">// 引入编译后的作用域样式</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'/src/App.vue?v=1a2b3c&amp;type=style&amp;scoped'</span>

<span class="hljs-comment">// 模板转译后的渲染函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">render</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">class</span>: <span class="hljs-string">'app_123abc'</span> }, [
  <span class="hljs-title function_">h</span>(<span class="hljs-title class_">HelloWorld</span>, { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Hello Vite + Vue'</span> })
])

<span class="hljs-comment">// 组合为 Vue 组件并导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'App'</span>,
  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">HelloWorld</span> },
  render
})
</code></pre>
<h6 data-id="heading-20">2. 样式文件编译（以 style.css 为例）</h6>
<p>当浏览器请求样式文件时，Vite 会根据文件类型执行对应处理，普通 CSS 和 SCSS/LESS 等预处理文件的处理流程如下：</p>
<ul>
<li>
<p>若为普通CSS文件，直接读取文件内容，添加必要的浏览器前缀（若配置autoprefixer）后返回；</p>
</li>
<li>
<p>若为Sass/LESS等预处理文件，先安装对应插件（如SCSS需安装<code>sass</code>和<code>vite-plugin-sass</code>），插件会将预处理语法编译为普通CSS后返回；</p>
</li>
<li>
<p>最终浏览器会将返回的CSS内容通过<code>&lt;style&gt;</code>标签注入页面，无需像传统构建工具那样打包为单独的CSS文件。</p>
</li>
</ul>
<p><strong>示例1：普通CSS文件编译与注入</strong></p>
<pre><code class="hljs language-css" lang="css">// 编译前（项目源码：<span class="hljs-attribute">src</span>/style<span class="hljs-selector-class">.css</span>）
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}

// 编译后返回的 CSS 内容
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}

// 浏览器自动注入页面的 DOM 结构
&lt;style&gt;
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}
&lt;/style&gt;
</code></pre>
<p><strong>示例2：SCSS文件编译与注入（需提前配置）</strong></p>
<p>首先需安装依赖：<code>npm install sass vite-plugin-sass --save-dev</code>，并在<code>vite.config.ts</code>中配置插件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>;
<span class="hljs-keyword">import</span> sass <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-sass'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>(), <span class="hljs-title function_">sass</span>()]
});
</code></pre>
<p>SCSS文件编译流程：</p>
<pre><code class="hljs language-css" lang="css">// 编译前（项目源码：<span class="hljs-attribute">src</span>/style<span class="hljs-selector-class">.scss</span>，含变量和嵌套语法）
$primary-<span class="hljs-attribute">color</span>: <span class="hljs-number">#42b983</span>;
$<span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">font-size</span>: $font-size;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;

  <span class="hljs-selector-class">.app-container</span> {
    <span class="hljs-attribute">background</span>: $primary-color;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
  }
}

// 编译后返回的 CSS 内容（预处理语法解析完成）
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}
<span class="hljs-selector-tag">body</span> <span class="hljs-selector-class">.app-container</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#42b983</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
}

// 浏览器自动注入页面的 DOM 结构
&lt;style&gt;
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Inter'</span>, sans-serif;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}
<span class="hljs-selector-tag">body</span> <span class="hljs-selector-class">.app-container</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#42b983</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2rem</span>;
}
&lt;/style&gt;
</code></pre>
<h5 data-id="heading-21">步骤 10：所有模块加载完成并渲染页面</h5>
<p>随着依赖模块的递归编译和加载，浏览器会逐步获取页面渲染所需的全部资源（TS/JS 模块、Vue 组件、样式文件、静态资源等），最终执行入口模块的渲染逻辑，完成页面构建。整个流程的收尾环节如下：</p>
<ol>
<li>
<p><strong>应用实例化</strong>：浏览器执行入口模块中的<code>createApp(App).mount('#app')</code>代码，基于编译后的Vue根组件App创建应用实例；</p>
</li>
<li>
<p><strong>虚拟DOM挂载</strong>：Vue框架通过组件的渲染函数生成虚拟DOM，再将虚拟DOM转换为真实DOM并挂载到页面的#app节点；</p>
</li>
<li>
<p><strong>资源全局就绪</strong>：所有样式通过<code>&lt;style&gt;</code>标签注入生效，图片、字体等静态资源通过直接请求加载完成，页面呈现最终效果；</p>
</li>
<li>
<p><strong>HMR客户端初始化</strong>：此前注入的<code>/@vite/client</code>脚本完成初始化，通过WebSocket与Vite开发服务器建立长连接，随时等待后续代码更新的通知。</p>
</li>
</ol>
<p><strong>示例：启动完成的标识</strong>：</p>
<ul>
<li>
<p>浏览器控制台会输出 Vite HMR 客户端的初始化日志：<code>[vite] connected.</code>；</p>
</li>
<li>
<p>终端会显示浏览器连接成功的提示：<code>➜  Local:   http://localhost:5173/</code>，此时开发环境正式就绪，支持代码热更新。</p>
</li>
</ul>
<h3 data-id="heading-22">三、代码更新流程（热模块替换 HMR）</h3>
<p>首次启动后，开发者修改代码时，Vite 不会重启开发服务器或刷新整个页面，而是通过「热模块替换（HMR）」机制仅更新修改的模块，实现毫秒级更新响应。其核心原理是通过 WebSocket 建立服务器与浏览器的长连接，实时推送模块变更信息，避免全页刷新导致的开发状态丢失。</p>
<p>以下将修改 <code>src/components/HelloWorld.vue</code> 中的文本内容（将 <code>msg</code> 属性值从 <code>Hello Vite + Vue</code> 改为 <code>Hello Vite 5.x + Vue 3</code>）为例</p>
<ol>
<li>（修改前）</li>
</ol>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup lang="ts"&gt;
  const msg = 'Hello Vite + Vue';
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt; 
&lt;/template&gt;
</code></pre>
<ol start="2">
<li>修改组件的msg值（触发热更新）</li>
</ol>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup lang="ts"&gt;
    // msg值修改为新内容
    const msg = 'Hello Vite 5.x + Vue 3';
&lt;/script&gt;

&lt;template&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt; 
&lt;/template&gt;
</code></pre>
<p>拆解代码更新的 5 个关键步骤：</p>
<h5 data-id="heading-23">步骤 1：文件变更监听</h5>
<p>Vite 启动后会通过 <code>chokidar</code> 库（高效的文件监听工具）实时监听项目源码目录（默认是 <code>src</code> 目录）的文件变化，包括文件的修改、新增、删除以及重命名等操作。当开发者修改 <code>HelloWorld.vue</code> 并保存后，<code>chokidar</code> 会立即捕获到该文件的修改事件，并将文件路径等信息传递给 Vite 核心处理逻辑。</p>
<h5 data-id="heading-24">步骤 2：变更模块定位与重新编译</h5>
<p>Vite 收到文件变更事件后，会根据文件路径快速定位到对应的模块（即 <code>HelloWorld.vue</code>），并触发该模块的重新编译流程。重新编译的逻辑与首次启动时的模块编译完全一致：对于 Vue 组件，<code>@vitejs/plugin-vue</code> 会重新拆解 SFC 并编译模板、脚本、样式；对于 TypeScript 或样式文件，也会执行与首次编译相同的转译和处理逻辑，确保输出的模块代码与当前源码一致。</p>
<p><strong>示</strong> <strong>例</strong>：重新编译 <code>HelloWorld.vue</code> 后，模板中的 <code>msg</code> 内容会更新为 <code>Hello Vite 5.x + Vue 3</code>，对应的渲染函数也会同步修改。</p>
<h5 data-id="heading-25">步骤 3：生成模块变更标识（hash）</h5>
<p>为了让浏览器能够准确识别模块是否发生更新，Vite 会为重新编译后的模块生成一个唯一的哈希（hash）标识。该哈希值基于模块的内容计算得出，只要模块内容发生变化，哈希值就会随之改变。同时，Vite 会更新内存中的模块映射表，将新的哈希值与模块路径关联，便于后续浏览器请求时的身份校验。</p>
<p><strong>示</strong> <strong>例</strong>：修改后的 <code>HelloWorld.vue</code> 对应的请求路径会变为 <code>/src/components/HelloWorld.vue?hash=abc123</code>，其中 <code>abc123</code> 就是新的哈希标识。</p>
<h5 data-id="heading-26">步骤 4：WebSocket 推送变更通知</h5>
<p>Vite 开发服务器通过 WebSocket 长连接向浏览器端的 HMR 客户端推送模块变更通知。通知信息是一个结构化的 JSON 数据，主要包含以下核心字段：</p>
<ul>
<li>
<p><code>type</code>：更新类型，如 <code>update</code> 表示模块更新、<code>delete</code> 表示模块删除；</p>
</li>
<li>
<p><code>updates</code>：变更模块列表，每个元素包含模块路径（<code>path</code>）、新哈希值（<code>hash</code>）以及可接受更新的模块路径（<code>acceptedPath</code>）等信息。</p>
</li>
</ul>
<p><strong>示例：推送的变更通知数据（简化版）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"update"</span>,
  <span class="hljs-string">"updates"</span>: [
    {
      <span class="hljs-string">"path"</span>: <span class="hljs-string">"/src/components/HelloWorld.vue"</span>,
      <span class="hljs-string">"hash"</span>: <span class="hljs-string">"abc123"</span>,
      <span class="hljs-string">"acceptedPath"</span>: <span class="hljs-string">"/src/components/HelloWorld.vue"</span>,
      <span class="hljs-string">"type"</span>: <span class="hljs-string">"js"</span>
    }
  ]
}
</code></pre>
<h5 data-id="heading-27">步骤 5：浏览器执行热替换逻辑</h5>
<p>浏览器端的 Vite HMR 客户端（即 <code>/@vite/client</code> 脚本）收到 WebSocket 推送的变更通知后，会按以下流程执行热模块替换：</p>
<ol>
<li>
<p><strong>请求新模块代码</strong>：根据通知中的模块路径和新哈希值，向 Vite 服务器发起新模块的请求（如 <code>GET /src/components/HelloWorld.vue?hash=abc123</code>），获取重新编译后的模块代码；</p>
</li>
<li>
<p><strong>模块替换与状态保留</strong>：由对应的框架插件（如 <code>@vitejs/plugin-vue</code>）提供热替换逻辑，将页面中的旧模块实例替换为新模块实例。对于 Vue 组件，会销毁旧的组件实例，创建新的组件实例并重新渲染对应的 DOM 节点，同时尽可能保留组件的局部状态（如输入框中的内容）；</p>
</li>
<li>
<p><strong>失败降级处理</strong>：若模块替换失败（如修改了入口文件 <code>main.ts</code> 这类无法单独热更新的模块，或插件未提供对应的热替换逻辑），HMR 客户端会自动降级为全页刷新，确保页面内容与源码一致。</p>
</li>
</ol>
<p><strong>示</strong> <strong>例</strong>：浏览器获取新的 <code>HelloWorld.vue</code> 模块后，<code>@vitejs/plugin-vue</code> 的热替换逻辑会仅重渲染 <code>HelloWorld</code> 组件对应的 DOM 节点，页面上的文本会从 <code>Hello Vite + Vue</code> 变为 <code>Hello Vite 5.x + Vue 3</code>，而页面中其他组件的状态（如顶部导航栏的选中状态、输入框中的内容）不会受到任何影响。</p>
<h3 data-id="heading-28">四、Vite 5.x 开发模式关键优化点总结</h3>
<p>Vite 5.x 开发模式的极速体验得益于其底层的四大核心优化设计，这些设计也是其与传统构建工具（如 Webpack）的核心差异：</p>
<ol>
<li>
<p><strong>依赖预构建 + esbuild 加速</strong>：利用 esbuild 的极速编译能力（比传统 JS 转译器快 10-100 倍），将第三方依赖转为 ESM 格式并合并重复依赖，减少首次启动时的编译耗时；同时通过缓存机制，二次启动时直接复用预构建产物，跳过重复工作。</p>
</li>
<li>
<p><strong>按需编译减少无效工作</strong>：仅在浏览器请求模块时才执行编译，避免传统工具“启动时全量打包”的无效工作，尤其对于大型项目，首次启动速度提升极为明显。</p>
</li>
<li>
<p><strong>HMR 精准更新保留开发状态</strong>：通过 WebSocket 实时推送变更，仅更新修改的模块而非全页刷新，既提升了更新速度，又保留了开发者的工作状态（如表单输入、组件状态），大幅提升开发效率。</p>
</li>
<li>
<p><strong>内存缓存复用编译结果</strong>：所有编译后的模块都会缓存到内存中，当浏览器再次请求同一模块时（如页面刷新后），Vite 直接从内存中返回编译结果，无需重复编译，进一步减少响应时间。</p>
</li>
</ol>
<h3 data-id="heading-29">五、常见问题与解决方案（内容由AI生成）</h3>
<h4 data-id="heading-30">1. 首次启动比二次启动慢很多？</h4>
<p><strong>原因</strong>：首次启动需要执行依赖预构建流程，将第三方依赖转为 ESM 并生成缓存；二次启动时，Vite 会读取 <code>node_modules/.vite</code> 目录中的缓存文件，跳过预构建步骤，因此启动速度更快。</p>
<p><strong>解决方案</strong>：这是正常现象，无需特殊处理。若需强制重新执行预构建，可删除 <code>node_modules/.vite</code> 目录，或执行命令 <code>npx vite --force</code>。</p>
<h4 data-id="heading-31">2. HMR 热更新失效，修改代码后页面无反应？</h4>
<p><strong>可能原因</strong>：</p>
<ul>
<li>
<p>修改了无法单独热更新的模块，如入口文件 <code>main.ts</code>、全局状态管理文件等；</p>
</li>
<li>
<p>框架插件版本与 Vite 5.x 不兼容（如 <code>@vitejs/plugin-vue</code> 版本过低）；</p>
</li>
<li>
<p>WebSocket 连接失败（如端口被占用、网络环境限制）。</p>
</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>
<p>检查修改的模块是否为可热更新模块，入口文件等核心模块修改后需手动刷新页面；</p>
</li>
<li>
<p>升级框架插件至与 Vite 5.x 兼容的版本（如 <code>@vitejs/plugin-vue@5.x</code>）；</p>
</li>
<li>
<p>查看浏览器控制台是否有 WebSocket 连接失败的错误，尝试重启服务器或更换端口（通过 <code>vite.config.ts</code> 的 <code>server.port</code> 配置）。</p>
</li>
</ul>
<h4 data-id="heading-32">3. 开发模式下 TypeScript 类型错误未被检测到？</h4>
<p><strong>原因</strong>：Vite 开发模式下的 TypeScript 转译仅做语法转译，不执行类型检查，目的是提升编译速度。类型检查工作默认由 IDE（如 VS Code）实时执行。</p>
<p><strong>解决方案</strong>：在 <code>package.json</code> 中添加类型检查脚本：<code>"type-check": "tsc --noEmit"</code>，开发过程中可通过 <code>npm run type-check</code> 手动执行类型检查，或在 CI/CD 流程中加入该步骤确保代码类型正确。</p>
<h3 data-id="heading-33">六、对按需加载的理解补充：无需加载与延迟加载场景</h3>
<p>基于 Vite 「按需编译+动态引入」的核心设计，首次启动时存在大量无需加载的文件，部分文件会在后续代码更新时因引用关系激活而被首次加载，包含两类核心场景。</p>
<h4 data-id="heading-34">1. 首次启动无需加载的文件场景</h4>
<p>首次启动仅加载页面初始渲染必需的资源，未被依赖或非渲染相关的文件均不会触发加载，具体分为三类场景：</p>
<h5 data-id="heading-35">1.1 未被任何模块引入的源码文件</h5>
<p>项目 <code>src</code> 目录中存在但未被入口模块或依赖链关联的文件，完全不会触发请求和编译，是最常见的无需加载场景：</p>
<ul>
<li>
<p><strong>独立未引用组件</strong>：新建的 <code>src/components/UnusedComponent.vue</code> 未在 <code>App.vue</code> 或其他业务组件中通过 <code>import</code> 引入，浏览器无请求，Vite 不编译；</p>
</li>
<li>
<p><strong>冗余工具函数</strong>：<code>src/utils/legacy-utils.ts</code> 包含历史工具函数，但所有业务代码均未调用，处于“定义未使用”状态；</p>
</li>
<li>
<p><strong>未注册路由组件</strong>：路由配置文件中未注册的页面组件（如 <code>src/views/TestPage.vue</code> 未加入 <code>routes</code> 数组），即使存在也不会被加载。</p>
</li>
</ul>
<h5 data-id="heading-36">1.2 已预构建但未引入的第三方依赖</h5>
<p>首次启动时 Vite 会对 <code>package.json</code> 中 <code>dependencies</code> 所有第三方依赖执行预构建，但仅当源码实际引入时才会被浏览器请求：</p>
<ul>
<li>
<p><strong>安装后未使用的依赖</strong>：通过 <code>npm install axios</code> 安装后，未在任何源码中写 <code>import axios from 'axios'</code>，其预构建产物 <code>node_modules/.vite/deps/axios.js</code> 不会被请求；</p>
</li>
<li>
<p><strong>按需引入库的未使用部分</strong>：使用 <code>lodash-es</code> 时仅引入 <code>import debounce from 'lodash-es/debounce'</code>，则 <code>lodash-es</code> 其他函数（如 <code>throttle</code>）的预构建相关代码不会被加载。</p>
</li>
</ul>
<h5 data-id="heading-37">1.3 非渲染相关的配置与辅助文件</h5>
<p>项目根目录或子目录中用于配置、文档、构建等目的的文件，仅在 Vite 启动时被读取配置或完全不参与开发流程，不会被浏览器请求：</p>
<ul>
<li>
<p><strong>配置文件</strong>：<code>vite.config.ts</code>、<code>tsconfig.json</code>、<code>.eslintrc.js</code> 等，仅在 Vite 初始化时解析配置，不进入浏览器渲染流程；</p>
</li>
<li>
<p><strong>文档与日志</strong>：<code>README.md</code>、<code>CHANGELOG.md</code> 及 <code>logs/</code> 目录下的日志文件，与前端渲染完全无关；</p>
</li>
<li>
<p><strong>构建产物与缓存</strong>：<code>dist/</code> 目录（构建产物）、<code>node_modules/.vite/cache/</code> 目录（预构建缓存），仅在构建或预构建时使用，不被浏览器请求。</p>
</li>
</ul>
<h4 data-id="heading-38">2. 首次启动未加载、代码更新时加载的场景</h4>
<p>这类文件本身存在且引用关系/内容未变，但因首次启动时未满足加载条件，在后续代码更新触发引用关系激活后才被首次加载，核心驱动力是“动态引入”和“条件激活”：</p>
<h5 data-id="heading-39">2.1 路由懒加载的非初始页面</h5>
<p>Vue Router、React Router 等支持的路由懒加载，是最典型的延迟加载场景，首次启动仅加载首页路由，其他路由组件在代码更新激活跳转后加载：</p>
<ol>
<li>
<p><strong>首次启动未加载</strong>：路由配置中通过 <code>() =&gt; import()</code> 定义非首页路由，首次启动仅加载 <code>/</code> 对应组件，其他路由组件未被请求：<code>// 路由配置（首次启动仅加载 Home.vue）</code></p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Home.vue'</span>) }, <span class="hljs-comment">// 初始加载</span>
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./About.vue'</span>) } <span class="hljs-comment">// 首次未加载</span>
];
</code></pre>
</li>
<li>
<p><strong>代码更新触发加载</strong>：修改 <code>Home.vue</code> 新增“关于页”跳转按钮（仅更新页面内容，<code>About.vue</code> 引用关系和内容不变）：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
 &lt;!-- <span class="hljs-title class_">Home</span>.<span class="hljs-property">vue</span> 代码更新：新增跳转按钮 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>去关于页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> <span class="hljs-comment">&lt;!-- 新增跳转 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>Vite 触发 HMR 更新 <code>Home.vue</code> 后，用户点击跳转按钮时，浏览器会首次请求 <code>About.vue</code> 并完成编译加载。</p>
</li>
</ol>
<h5 data-id="heading-40">2.2 条件渲染触发的动态引入组件</h5>
<p>首次启动时不满足渲染条件的组件，通过动态引入方式定义，在代码更新调整条件后被激活加载：</p>
<ol>
<li>
<p><strong>首次启动未加载</strong>：<code>App.vue</code> 中通过条件判断动态引入弹窗组件，首次启动时 <code>showModal</code> 为 <code>false</code>，<code>Modal.vue</code> 未被请求：<code>&lt;script setup&gt;</code></p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">const</span> showModal = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 初始为false，不触发引入</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">openModal</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  showModal.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">default</span>: <span class="hljs-title class_">Modal</span> } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/Modal.vue'</span>); <span class="hljs-comment">// 动态引入</span>
  <span class="hljs-comment">// 渲染弹窗逻辑</span>
};
&lt;/script&gt;
</code></pre>
</li>
<li>
<p><strong>代码更新触发加载</strong>：修改 <code>App.vue</code> 新增“打开弹窗”按钮（无需修改 <code>Modal.vue</code>），用户点击按钮后 <code>showModal</code> 变为 <code>true</code>，触发 <code>Modal.vue</code> 首次请求和加载。</p>
</li>
</ol>
<h5 data-id="heading-41">2.3 组件库按需引入的新增组件</h5>
<p>使用 Element Plus、Ant Design Vue 等支持按需引入的组件库时，首次启动仅加载已使用组件，代码更新新增组件引用后触发未加载组件的加载：</p>
<ol>
<li>
<p><strong>首次启动未加载</strong>：首次启动仅使用 <code>ElButton</code>，按需引入插件仅编译加载 <code>ElButton</code> 相关代码，<code>ElTable</code> 等未使用组件未被加载；</p>
</li>
<li>
<p><strong>代码更新触发加载</strong>：修改 <code>TablePage.vue</code> 新增 <code>&lt;ElTable&gt;</code> 组件并补充引入代码 <code>import { ElTable } from 'element-plus'</code>，Vite 会在 HMR 时识别新增引用，触发 <code>ElTable</code> 及其依赖的首次加载（组件库本身内容未变，仅引用关系激活）。</p>
</li>
</ol>
<h4 data-id="heading-42">3. 核心结论</h4>
<p>Vite 开发模式的加载逻辑始终围绕「按需」核心：首次启动仅为“初始渲染”服务，未被依赖的文件均无需加载；而后续代码更新时，只要通过修改代码激活了新的引用关系（如新增跳转、调整渲染条件），即使文件本身内容未变，也会被首次加载。这一特性既保证了首次启动的极速体验，又兼顾了开发过程中动态扩展的灵活性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nacos 源码深度畅游：Nacos 配置同步详解（上）]]></title>    <link>https://juejin.cn/post/7572485825705558025</link>    <guid>https://juejin.cn/post/7572485825705558025</guid>    <pubDate>2025-11-15T07:57:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572485825705558025" data-draft-id="7564725862025986100" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Nacos 源码深度畅游：Nacos 配置同步详解（上）"/> <meta itemprop="keywords" content="后端,GitHub,分布式"/> <meta itemprop="datePublished" content="2025-11-15T07:57:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="方圆想当图灵"/> <meta itemprop="url" content="https://juejin.cn/user/386633160473101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Nacos 源码深度畅游：Nacos 配置同步详解（上）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/386633160473101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    方圆想当图灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T07:57:14.000Z" title="Sat Nov 15 2025 07:57:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读31分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 <strong>方圆</strong>。最近学习了一下 Nacos 源码，顺便为 Nacos 开源项目提交了 10+ 个 PR，成为了 Nacos 项目的 Contributor。Nacos 是一个非常活跃且包容的社区，大家可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fnacos" target="_blank" title="https://github.com/alibaba/nacos" ref="nofollow noopener noreferrer">Github-Nacos</a> 关注并认领 ISSUE。本篇文章基于 Nacos 的 3.1.0 版本，准备详细解释一下 Nacos 对配置管理的核心流程，方便之后了解和学习 Nacos 的同学。</p>
<p>本文将主要分成两大部分：</p>
<ol>
<li>当配置发生变更时，Nacos Server 服务端是如何保证配置数据的一致性的，在这个小节内我们会讨论两种情况，分别关于 Nacos Server 的单机部署和集群部署</li>
<li>当配置发生变更时，Nacos Client 客户端是如何保证及时更新配置，并保证配置内容是最新的</li>
</ol>
<p>在每个部分我都会在讲解源码前将具体的逻辑使用图示整理出来，方便想理解原理而不想看源码的同学，同时也能让想看源码的同学快速入手。如果大家对 Nacos 感兴趣，可以将源码 clone 下来，Debug 调试整个流程，这样学习和理解的效果更佳。</p>
<h3 data-id="heading-0">Nacos Server 服务端</h3>
<p>当我们在 Nacos 控制台变更配置时，不论是单机部署还是集群部署都会经过以下逻辑，请求会由 <code>ConsoleConfigController</code> 来承接，调用其中的 <code>publishConfig</code> 发布配置的方法，如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@NacosApi</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/v3/console/cs/config")</span>
<span class="hljs-meta">@ExtractorManager</span>.Extractor(httpExtractor = ConfigDefaultHttpParamExtractor.class)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleConfigController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigProxy configProxy;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConsoleConfigController</span><span class="hljs-params">(ConfigProxy configProxy)</span> {
        <span class="hljs-built_in">this</span>.configProxy = configProxy;
    }
    
    <span class="hljs-meta">@PostMapping()</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.WRITE, signType = SignType.CONFIG, apiType = ApiType.CONSOLE_API)</span>
    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">publishConfig</span><span class="hljs-params">(HttpServletRequest request, ConfigFormV3 configForm)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// check required </span>
        configForm.validateWithContent();
        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">namespaceTransferred</span> <span class="hljs-operator">=</span> NamespaceUtil.isNeedTransferNamespace(configForm.getNamespaceId());
        configForm.setNamespaceId(NamespaceUtil.processNamespaceParameter(configForm.getNamespaceId()));

        <span class="hljs-comment">// check param</span>
        ParamUtils.checkParam(configForm.getDataId(), configForm.getGroup(), <span class="hljs-string">"datumId"</span>, configForm.getContent());
        ParamUtils.checkParamV2(configForm.getTag());

        <span class="hljs-keyword">if</span> (StringUtils.isBlank(configForm.getSrcUser())) {
            configForm.setSrcUser(RequestUtil.getSrcUserName(request));
        }
        <span class="hljs-keyword">if</span> (!ConfigType.isValidType(configForm.getType())) {
            configForm.setType(ConfigType.getDefaultType().getType());
        }

        <span class="hljs-type">ConfigRequestInfo</span> <span class="hljs-variable">configRequestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigRequestInfo</span>();
        configRequestInfo.setSrcIp(RequestUtil.getRemoteIp(request));
        configRequestInfo.setRequestIpApp(RequestUtil.getAppName(request));
        configRequestInfo.setBetaIps(request.getHeader(<span class="hljs-string">"betaIps"</span>));
        configRequestInfo.setCasMd5(request.getHeader(<span class="hljs-string">"casMd5"</span>));
        configRequestInfo.setNamespaceTransferred(namespaceTransferred);

        <span class="hljs-keyword">return</span> Result.success(configProxy.publishConfig(configForm, configRequestInfo));
    }
}
</code></pre>
<p>Controller 中并没有值得特别关注的逻辑，包含必要的参数校验和执行 <code>ConfigProxy#publishConfig</code> 方法，后者从命名来看，包含了 <code>Proxy</code> 字样，暗示它是一个代理类，具体的实现逻辑如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigProxy</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigHandler configHandler;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigProxy</span><span class="hljs-params">(ConfigHandler configHandler)</span> {
        <span class="hljs-built_in">this</span>.configHandler = configHandler;
    }

    <span class="hljs-comment">/**
     * Add or update configuration.
     */</span>
    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">publishConfig</span><span class="hljs-params">(ConfigForm configForm, ConfigRequestInfo configRequestInfo)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-keyword">return</span> configHandler.publishConfig(configForm, configRequestInfo);
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>可以发现它使用了 <strong>静态代理模式</strong>，并没有做发布配置的逻辑，而是注入了 <code>ConfigHandler</code> 类，并调用其 <code>publishConfig</code> 方法，那么它代理了什么呢？如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f12b493d78b4519949c6ae2735dffc7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763798468&amp;x-signature=GngJAxAtRBhQeebnwctOJ6diQiM%3D" alt="img_1.png" loading="lazy"/></p>
<p><code>ConfigHandler</code> 是一个接口，它有多个实现类，当在 Nacos 中采用不同的配置时，会注入不同的实现类，所以这部分代理操作实际上根据不同的配置来选择不同的策略。在这里我们仅关注 <code>ConfigInnerHandler</code> 实现策略，它会执行到 <code>ConfigOperationService#publishConfig</code> 发布配置的核心逻辑。这个方法的逻辑虽然很长，但是其中值得关注的内容我已经用序号标注了，分别为 “写入数据库的逻辑” 和 “发布 <code>ConfigDataChangeEvent</code> 配置变更事件”：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigOperationService</span> {

    <span class="hljs-keyword">private</span> ConfigInfoPersistService configInfoPersistService;

    <span class="hljs-keyword">private</span> ConfigInfoGrayPersistService configInfoGrayPersistService;

    <span class="hljs-keyword">private</span> ConfigMigrateService configMigrateService;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ConfigOperationService.class);

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigOperationService</span><span class="hljs-params">(ConfigInfoPersistService configInfoPersistService,
                                  ConfigInfoGrayPersistService configInfoGrayPersistService,
                                  ConfigMigrateService configMigrateService)</span> {
        <span class="hljs-built_in">this</span>.configInfoPersistService = configInfoPersistService;
        <span class="hljs-built_in">this</span>.configInfoGrayPersistService = configInfoGrayPersistService;
        <span class="hljs-built_in">this</span>.configMigrateService = configMigrateService;
    }
    
    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">publishConfig</span><span class="hljs-params">(ConfigForm configForm, ConfigRequestInfo configRequestInfo, String encryptedDataKey)</span> <span class="hljs-keyword">throws</span> NacosException {
        Map&lt;String, Object&gt; configAdvanceInfo = getConfigAdvanceInfo(configForm);
        ParamUtils.checkParam(configAdvanceInfo);

        configForm.setEncryptedDataKey(encryptedDataKey);
        <span class="hljs-type">ConfigInfo</span> <span class="hljs-variable">configInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigInfo</span>(configForm.getDataId(), configForm.getGroup(),
                configForm.getNamespaceId(), configForm.getAppName(), configForm.getContent());
        <span class="hljs-comment">// set old md5</span>
        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(configRequestInfo.getCasMd5())) {
            configInfo.setMd5(configRequestInfo.getCasMd5());
        }
        configInfo.setType(configForm.getType());
        configInfo.setEncryptedDataKey(encryptedDataKey);

        <span class="hljs-comment">// 1. 写入数据库的逻辑：区分了 md5 是否为空</span>
        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(configRequestInfo.getCasMd5())) {
            <span class="hljs-comment">// 非空会执行 CAS 比较并交换的操作</span>
            configOperateResult = configInfoPersistService.insertOrUpdateCas(configRequestInfo.getSrcIp(),
                    configForm.getSrcUser(), configInfo, configAdvanceInfo);
            <span class="hljs-keyword">if</span> (!configOperateResult.isSuccess()) {
                LOGGER.warn(
                        <span class="hljs-string">"[cas-publish-config-fail] srcIp = {}, dataId= {}, casMd5 = {}, msg = server md5 may have changed."</span>,
                        configRequestInfo.getSrcIp(), configForm.getDataId(), configRequestInfo.getCasMd5());
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosApiException</span>(HttpStatus.INTERNAL_SERVER_ERROR.value(), ErrorCode.RESOURCE_CONFLICT,
                        <span class="hljs-string">"Cas publish fail, server md5 may have changed."</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (configRequestInfo.getUpdateForExist()) {
                configOperateResult = configInfoPersistService.insertOrUpdate(configRequestInfo.getSrcIp(),
                        configForm.getSrcUser(), configInfo, configAdvanceInfo);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">try</span> {
                    configOperateResult = configInfoPersistService.addConfigInfo(configRequestInfo.getSrcIp(),
                            configForm.getSrcUser(), configInfo, configAdvanceInfo);
                } <span class="hljs-keyword">catch</span> (DataIntegrityViolationException ive) {
                    configOperateResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigOperateResult</span>(<span class="hljs-literal">false</span>);
                }
            }
        }
        
        <span class="hljs-keyword">if</span> (!configOperateResult.isSuccess()) {
            LOGGER.warn(<span class="hljs-string">"[publish-config-failed] config already exists. dataId: {}, group: {}, namespaceId: {}"</span>,
                    configForm.getDataId(), configForm.getGroup(), configForm.getNamespaceId());
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigAlreadyExistsException</span>(
                    String.format(<span class="hljs-string">"config already exist, dataId: %s, group: %s, namespaceId: %s"</span>,
                            configForm.getDataId(), configForm.getGroup(), configForm.getNamespaceId()));
        }
        
        <span class="hljs-comment">// 2. 发布 ConfigDataChangeEvent 配置变更事件</span>
        ConfigChangePublisher.notifyConfigChange(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigDataChangeEvent</span>(configForm.getDataId(), configForm.getGroup(), configForm.getNamespaceId(),
                        configOperateResult.getLastModified()));
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>接下来我们根据 “单机部署，采用 MySQL 数据库” 和 “集群部署，采用内嵌 Derby 数据库” 来讨论具体的逻辑。</p>
<h4 data-id="heading-1">单机部署，采用 MySQL 数据库</h4>
<p>在单机部署并采用 MySQL 数据库时，Nacos 服务端在配置变更后执行逻辑的流程图如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/983300874378498da832018857209668~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763798468&amp;x-signature=O2EnBH8g6rHICDjwAvsCIsNuw6U%3D" alt="image.png" loading="lazy"/></p>
<p>在控制台变更配置后，会先写入 MySQL 数据库，写入成功继续执行，如果写入失败则抛出异常，控制台会提示配置写入失败，就不再执行后续的逻辑了。</p>
<p>在写入 MySQL 数据库成功后，会触发 <code>ConfigDataChangeEvent</code> 配置发生变更的事件，由 <code>DumpService</code> 监听并消费。消费这个事件时，会创建 <code>DumpTask</code> 任务，这个任务的作用有两个：将配置信息 <strong>写入本地磁盘文件</strong> 和 <strong>写入服务 JVM 内存</strong>，这样 <strong>即使在 MySQL 数据库发生宕机时，客户端也能正常读取配置信息</strong>，写入本地磁盘相当于做了数据库的容灾。<code>DumpTask</code> 被创建后会被保存在一个 <code>ConcurrentHashMap</code> 中，由一个 <code>ScheduledExecutorService</code> 定时 100ms 执行的线程池定期处理任务，<strong>如果任务在执行时失败，都会被重新添加到 <code>ConcurrentHashMap</code> 中，无限次重试处理</strong>。</p>
<p><code>DumpTask</code> 处理完成后，会再次发出 <code>LocalDataChangeEvent</code> 本地缓存变更事件，这个事件由 <code>RpcConfigChangeNotifier</code> 监听并消费。<code>RpcConfigChangeNotifier</code> 处理这个事件时会创建 <code>RpcPushTask</code> 为客户端推送配置变更的任务，这个任务同样会被添加到另一个 <code>ScheduledExecutorService</code> 中去执行，但是异步推送变更的任务不会无限重试，最多只会重试 3 次。在这里大家可能会有疑问：如果重试超过 3 次没有成功，那么 Nacos 客户端该如何获取到最新的配置变更呢？其实 Nacos 客户端不只是通过 Nacos 服务端推送获取配置变更，而且还能通过主动从 Nacos 服务端拉取获取配置变更，这个逻辑在后续的内容中解释。</p>
<p>以上便是 Nacos 服务端在单机部署并采用 MySQL 数据库时主要的逻辑流程，接下来我们深入分析具体的源码。</p>
<hr/>
<p>在 “写入数据库的逻辑” 中，Nacos 区分了 MD5 是否为空的两种情况，MD5 在 Nacos 表示的是什么含义呢？Nacos 中的每项配置都会根据其 <strong>配置的内容</strong> 计算出 MD5 值，并将其存储在数据库中，因为 MD5 加密后输出长度固定，所以可以根据配置的 MD5 值快速判断配置内容是否发生变更。</p>
<blockquote>
<p>MD5（Message Digest Algorithm 5）是一种广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用来确保信息传输完整一致。不过现在更推荐使用 SHA-256 或更新的散列算法来替代 MD5。</p>
</blockquote>
<p>Nacos 在发布配置时，如果 MD5 值不为空则调用 <code>ConfigInfoPersistService#insertOrUpdateCas</code> 方法，这个方法使用了 <strong>CAS</strong> 操作，在执行 UPDATE SQL 时会先判断数据库中配置的 MD5 值是否与请求中的 MD5 值相同，如果相同则执行更新操作，否则不执行更新操作，这样能够避免多人在控制台同时修改配置造成的并发写入问题。</p>
<p>如果 MD5 值为空的话，那么直接调用 <code>ConfigInfoPersistService#insertOrUpdate</code> 方法，直接落库。</p>
<p>在数据库操作完成后，<strong>配置变更已经在保存在数据库了</strong>，之后会发布 <code>ConfigDataChangeEvent</code> 配置变更事件，这是一个异步处理的操作，在单机部署模式下，需要关注 <code>DumpService</code> 对这个事件的消费，它会执行 <code>DumpService#handleConfigDataChange</code> 方法，将配置变更事件转换为配置转储任务 <code>DumpTask</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 监听并处理 ConfigDataChangeEvent 事件
 * 将 ConfigDataChangeEvent 转换为 DumpRequest，交给 DumpProcessor 处理
 * 作用：将配置变更事件转换为配置转储任务，更新本地缓存
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DumpService</span> {

    <span class="hljs-keyword">private</span> TaskManager dumpTaskMgr;
    
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleConfigDataChange</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-comment">// Generate ConfigDataChangeEvent concurrently</span>
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ConfigDataChangeEvent) {
            <span class="hljs-type">ConfigDataChangeEvent</span> <span class="hljs-variable">evt</span> <span class="hljs-operator">=</span> (ConfigDataChangeEvent) event;
            <span class="hljs-type">DumpRequest</span> <span class="hljs-variable">dumpRequest</span> <span class="hljs-operator">=</span> DumpRequest.create(evt.dataId, evt.group, evt.tenant, evt.lastModifiedTs,
                    NetUtils.localIp());
            dumpRequest.setGrayName(evt.grayName);
            <span class="hljs-comment">// 执行 dump 转储操作，由 DumpProcessor 处理</span>
            DumpService.<span class="hljs-built_in">this</span>.dump(dumpRequest);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dump</span><span class="hljs-params">(DumpRequest dumpRequest)</span> {
        dumpFormal(dumpRequest.getDataId(), dumpRequest.getGroup(), dumpRequest.getTenant(),
                    dumpRequest.getLastModifiedTs(), dumpRequest.getSourceIp());
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpFormal</span><span class="hljs-params">(String dataId, String group, String tenant, <span class="hljs-type">long</span> lastModified, String handleIp)</span> {
        <span class="hljs-comment">// 生成 Task 的 Key 值，格式为：dataId+group+tenant </span>
        <span class="hljs-comment">// eg: default_config+DEFAULT_GROUP+public 其中 default_config 为配置的名称，DEFAULT_GROUP 为分组ID，public 为命名空间ID</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey2.getKey(dataId, group, tenant);
        <span class="hljs-type">String</span> <span class="hljs-variable">taskKey</span> <span class="hljs-operator">=</span> groupKey;
        <span class="hljs-comment">// 生成转储任务 DumpTask</span>
        dumpTaskMgr.addTask(taskKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DumpTask</span>(groupKey, <span class="hljs-literal">null</span>, lastModified, handleIp));
        DUMP_LOG.info(<span class="hljs-string">"[dump] add formal task. groupKey={}"</span>, groupKey);

    }
}
</code></pre>
<p>调用 <code>TaskManager#addTask</code> 方法添加配置转储任务 <code>DumpTask</code>，最终会执行以下逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosDelayTaskExecuteEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNacosTaskExecuteEngine</span>&lt;AbstractDelayTask&gt; {

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Object key, AbstractDelayTask newTask)</span> {
        lock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">AbstractDelayTask</span> <span class="hljs-variable">existTask</span> <span class="hljs-operator">=</span> tasks.get(key);
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != existTask) {
                newTask.merge(existTask);
            }
            tasks.put(key, newTask);
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
    }
}
</code></pre>
<p>在这个方法中有两点需要注意：</p>
<ol>
<li><code>ReentrantLock lock</code> 变量：在向 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 添加任务时执行了加锁操作</li>
<li><code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 变量：该变量是并发安全的，但是仍然在操作前执行了加锁操作</li>
</ol>
<p>因为 <code>AbstractDelayTask#merge</code> 方法并不是并发安全的，多线程操作时可能发生未知的情况，所以便需要注意以上两点。现在，转储任务 <code>DumpTask</code> 已经被添加到 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 中了，那么这个任务是如何被执行的呢？</p>
<p>我们先看一下 <code>NacosDelayTaskExecuteEngine</code> 的构造方法，在构造方法中创建了 <code>ScheduledExecutorService processingExecutor</code> 变量用于定期（100ms）执行 <code>ProcessRunnable</code> 任务，<code>ProcessRunnable</code> 是静态内部类，调用 <code>processTasks</code> 方法来处理任务：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosDelayTaskExecuteEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNacosTaskExecuteEngine</span>&lt;AbstractDelayTask&gt; {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService processingExecutor;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();
    
    <span class="hljs-comment">// processInterval 处理间隔默认值为 100ms</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NacosDelayTaskExecuteEngine</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> initCapacity, Logger logger, <span class="hljs-type">long</span> processInterval)</span> {
        <span class="hljs-built_in">super</span>(logger);
        tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(initCapacity);
        processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NameThreadFactory</span>(name));
        processingExecutor.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessRunnable</span>(), processInterval, processInterval, TimeUnit.MILLISECONDS);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">try</span> {
                processTasks();
            } <span class="hljs-keyword">catch</span> (Throwable e) {
                getEngineLog().error(e.toString(), e);
            }
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processTasks</span><span class="hljs-params">()</span> {
        Collection&lt;Object&gt; keys = getAllTaskKeys();
        <span class="hljs-keyword">for</span> (Object taskKey : keys) {
            <span class="hljs-comment">// 逐个删除而不是在上面统一删除，删除的时候而且加了锁，这样即使被多个线程拿到多个 Key，也能通过加锁避免执行重复的任务</span>
            <span class="hljs-type">AbstractDelayTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> removeTask(taskKey);
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == task) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// 此处使用了策略模式，可以针对不同的 key 来定义不同的处理策略，这里默认使用了 DumpProcessor</span>
            <span class="hljs-type">NacosTaskProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> getProcessor(taskKey);
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 处理失败或者抛出异常都会重试</span>
                <span class="hljs-keyword">if</span> (!processor.process(task)) {
                    retryFailedTask(taskKey, task);
                }
            } <span class="hljs-keyword">catch</span> (Throwable e) {
                getEngineLog().error(<span class="hljs-string">"Nacos task execute error "</span>, e);
                retryFailedTask(taskKey, task);
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">retryFailedTask</span><span class="hljs-params">(Object key, AbstractDelayTask task)</span> {
        task.setLastProcessTime(System.currentTimeMillis());
        <span class="hljs-comment">// 重新调用上文中的 NacosDelayTaskExecuteEngine#addTask 方法</span>
        addTask(key, task);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Collection&lt;Object&gt; <span class="hljs-title function_">getAllTaskKeys</span><span class="hljs-params">()</span> {
        Collection&lt;Object&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        lock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将 DumpService 执行时添加的 Key 在这里获取，但没有删除操作，而是在后续的步骤中遍历一个加锁删除一个</span>
            keys.addAll(tasks.keySet());
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
        <span class="hljs-keyword">return</span> keys;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> AbstractDelayTask <span class="hljs-title function_">removeTask</span><span class="hljs-params">(Object key)</span> {
        lock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">AbstractDelayTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.get(key);
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != task &amp;&amp; task.shouldProcess()) {
                <span class="hljs-keyword">return</span> tasks.remove(key);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
    }
}
</code></pre>
<p>在上述逻辑中，<code>getAllTaskKeys</code> 和 <code>removeTask</code> 方法中仍然使用了 <code>ReentrantLock</code> 加锁，但是在这两个方法中都是读操作，而且是定时线程池定期执行，发生并发问题的概率非常小，实际上我认为可以采用不加锁的方案，或者可以考虑将 <code>ConcurrentHashMap</code> 换成 <code>ConcurrentLinkedDeque</code> 队列，任务在队列尾部添加，每次线程在执行任务时直接将队列头部的任务取出，<strong>执行失败或者不满足执行条件再将它放回到队列中</strong>。不过，这种异步执行任务的多线程设计采用的是 <strong>“生产者消费者”模式</strong>，这种设计方法还是非常值得学习的。</p>
<p>接下来我们看一下 <code>DumpProcessor#process</code> 方法中，到底执行了什么逻辑，如下所示，大部分都是参数赋值，重点是 <strong>从数据库中将配置查询出来</strong> 后，执行了 <code>DumpConfigHandler#configDump</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DumpProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NacosTaskProcessor</span> {

    <span class="hljs-keyword">final</span> ConfigInfoPersistService configInfoPersistService;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(NacosTask task)</span> {
        <span class="hljs-type">DumpTask</span> <span class="hljs-variable">dumpTask</span> <span class="hljs-operator">=</span> (DumpTask) task;
        String[] pair = GroupKey2.parseKey(dumpTask.getGroupKey());
        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">0</span>];
        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">1</span>];
        <span class="hljs-type">String</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">2</span>];
        <span class="hljs-type">long</span> <span class="hljs-variable">lastModifiedOut</span> <span class="hljs-operator">=</span> dumpTask.getLastModified();
        <span class="hljs-type">String</span> <span class="hljs-variable">handleIp</span> <span class="hljs-operator">=</span> dumpTask.getHandleIp();
        <span class="hljs-type">String</span> <span class="hljs-variable">grayName</span> <span class="hljs-operator">=</span> dumpTask.getGrayName();

        ConfigDumpEvent.<span class="hljs-type">ConfigDumpEventBuilder</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> ConfigDumpEvent.builder().namespaceId(tenant).dataId(dataId)
                .group(group).grayName(grayName).handleIp(handleIp);
        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">"formal"</span>;
        
        <span class="hljs-comment">// 从数据库读取配置信息，构建 ConfigDumpEvent 事件</span>
        <span class="hljs-type">ConfigInfoWrapper</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> configInfoPersistService.findConfigInfo(dataId, group, tenant);
        build.remove(Objects.isNull(cf));
        build.content(Objects.isNull(cf) ? <span class="hljs-literal">null</span> : cf.getContent());
        build.type(Objects.isNull(cf) ? <span class="hljs-literal">null</span> : cf.getType());
        build.encryptedDataKey(Objects.isNull(cf) ? <span class="hljs-literal">null</span> : cf.getEncryptedDataKey());
        build.lastModifiedTs(Objects.isNull(cf) ? lastModifiedOut : cf.getLastModified());
        <span class="hljs-keyword">return</span> DumpConfigHandler.configDump(build.build());
    }
}
</code></pre>
<p>为了方便理解，省略一系列不重要的源码，最终会执行到 <code>ConfigCacheService#dumpWithMd5</code> 方法，在这个方法中修改缓存前会添加写锁 <code>tryWriteLock</code>，添加写锁成功后才能继续处理，后续处理逻辑中有两步比较重要：<strong>“写入到本地文件”</strong> 和 <strong>“更新 JVM 本地缓存对象”</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCacheService</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dumpWithMd5</span><span class="hljs-params">(String dataId, String group, String tenant, String content, String md5,
                                      <span class="hljs-type">long</span> lastModifiedTs, String type, String encryptedDataKey)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey2.getKey(dataId, group, tenant);
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> makeSure(groupKey, encryptedDataKey);
        ci.setType(type);
        <span class="hljs-comment">// 对某个缓存的操作添加了写锁</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">lockResult</span> <span class="hljs-operator">=</span> tryWriteLock(groupKey);

        <span class="hljs-keyword">if</span> (lockResult &lt; <span class="hljs-number">0</span>) {
            DUMP_LOG.warn(<span class="hljs-string">"[dump-error] write lock failed. {}"</span>, groupKey);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 校验修改时间</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">lastModifiedOutDated</span> <span class="hljs-operator">=</span> lastModifiedTs &lt; ConfigCacheService.getLastModifiedTs(groupKey);
            <span class="hljs-keyword">if</span> (lastModifiedOutDated) {
                DUMP_LOG.warn(<span class="hljs-string">"[dump-ignore] timestamp is outdated,groupKey={}"</span>, groupKey);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-type">boolean</span> <span class="hljs-variable">newLastModified</span> <span class="hljs-operator">=</span> lastModifiedTs &gt; ConfigCacheService.getLastModifiedTs(groupKey);

            <span class="hljs-keyword">if</span> (md5 == <span class="hljs-literal">null</span>) {
                md5 = MD5Utils.md5Hex(content, PERSIST_ENCODE);
            }

            <span class="hljs-comment">// 1. 写入到本地文件中</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">localContentMd5</span> <span class="hljs-operator">=</span> ConfigCacheService.getContentMd5(groupKey);
            <span class="hljs-type">boolean</span> <span class="hljs-variable">md5Changed</span> <span class="hljs-operator">=</span> !md5.equals(localContentMd5);
            <span class="hljs-keyword">if</span> (md5Changed) {
                DUMP_LOG.info(<span class="hljs-string">"[dump] md5 changed, save to disk cache ,groupKey={}, newMd5={},oldMd5={}"</span>, groupKey, md5, localContentMd5);
                ConfigDiskServiceFactory.getInstance().saveToDisk(dataId, group, tenant, content);
            } <span class="hljs-keyword">else</span> {
                DUMP_LOG.warn(<span class="hljs-string">"[dump-ignore] ignore to save to disk cache. md5 consistent,groupKey={}, md5={}"</span>, groupKey, md5);
            }

            <span class="hljs-comment">// 2. 更新 JVM 本地缓存对象 CacheItem</span>
            <span class="hljs-keyword">if</span> (md5Changed) {
                DUMP_LOG.info(
                        <span class="hljs-string">"[dump] md5 changed, update md5 and timestamp in jvm cache ,groupKey={}, newMd5={},oldMd5={},lastModifiedTs={}"</span>,
                        groupKey, md5, localContentMd5, lastModifiedTs);
                updateMd5(groupKey, md5, content, lastModifiedTs, encryptedDataKey);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newLastModified) {
                DUMP_LOG.info(
                        <span class="hljs-string">"[dump] md5 consistent ,timestamp changed, update timestamp only in jvm cache ,groupKey={},lastModifiedTs={}"</span>,
                        groupKey, lastModifiedTs);
                updateTimeStamp(groupKey, lastModifiedTs, encryptedDataKey);
            } <span class="hljs-keyword">else</span> {
                DUMP_LOG.warn(
                        <span class="hljs-string">"[dump-ignore] ignore to save to jvm cache. md5 consistent and no new timestamp changed.groupKey={}"</span>,
                        groupKey);
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (IOException ioe) {
            DUMP_LOG.error(<span class="hljs-string">"[dump-exception] save disk error. "</span> + groupKey + <span class="hljs-string">", "</span> + ioe);
            <span class="hljs-keyword">if</span> (ioe.getMessage() != <span class="hljs-literal">null</span>) {
                <span class="hljs-type">String</span> <span class="hljs-variable">errMsg</span> <span class="hljs-operator">=</span> ioe.getMessage();
                <span class="hljs-keyword">if</span> (errMsg.contains(NO_SPACE_CN) || errMsg.contains(NO_SPACE_EN) || errMsg.contains(DISK_QUOTA_CN)
                        || errMsg.contains(DISK_QUOTA_EN)) {
                    <span class="hljs-comment">// Protect from disk full.</span>
                    FATAL_LOG.error(<span class="hljs-string">"Local Disk Full,Exit"</span>, ioe);
                    EnvUtil.systemExit();
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">finally</span> {
            releaseWriteLock(groupKey);
        }
    }
    
}
</code></pre>
<p>我们先来看一下 “写入到本地文件” 的逻辑，它最终会执行到 <code>ConfigDiskService#saveToDisk</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRawDiskService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigDiskService</span> {
    
    <span class="hljs-comment">// 将配置信息写入磁盘文件</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveToDisk</span><span class="hljs-params">(String dataId, String group, String tenant, String content)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">File</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> targetFile(dataId, group, tenant);
        FileUtils.writeStringToFile(targetFile, content, ENCODE_UTF8);
    }
}
</code></pre>
<p>在这个方法中，它会将配置信息写入磁盘文件中，也就是说：<strong>Nacos 配置变更后，会异步将配置信息写入磁盘文件</strong>。这个文件何时被读取我们先不关注，我们先来考虑一下，如果配置变更在写入数据库成功后，服务立即宕机，也就是说磁盘文件还没有来得及写入，那么磁盘文件的数据该如何和数据库数据保持一致呢？</p>
<p>Nacos 借助 <code>@PostConstruct</code> 注解，在服务启动时，会执行 <code>DumpService#dumpOperate</code> 方法，这个方法的源码就不在这里贴了，它最终会执行到 <code>DumpAllProcessor#process</code> 方法，分页查询出所有的配置信息，逐一异步写入本地磁盘文件中，这样就保证了磁盘文件和数据库数据的一致性。</p>
<p>接下来我们再来看一下 “更新 JVM 本地缓存对象” 的逻辑，这段逻辑并不复杂，首先它需要保证在 JVM 本地缓存中创建了 <code>CacheItem</code> 本地缓存对象，然后创建 <code>ConfigCache</code> 对象记录必要的信息，注意在这段逻辑中，并没有为配置的内容 <code>content</code> 定义字段保存，这些逻辑完成后，发送了 <code>LocalDataChangeEvent</code> 事件：</p>
<blockquote>
<p>发送 <code>LocalDataChangeEvent</code> 事件的逻辑比较隐蔽，就像分布式事务中协同式 Saga 的设计模式（参见《微服务设计模式》），一个事件处理完成再去处理下一个事件，这使得代码的复杂度增加。</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCacheService</span> {

    <span class="hljs-comment">/**
     * groupKey -&gt; cacheItem.
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, CacheItem&gt; CACHE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateMd5</span><span class="hljs-params">(String groupKey, String md5, String content, <span class="hljs-type">long</span> lastModifiedTs, String encryptedDataKey)</span> {
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> makeSure(groupKey, encryptedDataKey);
        <span class="hljs-type">ConfigCache</span> <span class="hljs-variable">configCache</span> <span class="hljs-operator">=</span> cache.getConfigCache();
        <span class="hljs-keyword">if</span> (configCache.getMd5() == <span class="hljs-literal">null</span> || !configCache.getMd5().equals(md5)) {
            configCache.setMd5(md5);
            configCache.setLastModifiedTs(lastModifiedTs);
            configCache.setEncryptedDataKey(encryptedDataKey);
            ConfigCachePostProcessorDelegate.getInstance().postProcess(configCache, content);
            <span class="hljs-comment">// 更新本地 JVM 缓存后，发布 LocalDataChangeEvent 事件</span>
            NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDataChangeEvent</span>(groupKey));
        }
    }

    <span class="hljs-keyword">static</span> CacheItem <span class="hljs-title function_">makeSure</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String groupKey, <span class="hljs-keyword">final</span> String encryptedDataKey)</span> {
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> CACHE.get(groupKey);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != item) {
            <span class="hljs-keyword">return</span> item;
        }
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheItem</span>(groupKey, encryptedDataKey);
        item = CACHE.putIfAbsent(groupKey, tmp);
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == item) ? tmp : item;
    }
}
</code></pre>
<p>现在，配置变更已经成功写入数据库、磁盘文件和 JVM 内存，保证了在 Nacos Server 端配置数据的一致性。接下来便是由 Nacos Server 推送给 Nacos Client 的流程，这个逻辑便是在 <code>LocalDataChangeEvent</code> 事件的处理逻辑中完成的，<code>RpcConfigChangeNotifier#onEvent</code> 方法会监听 <code>LocalDataChangeEvent</code> 事件，并执行 <code>configDataChanged</code> 方法，这个方法的逻辑比较复杂，我们分段来看：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcConfigChangeNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subscriber</span>&lt;LocalDataChangeEvent&gt; {

    <span class="hljs-meta">@Autowired</span>
    ConfigChangeListenContext configChangeListenContext;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ConnectionManager connectionManager;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(LocalDataChangeEvent event)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> event.groupKey;

        String[] strings = GroupKey.parseKey(groupKey);
        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> strings[<span class="hljs-number">0</span>];
        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> strings[<span class="hljs-number">1</span>];
        <span class="hljs-type">String</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> strings.length &gt; <span class="hljs-number">2</span> ? strings[<span class="hljs-number">2</span>] : <span class="hljs-string">""</span>;

        <span class="hljs-comment">// 监听LocalDataChangeEvent事件，通过 gRPC 双向流推送配置变更通知到客户端</span>
        configDataChanged(groupKey, dataId, group, tenant);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configDataChanged</span><span class="hljs-params">(String groupKey, String dataId, String group, String tenant)</span> {
        <span class="hljs-comment">// 获取所有监听该配置的客户端连接</span>
        Set&lt;String&gt; listeners = configChangeListenContext.getListeners(groupKey);
        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(listeners)) {
            <span class="hljs-keyword">return</span>;
        }
        
        <span class="hljs-type">int</span> <span class="hljs-variable">notifyClientCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> String client : listeners) {
            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionManager.getConnection(client);
            <span class="hljs-keyword">if</span> (connection == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-type">boolean</span> <span class="hljs-variable">ifNamespaceTransfer</span> <span class="hljs-operator">=</span> configChangeListenContext.getConfigListenState(client, groupKey).isNamespaceTransfer();
            <span class="hljs-keyword">if</span> (ifNamespaceTransfer) {
                tenant = <span class="hljs-literal">null</span>;
            }
            <span class="hljs-type">ConnectionMeta</span> <span class="hljs-variable">metaInfo</span> <span class="hljs-operator">=</span> connection.getMetaInfo();
            <span class="hljs-type">String</span> <span class="hljs-variable">clientIp</span> <span class="hljs-operator">=</span> metaInfo.getClientIp();

            <span class="hljs-comment">// 构建 ConfigChangeNotifyRequest 请求，包含变更的配置信息</span>
            <span class="hljs-type">ConfigChangeNotifyRequest</span> <span class="hljs-variable">notifyRequest</span> <span class="hljs-operator">=</span> ConfigChangeNotifyRequest.build(dataId, group, tenant);

            <span class="hljs-comment">// 创建 RpcPushTask 异步推送任务，支持重试机制</span>
            <span class="hljs-type">RpcPushTask</span> <span class="hljs-variable">rpcPushRetryTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcPushTask</span>(notifyRequest,
                    ConfigCommonConfig.getInstance().getMaxPushRetryTimes(), client, clientIp, metaInfo.getAppName());
            <span class="hljs-comment">// 异步推送通知</span>
            push(rpcPushRetryTask, connectionManager);
            notifyClientCount++;
        }
    }

    <span class="hljs-comment">// 处理推送任务重试逻辑，支持延迟重试和连接管理</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(RpcPushTask retryTask, ConnectionManager connectionManager)</span> {
        <span class="hljs-type">ConfigChangeNotifyRequest</span> <span class="hljs-variable">notifyRequest</span> <span class="hljs-operator">=</span> retryTask.getNotifyRequest();
        <span class="hljs-keyword">if</span> (retryTask.isOverTimes()) {
            <span class="hljs-comment">// 重试次数超限，注销客户端连接</span>
            connectionManager.unregister(retryTask.getConnectionId());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (connectionManager.getConnection(retryTask.getConnectionId()) != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 客户端连接存在，延迟重试推送（首次延迟0s，第二次2s，第三次4s），</span>
            <span class="hljs-comment">// 本质上执行的是 ScheduledExecutorService#schedule(Runnable command, long delay, TimeUnit unit); 方法</span>
            ConfigExecutor.scheduleClientConfigNotifier(retryTask, retryTask.getTryTimes() * <span class="hljs-number">2</span>, TimeUnit.SECONDS);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 客户端已离线，忽略推送任务</span>
        }
    }
}
</code></pre>
<p>在 <code>configDataChanged</code> 方法中，会先获取当前连接到 Nacos Server 的 所有订阅某个配置 <code>groupKey</code> 的 Nacos Client 连接，创建 <code>RpcPushTask</code> 异步推送任务，并调用 <code>push</code> 方法异步推送配置变更通知，注意这里执行配置推送任务时，使用的是 <code>ScheduledExecutorService#schedule</code> 它会根据重试次数指定延迟推送时间，首次推送是不延迟的，如果超过重试次数，表示客户端无法响应，则注销客户端连接，接下来我们看一下 <code>RpcPushTask</code> 的逻辑，它是 <code>RpcConfigChangeNotifier</code> 的内部类：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcConfigChangeNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subscriber</span>&lt;LocalDataChangeEvent&gt; {
    
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcPushTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {

        ConfigChangeNotifyRequest notifyRequest;

        <span class="hljs-type">int</span> maxRetryTimes;

        <span class="hljs-type">int</span> <span class="hljs-variable">tryTimes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

        String connectionId;

        String clientIp;

        String appName;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcPushTask</span><span class="hljs-params">(ConfigChangeNotifyRequest notifyRequest, <span class="hljs-type">int</span> maxRetryTimes, String connectionId,
                           String clientIp, String appName)</span> {
            <span class="hljs-built_in">this</span>.notifyRequest = notifyRequest;
            <span class="hljs-built_in">this</span>.maxRetryTimes = maxRetryTimes;
            <span class="hljs-built_in">this</span>.connectionId = connectionId;
            <span class="hljs-built_in">this</span>.clientIp = clientIp;
            <span class="hljs-built_in">this</span>.appName = appName;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOverTimes</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> maxRetryTimes &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">this</span>.tryTimes &gt;= maxRetryTimes;
        }

        <span class="hljs-comment">// 异步执行配置推送任务</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 累加推送配置的重试次数</span>
            tryTimes++;
            <span class="hljs-type">TpsCheckRequest</span> <span class="hljs-variable">tpsCheckRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TpsCheckRequest</span>();

            tpsCheckRequest.setPointName(POINT_CONFIG_PUSH);
            <span class="hljs-keyword">if</span> (!tpsControlManager.check(tpsCheckRequest).isSuccess()) {
                <span class="hljs-comment">// TPS限流检查失败，延迟重试推送任务</span>
                push(<span class="hljs-built_in">this</span>, connectionManager);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// TPS检查通过，通过 gRPC 双向流推送配置变更通知到客户端</span>
                rpcPushService.pushWithCallback(connectionId, notifyRequest,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcPushCallback</span>(<span class="hljs-built_in">this</span>, tpsControlManager, connectionManager),
                        ConfigExecutor.getClientConfigNotifierServiceExecutor());
            }
        }
    }
}
</code></pre>
<p><code>RpcPushTask#run</code> 方法中会先检查限流配置，如果限流检查通过会通过 gRPC 推送配置变更到 Nacos Client，借助的是 gRPC 的双向流接口，并根据结果调用 <code>RpcPushCallback</code> 中的回调方法，<code>RpcPushCallback</code> 是 <code>RpcConfigChangeNotifier</code> 的内部类。如果配置推送成功会记录推送成功统计，否则调用 <code>RpcConfigChangeNotifier#push</code> 方法重试推送配置，如果超过最大重试次数（3次）则注销掉客户端：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcConfigChangeNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subscriber</span>&lt;LocalDataChangeEvent&gt; {
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcPushCallback</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractPushCallBack</span> {

        RpcPushTask rpcPushTask;

        TpsControlManager tpsControlManager;

        ConnectionManager connectionManager;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcPushCallback</span><span class="hljs-params">(RpcPushTask rpcPushTask, TpsControlManager tpsControlManager,
                               ConnectionManager connectionManager)</span> {
            <span class="hljs-built_in">super</span>(<span class="hljs-number">3000L</span>);
            <span class="hljs-built_in">this</span>.rpcPushTask = rpcPushTask;
            <span class="hljs-built_in">this</span>.tpsControlManager = tpsControlManager;
            <span class="hljs-built_in">this</span>.connectionManager = connectionManager;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 客户端成功接收配置变更通知，记录推送成功统计</span>
            <span class="hljs-type">TpsCheckRequest</span> <span class="hljs-variable">tpsCheckRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TpsCheckRequest</span>();
            tpsCheckRequest.setPointName(POINT_CONFIG_PUSH_SUCCESS);
            tpsControlManager.check(tpsCheckRequest);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFail</span><span class="hljs-params">(Throwable e)</span> {
            <span class="hljs-comment">// 推送失败，记录失败统计并进行重试</span>
            <span class="hljs-type">TpsCheckRequest</span> <span class="hljs-variable">tpsCheckRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TpsCheckRequest</span>();
            tpsCheckRequest.setPointName(POINT_CONFIG_PUSH_FAIL);
            tpsControlManager.check(tpsCheckRequest);
            Loggers.REMOTE_PUSH.warn(<span class="hljs-string">"Push fail, dataId={}, group={}, tenant={}, clientId={}"</span>,
                    rpcPushTask.getNotifyRequest().getDataId(), rpcPushTask.getNotifyRequest().getGroup(),
                    rpcPushTask.getNotifyRequest().getTenant(), rpcPushTask.getConnectionId(), e);
            push(rpcPushTask, connectionManager);
        }
    }
}
</code></pre>
<p>注意，<code>RpcPushTask</code> 在执行过程中都是没有被持久化的，也就是说一旦在执行过程中发生服务宕机，这些任务也会丢失，没有办法重新拉起向订阅配置的客户端推送，这样会不会导致客户端无法收到配置变更通知呢？实际上是不会的，配置变更除了服务端会主动推送以外，客户端还存在主动拉取的机制，也就是说 <strong>配置同步是推、拉结合的</strong>，保证客户端能够及时感知到配置变更，客户端的具体逻辑我们在后文中再解释。</p>
<p>以上我们讲解了 Nacos Server 单机采用 MySQL 数据库部署时，保证配置变更高可用的机制，接下来我们再看一下当集群部署并使用内嵌 Derby 数据库时，保证配置变更高可用的实现。</p>
<h4 data-id="heading-2">集群部署，采用内嵌 Derby 数据库</h4>
<p>Nacos Server 在集群模式部署时，也可以使用 MySQL 数据库，不过因为集群模式使用 MySQL 数据库与单机模式使用 MySQL 数据库对数据一致性的保证没有区别，所以我们就不再讨论这种情况了。值得讨论的是：在集群模式下，Nacos Server 还支持使用内嵌数据库 Derby 部署，这种情况下，Nacos 采用了 Raft 算法保证了集群的强一致性，Raft 算法的实现它使用的是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.sofastack.tech%2Fprojects%2Fsofa-jraft%2Foverview%2F" target="_blank" title="https://www.sofastack.tech/projects/sofa-jraft/overview/" ref="nofollow noopener noreferrer">开源项目 JRaft</a>。在本文中，我们不会具体讲解 Raft 算法的流程，如果大家感兴趣可以参考文章 <a href="https://juejin.cn/post/7544003305972088878" target="_blank" title="https://juejin.cn/post/7544003305972088878">深入理解分布式共识算法 Raft</a>。如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b3ead27e7f74c35b81d73b6b9f2f32b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763798468&amp;x-signature=xJTP5OB3SUsFHMDUO1dSn4GlaKc%3D" alt="image.png" loading="lazy"/></p>
<p>Nacos 在集群部署时，在控制台进行配置变更后，<strong>请求只会打到其中一台服务上</strong>，在这一台服务上会触发 JRaft 算法来完成各个服务内的 Derby 数据的写入，同样地，与写入 MySQL 的流程一致，只有在 JRaft 写入执行成功后才能继续处理。</p>
<p>在接收到请求的这台服务上，它会像单机模式一样发送 <code>ConfigDataChangeEvent</code> 事件，触发文件转存的操作，因为这部分内容是重复的就不再赘述了。集群模式与单机模式不同的是还有一个 <code>AsyncNotifyService</code> 服务会监听消费 <code>ConfigDataChangeEvent</code> 事件。<code>AsyncNotifyService</code> 的功能是 <strong>通知集群内其他节点触发文件转存的操作</strong>，如图所示，它会将通知集群内每个节点的请求封装成 <code>NotifySingleRpcTask</code>，创建所有节点的通知任务后，打包创建 <code>AsyncRpcTask</code> 任务，这个任务会被添加到 <code>ScheduledExecutorService</code> 线程池中，由线程池异步延时处理，如果发生处理失败的情况，会重新提交到线程池中，作为新的任务进行处理，以此来保证通知任务的处理成功。</p>
<p>以上就是 Nacos 在集群模式下采用 Derby 数据库时配置变更的处理流程，下面的内容我们根据源码来分析：当在 Nacos 控制台对配置进行修改时，Nacos 是如何借助 JRaft 保证数据一致性的。</p>
<hr/>
<p>同样地，<code>ConsoleConfigController#publishConfig</code> 方法是在 Nacos 控制台修改配置的入口，承接配置变更的 POST 请求：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@NacosApi</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/v3/console/cs/config")</span>
<span class="hljs-meta">@ExtractorManager</span>.Extractor(httpExtractor = ConfigDefaultHttpParamExtractor.class)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleConfigController</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigProxy configProxy;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConsoleConfigController</span><span class="hljs-params">(ConfigProxy configProxy)</span> {
        <span class="hljs-built_in">this</span>.configProxy = configProxy;
    }
    
    <span class="hljs-meta">@PostMapping()</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.WRITE, signType = SignType.CONFIG, apiType = ApiType.CONSOLE_API)</span>
    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">publishConfig</span><span class="hljs-params">(HttpServletRequest request, ConfigFormV3 configForm)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// ...</span>

        <span class="hljs-keyword">return</span> Result.success(configProxy.publishConfig(configForm, configRequestInfo));
    }
}
</code></pre>
<p>因为 Nacos Server 启动时配置内嵌（Embedded）数据库 Derby，所以它会执行到 <code>EmbeddedConfigInfoPersistServiceImpl</code> 相关的方法中，我们以其中的 <code>EmbeddedConfigInfoPersistServiceImpl#updateConfigInfoCas</code> 方法为例，在这个方法中有一个私有方法 <code>updateConfigInfoAtomicCas</code> 特别关键，它主要在这里封装 SQL 的参数，并生成一条 SQL 并不立即执行，而是封装到上下文 <code>EmbeddedStorageContextHolder</code> 中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service("embeddedConfigInfoPersistServiceImpl")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedConfigInfoPersistServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigInfoPersistService</span> {

    <span class="hljs-keyword">private</span> ConfigOperateResult <span class="hljs-title function_">updateConfigInfoAtomicCas</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ConfigInfo configInfo, <span class="hljs-keyword">final</span> String srcIp,
                                                          <span class="hljs-keyword">final</span> String srcUser, Map&lt;String, Object&gt; configAdvanceInfo)</span> {
        <span class="hljs-comment">// 处理 SQL 的入参</span>
        <span class="hljs-type">MapperContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperContext</span>();
        context.putUpdateParameter(FieldConstant.CONTENT, configInfo.getContent());
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// 生成 SQL 而不执行（ConfigInfoMapper#updateConfigInfoAtomicCas 在接口中定义的 default 方法）</span>
        <span class="hljs-type">MapperResult</span> <span class="hljs-variable">mapperResult</span> <span class="hljs-operator">=</span> configInfoMapper.updateConfigInfoAtomicCas(context);

        <span class="hljs-comment">// 保存在上下文中</span>
        EmbeddedStorageContextHolder.addSqlContext(Boolean.TRUE, mapperResult.getSql(),
                mapperResult.getParamList().toArray());
        <span class="hljs-keyword">return</span> getConfigInfoOperateResult(configInfo.getDataId(), configInfo.getGroup(), tenantTmp);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigInfoMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span> {
    <span class="hljs-keyword">default</span> MapperResult <span class="hljs-title function_">updateConfigInfoAtomicCas</span><span class="hljs-params">(MapperContext context)</span> {
        List&lt;Object&gt; paramList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-comment">// 封装 set 中的参数</span>
        paramList.add(context.getUpdateParameter(FieldConstant.CONTENT));
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// 封装 where 中的参数</span>
        paramList.add(context.getWhereParameter(FieldConstant.MD5));
        <span class="hljs-comment">// ...</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"UPDATE config_info SET "</span> + <span class="hljs-string">"content=?, md5=?, src_ip=?, src_user=?, gmt_modified="</span>
                + getFunction(<span class="hljs-string">"NOW()"</span>)
                + <span class="hljs-string">", app_name=?, c_desc=?, c_use=?, effect=?, type=?, c_schema=?, encrypted_data_key=? "</span>
                + <span class="hljs-string">"WHERE data_id=? AND group_id=? AND tenant_id=? AND (md5=? OR md5 IS NULL OR md5='')"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperResult</span>(sql, paramList);
    }
}
</code></pre>
<p>在这里有两个点值得注意：</p>
<ol>
<li>生成 Update SQL 而不执行，却放在了上下文 <code>EmbeddedStorageContextHolder</code> 中，它是一个 <code>ThreadLocal</code> 对象</li>
<li>生成的 SQL 使用 CAS 的策略，在 WHERE 条件中它会将前端控制台配置的 MD5 值作为条件传入，防止并发修改配置时的脏写问题</li>
</ol>
<p>现在既然已经将变更 Derby 数据库 Update SQL 保存在了上下文中，接下来就是看它什么时候被执行了，它会继续执行 <code>DatabaseOperate#blockUpdate</code> 方法，从它的命名中也能发现它是同步阻塞执行的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DatabaseOperate</span> {
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-comment">// 阻塞更新逻辑</span>
    <span class="hljs-keyword">default</span> Boolean <span class="hljs-title function_">blockUpdate</span><span class="hljs-params">(BiConsumer&lt;Boolean, Throwable&gt; consumer)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 在上下文中获取 SQL</span>
            <span class="hljs-keyword">return</span> update(EmbeddedStorageContextHolder.getCurrentSqlContext(), consumer);
        } <span class="hljs-keyword">finally</span> {
            EmbeddedStorageContextHolder.cleanAllContext();
        }
    }

}
</code></pre>
<p>它是一个 <code>default</code> 方法，会调用 <code>DistributedDatabaseOperateImpl#update</code> 方法，它会将 SQL 封装在 <code>WriteRequest</code> 中，调用封装好的 Raft 协议的 <code>write</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedDatabaseOperateImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestProcessor4CP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseDatabaseOperate</span> {

    <span class="hljs-keyword">private</span> CPProtocol protocol;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(List&lt;ModifyRequest&gt; sqlContext, BiConsumer&lt;Boolean, Throwable&gt; consumer)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span>
                    System.currentTimeMillis() + <span class="hljs-string">"-"</span> + group() + <span class="hljs-string">"-"</span> + memberManager.getSelf().getAddress() + <span class="hljs-string">"-"</span>
                            + MD5Utils.md5Hex(sqlContext.toString(), PersistenceConstant.DEFAULT_ENCODE);
            <span class="hljs-type">WriteRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> WriteRequest.newBuilder().setGroup(group()).setKey(key)
                    <span class="hljs-comment">// 将 SQL 序列化成字节数组保存在 WriteRequest 中</span>
                    .setData(ByteString.copyFrom(serializer.serialize(sqlContext)))
                    .putAllExtendInfo(EmbeddedStorageContextHolder.getCurrentExtendInfo())
                    .setType(sqlContext.getClass().getCanonicalName()).build();
            
            <span class="hljs-keyword">if</span> (Objects.isNull(consumer)) {
                <span class="hljs-comment">// 重要：raft 协议 write 开始执行，同步阻塞调用</span>
                <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.protocol.write(request);
                <span class="hljs-keyword">if</span> (response.getSuccess()) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
                LOGGER.error(<span class="hljs-string">"execute sql modify operation failed : {}"</span>, response.getErrMsg());
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// ...</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (TimeoutException e) {
            LOGGER.error(<span class="hljs-string">"An timeout exception occurred during the update operation"</span>);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRuntimeException</span>(NacosException.SERVER_ERROR, e.toString());
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            LOGGER.error(<span class="hljs-string">"An exception occurred during the update operation : {}"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRuntimeException</span>(NacosException.SERVER_ERROR, e.toString());
        }
    }
}
</code></pre>
<p>其中 <code>Response response = this.protocol.write(request);</code> 逻辑为执行 Raft 算法的写流程：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRaftProtocol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConsistencyProtocol</span>&lt;RaftConfig, RequestProcessor4CP&gt;
        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CPProtocol</span>&lt;RaftConfig, RequestProcessor4CP&gt; {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">write</span><span class="hljs-params">(WriteRequest request)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 依靠 CompletableFuture 实现阻塞同步调用</span>
        CompletableFuture&lt;Response&gt; future = writeAsync(request);
        <span class="hljs-keyword">return</span> future.get(<span class="hljs-number">10_000L</span>, TimeUnit.MILLISECONDS);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;Response&gt; <span class="hljs-title function_">writeAsync</span><span class="hljs-params">(WriteRequest request)</span> {
        <span class="hljs-keyword">return</span> raftServer.commit(request.getGroup(), request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;());
    }
}
</code></pre>
<p>在这段逻辑中依靠 <code>CompletableFuture</code> 实现了同步阻塞的写调用。<code>JRaftServer#commit</code> 方法是处理 Raft 算法中写请求的流程：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRaftServer</span> {
    <span class="hljs-comment">/**
     * [raft] 处理写请求，所有写操作必须通过 Leader 节点处理
     */</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;Response&gt; <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String group, <span class="hljs-keyword">final</span> Message data,
                                              <span class="hljs-keyword">final</span> CompletableFuture&lt;Response&gt; future)</span> {
        LoggerUtils.printIfDebugEnabled(Loggers.RAFT, <span class="hljs-string">"data requested this time : {}"</span>, data);
        <span class="hljs-keyword">final</span> <span class="hljs-type">RaftGroupTuple</span> <span class="hljs-variable">tuple</span> <span class="hljs-operator">=</span> findTupleByGroup(group);
        <span class="hljs-keyword">if</span> (tuple == <span class="hljs-literal">null</span>) {
            future.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"No corresponding Raft Group found : "</span> + group));
            <span class="hljs-keyword">return</span> future;
        }

        <span class="hljs-type">FailoverClosureImpl</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FailoverClosureImpl</span>(future);

        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tuple.node;
        <span class="hljs-keyword">if</span> (node.isLeader()) {
            <span class="hljs-comment">// 当前节点是 Leader，直接应用写操作到状态机</span>
            applyOperation(node, data, closure);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 当前节点不是 Leader，将请求转发给 Leader 处理</span>
            invokeToLeader(group, data, rpcRequestTimeoutMs, closure);
        }
        <span class="hljs-keyword">return</span> future;
    }
}
</code></pre>
<p>如果是 Leader 节点的话，直接操作日志写入，在这里的逻辑都是与 JRaft 框架相关了，不过我们只需要关注与 Raft 算法有关的流程，注意注释信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRaftServer</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyOperation</span><span class="hljs-params">(Node node, Message data, FailoverClosure closure)</span> {
        <span class="hljs-comment">// Task 是用户使用 jraft 最核心的类之一，用于向一个 raft 集群提交一个任务，这个任务提交到 leader，并复制到其他 follower 节点</span>
        <span class="hljs-comment">// 通俗的理解为让 Leader 节点记录 log 日志，并同步到其他 Follower 节点</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();
        <span class="hljs-comment">// done 表示任务的回调方法，在任务完成的时候，即 apply 的时候，通知此回调对象，无论成功还是失败。</span>
        task.setDone(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosClosure</span>(data, status -&gt; {
            NacosClosure.<span class="hljs-type">NacosStatus</span> <span class="hljs-variable">nacosStatus</span> <span class="hljs-operator">=</span> (NacosClosure.NacosStatus) status;
            closure.setThrowable(nacosStatus.getThrowable());
            closure.setResponse(nacosStatus.getResponse());
            closure.run(nacosStatus);
        }));

        <span class="hljs-comment">// add request type field at the head of task data.</span>
        <span class="hljs-type">byte</span>[] requestTypeFieldBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>];
        requestTypeFieldBytes[<span class="hljs-number">0</span>] = ProtoMessageUtil.REQUEST_TYPE_FIELD_TAG;
        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> ReadRequest) {
            requestTypeFieldBytes[<span class="hljs-number">1</span>] = ProtoMessageUtil.REQUEST_TYPE_READ;
        } <span class="hljs-keyword">else</span> {
            requestTypeFieldBytes[<span class="hljs-number">1</span>] = ProtoMessageUtil.REQUEST_TYPE_WRITE;
        }

        <span class="hljs-comment">// data 任务的数据，在本次逻辑中是变更配置的 SQL，用户应当将要复制的业务数据通过一定序列化方式（比如 java/hessian2) 序列化成一个 ByteBuffer，放到 task 里</span>
        <span class="hljs-type">byte</span>[] dataBytes = data.toByteArray();
        task.setData((ByteBuffer) ByteBuffer.allocate(requestTypeFieldBytes.length + dataBytes.length)
                .put(requestTypeFieldBytes).put(dataBytes).position(<span class="hljs-number">0</span>));
        <span class="hljs-comment">// 使用 node 提交任务，node 可以为是 Raft 集群的 Leader 节点，操作 apply 方法之后表示将日志记录下来并给其他 Follower 节点同步</span>
        node.apply(task);
    }
}
</code></pre>
<p>当在 Raft 集群中有超过半数节点已经将本次任务的日志持久化后，它会自动调用 <code>StateMachineAdapter#onApply</code> 方法，表示将日志应用到状态机，即使写请求生效：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosStateMachine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StateMachineAdapter</span> {
    
    <span class="hljs-comment">/**
     * 最核心的方法，应用任务列表应用到状态机，任务将按照提交顺序应用。
     * 请注意，当这个方法返回的时候，我们就认为这一批任务都已经成功应用到状态机上，如果你没有完全应用（比如错误、异常），
     * 将会被当做一个 critical 级别的错误，报告给状态机的 StateMachineAdapter#onError 方法，错误类型为 ERROR_TYPE_STATE_MACHINE
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApply</span><span class="hljs-params">(Iterator iter)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">applied</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        Message message;
        <span class="hljs-type">NacosClosure</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 遍历处理本次应用的任务（日志）</span>
            <span class="hljs-keyword">while</span> (iter.hasNext()) {
                <span class="hljs-comment">// 结果通过 Status 告知，Status#isOk() 告诉你成功还是失败</span>
                <span class="hljs-type">Status</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> Status.OK();
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 如果 task 没有设置 closure，那么 done 会是 null，</span>
                    <span class="hljs-comment">// 另外在 follower 节点上，done 也是 null，因为 done 不会被复制到除了 leader 节点之外的其他 raft 节点</span>
                    <span class="hljs-keyword">if</span> (iter.done() != <span class="hljs-literal">null</span>) {
                        <span class="hljs-comment">// 获取回调函数</span>
                        closure = (NacosClosure) iter.done();
                        <span class="hljs-comment">// 从 Leader 节点的日志条目中获取消息</span>
                        message = closure.getMessage();
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// 从 Follower 节点复制的日志条目中解析消息</span>
                        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> iter.getData();
                        <span class="hljs-comment">// 解析成 SQL</span>
                        message = ProtoMessageUtil.parse(data.array());
                        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> ReadRequest) {
                            <span class="hljs-comment">// Follower 节点忽略读请求，只处理写请求</span>
                            applied++;
                            index++;
                            iter.next();
                            <span class="hljs-keyword">continue</span>;
                        }
                    }

                    LoggerUtils.printIfDebugEnabled(Loggers.RAFT, <span class="hljs-string">"receive log : {}"</span>, message);

                    <span class="hljs-comment">// 应用写请求到业务状态机，实现数据的持久化存储</span>
                    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> WriteRequest) {
                        <span class="hljs-comment">// 使 Update SQL 执行并生效，在 Response 中返回执行结果</span>
                        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> processor.onApply((WriteRequest) message);
                        <span class="hljs-comment">// 对结果的后置处理</span>
                        postProcessor(response, closure);
                    }

                    <span class="hljs-comment">// 处理读请求（仅在 Leader 节点）</span>
                    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> ReadRequest) {
                        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> processor.onRequest((ReadRequest) message);
                        postProcessor(response, closure);
                    }
                } <span class="hljs-keyword">catch</span> (Throwable e) {
                    index++;
                    status.setError(RaftError.UNKNOWN, e.toString());
                    Optional.ofNullable(closure).ifPresent(closure1 -&gt; closure1.setThrowable(e));
                    <span class="hljs-keyword">throw</span> e;
                } <span class="hljs-keyword">finally</span> {
                    Optional.ofNullable(closure).ifPresent(closure1 -&gt; closure1.run(status));
                }

                applied++;
                index++;
                iter.next();
            }
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-comment">// 状态机应用失败时进行回滚，保证数据一致性</span>
            Loggers.RAFT.error(<span class="hljs-string">"processor : {}, stateMachine meet critical error: {}."</span>, processor, t);
            iter.setErrorAndRollback(index - applied,
                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Status</span>(RaftError.ESTATEMACHINE, <span class="hljs-string">"StateMachine meet critical error: %s."</span>,
                            ExceptionUtil.getStackTrace(t)));
        }
    }
}
</code></pre>
<p>因为将任务应用到状态机时会在 Leader 和 Follower 节点都执行，所以以上逻辑会包含针对 Leader 节点和 Follower 节点的执行逻辑。它会在 <code>Response response = processor.onApply((WriteRequest) message);</code> 逻辑中完成 Update SQL 的执行，如下 <code>DistributedDatabaseOperateImpl#onApply</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Conditional(ConditionDistributedEmbedStorage.class)</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedDatabaseOperateImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestProcessor4CP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseDatabaseOperate</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">onApply</span><span class="hljs-params">(WriteRequest log)</span> {
        LoggerUtils.printIfDebugEnabled(LOGGER, <span class="hljs-string">"onApply info : log : {}"</span>, log);
        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteString</span> <span class="hljs-variable">byteString</span> <span class="hljs-operator">=</span> log.getData();
        Preconditions.checkArgument(byteString != <span class="hljs-literal">null</span>, <span class="hljs-string">"Log.getData() must not null"</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> readLock;
        lock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将任务中的数据转换成本次修改配置要执行的 SQL</span>
            List&lt;ModifyRequest&gt; sqlContext = serializer.deserialize(byteString.toByteArray(), List.class);
            sqlLimiter.doLimitForModifyRequest(sqlContext);
            <span class="hljs-type">boolean</span> <span class="hljs-variable">isOk</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
            <span class="hljs-comment">// 区分导入和非导入逻辑</span>
            <span class="hljs-keyword">if</span> (log.containsExtendInfo(DATA_IMPORT_KEY)) {
                isOk = doDataImport(jdbcTemplate, sqlContext);
            } <span class="hljs-keyword">else</span> {
                sqlContext.sort(Comparator.comparingInt(ModifyRequest::getExecuteNo));
                <span class="hljs-comment">// 执行修改 SQL</span>
                isOk = update(transactionTemplate, jdbcTemplate, sqlContext);
                PersistenceExecutor.executeEmbeddedDump(() -&gt; {
                    <span class="hljs-keyword">for</span> (EmbeddedApplyHook each : EmbeddedApplyHookHolder.getInstance().getAllHooks()) {
                        each.afterApply(log);
                    }
                });
            }

            <span class="hljs-keyword">return</span> Response.newBuilder().setSuccess(isOk).build();
        } <span class="hljs-keyword">catch</span> (BadSqlGrammarException | DataIntegrityViolationException e) {
            <span class="hljs-keyword">return</span> Response.newBuilder().setSuccess(<span class="hljs-literal">false</span>).setErrMsg(e.toString()).build();
        } <span class="hljs-keyword">catch</span> (DataAccessException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistencyException</span>(e.toString());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            LoggerUtils.printIfWarnEnabled(LOGGER, <span class="hljs-string">"onApply warn : log : {}"</span>, log, e);
            <span class="hljs-keyword">return</span> Response.newBuilder().setSuccess(<span class="hljs-literal">false</span>).setErrMsg(e.toString()).build();
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
    }
}
</code></pre>
<p>执行完成后，通过 <code>Response</code> 对象来判断执行成功还是执行失败，<code>postProcessor</code> 方法负责后置处理，最终回调的逻辑如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailoverClosureImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FailoverClosure</span> {
    
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CompletableFuture&lt;Response&gt; future;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Status status)</span> {
        <span class="hljs-comment">// 调用 CompletableFuture#complete 方法标记任务完成，同步阻塞调用恢复，并返回结果值</span>
        <span class="hljs-keyword">if</span> (status.isOk()) {
            future.complete(data);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">final</span> <span class="hljs-type">Throwable</span> <span class="hljs-variable">throwable</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.throwable;
        future.completeExceptionally(Objects.nonNull(throwable) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistencyException</span>(throwable.getMessage())
                : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistencyException</span>(<span class="hljs-string">"operation failure"</span>));
    }
    
}
</code></pre>
<p>其中 <code>future</code> 字段为在执行 Raft 的写请求时保证同步阻塞调用的 <code>CompletableFuture</code>，如果执行成功调用 <code>CompletableFuture#complete</code> 方法便能让停止阻塞并返回结果，以上便是在 Nacos 集群中执行写请求的流程。在 Nacos 源码的 <code>DistributedDatabaseOperateImpl</code> 类上有以下流程图注释能非常清晰的反映整个流程：</p>
<ol>
<li>用户 <code>user</code> 执行配置变更时执行 <code>publishConfig</code> 的逻辑，要执行的 SQL 会被保存在上下文 <code>SqlContextUtils</code> 中</li>
<li>对数据库的操作都会被提交到 JRaft 协议状态机 <code>JRaftProtocol</code> 中执行，应用 <code>onApply</code> 到状态机时会从上下文 <code>SqlContextUtils</code> 中获取 SQL 并执行</li>
<li>同步阻塞返回用户 <code>user</code> 结果</li>
</ol>
<pre><code class="hljs language-text" lang="text">                   ┌────────────────────┐
               ┌──▶│   PersistService   │
               │   └────────────────────┘ ┌─────────────────┐
               │              │           │                 │
               │              │           │                 │
               │              │           │                 │
               │              │           │                 │
               │              │           │                 │
               │              │           │                 │
               │              │           │                 │
               │              │           │                 ▼
               │              │           │      ┌────────────────────┐          save sql
               │              ▼           │      │     saveConfig     │──────────context─────────────┐
               │     ┌────────────────┐   │      └────────────────────┘                              │
               │     │ publishConfig  │───┘                 │                                        │
               │     └────────────────┘                     │                                        │
               │                                            ▼                                        ▼
               │                               ┌─────────────────────────┐    save sql    ┌────────────────────┐
               │                               │ saveConfigTagRelations  │────context────▶│  SqlContextUtils   │◀─┐
        publish config                         └─────────────────────────┘                └────────────────────┘  │
               │                                            │                                        ▲            │
               │                                            │                                        │            │
               │                                            ▼                                        │            │
               │                                ┌───────────────────────┐         save sql           │            │
            ┌────┐                              │   saveConfigHistory   │─────────context────────────┘            │
            │user│                              └───────────────────────┘                                         │
            └────┘                                                                                                │
               ▲                                                                                                  │
               │                                           ┌1:getCurrentSqlContexts───────────────────────────────┘
               │                                           │
               │                                           │
               │                                           │
               │           ┌───────────────┐    ┌─────────────────────┐
               │           │ JdbcTemplate  │◀───│   DatabaseOperate   │───┐
       4:execute result    └───────────────┘    └─────────────────────┘   │
               │                   │                       ▲              │
               │                   │                       │              │
               │                   │                  3:onApply         2:submit(List&lt;ModifyRequest&gt;)
               │                   │                       │              │
               │                   ▼                       │              │
               │           ┌──────────────┐                │              │
               │           │ Apache Derby │    ┌───────────────────────┐  │
               │           └──────────────┘    │     JRaftProtocol     │◀─┘
               │                               └───────────────────────┘
               │                                           │
               │                                           │
               └───────────────────────────────────────────┘
</code></pre>
<p>当 Raft 的流程执行完成后，会回到在文章开头我们提到的 <code>ConfigOperationService#publishConfig</code> 方法中，在单机部署的模式下，我们提到过：Nacos 会触发 <code>ConfigDataChangeEvent</code> 事件来触发 <code>DumpTask</code> 来将配置信息写入到本地磁盘文件和 JVM 缓存中，并在随后触发 <code>LocalDataChangeEvent</code> 事件通知连接到该单机上所有的 Nacos Client 保证配置变更的通知。现在我们来考虑一个问题：当我们在控制台修改配置信息时，配置变更的请求只会打到 Nacos 集群的某一台服务上，在这一台服务上会执行 Dump 文件的操作并通知连接到该台服务器上的 Nacos Client 配置变更，那 <strong>集群中其他节点是不是也需要通知连接到本身的 Nacos Client 配置变更</strong> 呢？答案是肯定的。</p>
<p>在集群模式下，<code>ConfigDataChangeEvent</code> 事件会被 <code>AsyncNotifyService</code> 消费，其中的 <code>AsyncNotifyService#handleConfigDataChangeEvent</code> 方法会处理 <code>ConfigDataChangeEvent</code> 事件来完成通知集群内其他节点配置发生变更的操作：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncNotifyService</span> {

    <span class="hljs-keyword">private</span> ServerMemberManager memberManager;
    
    <span class="hljs-comment">// 处理 ConfigDataChangeEvent 事件</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleConfigDataChangeEvent</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ConfigDataChangeEvent) {
            <span class="hljs-type">ConfigDataChangeEvent</span> <span class="hljs-variable">evt</span> <span class="hljs-operator">=</span> (ConfigDataChangeEvent) event;

            MetricsMonitor.incrementConfigChangeCount(evt.tenant, evt.group, evt.dataId);
            <span class="hljs-comment">// 集群中除了自己的所有节点</span>
            Collection&lt;Member&gt; ipList = memberManager.allMembersWithoutSelf();

            Queue&lt;NotifySingleRpcTask&gt; rpcQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

            <span class="hljs-keyword">for</span> (Member member : ipList) {
                <span class="hljs-comment">// 生成通知其他节点数据变更的任务，包含配置信息和节点IP信息</span>
                <span class="hljs-type">NotifySingleRpcTask</span> <span class="hljs-variable">notifySingleRpcTask</span> <span class="hljs-operator">=</span> generateTask(evt, member);
                <span class="hljs-comment">// 加入队列</span>
                rpcQueue.add(notifySingleRpcTask);
            }
            <span class="hljs-comment">// 异步执行任务</span>
            <span class="hljs-keyword">if</span> (!rpcQueue.isEmpty()) {
                ConfigExecutor.executeAsyncNotify(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRpcTask</span>(rpcQueue));
            }
        }
    }   
}
</code></pre>
<p>它会将变更的配置和要通知的节点信息封装成一个个 <code>NotifySingleRpcTask</code> 异步任务，并放在队列 <code>Queue&lt;NotifySingleRpcTask&gt;</code> 中，随后使用线程池异步执行 <code>ConfigExecutor#executeAsyncNotify</code> 队列中所有的任务。<code>AsyncRpcTask</code> 是在 <code>AsyncNotifyService</code> 封装的内部类，执行通知的逻辑为 <code>AsyncNotifyService#executeAsyncRpcTask</code> 方法，借助 gRPC 通知其他节点，并在失败后重试，请关注以下逻辑的注释信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncNotifyService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_RETRY_INTERVAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INCREASE_STEPS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ConfigClusterRpcClientProxy configClusterRpcClientProxy;

    <span class="hljs-keyword">private</span> ServerMemberManager memberManager;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncRpcTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {

        <span class="hljs-keyword">private</span> Queue&lt;NotifySingleRpcTask&gt; queue;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AsyncRpcTask</span><span class="hljs-params">(Queue&lt;NotifySingleRpcTask&gt; queue)</span> {
            <span class="hljs-built_in">this</span>.queue = queue;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 处理通知其他节点配置变更的任务</span>
            executeAsyncRpcTask(queue);
        }
    }
    
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeAsyncRpcTask</span><span class="hljs-params">(Queue&lt;NotifySingleRpcTask&gt; queue)</span> {
        <span class="hljs-keyword">while</span> (!queue.isEmpty()) {
            <span class="hljs-type">NotifySingleRpcTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.poll();

            <span class="hljs-type">ConfigChangeClusterSyncRequest</span> <span class="hljs-variable">syncRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigChangeClusterSyncRequest</span>();
            syncRequest.setDataId(task.getDataId());
            syncRequest.setTenant(task.getTenant());
            syncRequest.setGroup(task.getGroup());
            syncRequest.setLastModified(task.getLastModified());
            syncRequest.setGrayName(task.getGrayName());
            syncRequest.setBeta(task.isBeta());
            syncRequest.setTag(task.getTag());
            <span class="hljs-type">Member</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> task.member;

            <span class="hljs-type">String</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> getNotifyEvent(task);
            <span class="hljs-keyword">if</span> (memberManager.hasMember(member.getAddress())) {
                <span class="hljs-comment">// 将可能下线的服务放入异步队列延迟执行，健康的服务器直接通知</span>
                <span class="hljs-type">boolean</span> <span class="hljs-variable">unHealthNeedDelay</span> <span class="hljs-operator">=</span> isUnHealthy(member.getAddress());
                <span class="hljs-keyword">if</span> (unHealthNeedDelay) {
                    ConfigTraceService.logNotifyEvent(task.getDataId(), task.getGroup(), task.getTenant(), <span class="hljs-literal">null</span>,
                            task.getLastModified(), InetUtils.getSelfIP(), event,
                            ConfigTraceService.NOTIFY_TYPE_UNHEALTH, <span class="hljs-number">0</span>, member.getAddress());
                    asyncTaskExecute(task);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// gRPC 通知配置发生变更</span>
                        configClusterRpcClientProxy.syncConfigChange(member, syncRequest,
                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRpcNotifyCallBack</span>(AsyncNotifyService.<span class="hljs-built_in">this</span>, task));
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        <span class="hljs-comment">// 无限重试，直到重试成功或服务停止</span>
                        MetricsMonitor.getConfigNotifyException().increment();
                        asyncTaskExecute(task);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//No nothing if  member has offline.</span>
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTaskExecute</span><span class="hljs-params">(NotifySingleRpcTask task)</span> {
        <span class="hljs-comment">// 获取重试延迟时间</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> getDelayTime(task);
        Queue&lt;NotifySingleRpcTask&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        queue.add(task);
        <span class="hljs-comment">// 借助 ScheduledExecutorService 线程池延迟执行的任务</span>
        <span class="hljs-type">AsyncRpcTask</span> <span class="hljs-variable">asyncTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRpcTask</span>(queue);
        ConfigExecutor.scheduleAsyncNotify(asyncTask, delay, TimeUnit.MILLISECONDS);
    }

    <span class="hljs-comment">// 执行失败后获取延迟执行的时间</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDelayTime</span><span class="hljs-params">(NotifySingleRpcTask task)</span> {
        <span class="hljs-comment">// 失败次数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">failCount</span> <span class="hljs-operator">=</span> task.getFailCount();
        <span class="hljs-comment">// 指数级计算重试间隔</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> MIN_RETRY_INTERVAL + failCount * failCount * INCREASE_STEPS;
        <span class="hljs-comment">// 最大重试次数限制，超过后仍然继续重试，只是限制了重试间隔的指数爆炸</span>
        <span class="hljs-keyword">if</span> (failCount &lt;= MAX_COUNT) {
            task.setFailCount(failCount + <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> delay;
    }
    
}
</code></pre>
<p>集群中其他节点在收到 <code>ConfigChangeClusterSyncRequest</code> 请求后，会在 <code>ConfigChangeClusterSyncRequestHandler</code> 类中处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@InvokeSource(source = {RemoteConstants.LABEL_SOURCE_CLUSTER})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigChangeClusterSyncRequestHandler</span>
        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;ConfigChangeClusterSyncRequest, ConfigChangeClusterSyncResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DumpService dumpService;

    <span class="hljs-keyword">private</span> ConfigMigrateService configMigrateService;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigChangeClusterSyncRequestHandler</span><span class="hljs-params">(DumpService dumpService,
                                                 ConfigMigrateService configMigrateService)</span> {
        <span class="hljs-built_in">this</span>.dumpService = dumpService;
        <span class="hljs-built_in">this</span>.configMigrateService = configMigrateService;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@NamespaceValidation</span>
    <span class="hljs-meta">@TpsControl(pointName = "ClusterConfigChangeNotify")</span>
    <span class="hljs-meta">@ExtractorManager</span>.Extractor(rpcExtractor = ConfigRequestParamExtractor.class)
    <span class="hljs-meta">@Secured(signType = SignType.CONFIG, apiType = ApiType.INNER_API)</span>
    <span class="hljs-keyword">public</span> ConfigChangeClusterSyncResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(ConfigChangeClusterSyncRequest configChangeSyncRequest,
                                                  RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 参数校验</span>
        checkCompatity(configChangeSyncRequest, meta);
        ParamUtils.checkParam(configChangeSyncRequest.getTag());
        
        <span class="hljs-comment">// 执行 Dump 操作</span>
        <span class="hljs-type">DumpRequest</span> <span class="hljs-variable">dumpRequest</span> <span class="hljs-operator">=</span> DumpRequest.create(configChangeSyncRequest.getDataId(),
                configChangeSyncRequest.getGroup(), configChangeSyncRequest.getTenant(),
                configChangeSyncRequest.getLastModified(), meta.getClientIp());
        dumpRequest.setGrayName(configChangeSyncRequest.getGrayName());
        dumpService.dump(dumpRequest);
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigChangeClusterSyncResponse</span>();
    }
    
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>它的逻辑非常简单，接受到请求后，执行文件 Dump 操作并通知连接到服务本身的所有 Nacos Client 客户端配置发生变更。接下来，我们再看一下在 Nacos Server 端通过控制台查询配置数据时，读取 Derby 数据库是如何读取的。在开始具体的逻辑前，先给大家留一个问题：在集群模式部署时，每个集群实例都有一份配置数据的副本，当请求打到不同的实例时，如果存在实例未完成最新配置数据的写入，会不会存在多次请求不一致的情况呢？</p>
<h5 data-id="heading-3">在 Nacos Server 端通过控制台读取配置数据</h5>
<p>在 Nacos 集群模式下使用内嵌 Derby 数据库时遵循 Raft 算法，如果要查询配置信息时它采用的是 <strong>ReadIndex Read 实现线性一致性读</strong>，我们直接略过非核心代码，分析与 Raft 相关的源码部分：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRaftServer</span> {
    <span class="hljs-comment">/**
     * [raft] 处理读请求，使用 ReadIndex 机制保证线性一致性读
     */</span>
    CompletableFuture&lt;Response&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ReadRequest request)</span> {
        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> request.getGroup();
        CompletableFuture&lt;Response&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();
        <span class="hljs-keyword">final</span> <span class="hljs-type">RaftGroupTuple</span> <span class="hljs-variable">tuple</span> <span class="hljs-operator">=</span> findTupleByGroup(group);
        <span class="hljs-keyword">if</span> (Objects.isNull(tuple)) {
            future.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchRaftGroupException</span>(group));
            <span class="hljs-keyword">return</span> future;
        }
        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tuple.node;
        <span class="hljs-keyword">final</span> <span class="hljs-type">RequestProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> tuple.processor;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 使用 ReadIndex Read 机制确保读取到的数据是最新的已提交数据</span>
            <span class="hljs-comment">// 其中 requestContext （第一个入参）提供给用户作为请求的附加上下文，可以在 closure 里再次拿到继续处理</span>
            node.readIndex(BytesUtil.EMPTY_BYTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadIndexClosure</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Status status, <span class="hljs-type">long</span> index, <span class="hljs-type">byte</span>[] reqCtx)</span> {
                    <span class="hljs-comment">// ReadIndex 成功，传入的 closure 将被调用，可以安全地从本地状态机读取数据</span>
                    <span class="hljs-keyword">if</span> (status.isOk()) {
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> processor.onRequest(request);
                            future.complete(response);
                        } <span class="hljs-keyword">catch</span> (Throwable t) {
                            MetricsMonitor.raftReadIndexFailed();
                            future.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistencyException</span>(
                                    <span class="hljs-string">"The conformance protocol is temporarily unavailable for reading"</span>, t));
                        }
                        <span class="hljs-keyword">return</span>;
                    }
                    MetricsMonitor.raftReadIndexFailed();
                    Loggers.RAFT.error(<span class="hljs-string">"ReadIndex has error : {}, go to Leader read."</span>, status.getErrorMsg());
                    MetricsMonitor.raftReadFromLeader();
                    <span class="hljs-comment">// ReadIndex 失败，降级到 Leader 读取保证一致性</span>
                    readFromLeader(request, future);
                }
            });
            <span class="hljs-keyword">return</span> future;
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            <span class="hljs-comment">// ReadIndex 异常，直接从 Leader 读取</span>
            MetricsMonitor.raftReadFromLeader();
            Loggers.RAFT.warn(<span class="hljs-string">"Raft linear read failed, go to Leader read logic : {}"</span>, e.toString());
            <span class="hljs-comment">// run raft read</span>
            readFromLeader(request, future);
            <span class="hljs-keyword">return</span> future;
        }
    }

    <span class="hljs-comment">// raft log process</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFromLeader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ReadRequest request, <span class="hljs-keyword">final</span> CompletableFuture&lt;Response&gt; future)</span> {
        commit(request.getGroup(), request, future);
    }
}
</code></pre>
<p>这部分源码比较简单，因为 JRaft 框架将 ReadIndex Read 的实现封装起来了，开放出了 <code>readIndex</code> 方法来直接复用，注意如果在 ReadIndex 时失败，会走 Raft Log 流程来处理读请求，这个开销就相对来说比较大了。如果大家对 Raft 算法不了解，可以阅读参考 <a href="https://juejin.cn/post/7544003305972088878" target="_blank" title="https://juejin.cn/post/7544003305972088878">深入理解分布式共识算法 Raft</a>。</p>
<p>至此，变更配置后 Nacos Server 端对配置数据一致性的保证相关的源码逻辑就已经讲解完了，接下来我们就要看看 Nacos Client 是如何接收配置变更并更新配置信息的。</p>
<p>由于社区最大字数限制，请看下篇：<a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"> Nacos 源码深度畅游：Nacos 配置同步详解（下）</a>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nacos 源码深度畅游：Nacos 配置同步详解（下）]]></title>    <link>https://juejin.cn/post/7572497847770202139</link>    <guid>https://juejin.cn/post/7572497847770202139</guid>    <pubDate>2025-11-15T08:00:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572497847770202139" data-draft-id="7564694695571636239" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Nacos 源码深度畅游：Nacos 配置同步详解（下）"/> <meta itemprop="keywords" content="后端,GitHub,分布式"/> <meta itemprop="datePublished" content="2025-11-15T08:00:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="方圆想当图灵"/> <meta itemprop="url" content="https://juejin.cn/user/386633160473101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Nacos 源码深度畅游：Nacos 配置同步详解（下）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/386633160473101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    方圆想当图灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T08:00:48.000Z" title="Sat Nov 15 2025 08:00:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">Nacos Client 客户端</h3>
<p>在上文 <a href="https://juejin.cn/post/7572485825705558025" target="_blank" title="https://juejin.cn/post/7572485825705558025"> Nacos 源码深度畅游：Nacos 配置同步详解（上）</a> 中了解到，当配置发生变更时，Nacos Server 服务端会主动通知 Nacos Client 变更配置的内容，并且在通知失败后 Nacos Client 有主动拉取变更配置的机制保证配置的及时更新，接下来我们先看一下 Nacos Client 处理配置相关的流程图，之后再深入到源码之中：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0327bdcdff714748bc575844eacf5e6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763798539&amp;x-signature=F9rsOKeZJyCVWrxGzW5%2FI6jdnnI%3D" alt="nacos-client.png" loading="lazy"/></p>
<p>Nacos Client 在接收到 Nacos Server 发送的配置变更请求 <code>ConfigChangeNotifyRequest</code> 后，会更新保存在内存中的 <code>CacheData</code> 配置对象的标志位，分别表示收到了配置变更请求和与服务端配置内容不一致，注意 <strong>此时并没有更新配置的内容</strong>，随后会在阻塞队列中添加一个元素。客户端在启动时，会创建一个 <strong>单线程的线程池并提交一个忙任务</strong>（<code>while (true)</code>），首先这个任务会检查阻塞队列中是否有元素，如果有元素的话立即处理同步配置的任务，否则阻塞 5 秒后主动同步配置，<strong>这也就是 Nacos Client 的主动拉取配置内容的机制</strong>。在执行同步配置的任务时，会有以下步骤：</p>
<ol>
<li><code>checkLocalConfig</code>: 检查本地配置文件（故障转移文件），需要注意的是：<strong>Nacos Client 的配置故障转移文件并不是由客户端程序自动创建和写入的，而是需要用户手动维护的应急机制</strong>，这样能避免配置的混乱，又提供了应急的机制</li>
<li><code>checkListenerMd5</code>: 检查配置的变更情况，如果有配置内容发生变更，则通知订阅了这些配置的监听器</li>
<li><code>checkListenCache</code>: 通过 gRPC 请求接口获取哪些配置发生了变更并获取对应的配置内容，更新到本地缓存对象 <code>CacheData</code> 中，并重置标志位，随后回调订阅了这些配置的监听器</li>
<li><code>checkRemoveListenCache</code>: 将已经失效的配置移除</li>
<li><code>notifyListenConfig</code>: 如果发生配置变更，则再触发一次同步配置的任务</li>
</ol>
<p>Nacos Client 客户端处理配置变更的逻辑并不复杂，需要注意的是每次 Nacos Client 向 Nacos Server 读取的时候都会走缓存（磁盘文件和内存对象），因此 <strong>Nacos Client 和 Nacos Server 之间的遵循的是 AP 定理</strong>，遵循数据的 <strong>最终一致性</strong>，通过 Nacos Client 的定期重试来保证配置数据的更新，这样做的好处是 <strong>能够避免数据库成为性能瓶颈</strong>。</p>
<p>Nacos Client 的主要流程如上所述，接下来为源码内容解析。</p>
<hr/>
<p>在 Nacos Client 启动时，它会执行 <code>ConfigRpcTransportClient#initRpcClientHandler</code> 方法来注册配置变更的处理器，这样在接收到服务端推送配置变更的请求时，会执行 <code>ConfigRpcTransportClient#handleConfigChangeNotifyRequest</code> 方法来处理请求，处理逻辑并不复杂，它会根据配置信息的唯一标识来查询配置信息的缓存数据，获取成功后会只是对缓存进行打标，而没有直接修改内存数据，并且向 <code>BlockingQueue&lt;Object&gt; listenExecutebell</code> 阻塞队列对象中添加了一个元素，随后处理服务端请求的流程就结束了，但是此时还并没有完成配置内容的变更：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRpcTransportClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConfigTransportClient</span> {

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Object&gt; listenExecutebell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRpcClientHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> RpcClient rpcClientInner)</span> {
            <span class="hljs-comment">// 注册 配置变更 或 配置重同步处理器</span>
            rpcClientInner.registerServerRequestHandler((request, connection) -&gt; {
                <span class="hljs-comment">// config change notify</span>
                <span class="hljs-keyword">if</span> (request <span class="hljs-keyword">instanceof</span> ConfigChangeNotifyRequest) {
                    <span class="hljs-comment">// 客户端处理服务端推送的配置变更通知请求</span>
                    <span class="hljs-keyword">return</span> handleConfigChangeNotifyRequest((ConfigChangeNotifyRequest) request,
                            rpcClientInner.getName());
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            });
            
            <span class="hljs-comment">// ...</span>
        }

        ConfigChangeNotifyResponse <span class="hljs-title function_">handleConfigChangeNotifyRequest</span><span class="hljs-params">(ConfigChangeNotifyRequest configChangeNotifyRequest,
                                                                   String clientName)</span> {
            <span class="hljs-comment">// 构建配置唯一标识，查找对应的本地缓存数据</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey.getKeyTenant(configChangeNotifyRequest.getDataId(),
                    configChangeNotifyRequest.getGroup(), configChangeNotifyRequest.getTenant());

            <span class="hljs-comment">// 获取对应的缓存数据</span>
            <span class="hljs-type">CacheData</span> <span class="hljs-variable">cacheData</span> <span class="hljs-operator">=</span> cacheMap.get().get(groupKey);
            <span class="hljs-keyword">if</span> (cacheData != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">synchronized</span> (cacheData) {
                    <span class="hljs-comment">// 标记配置状态变更，触发配置拉取和监听器通知</span>
                    cacheData.getReceiveNotifyChanged().set(<span class="hljs-literal">true</span>);
                    <span class="hljs-comment">// 标记与服务端不一致</span>
                    cacheData.setConsistentWithServer(<span class="hljs-literal">false</span>);
                    <span class="hljs-comment">// 重要：立即触发监听配置检查</span>
                    notifyListenConfig();
                }

            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigChangeNotifyResponse</span>();
        }

        <span class="hljs-comment">// 当有新的监听器添加或配置变更时或发生异常时，都会调用这个方法，那么在 startInternal 中的循环就会被唤醒</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListenConfig</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 向阻塞队列中放入一个元素，唤醒 startInternal 中的循环</span>
            listenExecutebell.offer(bellItem);
        }
    }
    
}
</code></pre>
<p>那么配置的内容何时变更呢？向阻塞队列 <code>BlockingQueue&lt;Object&gt; listenExecutebell</code> 中添加元素的作用是什么呢？看接下来的源码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRpcTransportClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConfigTransportClient</span> {

        <span class="hljs-keyword">private</span> ExecutorService listenExecutor;

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Object&gt; listenExecutebell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> {
            listenExecutor =
                    Executors.newSingleThreadExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NameThreadFactory</span>(<span class="hljs-string">"com.alibaba.nacos.client.listen-executor"</span>));
            listenExecutor.submit(() -&gt; {
                <span class="hljs-comment">// 忙任务</span>
                <span class="hljs-keyword">while</span> (!listenExecutor.isShutdown() &amp;&amp; !listenExecutor.isTerminated()) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 阻塞等待通知，最多等待5秒</span>
                        listenExecutebell.poll(<span class="hljs-number">5L</span>, TimeUnit.SECONDS);
                        <span class="hljs-keyword">if</span> (listenExecutor.isShutdown() || listenExecutor.isTerminated()) {
                            <span class="hljs-keyword">continue</span>;
                        }
                        <span class="hljs-comment">// 执行配置监听检查</span>
                        executeConfigListen();
                    } <span class="hljs-keyword">catch</span> (Throwable e) {
                        LOGGER.error(<span class="hljs-string">"[rpc listen execute] [rpc listen] exception"</span>, e);
                        <span class="hljs-keyword">try</span> {
                            Thread.sleep(<span class="hljs-number">50L</span>);
                        } <span class="hljs-keyword">catch</span> (InterruptedException interruptedException) {
                            <span class="hljs-comment">// ignore</span>
                        }
                        <span class="hljs-comment">// 出现异常时重新通知监听配置</span>
                        notifyListenConfig();
                    }
                }
            });
        }
    }

}
</code></pre>
<p>在 Nacos Client 启动时会调用 <code>ConfigRpcTransportClient#startInternal</code> 方法，创建一个 <code>ExecutorService listenExecutor</code> 线程池（这段逻辑是我在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fnacos%2Fcommit%2F39a55482912c52e373009f652635d4588fb8d860" target="_blank" title="https://github.com/alibaba/nacos/commit/39a55482912c52e373009f652635d4588fb8d860" ref="nofollow noopener noreferrer">ISSUE #13822</a> 中修改过后的），这个线程池只有一个线程，这个线程会处理一个“忙”任务：循环检查配置是否发生变更，直到线程池关闭。<code>BlockingQueue&lt;Object&gt; listenExecutebell</code> 是阻塞队列，当配置变更时添加元素，会立即触发 <code>executeConfigListen</code> 配置检查的逻辑，否则会 <strong>阻塞等待 5 秒，也就是说，即使在配置没有发生变更的情况下，也会触发配置的检查操作</strong>。现在我们明白了阻塞队列 <code>BlockingQueue&lt;Object&gt; listenExecutebell</code> 的作用，接下来我们继续看一下 <code>executeConfigListen</code> 执行配置检查的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRpcTransportClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConfigTransportClient</span> {

        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastAllSyncTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-comment">/**
         * 3 minutes to check all listen cache keys.
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ALL_SYNC_INTERNAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeConfigListen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException {
            <span class="hljs-comment">// 按 taskId 分组监听缓存和移除监听缓存</span>
            Map&lt;String, List&lt;CacheData&gt;&gt; listenCachesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);
            Map&lt;String, List&lt;CacheData&gt;&gt; removeListenCachesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);
            <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
            <span class="hljs-comment">// 每3分钟进行一次全量同步检查</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">needAllSync</span> <span class="hljs-operator">=</span> now - lastAllSyncTime &gt;= ALL_SYNC_INTERNAL;
            <span class="hljs-comment">// 遍历所有缓存配置，按状态分类</span>
            <span class="hljs-keyword">for</span> (CacheData cache : cacheMap.get().values()) {
                <span class="hljs-keyword">synchronized</span> (cache) {
                    <span class="hljs-comment">// 1. 检查本地配置（故障转移文件）</span>
                    checkLocalConfig(cache);

                    <span class="hljs-comment">// 这个变量在收到服务端推送配置变更的请求时会被修改为 false，否则为 true</span>
                    <span class="hljs-keyword">if</span> (cache.isConsistentWithServer()) {
                        <span class="hljs-comment">// 2. 检查配置变更，如果发生变更便通知各个监听器</span>
                        cache.checkListenerMd5();
                        <span class="hljs-comment">// 如果与服务端配置一致且不需要全量同步，则跳过这个配置缓存接下来的逻辑</span>
                        <span class="hljs-keyword">if</span> (!needAllSync) {
                            <span class="hljs-keyword">continue</span>;
                        }
                    }

                    <span class="hljs-comment">// 如果使用本地配置信息，跳过处理</span>
                    <span class="hljs-keyword">if</span> (cache.isUseLocalConfigInfo()) {
                        <span class="hljs-keyword">continue</span>;
                    }

                    <span class="hljs-comment">// 根据缓存状态分类处理</span>
                    <span class="hljs-keyword">if</span> (!cache.isDiscard()) {
                        <span class="hljs-comment">// 需要监听的配置</span>
                        List&lt;CacheData&gt; cacheDatas = listenCachesMap.computeIfAbsent(String.valueOf(cache.getTaskId()),
                                k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());
                        cacheDatas.add(cache);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// 需要移除监听的配置</span>
                        List&lt;CacheData&gt; cacheDatas = removeListenCachesMap.computeIfAbsent(
                                String.valueOf(cache.getTaskId()), k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());
                        cacheDatas.add(cache);
                    }
                }

            }

            <span class="hljs-comment">// 3. 执行监听检查，返回是否有变更，执行时会从服务端查询最新配置内容并触发监听器回调</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">hasChangedKeys</span> <span class="hljs-operator">=</span> checkListenCache(listenCachesMap);

            <span class="hljs-comment">// 4. 执行移除 discard 的配置</span>
            checkRemoveListenCache(removeListenCachesMap);

            <span class="hljs-keyword">if</span> (needAllSync) {
                lastAllSyncTime = now;
            }

            <span class="hljs-comment">// 5. 如果有变更，重新通知监听配置（形成循环），再立即处理一遍上述逻辑</span>
            <span class="hljs-keyword">if</span> (hasChangedKeys) {
                notifyListenConfig();
            }
        }

        <span class="hljs-comment">/**
         * Checks and handles local configuration for a given CacheData object. This method evaluates the use of
         * failover files for local configuration storage and updates the CacheData accordingly.
         * 用于处理本地配置故障转移（failover）机制，用于 Nacos 的高可用场景，当客户端无法连接到 Nacos 服务器时，可以通过本地故障转移文件继续提供配置服务，确保应用程序的正常运行
         *
         * <span class="hljs-doctag">@param</span> cacheData The CacheData object to be processed.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLocalConfig</span><span class="hljs-params">(CacheData cacheData)</span> {
            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> cacheData.dataId;
            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> cacheData.group;
            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> cacheData.tenant;
            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">envName</span> <span class="hljs-operator">=</span> cacheData.envName;

            <span class="hljs-comment">// Check if a failover file exists for the specified dataId, group, and tenant.</span>
            <span class="hljs-comment">// 校验故障转移文件是否存在</span>
            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> LocalConfigInfoProcessor.getFailoverFile(envName, dataId, group, tenant);

            <span class="hljs-comment">// If not using local config info and a failover file exists, load and use it.</span>
            <span class="hljs-comment">// 如果未使用本地配置信息且故障转移文件存在，加载并使用它。</span>
            <span class="hljs-keyword">if</span> (!cacheData.isUseLocalConfigInfo() &amp;&amp; file.exists()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> LocalConfigInfoProcessor.getFailover(envName, dataId, group, tenant);
                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> MD5Utils.md5Hex(content, Constants.ENCODE);
                <span class="hljs-comment">// 变更为使用本地配置</span>
                cacheData.setUseLocalConfigInfo(<span class="hljs-literal">true</span>);
                cacheData.setLocalConfigInfoVersion(file.lastModified());
                cacheData.setContent(content);
                LOGGER.warn(<span class="hljs-string">"[{}] [failover-change] failover file created. dataId={}, group={}, tenant={}, md5={}"</span>,
                        envName, dataId, group, tenant, md5);
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// If use local config info, but the failover file is deleted, switch back to server config.</span>
            <span class="hljs-comment">// 如果使用本地配置信息，但故障转移文件被删除，则切换回服务器配置</span>
            <span class="hljs-keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; !file.exists()) {
                cacheData.setUseLocalConfigInfo(<span class="hljs-literal">false</span>);
                LOGGER.warn(<span class="hljs-string">"[{}] [failover-change] failover file deleted. dataId={}, group={}, tenant={}"</span>, envName,
                        dataId, group, tenant);
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// When the failover file content changes, indicating a change in local configuration.</span>
            <span class="hljs-comment">// 使用本地配置，文件存在且文件修改时间发生变更，表示本地配置发生了变化，需要更新本地配置信息</span>
            <span class="hljs-keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; file.exists()
                    &amp;&amp; cacheData.getLocalConfigInfoVersion() != file.lastModified()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> LocalConfigInfoProcessor.getFailover(envName, dataId, group, tenant);
                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> MD5Utils.md5Hex(content, Constants.ENCODE);
                cacheData.setUseLocalConfigInfo(<span class="hljs-literal">true</span>);
                cacheData.setLocalConfigInfoVersion(file.lastModified());
                cacheData.setContent(content);
                LOGGER.warn(<span class="hljs-string">"[{}] [failover-change] failover file changed. dataId={}, group={}, tenant={}, md5={}"</span>,
                        envName, dataId, group, tenant, md5);
            }
        }
    }

}
</code></pre>
<p>在这个方法中，第一个关注点是 <code>checkLocalConfig</code> 方法，这个方法用于 <strong>处理本地配置故障转移（failover）</strong>，用于 Nacos 的 <strong>高可用</strong> 场景，当客户端无法连接到 Nacos 服务器时，可以通过本地故障转移文件继续提供配置服务，确保应用程序的正常运行，具体可以关注注释信息。需要注意的是：<strong>Nacos Client 的配置故障转移文件并不是由客户端程序自动创建和写入的，而是需要用户手动维护的应急机制</strong>，这样能避免配置的混乱，又提供了应急的机制。</p>
<p><code>CacheData#isConsistentWithServer</code> 在接收到服务端推送配置变更时会被修改为 false，表示与服务端配置信息不一致，不一致的话它会执行 <code>CacheData#checkListenerMd5</code> 方法，这个方法的作用是检查内存中配置信息的 MD5 值与“监听器”中记录的 MD5 值是否一致，如果不一致的话，则“安全地”通知各个监听器：</p>
<blockquote>
<p>监听器 <code>ManagerListenerWrap</code>：是指用户创建的订阅各个配置信息的监听器</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheData</span> {

    <span class="hljs-comment">/**
     * 监听器列表.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;ManagerListenerWrap&gt; listeners;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String md5;
    
    <span class="hljs-comment">/**
     * 检查配置是否发生变更，遍历所有监听器，检查MD5是否变更，若变更则调用 safeNotifyListener 触发用户监听器
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkListenerMd5</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (ManagerListenerWrap wrap : listeners) {
            <span class="hljs-comment">// 配置发生变更，触发监听器</span>
            <span class="hljs-keyword">if</span> (!md5.equals(wrap.lastCallMd5)) {
                safeNotifyListener(dataId, group, content, type, md5, encryptedDataKey, wrap);
            }
        }
    }

    <span class="hljs-comment">// 安全地通知监听器，调用用户的 receiveConfigInfo 方法，完成配置变更通知</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeNotifyListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String dataId, <span class="hljs-keyword">final</span> String group, <span class="hljs-keyword">final</span> String content, <span class="hljs-keyword">final</span> String type,
                                    <span class="hljs-keyword">final</span> String md5, <span class="hljs-keyword">final</span> String encryptedDataKey, <span class="hljs-keyword">final</span> ManagerListenerWrap listenerWrap)</span> {
        <span class="hljs-keyword">final</span> <span class="hljs-type">Listener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> listenerWrap.listener;
        <span class="hljs-comment">// 防止重复通知</span>
        <span class="hljs-keyword">if</span> (listenerWrap.inNotifying) {
            LOGGER.warn(
                    <span class="hljs-string">"[{}] [notify-currentSkip] dataId={}, group={},tenant={}, md5={}, listener={}, listener is not finish yet,will try next time."</span>,
                    envName, dataId, group, tenant, md5, listener);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 创建通知任务</span>
        <span class="hljs-type">NotifyTask</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotifyTask</span>() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
                <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">myClassLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();
                <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">appClassLoader</span> <span class="hljs-operator">=</span> listener.getClass().getClassLoader();
                ScheduledFuture&lt;?&gt; timeSchedule = <span class="hljs-literal">null</span>;

                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 为 AbstractSharedListener 共享监听器填充上下文信息</span>
                    <span class="hljs-keyword">if</span> (listener <span class="hljs-keyword">instanceof</span> AbstractSharedListener) {
                        <span class="hljs-type">AbstractSharedListener</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> (AbstractSharedListener) listener;
                        adapter.fillContext(dataId, group);
                        LOGGER.info(<span class="hljs-string">"[{}] [notify-context] dataId={}, group={},tenant={}, md5={}"</span>, envName, dataId,
                                group, tenant, md5);
                    }
                    <span class="hljs-comment">// Before executing the callback, set the thread classloader to the classloader of</span>
                    <span class="hljs-comment">// the specific webapp to avoid exceptions or misuses when calling the spi interface in</span>
                    <span class="hljs-comment">// the callback method (this problem occurs only in multi-application deployment).</span>
                    <span class="hljs-comment">// 在执行回调之前，将线程类加载器设置为特定webapp的类加载器，以避免在回调方法中调用spi接口时出现异常或误用（此问题仅在多应用程序部署中发生）</span>
                    Thread.currentThread().setContextClassLoader(appClassLoader);

                    <span class="hljs-type">ConfigResponse</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigResponse</span>();
                    cr.setDataId(dataId);
                    cr.setGroup(group);
                    cr.setContent(content);
                    cr.setEncryptedDataKey(encryptedDataKey);
                    configFilterChainManager.doFilter(<span class="hljs-literal">null</span>, cr);
                    <span class="hljs-type">String</span> <span class="hljs-variable">contentTmp</span> <span class="hljs-operator">=</span> cr.getContent();
                    <span class="hljs-comment">// 延期 60s 执行超时告警WARN任务</span>
                    timeSchedule = getNotifyBlockMonitor().schedule(
                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongNotifyHandler</span>(listener.getClass().getSimpleName(), dataId, group, tenant, md5,
                                    notifyWarnTimeout, Thread.currentThread()), notifyWarnTimeout,
                            TimeUnit.MILLISECONDS);
                    listenerWrap.inNotifying = <span class="hljs-literal">true</span>;
                    <span class="hljs-comment">// 回调监听器的方法，告知用户接收到的配置信息</span>
                    listener.receiveConfigInfo(contentTmp);
                    <span class="hljs-comment">// compare lastContent and content</span>
                    <span class="hljs-keyword">if</span> (listener <span class="hljs-keyword">instanceof</span> AbstractConfigChangeListener) {
                        <span class="hljs-comment">// 变更监听器 AbstractConfigChangeListener 相关逻辑：变更配置信息并触发变更事件</span>
                        Map&lt;String, ConfigChangeItem&gt; data = ConfigChangeHandler.getInstance()
                                .parseChangeData(listenerWrap.lastContent, contentTmp, type);
                        <span class="hljs-type">ConfigChangeEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigChangeEvent</span>(data);
                        ((AbstractConfigChangeListener) listener).receiveConfigChange(event);
                        listenerWrap.lastContent = contentTmp;
                    }

                    <span class="hljs-comment">// 变更 MD5 信息</span>
                    listenerWrap.lastCallMd5 = md5;
                    LOGGER.info(
                            <span class="hljs-string">"[{}] [notify-ok] dataId={}, group={},tenant={}, md5={}, listener={} ,job run cost={} millis."</span>,
                            envName, dataId, group, tenant, md5, listener, (System.currentTimeMillis() - start));
                } <span class="hljs-keyword">catch</span> (NacosException ex) {
                    LOGGER.error(
                            <span class="hljs-string">"[{}] [notify-error] dataId={}, group={},tenant={},md5={}, listener={} errCode={} errMsg={},stackTrace :{}"</span>,
                            envName, dataId, group, tenant, md5, listener, ex.getErrCode(), ex.getErrMsg(),
                            getTrace(ex.getStackTrace(), <span class="hljs-number">3</span>));
                } <span class="hljs-keyword">catch</span> (Throwable t) {
                    LOGGER.error(<span class="hljs-string">"[{}] [notify-error] dataId={}, group={},tenant={}, md5={}, listener={} tx={}"</span>,
                            envName, dataId, group, tenant, md5, listener, getTrace(t.getStackTrace(), <span class="hljs-number">3</span>));
                } <span class="hljs-keyword">finally</span> {
                    listenerWrap.inNotifying = <span class="hljs-literal">false</span>;
                    Thread.currentThread().setContextClassLoader(myClassLoader);
                    <span class="hljs-comment">// 及时通知完成就取消定时任务</span>
                    <span class="hljs-keyword">if</span> (timeSchedule != <span class="hljs-literal">null</span>) {
                        timeSchedule.cancel(<span class="hljs-literal">true</span>);
                    }
                }
            }
        };

        <span class="hljs-comment">// 执行任务：如果配置了线程池，则异步执行，否则同步执行</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != listener.getExecutor()) {
                LOGGER.info(
                        <span class="hljs-string">"[{}] [notify-listener] task submitted to user executor, dataId={}, group={},tenant={}, md5={}, listener={} "</span>,
                        envName, dataId, group, tenant, md5, listener);
                job.async = <span class="hljs-literal">true</span>;
                listener.getExecutor().execute(job);
            } <span class="hljs-keyword">else</span> {
                LOGGER.info(
                        <span class="hljs-string">"[{}] [notify-listener] task execute in nacos thread, dataId={}, group={},tenant={}, md5={}, listener={} "</span>,
                        envName, dataId, group, tenant, md5, listener);
                job.run();
            }
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            LOGGER.error(<span class="hljs-string">"[{}] [notify-listener-error] dataId={}, group={},tenant={}, md5={}, listener={} throwable={}"</span>,
                    envName, dataId, group, tenant, md5, listener, t.getCause());
        }
    }

}
</code></pre>
<p>在这个过程中，源码虽然很多，但是并不复杂，主要关注两项内容：</p>
<ol>
<li>针对发生变更的配置会创建 <code>NotifyTask</code> 任务，用于监听器方法 <code>receiveConfigInfo</code> 告知变更后的配置信息，为了方便大家理解，以如下监听器为例：</li>
</ol>
<pre><code class="hljs language-java" lang="java">    <span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, NacosException {
    <span class="hljs-comment">// 创建 NacosConfigService 客户端</span>
    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
    properties.put(PropertyKeyConst.SERVER_ADDR, <span class="hljs-string">"127.0.0.1:8850"</span>);
    properties.put(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT, <span class="hljs-string">"20000"</span>);
    properties.put(PropertyKeyConst.CONFIG_RETRY_TIME, <span class="hljs-string">"3000"</span>);
    properties.put(PropertyKeyConst.MAX_RETRY, <span class="hljs-string">"5"</span>);
    <span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> NacosFactory.createConfigService(properties);

    <span class="hljs-comment">// 添加监听器</span>
    configService.addListener(<span class="hljs-string">"default_value"</span>, <span class="hljs-string">"DEFAULT_GROUP"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 监听器的回调方法</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> {
            System.out.println(configInfo);
        }
    });
}
</code></pre>
<p>也就是说，用户可以自行创建各个不同的配置的监听器，当配置发生变更时，便能从 <code>receiveConfigInfo</code> 方法中获取到变更后的配置</p>
<ol start="2">
<li>在 <code>NotifyTask</code> 中创建了 <code>LongNotifyHandler</code> 任务，这个任务会被延期 60s 执行，同时 <code>NotifyTask</code> 任务的 <code>finally</code> 代码块中有 <code>LongNotifyHandler</code> 任务的取消逻辑，也就是说：<code>NotifyTask</code> 任务只要执行的足够快（60s以内），这个任务将会被取消，接下来我们看一下 <code>LongNotifyHandler</code> 任务的逻辑：</li>
</ol>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheData</span> {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongNotifyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">blockTrace</span> <span class="hljs-operator">=</span> getTrace(thread.getStackTrace(), <span class="hljs-number">5</span>);
            LOGGER.warn(<span class="hljs-string">"[{}] [notify-block-monitor] dataId={}, group={},tenant={}, md5={}, "</span>
                            + <span class="hljs-string">"receiveConfigInfo execute over {} mills，thread trace block : {}"</span>, envName, dataId, group, tenant,
                    md5, timeoutMills, blockTrace);
            NotifyCenter.publishEvent(
                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeNotifyBlockEvent</span>(<span class="hljs-built_in">this</span>.listenerClass, dataId, group, tenant, <span class="hljs-built_in">this</span>.startTime,
                            System.currentTimeMillis(), blockTrace));
        }
    }
}
</code></pre>
<p>发现它会打印一行告警日志，提示某个配置的监听器通知被阻塞了，并且会触发一个 <code>ChangeNotifyBlockEvent</code> 事件（但是这个事件还没有特定的消费者），在日常开发中可以参考这种告警机制的写法。</p>
<hr/>
<p>接下来，我们再回到 <code>ClientWorker#executeConfigListen</code> 的逻辑中，执行完 <code>CacheData#checkListenerMd5</code> 方法后会检查是否使用本地故障转移配置文件，如果使用的话就不再处理后续逻辑，否则会将 CacheData 根据是否失效的状态进行分组，并对仍然有效的配置进行处理，执行 <code>ConfigRpcTransportClient#checkListenCache</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRpcTransportClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConfigTransportClient</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkListenCache</span><span class="hljs-params">(Map&lt;String, List&lt;CacheData&gt;&gt; listenCachesMap)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 使用原子布尔值记录是否有配置发生变更，保证线程安全</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">hasChangedKeys</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);

        <span class="hljs-comment">// 如果没有需要监听的缓存，直接返回false</span>
        <span class="hljs-keyword">if</span> (!listenCachesMap.isEmpty()) {
            List&lt;Future&gt; listenFutures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;CacheData&gt;&gt; entry : listenCachesMap.entrySet()) {
                <span class="hljs-type">String</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> entry.getKey();
                <span class="hljs-comment">// 为每个 taskId 创建一个 RpcClient 客户端</span>
                <span class="hljs-type">RpcClient</span> <span class="hljs-variable">rpcClient</span> <span class="hljs-operator">=</span> ensureRpcClient(taskId);
                <span class="hljs-comment">// 每个 taskId 专门分配一个线程数为 1 的线程池</span>
                <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> ensureSyncExecutor(taskId);
                <span class="hljs-type">Future</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> executorService.submit(() -&gt; {
                    List&lt;CacheData&gt; listenCaches = entry.getValue();
                    <span class="hljs-comment">// 重置通知变更标识</span>
                    <span class="hljs-keyword">for</span> (CacheData cacheData : listenCaches) {
                        cacheData.getReceiveNotifyChanged().set(<span class="hljs-literal">false</span>);
                    }
                    <span class="hljs-comment">// 将多个配置的监听请求合并为一个批量请求，提高网络效率</span>
                    <span class="hljs-type">ConfigBatchListenRequest</span> <span class="hljs-variable">configChangeListenRequest</span> <span class="hljs-operator">=</span> buildConfigRequest(listenCaches);
                    configChangeListenRequest.setListen(<span class="hljs-literal">true</span>);
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 向 Nacos 服务端发送批量监听请求，检查配置是否有变更</span>
                        <span class="hljs-type">ConfigChangeBatchListenResponse</span> <span class="hljs-variable">listenResponse</span> <span class="hljs-operator">=</span> (ConfigChangeBatchListenResponse) requestProxy(
                                rpcClient, configChangeListenRequest);
                        <span class="hljs-keyword">if</span> (listenResponse != <span class="hljs-literal">null</span> &amp;&amp; listenResponse.isSuccess()) {
                            Set&lt;String&gt; changeKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

                            List&lt;ConfigChangeBatchListenResponse.ConfigContext&gt; changedConfigs = listenResponse.getChangedConfigs();
                            <span class="hljs-comment">// 获取服务端返回的变更配置列表，并通知监听者</span>
                            <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(changedConfigs)) {
                                hasChangedKeys.set(<span class="hljs-literal">true</span>);
                                <span class="hljs-keyword">for</span> (ConfigChangeBatchListenResponse.ConfigContext changeConfig : changedConfigs) {
                                    <span class="hljs-comment">// 构建配置的唯一标识key：dataId+group+tenant</span>
                                    <span class="hljs-type">String</span> <span class="hljs-variable">changeKey</span> <span class="hljs-operator">=</span> GroupKey.getKeyTenant(changeConfig.getDataId(),
                                            changeConfig.getGroup(), changeConfig.getTenant());
                                    changeKeys.add(changeKey);
                                    <span class="hljs-comment">// 检查配置是否处于初始化状态，初始化状态的配置不需要通知监听器，避免重复通知</span>
                                    <span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializing</span> <span class="hljs-operator">=</span> cacheMap.get().get(changeKey).isInitializing();
                                    <span class="hljs-comment">// 刷新配置内容并检查MD5，触发监听器回调</span>
                                    refreshContentAndCheck(rpcClient, changeKey, !isInitializing);
                                }

                            }

                            <span class="hljs-comment">// ReceiveNotifyChanged 已经在方法开始时被重置为 false，这段逻辑解决的是被重置为 false 之后，</span>
                            <span class="hljs-comment">// 如果这期间仍有配置变更同步到 Nacos Client 时能一并处理</span>
                            <span class="hljs-keyword">for</span> (CacheData cacheData : listenCaches) {
                                <span class="hljs-keyword">if</span> (cacheData.getReceiveNotifyChanged().get()) {
                                    <span class="hljs-type">String</span> <span class="hljs-variable">changeKey</span> <span class="hljs-operator">=</span> GroupKey.getKeyTenant(cacheData.dataId, cacheData.group,
                                            cacheData.getTenant());
                                    <span class="hljs-keyword">if</span> (!changeKeys.contains(changeKey)) {
                                        <span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializing</span> <span class="hljs-operator">=</span> cacheMap.get().get(changeKey).isInitializing();
                                        refreshContentAndCheck(rpcClient, changeKey, !isInitializing);
                                    }
                                }
                            }

                            <span class="hljs-comment">// 若从服务端未获取到变更的配置，标记为与服务端一致</span>
                            <span class="hljs-keyword">for</span> (CacheData cacheData : listenCaches) {
                                cacheData.setInitializing(<span class="hljs-literal">false</span>);
                                <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey.getKeyTenant(cacheData.dataId, cacheData.group,
                                        cacheData.getTenant());
                                <span class="hljs-keyword">if</span> (!changeKeys.contains(groupKey)) {
                                    <span class="hljs-keyword">synchronized</span> (cacheData) {
                                        <span class="hljs-keyword">if</span> (!cacheData.getReceiveNotifyChanged().get()) {
                                            cacheData.setConsistentWithServer(<span class="hljs-literal">true</span>);
                                        }
                                    }
                                }
                            }

                        }
                    } <span class="hljs-keyword">catch</span> (Throwable e) {
                        <span class="hljs-comment">// 发生异常的话进行重试</span>
                        LOGGER.error(<span class="hljs-string">"Execute listen config change error "</span>, e);
                        <span class="hljs-keyword">try</span> {
                            Thread.sleep(<span class="hljs-number">50L</span>);
                        } <span class="hljs-keyword">catch</span> (InterruptedException interruptedException) {
                            <span class="hljs-comment">//ignore</span>
                        }
                        <span class="hljs-comment">// 重新触发监听检查</span>
                        notifyListenConfig();
                    }
                });
                <span class="hljs-comment">// 将异步任务添加到Future列表中</span>
                listenFutures.add(future);
            }
            <span class="hljs-comment">// 阻塞等待任务完成</span>
            <span class="hljs-keyword">for</span> (Future future : listenFutures) {
                <span class="hljs-keyword">try</span> {
                    future.get();
                } <span class="hljs-keyword">catch</span> (Throwable throwable) {
                    LOGGER.error(<span class="hljs-string">"Async listen config change error "</span>, throwable);
                }
            }

        }
        <span class="hljs-keyword">return</span> hasChangedKeys.get();
    }
}
</code></pre>
<p>这是一个同步调用的方法，虽然比较长但是逻辑上并不难，首先它会将配置按照“任务”的维度分组、合并，这样可以减少对 Nacos Server 服务端的请求数量，合并完成后，每个任务都分配一个线程池去处理，处理时会先查询服务端有哪些配置发生了变更，获取到变更的配置后再逐一处理，调用 <code>ConfigRpcTransportClient#refreshContentAndCheck</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigRpcTransportClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ConfigTransportClient</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshContentAndCheck</span><span class="hljs-params">(RpcClient rpcClient, String groupKey, <span class="hljs-type">boolean</span> notify)</span> {
        <span class="hljs-keyword">if</span> (cacheMap.get() != <span class="hljs-literal">null</span> &amp;&amp; cacheMap.get().containsKey(groupKey)) {
            <span class="hljs-type">CacheData</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> cacheMap.get().get(groupKey);
            refreshContentAndCheck(rpcClient, cache, notify);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshContentAndCheck</span><span class="hljs-params">(RpcClient rpcClient, CacheData cacheData, <span class="hljs-type">boolean</span> notify)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 向服务端查询最新的配置内容，并写入 CacheData 中，并且记录在了本地文件中</span>
            <span class="hljs-type">ConfigResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.queryConfigInner(rpcClient, cacheData.dataId, cacheData.group,
                    cacheData.tenant, requestTimeout, notify);
            cacheData.setEncryptedDataKey(response.getEncryptedDataKey());
            cacheData.setContent(response.getContent());
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != response.getConfigType()) {
                cacheData.setType(response.getConfigType());
            }
            <span class="hljs-keyword">if</span> (notify) {
                LOGGER.info(<span class="hljs-string">"[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, type={}"</span>, agent.getName(),
                        cacheData.dataId, cacheData.group, cacheData.tenant, cacheData.getMd5(),
                        response.getConfigType());
            }
            <span class="hljs-comment">// 检查配置 MD5 变化并触发监听器回调通知应用程序</span>
            cacheData.checkListenerMd5();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            LOGGER.error(<span class="hljs-string">"refresh content and check md5 fail ,dataId={},group={},tenant={} "</span>, cacheData.dataId,
                    cacheData.group, cacheData.tenant, e);
        }
    }
}
</code></pre>
<p>在其中的 <code>ConfigRpcTransportClient#refreshContentAndCheck</code> 方法中会<strong>向 Nacos 服务端查询配置信息，再完成本地配置的写入</strong>，随后执行 <code>CacheData#checkListenerMd5</code> 方法完成监听器的通知回调。在这里我有一个疑问：为什么不在批量查询哪些配置发生变更时一并将配置的内容返回呢？这样的网络开销是不是会更小一些？</p>
<blockquote>
<p>后来我想了想，理论上可行，不过因为每次请求都是请求到 Nacos Server 的内存，所以多次请求也不会给 Nacos Server 造成太大的压力，网络开销也不大</p>
</blockquote>
<p><code>ConfigRpcTransportClient#checkListenCache</code> 方法如果在执行中抛出异常，那么会在 <code>catch</code> 代码块中执行 <code>ConfigRpcTransportClient#notifyListenConfig</code> 方法立即发起配置主动拉取的操作，<strong>避免配置内容更新不及时</strong>。再回到 <code>ClientWorker#executeConfigListen</code> 的逻辑中，如果 <code>ConfigRpcTransportClient#checkListenCache</code> 方法返回 true 表示有配置发生变更，同样地也会执行一次 <code>ConfigRpcTransportClient#notifyListenConfig</code> 方法，这么做的原因可能是当有配置发生变更时，用户可能在这期间陆续修改了多个配置，再次触发配置拉取操作减少配置同步的延时。</p>
<p>现在我们已经对 Nacos Client 处理 Nacos Server 推送配置变更的处理和主动同步配置变更的逻辑比较了解了，现在我们还要注意下 Nacos Client 在同步配置过程中与 Nacos Server 的两次交互：<strong>批量查询配置信息是否发生变更</strong> 和 <strong>查询单个配置的内容</strong>。</p>
<p>首先我们来看批量查询配置信息时，服务端的处理逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigChangeBatchListenRequestHandler</span>
        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;ConfigBatchListenRequest, ConfigChangeBatchListenResponse&gt; {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ConfigChangeListenContext configChangeListenContext;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@NamespaceValidation</span>
    <span class="hljs-meta">@TpsControl(pointName = "ConfigListen")</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.READ, signType = SignType.CONFIG)</span>
    <span class="hljs-meta">@ExtractorManager</span>.Extractor(rpcExtractor = ConfigBatchListenRequestParamExtractor.class)
    <span class="hljs-keyword">public</span> ConfigChangeBatchListenResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(ConfigBatchListenRequest configChangeListenRequest, RequestMeta meta)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 获取连接ID，用于标识客户端连接</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">connectionId</span> <span class="hljs-operator">=</span> StringPool.get(meta.getConnectionId());
        <span class="hljs-type">String</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> configChangeListenRequest.getHeader(Constants.VIPSERVER_TAG);
        ParamUtils.checkParam(tag);
        <span class="hljs-type">ConfigChangeBatchListenResponse</span> <span class="hljs-variable">configChangeBatchListenResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigChangeBatchListenResponse</span>();
        <span class="hljs-comment">// 处理批量监听请求中的每个配置项</span>
        <span class="hljs-keyword">for</span> (ConfigBatchListenRequest.ConfigListenContext listenContext : configChangeListenRequest.getConfigListenContexts()) {
            <span class="hljs-type">boolean</span> <span class="hljs-variable">isNeedTransferNamespace</span> <span class="hljs-operator">=</span> NamespaceUtil.isNeedTransferNamespace(listenContext.getTenant());
            <span class="hljs-type">String</span> <span class="hljs-variable">namespaceId</span> <span class="hljs-operator">=</span> NamespaceUtil.processNamespaceParameter(listenContext.getTenant());
            <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey2.getKey(listenContext.getDataId(), listenContext.getGroup(), namespaceId);
            groupKey = StringPool.get(groupKey);
            
            <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> StringPool.get(listenContext.getMd5());
            
            <span class="hljs-keyword">if</span> (configChangeListenRequest.isListen()) {
                <span class="hljs-comment">// 添加监听：将客户端连接与配置项关联</span>
                configChangeListenContext.addListen(groupKey, md5, connectionId, isNeedTransferNamespace);
                <span class="hljs-comment">// 检查配置是否已经发生变更</span>
                <span class="hljs-type">boolean</span> <span class="hljs-variable">isUptoDate</span> <span class="hljs-operator">=</span> ConfigCacheService.isUptodate(groupKey, md5, meta.getClientIp(), tag,
                        meta.getAppLabels());
                <span class="hljs-comment">// 如果配置已变更，添加变更的配置信息</span>
                <span class="hljs-keyword">if</span> (!isUptoDate) {
                    configChangeBatchListenResponse.addChangeConfig(listenContext.getDataId(), listenContext.getGroup(),
                            listenContext.getTenant());
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 移除监听：取消客户端连接与配置项的关联</span>
                configChangeListenContext.removeListen(groupKey, connectionId);
            }
        }
        
        <span class="hljs-keyword">return</span> configChangeBatchListenResponse;
        
    }
    
}
</code></pre>
<p>其中较为关键的逻辑是检查配置是否发生变更的 <code>ConfigCacheService#isUptodate</code> 方法，可见比较配置是否发生变更的 MD5 值是从本地缓存对象 <code>CacheItem</code> 中获取的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCacheService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUptodate</span><span class="hljs-params">(String groupKey, String md5, String ip, String tag,
                                     Map&lt;String, String&gt; appLabels)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">serverMd5</span> <span class="hljs-operator">=</span> ConfigCacheService.getContentMd5(groupKey, ip, tag, appLabels);
        <span class="hljs-keyword">return</span> StringUtils.equals(md5, serverMd5);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getContentMd5</span><span class="hljs-params">(String groupKey, String ip, String tag, Map&lt;String, String&gt; connLabels)</span> {
        <span class="hljs-comment">// JVM 本地内存对象</span>
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> CACHE.get(groupKey);
        <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> NULL;
        }
        <span class="hljs-keyword">if</span> (connLabels == <span class="hljs-literal">null</span> &amp;&amp; StringUtils.isNotBlank(ip)) {
            connLabels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">4</span>);
        }
        <span class="hljs-keyword">if</span> (connLabels == <span class="hljs-literal">null</span> &amp;&amp; StringUtils.isNotBlank(tag)) {
            connLabels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">4</span>);
        }

        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ip)) {
            connLabels.put(CLIENT_IP, ip);
        }
        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(tag)) {
            connLabels.put(VIPSERVER_TAG, tag);
        }
        <span class="hljs-keyword">if</span> (item.getSortConfigGrays() != <span class="hljs-literal">null</span> &amp;&amp; connLabels != <span class="hljs-literal">null</span> &amp;&amp; !connLabels.isEmpty()) {
            <span class="hljs-keyword">for</span> (ConfigCacheGray entry : item.getSortConfigGrays()) {
                <span class="hljs-keyword">if</span> (entry.match(connLabels)) {
                    <span class="hljs-keyword">return</span> entry.getMd5();
                }
            }
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> item.getConfigCache().getMd5();
        <span class="hljs-keyword">return</span> md5 == <span class="hljs-literal">null</span> ? NULL : md5;
    }
}
</code></pre>
<p>这样做会有什么问题吗？在上文讲解 Nacos Server 变更配置的逻辑中，我们了解到数据库变更是同步的，但是内存和服务端本地 Dump 文件变更是异步的，这样就可能存在节点未完成缓存更新的场景，可能造成查询时实际配置变了（数据库变更）但通过接口查询结果显示配置没变的情况，所以在 Nacos Client 超时自动配置同步的逻辑也是能理解的了，这也反映了 Nacos Client 同步配置遵循的是数据的 <strong>最终一致性</strong>。</p>
<p>其次，我们再看一下 Nacos Client 向 Nacos Server 查询单个配置的场景：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigQueryRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;ConfigQueryRequest, ConfigQueryResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ConfigQueryRequestHandler.class);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigQueryChainService configQueryChainService;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigQueryRequestHandler</span><span class="hljs-params">(ConfigQueryChainService configQueryChainService)</span> {
        <span class="hljs-built_in">this</span>.configQueryChainService = configQueryChainService;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@NamespaceValidation</span>
    <span class="hljs-meta">@TpsControl(pointName = "ConfigQuery")</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.READ, signType = SignType.CONFIG)</span>
    <span class="hljs-meta">@ExtractorManager</span>.Extractor(rpcExtractor = ConfigRequestParamExtractor.class)
    <span class="hljs-keyword">public</span> ConfigQueryResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(ConfigQueryRequest request, RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-keyword">try</span> {
            request.setTenant(NamespaceUtil.processNamespaceParameter(request.getTenant()));
            <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> request.getDataId();
            <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> request.getGroup();
            <span class="hljs-type">String</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> request.getTenant();
            <span class="hljs-type">String</span> <span class="hljs-variable">groupKey</span> <span class="hljs-operator">=</span> GroupKey2.getKey(dataId, group, tenant);
            <span class="hljs-type">boolean</span> <span class="hljs-variable">notify</span> <span class="hljs-operator">=</span> request.isNotify();

            <span class="hljs-type">String</span> <span class="hljs-variable">requestIpApp</span> <span class="hljs-operator">=</span> meta.getLabels().get(CLIENT_APPNAME_HEADER);
            <span class="hljs-type">String</span> <span class="hljs-variable">clientIp</span> <span class="hljs-operator">=</span> meta.getClientIp();

            <span class="hljs-type">ConfigQueryChainRequest</span> <span class="hljs-variable">chainRequest</span> <span class="hljs-operator">=</span> ConfigChainRequestExtractorService.getExtractor().extract(request, meta);
            <span class="hljs-comment">// 执行查询逻辑</span>
            <span class="hljs-type">ConfigQueryChainResponse</span> <span class="hljs-variable">chainResponse</span> <span class="hljs-operator">=</span> configQueryChainService.handle(chainRequest);

            <span class="hljs-keyword">if</span> (ResponseCode.FAIL.getCode() == chainResponse.getResultCode()) {
                <span class="hljs-keyword">return</span> ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), chainResponse.getMessage());
            }
            <span class="hljs-keyword">if</span> (chainResponse.getStatus() == ConfigQueryChainResponse.ConfigQueryStatus.CONFIG_NOT_FOUND) {
                <span class="hljs-keyword">return</span> handlerConfigNotFound(request.getDataId(), request.getGroup(), request.getTenant(), requestIpApp,
                        clientIp, notify);
            }
            <span class="hljs-keyword">if</span> (chainResponse.getStatus() == ConfigQueryChainResponse.ConfigQueryStatus.CONFIG_QUERY_CONFLICT) {
                <span class="hljs-keyword">return</span> handlerConfigConflict(clientIp, groupKey);
            }

            <span class="hljs-type">ConfigQueryResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigQueryResponse</span>();
            response.setMd5(chainResponse.getMd5());
            response.setEncryptedDataKey(chainResponse.getEncryptedDataKey());
            response.setContent(chainResponse.getContent());
            response.setContentType(chainResponse.getConfigType());
            response.setLastModified(chainResponse.getLastModified());
            <span class="hljs-comment">// ...</span>

            <span class="hljs-keyword">return</span> response;

        } <span class="hljs-keyword">catch</span> (Exception e) {
            LOGGER.error(<span class="hljs-string">"Failed to handle grpc configuration query"</span>, e);
            <span class="hljs-keyword">return</span> ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), e.getMessage());
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormalHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConfigQueryHandler</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FORMAL_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-string">"formalHandler"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> FORMAL_HANDLER;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ConfigQueryChainResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(ConfigQueryChainRequest request)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">ConfigQueryChainResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigQueryChainResponse</span>();

        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> request.getDataId();
        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> request.getGroup();
        <span class="hljs-type">String</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> request.getTenant();

        <span class="hljs-comment">// MD5 值来自 JVM 缓存对象</span>
        <span class="hljs-type">CacheItem</span> <span class="hljs-variable">cacheItem</span> <span class="hljs-operator">=</span> ConfigChainEntryHandler.getThreadLocalCacheItem();
        <span class="hljs-type">String</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> cacheItem.getConfigCache().getMd5();
        <span class="hljs-comment">// 配置的内容 Content 来自磁盘文件</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> ConfigDiskServiceFactory.getInstance().getContent(dataId, group, tenant);
        <span class="hljs-keyword">if</span> (StringUtils.isBlank(content)) {
            response.setStatus(ConfigQueryChainResponse.ConfigQueryStatus.CONFIG_NOT_FOUND);
            <span class="hljs-keyword">return</span> response;
        }
        <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> cacheItem.getConfigCache().getLastModifiedTs();
        <span class="hljs-type">String</span> <span class="hljs-variable">encryptedDataKey</span> <span class="hljs-operator">=</span> cacheItem.getConfigCache().getEncryptedDataKey();
        <span class="hljs-type">String</span> <span class="hljs-variable">configType</span> <span class="hljs-operator">=</span> cacheItem.getType();
        response.setContent(content);
        response.setMd5(md5);
        response.setLastModified(lastModified);
        response.setEncryptedDataKey(encryptedDataKey);
        response.setConfigType(configType);
        response.setStatus(ConfigQueryChainResponse.ConfigQueryStatus.CONFIG_FOUND_FORMAL);

        <span class="hljs-keyword">return</span> response;
    }
}
</code></pre>
<p>在这段逻辑中重点关注配置信息读取，可以发现配置的内容来自磁盘文件，配置的 MD5 值来自 JVM 的内存缓存对象，也就是说 Nacos Client 单次查询 Nacos Server 某个配置的内容同样也是不经过数据库的，那么这就 <strong>可能存在查询结果与数据库中实际的配置信息存在差异的情况</strong>。很显然，在 Nacos Server 上进行<strong>配置的发布遵循 CP 定理保证线性一致性</strong>，但是 Nacos Client 来读取的时候会走缓存，因此 <strong>Nacos Client 和 Nacos Server 之间的遵循的是 AP 定理</strong>，遵循数据的 <strong>最终一致性</strong>，通过 Nacos Client 的定期重试来保证配置数据的更新，这样做的好处是 <strong>能够避免数据库成为性能瓶颈</strong>。</p>
<hr/>
<h3 data-id="heading-1">巨人的肩膀</h3>
<ul>
<li><a href="https://juejin.cn/post/7544003305972088878" target="_blank" title="https://juejin.cn/post/7544003305972088878">掘金 - 深入理解分布式共识算法 Raft</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从原理到实践，吃透 Lit 响应式系统的核心逻辑]]></title>    <link>https://juejin.cn/post/7572502156486459418</link>    <guid>https://juejin.cn/post/7572502156486459418</guid>    <pubDate>2025-11-15T06:30:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572502156486459418" data-draft-id="7572437226023747594" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从原理到实践，吃透 Lit 响应式系统的核心逻辑"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-15T06:30:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码农张"/> <meta itemprop="url" content="https://juejin.cn/user/2168666743636654"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从原理到实践，吃透 Lit 响应式系统的核心逻辑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2168666743636654/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码农张
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T06:30:54.000Z" title="Sat Nov 15 2025 06:30:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、为什么 Lit 的响应式 “轻而强”？</h2>
<p>在前端框架林立的当下，响应式系统早已不是新鲜概念。Vue 的<code>reactive</code>、React 的<code>useState</code>，都通过抽象封装让开发者摆脱了手动操作 DOM 的繁琐。但 Lit 的响应式却走出了一条差异化路线 ——<strong>基于原生 JavaScript，无额外依赖，却能实现高效的状态驱动视图更新</strong>。</p>
<p>我在 4 年前端开发中，曾用 Vue、React 搭建过多个中后台项目，也踩过不少性能坑：大型列表渲染时的卡顿、复杂状态依赖导致的更新混乱、框架打包后体积过大影响首屏加载。直到接触 Lit，才发现它的响应式设计恰好解决了这些痛点。</p>
<p>Lit 的响应式核心体积仅几 KB，却能实现 “精准更新”—— 只有状态发生变化时，才会触发组件的重新渲染，且仅更新变化的 DOM 节点。这背后的关键，在于它没有引入复杂的虚拟 DOM，而是基于原生<code>Proxy</code>和 “属性访问追踪” 机制，让状态与视图的绑定更直接、更高效。</p>
<p>更重要的是，Lit 的响应式不依赖任何框架 runtime，组件编译后可直接在浏览器中运行，既能独立使用，也能嵌入其他框架。这种灵活性，让它在跨项目组件复用、设计系统搭建等场景中极具优势。也正因为如此，我决定深入拆解 Lit 响应式的底层逻辑，帮大家不仅 “会用”，更能 “吃透”。</p>
<h2 data-id="heading-1">二、Lit 响应式的底层原理：3 个核心机制</h2>
<p>要掌握 Lit 的响应式，不能只停留在 API 调用层面。我通过阅读 Lit 源码（v3.0 版本）、调试组件更新流程，总结出其核心依赖 3 个关键机制：<strong>状态追踪、依赖收集、精准更新</strong>。</p>
<h3 data-id="heading-2">1. 状态追踪：基于 Proxy 的 “属性访问监听”</h3>
<p>Lit 的响应式状态通过<code>@state()</code>装饰器或<code>createSignal</code>函数创建，其本质是对原始数据的 Proxy 代理。与 Vue 3 的<code>reactive</code>类似，但 Lit 的 Proxy 封装更轻量，仅聚焦 “属性访问” 和 “状态修改” 两个核心场景。</p>
<p>当你在组件中定义如下状态时：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LitElement</span>, html, state } <span class="hljs-keyword">from</span> <span class="hljs-string">'lit'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {
  <span class="hljs-meta">@state</span>() user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };
  <span class="hljs-meta">@state</span>() count = <span class="hljs-number">0</span>;

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> html`<span class="xml">
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>姓名：</span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.user.name}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>年龄：</span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.user.age}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>计数：</span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.count}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=</span></span><span class="hljs-subst">${() =&gt; <span class="hljs-variable language_">this</span>.count++}</span><span class="xml"><span class="hljs-tag">&gt;</span>点击+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    `</span>;
  }
}
</code></pre>
<p><code>@state()</code>会将<code>user</code>和<code>count</code>转化为 Proxy 对象。当组件首次执行<code>render</code>函数时，访问<code>this.user.name</code>、<code>this.count</code>等属性的过程，会被 Proxy 拦截并记录 —— 这一步就是 “属性访问追踪”。</p>
<p>Lit 内部维护了一个 “当前有效更新上下文”（currentUpdateContext），当属性被访问时，会将该属性与当前组件的更新函数关联起来。简单说：<strong>组件渲染时，哪些属性被用到了，Lit 就会记住 “这个属性变化时，需要重新执行渲染”</strong>。</p>
<h3 data-id="heading-3">2. 依赖收集：建立 “状态 - 组件” 的映射关系</h3>
<p>依赖收集是响应式系统的核心，它决定了 “状态变化时，该通知哪些组件更新”。Lit 的依赖收集机制非常简洁，核心是一个 “依赖映射表”（depsMap），结构如下：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 简化后的依赖映射表结构</span>
<span class="hljs-keyword">const</span> depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>([
  <span class="hljs-comment">// key: 响应式状态对象（如user）</span>
  [userProxy, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
    <span class="hljs-comment">// key: 属性名（如name）</span>
    [<span class="hljs-string">'name'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([
      <span class="hljs-comment">// value: 依赖该属性的组件更新函数</span>
      componentUpdateFn1,
      componentUpdateFn2
    ])]
  ])]
]);
</code></pre>
<p>当组件渲染时，每访问一个响应式属性，Lit 都会执行三步操作：</p>
<ol>
<li>检查当前是否存在 “更新上下文”（即组件是否在渲染中）；</li>
<li>若存在，从依赖映射表中找到该属性对应的依赖集合；</li>
<li>将当前组件的更新函数加入依赖集合。</li>
</ol>
<p>这个过程就像 “订阅 - 发布” 模式：响应式属性是 “发布者”，组件更新函数是 “订阅者”。依赖收集完成后，当属性发生变化，所有订阅它的更新函数都会被触发。</p>
<p>这里有个容易被忽略的细节：Lit 的依赖收集是 “懒收集” 的 —— 只有属性被实际访问时，才会建立依赖关系。如果某个状态定义后从未在<code>render</code>中使用，即使修改它，也不会触发组件更新。这种设计避免了无效的更新开销，提升了性能。</p>
<h3 data-id="heading-4">3. 精准更新：跳过虚拟 DOM，直接操作真实 DOM</h3>
<p>这是 Lit 响应式最具特色的一点。与 React、Vue 通过虚拟 DOM 对比差异来更新视图不同，Lit 采用 “模板字面量 + DOM 差异标记” 的方式，实现更高效的真实 DOM 更新。</p>
<p>当响应式状态变化时，Lit 会执行以下流程：</p>
<ol>
<li>状态修改触发 Proxy 的<code>set</code>拦截器；</li>
<li>从依赖映射表中取出该属性对应的所有更新函数，执行这些函数重新生成组件模板；</li>
<li>Lit 的模板编译器会对比新旧模板的差异，仅标记变化的 DOM 节点（如文本内容、属性值）；</li>
<li>直接操作真实 DOM，只更新标记的差异节点，无需整体重新渲染。</li>
</ol>
<p>举个例子：如果只修改<code>this.count</code>，Lit 会重新生成模板，但仅对比出 “计数” 对应的文本节点发生变化，随后直接更新该节点的<code>textContent</code>，而不会触碰<code>user</code>相关的 DOM 节点。</p>
<p>这种 “精准更新” 机制，让 Lit 组件的渲染性能远超许多框架。我曾做过一个测试：在同样渲染 1000 条列表数据的场景下，Lit 组件的首次渲染时间比 React 组件快 30%，更新时间快 50%（数据基于 Chrome 浏览器性能面板测试）。</p>
<h2 data-id="heading-5">三、实战避坑：Lit 响应式的 5 个关键技巧</h2>
<p>理解原理后，更重要的是在实战中灵活运用。结合我在项目中使用 Lit 的经验，总结了 5 个高频场景的避坑技巧，帮你避开 90% 的使用误区。</p>
<h3 data-id="heading-6">1. 复杂对象状态：避免 “深层属性更新不触发渲染”</h3>
<p>Lit 的<code>@state()</code>对复杂对象的响应式支持是 “浅层” 的吗？很多开发者会遇到这个问题：修改对象的深层属性时，组件没有触发更新。比如：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-ini" lang="ini">// 错误示例：修改深层属性，未触发更新
<span class="hljs-attr">this.user.address.city</span> = <span class="hljs-string">'北京'</span><span class="hljs-comment">;</span>
</code></pre>
<p>这不是 Lit 的缺陷，而是 Proxy 的特性 —— 默认情况下，Proxy 只能监听对象的第一层属性变化。要解决这个问题，有两种方案：</p>
<p>方案一：使用<code>@state()</code>装饰器时，确保对象的深层属性修改时，触发顶层属性的 setter：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 正确示例：重新赋值顶层属性</span>
<span class="hljs-keyword">this</span>.user = { ...<span class="hljs-keyword">this</span>.user, address: { ...<span class="hljs-keyword">this</span>.user.address, city: <span class="hljs-string">'北京'</span> } };
</code></pre>
<p>方案二：对于需要频繁修改的复杂对象，使用<code>createDeepSignal</code>（Lit v3.0 + 新增 API），它会递归代理对象的所有层级属性：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">import</span> { createDeepSignal } from 'lit/decorators/signal.js';

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitElement</span> </span>{
  user = createDeepSignal({ name: '张三', address: { city: '上海' } });

  <span class="hljs-comment">// 直接修改深层属性，会触发更新</span>
  updateCity() {
    <span class="hljs-keyword">this</span>.user.value.address.city = '北京';
  }
}
</code></pre>
<h3 data-id="heading-7">2. 数组状态：避免 “直接修改数组不触发更新”</h3>
<p>与对象类似，直接修改数组的元素或长度（如<code>push</code>、<code>splice</code>、<code>arr[0] = xxx</code>），默认不会触发 Lit 的响应式更新。这是因为数组的这些操作不会触发 Proxy 的<code>set</code>拦截器（针对数组的索引或<code>length</code>属性）。</p>
<p>解决方案有两个：</p>
<ul>
<li>
<p>对于简单数组，使用扩展运算符创建新数组：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 正确示例：添加元素</span>
<span class="hljs-keyword">this</span>.list = [...<span class="hljs-keyword">this</span>.list, newItem];
<span class="hljs-comment">// 正确示例：修改元素</span>
<span class="hljs-keyword">this</span>.list = <span class="hljs-keyword">this</span>.list.map((item, index) =&gt; index === <span class="hljs-number">0</span> ? newItem : item);
</code></pre>
</li>
<li>
<p>对于复杂数组，使用<code>createSignal</code>结合不可变数据处理：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">import</span> { createSignal } from 'lit/decorators/signal.js';

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitElement</span> </span>{
  list = createSignal([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

  addItem() {
    <span class="hljs-comment">// 基于原数组创建新数组，触发更新</span>
    <span class="hljs-keyword">this</span>.list.set([...<span class="hljs-keyword">this</span>.list.value, <span class="hljs-number">4</span>]);
  }
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-8">3. 状态依赖：使用computed处理衍生状态</h3>
<p>在实际开发中，经常会遇到 “基于多个状态计算衍生状态” 的场景。比如，根据<code>user</code>的<code>age</code>和<code>isStudent</code>状态，计算是否享受优惠：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误示例：直接在render中计算，可能导致重复计算</span>
<span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> hasDiscount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">age</span> &lt; <span class="hljs-number">25</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">isStudent</span>;
  <span class="hljs-keyword">return</span> html`<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>是否优惠：</span><span class="hljs-subst">${hasDiscount ? <span class="hljs-string">'是'</span> : <span class="hljs-string">'否'</span>}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span>;
}
</code></pre>
<p>这种写法的问题是：每次组件更新时，<code>hasDiscount</code>都会重新计算，即使依赖的状态没有变化。Lit 提供了<code>computed</code>函数，专门处理衍生状态，且具备缓存特性 —— 只有依赖的状态变化时，才会重新计算。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> { computed } from <span class="hljs-string">'lit/decorators/computed.js'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-title">extends</span> <span class="hljs-title">LitElement</span> {
  <span class="hljs-meta">@state()</span> user = { age: <span class="hljs-number">22</span>, isStudent: <span class="hljs-literal">true</span> };

  <span class="hljs-comment">// 正确示例：使用computed缓存衍生状态</span>
  <span class="hljs-meta">@computed()</span>
  <span class="hljs-keyword">get</span> hasDiscount() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.user.age &lt; <span class="hljs-number">25</span> &amp;&amp; <span class="hljs-keyword">this</span>.user.isStudent;
  }

  render() {
    <span class="hljs-keyword">return</span> html`&lt;div&gt;是否优惠：${<span class="hljs-keyword">this</span>.hasDiscount ? <span class="hljs-string">'是'</span> : <span class="hljs-string">'否'</span>}&lt;/div&gt;`;
  }
}
</code></pre>
<p><code>computed</code>函数会自动收集依赖的响应式状态，当<code>user.age</code>或<code>user.isStudent</code>变化时，才会重新计算<code>hasDiscount</code>的值，避免无效计算。</p>
<h3 data-id="heading-9">4. 批量更新：使用requestUpdate避免多次渲染</h3>
<p>如果一次操作中需要修改多个状态，直接修改可能会触发多次组件更新。比如：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 可能触发两次渲染</span>
<span class="hljs-keyword">this</span>.count++;
<span class="hljs-keyword">this</span>.user.name = <span class="hljs-string">'李四'</span>;
</code></pre>
<p>虽然 Lit 内部有一定的更新合并机制，但在复杂场景下，仍可能出现多次渲染的情况。此时可以使用<code>requestUpdate</code>方法，手动批量处理状态更新，确保只触发一次渲染：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 正确示例：批量更新，仅触发一次渲染</span>
<span class="hljs-keyword">this</span>.requestUpdate(() =&gt; {
  <span class="hljs-keyword">this</span>.count++;
  <span class="hljs-keyword">this</span>.user = { ...<span class="hljs-keyword">this</span>.user, name: <span class="hljs-string">'李四'</span> };
});
</code></pre>
<p><code>requestUpdate</code>的回调函数中，所有状态修改都会被合并，回调执行完成后，才会触发组件的一次重新渲染，提升性能。</p>
<h3 data-id="heading-10">5. 状态共享：跨组件通信的 3 种方案</h3>
<p>在中大型项目中，不可避免会遇到跨组件状态共享的需求。Lit 没有内置的全局状态管理工具，但结合其响应式特性，有 3 种实用方案：</p>
<p>方案一：使用 “父传子 + 子传父” 的传统方式，适用于父子组件通信：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// 父组件</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitElement</span> </span>{
  <span class="hljs-meta">@state</span>() count = <span class="hljs-number">0</span>;

  updateCount(newCount) {
    <span class="hljs-keyword">this</span>.count = newCount;
  }

  render() {
    <span class="hljs-keyword">return</span> html`&lt;child-component .count=${<span class="hljs-keyword">this</span>.count} <span class="hljs-meta">@count</span>-change=${(e) =&gt; <span class="hljs-keyword">this</span>.updateCount(e.detail)}&gt;&lt;/child-component&gt;`;
  }
}

<span class="hljs-comment">// 子组件</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitElement</span> </span>{
  <span class="hljs-meta">@property</span>() count = <span class="hljs-number">0</span>;

  handleClick() {
    <span class="hljs-keyword">this</span>.dispatchEvent(<span class="hljs-keyword">new</span> <span class="hljs-type">CustomEvent</span>('count-change', { detail: <span class="hljs-keyword">this</span>.count + <span class="hljs-number">1</span> }));
  }

  render() {
    <span class="hljs-keyword">return</span> html`&lt;button <span class="hljs-meta">@click</span>=${<span class="hljs-keyword">this</span>.handleClick}&gt;${<span class="hljs-keyword">this</span>.count}&lt;/button&gt;`;
  }
}
</code></pre>
<p>方案二：使用<code>createContext</code>创建全局上下文，适用于跨层级组件通信：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// context.js</span>
<span class="hljs-keyword">import</span> { createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'lit'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// 根组件</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CountContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./context.js'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RootComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {
  <span class="hljs-meta">@state</span>() count = <span class="hljs-number">0</span>;

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> html`<span class="xml">
      <span class="hljs-tag">&lt;<span class="hljs-name">CountContext.Provider</span> <span class="hljs-attr">value</span>=</span></span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.count}</span><span class="xml"><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">CountContext.Provider</span>&gt;</span>
    `</span>;
  }
}

<span class="hljs-comment">// 子组件（任意层级）</span>
<span class="hljs-keyword">import</span> { useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'lit'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CountContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./context.js'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {
  count = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>);

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> html`<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>全局计数：</span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.count}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span>;
  }
}
</code></pre>
<p>方案三：使用外部响应式状态，适用于全局共享状态（如用户信息）：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// globalState.js</span>
<span class="hljs-keyword">import</span> { createSignal } <span class="hljs-keyword">from</span> <span class="hljs-string">'lit/decorators/signal.js'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userState = <span class="hljs-title function_">createSignal</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">'admin'</span> });

<span class="hljs-comment">// 任意组件</span>
<span class="hljs-keyword">import</span> { userState } <span class="hljs-keyword">from</span> <span class="hljs-string">'./globalState.js'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> html`<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名：</span><span class="hljs-subst">${userState.value.name}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span>;
  }
}

<span class="hljs-comment">// 修改全局状态（任意组件中）</span>
userState.<span class="hljs-title function_">set</span>({ ...userState.<span class="hljs-property">value</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span> });
</code></pre>
<p>这种方案无需上下文嵌套，灵活度高，且修改状态后，所有使用该状态的组件都会自动更新。</p>
<h2 data-id="heading-11">四、原理延伸：Lit 响应式与其他框架的核心差异</h2>
<p>通过前面的分析，我们已经掌握了 Lit 响应式的核心逻辑。但要真正理解它的优势，还需要与 Vue、React 的响应式系统做对比，看清背后的设计思路差异。</p>
<h3 data-id="heading-12">1. 与 Vue 3 响应式的差异</h3>
<p>Vue 3 的响应式同样基于 Proxy，但两者的设计目标不同：</p>
<ul>
<li>Vue 的响应式更 “全能”，支持深层代理、数组变异方法（如<code>push</code>）、依赖自动收集等，封装程度高，开发者无需关注底层实现；</li>
<li>Lit 的响应式更 “轻量化”，默认只支持浅层代理，数组变异方法需要手动处理，但其核心逻辑更简洁，无额外 runtime 开销，组件兼容性更强。</li>
</ul>
<p>适用场景：如果是纯 Vue 项目，使用 Vue 自带的响应式更高效；如果需要跨框架复用组件，Lit 的响应式更有优势。</p>
<h3 data-id="heading-13">2. 与 React 响应式的差异</h3>
<p>React 的响应式基于 “状态更新触发重新渲染”，核心是虚拟 DOM 对比：</p>
<ul>
<li>React 的<code>useState</code>不追踪状态的具体变化，只要调用<code>setState</code>，就会触发组件重新渲染（除非使用<code>React.memo</code>、<code>useMemo</code>优化）；</li>
<li>Lit 的响应式精准追踪属性访问，只有被渲染使用的状态变化时，才会触发更新，且直接操作真实 DOM，无需虚拟 DOM 对比。</li>
</ul>
<p>性能差异：在小型组件、简单状态场景下，两者性能差距不大；但在大型列表、复杂状态依赖场景下，Lit 的精准更新机制能显著提升性能。</p>
<h2 data-id="heading-14">五、总结：掌握 Lit 响应式的 3 个关键</h2>
<p>Lit 的响应式系统看似简单，实则蕴含着 “轻量、高效、兼容” 的设计哲学。通过本文的拆解，希望能帮你建立起完整的知识体系：</p>
<ol>
<li>核心逻辑：记住 “状态追踪 - 依赖收集 - 精准更新” 三步流程，理解 Proxy 在其中的作用；</li>
<li>实战技巧：掌握复杂对象 / 数组的更新方式、<code>computed</code>衍生状态、批量更新、跨组件通信等高频场景的解决方案；</li>
<li>差异认知：明确 Lit 与其他框架响应式的区别，根据项目场景选择合适的技术方案。</li>
</ol>
<p>Lit 的响应式是其组件化开发的基础，吃透这部分内容，后续学习组件封装、性能优化、工程化配置等知识都会事半功倍。在接下来的小册内容中，我会结合更多实战项目，带你深入 Lit 的组件开发、工程化落地等核心场景，让你真正能用 Lit 搭建出高效、可复用的前端系统。</p>
<p>如果想提前查看 Lit 官方对响应式的详细说明，可以参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Flit.dev%2Fdocs%2Freactivity%2F" target="_blank" title="https://lit.dev/docs/reactivity/" ref="nofollow noopener noreferrer">Lit 响应式文档</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[object和map 和 WeakMap 的区别]]></title>    <link>https://juejin.cn/post/7572459217811210303</link>    <guid>https://juejin.cn/post/7572459217811210303</guid>    <pubDate>2025-11-15T06:31:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459217811210303" data-draft-id="7572396000545128511" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="object和map 和 WeakMap 的区别"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-15T06:31:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="jump680"/> <meta itemprop="url" content="https://juejin.cn/user/3631047185561411"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            object和map 和 WeakMap 的区别
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3631047185561411/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    jump680
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T06:31:43.000Z" title="Sat Nov 15 2025 06:31:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">object 和 map的区别</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/521d61187bdb41c084b96629ccb963b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAganVtcDY4MA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763793423&amp;x-signature=GsARTaSv2smjhmhsi01mBwKhMlg%3D" alt="PixPin_2025-11-15_00-40-56.png" loading="lazy"/>
<strong>选择 Object 的场景：</strong></p>
<ol>
<li><strong>简单的结构化数据/记录</strong>：当你需要创建一个结构固定的“东西”，并且属性名是简单、已知的字符串时。例如，一个用户对象 const user = { name: 'John', email: '...' }。</li>
<li><strong>JSON 操作</strong>：当数据需要通过 JSON.stringify() 或 JSON.parse() 进行序列化和反序列化时，必须使用 Object，因为 JSON 只支持字符串键。</li>
<li><strong>表示一个实体</strong>：当代码的意图是描述一个具体事物的属性时。</li>
</ol>
<p>Object 当作一个“记录 (Record)”或“结构体 (Struct)”，把 Map 当作一个真正的“字典 (Dictionary)”或“哈希表 (Hash Map)”。</p>
<p>map的key可以是<code>任何类型</code>，<code>map</code>对它的<code>key</code>是<code>强引用</code>的关系。也就是即使<code>对象类型置空</code>，对象类型依然会被map引用。导致无法被回收。(<code>引用计数器</code>不为零，<code>无法被回收</code>)</p>
<p>WeakMap 是 JavaScript (ES6) 中引入的一种新的集合类型。要理解它的核心作用，关键在于理解两个词：“Map” 和 “Weak”（弱引用）。</p>
<hr/>
<h4 data-id="heading-1">1. 首先，它是一个 Map</h4>
<p>和普通的 Map 一样，WeakMap 也是一个键值对（key-value）的集合。你可以用 set(key, value) 来添加数据，用 get(key) 来获取数据，用 has(key) 来检查是否存在，用 delete(key) 来删除。</p>
<p>codeJavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<span class="hljs-keyword">const</span> obj = {};

<span class="hljs-comment">// 设置键值对</span>
wm.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">'一些与obj相关的数据'</span>);

<span class="hljs-comment">// 获取值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">get</span>(obj)); <span class="hljs-comment">// '一些与obj相关的数据'</span>

<span class="hljs-comment">// 检查是否存在</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 删除</span>
wm.<span class="hljs-title function_">delete</span>(obj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// false</span>
</code></pre>
<p>但是，WeakMap 和 Map 有几个关键的区别，这些区别正是 WeakMap 价值的体现。</p>
<hr/>
<h4 data-id="heading-2">2. 核心特性：“Weak”（弱引用）</h4>
<p>这是 WeakMap 最重要、最核心的概念。要理解“弱引用”，我们先要明白什么是“强引用”。</p>
<h5 data-id="heading-3">强引用 (Strong Reference)</h5>
<p>在 JavaScript 中，我们平时使用的都是强引用。比如：</p>
<p>codeJavaScript</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">obj</span> = { name: <span class="hljs-string">'Alice'</span> }<span class="hljs-comment">; // 变量 obj 对 { name: 'Alice' } 这个对象是一个强引用</span>
let <span class="hljs-attr">anotherObj</span> = obj<span class="hljs-comment">;       // 变量 anotherObj 也对这个对象产生了一个强引用</span>
</code></pre>
<p>只要至少还有一个强引用指向一个对象，垃圾回收机制（Garbage Collection, GC）就<strong>不会</strong>回收这个对象。在上面的例子中，即使我们设置 obj = null，anotherObj 仍然引用着那个对象，所以它不会被回收。</p>
<h5 data-id="heading-4">弱引用 (Weak Reference)</h5>
<p>弱引用则不同。<strong>一个<code>弱引用</code>并<code>不会阻止</code>垃圾回收机制回收它所<code>引用的对象</code>。</strong></p>
<p><code>WeakMap</code> 对它的**键（<code>key</code>）**就是<code>弱引用</code>。</p>
<p>让我们通过一个 Map 和 WeakMap 的对比来理解这一点：</p>
<p><strong>使用 Map (强引用) 的情况：</strong></p>
<p>codeJavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
<span class="hljs-keyword">let</span> keyObject = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };

myMap.<span class="hljs-title function_">set</span>(keyObject, <span class="hljs-string">"一些元数据"</span>);

<span class="hljs-comment">// 现在，myMap 强引用着 keyObject。</span>

<span class="hljs-comment">// 我们尝试“忘记”keyObject，把对它的所有其他引用都断开</span>
keyObject = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 此时，keyObject 还能被访问到吗？</span>
<span class="hljs-comment">// 答案是：可以，通过 myMap。</span>
<span class="hljs-comment">// 因为 myMap 内部的引用是强引用，所以 { id: 1 } 这个对象无法被垃圾回收。</span>
<span class="hljs-comment">// 这就造成了潜在的内存泄漏！只要 myMap 存在，这个对象就永远存在。</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// { id: 1 }</span>
</code></pre>
<p><strong>使用 WeakMap (弱引用) 的情况：</strong></p>
<p>codeJavaScript</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">let</span> myWeakMap = <span class="hljs-keyword">new</span> WeakMap();
<span class="hljs-keyword">let</span> keyObject = { id: <span class="hljs-number">1</span> };

myWeakMap.<span class="hljs-keyword">set</span>(keyObject, <span class="hljs-string">"一些元数据"</span>);

<span class="hljs-comment">// 现在，myWeakMap 弱引用着 keyObject。</span>

<span class="hljs-comment">// 我们同样尝试“忘记”keyObject</span>
keyObject = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 此时，再也没有任何强引用指向 { id: 1 } 这个对象了。</span>
<span class="hljs-comment">// 垃圾回收机制在下一次运行时，就会发现这个对象可以被安全地回收。</span>
<span class="hljs-comment">// 一旦对象被回收，WeakMap 中对应的这个键值对也会被自动移除。</span>

<span class="hljs-comment">// 注意：我们无法直接验证这一点，因为垃圾回收的时机是不确定的。</span>
<span class="hljs-comment">// 但我们可以确信，这个键值对不会永久存在，从而避免了内存泄漏。</span>
</code></pre>
<p><strong>总结一下弱引用的效果：</strong>  WeakMap 允许你将数据与一个对象关联起来，但当这个对象在程序的其他地方不再被需要（即没有任何强引用指向它）时，WeakMap 不会成为它继续存活下去的“救命稻草”。它会自动“放手”，让垃圾回收机制清理内存。</p>
<hr/>
<h4 data-id="heading-5">3. WeakMap 的主要作用和应用场景</h4>
<p>基于“弱引用”这个核心特性，WeakMap 主要被用来解决以下几类问题：</p>
<h5 data-id="heading-6">场景一：存储对象的私有数据或元数据（最经典的应用）</h5>
<p>当你想要为一个对象附加一些额外信息，但又不想直接修改这个对象本身时，WeakMap 是完美的解决方案。</p>
<p><strong>问题：</strong>  假设你正在编写一个库，需要为用户传入的对象添加一些内部状态，但你不能在对象上添加属性（比如 userObject._myLibraryState = ...），因为这会污染对象，可能与用户的代码冲突。</p>
<p><strong>使用 Map 的缺陷：</strong>  你可以用一个全局的 Map 来存储：map.set(userObject, myState)。但这会导致前面提到的内存泄漏问题。如果用户用完 userObject 并将其设置为 null，你的 Map 仍然会“抓住”它不放。</p>
<p><strong>WeakMap 的解决方案：</strong></p>
<p>codeJavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-comment">// 将私有数据存储在 WeakMap 中，用 this (实例对象) 作为键</span>
    privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, { <span class="hljs-attr">loginCount</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">lastLogin</span>: <span class="hljs-literal">null</span> });
  }

  <span class="hljs-title function_">login</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> data = privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);
    data.<span class="hljs-property">loginCount</span>++;
    data.<span class="hljs-property">lastLogin</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 登录成功，已登录 <span class="hljs-subst">${data.loginCount}</span> 次。`</span>);
  }
}

<span class="hljs-keyword">let</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'Bob'</span>);
user1.<span class="hljs-title function_">login</span>(); <span class="hljs-comment">// Bob 登录成功，已登录 1 次。</span>

<span class="hljs-comment">// 当 user1 不再被使用时，比如：</span>
user1 = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// 在未来的某个时刻，垃圾回收机制会回收原来 user1 指向的对象。</span>
<span class="hljs-comment">// 同时，privateData 中与该对象关联的数据也会被自动清除，不会造成内存泄漏。</span>
</code></pre>
<p>这个模式在 JavaScript 实现私有属性的早期探索中非常流行（在 # 私有字段语法普及之前）。</p>
<h5 data-id="heading-7">场景二：缓存计算结果 (Memoization)</h5>
<p>当你有一个对对象进行复杂计算的函数时，你可以用 WeakMap 来缓存结果，以避免重复计算。</p>
<p><strong>问题：</strong>  有一个函数 process(obj)，计算成本很高。如果多次传入同一个 obj，我们希望直接返回缓存的结果。</p>
<p><strong>WeakMap 的解决方案：</strong></p>
<p>codeJavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-comment">// 如果缓存中有，直接返回</span>
  <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(obj)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'从缓存中读取...'</span>);
    <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(obj);
  }

  <span class="hljs-comment">// 否则，进行复杂计算</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'正在进行复杂计算...'</span>);
  <span class="hljs-keyword">const</span> result = <span class="hljs-comment">/* ... 一些非常耗时的操作 ... */</span> obj.<span class="hljs-property">value</span> * <span class="hljs-number">10</span>;

  <span class="hljs-comment">// 将结果存入缓存</span>
  cache.<span class="hljs-title function_">set</span>(obj, result);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> myObj = { <span class="hljs-attr">value</span>: <span class="hljs-number">5</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">process</span>(myObj)); <span class="hljs-comment">// 正在进行复杂计算...  50</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">process</span>(myObj)); <span class="hljs-comment">// 从缓存中读取...    50</span>

<span class="hljs-comment">// 当 myObj 不再需要时</span>
myObj = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// 缓存中的 { value: 5 } -&gt; 50 这条记录会自动被清理，释放内存。</span>
<span class="hljs-comment">// 如果用 Map，这条缓存会一直存在。</span>
</code></pre>
<h5 data-id="heading-8">场景三：管理 DOM 节点与数据的关联</h5>
<p>在前端开发中，我们经常需要为 DOM 元素附加一些状态或数据。</p>
<p><strong>问题：</strong>  你为一个按钮添加了一个点击事件监听器，并且需要存储一些与该按钮相关的状态。如果把这些状态存在一个全局的 Map 或对象中，当这个按钮从页面上被移除后，Map 中对它的引用依然存在，导致这个（已经分离的）DOM 节点无法被回收，造成内存泄漏。</p>
<p><strong>WeakMap 的解决方案：</strong></p>
<p>codeJavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myButton'</span>);

elementData.<span class="hljs-title function_">set</span>(button, { <span class="hljs-attr">clickCount</span>: <span class="hljs-number">0</span> });

button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> data = elementData.<span class="hljs-title function_">get</span>(button);
  data.<span class="hljs-property">clickCount</span>++;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮被点击了 <span class="hljs-subst">${data.clickCount}</span> 次`</span>);
});

<span class="hljs-comment">// 假设在某个时刻，我们从 DOM 中移除了这个按钮</span>
<span class="hljs-comment">// button.parentNode.removeChild(button);</span>
<span class="hljs-comment">// 并且没有其他地方引用这个 button 变量了。</span>
<span class="hljs-comment">// 那么这个 DOM 节点就会被垃圾回收，elementData 中对应的数据也会被自动清除。</span>
</code></pre>
<hr/>
<h4 data-id="heading-9">4. WeakMap 的限制</h4>
<p>为了实现弱引用和自动垃圾回收，WeakMap 付出了一些代价，导致它有以下限制：</p>
<ol>
<li><strong>键必须是对象</strong>：WeakMap 的键不能是原始类型值（如 string, number, symbol），因为原始值是不可变的，没有被垃圾回收的概念。</li>
<li><strong>不可遍历</strong>：WeakMap 没有 keys(), values(), entries() 方法，也不支持 forEach 循环，也没有 size 属性。因为键值对可能在任何时候被垃圾回收机制移除，所以它的成员列表是不确定的，遍历它没有意义。</li>
</ol>
<h4 data-id="heading-10">总结</h4>
<p>WeakMap 的核心作用是<strong>在不影响对象生命周期的前提下，将数据与该对象进行关联</strong>。</p>
<h2 data-id="heading-11">✅ WeakMap 的 key 可以是什么？</h2>
<p>👇 这些都是合法的 key：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> WeakMap();

wm.<span class="hljs-keyword">set</span>({}, <span class="hljs-string">'obj'</span>);          <span class="hljs-comment">// 普通对象</span>
wm.<span class="hljs-keyword">set</span>([], <span class="hljs-string">'array'</span>);        <span class="hljs-comment">// 数组</span>
wm.<span class="hljs-keyword">set</span>(() =&gt; {}, <span class="hljs-string">'fn'</span>);     <span class="hljs-comment">// 函数</span>
wm.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(), <span class="hljs-string">'map'</span>);   <span class="hljs-comment">// Map</span>
wm.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(), <span class="hljs-string">'set'</span>);   <span class="hljs-comment">// Set</span>
wm.<span class="hljs-keyword">set</span>(<span class="hljs-built_in">document</span>.body, <span class="hljs-string">'dom'</span>); <span class="hljs-comment">// DOM 节点</span>
wm.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>), <span class="hljs-string">'wrapped number'</span>); <span class="hljs-comment">// 包装对象</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[了解响应式Web设计：viewport网页可视区域]]></title>    <link>https://juejin.cn/post/7572459757106888758</link>    <guid>https://juejin.cn/post/7572459757106888758</guid>    <pubDate>2025-11-15T06:36:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459757106888758" data-draft-id="7572405211442053163" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="了解响应式Web设计：viewport网页可视区域"/> <meta itemprop="keywords" content="前端,HTML"/> <meta itemprop="datePublished" content="2025-11-15T06:36:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BBB努力学习程序设计"/> <meta itemprop="url" content="https://juejin.cn/user/3097787706900985"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            了解响应式Web设计：viewport网页可视区域
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3097787706900985/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BBB努力学习程序设计
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T06:36:39.000Z" title="Sat Nov 15 2025 06:36:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#444;background-image:linear-gradient(90deg,rgba(59,59,59,.1) 3%,transparent 0),linear-gradient(1turn,rgba(122,120,121,.1) 3%,transparent 0);background-size:30px 30px;background-position:50%;letter-spacing:1px;word-spacing:1px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:34px;margin-bottom:16px;font-weight:700;line-height:1.3;cursor:text;color:#444;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body h1{font-size:41px;margin-bottom:34px;line-height:1.5}.markdown-body h1:before{content:""}.markdown-body h2{font-size:30px;padding-left:.4em;border-left:.4em solid #5e5e5e;border-bottom:1px solid #444}.markdown-body h2:after{content:"🕛";position:absolute;top:0;right:0;transition:all;animation:rotate 10s linear infinite}@keyframes rotate{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.markdown-body h3{border-left:.4em solid #8d8d8d;font-size:24px;padding-left:.4em}.markdown-body h4{font-size:20px}.markdown-body h5{font-size:16px}.markdown-body h6{font-size:14px}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body table,.markdown-body ul{margin:.8em 0}.markdown-body strong{font-weight:1000;position:relative;color:#444;padding:0 3px}.markdown-body em{font-weight:inherit}.markdown-body a{box-sizing:border-box;color:grey;position:relative}.markdown-body a:before{position:absolute;box-sizing:border-box;content:"Go -&gt;";left:0;width:100%;max-width:0;color:#fff;background-color:hsla(0,0%,50.2%,.8);white-space:nowrap;transition:.2s ease;pointer-events:none;overflow:hidden}.markdown-body a:after{content:"";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:grey}.markdown-body a:active:before,.markdown-body a:hover:before{max-width:100%;padding-left:8px;border-radius:5px}.markdown-body hr{position:relative;width:100%;height:1px;border:none;margin-top:36px;margin-bottom:36px;background:linear-gradient(90deg,grey,#f1f1f1,#444,#444,#f1f1f1,grey);overflow:visible}.markdown-body ol,.markdown-body ul{padding-left:32px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px;list-style:inherit}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol{counter-reset:my-counter}.markdown-body ol&gt;li{padding-left:6px;list-style:none;counter-increment:my-counter;position:relative}.markdown-body ol&gt;li:before{position:absolute;left:-1.5em;content:counter(my-counter);font-weight:700}.markdown-body ol&gt;li:first-child:before{content:"1️⃣"}.markdown-body ol&gt;li:nth-child(2):before{content:"2️⃣"}.markdown-body ol&gt;li:nth-child(3):before{content:"3️⃣"}.markdown-body ol&gt;li:nth-child(4):before{content:"4️⃣"}.markdown-body ol&gt;li:nth-child(5):before{content:"5️⃣"}.markdown-body ol&gt;li:nth-child(6):before{content:"6️⃣"}.markdown-body ol&gt;li:nth-child(7):before{content:"7️⃣"}.markdown-body ol&gt;li:nth-child(8):before{content:"8️⃣"}.markdown-body ol&gt;li:nth-child(9):before{content:"9️⃣"}.markdown-body ol&gt;li:nth-child(10):before{content:"🔟"}.markdown-body ul&gt;li{list-style:none;position:relative}.markdown-body ul&gt;li:before{z-index:10;position:absolute;left:-1.57em;content:"🔹";margin-right:12px}.markdown-body ul&gt;li input{margin-left:8px!important}.markdown-body blockquote{position:relative;background-color:#d3d3d3;padding:5px 10px;border-left:.2em solid #000;border-radius:3px;transition:all .8s ease}.markdown-body blockquote:hover{opacity:.7}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(69,69,77,.8);color:#fff;font-size:.87em;padding:.07em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:7px;overflow:hidden}.markdown-body pre:before{z-index:10;position:absolute;top:14px;left:14px;width:12px;height:12px;border-radius:50%;background:#fc625d;-webkit-box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;content:" "}.markdown-body pre:after{z-index:9;content:"";position:absolute;width:100%;height:40px;top:0;background-color:#1a1a1a}.markdown-body pre&gt;code{display:block;font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#171717;color:#bababa;font-size:14px;padding:40px 20px 20px}.markdown-body del{color:grey}.markdown-body table{margin-bottom:1.25rem;border-collapse:collapse}.markdown-body table td,.markdown-body table th{margin:0;padding:8px;line-height:20px;vertical-align:middle;border:1px solid #ddd}.markdown-body table thead,.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table thead th,.markdown-body table tr:nth-child(2n) th{font-weight:700;vertical-align:middle;color:#444}.markdown-body table tbody tr td{font-weight:400;color:#444}.markdown-body table tbody tr:hover{background-color:#d3d3d3}.markdown-body table tbody tr:hover td{color:#fff}.markdown-body img{max-width:100%;margin:0 12px}@media (max-width:720px){.markdown-body h1{font-size:32.8px}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:19.2px}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:12.8px}}</style><style data-highlight="" data-highlight-key="hybrid">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1d1f21}.hljs::selection,.hljs span::selection{background:#373b41}.hljs::-moz-selection,.hljs span::-moz-selection{background:#373b41}.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#c5c8c6}.hljs-name,.hljs-title{color:#f0c674}.hljs-comment,.hljs-meta,.hljs-meta .hljs-keyword{color:#707880}.hljs-deletion,.hljs-link,.hljs-literal,.hljs-number,.hljs-symbol{color:#c66}.hljs-addition,.hljs-doctag,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string{color:#b5bd68}.hljs-attribute,.hljs-code,.hljs-selector-id{color:#b294bb}.hljs-bullet,.hljs-keyword,.hljs-selector-tag,.hljs-tag{color:#81a2be}.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-variable{color:#8abeb7}.hljs-built_in,.hljs-builtin-name,.hljs-quote,.hljs-section,.hljs-selector-class,.hljs-type{color:#de935f}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在移动设备普及的今天，我们访问同一个网页时，可能会在手机、平板、笔记本电脑等不同尺寸的设备上获得截然不同的浏览体验。这背后离不开两个关键技术：响应式Web设计和viewport可视区域控制。本文将深入探讨这两个概念，帮助你构建真正适配多设备的现代网页。</p>
<h2 data-id="heading-0">响应式Web设计</h2>
<p>响应式Web设计(Responsive Web Design)是一种网页设计方法，使网站能够响应不同设备的屏幕尺寸、方向和分辨率，自动调整布局和内容呈现方式，以提供最佳的用户体验。</p>
<h2 data-id="heading-1">Viewport：网页的可视区域</h2>
<h3 data-id="heading-2">概念</h3>
<p>Viewport（视口）是指用户在网页上可见的区域。在桌面浏览器中，viewport就是浏览器窗口的可见区域。但在移动设备上，情况就复杂得多。</p>
<h3 data-id="heading-3">移动设备分类</h3>
<ul>
<li>布局viewport：网页实际渲染的区域</li>
<li>可视viewport：用户在屏幕上看到的区域</li>
</ul>
<h2 data-id="heading-4">！！注意：</h2>
<p>在没有设置viewport的情况下，移动浏览器会默认使用一个较宽的布局viewport（通常约980px），然后将整个网页缩放至屏幕宽度，导致文字过小，用户需要缩放才能阅读。</p>
<h2 data-id="heading-5">Viewport元标签</h2>
<p>为了解决移动设备上的显示问题，我们需要使用viewport元标签：</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Viewport示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-6">Viewport属性详解</h2>
<p>viewport元标签的<code>content</code>属性可以包含多个值，用逗号分隔：</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span>
</code></pre>
<h2 data-id="heading-7">常用属性说明</h2>























































<table><thead><tr><th>属性</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td><code>width</code></td><td><code>device-width</code></td><td>设备宽度（推荐）</td></tr><tr><td/><td>具体像素值</td><td>如 <code>width</code>=600</td></tr><tr><td><code>height</code></td><td><code>device-height</code></td><td>设备高度</td></tr><tr><td/><td>具体像素值</td><td>设置布局视口的高度（很少使用）</td></tr><tr><td><code>initial-scale</code></td><td>数值</td><td>初始缩放比例，通常设为 1.0</td></tr><tr><td><code>minimum-scale </code></td><td>数值</td><td>允许的最小缩放比例</td></tr><tr><td><code>maximum-scale</code></td><td>数值</td><td>允许的最大缩放比例</td></tr><tr><td><code> user-scalable</code></td><td><code>yes</code></td><td>允许缩放</td></tr><tr><td/><td><code>no</code></td><td>禁止缩放</td></tr></tbody></table>
<h2 data-id="heading-8">实际应用示例</h2>
<h3 data-id="heading-9">示例1：基础Viewport设置</h3>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>基础Viewport设置<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
        }
        
        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
        }
        
        <span class="hljs-selector-tag">h1</span> {
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
            <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#3498db</span>;
            <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10px</span>;
        }
        
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f9f9f9</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
        }
        
        <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) {
            <span class="hljs-selector-class">.container</span> {
                <span class="hljs-attribute">max-width</span>: <span class="hljs-number">750px</span>;
                <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Viewport设置示例<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这个页面正确设置了Viewport<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在移动设备上，这个页面的文字大小合适，布局正常，无需用户缩放。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>尝试在手机和平板上查看此页面，体验正确的显示效果。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Viewport的作用<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Viewport元标签告诉浏览器如何控制页面的尺寸和缩放比例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>没有正确设置viewport的网页在移动设备上会显示为缩小的桌面版本，用户需要手动缩放才能阅读内容。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>如何检测当前Viewport<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>视口宽度: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewportWidth"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>px<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>设备像素比: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"devicePixelRatio"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>屏幕宽度: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"screenWidth"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>px<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// 显示当前视口信息</span>
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'viewportWidth'</span>).<span class="hljs-property">textContent</span> = 
            <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> || <span class="hljs-number">0</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-number">0</span>);
        
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'devicePixelRatio'</span>).<span class="hljs-property">textContent</span> = 
            <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;
            
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'screenWidth'</span>).<span class="hljs-property">textContent</span> = 
            screen.<span class="hljs-property">width</span>;
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-10">示例2：Viewport设置对比</h3>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 这个页面故意不设置viewport，用于展示问题 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>无Viewport设置的问题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">980px</span>; <span class="hljs-comment">/* 模拟桌面版网站宽度 */</span>
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
        }
        
        <span class="hljs-selector-tag">h1</span> {
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
        }
        
        <span class="hljs-selector-tag">p</span> {
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;
        }
        
        <span class="hljs-selector-class">.warning</span> {
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff3cd</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ffeaa7</span>;
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#856404</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"warning"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>注意：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>这个页面没有设置viewport，在移动设备上会显示为缩小的桌面版本。
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>未设置Viewport的网页示例<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个页面模拟了没有设置viewport的桌面版网站。在移动设备上查看时，你会发现：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>整个页面被缩小以适应屏幕宽度<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>文字太小，需要放大才能阅读<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>需要水平滚动才能看到全部内容<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>用户体验很差<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这就是为什么现代网页开发必须设置viewport的原因。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>如何修复这个问题？<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>只需在HTML的<span class="hljs-symbol">&amp;lt;</span>head<span class="hljs-symbol">&amp;gt;</span>部分添加以下代码：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>meta name="viewport" content="width=device-width, initial-scale=1.0"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>添加这行代码后，网页在移动设备上就会正常显示，文字大小合适，布局自适应屏幕宽度。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-11">示例3：不同Viewport设置的效果</h3>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Viewport设置比较<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        * {
            <span class="hljs-attribute">box-sizing</span>: border-box;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
        }
        
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
        }
        
        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
        }
        
        <span class="hljs-selector-tag">h1</span> {
            <span class="hljs-attribute">text-align</span>: center;
            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">30px</span>;
            <span class="hljs-attribute">color</span>: <span class="hljs-number">#2c3e50</span>;
        }
        
        <span class="hljs-selector-class">.comparison</span> {
            <span class="hljs-attribute">display</span>: flex;
            <span class="hljs-attribute">flex-wrap</span>: wrap;
            <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;
        }
        
        <span class="hljs-selector-class">.example</span> {
            <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
            <span class="hljs-attribute">min-width</span>: <span class="hljs-number">300px</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
            <span class="hljs-attribute">overflow</span>: hidden;
        }
        
        <span class="hljs-selector-class">.example-header</span> {
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#3498db</span>;
            <span class="hljs-attribute">color</span>: white;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
            <span class="hljs-attribute">text-align</span>: center;
        }
        
        <span class="hljs-selector-class">.example-content</span> {
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
        }
        
        <span class="hljs-selector-tag">code</span> {
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f8f9fa</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">6px</span>;
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Courier New'</span>, monospace;
        }
        
        <span class="hljs-selector-class">.note</span> {
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#e8f4fd</span>;
            <span class="hljs-attribute">border-left</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#3498db</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;
        }
        
        <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) {
            <span class="hljs-selector-class">.comparison</span> {
                <span class="hljs-attribute">flex-direction</span>: column;
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>不同Viewport设置的效果比较<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个页面展示了不同viewport设置对网页在移动设备上显示的影响。请尝试在移动设备上查看此页面，或使用浏览器开发者工具模拟移动设备。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"comparison"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-header"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>推荐设置<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-content"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Viewport代码：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>meta name="viewport" content="width=device-width, initial-scale=1.0"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
                    
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>效果：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>布局视口宽度等于设备宽度<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>初始缩放比例为1.0<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>允许用户手动缩放<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>适合大多数响应式网站<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-header"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-content"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Viewport代码：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>meta name="viewport" content="width=600, initial-scale=1.0"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
                    
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>效果：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>布局视口宽度固定为600px<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>在小屏幕上可能需要水平滚动<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>适合需要固定宽度的特殊场景<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-header"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>禁止缩放<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-content"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Viewport代码：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
                    
                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>效果：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>禁止用户缩放页面<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>可能影响可访问性<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>仅在某些特殊应用中使用<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>提示：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>大多数情况下，使用推荐的设置即可：<span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>meta name="viewport" content="width=device-width, initial-scale=1.0"<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-12">总结</h2>
<ul>
<li>Viewport元标签控制网页在移动设备上的布局视口和缩放行为</li>
<li>没有正确设置viewport的网页在移动设备上体验很差</li>
<li>大多数情况下，使用<code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>是最佳选择</li>
<li>谨慎限制用户缩放功能，以免影响可访问性</li>
<li>Viewport设置需要与实际内容和响应式设计结合使用</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[只有前端 Leader 才会告诉你：那些年踩过的模块加载失败的坑]]></title>    <link>https://juejin.cn/post/7572524368876126243</link>    <guid>https://juejin.cn/post/7572524368876126243</guid>    <pubDate>2025-11-15T05:28:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572524368876126243" data-draft-id="7572453554331156480" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="只有前端 Leader 才会告诉你：那些年踩过的模块加载失败的坑"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-15T05:28:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            只有前端 Leader 才会告诉你：那些年踩过的模块加载失败的坑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T05:28:19.000Z" title="Sat Nov 15 2025 05:28:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端部署后模块加载 404：从崩溃到自动恢复的解决方案</h2>
<h3 data-id="heading-1">测试时发现的诡异问题</h3>
<p>最近在开发一个新项目，用的 Vite + React 技术栈，开发体验挺不错。测试阶段却发现了一个诡异的问题。</p>
<p>测试同学反馈：点击某个功能模块时，页面直接白屏了。打开控制台一看：</p>
<pre><code class="hljs language-sql" lang="sql">Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">fetch</span> dynamically imported <span class="hljs-keyword">module</span>: <span class="hljs-operator">/</span>assets<span class="hljs-operator">/</span>chat<span class="hljs-operator">-</span>abc123.js
<span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>assets<span class="hljs-operator">/</span>chat<span class="hljs-operator">-</span>abc123.js <span class="hljs-number">404</span> <span class="hljs-keyword">Not</span> Found
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1f1758465da4b53bad010364c3529ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmf5peg6aOO6Zuo5Lmf6Zu-5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763789391&amp;x-signature=b9w2P5lUov1SZRjP6KDepf0XAkg%3D" alt="image.png" loading="lazy"/></p>
<p>用户刷新页面就又好了。但问题是——用户不该看到这个错误页面。</p>
<p>几个疑问立刻冒出来：</p>
<ul>
<li>为啥好端端的 JS 文件会 404？</li>
<li>为啥用户刷新就好了？</li>
<li>这问题是偶发还是必现？</li>
<li>怎么让用户无感知地解决这个问题？</li>
</ul>
<h3 data-id="heading-2">问题复盘：为什么会 404？</h3>
<p>捋了下时间线，问题原因就清晰了：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant U as 用户浏览器
    participant S as 服务器
    participant CI as CI/CD

    U-&gt;&gt;S: 10:00 打开页面
    S-&gt;&gt;U: 返回 index.html (引用 chat.abc123.js)
    Note over U: 用户保持页面打开
    
    CI-&gt;&gt;S: 14:30 部署新版本
    Note over S: chat.abc123.js → chat.def456.js
    
    U-&gt;&gt;S: 15:00 点击聊天按钮
    U-&gt;&gt;S: 请求 chat.abc123.js
    S-&gt;&gt;U: 404 Not Found ❌
    Note over U: 页面崩溃
</code></pre>
<p>说白了就是：<strong>用户浏览器里的 index.html 是旧的，但服务器上的 JS 文件已经是新的了</strong>。</p>
<p>这问题只在三个条件同时满足时才会出现：</p>
<ol>
<li>用户长时间不刷新页面（保持旧版 HTML）</li>
<li>后端部署了新版本（旧 chunk 被替换）</li>
<li>用户触发懒加载（动态 import 新模块）</li>
</ol>
<p>如果项目没用代码分割，所有 JS 都在首次加载，反而不会有这问题。但为了性能做了懒加载，结果踩了这个坑。</p>
<h3 data-id="heading-3">解决思路：自动刷新 + 兜底提示</h3>
<p>想了几种方案：</p>

























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>保留旧版本文件</strong></td><td>彻底避免 404</td><td>需要改造部署流程，清理策略复杂</td></tr><tr><td><strong>版本检测轮询</strong></td><td>可以主动通知用户</td><td>增加服务器压力，体验一般</td></tr><tr><td><strong>捕获错误自动刷新</strong></td><td>实现简单，用户无感知</td><td>需要防止无限刷新</td></tr></tbody></table>
<p>最后选了第三种——简单有效，改动最小。</p>
<p>核心逻辑很简单：</p>
<ol>
<li>检测到模块加载失败 → 自动刷新页面</li>
<li>刷新后还失败 → 显示友好错误提示</li>
<li>用 sessionStorage 防止无限刷新</li>
</ol>
<h3 data-id="heading-4">具体实现</h3>
<h4 data-id="heading-5">1. 创建错误处理工具函数</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/utils/moduleLoadErrorHandler.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RELOAD_FLAG_KEY</span> = <span class="hljs-string">'module_error_reloaded'</span>;

<span class="hljs-comment">// 检测是不是模块加载错误</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isModuleLoadError</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">const</span> message = <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">'string'</span> ? error : error.<span class="hljs-property">message</span> || <span class="hljs-string">''</span>;
  
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// 各种模块加载错误的特征</span>
    message.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'Failed to fetch dynamically imported module'</span>) ||
    message.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'Loading chunk'</span>) ||
    message.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'ChunkLoadError'</span>)
  );
}

<span class="hljs-comment">// 尝试自动刷新（只刷一次）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptModuleErrorReload</span>(<span class="hljs-params"/>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-comment">// 已经刷过了？那就别再刷了</span>
  <span class="hljs-keyword">if</span> (sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-variable constant_">RELOAD_FLAG_KEY</span>)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'❌ 模块加载持续失败，请手动强刷 (Ctrl+F5)'</span>);
    sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-variable constant_">RELOAD_FLAG_KEY</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// 标记一下，防止无限刷新</span>
  sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-variable constant_">RELOAD_FLAG_KEY</span>, <span class="hljs-string">'1'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'⚠️ 检测到模块加载失败，自动刷新页面...'</span>);
  
  <span class="hljs-comment">// 稍微延迟一下，避免页面闪烁</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>(), <span class="hljs-number">100</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">// 全局监听（兜底机制）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setupModuleLoadErrorHandler</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">event: ErrorEvent</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isModuleLoadError</span>(event.<span class="hljs-property">message</span> || <span class="hljs-string">''</span>)) {
      <span class="hljs-title function_">attemptModuleErrorReload</span>();
    }
  });

  <span class="hljs-comment">// 页面正常加载完，清除标记</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
    sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-variable constant_">RELOAD_FLAG_KEY</span>);
  });
}
</code></pre>
<p>关键点：</p>
<ul>
<li><code>sessionStorage</code> 存活期刚好是一个会话，关闭标签页就清除</li>
<li>延迟 100ms 刷新，避免用户看到闪烁</li>
<li>刷新失败后给出明确的手动操作提示</li>
</ul>
<h4 data-id="heading-6">2. 在 ErrorBoundary 中处理</h4>
<p>React 项目一般都有 ErrorBoundary，正好在这里统一处理：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// src/components/ErrorBoundary/index.tsx</span>

<span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, errorInfo: ErrorInfo</span>) {
  <span class="hljs-comment">// 模块加载错误？自动刷新试试</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isModuleLoadError</span>(error)) {
    <span class="hljs-title function_">attemptModuleErrorReload</span>();
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 页面马上刷新，不显示错误界面</span>
  }

  <span class="hljs-comment">// 其他错误正常显示</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ error, errorInfo });
}
</code></pre>
<h4 data-id="heading-7">3. 应用入口初始化</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main.tsx</span>
<span class="hljs-keyword">import</span> { setupModuleLoadErrorHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils/moduleLoadErrorHandler'</span>;

<span class="hljs-comment">// 尽早初始化，捕获所有错误</span>
<span class="hljs-title function_">setupModuleLoadErrorHandler</span>();
</code></pre>
<h3 data-id="heading-8">测试验证：模拟真实场景</h3>
<h4 data-id="heading-9">方法一：Chrome DevTools 拦截请求（最简单）</h4>
<p>这个方法不用改代码，直接在浏览器里模拟：</p>
<ol>
<li>打开 DevTools，切到 Network 标签</li>
<li>右上角三个点 → More tools → Request blocking</li>
<li>添加拦截规则：<code>*page/chat*</code> 或 <code>*chunk*</code></li>
<li>切换路由触发懒加载</li>
</ol>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[添加拦截规则] --&gt; B[触发懒加载]
    B --&gt; C{首次失败?}
    C --&gt;|是| D[自动刷新页面]
    C --&gt;|否| E[显示错误提示]
    D --&gt; F[刷新后重试]
    F --&gt; E
</code></pre>
<p>看到页面自动刷新就说明成功了。保持拦截规则，再触发一次，应该直接显示错误界面（不会无限刷新）。</p>
<h4 data-id="heading-10">方法二：模拟真实部署</h4>
<p>更接近生产环境的测试：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 构建项目</span>
pnpm build

<span class="hljs-comment"># 2. 启动预览服务</span>
pnpm preview

<span class="hljs-comment"># 3. 打开页面，不要刷新</span>

<span class="hljs-comment"># 4. 删除某个 chunk 文件（模拟新版本部署）</span>
<span class="hljs-built_in">rm</span> dist/assets/chat-*.js

<span class="hljs-comment"># 5. 在页面中点击聊天按钮</span>
</code></pre>
<p>应该看到页面自动刷新，然后正常加载（如果文件还在的话）。</p>
<h3 data-id="heading-11">上线后的效果</h3>
<p>部署这个方案一周了，效果挺好：</p>
<ul>
<li>用户反馈的"页面崩溃"问题消失了</li>
<li>监控显示模块加载错误减少了 95%</li>
<li>剩下 5% 是真的网络问题，有错误提示兜底</li>
</ul>
<p>唯一的小问题：用户正在填表单时如果触发了自动刷新，数据会丢失。不过这种情况很少，后续可以考虑加个表单数据缓存。</p>
<h3 data-id="heading-12">Nginx 配置：从根源预防问题</h3>
<p>前端的自动刷新是兜底，更重要的是 Nginx 配置要正确。</p>
<h4 data-id="heading-13">当前的 nginx.conf 配置</h4>
<pre><code class="hljs language-nginx" lang="nginx">server {
    listen       80;
    server_name  _;

    root   /usr/share/nginx/html;
    index  index.html;

    # 静态资源：找不到直接返回 404，不返回 index.html
    location /assets/ {
        try_files $uri =404;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # SPA 路由：HTML 完全不缓存
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }

    # gzip 压缩
    gzip on;
    gzip_types text/plain text/css application/javascript application/json application/xml image/svg+xml;
    gzip_min_length 1024;
}
</code></pre>
<h4 data-id="heading-14">配置说明</h4>
<p><strong>1. <code>/assets/</code> 路径的关键配置</strong></p>
<pre><code class="hljs language-nginx" lang="nginx">try_files $uri =404;
</code></pre>
<ul>
<li><strong>作用</strong>：chunk 文件找不到时，直接返回 404，而不是返回 index.html</li>
<li><strong>为什么重要</strong>：如果返回 HTML，浏览器会尝试把 HTML 当作 JavaScript 执行，导致 MIME type 错误</li>
<li><strong>效果</strong>：前端能正确捕获到 404 错误，触发自动刷新</li>
</ul>
<p><strong>2. index.html 不缓存</strong></p>
<pre><code class="hljs language-nginx" lang="nginx">add_header Cache-Control "no-cache, no-store, must-revalidate";
</code></pre>
<ul>
<li><strong>作用</strong>：确保用户每次访问/刷新都获取最新的 index.html</li>
<li><strong>为什么重要</strong>：新版本 HTML 会引用新的 chunk 文件名</li>
<li><strong>局限性</strong>：只对"刷新页面"有效，对"已打开的页面"无效（这就是为什么需要前端自动刷新）</li>
</ul>
<p><strong>3. 静态资源长期缓存</strong></p>
<pre><code class="hljs language-nginx" lang="nginx">expires 1y;
add_header Cache-Control "public, immutable";
</code></pre>
<ul>
<li><strong>作用</strong>：带 hash 的文件名可以永久缓存</li>
<li><strong>好处</strong>：减少带宽消耗，提升加载速度</li>
<li><strong>安全性</strong>：文件名变了就是新文件，不会有缓存问题</li>
</ul>
<h4 data-id="heading-15">为什么这样配置？</h4>
<p>这个配置实现了<strong>双层防护</strong>：</p>
<pre><code class="hljs language-erlang" lang="erlang">┌─────────────────────────────────┐
│  Nginx 层（预防 <span class="hljs-number">60</span>-<span class="hljs-number">70</span><span class="hljs-comment">%）         │</span>
│  - HTML 不缓存                   │
│  - <span class="hljs-number">404</span> 正确返回                  │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│  前端层（兜底 <span class="hljs-number">30</span>-<span class="hljs-number">40</span><span class="hljs-comment">%）           │</span>
│  - ErrorBoundary 自动刷新        │
│  - window.error 监听             │
└─────────────────────────────────┘
</code></pre>
<p><strong>Nginx 能解决的场景</strong>：</p>
<ul>
<li>✅ 用户刷新页面 → 获取最新 HTML</li>
<li>✅ 新用户访问 → 获取最新版本</li>
<li>✅ 正确的 404 响应 → 前端能捕获错误</li>
</ul>
<p><strong>Nginx 不能解决的场景</strong>：</p>
<ul>
<li>❌ 用户长时间不刷新 + 触发懒加载</li>
<li>❌ 多标签页旧版本问题</li>
</ul>
<p>这些场景就需要前端的自动刷新来兜底。</p>
<h3 data-id="heading-16">本次代码修改说明</h3>
<p>这次修复主要解决了一个关键问题：<strong>线上环境模块加载错误没有触发自动刷新</strong>。</p>
<h4 data-id="heading-17">问题原因</h4>
<p>之前只在全局监听了 <code>window.error</code> 事件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-comment">// 处理模块加载错误</span>
});
</code></pre>
<p>但 React 的 <code>ErrorBoundary</code> 会先捕获错误，导致错误无法冒泡到 <code>window.error</code>：</p>
<pre><code class="hljs language-scss" lang="scss">React<span class="hljs-selector-class">.lazy</span>() 加载失败
    ↓
ErrorBoundary<span class="hljs-selector-class">.componentDidCatch</span>() 捕获 ← 在这里被拦截！
    ↓
显示错误界面，等待用户点击
    ↓
❌ window<span class="hljs-selector-class">.error</span> 永远不会触发
    ↓
❌ 自动刷新逻辑从未执行
</code></pre>
<h4 data-id="heading-18">解决方案</h4>
<p><strong>1. 重构为可复用的工具函数</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 导出检测函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isModuleLoadError</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span>

<span class="hljs-comment">// 导出刷新函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptModuleErrorReload</span>(<span class="hljs-params"/>): <span class="hljs-built_in">boolean</span>

<span class="hljs-comment">// 保留全局监听（兜底）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setupModuleLoadErrorHandler</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span>
</code></pre>
<p><strong>2. 在 ErrorBoundary 中集成</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, errorInfo: ErrorInfo</span>) {
  <span class="hljs-comment">// 检测并处理模块加载错误 - 自动刷新</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isModuleLoadError</span>(error)) {
    <span class="hljs-title function_">attemptModuleErrorReload</span>();
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不显示错误UI，页面即将刷新</span>
  }

  <span class="hljs-comment">// 其他错误正常处理</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ error, errorInfo });
}
</code></pre>
<h4 data-id="heading-19">修改效果</h4>
<p>现在有了<strong>双层防护</strong>：</p>
<ol>
<li><strong>ErrorBoundary（第一道防线）</strong> - 捕获 React 组件错误，快速响应</li>
<li><strong>window.error（兜底）</strong> - 捕获其他未处理的错误</li>
</ol>
<p>无论错误从哪里来，都能被正确处理并自动刷新。</p>
<hr/>
<h4 data-id="heading-20">参考资源</h4>
<ol>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fvitejs.dev%2Fguide%2Fbuild.html" target="_blank" title="https://vitejs.dev/guide/build.html" ref="nofollow noopener noreferrer">Vite 文档 - 构建生产版本</a></strong> - 关于 chunk 分割的配置</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fimport" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" ref="nofollow noopener noreferrer">MDN - Dynamic import()</a></strong> - 动态导入的原理</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Freact.dev%2Freference%2Freact%2FComponent%23catching-rendering-errors-with-an-error-boundary" target="_blank" title="https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary" ref="nofollow noopener noreferrer">React Error Boundaries</a></strong> - 错误边界的使用</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🍵 Go Queryx 入门指南：让数据库操作像喝奶茶一样丝滑！]]></title>    <link>https://juejin.cn/post/7572466174224482330</link>    <guid>https://juejin.cn/post/7572466174224482330</guid>    <pubDate>2025-11-15T04:08:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572466174224482330" data-draft-id="7569825640852799523" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🍵 Go Queryx 入门指南：让数据库操作像喝奶茶一样丝滑！"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-15T04:08:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="golang学习记"/> <meta itemprop="url" content="https://juejin.cn/user/4371313964100990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🍵 Go Queryx 入门指南：让数据库操作像喝奶茶一样丝滑！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4371313964100990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    golang学习记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:08:48.000Z" title="Sat Nov 15 2025 04:08:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎬 前言：为什么是 Queryx？—— 因为 bug 等不及你「运行时才发现」</h2>
<p>想象一下这些经典场景：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 🚨 GORM 的“惊喜盲盒”</span>
db.Where(<span class="hljs-string">"nmae = ?"</span>, <span class="hljs-string">"john"</span>).Find(&amp;users) <span class="hljs-comment">// 拼写错误？编译器：没问题 👌  </span>
<span class="hljs-comment">// → 运行时：查不到数据？🤔 调试 2 小时：哦，`nmae` 少了个 `e` ……</span>

<span class="hljs-comment">// 🧨 原生 SQL 的“类型彩票”</span>
rows, _ := db.Query(<span class="hljs-string">"SELECT * FROM users WHERE age &gt; ?"</span>, <span class="hljs-string">"18"</span>) 
<span class="hljs-comment">// 字符串传数字？MySQL：我先 convert 一下～（可能报错，也可能静默截断！）</span>
</code></pre>
<blockquote>
<p>💡 <strong>Queryx 的承诺</strong>：<br/>
<em>“你写的每一个字段、每一条条件，都经过 Go 编译器的‘安检门’——<br/>
错别字？类型错？关联漏？—— 编译就报错，绝不拖到生产环境！”</em></p>
</blockquote>
<hr/>
<h2 data-id="heading-1">🧁 第一章：安装 Queryx —— 比泡面还快，比点外卖还省心</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方法一：一键安装（官方推荐脚本）</span>
curl -sf https://raw.githubusercontent.com/swiftcarrot/queryx/main/install.sh | sh

<span class="hljs-comment"># 方法二：Go install（适合 CI/CD）</span>
go install github.com/swiftcarrot/queryx/cmd/queryx@latest
</code></pre>
<p>✅ 安装后终端多一个 <code>queryx</code> 命令——你的 <strong>数据库自动化管家</strong> 正式上岗！🎩<br/>
（它会帮你生成代码、做迁移、检查 schema，就是不帮你写业务逻辑 😏）</p>
<hr/>
<h2 data-id="heading-2">📝 第二章：定义数据模型 —— 像写情书一样优雅</h2>
<p>创建 <code>schema.hcl</code> 文件（Queryx 的“魔法配方书”）：</p>
<pre><code class="hljs language-hcl" lang="hcl"># schema.hcl
database "db" {
  adapter = "postgresql"  # 也支持 mysql/sqlite

  config "development" {
    url = "postgres://postgres:postgres@localhost:5432/blog_dev?sslmode=disable"
  }

  config "production" {
    url = env("DATABASE_URL")  # 🛡️ 敏感信息走环境变量！
  }

  # 👉 关键一步：指定生成 Go 客户端
  generator "client-golang" {}
}

# 定义 User 模型 —— 像描述你的理想型
model "User" {
  column "name" {
    type = string
    null = false  # 不能为空，就像爱情不能将就 💖
  }

  column "email" {
    type = string
    unique = true  # 邮箱唯一，像身份证号
  }

  column "age" {
    type = integer
    null = true  # 年龄？可以是秘密～
  }

  column "created_at" {
    type = datetime
    default = "now()"  # 自动填充，真贴心！
  }
}

# Post 模型：因为用户总要发帖子
model "Post" {
  belongs_to "user" {}  # 自动加 user_id 外键！

  column "title"    { type = string }
  column "content"  { type = text }
}
</code></pre>
<blockquote>
<p>✅ <strong>HCL（HashiCorp Configuration Language）</strong> 的优势：</p>
<ul>
<li>比 YAML 不易缩进出错</li>
<li>比 JSON 支持注释 + 表达式</li>
<li>比 Go Struct 更专注 <strong>数据建模</strong>，而非实现细节</li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-3">🪄 第三章：数据库迁移 —— 像变魔术一样丝滑</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 创建数据库（如果不存在）</span>
queryx db:create

<span class="hljs-comment"># 2. 生成迁移文件（基于 schema.hcl）</span>
queryx db:migrate

<span class="hljs-comment"># 3. 应用迁移（建表 + 约束 + 索引）</span>
queryx db:migrate:up
</code></pre>
<p>🔧 运行后：</p>
<ul>
<li>自动生成 <code>migrations/</code> 目录 + 版本化 SQL</li>
<li>自动建 <code>users</code>、<code>posts</code> 表，带外键、唯一索引、默认值</li>
<li>你的双手终于从 <code>CREATE TABLE</code> 中解放了！</li>
</ul>
<blockquote>
<p>🏠 <strong>比喻时间</strong>：<br/>
你告诉管家：“我要一个两居室，主卧朝南，带智能马桶”<br/>
管家用 <code>schema.hcl</code> 记下需求 → <code>queryx db:migrate</code> → 交钥匙！✨</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">🎮 第四章：CRUD 操作 —— 比打游戏刷副本还爽！</h2>
<p>先生成 Go 代码（让 Queryx 为你打工）：</p>
<pre><code class="hljs language-bash" lang="bash">queryx g  <span class="hljs-comment"># or queryx generate</span>
<span class="hljs-comment"># → 生成 db/ 目录：含 client、models、builders、migrations...</span>
</code></pre>
<p>然后在代码中享受<strong>编译时类型安全</strong>的快乐：</p>
<h3 data-id="heading-5">4.1 🎉 创建用户：像迎接新朋友一样温暖</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"log"</span>

	<span class="hljs-string">"your-project/db"</span> <span class="hljs-comment">// ← Queryx 生成的包！</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	c, err := db.NewClient(context.Background())
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(<span class="hljs-string">"💔 连不上数据库"</span>)
	}
	<span class="hljs-keyword">defer</span> c.Close()

	<span class="hljs-comment">// ✅ 类型安全！SetName 只接受 string，SetAge 只接受 *int</span>
	newUser := c.ChangeUser().
		SetName(<span class="hljs-string">"Go语言小王子"</span>).
		SetEmail(<span class="hljs-string">"gopher@example.com"</span>).
		SetAge(db.Int(<span class="hljs-number">25</span>)) <span class="hljs-comment">// 注意：nil-safe，db.Int(nil) 表示 NULL</span>

	user, err := c.QueryUser().Create(newUser)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(<span class="hljs-string">"创建失败:"</span>, err) <span class="hljs-comment">// 可能是邮箱重复！</span>
	}

	fmt.Printf(<span class="hljs-string">"✅ 用户创建成功！ID: %d, 姓名: %s\n"</span>, user.ID, user.Name)
	<span class="hljs-comment">// 输出：ID: 1, 姓名: Go语言小王子</span>
}
</code></pre>
<blockquote>
<p>🔍 <strong>关键细节</strong>（来自 Queryx 真实设计）：</p>
<ul>
<li><code>c.ChangeUser()</code> → 返回 <strong>变更构建器</strong>（Builder Pattern）</li>
<li><code>SetAge(db.Int(25))</code>：用包装类型支持 <code>NULL</code>（<code>db.Int(nil)</code>）</li>
<li>所有 <code>SetXxx()</code> 方法：<strong>编译时报错</strong>！写错字段？Go 编译器秒拒！</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-6">4.2 🔍 查询用户：比福尔摩斯找线索还准</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 精准查找：按 ID</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUserByID</span><span class="hljs-params">(c *db.Client, id <span class="hljs-type">int64</span>)</span></span> {
	user, err := c.QueryUser().Find(id)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"🫣 用户不存在"</span>)
		<span class="hljs-keyword">return</span>
	}
	fmt.Printf(<span class="hljs-string">"👤 %s (%s, %d岁)\n"</span>, user.Name, user.Email, user.Age)
}

<span class="hljs-comment">// 条件查询：链式 API 如诗如画</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryUsers</span><span class="hljs-params">(c *db.Client)</span></span> {
	<span class="hljs-comment">// 找 18+ 用户，按创建时间倒序</span>
	adults, err := c.QueryUser().
		Where(c.User.Age.GT(<span class="hljs-number">18</span>)).           <span class="hljs-comment">// 年龄 &gt; 18</span>
		OrderBy(c.User.CreatedAt.Desc()).   <span class="hljs-comment">// 时间倒序</span>
		All()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(<span class="hljs-string">"查询翻车了"</span>)
	}

	fmt.Printf(<span class="hljs-string">"👥 共 %d 位成年用户：\n"</span>, <span class="hljs-built_in">len</span>(adults))
	<span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> adults {
		fmt.Printf(<span class="hljs-string">"• %s（%d岁）\n"</span>, u.Name, u.Age)
	}

	<span class="hljs-comment">// 邮箱精准匹配（编译时检查字段！）</span>
	user, err := c.QueryUser().
		Where(c.User.Email.EQ(<span class="hljs-string">"gopher@example.com"</span>)).
		First()
	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
		fmt.Printf(<span class="hljs-string">"📧 邮箱主人：%s\n"</span>, user.Name)
	}
}
</code></pre>
<blockquote>
<p>💡 <strong>Queryx 查询构建器三大法宝</strong>：</p>
<ol>
<li><code>c.User.Age.GT(18)</code> —— 字段路径 + 操作符（GT/LT/EQ/IN...）</li>
<li><code>OrderBy(...).Limit(...).Offset(...)</code> —— 链式组合</li>
<li><code>First()</code> / <code>All()</code> / <code>Count()</code> —— 清晰语义，告别 <code>Scan</code> 地狱</li>
</ol>
</blockquote>
<hr/>
<h3 data-id="heading-7">4.3 ✏️ 更新用户：像美颜相机一样精准</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(c *db.Client, id <span class="hljs-type">int64</span>)</span></span> {
	<span class="hljs-comment">// 先查后改（乐观锁友好）</span>
	user, err := c.QueryUser().Find(id)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// 构建更新：类型安全！</span>
	update := c.ChangeUser().
		SetName(<span class="hljs-string">"Go语言大神"</span>).
		SetAge(db.Int(<span class="hljs-number">26</span>)).
		SetEmail(<span class="hljs-string">"master@golang.com"</span>)

	err = user.Update(update)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(<span class="hljs-string">"更新失败"</span>)
	}
	fmt.Println(<span class="hljs-string">"✨ 用户信息已升级！"</span>)

	<span class="hljs-comment">// 批量更新：全公司员工 +1 岁（生日快乐🎂）</span>
	count, err := c.QueryUser().
		Where(c.User.Age.IsNotNull()). <span class="hljs-comment">// 只更新非 NULL 年龄</span>
		UpdateAll(c.ChangeUser().SetAge(c.User.Age.Add(<span class="hljs-number">1</span>)))
	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
		fmt.Printf(<span class="hljs-string">"🎉 给 %d 位同事过了生日！\n"</span>, count)
	}
}
</code></pre>
<blockquote>
<p>🌟 <strong>亮点</strong>：</p>
<ul>
<li><code>c.User.Age.Add(1)</code> → 生成 <code>age = age + 1</code>，避免竞态</li>
<li><code>UpdateAll</code> 支持表达式更新，<strong>无 N+1 问题</strong></li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-8">4.4 🗑️ 删除用户：比分手还干净利落</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(c *db.Client, id <span class="hljs-type">int64</span>)</span></span> {
	<span class="hljs-comment">// 方式1：先查后删（适合带业务逻辑校验）</span>
	user, _ := c.QueryUser().Find(id)
	<span class="hljs-keyword">if</span> user != <span class="hljs-literal">nil</span> {
		err := user.Delete() <span class="hljs-comment">// 软删除？硬删除？schema 决定！</span>
		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
			fmt.Println(<span class="hljs-string">"✅ 用户已删除"</span>)
		}
	}

	<span class="hljs-comment">// 方式2：条件批量删（高效！）</span>
	count, err := c.QueryUser().
		Where(c.User.Age.LT(<span class="hljs-number">18</span>)). <span class="hljs-comment">// 未成年</span>
		DeleteAll()
	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
		fmt.Printf(<span class="hljs-string">"👮 清理了 %d 位未成年用户\n"</span>, count)
	}
}
</code></pre>
<blockquote>
<p>⚠️ <strong>安全设计</strong>：<br/>
Queryx <strong>默认开启软删除</strong>（如有 <code>deleted_at</code> 字段），<br/>
真要硬删？需显式调用 <code>ForceDelete()</code> —— 防手抖第一道防线！</p>
</blockquote>
<hr/>
<h2 data-id="heading-9">🤝 第五章：关联查询 —— 像社交网络一样自然</h2>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 预加载帖子（1 次查询搞定，无 N+1！）</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">userWithPosts</span><span class="hljs-params">(c *db.Client, userID <span class="hljs-type">int64</span>)</span></span> {
	user, err := c.QueryUser().
		Preload(c.User.Posts). <span class="hljs-comment">// ← 关键！生成 JOIN 或 IN 查询</span>
		Find(userID)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(<span class="hljs-string">"查询失败"</span>)
	}

	fmt.Printf(<span class="hljs-string">"📝 %s 的博客：\n"</span>, user.Name)
	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> user.Posts {
		fmt.Printf(<span class="hljs-string">"• %s\n"</span>, truncate(p.Title, <span class="hljs-number">30</span>))
	}
}

<span class="hljs-comment">// 创建「用户+帖子」组合数据</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserWithPosts</span><span class="hljs-params">(c *db.Client)</span></span> {
	<span class="hljs-comment">// 1. 创建用户</span>
	user, _ := c.QueryUser().Create(
		c.ChangeUser().SetName(<span class="hljs-string">"博客达人"</span>).SetEmail(<span class="hljs-string">"blogger@go.com"</span>),
	)

	<span class="hljs-comment">// 2. 关联创建帖子（自动填 user_id！）</span>
	posts := []db.CreatePostInput{
		{Title: <span class="hljs-string">"我的第一个 Go 程序"</span>, Content: <span class="hljs-string">"Hello, Queryx!"</span>},
		{Title: <span class="hljs-string">"为什么我爱 Queryx"</span>, Content: <span class="hljs-string">"类型安全让我睡得更香～"</span>},
	}

	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> posts {
		_, _ = c.QueryPost().Create(
			c.ChangePost().
				SetTitle(p.Title).
				SetContent(p.Content).
				SetUserID(user.ID), <span class="hljs-comment">// ← 类型安全！ID 是 int64</span>
		)
	}
	fmt.Printf(<span class="hljs-string">"📚 用户 %s 发布了 2 篇博文！\n"</span>, user.Name)
}

<span class="hljs-comment">// 辅助：截断长文本</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">truncate</span><span class="hljs-params">(s <span class="hljs-type">string</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt;= n {
		<span class="hljs-keyword">return</span> s
	}
	<span class="hljs-keyword">return</span> s[:n] + <span class="hljs-string">"…"</span>
}
</code></pre>
<blockquote>
<p>✅ <strong>关联优势</strong>：</p>
<ul>
<li><code>Preload(c.User.Posts)</code> → 自动识别 <code>belongs_to</code> 关系</li>
<li>生成高效 SQL（<code>JOIN</code> 或 <code>SELECT ... WHERE id IN (...)</code>）</li>
<li>编译时检查关联路径：<code>c.User.Postxxx</code>？❌ 不存在！</li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-10">🧙 第六章：高级技巧 —— 成为 Queryx 高手</h2>
<h3 data-id="heading-11">6.1 💰 事务处理：要么全成功，要么全回滚</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferPoints</span><span class="hljs-params">(c *db.Client, fromID, toID <span class="hljs-type">int64</span>, pts <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">error</span> {
	tx, err := c.Begin(context.Background())
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	<span class="hljs-keyword">defer</span> tx.Rollback() <span class="hljs-comment">// ← 忘记这行？defer 保你平安</span>

	<span class="hljs-comment">// 扣款方</span>
	from, err := tx.QueryUser().Find(fromID)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || from.Points &lt; pts {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"余额不足"</span>)
	}
	err = from.Update(c.ChangeUser().SetPoints(from.Points - pts))
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}

	<span class="hljs-comment">// 收款方</span>
	to, err := tx.QueryUser().Find(toID)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	err = to.Update(c.ChangeUser().SetPoints(to.Points + pts))
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}

	<span class="hljs-keyword">return</span> tx.Commit() <span class="hljs-comment">// 🎯 提交！资金到位！</span>
}
</code></pre>
<blockquote>
<p>🔐 事务中所有操作走 <code>tx.QueryUser()</code>，非 <code>c.QueryUser()</code> —— Queryx 强制你区分！</p>
</blockquote>
<hr/>
<h3 data-id="heading-12">6.2 📊 复杂查询：像搭乐高一样组合</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">userStats</span><span class="hljs-params">(c *db.Client)</span></span> {
	<span class="hljs-comment">// 统计：COUNT + 条件</span>
	total, _ := c.QueryUser().Count()
	adults, _ := c.QueryUser().Where(c.User.Age.GTE(<span class="hljs-number">18</span>)).Count()
	active, _ := c.QueryUser().Where(c.User.LastLogin.GT(time.Now().Add(<span class="hljs-number">-30</span>*<span class="hljs-number">24</span>*time.Hour))).Count()

	fmt.Printf(<span class="hljs-string">`📊 用户大盘：
   总用户    : %d
   成年用户  : %d
   近30天活跃: %d
`</span>, total, adults, active)
}

<span class="hljs-comment">// 分组统计：年龄分布</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ageDistribution</span><span class="hljs-params">(c *db.Client)</span></span> {
	<span class="hljs-keyword">var</span> results []<span class="hljs-keyword">struct</span> {
		AgeRange <span class="hljs-type">string</span> <span class="hljs-string">`db:"age_range"`</span>
		Count    <span class="hljs-type">int</span>    <span class="hljs-string">`db:"count"`</span>
	}

	<span class="hljs-comment">// Queryx 支持 Raw SQL 片段（紧急时的“创可贴”）</span>
	err := c.QueryRaw(<span class="hljs-string">`
		SELECT 
			CASE 
				WHEN age &lt; 18 THEN '未成年'
				WHEN age BETWEEN 18 AND 35 THEN '青壮年'
				ELSE '资深青年'
			END AS age_range,
			COUNT(*) AS count
		FROM users 
		WHERE age IS NOT NULL
		GROUP BY age_range
	`</span>).Scan(&amp;results)
	<span class="hljs-comment">// ...</span>
}
</code></pre>
<blockquote>
<p>✅ 原则：</p>
<ul>
<li>95% 场景用类型安全 Builder</li>
<li>5% 高级 SQL 用 <code>QueryRaw()</code>，但参数仍走 <code>?</code> 占位防注入</li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-13">⚖️ 第七章：Queryx vs 其他方案 —— 谁才是你的真命天“库”？</h2>















































<table><thead><tr><th>特性</th><th>Queryx ✅</th><th>GORM 🟡</th><th>原生 SQL ❌</th></tr></thead><tbody><tr><td><strong>类型安全</strong></td><td>✅ 编译时报错</td><td>❌ 运行时才发现</td><td>❌ 全靠人眼</td></tr><tr><td><strong>性能</strong></td><td>✅ 零反射，预生成代码</td><td>🟡 反射开销（中小项目可忍）</td><td>✅ 最快</td></tr><tr><td><strong>开发体验</strong></td><td>✅ IDE 自动补全 + 跳转</td><td>✅ 功能丰富</td><td>❌ 易错、难维护</td></tr><tr><td><strong>学习曲线</strong></td><td>✅ 1 0分钟上手</td><td>🟡 需理解 Scopes/Hooks</td><td>✅ 会 SQL 就行</td></tr><tr><td><strong>关联查询</strong></td><td>✅ <code>Preload()</code> 防 N+1</td><td>✅ <code>.Preload()</code></td><td>❌ 手写 JOIN 易出错</td></tr><tr><td><strong>迁移管理</strong></td><td>✅ <code>queryx db:migrate</code></td><td>✅ <code>AutoMigrate()</code></td><td>❌ 手动维护</td></tr></tbody></table>
<blockquote>
<p>🎯 <strong>选型建议</strong>：</p>
<ul>
<li>想<strong>掌控 SQL、讨厌魔法、追求轻量高效</strong> → <strong>Queryx</strong></li>
<li>团队已重度依赖 GORM、需快速 CRUD → <strong>GORM</strong></li>
<li>做<strong>超高性能场景、复杂报表</strong> → <strong>原生 SQL + queryx.QueryRaw()</strong></li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-14">🎁 结语：用 Queryx 的一天，是安心写代码的一天</h2>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 用 Queryx 的幸福时刻 👇</span>
user, err := c.QueryUser().
	Where(c.User.Email.EQ(<span class="hljs-string">"happy@coder.com"</span>)).
	Preload(c.User.Posts).
	First()

<span class="hljs-comment">// 而不是：</span>
<span class="hljs-comment">// 🤯 "为什么字段是空的？哦，struct tag 写错了..."</span>
<span class="hljs-comment">// 🤯 "为什么报错？哦，SQL 拼错了关键字..."</span>
<span class="hljs-comment">// 🤯 "为什么慢？哦，N+1 查询了 1000 次..."</span>
</code></pre>
<blockquote>
<p>🌈 <strong>Queryx 的哲学</strong>：<br/>
<em>“我们不 hide SQL —— 我们让 SQL 写得更安全、更快乐、更 Go。”</em></p>
</blockquote>
<hr/>
<h3 data-id="heading-15">🚀 现在就试试吧！</h3>
<ol>
<li>
<p><code>go install github.com/swiftcarrot/queryx/cmd/queryx@latest</code></p>
</li>
<li>
<p>写 <code>schema.hcl</code></p>
</li>
<li>
<p><code>queryx db:create &amp;&amp; queryx g</code></p>
</li>
<li>
<p>感受<strong>编译时报错</strong>带来的安全感 ❤️</p>
</li>
</ol>
<hr/>
<blockquote>
<p><strong>最后一句真心话</strong>：<br/>
<em>“早用 Queryx，少 debug 2 小时；<br/>
晚用 Queryx，多加班 3 通宵。”</em></p>
</blockquote>
<p>Happy Querying! 🍵🐉<br/>
（奶茶已下单，代码正在跑～）</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文搞懂 AI 流式响应]]></title>    <link>https://juejin.cn/post/7572403510467772459</link>    <guid>https://juejin.cn/post/7572403510467772459</guid>    <pubDate>2025-11-15T04:51:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572403510467772459" data-draft-id="7572459217811144767" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文搞懂 AI 流式响应"/> <meta itemprop="keywords" content="前端,Node.js,OpenAI"/> <meta itemprop="datePublished" content="2025-11-15T04:51:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="只想写个小玩意"/> <meta itemprop="url" content="https://juejin.cn/user/923245496771783"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文搞懂 AI 流式响应
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/923245496771783/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    只想写个小玩意
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:51:42.000Z" title="Sat Nov 15 2025 04:51:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是 <code>OpenAI</code> 文档中流式响应的代码 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Fstreaming-responses%3Fapi-mode%3Dresponses%25EF%25BC%259A" target="_blank" title="https://platform.openai.com/docs/guides/streaming-responses?api-mode=responses%EF%BC%9A" ref="nofollow noopener noreferrer">platform.openai.com/docs/guides…</a></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">OpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"openai"</span>;
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>();

<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> client.<span class="hljs-property">responses</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">model</span>: <span class="hljs-string">"gpt-5"</span>,
    <span class="hljs-attr">input</span>: [
        {
            <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-attr">content</span>: <span class="hljs-string">"Say 'double bubble bath' ten times fast."</span>,
        },
    ],
    <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,
});

<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> event <span class="hljs-keyword">of</span> stream) 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event);
}
</code></pre>
<p>在我第一次看到这段代码时，有无数的疑惑出现在了我的大脑中：</p>
<ul>
<li><code>stream</code> 是什么？</li>
<li>为什么可以通过 <code>for await of</code> 来遍历？</li>
<li>这和异步有什么关系吗？</li>
<li>服务端要如何将 <code>stream</code> 一点点返回给前端？</li>
<li>前端要如何接收数据？</li>
<li>……</li>
</ul>
<p>如果你也有类似的疑问，请耐心阅读本文，相信你一定能找到答案。</p>
<p>本文的代码在这里 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangkaiwd%2Fai-stream-response%25EF%25BC%258C%25E5%25BB%25BA%25E8%25AE%25AE%25E7%25BB%2593%25E5%2590%2588%25E6%2596%2587%25E7%25AB%25A0%25E4%25B8%2580%25E8%25B5%25B7%25E9%2598%2585%25E8%25AF%25BB" target="_blank" title="https://github.com/wangkaiwd/ai-stream-response%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%BB%93%E5%90%88%E6%96%87%E7%AB%A0%E4%B8%80%E8%B5%B7%E9%98%85%E8%AF%BB" ref="nofollow noopener noreferrer">github.com/wangkaiwd/a…</a></p>
<h2 data-id="heading-0">Iterable protocol 和 Iterator protocol</h2>
<p>支持 <code>for...of</code> 循环的变量，一定要符合 <code>Iterable protocol</code> 和 <code>Iterator protocol</code></p>
<p><code>Iterable protocol</code> :</p>
<ul>
<li>变量是一个对象</li>
<li>对象必须实现 <code>[Symbol.iterator]</code> 方法</li>
<li><code>[Symbol.iterator]</code> 方法必须返回遵循 <code>Iterator protocol</code> 约定的对象</li>
</ul>
<p><code>Iterator protocol</code> :</p>
<ul>
<li>变量是一个对象</li>
<li>对象必须实现 <code>next</code> 方法</li>
<li><code>next</code> 方法要返回一个对象 <code>{ done: boolean, value: any }</code>
<ul>
<li><code>done</code> 表示迭代是否结束</li>
<li><code>value</code> 表示迭代器的返回值</li>
</ul>
</li>
</ul>
<p>下面是一个示例：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeIterableObj</span> (<span class="hljs-attr">array</span>: any[]) {
  <span class="hljs-keyword">return</span> {
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] () {
      <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> {
        next () {
          <span class="hljs-keyword">if</span> (nextIndex &lt; array.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">const</span> result = { <span class="hljs-attr">value</span>: array[nextIndex], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }
            nextIndex++
            <span class="hljs-keyword">return</span> result
          }
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> }
        },
      }
    },
  }
}

<span class="hljs-keyword">const</span> iterableObj = <span class="hljs-title function_">makeIterableObj</span>([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>])
</code></pre>
<p>可以手动循环 <code>iterableObj</code></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> iterator = iterableObj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { value, done } = iterator.<span class="hljs-title function_">next</span>()
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'value'</span>, value)
}

<span class="hljs-comment">// 输出结果</span>
<span class="hljs-comment">// value one</span>
<span class="hljs-comment">// value two</span>
</code></pre>
<p>也可以通过 <code>for...of</code> 来循环 <code>iterableObj</code> :</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 这里的 item 就是 next 方法执行后得到的 value</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iterableObj) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'item'</span>, item)
}

<span class="hljs-comment">// 输出结果</span>
<span class="hljs-comment">// item one</span>
<span class="hljs-comment">// item two</span>
</code></pre>
<h2 data-id="heading-1">Async iterable protocol 和 Async iterator protocol</h2>
<p>理解了 <code>iterable protocol</code> 和 <code>iterator protocol</code> 再来理解 <code>async iterable protocol</code> 和 <code>async iterator protocol</code> 就会容易很多。</p>
<p>异步相比于同步，有以下区别：</p>
<ul>
<li>对象必须有 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSymbol%2FasyncIterator" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator" ref="nofollow noopener noreferrer"><code>[Symbol.asyncIterator]()</code></a> 方法</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSymbol%2FasyncIterator" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator" ref="nofollow noopener noreferrer"><code>[Symbol.asyncIterator]()</code></a> 返回 <code>async iterator</code></li>
<li><code>async iterator</code> 的 <code>next</code> 方法返回 <code>Promise</code> ， <code>Promise</code> 成功时的值为 <code>{ value: any, done: boolean }</code></li>
</ul>
<p>同样的示例改为异步版本：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = (<span class="hljs-params">result: IResult</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">IResult</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(result)
    }, <span class="hljs-number">1000</span>)
  })
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeIterableObj</span> (<span class="hljs-attr">array</span>: any[]) {
  <span class="hljs-keyword">return</span> {
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>] () {
      <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> {
        next () {
          <span class="hljs-keyword">if</span> (nextIndex &lt; array.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">sleep</span>({ <span class="hljs-attr">value</span>: array[nextIndex], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> })
            nextIndex++
            <span class="hljs-keyword">return</span> promise
          }
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">sleep</span>({ <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> })
        },
      }
    },
  }
}
</code></pre>
<p>手动循环：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> asyncIterableObj = <span class="hljs-title function_">makeIterableObj</span>([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>])
<span class="hljs-keyword">const</span> iterator = asyncIterableObj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]()
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> iterator.<span class="hljs-title function_">next</span>()
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'value'</span>, value)
}
</code></pre>
<p>使用 <code>for await ... of</code> 循环</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-title function_">makeIterableObj</span>([<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>])) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'item'</span>, item)
}
</code></pre>
<p>此时再回到开篇的示例：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> client.<span class="hljs-property">responses</span>.<span class="hljs-title function_">create</span>()
</code></pre>
<p><strong><code>stream</code> 其实就是一个遵循 <code>async iterable protocol</code>  的对象</strong></p>
<h2 data-id="heading-2">可读流 ReadableStream</h2>
<p>下面是一个 <code>ReadableStream</code> 的示例：每隔 1s 向流中写入4个字符，直到字符完全写入到流中</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">let</span> mockData = <span class="hljs-string">`This is a sample string that will be streamed in chunks.`</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>: any = <span class="hljs-literal">null</span>
<span class="hljs-keyword">const</span> step = <span class="hljs-number">4</span>

<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableStream</span>({
  start (controller) {
    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> chunk = mockData.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, step)
      <span class="hljs-comment">// 删除已经写入的字符</span>
      mockData = mockData.<span class="hljs-title function_">slice</span>(step)
      <span class="hljs-keyword">if</span> (!mockData) {
        <span class="hljs-comment">// 字符处理完成后，停止写入</span>
        controller.<span class="hljs-title function_">close</span>()
        <span class="hljs-keyword">if</span> (timer) {
          <span class="hljs-built_in">clearInterval</span>(timer)
          timer = <span class="hljs-literal">null</span>
        }
      }
      <span class="hljs-comment">// 添加字符到 stream</span>
      controller.<span class="hljs-title function_">enqueue</span>(chunk)
    }, <span class="hljs-number">1000</span>)
  },
  cancel () {
    <span class="hljs-built_in">clearInterval</span>(timer)
  },
})
</code></pre>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FReadableStream" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" ref="nofollow noopener noreferrer"><code>ReadableStream</code></a> 默认实现了 <code>Symbol.asyncIterator</code> ，所以它是一个异步可迭代对象，可以使用 <code>for await ... of</code> 来循环</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> stream) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'chunk'</span>, chunk)
}
</code></pre>
<p><code>ReadableStream</code> 自己也提供了 <code>getReader</code> 方法来读取流：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">createStream</span>()
<span class="hljs-keyword">const</span> reader = stream.<span class="hljs-title function_">getReader</span>()
<span class="hljs-comment">// 循环直到 done 为 true 时结束</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>()
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'value'</span>, value)
}
</code></pre>
<p>这是 <code>mdn</code> 官方仓库中的一个示例，也可以结合一起学习：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmdn%2Fdom-examples%2Fblob%2Fmain%2Fstreams%2Fsimple-random-stream%2Findex.html" target="_blank" title="https://github.com/mdn/dom-examples/blob/main/streams/simple-random-stream/index.html" ref="nofollow noopener noreferrer">github.com/mdn/dom-exa…</a></p>
<h2 data-id="heading-3">服务端 SSE</h2>
<p>目前的 <code>AI</code> 应用服务端流式响应使用 <code>Server-Sent Events</code> 来实现，简称 <code>SSE</code> 。下面是 <code>ChatGPT</code> 网页版的响应内容：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80a788d9e386448dbd4d646eeced024b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-q5oOz5YaZ5Liq5bCP546p5oSP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763787101&amp;x-signature=PP56pu8Qid4BxlgVYl1ut2Pz%2Brs%3D" alt="" loading="lazy"/></p>
<p><code>mdn</code> 的相关介绍在这里：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FServer-sent_events%2FUsing_server-sent_events" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" ref="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></p>
<h3 data-id="heading-4">sse 示例</h3>
<p><code>MDN</code> 的示例是使用 <code>PHP</code> 实现的，代码比较难懂，我也没有找到一个可以直接运行的案例。为了方便理解，我参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F36249684%2Fsimple-way-to-implement-server-sent-events-in-node-js" target="_blank" title="https://stackoverflow.com/questions/36249684/simple-way-to-implement-server-sent-events-in-node-js" ref="nofollow noopener noreferrer">stackoverflow.com/questions/3…</a> ，使用 <code>express</code> 实现了流式响应：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">'public'</span>))

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/countdown'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-comment">// sse 响应头设置</span>
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/event-stream'</span>,
    <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'no-cache'</span>,
    <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'keep-alive'</span>,
  })
  <span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>
  timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 返回内容必须严格遵守格式</span>
      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data: '</span> + count + <span class="hljs-string">'\n\n'</span>)
      count--
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// count 小于0时，停止响应</span>
    <span class="hljs-keyword">if</span> (timer) {
      <span class="hljs-built_in">clearInterval</span>(timer)
      timer = <span class="hljs-literal">null</span>
    }
    res.<span class="hljs-title function_">end</span>()
  }, <span class="hljs-number">1000</span>)
})

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'SSE app listening on port 3000'</span>))
</code></pre>
<p>这段代码会每隔 1s 在响应中写入 <code>count</code> ，直到 <code>count &lt; 0</code> 时结束响应。</p>
<p>代码中以下内容需要注意：</p>
<ul>
<li>
<p>响应头设置： <code>'Content-Type': 'text/event-stream'</code></p>
</li>
<li>
<p>返回内容必须严格遵守格式:   <code>data:</code> + 空格 + 字符串 + 两个换行符 (<code>\n\n</code>)</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5558a1fc0ba64cac84ccaa0dbfa54c23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-q5oOz5YaZ5Liq5bCP546p5oSP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763787101&amp;x-signature=IK4kgZDZ1c76zt5Td7BJ8aS1sPs%3D" alt="" loading="lazy"/></p>
</li>
</ul>
<h3 data-id="heading-5">AI 流式响应</h3>
<p>上面我们先实现了一个简单的流式响应，现在我们把 <code>AI</code> 结合进来</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>({
  <span class="hljs-attr">apiKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">OPENAI_API_KEY</span>,
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.deepseek.com'</span>,
})

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">'public'</span>))

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/chat'</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/event-stream'</span>,
    <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'no-cache'</span>,
    <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'keep-alive'</span>,
  })
  <span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-chat'</span>,
    <span class="hljs-attr">messages</span>: [{ <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'你是谁？'</span> }],
    <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,
  })
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> stream) {
    <span class="hljs-keyword">const</span> content = chunk.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>.<span class="hljs-property">content</span>
    <span class="hljs-comment">// 注意：这里通过 JSON.stringify 来返回 JSON 字符串，更加灵活</span>
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ content })}</span>\n\n`</span>)
  }
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: [DONE]\n\n`</span>)
  res.<span class="hljs-title function_">end</span>()
})

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`
SSE app listening on port 3000
Open http://localhost:3000/sse-ai.html in your browser to access page.
`</span>))
</code></pre>
<p>有以下几点需要注意：</p>
<ol>
<li>
<p>如果使用的是 <code>OpenAI</code> 兼容的 <code>api</code> ，例如我在当前示例中使用的 <code>deepseek</code> ，要使用之前的 <code>OpenAI</code> 请求标准：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenai%2Fopenai-node%23usage%25E3%2580%2582%25E6%2596%2587%25E6%25A1%25A3%25E4%25B8%25AD%25E6%259C%2589%25E6%258F%2590%25E5%2588%25B0%25EF%25BC%258C%25E4%25BD%2586%25E6%2598%25AF%25E6%2588%2591%25E4%25B8%2580%25E5%25BC%2580%25E5%25A7%258B%25E6%25B2%25A1%25E6%259C%2589%25E4%25BB%2594%25E7%25BB%2586%25E7%259C%258B%25E6%2596%2587%25E6%25A1%25A3%25EF%25BC%258C%25E5%259B%25B0%25E6%2589%25B0%25E4%25BA%2586%25E5%25BE%2588%25E4%25B9%2585%25E3%2580%2582" target="_blank" title="https://github.com/openai/openai-node#usage%E3%80%82%E6%96%87%E6%A1%A3%E4%B8%AD%E6%9C%89%E6%8F%90%E5%88%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%B8%80%E5%BC%80%E5%A7%8B%E6%B2%A1%E6%9C%89%E4%BB%94%E7%BB%86%E7%9C%8B%E6%96%87%E6%A1%A3%EF%BC%8C%E5%9B%B0%E6%89%B0%E4%BA%86%E5%BE%88%E4%B9%85%E3%80%82" ref="nofollow noopener noreferrer">github.com/openai/open…</a> <strong>用法和传参都不一样</strong>，需要特别留意</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56cc3dc1470a432db0d816eed9e9af0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-q5oOz5YaZ5Liq5bCP546p5oSP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763787101&amp;x-signature=J4uJ%2FQ%2FUNuJeC9VkJUXy0AykAyI%3D" alt="" loading="lazy"/></p>
</li>
<li>
<p>返回内容要通过 <code>JSON.stringify</code> 来处理，方便我们给前端返回更多字段</p>
</li>
<li>
<p>结束时返回 <code>res.write(</code>data: [DONE]\n\n<code>)</code> ，方便前端使用 <code>EventSource</code> 时终止请求</p>
</li>
</ol>
<h2 data-id="heading-6">前端处理流式响应</h2>
<h3 data-id="heading-7">EventSource</h3>
<p>前端可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FServer-sent_events%2FUsing_server-sent_events" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" ref="nofollow noopener noreferrer"><code>EventSource</code></a> 来处理 <code>sse</code> 响应的内容，代码如下：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> stop = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'stop'</span>)
<span class="hljs-keyword">const</span> start = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'start'</span>)
<span class="hljs-keyword">let</span> eventSource = <span class="hljs-literal">null</span>
start.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">'/chat'</span>)
  eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
    <span class="hljs-comment">// 要手动关闭，否则会一直请求服务器</span>
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> === <span class="hljs-string">'[DONE]'</span>) {
      eventSource.<span class="hljs-title function_">close</span>()
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>)
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'log'</span>).<span class="hljs-property">innerHTML</span> += json.<span class="hljs-property">content</span>
  }
})
stop.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  eventSource.<span class="hljs-title function_">close</span>()
})
</code></pre>
<p>完整代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangkaiwd%2Fai-stream-response%2Fblob%2F7e5d1968c2018e5b6632d6eb5631d79af984e7b0%2Fapps%2Fexpress%2Fpublic%2Fsse-ai.html" target="_blank" title="https://github.com/wangkaiwd/ai-stream-response/blob/7e5d1968c2018e5b6632d6eb5631d79af984e7b0/apps/express/public/sse-ai.html" ref="nofollow noopener noreferrer">github.com/wangkaiwd/a…</a></p>
<p><strong><code>EventSource</code> 有一个细节需要注意</strong>：</p>
<p>如果没有调用 <code>eventSource.close()</code> 方法，那么<strong>请求会一直不停的发起</strong>。所以我<strong>在服务端特意在响应结束时返回 <code>data: [DONE]\n\n</code> 来让前端知道什么时候关闭 <code>eventSource</code></strong></p>
<h3 data-id="heading-8">fetch</h3>
<p>前面我们介绍了通过 <code>EventSource</code> 来处理服务端的流式响应，但其实它存在很多问题：</p>
<ul>
<li>只能发起 <code>get</code> 请求</li>
<li>请求参数只能在 <code>url</code> 中传递，但是一般要传入给 <code>AI</code> 的提示词长度可能较大，容易超过 <code>url</code> 长度的最大限制</li>
<li>无法自定义请求头来设置 <code>Authorization</code> ，给服务端传递用户 <code>token</code></li>
</ul>
<p>基于上述的这些原因，我们通常会使用 <code>fetch</code> 方法来处理服务端的流式响应。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAzure%2Ffetch-event-source" target="_blank" title="https://github.com/Azure/fetch-event-source" ref="nofollow noopener noreferrer">github.com/Azure/fetch…</a> 就是基于 <code>fetch</code> 实现的用来发起 <code>EventSource</code> 请求的开源库，下面是它的使用示例：</p>
<pre><code class="hljs language-jsx" lang="jsx">&lt;script type=<span class="hljs-string">"module"</span>&gt;
  <span class="hljs-keyword">import</span> { fetchEventSource } <span class="hljs-keyword">from</span> <span class="hljs-string">"https://esm.sh/@microsoft/fetch-event-source"</span>;

  <span class="hljs-keyword">const</span> stop = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"stop"</span>);
  <span class="hljs-keyword">const</span> start = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"start"</span>);
  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
  start.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 发起post请求</span>
    <span class="hljs-title function_">fetchEventSource</span>(<span class="hljs-string">"/chat"</span>, {
      <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
      <span class="hljs-comment">// 一点点处理服务端响应</span>
      <span class="hljs-attr">onmessage</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>;
        <span class="hljs-keyword">if</span> (data === <span class="hljs-string">"[DONE]"</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"done"</span>);
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"log"</span>).<span class="hljs-property">innerHTML</span> += json.<span class="hljs-property">content</span>;
      },
    });
  });
  stop.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    controller.<span class="hljs-title function_">abort</span>();
  });
&lt;/script&gt;
</code></pre>
<p>完整代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangkaiwd%2Fai-stream-response%2Fblob%2Fmain%2Fapps%2Fexpress%2Fpublic%2Ffetch.html" target="_blank" title="https://github.com/wangkaiwd/ai-stream-response/blob/main/apps/express/public/fetch.html" ref="nofollow noopener noreferrer">github.com/wangkaiwd/a…</a></p>
<p>这里使用的 <code>POST</code> 请求，我把服务端的示例改为了 <code>all</code> 方法来接收请求，可以同时处理 <code>GET</code> 和 <code>POST</code> 请求</p>
<p>我们也可以自己通过 <code>fetch</code> 请求来看看具体的响应内容</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/chat"</span>, {
  <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
});
</code></pre>
<p>这里的 <code>response.body</code> 就是一个 <code>ReadableStream</code> (ps: 前面的章节有介绍过<code>ReadableStream</code> ，忘记的同学可以再回去看一下 )，所以我们可以通过 <code>for await ... of</code> 或者 <code>getReader</code> 方法来拿到 <code>ReadableStream</code> 中的数据：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> textDecoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();
<span class="hljs-comment">// response.body 是可读流</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> response.<span class="hljs-property">body</span>) {
  <span class="hljs-comment">// chunk 是 Uint8Array ，通过 TextDecoder 转换为字符串</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'chunk'</span>, chunk)
  <span class="hljs-keyword">const</span> text = textDecoder.<span class="hljs-title function_">decode</span>(chunk);
  <span class="hljs-keyword">if</span> (text === <span class="hljs-string">"[DONE]"</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"done"</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'text'</span>, text)
}

<span class="hljs-comment">// 使用 getReader 方法获取数据</span>
<span class="hljs-comment">//   const reader = response.body.getReader();</span>
<span class="hljs-comment">//   while (true) {</span>
<span class="hljs-comment">//     const { done, value } = await reader.read();</span>
<span class="hljs-comment">//     if (done) {</span>
<span class="hljs-comment">//       break;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     const text = textDecoder.decode(value);</span>
<span class="hljs-comment">//     if (text === "[DONE]") {</span>
<span class="hljs-comment">//       console.log("done");</span>
<span class="hljs-comment">//       return;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     console.log('text', text)</span>
<span class="hljs-comment">//   }</span>
</code></pre>
<p>最终结果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a730cba8404d47488513f9f36e69d310~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-q5oOz5YaZ5Liq5bCP546p5oSP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763787101&amp;x-signature=WwvpHp%2BlYYENCzkxPLza2KVx9LA%3D" alt="" loading="lazy"/></p>
<p>我们拿到的是服务端返回符合 <code>SSE</code> 规范的字符串，将字符根据规则解析后，就能拿到最终的结果了。<strong>这其实就是 <code>fetch-event-source</code> 帮我们实现的逻辑</strong></p>
<h3 data-id="heading-9">踩坑</h3>
<p>我在使用 <code>fetch-event-source</code> 的过程中发现了如下问题：</p>
<p><strong>如果服务端返回的内容只包含 <code>\n</code> ，那么前端接收到的内容为空字符。在 <code>markdown</code> 渲染的场景下，会导致格式完全错乱。</strong> 下面是伪代码，方便理解</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 服务端如果返回的内容如果只包含 \n</span>
res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data: '</span> + <span class="hljs-string">'\n\n'</span> + <span class="hljs-string">'\n\n'</span>)

<span class="hljs-comment">// 前端拿到的内容为空字符串</span>
<span class="hljs-attr">onmessage</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>;
  <span class="hljs-comment">// true</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data === <span class="hljs-string">''</span>)
}
</code></pre>
<p>官方也有相关的 <code>issue</code> 一直没有修复：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAzure%2Ffetch-event-source%2Fissues%2F50" target="_blank" title="https://github.com/Azure/fetch-event-source/issues/50" ref="nofollow noopener noreferrer">github.com/Azure/fetch…</a></p>
<p>所以在使用 <code>fetch-event-source</code> 时可以通过 <code>JSON.stringify</code> 来传入 <code>json</code> 字符串，防止前端接收到空字符串</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">const</span> content = chunk.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>.<span class="hljs-property">content</span>
<span class="hljs-comment">// JSON.stringify 避免了返回内容只有 `\n` 的情况</span>
res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ content })}</span>\n\n`</span>)
</code></pre>
<h2 data-id="heading-10">结语</h2>
<p>在 <code>AI</code> 出现之前，这些知识很少有使用场景。但随着 <code>AI</code> 的快速发展，这些代码不断地出现在我眼前，也让我有了更多实践的机会。这篇文章是我在实践中的一些沉淀和总结，希望能帮到你。</p>
<h2 data-id="heading-11">参考</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23the_iterator_protocol" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol" ref="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Ffor...of" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" ref="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FReadableStream" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" ref="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmdn%2Fdom-examples%2Fblob%2Fmain%2Fstreams%2Fsimple-random-stream%2Findex.html" target="_blank" title="https://github.com/mdn/dom-examples/blob/main/streams/simple-random-stream/index.html" ref="nofollow noopener noreferrer">github.com/mdn/dom-exa…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FEventSource" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" ref="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftpiros.dev%2Fblog%2Fstreaming-llm-responses-a-deep-dive%2F" target="_blank" title="https://tpiros.dev/blog/streaming-llm-responses-a-deep-dive/" ref="nofollow noopener noreferrer">tpiros.dev/blog/stream…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[跟着ECMAScript 规范，手写数组方法之map]]></title>    <link>https://juejin.cn/post/7572455881030025225</link>    <guid>https://juejin.cn/post/7572455881030025225</guid>    <pubDate>2025-11-15T05:55:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572455881030025225" data-draft-id="7572781559749820443" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="跟着ECMAScript 规范，手写数组方法之map"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-15T05:55:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鎏金铁匠"/> <meta itemprop="url" content="https://juejin.cn/user/4097251296420188"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            跟着ECMAScript 规范，手写数组方法之map
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4097251296420188/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鎏金铁匠
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T05:55:16.000Z" title="Sat Nov 15 2025 05:55:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>不止于会用：跟着 ECMAScript 规范，手写 <code>map</code></strong></h2>
<p>开宗明义：以传入的数组，回调函数 和 <code>thisArg</code> 加工成新数组。</p>
<p><code>Array.prototype.myMap</code> 接受一个可调用的 callback 和可选的 thisArg，按从 0 到 ToLength(O.length)-1 的索引依次对传入的（类）数组元素调用 callback（参数为 currentValue, index, 原对象），把每次调用的返回值放到同一索引的新数组并返回该新数组；回调不会改变原数组，也不会为原数组中“空位”（hole）创建值。</p>
<h3 data-id="heading-1">主干</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">// 创建空数组</span>
  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-comment">// this即传入数组</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) {
    result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>));
  }

  <span class="hljs-keyword">return</span> result;
};


</code></pre>
<h3 data-id="heading-2">树枝</h3>
<p>考虑到边界的处理</p>
<h4 data-id="heading-3">处理 <code>thisArg</code></h4>
<p>如果想在回调函数里使用一个特定的 <code>this</code> 上下文</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) {
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) {
    result.<span class="hljs-title function_">push</span>(callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-keyword">return</span> result;
};

</code></pre>
<p>变化：</p>
<ol>
<li>在函数签名中接收 <code>thisArg</code> 参数。</li>
<li>调用回调时，不用 <code>callback()</code>，而是用 <code>callback.call(thisArg)</code> 来手动指定 <code>this</code>。</li>
</ol>
<h4 data-id="heading-4">处理稀疏数组</h4>
<p>原生的 <code>map</code> 会返回 <code>[2, &lt;1 empty item&gt;, 4]</code>，它会<strong>跳过空位</strong>。主干版本没有这个能力，它会把空位当成 <code>undefined</code> 来处理。</p>
<p>目标： <strong>识别并跳过空位</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">customMap</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) {
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) {
      result.<span class="hljs-title function_">push</span>(callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>));
    }
  }
  <span class="hljs-keyword">return</span> result;
};

</code></pre>
<p>变化：</p>
<ol>
<li>在循环中，访问元素前，先检查这个索引位置上是否真的有值。</li>
<li>JavaScript 的 <code>in</code> 操作符：<code>if (i in this)</code>。</li>
</ol>
<h4 data-id="heading-5">防御性编程</h4>
<ul>
<li><code>callback</code> 不是一个函数？</li>
<li>在非数组上调用（比如 <code>document.getElementsByTagName('div')</code> 这种类数组）？</li>
<li><code>this</code> 是 <code>null</code> 或 <code>undefined</code>？</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">customMap</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) {
    <span class="hljs-comment">// 修剪1：检查 callback</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'callback is not a function'</span>);
  }
    <span class="hljs-comment">// 修剪2： 包装类</span>
  <span class="hljs-keyword">const</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-comment">// 修剪3： 安全长度</span>
  <span class="hljs-keyword">const</span> len = O.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
    <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> O) {
      result.<span class="hljs-title function_">push</span>(callback.<span class="hljs-title function_">call</span>(thisArg, O[i], i, O));
    }
  }
  <span class="hljs-keyword">return</span> result;
}

</code></pre>
<p>修剪：</p>
<ol>
<li><strong>检查 <code>callback</code></strong>：在函数开头 <code>if (typeof callback !== 'function')</code>，如果不是函数就立刻报错。</li>
<li><strong>转换 <code>this</code></strong>：使用 <code>const O = Object(this)</code> 确保 <code>this</code> 总是一个对象，这样即使在字符串 <code>hello</code> 上调用，也能把它变成一个类数组对象 <code>{0: 'h', 1: 'e', ...}</code> 来处理。</li>
<li><strong>安全获取长度</strong>：使用 <code>const len = O.length &gt;&gt;&gt; 0</code> 确保长度总是一个非负整数，避免负数或奇怪值导致循环出错。</li>
</ol>
<h4 data-id="heading-6">性能优化</h4>
<ul>
<li><code>result.push()</code> 可能会有性能开销，并且无法创建稀疏数组。</li>
<li>规范中创建新数组的方式是 <code>ArraySpeciesCreate</code>，它更复杂但也更精确。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'callback is not a function'</span>);
  }
  <span class="hljs-keyword">const</span> O = <span class="hljs-title class_">Object</span>(<span class="hljs-variable language_">this</span>);
  <span class="hljs-keyword">const</span> len = O.<span class="hljs-property">length</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 修剪：预分配新数组</span>
  <span class="hljs-keyword">const</span> A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len);
  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 修剪：使用 while 循环</span>
  <span class="hljs-keyword">while</span> (k &lt; len) {
    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) {
      <span class="hljs-keyword">const</span> kValue = O[k];
      <span class="hljs-keyword">const</span> mappedValue = callback.<span class="hljs-title function_">call</span>(thisArg, kValue, k, O);
      <span class="hljs-comment">// 修剪：直接赋值</span>
      A[k] = mappedValue;
    }
    k++;
  }
  <span class="hljs-keyword">return</span> A;
};

<span class="hljs-comment">// 1. 基本功能测试</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">myMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>)); <span class="hljs-comment">// [2, 4, 6]</span>

<span class="hljs-comment">// 2. 稀疏数组测试</span>
<span class="hljs-keyword">const</span> sparse = [<span class="hljs-number">1</span>, , <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sparse.<span class="hljs-title function_">myMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>)); <span class="hljs-comment">// [2, &lt;1 empty item&gt;, 4] (正确跳过空位)</span>

<span class="hljs-comment">// 3. thisArg 测试</span>
<span class="hljs-keyword">const</span> multiplier = { <span class="hljs-attr">factor</span>: <span class="hljs-number">10</span> };
<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">item</span>) {
  <span class="hljs-keyword">return</span> item * <span class="hljs-variable language_">this</span>.<span class="hljs-property">factor</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">myMap</span>(multiply, multiplier)); <span class="hljs-comment">// [10, 20, 30]</span>

<span class="hljs-comment">// 4. 类数组对象测试</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">// [5, 6, 7]</span>

<span class="hljs-comment">// 5. 字符串测试</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">'abc'</span>, <span class="hljs-function"><span class="hljs-params">char</span> =&gt;</span> char.<span class="hljs-title function_">toUpperCase</span>())); <span class="hljs-comment">// ['A', 'B', 'C']</span>

</code></pre>
<p>修剪：</p>
<ol>
<li><strong>预分配数组</strong>：用 <code>const A = new Array(len)</code> 提前创建好一个固定长度的数组。</li>
<li><strong>直接赋值</strong>：在循环中用 <code>A[k] = mappedValue</code> 直接赋值，而不是 <code>push</code>。这样更快，并且如果跳过某个索引，新数组也会在对应位置留下空位。</li>
<li><strong>使用 <code>while</code> 循环</strong>：规范中用的是 <code>while</code>，我们也跟着用，保持风格一致。</li>
</ol>
<h3 data-id="heading-7">收获总结</h3>
<h3 data-id="heading-8">参考</h3>
<blockquote>
<p>文档地址：ECMAScript® 2023 Language Specification - Array.prototype.map</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1voWqzGEw7%2F%3Fspm_id_from%3D333.1387.homepage.video_card.click%26vd_source%3Ddf71ce41be96fa18a0fe9dc7eec5f4e7" target="_blank" title="https://www.bilibili.com/video/BV1voWqzGEw7/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=df71ce41be96fa18a0fe9dc7eec5f4e7" ref="nofollow noopener noreferrer">【JavaScript】大厂前端面试官最爱考的JS手写题整理出来了！你能答对几道题？_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 data-id="heading-9">文档原文</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcbd466e9ecd499284fc46c9ee974c77~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Y6P6YeR6ZOB5Yyg:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763790915&amp;x-signature=vWmJa1ACmYWuSBn7zM5BJ6RcPHk%3D" alt="001_map.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/26733bfb1d524955b698d7768b15fa25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Y6P6YeR6ZOB5Yyg:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763790915&amp;x-signature=TSMzlspiKbhtnHXX%2B4vt%2FfmEQT8%3D" alt="002_map.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc6683fca2ae4916b3d2996a02a11773~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Y6P6YeR6ZOB5Yyg:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763790915&amp;x-signature=4zGNdaReEkTcsBPGX12Ij%2B%2Fepik%3D" alt="003_map.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain v1.0+ 如何构建自定义中间件来拦截和控制 Agent 执行过程]]></title>    <link>https://juejin.cn/post/7572403510467788843</link>    <guid>https://juejin.cn/post/7572403510467788843</guid>    <pubDate>2025-11-15T04:56:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572403510467788843" data-draft-id="7572465262738800659" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain v1.0+  如何构建自定义中间件来拦截和控制 Agent 执行过程"/> <meta itemprop="keywords" content="LangChain,Agent"/> <meta itemprop="datePublished" content="2025-11-15T04:56:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="世界那么哒哒"/> <meta itemprop="url" content="https://juejin.cn/user/2285242287142777"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain v1.0+  如何构建自定义中间件来拦截和控制 Agent 执行过程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2285242287142777/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    世界那么哒哒
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:56:21.000Z" title="Sat Nov 15 2025 04:56:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h3 data-id="heading-0">注：本文使用 LangChain v1.0+</h3>
<blockquote>
<p>Custom 中间件是 LangChain Agent 最强大的扩展机制，让开发者能够在 Agent 执行的任何关键点插入自定义逻辑。</p>
</blockquote>
<h2 data-id="heading-1">Custom 中间件的两种风格</h2>
<p>Custom 中间件提供两种方式来拦截和修改 Agent 行为：</p>
<h3 data-id="heading-2">1️⃣ Node-Style Hooks（节点风格）</h3>
<p>顺序执行在<strong>特定执行点</strong>，用于日志记录、验证、状态更新。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> create_agent, AgentState
<span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model, after_model
<span class="hljs-keyword">from</span> langchain.tools <span class="hljs-keyword">import</span> tool
<span class="hljs-keyword">from</span> langchain.messages <span class="hljs-keyword">import</span> AIMessage
<span class="hljs-keyword">from</span> langgraph.runtime <span class="hljs-keyword">import</span> Runtime
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict

model = ChatOpenAI(
    model=os.getenv(<span class="hljs-string">"MODEL_NAME"</span>, <span class="hljs-string">"Qwen/Qwen2-7B-Instruct"</span>),
    temperature=<span class="hljs-number">0.7</span>,
    base_url=os.getenv(<span class="hljs-string">"SILICONFLOW_BASE_URL"</span>),
    api_key=os.getenv(<span class="hljs-string">"SILICONFLOW_API_KEY"</span>)
)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    user_id: <span class="hljs-built_in">str</span>
    request_id: <span class="hljs-built_in">str</span>

<span class="hljs-comment"># ===== 钩子 1: 模型调用前 =====</span>
<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">log_request_info</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""记录请求信息（节点风格）"""</span>
    user_id = runtime.context.user_id
    msg_count = <span class="hljs-built_in">len</span>(state.get(<span class="hljs-string">"messages"</span>, []))
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📊 [用户 <span class="hljs-subst">{user_id}</span>] 即将调用模型"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   消息数量: <span class="hljs-subst">{msg_count}</span>"</span>)
    
    <span class="hljs-comment"># 不修改状态，返回 None</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ===== 钩子 2: 模型调用后 =====</span>
<span class="hljs-meta">@after_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">log_response_info</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""记录响应信息（节点风格）"""</span>
    last_msg = state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(last_msg, AIMessage):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 模型已响应，长度: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(last_msg.content)}</span>"</span>)
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ===== 创建 Agent =====</span>
agent = create_agent(
    model=model,
    tools=[],
    middleware=[log_request_info, log_response_info],
    context_schema=Context
)

result = agent.invoke(
    {<span class="hljs-string">"messages"</span>: [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>}]},
    context={<span class="hljs-string">"user_id"</span>: <span class="hljs-string">"user123"</span>, <span class="hljs-string">"request_id"</span>: <span class="hljs-string">"req_001"</span>}
)
</code></pre>
<h3 data-id="heading-3">2️⃣ Wrap-Style Hooks（环绕风格）</h3>
<p>环绕执行，<strong>你控制 handler 何时被调用</strong>。用于重试、缓存、动态修改。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model
<span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> create_agent

<span class="hljs-comment"># ===== Wrap 风格中间件：重试逻辑 =====</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_retry_middleware</span>(<span class="hljs-params">max_retries: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):
    <span class="hljs-string">"""创建重试中间件"""</span>
    
    <span class="hljs-comment"># 这里用 before_model 演示，但真实场景中应该用 wrap 风格</span>
<span class="hljs-meta">    @before_model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">retry_on_error</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># 在这个例子中，我们可以使用状态追踪重试次数</span>
        <span class="hljs-comment"># 实际的 wrap 风格需要使用特殊的装饰器</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">return</span> retry_on_error

agent = create_agent(
    model=model,
    tools=[],
    middleware=[create_retry_middleware(max_retries=<span class="hljs-number">3</span>)],
    context_schema=Context
)
</code></pre>
<p>更完整的 Wrap 风格示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model

<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_model_retry_middleware</span>(<span class="hljs-params">max_retries: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):
    <span class="hljs-string">"""
    使用状态跟踪来实现重试逻辑
    """</span>
<span class="hljs-meta">    @before_model</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_retry</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># 检查重试计数</span>
        retry_count = state.get(<span class="hljs-string">"retry_count"</span>, <span class="hljs-number">0</span>)
        
        <span class="hljs-keyword">if</span> retry_count &gt;= max_retries:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">"messages"</span>: [AIMessage(content=<span class="hljs-string">"已达到最大重试次数"</span>)],
                <span class="hljs-string">"jumpTo"</span>: <span class="hljs-string">"end"</span>  <span class="hljs-comment"># 跳到结束</span>
            }
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">return</span> handle_retry
</code></pre>
<h2 data-id="heading-4">修改状态的中间件</h2>
<p><strong>中间件可以返回一个字典来修改状态：</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict
<span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> AgentState, create_agent
<span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model, after_model
<span class="hljs-keyword">from</span> langchain.messages <span class="hljs-keyword">import</span> AIMessage
<span class="hljs-keyword">from</span> langgraph.runtime <span class="hljs-keyword">import</span> Runtime

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    user_id: <span class="hljs-built_in">str</span>

<span class="hljs-comment"># ===== 例子 1: 在模型调用前修改消息 =====</span>
<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">trim_long_messages</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""如果消息过多，删除旧消息"""</span>
    messages = state.get(<span class="hljs-string">"messages"</span>, [])
    
    <span class="hljs-comment"># 超过 100 条消息则只保留最近 50 条</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(messages) &gt; <span class="hljs-number">100</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"⚠️  消息过多 (<span class="hljs-subst">{<span class="hljs-built_in">len</span>(messages)}</span>)，正在修剪..."</span>)
        trimmed_messages = messages[-<span class="hljs-number">50</span>:]  <span class="hljs-comment"># 只保留最后 50 条</span>
        
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"messages"</span>: trimmed_messages}
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ===== 例子 2: 在模型响应后替换内容 =====</span>
<span class="hljs-meta">@after_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_sensitive_content</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""过滤敏感内容"""</span>
    last_msg = state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(last_msg, AIMessage):
        content = last_msg.content.lower()
        
        <span class="hljs-comment"># 检测敏感词</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">"password"</span> <span class="hljs-keyword">in</span> content <span class="hljs-keyword">or</span> <span class="hljs-string">"api_key"</span> <span class="hljs-keyword">in</span> content:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"🚫 检测到敏感内容，正在替换..."</span>)
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">"messages"</span>: [AIMessage(content=<span class="hljs-string">"无法显示该内容。"</span>)]
            }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

agent = create_agent(
    model=model,
    tools=[],
    middleware=[trim_long_messages, filter_sensitive_content],
    context_schema=Context
)
</code></pre>
<h2 data-id="heading-5">使用 jumpTo 控制流程</h2>
<p><strong>中间件可以用 <code>jumpTo</code> 提前结束或跳过执行：</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model

<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">rate_limit_check</span>(<span class="hljs-params">state: AgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""检查速率限制"""</span>
    msg_count = <span class="hljs-built_in">len</span>(state.get(<span class="hljs-string">"messages"</span>, []))
    
    <span class="hljs-comment"># 如果消息太多，直接返回错误并结束</span>
    <span class="hljs-keyword">if</span> msg_count &gt; <span class="hljs-number">1000</span>:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"messages"</span>: [AIMessage(content=<span class="hljs-string">"已达到请求限制"</span>)],
            <span class="hljs-string">"jumpTo"</span>: <span class="hljs-string">"end"</span>  <span class="hljs-comment"># 直接跳到 agent 结束</span>
        }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

agent = create_agent(
    model=model,
    tools=[],
    middleware=[rate_limit_check],
    context_schema=Context
)
</code></pre>
<h2 data-id="heading-6">扩展状态 Schema</h2>
<p><strong>中间件可以为 Agent 状态添加自定义字段：</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> AgentState, create_agent
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict
<span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model, after_model

<span class="hljs-comment"># 创建扩展的状态类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendedAgentState</span>(<span class="hljs-title class_ inherited__">AgentState</span>):
    <span class="hljs-string">"""扩展状态，添加自定义字段"""</span>
    call_count: <span class="hljs-built_in">int</span>  <span class="hljs-comment"># 模型调用次数</span>
    total_tokens: <span class="hljs-built_in">int</span>  <span class="hljs-comment"># 总 token 数</span>
    user_metadata: <span class="hljs-built_in">dict</span>  <span class="hljs-comment"># 用户元数据</span>

<span class="hljs-comment"># ===== 中间件追踪调用次数 =====</span>
<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">track_calls</span>(<span class="hljs-params">state: ExtendedAgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""记录模型调用次数"""</span>
    current_count = state.get(<span class="hljs-string">"call_count"</span>, <span class="hljs-number">0</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📞 这是第 <span class="hljs-subst">{current_count + <span class="hljs-number">1</span>}</span> 次模型调用"</span>)
    
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"call_count"</span>: current_count + <span class="hljs-number">1</span>}

<span class="hljs-meta">@after_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">track_tokens</span>(<span class="hljs-params">state: ExtendedAgentState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""记录 token 使用量"""</span>
    last_msg = state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>]
    
    <span class="hljs-comment"># 估算 token 数（简单方法）</span>
    token_count = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(last_msg.content).split())
    current_total = state.get(<span class="hljs-string">"total_tokens"</span>, <span class="hljs-number">0</span>)
    
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"total_tokens"</span>: current_total + token_count}

agent = create_agent(
    model=model,
    tools=[],
    middleware=[track_calls, track_tokens],
    context_schema=Context,
    state_schema=ExtendedAgentState  <span class="hljs-comment"># 使用扩展的状态</span>
)

result = agent.invoke(
    {
        <span class="hljs-string">"messages"</span>: [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你好"</span>}],
        <span class="hljs-string">"call_count"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-string">"total_tokens"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-string">"user_metadata"</span>: {<span class="hljs-string">"plan"</span>: <span class="hljs-string">"premium"</span>}
    },
    context={<span class="hljs-string">"user_id"</span>: <span class="hljs-string">"user123"</span>}
)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"最终调用次数: <span class="hljs-subst">{result[<span class="hljs-string">'call_count'</span>]}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总 token 数: <span class="hljs-subst">{result[<span class="hljs-string">'total_tokens'</span>]}</span>"</span>)
</code></pre>
<h2 data-id="heading-7">实战：完整的中间件系统</h2>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> create_agent, AgentState
<span class="hljs-keyword">from</span> langchain.agents.middleware <span class="hljs-keyword">import</span> before_model, after_model
<span class="hljs-keyword">from</span> langchain.tools <span class="hljs-keyword">import</span> tool
<span class="hljs-keyword">from</span> langchain.messages <span class="hljs-keyword">import</span> AIMessage
<span class="hljs-keyword">from</span> langgraph.runtime <span class="hljs-keyword">import</span> Runtime
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> time

model = ChatOpenAI(
    model=os.getenv(<span class="hljs-string">"MODEL_NAME"</span>, <span class="hljs-string">"Qwen/Qwen2-7B-Instruct"</span>),
    temperature=<span class="hljs-number">0.7</span>,
    base_url=os.getenv(<span class="hljs-string">"SILICONFLOW_BASE_URL"</span>),
    api_key=os.getenv(<span class="hljs-string">"SILICONFLOW_API_KEY"</span>)
)

<span class="hljs-comment"># ===== 上下文和状态 =====</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    user_id: <span class="hljs-built_in">str</span>
    user_role: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># "admin" 或 "user"</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendedState</span>(<span class="hljs-title class_ inherited__">AgentState</span>):
    call_count: <span class="hljs-built_in">int</span>
    start_time: <span class="hljs-built_in">float</span>
    execution_logs: <span class="hljs-built_in">list</span>

<span class="hljs-comment"># ===== 工具 =====</span>
<span class="hljs-meta">@tool</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">search_tool</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""搜索工具"""</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"找到关于 '<span class="hljs-subst">{query}</span>' 的 3 个结果"</span>

<span class="hljs-comment"># ===== 中间件 1: 请求验证 =====</span>
<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_request</span>(<span class="hljs-params">state: ExtendedState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""验证请求权限"""</span>
    user_role = runtime.context.get(<span class="hljs-string">"user_role"</span>, <span class="hljs-string">"user"</span>)
    
    <span class="hljs-comment"># 仅管理员可以连续发送超过 10 条消息</span>
    msg_count = <span class="hljs-built_in">len</span>(state.get(<span class="hljs-string">"messages"</span>, []))
    <span class="hljs-keyword">if</span> msg_count &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> user_role != <span class="hljs-string">"admin"</span>:
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"messages"</span>: [AIMessage(content=<span class="hljs-string">"您已达到消息限制。"</span>)],
            <span class="hljs-string">"jumpTo"</span>: <span class="hljs-string">"end"</span>
        }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ===== 中间件 2: 请求日志 =====</span>
<span class="hljs-meta">@before_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">log_request</span>(<span class="hljs-params">state: ExtendedState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""记录请求详情"""</span>
    user_id = runtime.context.user_id
    call_count = state.get(<span class="hljs-string">"call_count"</span>, <span class="hljs-number">0</span>)
    
    log_msg = <span class="hljs-string">f"[<span class="hljs-subst">{datetime.now().strftime(<span class="hljs-string">'%H:%M:%S'</span>)}</span>] 用户 <span class="hljs-subst">{user_id}</span> - 调用 #<span class="hljs-subst">{call_count + <span class="hljs-number">1</span>}</span>"</span>
    
    logs = state.get(<span class="hljs-string">"execution_logs"</span>, [])
    logs.append(log_msg)
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"call_count"</span>: call_count + <span class="hljs-number">1</span>,
        <span class="hljs-string">"execution_logs"</span>: logs
    }

<span class="hljs-comment"># ===== 中间件 3: 响应验证 =====</span>
<span class="hljs-meta">@after_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_response</span>(<span class="hljs-params">state: ExtendedState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""检查响应质量"""</span>
    last_msg = state[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(last_msg, AIMessage):
        content = last_msg.content
        
        <span class="hljs-comment"># 内容过短可能是错误</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(content) &lt; <span class="hljs-number">10</span>:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">"messages"</span>: [AIMessage(content=<span class="hljs-string">"模型响应异常，请重试。"</span>)]
            }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># ===== 中间件 4: 性能监控 =====</span>
<span class="hljs-meta">@after_model</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">monitor_performance</span>(<span class="hljs-params">state: ExtendedState, runtime: Runtime[Context]</span>) -&gt; <span class="hljs-built_in">dict</span> | <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""监控执行时间"""</span>
    start_time = state.get(<span class="hljs-string">"start_time"</span>, time.time())
    elapsed = time.time() - start_time
    
    logs = state.get(<span class="hljs-string">"execution_logs"</span>, [])
    logs.append(<span class="hljs-string">f"⏱️  耗时: <span class="hljs-subst">{elapsed:<span class="hljs-number">.2</span>f}</span>秒"</span>)
    
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"execution_logs"</span>: logs}

<span class="hljs-comment"># ===== 创建 Agent =====</span>
agent = create_agent(
    model=model,
    tools=[search_tool],
    middleware=[
        validate_request,    <span class="hljs-comment"># ① 验证权限</span>
        log_request,        <span class="hljs-comment"># ② 记录请求</span>
        validate_response,  <span class="hljs-comment"># ③ 验证响应</span>
        monitor_performance <span class="hljs-comment"># ④ 监控性能</span>
    ],
    context_schema=Context,
    state_schema=ExtendedState
)

<span class="hljs-comment"># ===== 测试 =====</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    result = agent.invoke(
        {
            <span class="hljs-string">"messages"</span>: [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"搜索 Python"</span>}],
            <span class="hljs-string">"call_count"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">"start_time"</span>: time.time(),
            <span class="hljs-string">"execution_logs"</span>: []
        },
        context={<span class="hljs-string">"user_id"</span>: <span class="hljs-string">"user_001"</span>, <span class="hljs-string">"user_role"</span>: <span class="hljs-string">"admin"</span>}
    )
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"执行日志:"</span>)
    <span class="hljs-keyword">for</span> log <span class="hljs-keyword">in</span> result.get(<span class="hljs-string">"execution_logs"</span>, []):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  <span class="hljs-subst">{log}</span>"</span>)
</code></pre>
<h2 data-id="heading-8">关键概念总结</h2>



































<table><thead><tr><th>特性</th><th>Node-Style</th><th>Wrap-Style</th></tr></thead><tbody><tr><td><strong>执行时机</strong></td><td>顺序执行在特定点</td><td>环绕执行</td></tr><tr><td><strong>用途</strong></td><td>日志、验证、更新</td><td>重试、缓存、动态选择</td></tr><tr><td><strong>控制权</strong></td><td>框架控制</td><td>你控制 handler</td></tr><tr><td><strong>钩子</strong></td><td><code>before_*</code>, <code>after_*</code></td><td><code>wrap_*</code></td></tr><tr><td><strong>返回值</strong></td><td><code>dict</code> 或 <code>None</code></td><td>直接返回结果</td></tr></tbody></table>
<blockquote>
<p>本文使用的模型服务来自硅基流动平台。新用户通过邀请链接注册可领取 <strong>2000万免费token</strong>，支持GLM-4.6、Kimi-K2-Thinking、MiniMaxAI/MiniMax-M2、DeepSeek-R2等主流大模型调用，API稳定性与响应速度俱佳。</p>
<p>专属注册链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.siliconflow.cn%2Fi%2FAvDmOKTO" title="https://link.juejin.cn?target=https%3A%2F%2Fcloud.siliconflow.cn%2Fi%2FAvDmOKTO" target="_blank">cloud.siliconflow.cn/i/AvDmOKTO</a></p>
<p>（打直球：这是我的推荐码 感谢大佬的支持）</p>
</blockquote>
<p>作者：世界那么哒哒<br/>
链接：<a href="https://juejin.cn/post/7572403510467756075" target="_blank" title="https://juejin.cn/post/7572403510467756075">juejin.cn/post/757240…</a><br/>
来源：稀土掘金<br/>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>相关文档：</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.langchain.com%2Foss%2Fpython%2Flangchain%2Fmiddleware%2Fcustom" target="_blank" title="https://docs.langchain.com/oss/python/langchain/middleware/custom" ref="nofollow noopener noreferrer">Custom Middleware 详解</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.langchain.com%2Foss%2Fpython%2Flangchain%2Fruntime" target="_blank" title="https://docs.langchain.com/oss/python/langchain/runtime" ref="nofollow noopener noreferrer">Runtime 对象</a></li>
<li>[Agents 中间件</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[部署Cloudflare免费图床——免费开源强大]]></title>    <link>https://juejin.cn/post/7572485825705230345</link>    <guid>https://juejin.cn/post/7572485825705230345</guid>    <pubDate>2025-11-15T05:36:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572485825705230345" data-draft-id="7572781559750066203" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="部署Cloudflare免费图床——免费开源强大"/> <meta itemprop="keywords" content="GitHub,开源"/> <meta itemprop="datePublished" content="2025-11-15T05:36:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="这儿有一堆花"/> <meta itemprop="url" content="https://juejin.cn/user/3076912575965819"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            部署Cloudflare免费图床——免费开源强大
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3076912575965819/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    这儿有一堆花
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T05:36:46.000Z" title="Sat Nov 15 2025 05:36:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 先说清楚：ImgNaondo 到底解决了什么问题？</h2>
<p>经常写教程、整理文档的人，很容易遇到这样一连串的小麻烦：</p>
<ul>
<li>本地截图太多，散落在各个文件夹；</li>
<li>贴到文章里要先上传第三方图床，再复制 URL；</li>
<li>某天第三方图床抽风、限流或者关站，整篇文章插图全军覆没。</li>
</ul>
<p>ImgNaondo 的目标很直接：在 Cloudflare Workers + R2 上，搭一套<strong>只为自己服务的图床</strong>，界面简单，使用门槛低，又不需要维护传统服务器。</p>
<p>项目仓库本体在 GitHub 上，可以随时查看源码和更新：</p>
<p><strong>ImgNaondo 仓库</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjovial-fortune.com%2Fb.3-VN0%2FP%2F3Np%2FvObOmBVmJvZ%2FDA0%2F2HMoD%2FQDw%2FNjDJAH3%2FL%2FTyYzwpNXD%2FA_0rM-Dtgj" target="_blank" title="https://jovial-fortune.com/b.3-VN0/P/3Np/vObOmBVmJvZ/DA0/2HMoD/QDw/NjDJAH3/L/TyYzwpNXD/A_0rM-Dtgj" ref="nofollow noopener noreferrer">github.com/xdanielf/Im…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0478753fdd5a450c8fd5734a8b5f6994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-Z5YS_5pyJ5LiA5aCG6Iqx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763789806&amp;x-signature=%2FWCAfckh4P0gX%2FB1PLg6C%2FAik1M%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-1">2. 环境准备：需要哪些账号和资源？</h2>
<p>整套方案依赖 Cloudflare 的无服务器产品组合：</p>
<ul>
<li><strong>Cloudflare 账户</strong>（用来创建 Worker 和 R2 存储桶）</li>
<li><strong>一个 R2 Bucket</strong>，用来存所有图片；</li>
<li><strong>一个 Worker 脚本</strong>，负责接收上传请求、从 R2 读取图片并输出；</li>
<li>（可选）一个自定义域名，比如 <code>img.example.com</code>。</li>
</ul>
<p>如果还没有 Cloudflare 账户，可以先注册一个，后面所有操作都会在同一控制台完成：</p>
<p><strong>Cloudflare 控制台</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjovial-fortune.com%2Fb.3-VN0%2FP%2F3Np%2FvObOmBVmJvZ%2FDA0%2F2HMoD%2FQDw%2FNjDJAH3%2FL%2FTyYzwpNXD%2FA_0rM-Dtgj" target="_blank" title="https://jovial-fortune.com/b.3-VN0/P/3Np/vObOmBVmJvZ/DA0/2HMoD/QDw/NjDJAH3/L/TyYzwpNXD/A_0rM-Dtgj" ref="nofollow noopener noreferrer">dash.cloudflare.com/</a></p>
<p>注册完成后，只要开启 R2（按量计费，小规模个人使用时成本通常比较友好），就可以继续往下走。
<strong>实际上，10GB以内的存储是免费的，单纯存图片很难用得完。</strong></p>
<hr/>
<h2 data-id="heading-2">3. 创建 R2 存储桶：给图片找一个“仓库”</h2>
<p>在控制台中打开 R2，创建一个新的 Bucket。ImgNaondo 默认约定的名字叫：</p>
<pre><code class="hljs language-text" lang="text">imgnaondo
</code></pre>
<p>当然，也可以用别的名字，只要后面在 Worker 绑定时对应起来就行。</p>
<p>在 R2 这一步，不需要设置复杂的生命周期策略，只要保证：</p>
<ul>
<li>Bucket 可以被绑定到 Worker；</li>
<li>默认私有，不对公网直接暴露（真正的出入口由 Worker 负责）。</li>
</ul>
<p>这样做的好处是：以后想换一套管理界面，或者自己写新的前端，都可以继续复用同一个 Bucket。</p>
<hr/>
<h2 data-id="heading-3">4. 部署 Worker：让脚本站在 Cloudflare 边缘节点上</h2>
<p>接下来是这套图床的“核心发动机”——Cloudflare Worker。</p>
<p>在控制台中新建一个 Worker，把默认示例代码全部删掉，替换成 ImgNaondo 仓库里的 <code>worker.js</code> 内容。为了便于理解，可以先看一个高度简化的版本，大致结构类似这样：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request, env</span>) {
    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);

    <span class="hljs-comment">// 简单的上传鉴权</span>
    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> === <span class="hljs-string">"POST"</span>) {
      <span class="hljs-keyword">const</span> token = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"x-upload-token"</span>);
      <span class="hljs-keyword">if</span> (token !== env.<span class="hljs-property">PASSWORD</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">"Unauthorized"</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">401</span> });
      }
      <span class="hljs-comment">// 这里处理上传逻辑：读取表单，写入 R2</span>
    }

    <span class="hljs-comment">// 读取图片</span>
    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> === <span class="hljs-string">"GET"</span>) {
      <span class="hljs-keyword">const</span> key = url.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/+/</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// 去掉前导 /</span>
      <span class="hljs-keyword">const</span> object = <span class="hljs-keyword">await</span> env.<span class="hljs-property">IMAGES</span>.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!object) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">"Not found"</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> });

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(object.<span class="hljs-property">body</span>, {
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">"Content-Type"</span>: object.<span class="hljs-property">httpMetadata</span>?.<span class="hljs-property">contentType</span> || <span class="hljs-string">"image/jpeg"</span>,
          <span class="hljs-string">"Cache-Control"</span>: <span class="hljs-string">"public, max-age=31536000, immutable"</span>
        }
      });
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">"Method Not Allowed"</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">405</span> });
  }
}
</code></pre>
<p>这段伪代码表达出的思路非常清晰：</p>
<ol>
<li>所有上传都必须带一个密码（<code>PASSWORD</code> 环境变量）；</li>
<li>所有读取都通过 <code>env.IMAGES.get(key)</code> 从 R2 拿文件；</li>
<li>返回时加上合理的缓存头，让图片可以在 Cloudflare 边缘节点长时间缓存。</li>
</ol>
<p>在 Worker 的“Settings → Variables”中，需要设置两个关键内容：</p>
<ul>
<li>一个名为 <code>IMAGES</code> 的 R2 Binding，指向刚才创建的 <code>imgnaondo</code> Bucket；</li>
<li>一个名为 <code>PASSWORD</code> 的环境变量，设置为自定义的上传密码。</li>
</ul>
<p>配置完成后，点一下“Save and deploy”，后端接口就已经上线了。</p>
<hr/>
<h2 data-id="heading-4">5. 绑定前端面板：从脚本变成真正可用的图床</h2>
<p>后端接口准备好之后，还差一个“人类友好”的前端面板。ImgNaondo 项目自带的那套界面，就对应读者看到的截图：</p>
<ul>
<li>顶部是深色导航栏和 Logout 按钮；</li>
<li>中间是巨大的拖拽区域，可以直接拖图片进来；</li>
<li>下方有 Custom Name 和 Tags 的输入框；</li>
<li>再往下是 Tag Cloud、搜索栏、排序方式和 Bulk Select；</li>
<li>最底部则是图片列表（刚搭好时会显示 “No images found.”）。</li>
</ul>
<p>通常的做法，是把前端构建好的静态文件直接塞进 Worker 中，通过 <code>HTML</code> 响应一起返回。一个极简路由示例如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">if</span> (url.<span class="hljs-property">pathname</span> === <span class="hljs-string">"/"</span> &amp;&amp; request.<span class="hljs-property">method</span> === <span class="hljs-string">"GET"</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-keyword">await</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"index.html"</span>), {
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/html; charset=utf-8"</span> }
  });
}
</code></pre>
<p>在实际项目里，HTML、CSS、JS 可能通过 Wrangler 或 Pages Functions 来托管，关键点是：<strong>前端只需要知道一个上传接口和一个获取列表的接口</strong>，剩下的都交给 Worker + R2 处理。</p>
<p>真正解析时只需要把 <code>img.example.com</code> 的流量指向这个 Worker 即可。</p>
<hr/>
<h2 data-id="heading-5">6. 实战操作：从拖拽上传，到在 Markdown 中插图</h2>
<p>当后台面板已经可以正常打开时，一次完整的“上传 — 获取 URL — 写文档”的流程会非常顺滑。</p>
<p>可以想象这样一个画面：一台笔记本电脑放在桌面上，屏幕里打开的是教程草稿，旁边是浏览器里的 ImgNaondo 后台。读者只要把截图从图片管理器拖到浏览器中间那块虚线框，就能看到上传进度和完成后的缩略图。</p>
<p>示意图可以用一张类似的工作场景照片来辅助理解：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1097f395ef844001913f064e43346444~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-Z5YS_5pyJ5LiA5aCG6Iqx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763789806&amp;x-signature=VXxjEFg2YB0BE3HH3zUdMmtK5%2Bs%3D" alt="ImgNaondo 使用场景示意" loading="lazy"/></p>
<p>上传完成后，后台会给出一个完整的访问链接，例如：</p>
<pre><code class="hljs language-text" lang="text">https://img.example.com/2025/11/15/terminal-latency-test.png
</code></pre>
<p>在 Markdown 文档里，只要这样插入即可：</p>
<pre><code class="hljs language-markdown" lang="markdown">![<span class="hljs-string">终端延迟测试截图</span>](<span class="hljs-link">https://img.example.com/2025/11/15/terminal-latency-test.png</span>)
</code></pre>
<p>对于经常写教程、做笔记的人来说，这种“看到就能直接复制”的体验，比一堆命令行工具要直观得多。</p>
<p>如果文章托管在 GitHub Pages 或其他静态站点上，也可以继续使用这种方式插图，例如 GitHub 官方的介绍页面：</p>
<p><strong>GitHub Pages 说明</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fjovial-fortune.com%2Fb.3-VN0%2FP%2F3Np%2FvObOmBVmJvZ%2FDA0%2F2HMoD%2FQDw%2FNjDJAH3%2FL%2FTyYzwpNXD%2FA_0rM-Dtgj" target="_blank" title="https://jovial-fortune.com/b.3-VN0/P/3Np/vObOmBVmJvZ/DA0/2HMoD/QDw/NjDJAH3/L/TyYzwpNXD/A_0rM-Dtgj" ref="nofollow noopener noreferrer">pages.github.com/</a></p>
<p>不论文章部署到哪里，只要图床域名不变、R2 不清理，对外可见的图片就会稳定存在。</p>
<hr/>
<h2 data-id="heading-6">7. 小小的安全与管理细节</h2>
<p>虽然 ImgNaondo 主要面向个人或小团队使用，但一些基础的安全和管理细节还是值得顺手做好。</p>
<p>最关键的是上传密码 <code>PASSWORD</code>。为了避免脚本被别人拿到就随意上传，可以再加一层简单的约束，例如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> allowedOrigins = [<span class="hljs-string">"https://img.example.com"</span>, <span class="hljs-string">"https://wiki.example.com"</span>];

<span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> === <span class="hljs-string">"POST"</span>) {
  <span class="hljs-keyword">const</span> origin = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"Origin"</span>);
  <span class="hljs-keyword">if</span> (!allowedOrigins.<span class="hljs-title function_">includes</span>(origin)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">"Forbidden"</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">403</span> });
  }
  <span class="hljs-comment">// 再继续密码校验和上传逻辑</span>
}
</code></pre>
<p>另外，如果图片数量会长期增长，建议时不时查看一下 R2 的容量和计费情况；必要时还可以设置生命周期规则，将非常古老、几乎不会再访问的图片迁移到更便宜的存储等级。</p>
<p>ImgNaondo 的 Tag Cloud 和搜索功能，也可以帮助管理：给每一批图片打上带项目名或主题的标签，例如 <code>blog</code>, <code>doc</code>, <code>invoice</code>，后期查找和批量整理会轻松很多。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringBoot 3.2新特性实战：这5个隐藏技巧让你的应用性能飙升50%]]></title>    <link>https://juejin.cn/post/7572714389921857576</link>    <guid>https://juejin.cn/post/7572714389921857576</guid>    <pubDate>2025-11-15T04:16:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572714389921857576" data-draft-id="7572408522438426659" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringBoot 3.2新特性实战：这5个隐藏技巧让你的应用性能飙升50%"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2025-11-15T04:16:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="IT_陈寒"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringBoot 3.2新特性实战：这5个隐藏技巧让你的应用性能飙升50%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    IT_陈寒
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:16:57.000Z" title="Sat Nov 15 2025 04:16:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>SpringBoot 3.2新特性实战：这5个隐藏技巧让你的应用性能飙升50%</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>SpringBoot 3.2作为Spring生态的最新里程碑版本，不仅继承了Spring Framework 6.1的强大功能，还引入了多项性能优化和开发效率提升的特性。尽管官方文档已经列举了主要更新，但许多隐藏的技巧和最佳实践尚未被广泛讨论。本文将深入挖掘SpringBoot 3.2的5个关键特性，结合实战案例展示如何通过这些技巧将应用性能提升50%甚至更多。</p>
<p>无论是响应式编程的增强、GraalVM原生镜像支持的优化，还是JVM调优的新选项，这些特性都能显著降低延迟、提高吞吐量。我们将从底层原理出发，逐步解析如何在实际项目中落地这些优化手段。</p>
<h2 data-id="heading-2">主体</h2>
<h3 data-id="heading-3">1. 虚拟线程（Virtual Threads）的深度集成</h3>
<p>SpringBoot 3.2全面拥抱JDK 21的虚拟线程特性，通过简单的配置即可将传统阻塞式IO模型升级为轻量级线程模型。相较于平台线程（Platform Thread），虚拟线程的上下文切换成本极低，特别适合高并发场景。</p>
<p><strong>实战技巧：</strong></p>
<pre><code class="hljs language-properties" lang="properties"># application.properties
spring.threads.virtual.enabled=true
spring.datasource.hikari.thread-factory=org.springframework.boot.task.VirtualThreadTaskExecutorBuilder
</code></pre>
<p>通过上述配置，Tomcat/Jetty等Web容器的请求处理线程池以及HikariCP的连接池都将使用虚拟线程。实测表明，在IO密集型场景下（如数据库查询或HTTP调用），吞吐量可提升30%-40%。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>需确保JDK版本≥21</li>
<li>Synchronized块会强制绑定平台线程，应改用<code>ReentrantLock</code></li>
<li>避免在虚拟线程中执行CPU密集型任务</li>
</ul>
<h3 data-id="heading-4">2. GraalVM原生镜像编译优化</h3>
<p>SpringBoot 3.2对GraalVM原生镜像的支持达到生产就绪状态，AOT（Ahead-of-Time）编译生成的二进制文件启动时间可控制在100ms以内，内存占用减少50%。新版Native Build Tools提供了更智能的反射/资源自动检测机制。</p>
<p><strong>关键配置：</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pom.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.graalvm.buildtools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>native-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">quickBuild</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">quickBuild</span>&gt;</span> <span class="hljs-comment">&lt;!-- 启用实验性快速模式 --&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">optimizationLevel</span>&gt;</span>O3<span class="hljs-tag">&lt;/<span class="hljs-name">optimizationLevel</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
</code></pre>
<p>通过<code>@NativeHint</code>注解可手动注册需要动态处理的类：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@NativeHint(
    types = @TypeHint(types = com.example.CustomClass.class),
    resources = @ResourceHint(patterns = "META-INF/resources/*")
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeConfig</span> {}
</code></pre>
<h3 data-id="heading-5">3. JDBC连接池的智能预热策略</h3>
<p>新增的<code>spring.datasource.hikari.pool-warmup</code>属性允许在应用启动时预先建立最小空闲连接数：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># application.yml</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">hikari:</span>
      <span class="hljs-attr">pool-warmup:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Warm-up connections count</span>
</code></pre>
<p>测试显示该特性可将首次数据库查询延迟从200ms降至20ms以内。结合HikariCP的<code>connectionTestQuery</code>优化，全链路响应时间P99下降15%。</p>
<h3 data-id="heading-6">4. RSocket服务端负载均衡增强</h3>
<p>对于微服务架构，SpringBoot 3.2改进了RSocket负载均衡算法（新增WeightedLoadBalanceStrategy），支持基于服务端实时指标的动态权重分配：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> RSocketRequester <span class="hljs-title function_">requester</span><span class="hljs-params">(RSocketStrategies strategies)</span> {
    <span class="hljs-keyword">return</span> RSocketRequester.builder()
           .rsocketConnector(connector -&gt; connector.loadBalancer(LoadBalancerFactory 
               .builder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedLoadBalanceStrategy</span>())
               .withHealthCheckInterval(Duration.ofSeconds(<span class="hljs-number">5</span>))
               .build()))
           .dataMimeType(MimeTypeUtils.APPLICATION_JSON)
           .tcp(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">7000</span>);
}
</code></pre>
<p>配合新版Micrometer指标导出器（支持RSocket协议），可实现亚秒级的服务实例权重调整。某电商压测案例显示该方案使错误率降低60%。</p>
<h3 data-id="heading-7">5.JVM内存布局优化与CRaC支持</h3>
<p>通过JVM参数调整对象指针压缩（OOPs）策略显著减少内存占用：</p>
<pre><code class="hljs language-bash" lang="bash">java -jar your-app.jar \
     -XX:+UseCompressedOops \
     -XX:ObjectAlignmentInBytes=16 \ <span class="hljs-comment"># SpringBoot默认为8,调整为16提升大对象访问速度</span>
     -XX:+UseZGC \
     -Xmx512m <span class="hljs-comment"># ZGC下可安全设置较低堆大小</span>
</code></pre>
<p>同时支持CRaC（Coordinated Restore at Checkpoint）技术实现亚毫秒级恢复：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RestControllerAdvice</span> 
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CracHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CRaCLifecycle</span> {

    <span class="hljs-meta">@Override</span> 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCheckpoint</span><span class="hljs-params">(Context&lt;? extends Resource&gt; context)</span> { <span class="hljs-comment">/*清理临时文件*/</span> }
    
    <span class="hljs-meta">@Override</span> 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRestore</span><span class="hljs-params">(Context&lt;? extends Resource&gt; context)</span> { <span class="hljs-comment">/*重建缓存*/</span> }
}
</code></pre>
<p>某金融系统采用该方案后冷启动时间从8秒缩短至200ms。</p>
<h2 data-id="heading-8">总结</h2>
<p>SpringBoot 3.2的性能优化空间远超表面可见的功能列表。本文揭示的五项关键技术——从虚拟线程的革命性并发模型到GraalVM原生编译的精调参数——共同构成了现代Java应用的高性能基石。实际落地时需要根据具体业务特点组合使用这些特性：</p>
<ol>
<li>IO密集型场景优先启用虚拟线程</li>
<li>Serverless环境选择GraalVM原生镜像+CRaC组合方案<br/>
3.微服务架构充分利用RSocket的动态负载均衡能力</li>
</ol>
<p>所有这些改进都遵循"零侵入"原则——无需重构核心业务代码即可获得显著收益。随着Java生态向云原生时代的持续演进，掌握这些深层次优化技巧将成为高级开发者的核心竞争力</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025年10月总结]]></title>    <link>https://juejin.cn/post/7572459217811111999</link>    <guid>https://juejin.cn/post/7572459217811111999</guid>    <pubDate>2025-11-15T04:29:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459217811111999" data-draft-id="7572405211441971243" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025年10月总结"/> <meta itemprop="keywords" content="AIGC,Coze,人工智能"/> <meta itemprop="datePublished" content="2025-11-15T04:29:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="袁庭新"/> <meta itemprop="url" content="https://juejin.cn/user/1207714136735408"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025年10月总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1207714136735408/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    袁庭新
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:29:44.000Z" title="Sat Nov 15 2025 04:29:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是袁庭新。2025年10月转瞬已逝，今天系统梳理了下10月的主要工作，在这里简要做个月总结，与各位朋友们分享下。</p>
<h2 data-id="heading-0">博客短视频创作</h2>
<p>说实话，这个月偷懒了。只写了1篇博客文章，短视频创作无。</p>
<p>我对自己的要求是，每周至少输出1篇文章，1条短视频。本月两项任务均未完成，甚至短视频还挂了零，本想找个理由欺骗下自己，这样会好受点，想来想去除了懒，真的没别的原因了。</p>
<p>明明知道时间很珍贵，还在大把大把地浪费时间。2025年只剩一个多月了，想想就可怕，感觉上周才过完的春节，2025年怎么就快没了～</p>
<h2 data-id="heading-1">市场合作伙伴</h2>
<p>今年，我公司开拓了一个新业务“人工智能技术职业技术证书认证培训”，我司向工业和信息化部教育与考试中心申报了“人工智能技术应用工程师”和“生成式人工智能技术应用工程师”两个方向的证书。同时，我是该认证的人才培养标准主要参编人。且，我司是西北地区唯一一家工信部教考中心认证授权培训单位。</p>
<p>为了开拓市场，我也会和公司的老师出去跑业务，寻找合作伙伴。这个月，新建立了6个合作伙伴，其中有以个人名义也有以公司名义和我们合作的。寻求合作伙伴并建立合作关系是困难的，首先你得让人家充分认可我们现在所做的事情，光这还不行的，关键在于人家还得愿意投入时间、精力和资源去一同做这件事。</p>
<p>我是真心愿大家合作共赢，共同富裕～</p>
<h2 data-id="heading-2">课程研发</h2>
<p>给大家汇报下这个月《人工智能应用认证培训课程》产品的研发进度。</p>
<p>其中《全面掌握LiblibAI在线AI绘画》模块已经研发完成，共计24课时，计划11月初上线。这个模块课程将全方位详细的讲解如何在LiblibAI上进行AI创作，无需代码和硬件，一键开启AI艺术创作之旅！快速从AI绘画小白进阶成创作达人，轻松落地作品直至变现。</p>
<p>很多朋友想创业，跨境电商是一个不错的选择。我们联合前字节跳动跨境电商高级运营师共同研发《AI+美客多跨境电商实战》，就是想从0到1，手把手带你玩转跨境生意。目前，已经录制18节，很快就会推上线。</p>
<p>同时，我自己也在研发一套《微信商业生态平民创业》课程，这是一套关于个人创业的商业思维课程。两年前我就在开始准备其中的内容，已经完成9节课程的录制，预计在11月底上下。我讲了8年课，大大小小能讲50多门课，但是如果只推荐一门课，那就是——《微信商业生态平民创业》。</p>
<h2 data-id="heading-3">知识星球</h2>
<p>10月份，我在「人人都要学AI」知识星球中发布了6篇聚焦AIGC领域前沿技术的主题内容。同时在「圆心学堂」Java星球里更新了8篇主题内容。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c01afabf557841c692113dc6838b0ac1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=GCkggVZWW3LWvpBGcvWwbCjrlOU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">圆心启点市场知识库</h2>
<p>为便于各合作伙伴快速了解《人工智能应用认证培训课程》产品，我们特别整理了本产品知识库。内容包含公司简介、证书介绍、课程简章、课程海报、报名表格、招生讲座、咨询话术、考试流程、练习题库等核心资料。本课程将持续优化升级，相关市场物料请以知识库最新版本为准。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/703a76e2bcf843b9a23f010b1facb890~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=6Kwof2OQlfiXrzXVmT%2BHehC9DJU%3D" alt="" loading="lazy"/></p>
<p>圆心启点市场知识库内容见下图。10月份在这个知识库的搭建上花费了巨大的时间，毫不夸张。目的就是希望我们的合作伙伴更加快速的了解我们的产品，用最快最短的时间实现合作共赢。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/deb80f4ab07747b49c843cb5a77348f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=5uqmJdjkeUszt8nEn2KbNREt1S8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">知识店铺运营</h2>
<p>这个月花了很大力气来运营店铺，先后推上线《玩转大模型提示词工程：从基础框架到高级应用的系统课程》、《利用人工智能成为学习专家：AI赋能高效学习与职场办公》、《大模型本地部署与个人知识库搭建》、《Coze扣子AI智能体与工作流开发实战》、《Lua编程实战：从基础语法到高级特性》、《Redis高性能缓存与分布式架构实战》和《人工智能应用全链路职业技能培训课程》等7门课程。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/074c8fab11364c3eba116ab6f5cad151~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=FvLqp4%2FV20ociZY1jcGgntpIqc4%3D" alt="" loading="lazy"/></p>
<p>其实，时间主要花费在了视频封面和长图海报设计上。我是不懂设计的，那咋办？不懂就学呀，还能咋办，我又没钱请别人帮我设计。当然了，我对自己设计的海报还是挺满意的，大家觉得咋样呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44deba7e1c47480aaec55d0f21a4d9bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=vHxu7HnXdYaGzOCSM6R6fsp%2Blj4%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">物料更新</h2>
<p>课程简章是非常重要的市场支持物料文件，课程内容有新的迭代了，第一时间要同步到课程简章中，同时还要考虑排版设计，总不能太丑吧，那样看上去就很low。下图是百分百由我操刀设计的简章，大家觉得咋样呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0406094c01e24b13940e6770bb525895~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=lNAjwnhMIg7RIlpJkD%2BPtIUN0D0%3D" alt="" loading="lazy"/></p>
<p>为助力高校适时调整课程体系，持续深化教学改革，指导数字技术跨学科人才培养，进一步提升教学与科研能力，将于提升教学与科研能力，我司计划年底想举办线上与线下相结合的 “AI Agent 智能体工作流与多模态应用实战能力提升师资研修班”，为高校教师做赋能培训。基于市场调研及高校教师教学的痛点问题，我制定了一份师资培养方案。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5182994c5ce84b009ac6dfb28912fc88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=XHBVIq0sQgArE2n81W5k3J%2FqBtA%3D" alt="" loading="lazy"/></p>
<p>同时，还修改了培养方案，根据专家评审意见，对部分的内容做了调整。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/769da3f3a0a344c8a3cd811b7a815b8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763785783&amp;x-signature=U4bXIbR0rVbii3gZGBGe2Cb2WUM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">老友聚会</h2>
<p>国庆节友人结婚，回了趟老家，遇到了几位十五六年未见的同学，无数个美好的瞬间浮现在眼前，学生时代恍如昨日般。这真是幸福美好的时刻，希望大家未来健康平安越来越好～</p>
<p>10月15号，在西安见了宝儿哥，初中我们是同桌，印象中高中毕业后就没见了，一晃也12年不见了。宝儿哥大学学的是美术设计，现在在一家国企上班，工作事业顺风顺水。</p>
<p>10月20号，水来西安师资培训，一块儿吃了夜宵也聊了很多，我和水是初中高中同班同学，现在在我们县城里的一个镇上的初中教书，是一位人民教师同时也是学校里的主任，前途一片光明。</p>
<h2 data-id="heading-8">运动健身</h2>
<p>这个月健身了4次，说实话有点少，但也没啥负罪感，健身这个事儿我向来对自己是“三天打鱼两天晒网”的心态，想起来就去，累了就躺着。</p>
<p>自律，咱不是没想过，也不是没行动过，关键是真做不到。我也想向网上健身博主那样，无论刮风下雨，每天健身从不间断，后来想想还是算了。</p>
<p>啰啰嗦嗦了半天，好了，今天的分享就到这里吧～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MyBatis-Plus 不只是简化CRUD！资深架构师总结的15个高阶用法]]></title>    <link>https://juejin.cn/post/7572524368876109859</link>    <guid>https://juejin.cn/post/7572524368876109859</guid>    <pubDate>2025-11-15T04:41:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572524368876109859" data-draft-id="7564921269491449871" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MyBatis-Plus 不只是简化CRUD！资深架构师总结的15个高阶用法"/> <meta itemprop="keywords" content="后端,Java,MyBatis"/> <meta itemprop="datePublished" content="2025-11-15T04:41:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MyBatis-Plus 不只是简化CRUD！资深架构师总结的15个高阶用法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T04:41:51.000Z" title="Sat Nov 15 2025 04:41:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是大华！相信Java后端开发的朋友们对<code>MyBatis-Plus（简称MP）</code>肯定不陌生，它可以让CRUD的操作瞬间起飞。</p>
<p>今天就给大家分享15个使用技巧。</p>
<h3 data-id="heading-0">1. Service 和 Mapper？</h3>
<p><strong>IService</strong>：内置了海量现成方法，<code>save</code>, <code>update</code>, <code>list</code>, <code>page</code> 等，适用于绝大多数单表 CRUD。
<strong>BaseMapper</strong>：当需要进行复杂联表查询、或者要写自定义 SQL 时，它就是你的主战场。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 简单查询，用 Service 的 lambdaQuery</span>
List&lt;User&gt; users = userService.lambdaQuery()
                .eq(User::getStatus, <span class="hljs-number">1</span>)
                .like(User::getName, <span class="hljs-string">"张"</span>)
                .list();

<span class="hljs-comment">// 复杂查询，用 Mapper + XML 或注解！</span>
<span class="hljs-comment">// 在 UserMapper.java 中</span>
<span class="hljs-meta">@Select("SELECT u.*, d.dept_name FROM user u LEFT JOIN dept d ON u.dept_id = d.id WHERE u.id = #{userId}")</span>
UserVO <span class="hljs-title function_">selectUserDetail</span><span class="hljs-params">(<span class="hljs-meta">@Param("userId")</span> Long userId)</span>;
</code></pre>
<p>别在 Service 里硬塞复杂 SQL，该写 XML 的时候还是不能偷懒。</p>
<h3 data-id="heading-1">2. Lambda 表达式</h3>
<p>MP 最棒的特性之一就是 Lambda 查询，<strong>编译期就能发现字段名错误</strong>，告别运行时才发现拼错的尴尬。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 【错误姿势】字段名是字符串，容易拼错，编译器不报错</span>
userService.lambdaQuery().eq(<span class="hljs-string">"naem"</span>, <span class="hljs-string">"张三"</span>); <span class="hljs-comment">// 运行才报错，哭死！</span>

<span class="hljs-comment">// 【正确姿势】使用方法引用，安全又优雅</span>
userService.lambdaQuery().eq(User::getName, <span class="hljs-string">"张三"</span>); 
<span class="hljs-comment">// 编译不通过，立马改正！</span>
</code></pre>
<h3 data-id="heading-2">3. 分页查询，不只是<code>PageHelper</code>的替代品</h3>
<p>MP 的分页功能非常强大，而且与自身条件构造器无缝集成。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建分页参数，并指定排序</span>
Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 查第1页，每页20条</span>
page.addOrder(OrderItem.desc(<span class="hljs-string">"create_time"</span>)); <span class="hljs-comment">// 按创建时间倒序</span>

<span class="hljs-comment">// 执行分页查询</span>
Page&lt;User&gt; userPage = userService.page(page,
        Wrappers.&lt;User&gt;lambdaQuery()
                .eq(User::getDeptId, <span class="hljs-number">2</span>)
);

<span class="hljs-comment">// 直接转换为 VO 分页对象，一步到位</span>
Page&lt;UserVO&gt; voPage = userPage.convert(user -&gt; {
    <span class="hljs-type">UserVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserVO</span>();
    BeanUtils.copyProperties(user, vo); <span class="hljs-comment">// 使用 Spring 的工具类</span>
    <span class="hljs-comment">// 或者用 MapStruct 等更专业的工具</span>
    <span class="hljs-keyword">return</span> vo;
});
</code></pre>
<h3 data-id="heading-3">4. 批量操作，性能提升的关键</h3>
<p>大批量数据插入/更新时，一条条处理会让数据库哭泣。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 批量插入，分批提交</span>
List&lt;User&gt; hugeUserList = ... <span class="hljs-comment">// 一个巨大的列表</span>
userService.saveBatch(hugeUserList, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每1000条批量提交一次</span>

<span class="hljs-comment">// 批量更新（自己控制事务）</span>
<span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchUpdateStatus</span><span class="hljs-params">(List&lt;Long&gt; ids, Integer status)</span> {
    List&lt;User&gt; updateList = ids.stream().map(id -&gt; {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
        user.setId(id);
        user.setStatus(status);
        <span class="hljs-keyword">return</span> user;
    }).collect(Collectors.toList());
    userService.updateBatchById(updateList);
}
</code></pre>
<h3 data-id="heading-4">5. 条件构造器，让你的逻辑更清晰</h3>
<p><code>QueryWrapper</code>和<code>LambdaQueryWrapper</code>可以构建非常复杂的查询逻辑。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 复杂的 AND-OR 组合查询</span>
List&lt;User&gt; users = userService.lambdaQuery()
    .eq(User::getStatus, <span class="hljs-number">1</span>)
    .and(wrapper -&gt; wrapper <span class="hljs-comment">// 这是一个 AND 嵌套</span>
        .like(User::getName, <span class="hljs-string">"张"</span>)
        .or()
        .like(User::getEmail, <span class="hljs-string">"zhang"</span>) <span class="hljs-comment">// name LIKE '%张%' OR email LIKE '%zhang%'</span>
    )
    .between(User::getCreateTime, startTime, endTime)
    .list();

<span class="hljs-comment">// 【性能技巧】只查需要的字段，避免 SELECT *</span>
List&lt;User&gt; userList = userService.lambdaQuery()
    .select(User::getId, User::getName) <span class="hljs-comment">// 只查询 ID 和 Name 字段</span>
    .eq(User::getStatus, <span class="hljs-number">1</span>)
    .list();
</code></pre>
<h3 data-id="heading-5">6. 自动填充，告别手动 set 创建时间</h3>
<p>像 <code>create_time</code>, <code>update_time</code> 这种字段，就别再手动 <code>set</code> 了。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> {
        <span class="hljs-comment">// 插入时自动填充</span>
        <span class="hljs-built_in">this</span>.strictInsertFill(metaObject, <span class="hljs-string">"createTime"</span>, LocalDateTime.class, LocalDateTime.now());
        <span class="hljs-built_in">this</span>.strictInsertFill(metaObject, <span class="hljs-string">"createBy"</span>, String.class, getCurrentUser());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> {
        <span class="hljs-comment">// 更新时自动填充</span>
        <span class="hljs-built_in">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">"updateTime"</span>, LocalDateTime.class, LocalDateTime.now());
    }
}

<span class="hljs-comment">// 实体类字段上需要加注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span>
    <span class="hljs-keyword">private</span> LocalDateTime createTime;
    
    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>
    <span class="hljs-keyword">private</span> LocalDateTime updateTime;
}
</code></pre>
<h3 data-id="heading-6">7. 逻辑删除，数据不是真的删除</h3>
<p>千万别用 <code>delete from</code> 硬删数据了！</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 在 application.yml 中配置</span>
<span class="hljs-attr">mybatis-plus:</span>
  <span class="hljs-attr">global-config:</span>
    <span class="hljs-attr">db-config:</span>
      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span>  <span class="hljs-comment"># 全局逻辑删除实体字段名</span>
      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 逻辑已删除值（默认为 1）</span>
      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span>    <span class="hljs-comment"># 逻辑未删除值（默认为 0）</span>
</code></pre>
<p>配置后，调用 <code>userService.removeById(1)</code>，MP 实际执行的是：
<code>UPDATE user SET deleted = 1 WHERE id = 1 AND deleted = 0</code>。
所有查询也会自动带上 <code>AND deleted = 0</code> 条件。</p>
<h3 data-id="heading-7">8. 枚举处理器，告别数据库存数字的迷惑行为</h3>
<p>数据库存 <code>status = 1</code>，代码里还要猜 1 是啥意思？用枚举！</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserStatus</span> {
    ENABLED(<span class="hljs-number">1</span>, <span class="hljs-string">"启用"</span>),
    DISABLED(<span class="hljs-number">0</span>, <span class="hljs-string">"禁用"</span>);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> code;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;

    UserStatus(<span class="hljs-type">int</span> code, String desc) {
        <span class="hljs-built_in">this</span>.code = code;
        <span class="hljs-built_in">this</span>.desc = desc;
    }
}

<span class="hljs-comment">// 实体类中直接使用枚举类型</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> UserStatus status;
}

<span class="hljs-comment">// 配置枚举处理器（Spring Boot 基本不用配了，开箱即用）</span>
</code></pre>
<p>这样，数据库存的是数字 <code>1</code>，但代码里操作的一直是 <code>UserStatus.ENABLED</code>，清晰明了！</p>
<h3 data-id="heading-8">9. 多租户数据隔离，SAAS 系统必备</h3>
<p>SAAS 应用中，不同租户的数据必须严格隔离。MP 的租户插件可以自动在每次查询时加上租户 ID。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> {
        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();
        
        <span class="hljs-comment">// 租户插件</span>
        <span class="hljs-type">TenantLineInnerInterceptor</span> <span class="hljs-variable">tenantInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TenantLineInnerInterceptor</span>();
        tenantInterceptor.setTenantLineHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TenantLineHandler</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> Expression <span class="hljs-title function_">getTenantId</span><span class="hljs-params">()</span> {
                <span class="hljs-comment">// 从当前上下文中获取租户ID，比如从 JWT Token 中</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringValue</span>(TenantContext.getCurrentTenantId());
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTenantIdColumn</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-string">"tenant_id"</span>; <span class="hljs-comment">// 数据库中的租户ID列名</span>
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ignoreTable</span><span class="hljs-params">(String tableName)</span> {
                <span class="hljs-comment">// 忽略不需要租户隔离的表，如全局配置表</span>
                <span class="hljs-keyword">return</span> <span class="hljs-string">"system_config"</span>.equals(tableName);
            }
        });
        interceptor.addInnerInterceptor(tenantInterceptor);
        <span class="hljs-keyword">return</span> interceptor;
    }
}
</code></pre>
<h3 data-id="heading-9">10. 代码生成器，效率翻倍利器</h3>
<p>别再手撸 <code>Entity</code>, <code>Mapper</code>, <code>Service</code>, <code>Controller</code> 了！</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeGenerator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">AutoGenerator</span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoGenerator</span>();
        
        <span class="hljs-comment">// 数据源配置</span>
        <span class="hljs-type">DataSourceConfig</span> <span class="hljs-variable">dataSourceConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceConfig</span>();
        dataSourceConfig.setUrl(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>);
        dataSourceConfig.setDriverName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);
        dataSourceConfig.setUsername(<span class="hljs-string">"root"</span>);
        dataSourceConfig.setPassword(<span class="hljs-string">"123456"</span>);
        generator.setDataSource(dataSourceConfig);
        
        <span class="hljs-comment">// 全局配置</span>
        <span class="hljs-type">GlobalConfig</span> <span class="hljs-variable">globalConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalConfig</span>();
        globalConfig.setOutputDir(System.getProperty(<span class="hljs-string">"user.dir"</span>) + <span class="hljs-string">"/src/main/java"</span>);
        globalConfig.setAuthor(<span class="hljs-string">"大华"</span>);
        globalConfig.setOpen(<span class="hljs-literal">false</span>);
        globalConfig.setSwagger2(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 实体属性 Swagger2 注解</span>
        generator.setGlobalConfig(globalConfig);
        
        <span class="hljs-comment">// 包配置</span>
        <span class="hljs-type">PackageConfig</span> <span class="hljs-variable">packageConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageConfig</span>();
        packageConfig.setParent(<span class="hljs-string">"com.laomao.demo"</span>);
        packageConfig.setEntity(<span class="hljs-string">"domain.entity"</span>);
        packageConfig.setMapper(<span class="hljs-string">"dao.mapper"</span>);
        packageConfig.setService(<span class="hljs-string">"service"</span>);
        packageConfig.setServiceImpl(<span class="hljs-string">"service.impl"</span>);
        generator.setPackageInfo(packageConfig);
        
        generator.execute(); <span class="hljs-comment">// 执行生成</span>
    }
}
</code></pre>
<p>运行一下，全套代码瞬间生成！</p>
<h3 data-id="heading-10">11. 自定义全局拦截器，统一处理逻辑</h3>
<p>可以用来做数据权限控制、SQL 性能监控、字段加解密等。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlLogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterceptor</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeQuery</span><span class="hljs-params">(Executor executor, MappedStatement ms, Object parameter, BoundSql boundSql)</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-comment">// 将开始时间存入当前线程上下文</span>
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterQuery</span><span class="hljs-params">(Executor executor, MappedStatement ms, Object parameter, BoundSql boundSql, List&lt;Object&gt; result)</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> end - start;
        <span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">1000</span>) { <span class="hljs-comment">// 超过1秒算慢SQL</span>
            log.warn(<span class="hljs-string">"慢SQL警告: {}, 执行耗时: {}ms"</span>, boundSql.getSql(), cost);
            <span class="hljs-comment">// 可以接入告警系统，通知开发人员</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-11">12. 分布式主键 ID，告别数据库自增</h3>
<p>在分布式系统中，数据库自增 ID 是瓶颈。推荐使用雪花算法。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-comment">// 指定主键类型为 ASSIGN_ID（雪花算法）</span>
    <span class="hljs-meta">@TableId(type = IdType.ASSIGN_ID)</span>
    <span class="hljs-keyword">private</span> Long id; <span class="hljs-comment">// 注意是 Long，不是 Integer</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 data-id="heading-12">13. 乐观锁，防止并发更新覆盖</h3>
<p>高并发下，防止后提交的数据覆盖先提交的数据。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 实体类中增加版本号字段</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-meta">@Version</span>
    <span class="hljs-keyword">private</span> Integer version;
}

<span class="hljs-comment">// 更新时，MP会自动带上版本号条件</span>
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(<span class="hljs-number">1L</span>);
user.setName(<span class="hljs-string">"新名字"</span>);
userService.updateById(user); <span class="hljs-comment">// SQL: UPDATE user SET name=?, version=? WHERE id=? AND version=?</span>
</code></pre>
<h3 data-id="heading-13">14. 结果映射，自动处理一对一、一对多</h3>
<p>MP 可以和 MyBatis 的 <code>@Result</code> 注解完美结合。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 在 Mapper 方法上使用复杂结果映射</span>
<span class="hljs-meta">@Select("SELECT u.*, d.name as dept_name FROM user u LEFT JOIN department d ON u.dept_id = d.id WHERE u.id = #{id}")</span>
<span class="hljs-meta">@Results({
    @Result(column = "id", property = "id"),
    @Result(column = "dept_name", property = "deptName"),
    @Result(column = "id", property = "roles", 
            many = @Many(select = "com.laomao.mapper.RoleMapper.findByUserId"))
})</span>
UserVO <span class="hljs-title function_">findUserWithDept</span><span class="hljs-params">(Long id)</span>;
</code></pre>
<h3 data-id="heading-14">15. 事务管理，保证数据一致性</h3>
<p>这是最后一道防线，也是最关键的一道。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span> <span class="hljs-comment">// 注意：默认只回滚 RuntimeException</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createUserWithInitData</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-comment">// 1. 保存用户基本信息</span>
        userService.save(user);
        
        <span class="hljs-comment">// 2. 初始化用户账户</span>
        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();
        account.setUserId(user.getId());
        accountService.save(account);
        
        <span class="hljs-comment">// 3. 发送欢迎消息（如果消息发送失败，希望用户创建也回滚）</span>
        messageService.sendWelcomeMessage(user.getId());
        
        <span class="hljs-comment">// 任何一个步骤出错，所有操作都会回滚</span>
    }
}
</code></pre>
<h3 data-id="heading-15">总结</h3>
<p>MyBatis-Plus 的强大远不止于此，但掌握以上 <strong>15个核心技巧</strong>，足以让你在日常开发中游刃有余，写出既高效又优雅的代码。</p>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-16">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP7SMincYFKERZbNKAFtzGQ" target="_blank" title="https://mp.weixin.qq.com/s/P7SMincYFKERZbNKAFtzGQ" ref="nofollow noopener noreferrer">《这20条SQL优化方案，让你的数据库查询速度提升10倍》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fy-GJ26kl0-yT6hE3fy2KjQ" target="_blank" title="https://mp.weixin.qq.com/s/y-GJ26kl0-yT6hE3fy2KjQ" ref="nofollow noopener noreferrer">《MySQL 为什么不推荐用雪花ID 和 UUID 做主键？》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFmTXkMKbOX-g0m58YE81Ew" target="_blank" title="https://mp.weixin.qq.com/s/FmTXkMKbOX-g0m58YE81Ew" ref="nofollow noopener noreferrer">《图片标签用 img 还是 picture？很多人彻底弄混了》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaGLep07rnMQdQLyDHBer8Q" target="_blank" title="https://mp.weixin.qq.com/s/aGLep07rnMQdQLyDHBer8Q" ref="nofollow noopener noreferrer">《还在用 WebSocket 做实时通信？SSE 可能更简单》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实战：用 Rsync 实现服务器间的高效增量同步与备份]]></title>    <link>https://juejin.cn/post/7572455881029566473</link>    <guid>https://juejin.cn/post/7572455881029566473</guid>    <pubDate>2025-11-15T03:02:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572455881029566473" data-draft-id="7572524368875520035" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实战：用 Rsync 实现服务器间的高效增量同步与备份"/> <meta itemprop="keywords" content="Linux"/> <meta itemprop="datePublished" content="2025-11-15T03:02:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LCG元"/> <meta itemprop="url" content="https://juejin.cn/user/3097802498120889"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实战：用 Rsync 实现服务器间的高效增量同步与备份
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3097802498120889/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LCG元
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T03:02:27.000Z" title="Sat Nov 15 2025 03:02:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 引言</h2>
<p>在现代 IT 基础设施管理中，数据同步与备份是确保业务连续性和数据安全的关键环节。Rsync（Remote Synchronization）作为一款强大的文件同步工具，以其高效的增量传输算法和灵活的配置选项，成为系统管理员的首选工具之一。</p>
<h3 data-id="heading-1">1.1 Rsync 的核心优势</h3>
<ul>
<li><strong>增量同步</strong>：仅传输发生变化的部分，大幅减少带宽消耗</li>
<li><strong>保持权限</strong>：完整保留文件属性、权限和时间戳</li>
<li><strong>压缩传输</strong>：内置压缩功能，优化网络利用率</li>
<li><strong>灵活配置</strong>：支持多种传输模式和过滤规则</li>
<li><strong>可靠性</strong>：支持断点续传和完整性校验</li>
</ul>
<h2 data-id="heading-2">2. 环境准备与安装</h2>
<h3 data-id="heading-3">2.1 系统要求</h3>
<p>确保所有参与同步的服务器均满足以下要求：</p>
<ul>
<li>Linux 操作系统（CentOS、Ubuntu 等）</li>
<li>SSH 访问权限</li>
<li>足够的磁盘空间</li>
</ul>
<h3 data-id="heading-4">2.2 Rsync 安装</h3>
<p><strong>创建安装脚本文件：<code>install_rsync.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 安装 Rsync 的通用脚本</span>
<span class="hljs-comment"># 适用于大多数 Linux 发行版</span>

<span class="hljs-built_in">set</span> -e  <span class="hljs-comment"># 遇到错误立即退出</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始安装 Rsync..."</span>

<span class="hljs-comment"># 检测系统类型并安装</span>
<span class="hljs-keyword">if</span> [ -f /etc/redhat-release ]; <span class="hljs-keyword">then</span>
    <span class="hljs-comment"># CentOS/RHEL 系统</span>
    sudo yum update -y
    sudo yum install -y rsync
<span class="hljs-keyword">elif</span> [ -f /etc/debian_version ]; <span class="hljs-keyword">then</span>
    <span class="hljs-comment"># Ubuntu/Debian 系统</span>
    sudo apt-get update
    sudo apt-get install -y rsync
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"不支持的 Linux 发行版"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 验证安装</span>
rsync_version=$(rsync --version | <span class="hljs-built_in">head</span> -n1)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"安装成功: <span class="hljs-variable">$rsync_version</span>"</span>

<span class="hljs-comment"># 创建必要的目录结构</span>
sudo <span class="hljs-built_in">mkdir</span> -p /var/log/rsync
sudo <span class="hljs-built_in">touch</span> /var/log/rsync/sync.log
sudo <span class="hljs-built_in">chmod</span> 666 /var/log/rsync/sync.log

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Rsync 安装完成"</span>
</code></pre>
<p>运行安装脚本：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">chmod</span> +x install_rsync.sh
./install_rsync.sh
</code></pre>
<h2 data-id="heading-5">3. Rsync 基础配置</h2>
<h3 data-id="heading-6">3.1 SSH 密钥认证配置</h3>
<p>为实现无密码同步，需要配置 SSH 密钥认证。</p>
<p><strong>创建 SSH 密钥配置脚本：<code>setup_ssh_keys.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># SSH 密钥配置脚本</span>
<span class="hljs-comment"># 在源服务器上执行</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-built_in">echo</span> <span class="hljs-string">"设置 SSH 密钥认证..."</span>

<span class="hljs-comment"># 生成 SSH 密钥对（如果不存在）</span>
<span class="hljs-keyword">if</span> [ ! -f ~/.ssh/id_rsa ]; <span class="hljs-keyword">then</span>
    ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N <span class="hljs-string">""</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"SSH 密钥对已生成"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 显示公钥内容</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"请将以下公钥内容添加到目标服务器的 authorized_keys 文件中："</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=========================================================="</span>
<span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=========================================================="</span>

<span class="hljs-comment"># 设置正确的权限</span>
<span class="hljs-built_in">chmod</span> 700 ~/.ssh
<span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa
<span class="hljs-built_in">chmod</span> 644 ~/.ssh/id_rsa.pub

<span class="hljs-built_in">echo</span> <span class="hljs-string">"SSH 密钥设置完成"</span>
</code></pre>
<p>在目标服务器上添加公钥：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 将源服务器的公钥添加到 ~/.ssh/authorized_keys</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"ssh-rsa AAAAB3NzaC1yc2E...你的公钥内容..."</span> &gt;&gt; ~/.ssh/authorized_keys
<span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys
</code></pre>
<h3 data-id="heading-7">3.2 测试 SSH 连接</h3>
<p><strong>创建连接测试脚本：<code>test_connection.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 测试 SSH 连接脚本</span>

<span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入目标服务器IP地址: "</span> remote_host
<span class="hljs-built_in">read</span> -p <span class="hljs-string">"请输入目标服务器用户名: "</span> remote_user

<span class="hljs-built_in">echo</span> <span class="hljs-string">"测试 SSH 连接到 <span class="hljs-variable">$remote_user</span>@<span class="hljs-variable">$remote_host</span>..."</span>

<span class="hljs-comment"># 测试连接</span>
ssh -o BatchMode=<span class="hljs-built_in">yes</span> -o ConnectTimeout=5 <span class="hljs-variable">$remote_user</span>@<span class="hljs-variable">$remote_host</span> <span class="hljs-string">"echo 'SSH 连接成功!'"</span>

<span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ SSH 连接测试成功"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"✗ SSH 连接测试失败"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
</code></pre>
<h2 data-id="heading-8">4. Rsync 同步流程详解</h2>
<p>以下是 Rsync 同步过程的完整流程图：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始同步任务] --&gt; B[扫描源目录文件]
    B --&gt; C[生成文件校验和]
    C --&gt; D[与目标目录比较]
    D --&gt; E{发现差异?}
    E --&gt;|是| F[仅传输差异部分]
    E --&gt;|否| G[跳过文件]
    F --&gt; H[更新目标文件]
    G --&gt; I[验证文件完整性]
    H --&gt; I
    I --&gt; J[记录同步日志]
    J --&gt; K[发送完成通知]
    K --&gt; L[结束同步任务]
    
    style A fill:#2d5c8a,color:#ffffff
    style L fill:#2d5c8a,color:#ffffff
    style F fill:#4caf50,color:#ffffff
    style H fill:#4caf50,color:#ffffff
    style I fill:#ff9800,color:#ffffff
    style J fill:#ff9800,color:#ffffff
</code></pre>
<h2 data-id="heading-9">5. 基础同步实战</h2>
<h3 data-id="heading-10">5.1 本地文件同步</h3>
<p><strong>创建本地同步脚本：<code>local_sync.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 本地目录同步脚本</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 配置变量</span>
SOURCE_DIR=<span class="hljs-string">"/home/user/source"</span>
BACKUP_DIR=<span class="hljs-string">"/home/user/backup"</span>
LOG_FILE=<span class="hljs-string">"/var/log/rsync/local_sync.log"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 开始本地同步"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>

<span class="hljs-comment"># 执行 rsync 同步</span>
rsync -avh \
    --progress \
    --delete \
    --exclude=<span class="hljs-string">'*.tmp'</span> \
    --exclude=<span class="hljs-string">'.git/'</span> \
    <span class="hljs-variable">$SOURCE_DIR</span>/ <span class="hljs-variable">$BACKUP_DIR</span>/ &gt;&gt; <span class="hljs-variable">$LOG_FILE</span> 2&gt;&amp;1

<span class="hljs-comment"># 检查执行结果</span>
<span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 本地同步完成"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"同步完成！查看日志: <span class="hljs-variable">$LOG_FILE</span>"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 本地同步失败"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"同步失败！查看日志: <span class="hljs-variable">$LOG_FILE</span>"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
</code></pre>
<h3 data-id="heading-11">5.2 远程服务器同步</h3>
<p><strong>创建远程同步脚本：<code>remote_sync.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 远程服务器同步脚本</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 配置变量</span>
REMOTE_USER=<span class="hljs-string">"backupuser"</span>
REMOTE_HOST=<span class="hljs-string">"192.168.1.100"</span>
REMOTE_PORT=<span class="hljs-string">"22"</span>
SOURCE_DIR=<span class="hljs-string">"/data/important"</span>
BACKUP_DIR=<span class="hljs-string">"/backup/primary"</span>
LOG_FILE=<span class="hljs-string">"/var/log/rsync/remote_sync.log"</span>

<span class="hljs-comment"># 同步选项</span>
RSYNC_OPTIONS=<span class="hljs-string">"-avzhP \
    --progress \
    --delete \
    --exclude='cache/*' \
    --exclude='temp/*' \
    --exclude='*.log' \
    --log-file=<span class="hljs-variable">$LOG_FILE</span>"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 开始远程同步到 <span class="hljs-variable">$REMOTE_USER</span>@<span class="hljs-variable">$REMOTE_HOST</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>

<span class="hljs-comment"># 执行远程同步</span>
rsync <span class="hljs-variable">$RSYNC_OPTIONS</span> \
    -e <span class="hljs-string">"ssh -p <span class="hljs-variable">$REMOTE_PORT</span>"</span> \
    <span class="hljs-variable">$SOURCE_DIR</span>/ <span class="hljs-variable">$REMOTE_USER</span>@<span class="hljs-variable">$REMOTE_HOST</span>:<span class="hljs-variable">$BACKUP_DIR</span>/

<span class="hljs-comment"># 验证同步结果</span>
<span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 远程同步成功完成"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    
    <span class="hljs-comment"># 统计同步结果</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 同步统计 ==="</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">tail</span> -n 10 <span class="hljs-variable">$LOG_FILE</span> | grep -E <span class="hljs-string">"sent|received"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 远程同步失败"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"远程同步完成！详细日志: <span class="hljs-variable">$LOG_FILE</span>"</span>
</code></pre>
<h2 data-id="heading-12">6. 高级备份策略</h2>
<h3 data-id="heading-13">6.1 增量备份与轮转</h3>
<p><strong>创建智能备份脚本：<code>smart_backup.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 智能备份脚本 - 支持增量备份和轮转</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 配置变量</span>
SOURCE_DIR=<span class="hljs-string">"/data/production"</span>
BACKUP_BASE=<span class="hljs-string">"/backup"</span>
REMOTE_HOST=<span class="hljs-string">"backup.server.com"</span>
REMOTE_USER=<span class="hljs-string">"backup"</span>
LOG_FILE=<span class="hljs-string">"/var/log/rsync/backup_<span class="hljs-subst">$(date +%Y%m%d)</span>.log"</span>

<span class="hljs-comment"># 备份类型配置</span>
BACKUP_TYPE=<span class="hljs-string">"incremental"</span>  <span class="hljs-comment"># incremental 或 full</span>
RETENTION_DAYS=30

<span class="hljs-comment"># 创建备份目录结构</span>
YEAR=$(<span class="hljs-built_in">date</span> +%Y)
MONTH=$(<span class="hljs-built_in">date</span> +%m)
DAY=$(<span class="hljs-built_in">date</span> +%d)
TIMESTAMP=$(<span class="hljs-built_in">date</span> +%Y%m%d_%H%M%S)

BACKUP_PATH=<span class="hljs-string">"<span class="hljs-variable">$BACKUP_BASE</span>/<span class="hljs-variable">$YEAR</span>/<span class="hljs-variable">$MONTH</span>/<span class="hljs-variable">$DAY</span>"</span>
LATEST_LINK=<span class="hljs-string">"<span class="hljs-variable">$BACKUP_BASE</span>/latest"</span>

<span class="hljs-comment"># 远程备份目录</span>
REMOTE_BACKUP_PATH=<span class="hljs-string">"/backup/<span class="hljs-subst">$(hostname)</span>/<span class="hljs-variable">$YEAR</span>/<span class="hljs-variable">$MONTH</span>/<span class="hljs-variable">$DAY</span>"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"=========================================="</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始备份: <span class="hljs-subst">$(date)</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"源目录: <span class="hljs-variable">$SOURCE_DIR</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"备份路径: <span class="hljs-variable">$BACKUP_PATH</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=========================================="</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>

<span class="hljs-comment"># 创建本地备份目录</span>
<span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$BACKUP_PATH</span>

<span class="hljs-comment"># 根据备份类型执行相应操作</span>
<span class="hljs-keyword">case</span> <span class="hljs-variable">$BACKUP_TYPE</span> <span class="hljs-keyword">in</span>
    <span class="hljs-string">"full"</span>)
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"执行完整备份..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
        LINK_DEST=<span class="hljs-string">""</span>
        ;;
    <span class="hljs-string">"incremental"</span>)
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"执行增量备份..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
        <span class="hljs-keyword">if</span> [ -L <span class="hljs-variable">$LATEST_LINK</span> ]; <span class="hljs-keyword">then</span>
            LINK_DEST=<span class="hljs-string">"--link-dest=<span class="hljs-variable">$LATEST_LINK</span>"</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"基于上一个备份: <span class="hljs-subst">$(readlink $LATEST_LINK)</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
        <span class="hljs-keyword">else</span>
            LINK_DEST=<span class="hljs-string">""</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"首次完整备份（增量基准）"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
        <span class="hljs-keyword">fi</span>
        ;;
    *)
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"错误的备份类型: <span class="hljs-variable">$BACKUP_TYPE</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
        <span class="hljs-built_in">exit</span> 1
        ;;
<span class="hljs-keyword">esac</span>

<span class="hljs-comment"># 执行本地备份</span>
rsync -avh \
    --progress \
    --delete \
    <span class="hljs-variable">$LINK_DEST</span> \
    --exclude=<span class="hljs-string">'*.tmp'</span> \
    --exclude=<span class="hljs-string">'/cache/'</span> \
    --log-file=<span class="hljs-variable">$LOG_FILE</span> \
    <span class="hljs-variable">$SOURCE_DIR</span>/ <span class="hljs-variable">$BACKUP_PATH</span>/

<span class="hljs-comment"># 更新 latest 符号链接</span>
<span class="hljs-built_in">ln</span> -sfn <span class="hljs-variable">$BACKUP_PATH</span> <span class="hljs-variable">$LATEST_LINK</span>

<span class="hljs-comment"># 执行远程同步</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始远程同步..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
rsync -avzh \
    -e <span class="hljs-string">"ssh"</span> \
    --progress \
    --delete \
    <span class="hljs-variable">$BACKUP_BASE</span>/ <span class="hljs-variable">$REMOTE_USER</span>@<span class="hljs-variable">$REMOTE_HOST</span>:<span class="hljs-variable">$REMOTE_BACKUP_PATH</span>/ &gt;&gt; <span class="hljs-variable">$LOG_FILE</span> 2&gt;&amp;1

<span class="hljs-comment"># 清理旧备份</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"清理超过 <span class="hljs-variable">$RETENTION_DAYS</span> 天的备份..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
find <span class="hljs-variable">$BACKUP_BASE</span> -<span class="hljs-built_in">type</span> d -mtime +<span class="hljs-variable">$RETENTION_DAYS</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> -rf {} \; 2&gt;/dev/null || <span class="hljs-literal">true</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"备份完成: <span class="hljs-subst">$(date)</span>"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"备份日志: <span class="hljs-variable">$LOG_FILE</span>"</span>
</code></pre>
<h3 data-id="heading-14">6.2 备份验证脚本</h3>
<p><strong>创建备份验证脚本：<code>verify_backup.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 备份验证脚本</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 配置变量</span>
SOURCE_DIR=<span class="hljs-string">"/data/production"</span>
BACKUP_DIR=<span class="hljs-string">"/backup/latest"</span>
LOG_FILE=<span class="hljs-string">"/var/log/rsync/verify.log"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: 开始备份验证"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>

<span class="hljs-comment"># 生成源目录校验和</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"生成源目录文件列表..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
find <span class="hljs-variable">$SOURCE_DIR</span> -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">sha256sum</span> {} \; | <span class="hljs-built_in">sort</span> &gt; /tmp/source_checksums.txt

<span class="hljs-comment"># 生成备份目录校验和</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"生成备份目录文件列表..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
find <span class="hljs-variable">$BACKUP_DIR</span> -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">sha256sum</span> {} \; | <span class="hljs-built_in">sort</span> &gt; /tmp/backup_checksums.txt

<span class="hljs-comment"># 比较校验和</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"比较文件校验和..."</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
diff /tmp/source_checksums.txt /tmp/backup_checksums.txt &gt; /tmp/checksum_diff.txt

<span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: ✓ 备份验证成功 - 所有文件一致"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"备份验证成功！"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(date)</span>: ✗ 备份验证失败 - 发现差异:"</span> &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">cat</span> /tmp/checksum_diff.txt &gt;&gt; <span class="hljs-variable">$LOG_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"备份验证失败！查看日志: <span class="hljs-variable">$LOG_FILE</span>"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 清理临时文件</span>
<span class="hljs-built_in">rm</span> -f /tmp/source_checksums.txt /tmp/backup_checksums.txt /tmp/checksum_diff.txt
</code></pre>
<h2 data-id="heading-15">7. 自动化与监控</h2>
<h3 data-id="heading-16">7.1 Cron 定时任务配置</h3>
<p><strong>创建 Cron 配置脚本：<code>setup_cron.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 设置 Rsync 定时任务</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 备份脚本路径</span>
BACKUP_SCRIPT=<span class="hljs-string">"/usr/local/bin/smart_backup.sh"</span>
VERIFY_SCRIPT=<span class="hljs-string">"/usr/local/bin/verify_backup.sh"</span>

<span class="hljs-comment"># 确保脚本有执行权限</span>
<span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$BACKUP_SCRIPT</span>
<span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$VERIFY_SCRIPT</span>

<span class="hljs-comment"># 添加定时任务</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"设置 Rsync 定时任务..."</span>

<span class="hljs-comment"># 每天凌晨2点执行完整备份</span>
(crontab -l 2&gt;/dev/null; <span class="hljs-built_in">echo</span> <span class="hljs-string">"0 2 * * 1 <span class="hljs-variable">$BACKUP_SCRIPT</span>"</span>) | crontab -

<span class="hljs-comment"># 每天凌晨3点执行增量备份</span>
(crontab -l 2&gt;/dev/null; <span class="hljs-built_in">echo</span> <span class="hljs-string">"0 3 * * 2-7 <span class="hljs-variable">$BACKUP_SCRIPT</span>"</span>) | crontab -

<span class="hljs-comment"># 每周日凌晨4点验证备份</span>
(crontab -l 2&gt;/dev/null; <span class="hljs-built_in">echo</span> <span class="hljs-string">"0 4 * * 0 <span class="hljs-variable">$VERIFY_SCRIPT</span>"</span>) | crontab -

<span class="hljs-comment"># 显示当前定时任务</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"当前定时任务:"</span>
crontab -l

<span class="hljs-built_in">echo</span> <span class="hljs-string">"定时任务设置完成"</span>
</code></pre>
<h3 data-id="heading-17">7.2 监控与告警脚本</h3>
<p><strong>创建监控脚本：<code>monitor_backup.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 备份监控和告警脚本</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-comment"># 配置变量</span>
LOG_DIR=<span class="hljs-string">"/var/log/rsync"</span>
ALERT_EMAIL=<span class="hljs-string">"admin@company.com"</span>
MAX_LOG_AGE=24  <span class="hljs-comment"># 小时</span>

<span class="hljs-comment"># 检查最近的备份日志</span>
RECENT_LOGS=$(find <span class="hljs-variable">$LOG_DIR</span> -name <span class="hljs-string">"backup_*.log"</span> -mtime -1)

<span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">$RECENT_LOGS</span>"</span> ]; <span class="hljs-keyword">then</span>
    SUBJECT=<span class="hljs-string">"警告: 未发现最近备份日志"</span>
    MESSAGE=<span class="hljs-string">"在 <span class="hljs-variable">$LOG_DIR</span> 中未找到最近 <span class="hljs-variable">$MAX_LOG_AGE</span> 小时内的备份日志，请检查备份任务状态。"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$MESSAGE</span>"</span> | mail -s <span class="hljs-string">"<span class="hljs-variable">$SUBJECT</span>"</span> <span class="hljs-variable">$ALERT_EMAIL</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 检查最新备份状态</span>
LATEST_LOG=$(<span class="hljs-built_in">ls</span> -t <span class="hljs-variable">$LOG_DIR</span>/backup_*.<span class="hljs-built_in">log</span> | <span class="hljs-built_in">head</span> -n1)

<span class="hljs-keyword">if</span> grep -q <span class="hljs-string">"备份完成"</span> <span class="hljs-string">"<span class="hljs-variable">$LATEST_LOG</span>"</span>; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"备份状态: 正常"</span>
    
    <span class="hljs-comment"># 提取备份统计信息</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 最新备份统计 ==="</span>
    <span class="hljs-built_in">tail</span> -n 20 <span class="hljs-variable">$LATEST_LOG</span> | grep -E <span class="hljs-string">"sent|received|Number of files"</span>
<span class="hljs-keyword">else</span>
    SUBJECT=<span class="hljs-string">"紧急: 备份任务失败"</span>
    MESSAGE=<span class="hljs-string">"最新备份任务可能失败，请立即检查日志: <span class="hljs-variable">$LATEST_LOG</span>"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$MESSAGE</span>"</span> | mail -s <span class="hljs-string">"<span class="hljs-variable">$SUBJECT</span>"</span> <span class="hljs-variable">$ALERT_EMAIL</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"备份状态: 失败 - 已发送告警"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 检查磁盘空间</span>
DISK_USAGE=$(<span class="hljs-built_in">df</span> -h <span class="hljs-variable">$LOG_DIR</span> | awk <span class="hljs-string">'NR==2 {print $5}'</span> | sed <span class="hljs-string">'s/%//'</span>)
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$DISK_USAGE</span> -gt 90 ]; <span class="hljs-keyword">then</span>
    SUBJECT=<span class="hljs-string">"警告: 备份磁盘空间不足"</span>
    MESSAGE=<span class="hljs-string">"备份目录磁盘使用率: <span class="hljs-variable">${DISK_USAGE}</span>%，请及时清理。"</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$MESSAGE</span>"</span> | mail -s <span class="hljs-string">"<span class="hljs-variable">$SUBJECT</span>"</span> <span class="hljs-variable">$ALERT_EMAIL</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"监控检查完成: <span class="hljs-subst">$(date)</span>"</span>
</code></pre>
<h2 data-id="heading-18">8. 高级配置与优化</h2>
<h3 data-id="heading-19">8.1 Rsync 守护模式配置</h3>
<p><strong>创建 Rsync 服务端配置：<code>rsyncd.conf</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Rsync 守护进程配置文件</span>
<span class="hljs-comment"># 位置: /etc/rsyncd.conf</span>

uid = nobody
gid = nobody
use <span class="hljs-built_in">chroot</span> = <span class="hljs-built_in">yes</span>
max connections = 10
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
<span class="hljs-built_in">log</span> file = /var/log/rsyncd.log

[backup]
    path = /data/backup
    comment = Main backup directory
    <span class="hljs-built_in">read</span> only = no
    auth <span class="hljs-built_in">users</span> = backupuser
    secrets file = /etc/rsyncd.secrets
    hosts allow = 192.168.1.0/24
    hosts deny = *
    list = <span class="hljs-built_in">yes</span>

[webdata]
    path = /var/www/html
    comment = Web data backup
    <span class="hljs-built_in">read</span> only = <span class="hljs-built_in">yes</span>
    exclude = cache/ temp/ logs/
    dont compress = *.gz *.zip *.jpg *.png
</code></pre>
<p><strong>创建认证文件：<code>setup_rsync_daemon.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 设置 Rsync 守护模式</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-built_in">echo</span> <span class="hljs-string">"设置 Rsync 守护进程..."</span>

<span class="hljs-comment"># 创建认证文件</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"backupuser:password123"</span> | sudo <span class="hljs-built_in">tee</span> /etc/rsyncd.secrets
sudo <span class="hljs-built_in">chmod</span> 600 /etc/rsyncd.secrets

<span class="hljs-comment"># 创建备份目录</span>
sudo <span class="hljs-built_in">mkdir</span> -p /data/backup
sudo <span class="hljs-built_in">chown</span> nobody:nobody /data/backup

<span class="hljs-comment"># 复制配置文件</span>
sudo <span class="hljs-built_in">cp</span> rsyncd.conf /etc/

<span class="hljs-comment"># 启动 Rsync 守护进程</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span> -v systemctl &gt;/dev/null; <span class="hljs-keyword">then</span>
    <span class="hljs-comment"># Systemd 系统</span>
    sudo systemctl <span class="hljs-built_in">enable</span> rsync
    sudo systemctl start rsync
    sudo systemctl status rsync
<span class="hljs-keyword">else</span>
    <span class="hljs-comment"># SysV init 系统</span>
    sudo service rsync start
    sudo service rsync status
<span class="hljs-keyword">fi</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Rsync 守护进程设置完成"</span>
</code></pre>
<h3 data-id="heading-20">8.2 性能优化脚本</h3>
<p><strong>创建性能优化脚本：<code>optimize_rsync.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># Rsync 性能优化配置</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-built_in">echo</span> <span class="hljs-string">"优化 Rsync 性能配置..."</span>

<span class="hljs-comment"># 创建优化配置</span>
<span class="hljs-built_in">cat</span> &gt; /tmp/rsync_optimizations.txt &lt;&lt; <span class="hljs-string">'EOF'</span>
<span class="hljs-comment"># Rsync 性能优化建议</span>

1. 网络优化：
   - 使用 -z 压缩传输
   - 调整 --block-size 参数
   - 使用 -W 禁用增量检测（全量传输时）

2. 文件处理优化：
   - 使用 --inplace 避免临时文件
   - 合理使用 --exclude 减少扫描文件数
   - 考虑使用 --max-size 和 --min-size

3. 系统级优化：
   - 调整 TCP 缓冲区大小
   - 使用更快的加密算法（如 arcfour）
   - 考虑使用 rsync over rsync 守护进程

4. 针对大文件集的优化参数：
   rsync -avzh \
     --progress \
     --delete \
     --partial \
     --inplace \
     --compress \
     --compress-level=6 \
     --bwlimit=50000 \
     --<span class="hljs-built_in">timeout</span>=300 \
     <span class="hljs-built_in">source</span>/ destination/
EOF

<span class="hljs-built_in">echo</span> <span class="hljs-string">"性能优化建议已保存到: /tmp/rsync_optimizations.txt"</span>
<span class="hljs-built_in">cat</span> /tmp/rsync_optimizations.txt
</code></pre>
<h2 data-id="heading-21">9. 故障排除与维护</h2>
<h3 data-id="heading-22">9.1 常见问题解决脚本</h3>
<p><strong>创建故障排除脚本：<code>troubleshoot_rsync.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># Rsync 故障排除工具</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Rsync 故障排除检查..."</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"========================"</span>

<span class="hljs-comment"># 检查 Rsync 是否安装</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span> -v rsync &gt;/dev/null; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ Rsync 已安装: <span class="hljs-subst">$(rsync --version | head -n1)</span>"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"✗ Rsync 未安装"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 检查 SSH 连接</span>
<span class="hljs-built_in">read</span> -p <span class="hljs-string">"测试远程连接？(y/n): "</span> test_ssh
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$test_ssh</span>"</span> = <span class="hljs-string">"y"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">read</span> -p <span class="hljs-string">"远程主机: "</span> remote_host
    <span class="hljs-built_in">read</span> -p <span class="hljs-string">"用户名: "</span> remote_user
    ssh -o BatchMode=<span class="hljs-built_in">yes</span> <span class="hljs-variable">$remote_user</span>@<span class="hljs-variable">$remote_host</span> <span class="hljs-string">"echo 'SSH 连接成功'"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 检查磁盘空间</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 磁盘空间检查 ==="</span>
<span class="hljs-built_in">df</span> -h | grep -E <span class="hljs-string">"(Filesystem|/backup|/data)"</span>

<span class="hljs-comment"># 检查最近日志</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 最近 Rsync 日志 ==="</span>
find /var/log/rsync -name <span class="hljs-string">"*.log"</span> -mtime -1 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">tail</span> -n 5 {} \; 2&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">"未找到日志文件"</span>

<span class="hljs-comment"># 检查定时任务</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 定时任务检查 ==="</span>
crontab -l | grep -E <span class="hljs-string">"(rsync|backup)"</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"未找到相关定时任务"</span>

<span class="hljs-comment"># 检查进程</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== 相关进程检查 ==="</span>
ps aux | grep -E <span class="hljs-string">"(rsync|backup)"</span> | grep -v grep || <span class="hljs-built_in">echo</span> <span class="hljs-string">"未找到相关进程"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"故障排除检查完成"</span>
</code></pre>
<h3 data-id="heading-23">9.2 日志分析脚本</h3>
<p><strong>创建日志分析脚本：<code>analyze_logs.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># Rsync 日志分析工具</span>

<span class="hljs-built_in">set</span> -e

LOG_DIR=<span class="hljs-string">"/var/log/rsync"</span>
OUTPUT_FILE=<span class="hljs-string">"/tmp/rsync_analysis_<span class="hljs-subst">$(date +%Y%m%d)</span>.txt"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始分析 Rsync 日志..."</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Rsync 日志分析报告 - <span class="hljs-subst">$(date)</span>"</span> &gt; <span class="hljs-variable">$OUTPUT_FILE</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"================================="</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>

<span class="hljs-comment"># 分析最近7天的日志</span>
<span class="hljs-keyword">for</span> log_file <span class="hljs-keyword">in</span> $(find <span class="hljs-variable">$LOG_DIR</span> -name <span class="hljs-string">"*.log"</span> -mtime -7); <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">""</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"分析文件: <span class="hljs-variable">$log_file</span>"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"-------------------------"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    
    <span class="hljs-comment"># 统计成功次数</span>
    success_count=$(grep -c <span class="hljs-string">"完成\|成功"</span> <span class="hljs-string">"<span class="hljs-variable">$log_file</span>"</span> || <span class="hljs-literal">true</span>)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"成功次数: <span class="hljs-variable">$success_count</span>"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    
    <span class="hljs-comment"># 统计失败次数</span>
    failure_count=$(grep -c <span class="hljs-string">"失败\|错误\|error"</span> <span class="hljs-string">"<span class="hljs-variable">$log_file</span>"</span> || <span class="hljs-literal">true</span>)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"失败次数: <span class="hljs-variable">$failure_count</span>"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    
    <span class="hljs-comment"># 提取传输统计</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"传输统计:"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    grep -E <span class="hljs-string">"sent|received|total size"</span> <span class="hljs-string">"<span class="hljs-variable">$log_file</span>"</span> | <span class="hljs-built_in">tail</span> -n 5 &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"无传输统计"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    
    <span class="hljs-comment"># 检查最近错误</span>
    recent_errors=$(grep -i <span class="hljs-string">"error\|fail"</span> <span class="hljs-string">"<span class="hljs-variable">$log_file</span>"</span> | <span class="hljs-built_in">tail</span> -n 3)
    <span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$recent_errors</span>"</span> ]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"最近错误:"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$recent_errors</span>"</span> &gt;&gt; <span class="hljs-variable">$OUTPUT_FILE</span>
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"日志分析完成: <span class="hljs-variable">$OUTPUT_FILE</span>"</span>
<span class="hljs-built_in">cat</span> <span class="hljs-variable">$OUTPUT_FILE</span>
</code></pre>
<h2 data-id="heading-24">10. 完整部署示例</h2>
<h3 data-id="heading-25">10.1 生产环境部署脚本</h3>
<p><strong>创建完整部署脚本：<code>deploy_rsync_system.sh</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 完整的 Rsync 备份系统部署脚本</span>

<span class="hljs-built_in">set</span> -e

<span class="hljs-built_in">echo</span> <span class="hljs-string">"开始部署完整的 Rsync 备份系统..."</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=================================="</span>

<span class="hljs-comment"># 创建目录结构</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"创建目录结构..."</span>
sudo <span class="hljs-built_in">mkdir</span> -p /{backup,data,usr/local/bin,var/log/rsync}

<span class="hljs-comment"># 安装 Rsync</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"安装 Rsync..."</span>
<span class="hljs-keyword">if</span> [ -f /etc/redhat-release ]; <span class="hljs-keyword">then</span>
    sudo yum install -y rsync
<span class="hljs-keyword">elif</span> [ -f /etc/debian_version ]; <span class="hljs-keyword">then</span>
    sudo apt-get update &amp;&amp; sudo apt-get install -y rsync
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 部署所有脚本</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"部署管理脚本..."</span>
sudo <span class="hljs-built_in">cp</span> smart_backup.sh /usr/local/bin/
sudo <span class="hljs-built_in">cp</span> verify_backup.sh /usr/local/bin/
sudo <span class="hljs-built_in">cp</span> monitor_backup.sh /usr/local/bin/
sudo <span class="hljs-built_in">cp</span> troubleshoot_rsync.sh /usr/local/bin/

<span class="hljs-comment"># 设置执行权限</span>
sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/*.sh

<span class="hljs-comment"># 设置定时任务</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"配置定时任务..."</span>
(sudo crontab -l 2&gt;/dev/null | grep -v -E <span class="hljs-string">"(smart_backup|verify_backup)"</span> ; <span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">'EOF'</span>
<span class="hljs-comment"># Rsync 备份任务</span>
0 2 * * * /usr/local/bin/smart_backup.sh
0 4 * * 0 /usr/local/bin/verify_backup.sh
0 6 * * * /usr/local/bin/monitor_backup.sh
EOF
) | sudo crontab -

<span class="hljs-comment"># 创建日志轮转配置</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"配置日志轮转..."</span>
sudo <span class="hljs-built_in">cat</span> &gt; /etc/logrotate.d/rsync &lt;&lt; <span class="hljs-string">'EOF'</span>
/var/log/rsync/*.<span class="hljs-built_in">log</span> {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 644 root root
}
EOF

<span class="hljs-built_in">echo</span> <span class="hljs-string">"部署完成！"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"========== 部署摘要 =========="</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ Rsync 已安装"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ 管理脚本已部署到 /usr/local/bin/"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ 定时任务已配置"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"✓ 日志轮转已设置"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=============================="</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"请根据实际环境修改脚本中的配置变量"</span>
</code></pre>
<h2 data-id="heading-26">11. 总结</h2>
<p>通过本教程，我们构建了一个完整的 Rsync 备份和同步系统，具备以下特性：</p>
<ul>
<li><strong>完整的安装和配置指南</strong></li>
<li><strong>灵活的同步策略</strong>（完整备份 + 增量备份）</li>
<li><strong>自动化运维</strong>（定时任务 + 监控告警）</li>
<li><strong>健壮的故障处理</strong>（验证 + 日志分析）</li>
<li><strong>性能优化建议</strong></li>
</ul>
<p>这套系统可以直接在生产环境中部署使用，能够满足大多数企业的数据同步和备份需求。根据实际环境调整配置参数后，即可提供可靠的数据保护解决方案。</p>
<h3 data-id="heading-27">11.1 后续维护建议</h3>
<ol>
<li><strong>定期检查日志文件</strong>，确保备份任务正常运行</li>
<li><strong>监控磁盘空间</strong>，及时清理过期备份</li>
<li><strong>定期验证备份完整性</strong>，确保可恢复性</li>
<li><strong>更新安全配置</strong>，定期更换认证密钥</li>
<li><strong>测试恢复流程</strong>，确保灾难恢复可行性</li>
</ol>
<p>通过遵循这些最佳实践，您可以构建一个可靠、高效的数据保护体系，为业务连续性提供坚实保障。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[接口设计中的扩展与组合：一次Code Review引发的思考]]></title>    <link>https://juejin.cn/post/7572437226023387146</link>    <guid>https://juejin.cn/post/7572437226023387146</guid>    <pubDate>2025-11-15T03:05:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572437226023387146" data-draft-id="7572455881029582857" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="接口设计中的扩展与组合：一次Code Review引发的思考"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2025-11-15T03:05:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="9号达人"/> <meta itemprop="url" content="https://juejin.cn/user/2450136052270077"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            接口设计中的扩展与组合：一次Code Review引发的思考
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2450136052270077/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    9号达人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T03:05:15.000Z" title="Sat Nov 15 2025 03:05:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>最近在开发微服务项目时遇到了一个典型的技术决策场景：我们的商品服务通过 Dubbo 对外提供了一个商品列表查询的 RPC 接口，目前被网页端系统调用。现在 PC 端管理系统（新的调用方）也需要类似的商品列表功能。在 Code Review 过程中，关于是新建接口还是复用现有接口，组长和我产生了分歧。</p>
<p><strong>这次争论让我意识到：同样是"代码复用"，不同人看到的场景也可能是不同的。</strong></p>
<blockquote>
<p>💡 <strong>本文约 4500 字，预计阅读 10 分钟</strong>。如果你也遇到过类似的技术决策困惑，欢迎关注公众号「<strong>9号达人</strong>」，一起交流实战经验。</p>
</blockquote>
<p><strong>项目架构：</strong></p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────┐
│ 订单服务        │ ────┐
│ <span class="hljs-attribute">order</span>-service   │     │
└─────────────────┘     │
                        │
┌─────────────────┐     │      ┌──────────────────────────┐
│ PC管理系统      │ ────┼─────→│ 商品服务                 │
│ pc-admin        │     │      │ product-service          │
└─────────────────┘     │      │                          │
                        │      │ ProductFacade (Dubbo)    │
┌─────────────────┐     │      │  ├─ <span class="hljs-built_in">queryProductList</span>()   │
│ 网页商城        │ ────┘      │  └─ ??? 新增方法 ???    │
│ web-mall        │            └──────────────────────────┘
└─────────────────┘
</code></pre>
<h3 data-id="heading-1">具体场景</h3>
<ul>
<li><strong>现有接口</strong>：商品服务对外提供的 RPC 接口（被网页商城调用，包含热度计算、推荐数据等额外查询）</li>
<li><strong>新需求</strong>：PC 端管理系统需要商品列表功能（只需要基本查询，用于后台管理）</li>
<li><strong>我的方案</strong>：在 Facade 接口中新增一个方法 <code>queryProductListForPc()</code></li>
<li><strong>质疑</strong>：为什么不在现有方法 <code>queryProductList()</code> 加个 <code>source</code> 参数来区分，代码差不多为什么要重复？</li>
</ul>
<hr/>
<h2 data-id="heading-2">两种设计思路的对比</h2>
<h3 data-id="heading-3">方案 A： 在请求对象中新增可选字段，通过判空兼容</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">/**
 * 商品服务对外 Facade 接口（API 层）
 * 调用方：web-mall, pc-admin, order-service
 */</span>
<span class="hljs-keyword">public</span> interface <span class="hljs-type">ProductFacade</span> {

    <span class="hljs-comment">/**
     * 查询商品列表（保持方法签名不变，向后兼容）
     */</span>
    <span class="hljs-type">Result</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">ProductDTO</span>&gt;&gt; queryProductList(<span class="hljs-type">ProductQueryRequest</span> request);
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 请求对象（在 API jar 中）</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductQueryRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageNum;
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageSize;
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> source;    <span class="hljs-comment">// 新增字段：来源标识（可选，老调用方不传）</span>
}
</code></pre>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// product-service-impl 实现</span>
<span class="hljs-variable">@Service</span>
<span class="hljs-variable">@DubboService</span>
public class ProductFacadeImpl implements ProductFacade {

    <span class="hljs-variable">@Override</span>
    public Result&lt;List&lt;ProductDTO&gt;&gt; <span class="hljs-built_in">queryProductList</span>(ProductQueryRequest request) {
        <span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">Product</span>&gt; <span class="hljs-selector-tag">products</span> = <span class="hljs-selector-tag">productService</span><span class="hljs-selector-class">.queryBasicList</span>(
            request.<span class="hljs-built_in">getPageNum</span>(),
            request.<span class="hljs-built_in">getPageSize</span>()
        );

        <span class="hljs-comment">// 判断 source 字段是否为空（向后兼容的关键）</span>
        <span class="hljs-selector-tag">if</span> (request.<span class="hljs-built_in">getSource</span>() == null || <span class="hljs-string">"web"</span>.<span class="hljs-built_in">equals</span>(request.<span class="hljs-built_in">getSource</span>())) {
            <span class="hljs-comment">// 老调用方不传 source，默认按 Web 端处理</span>
            <span class="hljs-comment">// 或者显式传 "web"</span>
            <span class="hljs-selector-tag">enrichWebData</span>(products);          <span class="hljs-comment">// +50ms</span>
            <span class="hljs-selector-tag">calculateWebMetrics</span>(products);    <span class="hljs-comment">// +80ms</span>
            <span class="hljs-selector-tag">loadWebRecommendations</span>(products); <span class="hljs-comment">// +70ms</span>
        } <span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span> (<span class="hljs-string">"pc"</span>.<span class="hljs-built_in">equals</span>(request.<span class="hljs-built_in">getSource</span>())) {
            <span class="hljs-comment">// PC端逻辑（或者不做额外处理）</span>
        }

        return Result.<span class="hljs-built_in">success</span>(ProductConverter.<span class="hljs-built_in">toDTO</span>(products));
    }
}
</code></pre>
<h4 data-id="heading-4">优点</h4>
<ul>
<li>只修改请求对象，不修改方法签名，向后兼容</li>
<li>老调用方不传 <code>source</code>，代码不用改，也能正常运行</li>
<li>只有一个方法，"代码复用率高"，后期可以统一维护，认知成本低（实际上依赖对 source 字段的维护，认知成本也不低）</li>
</ul>
<h4 data-id="heading-5">可能存在的问题</h4>
<ol>
<li>
<p><strong>隐式默认值问题，容易出错</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 问题：source == null 默认是 Web 端，这是一个隐式假设</span>
<span class="hljs-selector-tag">if</span> (request.<span class="hljs-built_in">getSource</span>() == null || <span class="hljs-string">"web"</span>.<span class="hljs-built_in">equals</span>(request.<span class="hljs-built_in">getSource</span>())) {
    <span class="hljs-comment">// 执行 Web 端逻辑</span>
}

<span class="hljs-comment">// 隐患：</span>
<span class="hljs-comment">// 1. 订单服务调用时，不知道会走 Web 端逻辑，可能执行了不需要的查询</span>
<span class="hljs-comment">// 2. 未来如果有第4个、第5个调用方，默认值假设可能不成立</span>
<span class="hljs-comment">// 3. 新人维护代码时，不清楚 null 代表什么含义</span>
</code></pre>
</li>
<li>
<p><strong>职责不清晰，一个方法服务多个场景</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 这个方法既要服务 Web 端，又要服务 PC 端，还可能要服务 App 端</span>
<span class="hljs-comment">// 随着业务发展，if-else 会越来越多</span>
<span class="hljs-keyword">if</span> (source == <span class="hljs-literal">null</span> || <span class="hljs-string">"web"</span>.<span class="hljs-keyword">equals</span>(source)) {
    <span class="hljs-comment">// Web端逻辑（50行）</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"pc"</span>.<span class="hljs-keyword">equals</span>(source)) {
    <span class="hljs-comment">// PC端逻辑（80行）</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"app"</span>.<span class="hljs-keyword">equals</span>(source)) {
    <span class="hljs-comment">// App端逻辑（60行）</span>
}
<span class="hljs-comment">// 这个方法会膨胀到200行+</span>
</code></pre>
</li>
<li>
<p><strong>各端逻辑耦合，改一处影响全局</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 场景：Web 端要优化性能，调整了基础查询逻辑</span>
List&lt;Product&gt; products = productService<span class="hljs-selector-class">.queryBasicList</span>(pageNum, pageSize);

<span class="hljs-comment">// 问题：这个改动会影响 PC 端、App 端的所有调用</span>
<span class="hljs-comment">// 需要回归测试所有端的所有场景</span>
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-6">方案 B：我的方案 - 新增独立方法</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">/**
 * 商品服务对外 Facade 接口（API 层）
 */</span>
<span class="hljs-keyword">public</span> interface <span class="hljs-type">ProductFacade</span> {

    <span class="hljs-comment">/**
     * 查询商品列表（保持原有签名不变，向后兼容）
     */</span>
    <span class="hljs-type">Result</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">ProductDTO</span>&gt;&gt; queryProductList(<span class="hljs-type">ProductQueryRequest</span> request);

    <span class="hljs-comment">/**
     * 查询商品列表 - PC端（新增方法，专门给PC管理端使用）
     */</span>
    <span class="hljs-type">Result</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">ProductDTO</span>&gt;&gt; queryProductListForPc(<span class="hljs-type">ProductQueryRequest</span> request);
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 请求对象保持不变</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductQueryRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">private</span> Integer pageNum;
    <span class="hljs-keyword">private</span> Integer pageSize;
    <span class="hljs-comment">// 不添加 source 字段</span>
}
</code></pre>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// product-service-impl 实现</span>
<span class="hljs-variable">@Service</span>
<span class="hljs-variable">@DubboService</span>
public class ProductFacadeImpl implements ProductFacade {

    <span class="hljs-comment">/**
     * 查询商品列表（保持原有逻辑不变，服务 Web 端和老调用方）
     */</span>
    <span class="hljs-variable">@Override</span>
    public Result&lt;List&lt;ProductDTO&gt;&gt; <span class="hljs-built_in">queryProductList</span>(ProductQueryRequest request) {
        <span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">Product</span>&gt; <span class="hljs-selector-tag">products</span> = <span class="hljs-selector-tag">productService</span><span class="hljs-selector-class">.queryBasicList</span>(
            request.<span class="hljs-built_in">getPageNum</span>(),
            request.<span class="hljs-built_in">getPageSize</span>()
        );

        <span class="hljs-comment">// Web端特有的数据增强</span>
        <span class="hljs-selector-tag">enrichWebData</span>(products);          <span class="hljs-comment">// +50ms</span>
        <span class="hljs-selector-tag">calculateWebMetrics</span>(products);    <span class="hljs-comment">// +80ms</span>
        <span class="hljs-selector-tag">loadWebRecommendations</span>(products); <span class="hljs-comment">// +70ms</span>

        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Result</span><span class="hljs-selector-class">.success</span>(ProductConverter.<span class="hljs-built_in">toDTO</span>(products));
    }

    <span class="hljs-comment">/**
     * PC端商品列表（新增，轻量级）
     */</span>
    @<span class="hljs-selector-tag">Override</span>
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">Result</span>&lt;<span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">ProductDTO</span>&gt;&gt; <span class="hljs-selector-tag">queryProductListForPc</span>(ProductQueryRequest request) {
        <span class="hljs-comment">// 只做基础查询，不做额外增强</span>
        <span class="hljs-selector-tag">List</span>&lt;<span class="hljs-selector-tag">Product</span>&gt; <span class="hljs-selector-tag">products</span> = <span class="hljs-selector-tag">productService</span><span class="hljs-selector-class">.queryBasicList</span>(
            request.<span class="hljs-built_in">getPageNum</span>(),
            request.<span class="hljs-built_in">getPageSize</span>()
        );
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Result</span><span class="hljs-selector-class">.success</span>(ProductConverter.<span class="hljs-built_in">toDTO</span>(products));
    }
}
</code></pre>
<h4 data-id="heading-7">优点</h4>
<p><strong>1. 完全向后兼容，老调用方零改动</strong></p>
<pre><code class="hljs language-ini" lang="ini">// 订单服务、Web商城的调用代码完全不需要改
ProductQueryRequest <span class="hljs-attr">request</span> = new ProductQueryRequest()<span class="hljs-comment">;</span>
request.setPageNum(1)<span class="hljs-comment">;</span>
request.setPageSize(10)<span class="hljs-comment">;</span>
Result&lt;List&lt;ProductDTO&gt;&gt; <span class="hljs-attr">result</span> = productFacade.queryProductList(request)<span class="hljs-comment">;</span>

// PC管理系统调用新方法
ProductQueryRequest <span class="hljs-attr">request</span> = new ProductQueryRequest()<span class="hljs-comment">;</span>
request.setPageNum(1)<span class="hljs-comment">;</span>
request.setPageSize(10)<span class="hljs-comment">;</span>
Result&lt;List&lt;ProductDTO&gt;&gt; <span class="hljs-attr">result</span> = productFacade.queryProductListForPc(request)<span class="hljs-comment">;</span>
</code></pre>
<p><strong>2. 独立升级，互不影响</strong></p>
<ul>
<li>商品服务发布新版本 API jar 包（新增了 <code>queryProductListForPc</code> 方法）</li>
<li>PC 管理系统升级 jar 包，调用新方法</li>
<li><strong>订单服务、Web 商城不用动</strong>，继续用老方法 <code>queryProductList</code></li>
<li>各自按自己的节奏升级</li>
</ul>
<p><strong>3. 零风险上线</strong></p>
<ul>
<li>新方法只服务新调用方（PC 管理系统）</li>
<li>老方法保持不变，所有老调用方不受影响</li>
<li>不存在"遗漏某个调用方"的问题</li>
</ul>
<p><strong>4. 职责清晰，独立演进</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">queryProductList</span>()       <span class="hljs-comment">// 服务 Web端和老调用方，未来加推荐、短视频</span>
<span class="hljs-built_in">queryProductListForPc</span>()  <span class="hljs-comment">// 服务 PC端，未来加ERP、批量导入</span>

<span class="hljs-comment">// 两个方法各管各的，互不干扰</span>
</code></pre>
<p><strong>5. 性能优化，各取所需</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// Web 端调用：执行完整逻辑，耗时 200ms</span>
productFacade<span class="hljs-selector-class">.queryProductList</span>(request);  <span class="hljs-comment">// 含推荐、热度等</span>

<span class="hljs-comment">// PC 端调用：只查基础数据，耗时 10ms</span>
productFacade<span class="hljs-selector-class">.queryProductListForPc</span>(request);  <span class="hljs-comment">// 轻量级</span>

<span class="hljs-comment">// 老调用方（订单服务）：继续走原有逻辑</span>
productFacade<span class="hljs-selector-class">.queryProductList</span>(request);  <span class="hljs-comment">// 虽然有冗余查询，但向后兼容</span>
</code></pre>
<p><strong>6. 便于监控和问题排查</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 可以分别监控：</span>
<span class="hljs-comment">// - queryProductList 的调用量、耗时、错误率（Web端 + 老调用方）</span>
<span class="hljs-comment">// - queryProductListForPc 的调用量、耗时、错误率（PC端）</span>

<span class="hljs-comment">// 出问题时能快速定位是哪个端的调用</span>
</code></pre>
<h4 data-id="heading-8">缺点</h4>
<ul>
<li>Facade 接口方法数量增加（但每个方法职责更清晰）</li>
<li>存在一定程度的代码重复（但可以通过 Service 层复用解决）</li>
<li>存在认知成本，换个开发看到好几个获取商品列表的方法会有点困惑</li>
</ul>
<hr/>
<h2 data-id="heading-9">为什么我们的想法会不同？</h2>
<p>讨论到这里，我突然意识到一个问题：<strong>我们实际讨论的是扩展和组合。</strong></p>
<h3 data-id="heading-10">一个成功的组合案例：退款逻辑合并</h3>
<p>在我们的项目中，曾经进行过一次重构，把两条独立的退款逻辑成功合并到了一起，进行统一维护。</p>
<h4 data-id="heading-11">重构前的状态</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// PC 端退款逻辑（已稳定运行 1 年+）</span>
public class PcRefundService {
    public RefundResult <span class="hljs-built_in">refundForPc</span>(RefundRequest request) {
        <span class="hljs-comment">// 1. PC 端特有的审核流程（多级审批）</span>
        pcAuditService<span class="hljs-selector-class">.audit</span>(request);

        <span class="hljs-comment">// 2. 调用第三方支付退款</span>
        paymentGateway<span class="hljs-selector-class">.refund</span>(request);

        <span class="hljs-comment">// 3. PC 端特有的凭证生成</span>
        pcVoucherService<span class="hljs-selector-class">.generateVoucher</span>(request);

        <span class="hljs-comment">// 4. 同步到 ERP 系统</span>
        erpService<span class="hljs-selector-class">.syncRefund</span>(request);
    }
}

<span class="hljs-comment">// Web 端退款逻辑（已稳定运行 8 个月）</span>
public class WebRefundService {
    public RefundResult <span class="hljs-built_in">refundForWeb</span>(RefundRequest request) {
        <span class="hljs-comment">// 1. Web 端特有的风控检查</span>
        riskControlService<span class="hljs-selector-class">.check</span>(request);

        <span class="hljs-comment">// 2. 调用第三方支付退款（同样的支付网关）</span>
        paymentGateway<span class="hljs-selector-class">.refund</span>(request);

        <span class="hljs-comment">// 3. Web 端特有的积分返还</span>
        pointService<span class="hljs-selector-class">.returnPoints</span>(request);

        <span class="hljs-comment">// 4. 发送通知给用户</span>
        notificationService<span class="hljs-selector-class">.notify</span>(request);
    }
}
</code></pre>
<h4 data-id="heading-12">重构后的状态</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnifiedRefundService</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> RefundResult <span class="hljs-title">refund</span>(<span class="hljs-params">RefundRequest request</span>)</span> {
        <span class="hljs-comment">// 1. 根据来源执行不同的前置流程</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"pc"</span>.<span class="hljs-keyword">equals</span>(request.getSource())) {
            pcAuditService.audit(request);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"web"</span>.<span class="hljs-keyword">equals</span>(request.getSource())) {
            riskControlService.check(request);
        }

        <span class="hljs-comment">// 2. 通用的退款核心逻辑（提取出来）</span>
        paymentGateway.refund(request);

        <span class="hljs-comment">// 3. 根据来源执行不同的后置流程</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"pc"</span>.<span class="hljs-keyword">equals</span>(request.getSource())) {
            pcVoucherService.generateVoucher(request);
            erpService.syncRefund(request);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"web"</span>.<span class="hljs-keyword">equals</span>(request.getSource())) {
            pointService.returnPoints(request);
            notificationService.notify(request);
        }
    }
}
</code></pre>
<h4 data-id="heading-13">这次合并为什么成功？</h4>
<ul>
<li>两条退款逻辑都已经稳定运行很久，业务边界清晰</li>
<li>核心流程（调用支付网关）确实可以复用</li>
<li>合并后维护更方便，bug 修复只需改一处</li>
<li>新增其他端的退款（如 App 端）也很容易扩展</li>
</ul>
<p><strong>成功的关键前提：</strong></p>
<ol>
<li><strong>两条业务线都已经独立演进到稳定状态</strong></li>
<li><strong>业务边界已经清晰</strong></li>
<li><strong>确实发现了可复用的核心逻辑</strong></li>
<li><strong>这是对内的重构</strong>，不影响外部调用方</li>
</ol>
<hr/>
<h3 data-id="heading-14">当前场景：商品列表查询</h3>
<p>但这次商品列表查询是否满足组合条件呢？我认为<strong>不满足</strong>。</p>
<h4 data-id="heading-15">关键差异对比</h4>






























<table><thead><tr><th>维度</th><th>退款合并（成功的组合）</th><th>商品列表（当前场景）</th></tr></thead><tbody><tr><td><strong>阶段</strong></td><td>两条线都已经稳定运行很久</td><td>PC 端是全新需求，还没开始</td></tr><tr><td><strong>业务理解</strong></td><td>业务边界清晰，知道哪些可以复用</td><td>PC 端需求还不明确，可能会变</td></tr><tr><td><strong>复用价值</strong></td><td>确实有核心逻辑可以提取</td><td>只是都叫"商品列表"，实际逻辑差异大</td></tr><tr><td><strong>方向</strong></td><td>对内重构，优化内部结构</td><td>对外扩展，增加新能力</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-16">扩展 vs 组合的本质区别</h2>
<h3 data-id="heading-17">概念定义</h3>
<p><strong>扩展（Extension）- 对外增加能力</strong></p>
<ul>
<li><strong>目的</strong>：给系统增加新的对外能力</li>
<li><strong>时机</strong>：新需求、新业务线</li>
<li><strong>原则</strong>：各自独立，给予足够的演进空间</li>
<li><strong>示例</strong>：新增 PC 端商品列表接口</li>
</ul>
<p><strong>组合（Composition）- 对内优化结构</strong></p>
<ul>
<li><strong>目的</strong>：重构内部实现，消除重复</li>
<li><strong>时机</strong>：多条业务线稳定后，发现可复用模式</li>
<li><strong>原则</strong>：提取共性，保持灵活性</li>
<li><strong>示例</strong>：合并 PC 端和 Web 端的退款逻辑</li>
</ul>
<h3 data-id="heading-18">核心原则：先扩展，后组合</h3>
<p>退款逻辑的重构本质上也是<strong>先进行了扩展，然后再进行组合</strong>。</p>
<p><strong>为什么退款会先进行扩展？</strong></p>
<ol>
<li><strong>时间成本</strong> - 本质上还是两个独立的业务，如果在开发之初就尝试组合复用，会极大增加时间成本</li>
<li><strong>需求变化</strong> - 新的业务免不了调整，这时业务边界不清晰，很容易造成影响</li>
<li><strong>兼容成本</strong> - 如果在需求不清晰的时候就考虑兼容，很容易处处受限</li>
</ol>
<p><strong>为什么商品列表会让人考虑直接组合？</strong></p>
<ol>
<li><strong>业务逻辑简单</strong> - 本质就是一个 CRUD，兼容成本看起来很低</li>
<li><strong>需求变化小</strong> - 感觉不太会有太多的变化</li>
</ol>
<p>但实际上这两者是一样的，<strong>它们都是对外增加了新的能力</strong>，而不能因为业务简单就直接考虑进行组合。</p>
<hr/>
<h2 data-id="heading-19">总结</h2>
<p>这次 Code Review 让我明白了几个道理：</p>
<h3 data-id="heading-20">1. 不要混淆"对外扩展"和"对内组合"</h3>
<ul>
<li><strong>对外扩展时</strong>：优先考虑独立性和灵活性</li>
<li><strong>对内组合时</strong>：可以考虑复用和统一</li>
</ul>
<h3 data-id="heading-21">2. 不要过早组合</h3>
<ul>
<li>退款合并是成功的，因为是"<strong>先扩展，后组合</strong>"</li>
<li>如果在 PC 端商品列表刚立项时就组合，是"<strong>过早组合</strong>"</li>
</ul>
<h3 data-id="heading-22">3. 分阶段演进</h3>
<ol>
<li><strong>扩展期</strong>：新增独立接口，给予足够的演进空间</li>
<li><strong>稳定期</strong>：各自独立发展，积累业务理解</li>
<li><strong>组合期</strong>：发现可复用模式，进行内部重构</li>
</ol>
<h3 data-id="heading-23">4. 当前场景的决策</h3>
<ul>
<li><strong>现在</strong>：采用方案 B，新增独立的 <code>queryProductListForPc()</code> 方法</li>
<li><strong>未来</strong>：等 PC 端商品列表也稳定运行半年后，再评估是否需要组合</li>
<li><strong>原则</strong>：先让子弹飞一会儿，不要急着优化</li>
</ul>
<p><strong>最重要的是</strong>：扩展总不会错，不会影响老逻辑，尤其是在小公司快速迭代的环境下。</p>
<hr/>
<h3 data-id="heading-24">关注「9号达人」公众号，获取更多干货</h3>
<p>我是一名小厂程序员，专注分享<strong>真实的项目实战经验</strong>和<strong>接地气的技术思考</strong>。</p>
<p><strong>关注公众号「9号达人」</strong></p>
<p><strong>不讲大而全的理论，只聊真实踩过的坑。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🧸 前端不是只会写管理后台，我用 400 行代码画了一个 LABUBU ！]]></title>    <link>https://juejin.cn/post/7571846248719581184</link>    <guid>https://juejin.cn/post/7571846248719581184</guid>    <pubDate>2025-11-13T12:12:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7571846248719581184" data-draft-id="7572020278386917410" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🧸 前端不是只会写管理后台，我用 400 行代码画了一个 LABUBU ！"/> <meta itemprop="keywords" content="Canvas,Vue.js,TypeScript"/> <meta itemprop="datePublished" content="2025-11-13T12:12:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xiaohe0601"/> <meta itemprop="url" content="https://juejin.cn/user/3183831378302871"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🧸 前端不是只会写管理后台，我用 400 行代码画了一个 LABUBU ！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3183831378302871/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xiaohe0601
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-13T12:12:51.000Z" title="Thu Nov 13 2025 12:12:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252b3a}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px;color:#5e7ce0}.markdown-body h1{font-size:24px;margin-bottom:5px;margin-top:80px;position:relative;text-align:center}.markdown-body h2{font-size:20px;padding-bottom:12px;border-bottom:1px solid #dfe1e6}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px;margin-top:30px}.markdown-body h5{font-size:14px;margin-top:20px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #dfe1e6;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#ffeeed;color:#c73636;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#252b3a;background:#f8f8f8}.markdown-body a{position:relative;text-decoration:none;color:#5e7ce0;padding-right:18px;padding-bottom:4px}.markdown-body a[href^=http]:after{position:absolute;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:6px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAACCgAwAEAAAAAQAAACAAAAAAX7wP8AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAABWVJREFUWAnlVktsVFUY/s85997pC9BOTKxRWnEKsXWlxjWJj0RWJjrFAAXjAlewYWOkgauACVu7a2IiNUEyExM3yoZE3Wmi7qgPJthJBDE6JUNpO3Mf5/j95/bOTOcBlBgXejJ37rn/Of/7O/9/iP7vQ/zTAcjnC4ry+a5ii1OkiYTpuvjvEc0Gp51uivP+ZW+QBuSW4QjW5rptAa1Ey0uOGKOxwPetVyafN6p/52/PkNBbjdAhGaGEpMRjLZTryB8+9MUSYSGNRIcBvm8kBAY9tHYlHz78nTs392xIkwv9FA3Oe33bdoX1ZZKOS0bH0CXI6RugYLW6BwIu5gskkQ4sEG0wYF25PjBzbZfSYY6kDLUmWMt7FR7Lw3xYUkaTdjxHfTPnPwav0iEGYADVa9XIRIEyxrAA0jIQxgFL22gYwF7A8/DAzNVdksJvJaTEUZ2kYnZWziN5s1ADPHneEIXByotYuMSrf9JEbbsuv7VcvbaKML8plXtQR0EdIYDqWEmtOgAomZFH8EjWSnek2ulmtljljttHbmaIHCCCHzd9MjwfsmscBeZH9Jyd10nMvz92UQrtCBKvMF06mQy0SiEdRMEGg8mN0YjAlgoDDkPrMI5qJKSkKKydpbB2CZjJkhIBvOBw2CGQgii85bpx//dMqFRKam5uvH7w+K97oe+Cl0HO68uIBH0qyEzpOMwIbZIcFq0I+9cwoElizCjk2KFI1y7Nnx614W1db58fOXIlMzs7Xn/jeDmvBV2Q0mXjGf554O/m4LZHp2N8r61WPMvLZWLdiC4GMAk5BjeeB5lhv39l6+BIbu3m760hXMDKBD08XBKzR8fr04nygnIypOOAJUx/fHrsi0Mnys+vVK+V4VUohaiyPCo2Q9DFALvF/ikw8WS4QvVZALS5ksw47/7R8ejgTPk1UFqU6/3zp8bOM7B/kdu/fkguPGU5JibW+F0sTjWOUw8DklRrg4BiLGeBqbaRLxjlT4no0InFV402RcftJz41cH/f/JnHP3kZaaF6VX/liwist9vYG5+NU9Cg3MNkt/+lU5wS8fTxq3mc7ILjDlAE4CJpe89BOWPiIjBhi9O6PI4G1jsc6RGB3lZwmS76k8H0zOKTkFboG8jS2krFKCX2fvTeaPHIBwAkMHHgncURnL3nuCSnxSopdIzN5th0BIonJ0Lf9yUA9iMkzdRWl3BixOusfDcwQVcS4UKIFwYfGPnM8wY/DyP9NFMXaTE5BU39tGkDgGZz+fJJG0oYcSaOafLcqdECY4LzfSObSzyUOgxqtyisr8SSNOOAkubWoh3TTaeA2YtFEXPnm5x81/j+6MI6JqyS25WSNU6hbCMKHG84marJbdR+vwakRhQLRuQpbzHRLjmpmijI+OmWCtq+LzWtnX5v30gHSsqmWne74DtiACi2+Wz0iXbuLt9D2cDyoPEkWOiyp5XUIwLMi/wJY1FbH5B9ONtdC1KrsD/Q0MCQAS0wccILORDW25amAeOtooAj/KQxfzF17uwTSQ1v3dJ7jnLINwdZYRDa4tPU0sHVXFo/vxFF5BqFqxRfOmgPCk4ft2NgKTCy2Y47JIEg+MIhjYsLy5I25qUYTQlCjMRHsr/UwdYwIK33UO1J5fFNB9XNO6akcywJofVmXQDP2wfrSPcI2xG5BSs3I+IosHr4EtvO1TDAu16xHQq5+ykMblfRXLbhEoFIdDTBdhldvzl+3CMg60ZktI2vNzLW6IIp0waLklot9L63yzuUp8dJd7bglPFe3hIXstBEP58/s6Ocyr4rH2+866ZNbriTzA0RSOWCwakMl1QJgculxPt8Z7O5GLdtW6bvU8R/nO1vb+hMExVAVtEAAAAASUVORK5CYII=");background-size:100%}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #5e7ce0}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #5e7ce0;border-spacing:0}.markdown-body thead{color:#fff;text-align:left}.markdown-body thead tr{background:#5e7ce0}.markdown-body thead th{border-bottom:1px solid #dfe1e6}.markdown-body tr{background-color:#fff}.markdown-body tr:nth-child(2n){background-color:#f2f5fc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#252b3a;padding:1px 23px;margin:22px 0;border-left:4px solid #5e7ce0;background-color:#f2f5fc}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{padding-left:10px;margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5e7ce0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ul li::marker{content:"•";color:#5e7ce0}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body input[type=checkbox]:before{display:inline-block;width:16px;height:16px;content:"";background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAhRJREFUeAHtnLEuBFEUhs9cu7JCskEhIrZAgYZGoREPwBuIygOoPITKA6jEG/AAolFoaFCgICIKZBNiY8Pyz5rNOWe9wNz5T7N3Z2eT/b/7zZlpziat3xKWBDJoEyh5EDd3DTk5r8vV7Yc8vzbl6zvfwvSERIYHyzI90SeLc1WZrFV85PR9oi+N/YMnOT6t/3tiLAeXFqqytjrSFacDYmfvQS6u37tOiPHA7FS/bK6PmWhpj4AJRYGA9MiKzLpK6An+cqiNVmRleUhArrec6PNzt/5sttLgh0cvcvfY6Px+ZNY9I6Ax6gKErY1xmZ8ZyD0E5MJGIgsyIZsunT3g7qALJuTdAp0nWyMTsunS2QNukbpwOcRaPpvOHvxzQow2ZBvrs+nsfLL8o0QQBJFdMO1XGkEjaIQlQCMsD/YIGkEjLAEaYXmwR9AIGmEJ0AjLgz2CRtAIS4BGWB7sETSCRlgCNMLyYI+gETTCEqARlgd7BI2gEZYAjbA82CNoBI2wBGiE5cEeQSNohCVAIywP9ggaQSMsARphebBH0AgaYQnQCMsjYC5SF2agYi2fTWcPGA7VFfO0n8+mswdMyOrCNJwnpz/P6xqZkE2Xzh4w8qcLI4Hbu/dydvkWBRAAQBZk0uOOyKyzp5PARRiF1puNtR+NTh+oMCvtJ+D8F2N6j6x+PrwzG46gRTDDm5BtsAGBg0X924Qfj7i23p7HNgQAAAAASUVORK5CYII=");background-size:100%;position:relative;right:2px;top:-5px}.markdown-body input[type=checkbox]:checked:before{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABCCAYAAADjVADoAAAK2GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU9kWhs+96Y0WiHRC70gngJTQQxGkg6iEJJBQYkgIKmJnUMGxoCKCZcSKKFhGQMaCWLANAopdJ8igoD4HC6Ki5t3AI8zMW++99fZaJ+dbO/vss/e55671XwAoYWyRKBdWAyBPWCCODQ2gJ6ek0nHPAQRgQAI2wIHNkYiYMTGRALHJ+a/28S4Sjdhte0Wuf///v5oGlyfhAAClIZzBlXDyEG5DxkuOSFwAAOoI4jddUCBScBfCmmKkQIR/V3DWBH9ScMY4o8njMfGxgQjTAcCT2WxxFgBkO8RPL+RkIXnIih4chVyBEOFihH05fDYX4TMI2+XlzVfwIMJWSLwIAApyOoCR8aecWX/Jn6HMz2ZnKXmir3HDBwkkolz2ov/zaP635eVKJ/ewQAaZLw6LVeyHnN/9nPkRShZmzIyeZAF3oiYF86VhCZPMkQSmTjKXHRShXJs7M3KSMwUhLGWeAlb8JPMkwXGTLJ4fq9wrUxzInGS2eHxfIsIyaU6C0s/nsZT5i/jxSZNcKEicOcmSnLiIqZhApV8sjVXWzxOGBkztG6LsPU/yp34FLOXaAn58mLJ39lT9PCFzKqckWVkblxcUPBWToIwXFQQo9xLlxijjebmhSr+kME65tgC5nFNrY5RnmM0Oj5lkIABRgA04dNVJAqCAt7BA0UjgfNEisSCLX0BnIm8bj84Schzs6M6Ozs4AKN7dievwnjb+TkK061O+NYjHr10ul5+e8oUi9/i4KfJYbk35LCsAUNUD4Op+jlRcOOFDK34wyNNTBZpABxgCU2AF7IEzcAfewB8Eg3AQDeJBCpiL1MoHeUAMFoBisAKUgnKwEWwF1WA32AsOgaPgBGgGZ8AFcAXcAF2gFzwCMjAAXoFh8BGMQRCEgygQFdKBjCBzyBZyhhiQLxQMRUKxUAqUDmVBQkgKFUOroHKoAqqG9kB10HHoNHQBugZ1Qw+gPmgIegd9gVEwGdaEDWALeDrMgJlwBBwPz4Gz4Hy4CC6B18NVcC18BG6CL8A34F5YBr+CR1AARULRUMYoexQDFYiKRqWiMlFi1FJUGaoSVYtqQLWiOlC3UTLUa9RnNBZNRdPR9mhvdBg6Ac1B56OXotehq9GH0E3oS+jb6D70MPo7hoLRx9hivDAsTDImC7MAU4qpxBzAnMJcxvRiBjAfsVgsDWuJ9cCGYVOw2djF2HXYndhGbBu2G9uPHcHhcDo4W5wPLhrHxhXgSnHbcUdw53E9uAHcJzwJb4R3xofgU/FC/Ep8Jf4w/hy+B/8CP0ZQI5gTvAjRBC5hEWEDYR+hlXCLMEAYI6oTLYk+xHhiNnEFsYrYQLxMfEx8TyKRTEiepFkkAWk5qYp0jHSV1Ef6TNYg25ADyWlkKXk9+SC5jfyA/J5CoVhQ/CmplALKekod5SLlKeWTClXFQYWlwlVZplKj0qTSo/JGlaBqrspUnatapFqpelL1luprNYKahVqgGlttqVqN2mm1e2oj6lR1J/Vo9Tz1deqH1a+pD2rgNCw0gjW4GiUaezUuavRTUVRTaiCVQ11F3Ue9TB3QxGpaarI0szXLNY9qdmoOa2louWolai3UqtE6qyWjoWgWNBYtl7aBdoJ2l/ZlmsE05jTetLXTGqb1TBvV1tP21+Zpl2k3avdqf9Gh6wTr5Ohs0mnWeaKL1rXRnaW7QHeX7mXd13qaet56HL0yvRN6D/VhfRv9WP3F+nv1b+qPGBgahBqIDLYbXDR4bUgz9DfMNtxieM5wyIhq5GskMNpidN7oJV2LzqTn0qvol+jDxvrGYcZS4z3GncZjJpYmCSYrTRpNnpgSTRmmmaZbTNtNh82MzKLMis3qzR6aE8wZ5nzzbeYd5qMWlhZJFqstmi0GLbUtWZZFlvWWj60oVn5W+Va1VnessdYM6xzrndZdNrCNmw3fpsbmli1s624rsN1p222HsfO0E9rV2t2zJ9sz7Qvt6+37HGgOkQ4rHZod3kw3m546fdP0junfHd0ccx33OT5y0nAKd1rp1Or0ztnGmeNc43zHheIS4rLMpcXlrautK891l+t9N6pblNtqt3a3b+4e7mL3BvchDzOPdI8dHvcYmowYxjrGVU+MZ4DnMs8znp+93L0KvE54/eFt753jfdh7cIblDN6MfTP6fUx82D57fGS+dN903598ZX7Gfmy/Wr9n/qb+XP8D/i+Y1sxs5hHmmwDHAHHAqYDRQK/AJYFtQaig0KCyoM5gjeCE4OrgpyEmIVkh9SHDoW6hi0PbwjBhEWGbwu6xDFgcVh1rONwjfEn4pQhyRFxEdcSzSJtIcWRrFBwVHrU56vFM85nCmc3RIJoVvTn6SYxlTH7ML7Ows2Jm1cx6HusUWxzbEUeNmxd3OO5jfED8hvhHCVYJ0oT2RNXEtMS6xNGkoKSKJFny9OQlyTdSdFMEKS2puNTE1AOpI7ODZ2+dPZDmllaadneO5ZyFc67N1Z2bO/fsPNV57Hkn0zHpSemH07+yo9m17JEMVsaOjGFOIGcb5xXXn7uFO8Tz4VXwXmT6ZFZkDmb5ZG3OGuL78Sv5rwWBgmrB2+yw7N3ZoznROQdz5LlJuY15+Lz0vNNCDWGO8NJ8w/kL53eLbEWlIlm+V/7W/GFxhPiABJLMkbQUaCIi6abUSvqDtK/Qt7Cm8NOCxAUnF6ovFC68uchm0dpFL4pCivYvRi/mLG4vNi5eUdy3hLlkz1JoacbS9mWmy0qWDSwPXX5oBXFFzopfVzqurFj5YVXSqtYSg5LlJf0/hP5QX6pSKi69t9p79e416DWCNZ1rXdZuX/u9jFt2vdyxvLL86zrOuus/Ov1Y9aN8feb6zg3uG3ZtxG4Ubry7yW/ToQr1iqKK/s1Rm5u20LeUbfmwdd7Wa5Wulbu3EbdJt8mqIqtatptt37j9azW/urcmoKZxh/6OtTtGd3J39uzy39Ww22B3+e4vPwl+ur8ndE9TrUVt5V7s3sK9z/cl7uvYz9hfd0D3QPmBbweFB2WHYg9dqvOoqzusf3hDPVwvrR86knak62jQ0ZYG+4Y9jbTG8mPgmPTYy+Ppx++eiDjRfpJxsuFn8593nKKeKmuCmhY1DTfzm2UtKS3dp8NPt7d6t576xeGXg2eMz9Sc1Tq74RzxXMk5+fmi8yNtorbXF7Iu9LfPa390MfninUuzLnVejrh89UrIlYsdzI7zV32unrnmde30dcb15hvuN5puut089avbr6c63Tubbnncauny7GrtntF9rsev58LtoNtX7rDu3Oid2dt9N+Hu/Xtp92T3ufcHH+Q+ePuw8OHYo+WPMY/Lnqg9qXyq/7T2N+vfGmXusrN9QX03n8U9e9TP6X/1u+T3rwMlzynPK18YvagbdB48MxQy1PVy9suBV6JXY69L/6H+jx1vrN78/If/HzeHk4cH3orfyt+te6/z/uAH1w/tIzEjTz/mfRwbLfuk8+nQZ8bnji9JX16MLfiK+1r1zfpb6/eI74/leXK5iC1mj0sBFDLgzEwA3h1EtHEKAFRElxNnT2jrcYMmvgfGCfwnntDf4+YOQAMyKWQR0x+Akwo5i8wqyKyQRPH+AHZxUY5/mSTTxXkiFxlRlphPcvl7AwBwrQB8E8vlYzvl8m/7kGIfANCWP6HpFYZFtHyD3vJRg6LbPe3g7zah9//U499noKjAFfx9/ieoZhkWVvYkwwAAAGxlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAKgAgAEAAAAAQAAAEKgAwAEAAAAAQAAAEIAAAAAgodoEQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAABMtJREFUeAHtXM2KFDEQzrQKruIu4mEXRFlUVLz4A4K7B99AcO8io0/gwQfxDVzFuwu+gQf34EG8iOAPKAh6EFlBFMSf/qa2uqszlVR6ZtYxM5PDJNVVSer78nU6KrHzpyxuVlwx44AY2O0T8eb9D7f5fMu9fPvdff7y0/36nbdgdhUdd+jgHnf62JxbObvgjh/d60Pu2R35ajx49Mk9frqlBk7Kw8sXF9y1K4t9cCoi7tz/4F68/tYXMIkPzpzY725dP9yA1tsjoIRpIQHogRWYZSmwJ4Reh06nI2Nd7rYEA8zAzqXAxhgq/pc1d9vHKbEX+Dr4JbzypJDc/YxXYi/wifRLeOXpU5q7n/FK7EXsnBBeeRoqd7/EHj1ZhleeiMjdz8pArRKR+0pb+UsCuK0SkftKW/kzeFmrRHCAxWzufsaJOkqExWzufpOI8EpP1jnCJCK80pN1jjCJ4ICwMigidz/jRD3bI7bZUInIfaWt/KUSuK0SEd4jqFvufgYva5UIDrCYzd3POFFHifhfV/7k8lwPw7D5mUSEV3r854ju2pK7ffOIWzk/X+Go803Lr+ooGqoiwkyP9xzRXVt0q9sE3CgJYTLqfNPyE/irpkoEe2um6ck4bSiBSeD8JBl41jY/Hgd1lIiaaeoyLlsjgUGAjEH3DB4DtUpEW2Z3Mj5GAgA8efbVvXpX/200nln5IMYvKhHDrvylcwdc9+pSNdeg46WQsP7wo2s7fpWYaPT926fw9ZiVk4BpywYJkGuvlJs4EuWS0p/HTyHh3kbzH2najM85cR0lgpPiYMtukFB26m1u5Ua+vkFkWP3Zn0KCJDg1Px6f42Wtvhrhdyz8ncanrFKCmGH1wrwDMCrh/uxPIUFTAvdHbeVPsc1fVRE+c7Ud/k6fWt7XHFlYqcqQ5wTRvWpiY4wrIZwfDUL+akDRUBXB/jCzFCH9SHCzTDRUmsro7z+cEvrHwxOZn2ZTL/pVFcEBtRLoiWXfxQ5ehvoHHx4vpIwUEuJKSMvPz5/zQq0qwmIy5m+rjBQSwnsCQYnlgwjfT72av6oifOba2qnKcOXeGVIP0rT3BALTNr8mBWSpRHAgmJSTtLGhDHwj+A9GPCbX2DNiBSRoShg0H8zl5y/njxIhJ0WntralDJmIbO+UEvz85Zwt9wj7HIDB5Ttp7RkyGbRDSqC49vOjX50P9aexmr+qInzmajvtO13H02SpyrCVMNj8dT7/4BwByDXzRIC0LWXEldA/njVfip9GpV9VERxQM0lPhrVDyrCVMJr5/fwZJ+qWewR1lSuNJ21sXxnjVgIhck5VhM/cqG1WBpIAMX4Z9Xz+eP58sFUiOBArLQcZpQ0CNCXt1HzA5OfPOFGrrwYHyKTwbNJsxolaJUJbKeo0mu/4uMeXBHBbJSK88qP5jo97fAYva5UIDgivHEXk7mecqKNEhFeOhsjdbxKR+0pb+UsCuK0qIveVtvJn8LJWieAAi9nc/YwTdZQIi9nc/SYR4ZWenSO2yZvgcwTuRYZKWBnUI3e/xF7gcmio5L4HWPlL7AVuyPol95W28me8EnuBa8J+sZjM3c94JfYCd6VxTXjaCjDLe+K9cwTuSuOa8LQUYPXvh1d3w0HC7JK8kMK0/rcJfwHkVMYgi4xhOgAAAABJRU5ErkJggg==");background-size:100%}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>注意看，这个男人叫小何，别小看他，每天晚上 9 点 59 分他都准时打开泡泡玛特小程序蹲守 LABUBU 抢购。就在刚才，屏幕时钟倒计时又到 00:00:00 了，他立刻开始狂戳屏幕上的「立即购买」按钮，切换「购买方式」反复刷新库存，熟练的让人心疼。</p>
<p>可是，现实却从来没有什么“功夫不负有心人”，有的只是无数“黄牛”挥舞着自己的“科技”与小何同台竞技。毫无意外，今天的小何依然没有胜利，看着屏幕上的「已售罄」陷入了沉思 ……</p>
<p><strong>拼尽全力也无法战胜吗？</strong></p>
<p>空气里漂泊着手机屏幕反射的冷光，小何指尖的汗渍在「已售罄」三个字上洇出淡淡的印子。屏幕里 LABUBU 的笑脸还在倔强 —— 那只顶着毛茸茸耳朵、圆眼圆腮的小家伙，本该是用来治愈生活的，此刻却成了科技与欲望“厮杀”后，留给普通人的一道冷疤。</p>
<p>技术从来都该是温柔的，当“黄牛”用它筑起壁垒时，或许我该用同样的东西，造一扇窗！</p>
<p>我是一名前端开发工程师，不是切图仔，不是只会写管理后台，今天势必要夺回失去的一切！</p>
<p>是的，我画了一个专属于自己的 LABUBU ！</p>
<p>👉 在线体验：<a href="https://link.juejin.cn?target=https%3A%2F%2Flabubu.xiaohe.ink" target="_blank" title="https://labubu.xiaohe.ink" ref="nofollow noopener noreferrer">labubu.xiaohe.ink</a></p>
<h2 data-id="heading-0">✍️ 开始创作</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.leaferjs.com" target="_blank" title="https://www.leaferjs.com" ref="nofollow noopener noreferrer">LeaferJS</a> 是一款好用的 Canvas 引擎，革新的开发体验，可用于高效绘图 、UI 交互、图形编辑。</p>
<p>而 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FFliPPeDround%2Fleafer-vue" target="_blank" title="https://github.com/FliPPeDround/leafer-vue" ref="nofollow noopener noreferrer">Leafer Vue</a> 是由 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FFliPPeDround" target="_blank" title="https://github.com/FliPPeDround" ref="nofollow noopener noreferrer">@FliPPeDround</a> 基于 LeaferJS 创建的项目，可以使用 Vue 组件化轻松构建 Leafer 应用，具有以下特性：</p>
<ul>
<li>使用 Vue 构建 Leafer 应用，高性能</li>
<li>生态统一，完全兼容 Leafer 插件</li>
<li>由 TypeScript 编写，提供强大的类型支持</li>
<li>提供在线演练场，即开即用、畅享创作</li>
</ul>
<p>现在，我们将使用 Leafer Vue 一起来完成这个作品！</p>
<h3 data-id="heading-1">一半茶叶蛋</h3>
<p>首先是 LABUBU 的脑袋，看起来有点像被切开的茶叶蛋，可以用两段二次贝塞尔曲线来绘制一个非对称椭圆表示。</p>
<p>我们先编写 <code>createBezierEllipsePath</code> 工具方法，用于生成更自然流畅的椭圆路径：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PathCreator</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"leafer-ui"</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">/**
 * 以控制点 cp 为中心反射生成点 p 关于它的对称点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reflect</span>(<span class="hljs-params">p: Point, cp: Point</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">x</span>: p.<span class="hljs-property">x</span> + (p.<span class="hljs-property">x</span> - cp.<span class="hljs-property">x</span>),
    <span class="hljs-attr">y</span>: p.<span class="hljs-property">y</span> + (p.<span class="hljs-property">y</span> - cp.<span class="hljs-property">y</span>)
  };
}

<span class="hljs-comment">/**
 * 创建非对称椭圆路径
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createBezierEllipsePath</span>(<span class="hljs-params">p1: Point, p2: Point, ox: <span class="hljs-built_in">number</span>, oy: <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">const</span> cp1 = { <span class="hljs-attr">x</span>: p1.<span class="hljs-property">x</span> + ox, <span class="hljs-attr">y</span>: p1.<span class="hljs-property">y</span> + oy };
  <span class="hljs-keyword">const</span> cp2 = { <span class="hljs-attr">x</span>: p2.<span class="hljs-property">x</span> - ox, <span class="hljs-attr">y</span>: p2.<span class="hljs-property">y</span> + oy };

  <span class="hljs-comment">// 通过反射生成另外两个控制点</span>
  <span class="hljs-keyword">const</span> cp3 = <span class="hljs-title function_">reflect</span>(p2, cp2);
  <span class="hljs-keyword">const</span> cp4 = <span class="hljs-title function_">reflect</span>(p1, cp1);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
    .<span class="hljs-title function_">moveTo</span>(p1.<span class="hljs-property">x</span>, p1.<span class="hljs-property">y</span>)
    <span class="hljs-comment">// 第 1 段贝塞尔曲线</span>
    .<span class="hljs-title function_">bezierCurveTo</span>(cp1.<span class="hljs-property">x</span>, cp1.<span class="hljs-property">y</span>, cp2.<span class="hljs-property">x</span>, cp2.<span class="hljs-property">y</span>, p2.<span class="hljs-property">x</span>, p2.<span class="hljs-property">y</span>)
    <span class="hljs-comment">// 第 2 段贝塞尔曲线</span>
    .<span class="hljs-title function_">bezierCurveTo</span>(cp3.<span class="hljs-property">x</span>, cp3.<span class="hljs-property">y</span>, cp4.<span class="hljs-property">x</span>, cp4.<span class="hljs-property">y</span>, p1.<span class="hljs-property">x</span>, p1.<span class="hljs-property">y</span>)
    .<span class="hljs-title function_">closePath</span>()
    .<span class="hljs-property">path</span>;
}
</code></pre>
<p>然后调用 <code>createBezierEllipsePath</code> 创建头部和脸部的路径：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> headPath = <span class="hljs-title function_">createBezierEllipsePath</span>(
  { <span class="hljs-attr">x</span>: <span class="hljs-number">40</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">240</span> },
  { <span class="hljs-attr">x</span>: <span class="hljs-number">260</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">240</span> },
  <span class="hljs-number">28</span>,
  -<span class="hljs-number">120</span>
);

<span class="hljs-keyword">const</span> facePath = <span class="hljs-title function_">createBezierEllipsePath</span>(
  { <span class="hljs-attr">x</span>: <span class="hljs-number">60</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">260</span> },
  { <span class="hljs-attr">x</span>: <span class="hljs-number">240</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">260</span> },
  -<span class="hljs-number">10</span>,
  <span class="hljs-number">80</span>
);
</code></pre>
<p>使用 <code>Path</code> 标签传入路径，再加上填充色和描边：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 头 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"headPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#984628"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 脸 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"facePath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffd9d0"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>
</code></pre>
<p>✨ 脑袋部分完成啦！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/00d2a1413203464cb754109681e48d4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=vN0%2BfjPZM43VfbpHBJjEWa2kNiw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">一个魔丸</h3>
<p>画好了脑袋，现在开始画五官。光看五官 LABUBU 跟“魔丸”哪吒是不是有点神似？哪吒和泡泡玛特甚至推出过联名款！</p>
<p>眼睛画起来很简单，直接使用 <code>Ellipse</code> 标签绘制几个椭圆组合起来就好，至于眉毛就用 <code>Line</code> 标签画一条曲线吧 ～</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 左眼白 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"93"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"228"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"40"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"60"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#f9f9f9"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左上眼睑 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"96"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"206"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"44"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"26"</span>
  <span class="hljs-attr">:rotation</span>=<span class="hljs-string">"10"</span>
  <span class="hljs-attr">:start-angle</span>=<span class="hljs-string">"20"</span>
  <span class="hljs-attr">:end-angle</span>=<span class="hljs-string">"154"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffd9d0"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左眉毛 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Line</span>
  <span class="hljs-attr">:points</span>=<span class="hljs-string">"[96, 226, 104, 233, 124, 235, 134, 232]"</span>
  <span class="hljs-attr">curve</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
  <span class="hljs-attr">stroke-cap</span>=<span class="hljs-string">"round"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Line</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左眼球 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"100"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"242"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"28"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"45"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#000000"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左眼光 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"111"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"245"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"6"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"10"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffffff"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右眼白 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"165"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"228"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"40"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"60"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#f9f9f9"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右上眼睑 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"158"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"214"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"44"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"26"</span>
  <span class="hljs-attr">:rotation</span>=<span class="hljs-string">"-10"</span>
  <span class="hljs-attr">:start-angle</span>=<span class="hljs-string">"24"</span>
  <span class="hljs-attr">:end-angle</span>=<span class="hljs-string">"158"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffd9d0"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右眉毛 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Line</span>
  <span class="hljs-attr">:points</span>=<span class="hljs-string">"[164, 232, 176, 236, 194, 233, 202, 226]"</span>
  <span class="hljs-attr">curve</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
  <span class="hljs-attr">stroke-cap</span>=<span class="hljs-string">"round"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Line</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右眼球 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"171"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"242"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"28"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"45"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#000000"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右眼光 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"181"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"245"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"6"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"10"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffffff"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>
</code></pre>
<p>鼻子也是一个非对称椭圆，可以用之前编写的 <code>createBezierEllipsePath</code> 创建一个小小的椭圆：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> nosePath = <span class="hljs-title function_">createBezierEllipsePath</span>(
  { <span class="hljs-attr">x</span>: <span class="hljs-number">141</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">275</span> },
  { <span class="hljs-attr">x</span>: <span class="hljs-number">157</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">275</span> },
  <span class="hljs-number">2</span>,
  <span class="hljs-number">9</span>
);
</code></pre>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 鼻子 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"nosePath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ff0154"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>
</code></pre>
<p>嘴巴是一条 0.76 曲率的曲线，使用 <code>Path</code> 标签的 <code>curve</code> 参数可以轻松实现。</p>
<p>但是牙齿画起来就比较麻烦了，因为要紧密贴合嘴巴曲线，所以我们需要编写一个方法将嘴巴的曲率转换为三次贝塞尔曲线，再根据传入牙齿的数量和大小沿曲线切线方向排布并生成对应的路径数组。</p>
<p>方法的具体实现如下：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 嘴巴曲线</span>
<span class="hljs-keyword">const</span> mouthPoints = [<span class="hljs-number">76</span>, <span class="hljs-number">266</span>, <span class="hljs-number">150</span>, <span class="hljs-number">304</span>, <span class="hljs-number">224</span>, <span class="hljs-number">266</span>];
<span class="hljs-comment">// 嘴巴曲率</span>
<span class="hljs-keyword">const</span> mouthCurve = <span class="hljs-number">0.76</span>;

<span class="hljs-comment">/**
 * 创建牙齿路径
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createTeethPaths</span>(<span class="hljs-params">
  count: <span class="hljs-built_in">number</span>,
  toothWidth: <span class="hljs-built_in">number</span>,
  toothHeight: <span class="hljs-built_in">number</span>,
  curve: <span class="hljs-built_in">number</span>
</span>) {
  <span class="hljs-keyword">const</span> p1 = { <span class="hljs-attr">x</span>: mouthPoints[<span class="hljs-number">0</span>], <span class="hljs-attr">y</span>: mouthPoints[<span class="hljs-number">1</span>] };
  <span class="hljs-keyword">const</span> c0 = { <span class="hljs-attr">x</span>: mouthPoints[<span class="hljs-number">2</span>], <span class="hljs-attr">y</span>: mouthPoints[<span class="hljs-number">3</span>] };
  <span class="hljs-keyword">const</span> p2 = { <span class="hljs-attr">x</span>: mouthPoints[<span class="hljs-number">4</span>], <span class="hljs-attr">y</span>: mouthPoints[<span class="hljs-number">5</span>] };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">lerp</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, t: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-keyword">return</span> a + (b - a) * t;
  }

  <span class="hljs-comment">// 贝塞尔曲线中间控制点</span>
  <span class="hljs-keyword">const</span> c1 = {
    <span class="hljs-attr">x</span>: <span class="hljs-title function_">lerp</span>(p1.<span class="hljs-property">x</span>, c0.<span class="hljs-property">x</span>, <span class="hljs-number">0.5</span>) - curve * <span class="hljs-number">20</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-title function_">lerp</span>(p1.<span class="hljs-property">y</span>, c0.<span class="hljs-property">y</span>, <span class="hljs-number">0.5</span>) + curve * <span class="hljs-number">43</span>
  };
  <span class="hljs-keyword">const</span> c2 = {
    <span class="hljs-attr">x</span>: <span class="hljs-title function_">lerp</span>(c0.<span class="hljs-property">x</span>, p2.<span class="hljs-property">x</span>, <span class="hljs-number">0.5</span>) + curve * <span class="hljs-number">20</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-title function_">lerp</span>(c0.<span class="hljs-property">y</span>, p2.<span class="hljs-property">y</span>, <span class="hljs-number">0.5</span>) + curve * <span class="hljs-number">43</span>
  };

  <span class="hljs-comment">/**
   * 三次贝塞尔计算
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cubic</span>(<span class="hljs-params">t: <span class="hljs-built_in">number</span></span>): [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] {
    <span class="hljs-keyword">return</span> [
      (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">3</span> * p1.<span class="hljs-property">x</span> + <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">2</span> * t * c1.<span class="hljs-property">x</span> + <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) * t ** <span class="hljs-number">2</span> * c2.<span class="hljs-property">x</span> + t ** <span class="hljs-number">3</span> * p2.<span class="hljs-property">x</span>,
      (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">3</span> * p1.<span class="hljs-property">y</span> + <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">2</span> * t * c1.<span class="hljs-property">y</span> + <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) * t ** <span class="hljs-number">2</span> * c2.<span class="hljs-property">y</span> + t ** <span class="hljs-number">3</span> * p2.<span class="hljs-property">y</span>
    ];
  }

  <span class="hljs-comment">/**
   * 贝塞尔切线
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">derivative</span>(<span class="hljs-params">t: <span class="hljs-built_in">number</span></span>): [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] {
    <span class="hljs-keyword">return</span> [
      <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">2</span> * (c1.<span class="hljs-property">x</span> - p1.<span class="hljs-property">x</span>) + <span class="hljs-number">6</span> * (<span class="hljs-number">1</span> - t) * t * (c2.<span class="hljs-property">x</span> - c1.<span class="hljs-property">x</span>) + <span class="hljs-number">3</span> * t ** <span class="hljs-number">2</span> * (p2.<span class="hljs-property">x</span> - c2.<span class="hljs-property">x</span>),
      <span class="hljs-number">3</span> * (<span class="hljs-number">1</span> - t) ** <span class="hljs-number">2</span> * (c1.<span class="hljs-property">y</span> - p1.<span class="hljs-property">y</span>) + <span class="hljs-number">6</span> * (<span class="hljs-number">1</span> - t) * t * (c2.<span class="hljs-property">y</span> - c1.<span class="hljs-property">y</span>) + <span class="hljs-number">3</span> * t ** <span class="hljs-number">2</span> * (p2.<span class="hljs-property">y</span> - c2.<span class="hljs-property">y</span>)
    ];
  }

  <span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>[][] = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i += <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">const</span> t = i / (count - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">const</span> [cx, cy] = <span class="hljs-title function_">cubic</span>(t);
    <span class="hljs-keyword">const</span> [dx, dy] = <span class="hljs-title function_">derivative</span>(t);

    <span class="hljs-keyword">const</span> length = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(dx * dx + dy * dy);

    <span class="hljs-comment">// 法向量</span>
    <span class="hljs-keyword">const</span> nx = -dy / length;
    <span class="hljs-keyword">const</span> ny = dx / length;

    <span class="hljs-keyword">const</span> halfWidth = toothWidth / <span class="hljs-number">2</span>;

    <span class="hljs-keyword">const</span> x1 = cx - halfWidth * dx / length;
    <span class="hljs-keyword">const</span> y1 = cy - halfWidth * dy / length;
    <span class="hljs-keyword">const</span> x2 = cx + halfWidth * dx / length;
    <span class="hljs-keyword">const</span> y2 = cy + halfWidth * dy / length;

    <span class="hljs-keyword">const</span> xt = cx + toothHeight * nx;
    <span class="hljs-keyword">const</span> yt = cy + toothHeight * ny;

    <span class="hljs-keyword">const</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
      .<span class="hljs-title function_">moveTo</span>(x1, y1)
      .<span class="hljs-title function_">quadraticCurveTo</span>(xt, yt, x2, y2)
      .<span class="hljs-title function_">closePath</span>()
      .<span class="hljs-property">path</span>;

    value.<span class="hljs-title function_">push</span>(path);
  }

  <span class="hljs-keyword">return</span> value;
}

<span class="hljs-keyword">const</span> teethPaths = <span class="hljs-title function_">createTeethPaths</span>(<span class="hljs-number">11</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, mouthCurve);
</code></pre>
<p>然后使用 <code>v-for</code> 循环生成牙齿：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 嘴巴 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Line</span>
  <span class="hljs-attr">:points</span>=<span class="hljs-string">"mouthPoints"</span>
  <span class="hljs-attr">:curve</span>=<span class="hljs-string">"mouthCurve"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
  <span class="hljs-attr">stroke-cap</span>=<span class="hljs-string">"round"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Line</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 牙齿 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in teethPaths"</span>
  <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"item"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffffff"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>
</code></pre>
<p>🥳 我们完成了整个作品中最困难的部分！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/19eccd5b6bb540edb0cc21d94348aeca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=tO3sSacn2g8OMqQE5WAsycU47Xc%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">滑稽兔耳朵</h3>
<p>LABUBU 的耳朵跟滑稽兔很像，画起来也比较容易，用 <code>Ellipse</code> 标签绘制两个纵向的扁椭圆：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 左耳 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"74"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"56"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"65"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"150"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#984628"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右耳 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"156"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"56"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"65"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"150"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#984628"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc5b4c5587354fe0813e9ecffa3aa030~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=DBUSGrp4UoXIii96EPbNCL6hQJQ%3D" alt="" loading="lazy"/></p>
<p>再用两个 <code>Ellipse</code> 标签绘制不同颜色的小椭圆表示内耳和耳蜗：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 左内耳 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"82"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"72"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"50"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"120"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffd9d0"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左耳蜗 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"95"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"118"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"26"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"60"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffbbbf"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右内耳 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"164"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"72"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"50"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"120"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffd9d0"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右耳蜗 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Ellipse</span>
  <span class="hljs-attr">:x</span>=<span class="hljs-string">"176"</span>
  <span class="hljs-attr">:y</span>=<span class="hljs-string">"118"</span>
  <span class="hljs-attr">:width</span>=<span class="hljs-string">"26"</span>
  <span class="hljs-attr">:height</span>=<span class="hljs-string">"60"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffbbbf"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"2"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ellipse</span>&gt;</span>
</code></pre>
<p>🐰 整个头部都完成啦！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a45aa3d38ef4a2da5902df412e5dc7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=V6jRgIAbBvnaOuq4hUd7EijAUe0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">像个布娃娃</h3>
<p>身体部分需要花一些心思，我们这里使用两段二次贝塞尔曲线（手臂）和两段三次贝塞尔曲线（腿）组合完成：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> bodyPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
  .<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">84</span>, <span class="hljs-number">316</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">40</span>, <span class="hljs-number">374</span>, <span class="hljs-number">90</span>, <span class="hljs-number">368</span>)
  .<span class="hljs-title function_">bezierCurveTo</span>(<span class="hljs-number">74</span>, <span class="hljs-number">460</span>, <span class="hljs-number">140</span>, <span class="hljs-number">440</span>, <span class="hljs-number">147</span>, <span class="hljs-number">430</span>)
  .<span class="hljs-title function_">bezierCurveTo</span>(<span class="hljs-number">154</span>, <span class="hljs-number">444</span>, <span class="hljs-number">224</span>, <span class="hljs-number">454</span>, <span class="hljs-number">204</span>, <span class="hljs-number">368</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">254</span>, <span class="hljs-number">374</span>, <span class="hljs-number">210</span>, <span class="hljs-number">316</span>)
  .<span class="hljs-title function_">closePath</span>()
  .<span class="hljs-property">path</span>;
</code></pre>
<p>再加上填充色和描边就形成了身体：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 身体 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"bodyPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#984628"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>
</code></pre>
<p>🐻 是不是很像一个布娃娃？可爱捏！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcced7cf41ff44b4be531297163731bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=eXdN3x7RAV6%2BaYWhd2wkUfUB0Fs%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">加上小手和小脚</h3>
<p>终于到了作品的最后一部分，使用多段二次贝塞尔曲线组合绘制出 LABUBU 的小手和小脚：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> leftHandPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
  .<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">68</span>, <span class="hljs-number">352</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">48</span>, <span class="hljs-number">348</span>, <span class="hljs-number">59</span>, <span class="hljs-number">360</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">42</span>, <span class="hljs-number">372</span>, <span class="hljs-number">58</span>, <span class="hljs-number">370</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">50</span>, <span class="hljs-number">386</span>, <span class="hljs-number">66</span>, <span class="hljs-number">372</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">68</span>, <span class="hljs-number">392</span>, <span class="hljs-number">76</span>, <span class="hljs-number">366</span>)
  .<span class="hljs-title function_">closePath</span>()
  .<span class="hljs-property">path</span>;

<span class="hljs-keyword">const</span> rightHandPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
  .<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">226</span>, <span class="hljs-number">352</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">246</span>, <span class="hljs-number">348</span>, <span class="hljs-number">235</span>, <span class="hljs-number">360</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">252</span>, <span class="hljs-number">372</span>, <span class="hljs-number">236</span>, <span class="hljs-number">370</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">244</span>, <span class="hljs-number">386</span>, <span class="hljs-number">228</span>, <span class="hljs-number">372</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">226</span>, <span class="hljs-number">392</span>, <span class="hljs-number">218</span>, <span class="hljs-number">366</span>)
  .<span class="hljs-title function_">closePath</span>()
  .<span class="hljs-property">path</span>;

<span class="hljs-keyword">const</span> leftFootPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
  .<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">104</span>, <span class="hljs-number">430</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">103</span>, <span class="hljs-number">456</span>, <span class="hljs-number">115</span>, <span class="hljs-number">444</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">122</span>, <span class="hljs-number">456</span>, <span class="hljs-number">128</span>, <span class="hljs-number">444</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">144</span>, <span class="hljs-number">456</span>, <span class="hljs-number">140</span>, <span class="hljs-number">430</span>)
  .<span class="hljs-title function_">closePath</span>()
  .<span class="hljs-property">path</span>;

<span class="hljs-keyword">const</span> rightFootPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathCreator</span>()
  .<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">191</span>, <span class="hljs-number">430</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">192</span>, <span class="hljs-number">456</span>, <span class="hljs-number">180</span>, <span class="hljs-number">444</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">173</span>, <span class="hljs-number">456</span>, <span class="hljs-number">167</span>, <span class="hljs-number">444</span>)
  .<span class="hljs-title function_">quadraticCurveTo</span>(<span class="hljs-number">151</span>, <span class="hljs-number">456</span>, <span class="hljs-number">155</span>, <span class="hljs-number">430</span>)
  .<span class="hljs-title function_">closePath</span>()
  .<span class="hljs-property">path</span>;
</code></pre>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 左手 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"leftHandPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffdbd7"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右手 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"rightHandPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffdbd7"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 左脚 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"leftFootPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffdbd7"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 右脚 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Path</span>
  <span class="hljs-attr">:path</span>=<span class="hljs-string">"rightFootPath"</span>
  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#ffdbd7"</span>
  <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#000000"</span>
  <span class="hljs-attr">:stroke-width</span>=<span class="hljs-string">"3"</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Path</span>&gt;</span>
</code></pre>
<p>🎉 LABUBU 诞生！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8856848ac11942f18d4133bf6da7cb53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgeGlhb2hlMDYwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763640771&amp;x-signature=lR21QVIMozjEDLrSpKadB9TYZn8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">🖥️ 源码</h2>
<p>项目的完整代码可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiaohe0601%2Fleafer-labubu" target="_blank" title="https://github.com/xiaohe0601/leafer-labubu" ref="nofollow noopener noreferrer">leafer-labubu</a> 仓库中查看。</p>
<p>赠人玫瑰，手留余香，如果对你有帮助可以给我一个 ⭐️ 鼓励，这将是我继续前进的动力，谢谢大家 🙏！</p>
<h2 data-id="heading-7">🍬 感谢</h2>
<p>项目灵感及图形创意来源于 <a href="https://link.juejin.cn?target=http%3A%2F%2Fxhslink.com%2Fo%2F2Xum9er44EP" target="_blank" title="http://xhslink.com/o/2Xum9er44EP" ref="nofollow noopener noreferrer">LABUBU 简笔画教程 - Thomas</a> 。</p>
<h2 data-id="heading-8">🍵 写在最后</h2>
<p>我是 xiaohe0601，热爱代码，目前专注于 Web 前端领域。</p>
<p>欢迎关注我的微信公众号「小何不会写代码」，我会不定期分享一些开发心得、最佳实践以及技术探索等内容，希望能够帮到你！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LLM 交互的“省钱”新姿势：JSON 已死，TOON 当立]]></title>    <link>https://juejin.cn/post/7572453554331009024</link>    <guid>https://juejin.cn/post/7572453554331009024</guid>    <pubDate>2025-11-15T03:38:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572453554331009024" data-draft-id="7572408522438344739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LLM 交互的“省钱”新姿势：JSON 已死，TOON 当立"/> <meta itemprop="keywords" content="后端,AIGC"/> <meta itemprop="datePublished" content="2025-11-15T03:38:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小奏技术"/> <meta itemprop="url" content="https://juejin.cn/user/395479918848487"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LLM 交互的“省钱”新姿势：JSON 已死，TOON 当立
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/395479918848487/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小奏技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T03:38:16.000Z" title="Sat Nov 15 2025 03:38:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>嘿，兄弟！你是不是也感觉 AI 越来越香，但 Token 账单也越来越“烫”？ 💸</p>
<p><code>GPT-4o</code>、<code>Kimi</code> 这些模型的上下文窗口动不动就几十万、上百万 <code>Token</code>，我们恨不得把整个项目都扔进去。但冷静下来看看账单... ... 哇哦</p>
<p><code>LLM</code> 的 <code>Token</code> 每一分都是真金白银啊！</p>
<p>当大家都在想办法优化模型、优化算法时，有没有想过，我们每天都在用的 <code>JSON</code>，可能就是那个“背刺”我们 Token 费用的“内鬼”？</p>
<p>JSON 虽好，但它实在是... ... 太！啰！嗦！了！</p>
<h2 data-id="heading-1">“内鬼”现形：JSON 到底有多浪费</h2>
<p>在 LLM 的世界里，Token 就是钱。表达同样的信息，谁用的 Token 少，谁就是赢家。</p>
<p>不信？我们直接上例子，用事实说话。</p>
<p>假设我们有这样一个简单的用户列表：</p>
<h3 data-id="heading-2">1. 冗长的“老大哥”：JSON</h3>
<p>标准的 JSON 格式，充满了大括号、双引号和逗号，简直是 Token 杀手。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Alice"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Bob"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Charlie"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">35</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>（数数看，光是 name 这个词就重复了 3 遍！）</p>
<h3 data-id="heading-3">2. “小清新”但还不够：YAML</h3>
<p>YAML 确实清爽了不少，用缩进代替了括号，也去掉了双引号。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Alice</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">30</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Bob</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">25</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Charlie</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">35</span>
</code></pre>
<p>嗯，进步了，但不多。id, name, age 这些键名还是在无情地重复。</p>
<h3 data-id="heading-4">3. “抠门”的王者：TOON 登场！</h3>
<p>TOON （Token-Oriented Object Notation）闪亮登场，它用了一种近乎“变态”的方式来压缩信息：</p>
<pre><code class="hljs language-TOON" lang="TOON">[3]{id,name,age}:
  1,Alice,30
  2,Bob,25
  3,Charlie,35
</code></pre>
<p>看明白了吗？[3] 表示有3个对象，{id,name,age} 只定义了一次“表头”，后面的数据就像 CSV 一样紧凑排列。</p>
<p>没有对比就没有伤害！ 同样的数据，<code>TOON</code> 的 <code>Token</code> 占用量简直是“骨折价”！</p>
<h2 data-id="heading-5">啥是 TOON？为 LLM 而生的“省钱利器”</h2>
<p><code>TOON</code>（面向 Token 的对象表示法）就是这么一个专为 LLM 提示词而生的、紧凑且人类可读的数据格式。</p>
<p>它能表示和 <code>JSON</code> 一模一样的对象、数组和数据类型，但它的语法就是为了最小化 Token 使用而设计的。</p>
<p>你可以把它理解为 <code>YAML</code> 的嵌套结构 +<code> CSV</code> 的表格布局 = <code>TOON</code></p>
<p>TOON 最擅长处理的场景，就是我们最常见的**“结构一致的对象数组”**。在实现 CSV 般紧凑的同时，它又提供了清晰的结构信息（{key1, key2}:），帮助 LLM 更可靠地解析和验证数据。</p>
<blockquote>
<p>注意： TOON 并非银弹。如果你的数据是深度嵌套或结构极其不统一的，那 JSON 可能还是老老实实的选择。但在“对象数组”这个 LLM 最常见的场景下，TOON 简直无敌。</p>
</blockquote>
<h2 data-id="heading-6">数据为证：TOON 到底有多能打？</h2>
<p>光说不练假把式。<code>Chase Adams</code> 大佬做了一组非常直观的基准测试，对比了 <code>JSON</code>、<code>YAML</code>、<code>TOON</code> 和 <code>CSV</code> 的 <code>Token</code> 效率。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8fb85506e00a48b19fe5304bcfd16793~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5aWP5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763782696&amp;x-signature=hPM7corj2AoLxlSEq%2BZ16r7lJfQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12f9a5eaf8104b99bbe50a23c0c26149~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5aWP5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763782696&amp;x-signature=Q8OVpSc4uu1YqOfj6VTa3kUyXc4%3D" alt="" loading="lazy"/></p>
<blockquote>
<p>基准测试链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.curiouslychase.com%2Fplayground%2Fformat-tokenization-exploration" target="_blank" title="https://www.curiouslychase.com/playground/format-tokenization-exploration" ref="nofollow noopener noreferrer">www.curiouslychase.com/playground/…</a></p>
</blockquote>
<p>结论一目了然：</p>
<p><code>CSV</code> 是 <code>Token</code> 效率的“天花板”，但它无法表示嵌套结构，而且没有元数据，LLM 很容易“读歪”。</p>
<p><code>TOON</code> 稳坐第二把交椅，效率直逼 CSV，但它保留了完整的结构信息。</p>
<p>J<code>SON</code> 和 <code>YAML</code>... ... 两位老大哥，在 <code>Token</code> 效率上被 <code>TOON</code> 吊打。</p>
<h2 data-id="heading-7">如何在 LLM 中“无痛”用上 TOON？</h2>
<p>你可能会想：“哇，这么牛？那我岂不是要重构整个系统？”</p>
<p>完全不用</p>
<p>官方推荐的架构是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cc3d269124e4fb983ca51c898a65ab1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5aWP5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763782696&amp;x-signature=TeXTKGnpbLsqNdwbD5tpA%2B9zyM8%3D" alt="" loading="lazy"/></p>
<p>看懂了吗？<code>TOON</code> 只是一个**“转换层”**。</p>
<p>你的系统内部，该用 <code>JSON</code> 还是用 <code>JSON</code>，啥也不用改。</p>
<p>在调用 <code>LLM</code> 之前，你只需加一个编码步骤，把 <code>JSON</code> 编码（Encode） 成 <code>TOON</code> 格式再发送。</p>
<p><code>LLM</code> 返回 <code>TOON</code> 格式的数据后，你再解码（Decode） 成 <code>JSON</code> 给系统用。</p>
<p>你就把它当成一个“中间件”，在和 <code>LLM</code> 交互的“最后一公里”上帮你省钱</p>
<h2 data-id="heading-8">别再浪费 Token 了！</h2>
<p>在 <code>LLM</code> 时代，<code>Token</code> 效率就是核心竞争力。</p>
<p><code>JSON</code> 是一个伟大的格式，但在 <code>LLM</code> 交互这个新场景下，它显得既臃肿又昂贵。</p>
<p><code>TOON</code> 提供了一个完美的替代方案：它在保留 <code>JSON</code> 完整表达能力的同时，实现了接近 <code>CSV</code> 的 <code>Token</code> 效率。</p>
<p>如果你还在为高昂的 <code>LLM Token</code> 费用而头疼，如果你还在忍受 <code>JSON</code> 带来的冗余，那么，是时候给你的系统“升个舱”了</p>
<h2 data-id="heading-9">参考</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftoon-format%2Ftoon" target="_blank" title="https://github.com/toon-format/toon" ref="nofollow noopener noreferrer">github.com/toon-format…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.curiouslychase.com%2Fplayground%2Fformat-tokenization-exploration" target="_blank" title="https://www.curiouslychase.com/playground/format-tokenization-exploration" ref="nofollow noopener noreferrer">www.curiouslychase.com/playground/…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[mcp-server案例分享-即梦MCP-Server实战教程-让Claude直接调用AI生图视频能力]]></title>    <link>https://juejin.cn/post/7572454929143693347</link>    <guid>https://juejin.cn/post/7572454929143693347</guid>    <pubDate>2025-11-15T03:20:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572454929143693347" data-draft-id="7572453554330910720" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="mcp-server案例分享-即梦MCP-Server实战教程-让Claude直接调用AI生图视频能力"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-15T03:20:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wwwzhouhui"/> <meta itemprop="url" content="https://juejin.cn/user/3428746411400537"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            mcp-server案例分享-即梦MCP-Server实战教程-让Claude直接调用AI生图视频能力
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3428746411400537/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wwwzhouhui
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T03:20:08.000Z" title="Sat Nov 15 2025 03:20:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>在AI辅助开发工具快速发展的今天，如何让AI助手直接调用外部服务成为了开发者关注的焦点。传统的方式往往需要开发者手动编写大量的API调用代码，不同服务的接口格式又各不相同，导致集成成本居高不下。更关键的是，像Claude、ChatGPT这样的AI助手无法直接访问外部资源，只能通过开发者作为"中间人"来完成任务，效率大打折扣。</p>
<p>MCP（Model Context Protocol，模型上下文协议）是由Anthropic公司于2024年11月开源的标准化协议，专门用于解决AI模型与外部资源之间的连接问题。而今天要介绍的<strong>jimeng-mcp-server</strong>正是基于这个协议打造的即梦AI集成服务器，它能让Claude、Cherry Studio等AI应用直接调用即梦的"文生图"、"图像合成"、"文生视频"、"图生视频"四大核心能力。通过"Claude客户端 → MCP服务器 → 即梦API"的三层架构，实现了10-20倍的token压缩效率，同时保持97%以上的调用成功率。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/45f23da630684d42bae1625bf65d276e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=gUdw9k9aw1qsiVCwAqUHLb35i6I%3D" alt="MCP三层架构图" loading="lazy"/></p>
<p>昨天开源在GitHub上开源了jimeng-mcp-server，今天我们就手把手教大家在本地部署这个项目，体验和感受一下让Claude直接生成AI图片和视频的强大能力。话不多说，下面带大家一起来实现。</p>
<hr/>
<h2 data-id="heading-1">2. 项目介绍</h2>
<p>jimeng-mcp-server 是一个开源的MCP服务器实现，它将即梦AI的多模态生成能力封装成标准的MCP工具，让任何支持MCP协议的AI应用都能轻松调用。</p>
<h4 data-id="heading-2">✨ 核心特性</h4>
<ul>
<li><strong>🚀 四大AI生成工具</strong>：文生图、图像合成、文生视频、图生视频，满足多样化创作需求</li>
<li><strong>🎯 标准MCP协议</strong>：完全兼容Anthropic的MCP规范，支持stdio、SSE、HTTP三种运行模式</li>
<li><strong>💰 零成本使用</strong>：基于jimeng-free-api-all项目，官方每日赠送66积分，完全免费体验</li>
<li><strong>🔧 一键Docker部署</strong>：提供完整的Docker Compose配置，3分钟即可启动服务</li>
<li><strong>📦 多客户端支持</strong>：兼容Claude Desktop、Cherry Studio、Cline等主流MCP客户端</li>
<li><strong>🌐 OpenAI兼容接口</strong>：支持标准的OpenAI API格式，易于集成到现有项目</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fdff449c072347888d987c792cabf9be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=t6V%2FWV4W9HkVZqbQafS1y0kw2zo%3D" alt="image-20251115095418050" loading="lazy"/></p>
<h4 data-id="heading-3">🛠️ 技术栈</h4>



































<table><thead><tr><th>技术组件</th><th>说明</th><th>版本要求</th></tr></thead><tbody><tr><td><strong>语言</strong></td><td>Python</td><td>3.10+</td></tr><tr><td><strong>框架</strong></td><td>FastMCP</td><td>最新版</td></tr><tr><td><strong>协议</strong></td><td>MCP Protocol</td><td>v1.0</td></tr><tr><td><strong>后端API</strong></td><td>jimeng-free-api-all</td><td>Docker部署</td></tr><tr><td><strong>部署方式</strong></td><td>Docker / stdio / SSE</td><td>-</td></tr></tbody></table>
<p><strong>核心依赖：</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 主要依赖包</span>
mcp&gt;=<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>           <span class="hljs-comment"># MCP协议核心库</span>
httpx&gt;=<span class="hljs-number">0.27</span><span class="hljs-number">.0</span>        <span class="hljs-comment"># HTTP客户端</span>
python-dotenv&gt;=<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> <span class="hljs-comment"># 环境变量管理</span>
</code></pre>
<h4 data-id="heading-4">🎯 应用场景</h4>
<p><strong>AI内容创作</strong></p>
<ul>
<li>博客配图自动生成</li>
<li>短视频批量制作</li>
<li>产品宣传素材创作</li>
</ul>
<p><strong>智能办公助手</strong></p>
<ul>
<li>PPT自动配图</li>
<li>报告可视化</li>
<li>创意头脑风暴</li>
</ul>
<p><strong>开发者工具</strong></p>
<ul>
<li>UI原型快速生成</li>
<li>测试数据可视化</li>
<li>技术文档配图</li>
</ul>
<h4 data-id="heading-5">🆚 为什么选择MCP方案？</h4>
<p>相比传统的API集成方式，MCP方案具有显著优势：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f57c5184079046438b3c218cca239092~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=UNL36YfTTR%2Fmvs4gpRhvbiCVepE%3D" alt="image-20251115095601637" loading="lazy"/></p>
<p><strong>核心优势总结：</strong></p>
<ul>
<li>⚡ <strong>开发效率提升95%</strong>：从4周降至30分钟</li>
<li>💰 <strong>成本降低90%</strong>：Token消耗大幅减少</li>
<li>🎯 <strong>零维护成本</strong>：自动适配API变更</li>
<li>🚀 <strong>无限扩展性</strong>：轻松添加新服务</li>
</ul>
<hr/>
<h2 data-id="heading-6">3. 部署实战</h2>
<p>下面我们就来手把手实现这个MCP服务器的完整部署流程。整个过程分为两部分：首先部署jimeng-free-api-all后端服务，然后安装配置jimeng-mcp-server。</p>
<h3 data-id="heading-7">环境准备</h3>
<p>在开始之前，我们需要确保系统已经安装了以下环境：</p>
<p><strong>必备环境：</strong></p>
<ul>
<li>Python 3.10 或更高版本</li>
<li>Docker 和 Docker Compose（用于部署后端API）</li>
<li>Git（用于克隆项目）</li>
</ul>
<p><strong>推荐配置：</strong></p>
<ul>
<li>操作系统：Ubuntu 20.04+ / macOS 12+ / Windows 10/11（WSL2）</li>
<li>内存：至少 4GB</li>
<li>磁盘空间：至少 10GB</li>
</ul>
<p>首先检查Python版本：</p>
<pre><code class="hljs language-shell" lang="shell">python --version
<span class="hljs-meta prompt_"># </span><span class="bash">输出应该是 Python 3.10.x 或更高</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d270ea4d845a4e1b974b05663d9e85f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=49sH9flqlG37%2BW9y0KYroz%2FMUA8%3D" alt="image-20251115095759755" loading="lazy"/></p>
<p>然后验证Docker是否安装：</p>
<pre><code class="hljs language-shell" lang="shell">docker --version
docker-compose --version
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/368509b6e92d42ef80f4973729c9f794~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=%2BFWuiFU2vQDu%2BIglWeNFNTwmsrw%3D" alt="image-20251115095905271" loading="lazy"/></p>
<p>如果Docker未安装，可以参考官方文档进行安装：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.docker.com%2Fget-docker%2F" target="_blank" title="https://docs.docker.com/get-docker/" ref="nofollow noopener noreferrer">docs.docker.com/get-docker/</a></p>
<h3 data-id="heading-8">部署后端API服务</h3>
<p>jimeng-mcp-server 需要配合 jimeng-free-api-all 后端服务使用。我们首先来部署这个后端服务。</p>
<h4 data-id="heading-9">3.2.1 克隆后端项目</h4>
<p>打开终端，执行以下命令：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">克隆 jimeng-free-api-all 项目</span>
git clone https://github.com/wwwzhouhui/jimeng-free-api-all.git
cd jimeng-free-api-all
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c4c379d40894c0080a96402cbfebf67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=kBrQcP0pgjLuXNq9zhQVAXvM0gU%3D" alt="image-20251115100042667" loading="lazy"/></p>
<h4 data-id="heading-10">3.2.2 配置环境变量</h4>
<p>进入即梦登录账号，然后 F12 打开开发者工具，从 Application &gt; Cookies 中找到<code>sessionid</code>的值，这将作为 Authorization 的 Bearer Token 值：<code>Authorization: Bearer sessionid</code></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e82007969894ae4aee904d7e798eb25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=vT5%2FwkCgExT0mo4GzUHITIoWrLU%3D" alt="example0" loading="lazy"/></p>
<h4 data-id="heading-11">3.2.3 启动后端服务</h4>
<p>下载镜像</p>
<pre><code class="hljs language-bash" lang="bash">docker pull wwwzhouhui569/jimeng-free-api-all:latest
</code></pre>
<p>启动 Docker 容器</p>
<pre><code class="hljs language-css" lang="css">docker run -it -d <span class="hljs-attr">--init</span> <span class="hljs-attr">--name</span> jimeng-free-api-<span class="hljs-attribute">all</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">8001</span>:<span class="hljs-number">8000</span> -e TZ=Asia/Shanghai wwwzhouhui569/jimeng-free-api-all:latest
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ce410bc2b954f608c8137f1b3568f64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=5qbhWtaZfZvpf%2BtHAFw4tIOy%2B4c%3D" alt="image-20251115101401289" loading="lazy"/></p>
<h3 data-id="heading-12">安装MCP服务器</h3>
<p>后端服务部署完成后，我们开始安装jimeng-mcp-server。</p>
<h4 data-id="heading-13">3.3.1 克隆MCP项目</h4>
<p>打开新的终端窗口，执行：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">克隆 jimeng-mcp-server 项目</span>
git clone https://github.com/wwwzhouhui/jimeng-mcp-server.git
cd jimeng-mcp-server
</code></pre>
<h4 data-id="heading-14">3.3.2 安装Python依赖</h4>
<p>项目使用 <code>uv</code> 作为包管理工具（推荐），也可以使用传统的 pip。</p>
<p><strong>方法一：使用 uv（推荐）</strong></p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">安装 uv（如果尚未安装）</span>
curl -LsSf https://astral.sh/uv/install.sh | sh
<span class="hljs-meta prompt_">
# </span><span class="bash">创建虚拟环境并安装依赖</span>
uv venv
source .venv/bin/activate  # Linux/macOS
<span class="hljs-meta prompt_"># </span><span class="bash">或者在 Windows 上使用: .venv\Scripts\activate</span>

uv pip install -e .
</code></pre>
<p><strong>方法二：使用 pip</strong></p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">创建虚拟环境</span>
python -m venv .venv
source .venv/bin/activate  # Linux/macOS
<span class="hljs-meta prompt_"># </span><span class="bash">或者在 Windows 上使用: .venv\Scripts\activate</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">安装依赖</span>
pip install -e .
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb20f773427c476099c7588709305ecb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=NBCxpf%2BtsEHD2kW01SjvnQ6uuqw%3D" alt="image-20251115101728380" loading="lazy"/></p>
<p>安装过程中可能需要几分钟时间，请耐心等待。</p>
<h4 data-id="heading-15">3.3.3 配置MCP服务器</h4>
<p>创建 <code>.env</code> 文件配置后端API地址：</p>
<pre><code class="hljs language-shell" lang="shell">touch .env
</code></pre>
<p>编辑 <code>.env</code> 文件：</p>
<pre><code class="hljs language-env" lang="env"># 即梦API配置

# 您的即梦API密钥 (必需)
JIMENG_API_KEY=您的API密钥

# API基础URL (可选, 默认为 https://jimeng.duckcloud.fun)
JIMENG_API_URL=http://127.0.0.1:8001

# 图像生成的默认模型 (可选, 默认为 jimeng-4.0)
JIMENG_MODEL=jimeng-4.0
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eaaa95756e4641078efd7545c3f10f98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=g12tWkMPZLNLrqaXMGgn90yoYOw%3D" alt="image-20251115101958669" loading="lazy"/></p>
<p><strong>注意</strong>：<code>JIMENG_API_KEY</code> 就是前面网页版本即梦 cookies</p>
<h3 data-id="heading-16">Cherry Studio配置</h3>
<p>将此服务器添加到Cherry Studio配置文件:</p>
<p><strong>MacOS</strong>: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></p>
<p><strong>Windows</strong>: <code>%APPDATA%\Claude\claude_desktop_config.json</code></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"jimeng"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"python"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"-m"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"jimeng_mcp.server"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"JIMENG_API_KEY"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"您的API密钥"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>或者,如果您有<code>.env</code>文件:</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"jimeng"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"python"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"-m"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"jimeng_mcp.server"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>sse配置</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98e8af42f454473d9a31741c862c7d0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=oQbsn4NfEgRW1IRbPKBY3uiGj%2BE%3D" alt="image-20251114205117656" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3547a384b2374e81a56a771bd53a954d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=Dq1jgfSQNI92TyCgbzk12p6hOCs%3D" alt="image-20251114205145614" loading="lazy"/></p>
<h4 data-id="heading-17">文本生成图像示例</h4>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">生成一张图像:小猪和小狗踢球</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b44f76f3d7e4902b6f6aa03a9f34053~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=v3dFgRChNTZTH107pVOZESD6Pvo%3D" alt="image-20251114225936753" loading="lazy"/></p>
<h5 data-id="heading-18">图像合成示例</h5>
<pre><code class="hljs language-bash" lang="bash">将这两张图像合成在一起:
- 图像1: https://p3-dreamina-sign.byteimg.com/tos-cn-i-tb4s082cfz/bab623359bd9410da0c1f07897b16fec~tplv-tb4s082cfz-resize:0:0.image?lk3s=8e790bc3&amp;x-expires=1788961069&amp;x-signature=cbtnyeSIcqWpngHdoYWFkCra3cA%3D
- 图像2: https://p3-dreamina-sign.byteimg.com/tos-cn-i-tb4s082cfz/6acf16d07c47413898aea2bdd1ad339e~tplv-tb4s082cfz-resize:0:0.image?lk3s=8e790bc3&amp;x-expires=1788961069&amp;x-signature=30S2i%2FvCH0eRR32CehcEaK8t5ns%3D
创建一个艺术风格的无缝融合
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9192a831985e4b29b844ae9cee4d75ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=uaaAdxPTuIlLQVvIZaSI1gTtGM0%3D" alt="image-20251114230207881" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7936feaa3e474c188aa34e26c02acf6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=%2BvJCsgCobZHvl3esX678v0TAy6M%3D" alt="image-20251114230356088" loading="lazy"/></p>
<h5 data-id="heading-19">文本生成视频示例</h5>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">创建一个视频:小猫在钓鱼</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/374144ec33c743f1a6c57f95e34ecf28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=kzgXfOBLQIk7P9%2F5t6NT5zKA%2BKM%3D" alt="image-20251114210421561" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4020c55afa9846c4a2aa3d826677765b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=nsyuwYk2SG%2BGSg6U00hX2wQj7Jk%3D" alt="image-20251114210442167" loading="lazy"/></p>
<h5 data-id="heading-20">图像生成视频示例</h5>
<pre><code class="hljs language-bash" lang="bash">为这张图像添加动画效果:
https://p3-dreamina-sign.byteimg.com/tos-cn-i-tb4s082cfz/bab623359bd9410da0c1f07897b16fec~tplv-tb4s082cfz-resize:0:0.image?lk3s=8e790bc3&amp;x-expires=1788961069&amp;x-signature=cbtnyeSIcqWpngHdoYWFkCra3cA%3D
添加轻柔的运动和自然的镜头缩放
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/54ffabdb374b40ec9760dafd34d886e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=ogL5FF4dx58dOrP567XT6hwWxcU%3D" alt="image-20251114231138586" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/118eef1f6d29449b849caf75afff6f48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=6DchFDKcZm%2BxApObdiQ595Bqsr4%3D" alt="image-20251114231206562" loading="lazy"/></p>
<h3 data-id="heading-21">在claude code中使用</h3>
<h4 data-id="heading-22">文本生成图像示例</h4>
<pre><code class="hljs language-vbscript" lang="vbscript">请使用jimeng-mcp-<span class="hljs-built_in">server</span> 生成一张图像:小猪和小狗踢球
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b8c6198a40d4acfb225b48244b3881d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=KBGNkM1gfsPXMI9%2F3%2BRw3EPSICU%3D" alt="image-20251115003223041" loading="lazy"/></p>
<h4 data-id="heading-23">图像合成示例</h4>
<pre><code class="hljs language-bash" lang="bash">请使用jimeng-mcp-server 将这两张图像合成在一起:
- 图像1: https://p3-dreamina-sign.byteimg.com/tos-cn-i-tb4s082cfz/bab623359bd9410da0c1f07897b16fec~tplv-tb4s082cfz-resize:0:0.image?lk3s=8e790bc3&amp;x-expires=1788961069&amp;x-signature=cbtnyeSIcqWpngHdoYWFkCra3cA%3D
- 图像2: https://p3-dreamina-sign.byteimg.com/tos-cn-i-tb4s082cfz/6acf16d07c47413898aea2bdd1ad339e~tplv-tb4s082cfz-resize:0:0.image?lk3s=8e790bc3&amp;x-expires=1788961069&amp;x-signature=30S2i%2FvCH0eRR32CehcEaK8t5ns%3D
创建一个艺术风格的无缝融合
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f109c8bfa4246dfa56447ab44e00138~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=UL5n%2FqN32NFTQgXB7w96%2FW8fnoc%3D" alt="image-20251115003456583" loading="lazy"/></p>
<p>图片生成结果</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/48885517a7f14e0996278be8c02d5f5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763781607&amp;x-signature=5ft%2FFkvO8oy3hO1QhByVAVihxJo%3D" alt="image-20251115003526890" loading="lazy"/></p>
<h3 data-id="heading-24">3.6 高级配置（可选）</h3>
<h4 data-id="heading-25">SSE模式部署</h4>
<p>如果需要将MCP服务器部署到云端供多人使用，可以使用SSE（Server-Sent Events）模式：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">启动SSE服务器</span>
cd jimeng-mcp-server
uv run jimeng-mcp-server --transport sse --port 8080
</code></pre>
<p>然后在客户端配置中使用SSE连接：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"jimeng-remote"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"url"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"http://your-server-ip:8080/sse"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"transport"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sse"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-26">HTTP REST API模式</h4>
<p>jimeng-mcp-server还支持标准的HTTP REST API调用：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">启动HTTP服务</span>
uv run jimeng-mcp-server --transport http --port 8080
</code></pre>
<p>可以使用curl或Postman测试：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">调用文生图API</span>
curl -X POST http://localhost:8080/tools/text_to_image \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "一只可爱的柴犬",
    "width": 1024,
    "height": 1024
  }'
</code></pre>
<hr/>
<h2 data-id="heading-27">4. 总结</h2>
<p>今天主要带大家了解并实现了 <strong>jimeng-mcp-server（即梦MCP服务器）</strong> 的 <strong>完整部署与集成流程</strong>，该 <strong>开源MCP服务器</strong> 以 <strong>"标准MCP协议 + 即梦AI多模态能力"</strong> 为核心优势，结合 <strong>AI辅助开发与内容创作</strong> 需求，通过 <strong>Docker容器化部署</strong> 与 <strong>FastMCP框架</strong>，形成了一套从 <strong>后端API搭建</strong> 到 <strong>Claude客户端集成</strong> 的全链路 <strong>AI工具编排解决方案</strong>。</p>
<p>通过这套实践方案，开发者与内容创作者 能够高效突破 传统AI助手无法直接调用外部服务 的技术壁垒 —— 借助 三层架构设计（包括 Claude客户端层、MCP协议层、即梦API层），无需 手动编写API对接代码，就能快速 实现AI生图、图像合成、文生视频、图生视频四大核心功能（如本次演示的 "让Claude用一句话生成樱花下的柴犬视频"）。无论是 博客配图自动生成、PPT智能配图，还是 短视频批量制作、UI原型快速生成，都能通过 自然语言指令 完成，极大 提升内容创作效率和开发体验。</p>
<p>在实际应用中，该 <strong>MCP服务器</strong> 不仅 <strong>支持stdio、SSE、HTTP三种运行模式</strong>，还 <strong>提供OpenAI兼容接口</strong>，适配性远优于 <strong>传统单一协议方案</strong>；特别是通过 <strong>Docker Compose一键部署</strong>，有效解决了 <strong>复杂环境配置和依赖管理</strong> 的难题。同时，方案具备良好的扩展性 —— 小伙伴们可以基于此扩展更多 <strong>AI生成工具</strong>，如 <strong>AI音乐生成、3D模型生成、代码可视化生成</strong> 等，进一步发挥 <strong>MCP协议标准化能力</strong> 在 <strong>企业级AI应用、智能办公系统、教育培训平台</strong> 等领域的应用价值。感兴趣的小伙伴可以按照文中提供的步骤进行实践，根据实际 <strong>业务场景和创作需求</strong> 调整 <strong>工具参数、分辨率、时长等配置项</strong>。今天的分享就到这里结束了，我们下一篇文章见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Monorepo性能噩梦：一行配置解决VSCode卡顿与TS类型崩溃]]></title>    <link>https://juejin.cn/post/7572434032518807598</link>    <guid>https://juejin.cn/post/7572434032518807598</guid>    <pubDate>2025-11-15T03:44:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572434032518807598" data-draft-id="7572466174224465946" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Monorepo性能噩梦：一行配置解决VSCode卡顿与TS类型崩溃"/> <meta itemprop="keywords" content="前端,Visual Studio Code,TypeScript"/> <meta itemprop="datePublished" content="2025-11-15T03:44:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="eason_fan"/> <meta itemprop="url" content="https://juejin.cn/user/2995517308808877"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Monorepo性能噩梦：一行配置解决VSCode卡顿与TS类型崩溃
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2995517308808877/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    eason_fan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T03:44:33.000Z" title="Sat Nov 15 2025 03:44:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Monorepo性能噩梦：一行配置解决VSCode卡顿与TS类型崩溃</h2>
<h3 data-id="heading-1">前言</h3>
<p>在现代前端开发中，Monorepo已成为管理大型项目的流行方案。它通过将多个项目、库和组件集中在同一个代码仓库中，简化了依赖管理和代码复用。然而，随着项目规模的扩大，Monorepo也可能带来一些意想不到的性能问题。</p>
<p>本文将分享一个我在实际项目中遇到的性能噩梦，以及如何通过一行简单的VSCode配置解决这个问题的经历。</p>
<h3 data-id="heading-2">问题背景</h3>
<p>我所在的项目是一个大型的Monorepo，其中包含一个主项目A，以及从A中拆分出的子包B和十几个组件库C-G。项目的引用关系变得非常复杂，TypeScript配置为直接读取源码进行类型生成，而不是依赖打包后的<code>dist</code>文件。</p>
<p>拆包之后，VSCode的性能急剧下降，出现了以下问题：</p>
<ul>
<li><strong>路径跳转卡顿</strong>：每次安装依赖后，第一次跳转到定义需要等待长达一分钟的初始化时间</li>
<li><strong>类型推断崩溃</strong>：TypeScript类型提示经常失效，导致出现大量<code>unsafe type error</code></li>
<li><strong>编辑器假死</strong>：需要频繁重启VSCode才能恢复正常</li>
</ul>
<p>我尝试了各种方法，包括调整TypeScript配置、升级VSCode、禁用插件等，但都无济于事。</p>
<h3 data-id="heading-3">问题根源</h3>
<p>经过反复排查，我发现问题的根源在于VSCode的<strong>文件监听机制</strong>。</p>
<p>由于我们的TypeScript配置是直接读取源码，<code>dist</code>目录下的打包文件实际上对类型推断是无用的。然而，VSCode的文件监听器（File Watcher）默认会监控项目中的所有文件变化，包括<code>dist</code>目录。</p>
<p>当我们在Monorepo中进行构建或安装依赖时，大量的<code>dist</code>文件会被生成或修改，导致VSCode的文件监听器不堪重负，占用了大量系统资源，从而引发了上述性能问题。</p>
<h3 data-id="heading-4">解决方案</h3>
<p>最终，我通过在项目的<code>.vscode/settings.json</code>文件中添加一行简单的配置，彻底解决了这个问题：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"files.watcherExclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"**/dist/**"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这行配置的作用是告诉VSCode的文件监听器<strong>忽略所有<code>dist</code>目录下的文件变化</strong>。</p>
<h4 data-id="heading-5">为什么这个配置有效？</h4>
<ol>
<li><strong>减少不必要的监听</strong>：排除了对<code>dist</code>目录的监听，大大减少了VSCode需要处理的文件变化事件</li>
<li><strong>释放系统资源</strong>：降低了CPU和内存占用，使VSCode能够更流畅地运行</li>
<li><strong>专注源码</strong>：让VSCode专注于监听源码文件，确保类型推断和路径跳转的性能</li>
</ol>
<h3 data-id="heading-6">总结</h3>
<p>如果你也在使用Monorepo，并且遇到了类似的性能问题，不妨检查一下你的VSCode配置。通过<code>files.watcherExclude</code>配置，排除掉不需要监听的目录，可能会给你带来意想不到的惊喜。</p>
<p>这个经历告诉我们，有时候解决复杂问题的答案可能就隐藏在最简单的配置中。希望这篇文章能帮助你摆脱Monorepo性能噩梦，享受更流畅的开发体验！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【React Native】如何在开发中使用Appwrite]]></title>    <link>https://juejin.cn/post/7572390974459871232</link>    <guid>https://juejin.cn/post/7572390974459871232</guid>    <pubDate>2025-11-14T12:18:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572390974459871232" data-draft-id="7572408208263004200" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【React Native】如何在开发中使用Appwrite"/> <meta itemprop="keywords" content="React Native"/> <meta itemprop="datePublished" content="2025-11-14T12:18:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一头小鹿"/> <meta itemprop="url" content="https://juejin.cn/user/1216481943637741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【React Native】如何在开发中使用Appwrite
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1216481943637741/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一头小鹿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T12:18:54.000Z" title="Fri Nov 14 2025 12:18:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、为什么选择Appwrite</h3>
<p>最近在做React native的项目，研究后端的时候考虑了几种方法，先是按照以往的方法自己搭了node+mysql的数据库，但是实际使用的时候发现很麻烦：</p>
<ul>
<li>一方面是使用了expo框架，每次启动项目的时候，<strong>expo和node服务器都需要单独跑</strong>，开发流程变得很复杂。</li>
<li>一方面是在手机端预览的时候<strong>环境非常不稳定</strong>，各种数据的更新都不及时，降低了开发效率。由于 Expo 运行在手机中，而本地 Node + MySQL 跑在电脑上，手机并不能直接访问 <code>localhost</code>，这导致开发过程中每次请求数据非常不稳定。</li>
</ul>
<p>参考了其他的项目，最后选用了appwrite，它把数据库、用户、权限、日志，做成了可视化控制台。我们只需要在<strong>网页上</strong>就可以在控制台中创建数据表、自动生成测试数据、开关权限和查看日志，集合了很多我们所需的功能，并且是<strong>开源</strong>的，对于做demo而言十分便捷。</p>
<h3 data-id="heading-1">二、Appwrite介绍</h3>
<p>关于Appwrite，可以这样介绍：Appwrite 是一个开箱即用的后端服务平台，将后端复杂的功能模块化，让开发者不用手写后端代码，在网页上就可以实现账号、数据库、云函数、开发日志等功能。</p>
<ul>
<li>它是开源的，可以自己部署，也可以直接用官方的 Cloud 服务。</li>
<li>支持 Web / iOS / Android / Flutter / React Native / Next.js / Vue 等前端框架。</li>
</ul>
<p>Appwrite 主要功能模块：</p>





























<table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>Auth</td><td>登录注册、OAuth、JWT 管理</td></tr><tr><td>Database</td><td>类似文档数据库，支持权限控制</td></tr><tr><td>Storage</td><td>图片/文件存储、访问权限</td></tr><tr><td>Functions</td><td>云函数，可以跑 server 逻辑</td></tr><tr><td>Realtime</td><td>数据实时监听（聊天室、点赞数实时更新）</td></tr></tbody></table>
<h3 data-id="heading-2">三、优缺点</h3>
<h4 data-id="heading-3">优点</h4>
<ul>
<li>
<p>界面简洁美观，控制台UI舒适，操作简洁易懂</p>
</li>
<li>
<p>权限模型直接可视化，对于数据中的每个表的权限，创建、读、改都可以直接GUI调整。Appwrite用UI把权限（owner / user / role / team / public）做成了可视化界面。</p>
</li>
<li>
<p>API简洁直观：在程序中使用API向appwrite中发起请求的时候，使用的API十分简洁易懂，好上手</p>
<ul>
<li><code>listDocuments()</code> → 获取文档列表</li>
<li><code>createDocument()</code> → 创建文档</li>
<li><code>updateDocument()</code> → 更新文档</li>
</ul>
</li>
</ul>
<h4 data-id="heading-4">缺点</h4>
<ul>
<li>相关的资料不多，开发过程中会遇到的问题有查不到的可能，需要自己摸索。比如我在开发过程中遇到Appwrite的更新，新版本中引入了table的概念，但是在先前的一些文档中介绍的都是attribute，让我研究了好一会哈哈哈。</li>
<li>对于相关概念需要一定理解：Appwrite不是单纯的数据库，虽然类似 Firebase，但其<code>Collections</code>、<code>Documents</code> 等数据模型仍需要一点时间学习。</li>
<li>Appwrite的字段是强结构化的，创建后不能修改字段名。表的结构一定要设计好，否则后期维护会很困难。</li>
</ul>
<h3 data-id="heading-5">四、如何使用</h3>
<h4 data-id="heading-6">1. 创建 Appwrite 项目</h4>
<ul>
<li>在Appwrite网页中打开console，创建一个新项目，设置好平台</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7e99ea7453d4b0ea1869b8ea37f6b2c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=OVZ%2FS%2FMk%2FHh7rQaUDeL2wRMZCNo%3D" alt="1.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47f8bf8a270b4d7ea04ed01c3d0c1c46~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=%2BxML6drb2646ZxG6nl%2BXDLvHJoQ%3D" alt="2.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14e63f4135b342e68577dcc54c289484~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=shxPSDWMnUdi4%2FjbFeUBPXVGXPw%3D" alt="3.png" loading="lazy"/></p>
<ul>
<li>你可以先进行第二点中提到的配置，也可以先创建数据库和表。</li>
<li>PS：如果你看的是先前的教程，在创建完数据库后他们会开始创建 'Collection'，在曾经版本的Appwrite中，在Database下面是'Collection'，然后在Collection中创建'Attribute'作为数据。Collection会有ID（是一串字母+数字的格式），需要写在文件里，但是新版本取消了'Collection'的概念，更换为'Table'，更贴近于数据库的逻辑，方便你创建数据。</li>
</ul>
<h4 data-id="heading-7">2.接下来按照网站给出的顺序进行项目配置</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/822c4d46c13a4d5785d748fbce4259e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=RiZalj%2FnQTyCjLUycUIht%2FNwE%2F8%3D" alt="4.png" loading="lazy"/></p>
<ul>
<li>在编译器中打开终端，安装Appwrite</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/appwrite/starter-for-react-native
<span class="hljs-built_in">cd</span> starter-for-react-native
</code></pre>
<ul>
<li>在.env文件中添加你的Appwrite相关ID（项目ID、数据库ID、表ID......），这是连接客户端的钥匙</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9500fec9d174914a4e123947d4b7e2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=Vmyl0GEdWYCfjoMovqIcuNwVT5w%3D" alt="env.png" loading="lazy"/></p>
<p><em>注意</em>：在先前版本中需要写上每一个'Collection'的ID（都是数字+字母的形式），有些复杂且不好辨别，现在你只需要写上你的数据库ID，剩下的表的ID都和表名相同，大大方便了我们。更新后，你甚至可以不用提前声明表的ID，而是在使用时直接灵活运用。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08f1f7ef021045819ed085277c6c95c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=TpzuRju%2BkJjQTWES4NWj%2BZ6sJs8%3D" alt="5.png" loading="lazy"/></p>
<ul>
<li>不要忘记调整你的表的使用权限，否则请求的时候会因为没有权限而请求失败</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c01ce1308da842d58006744e562cc289~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=8aXjQVdiqX52zl1f6ojyivMY4vQ%3D" alt="settings.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/521b314ab35a4a1ea34d800f4e92e83a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=J5TlKuxpRLhxv1rBLlXsWpOPrFk%3D" alt="permission.png" loading="lazy"/></p>
<h4 data-id="heading-8">3. 在appwrite.ts中初始化 Client</h4>
<pre><code class="hljs language-ini" lang="ini">import { Client, Databases } from 'appwrite'<span class="hljs-comment">;</span>
​
const <span class="hljs-attr">DATABASE_ID</span> = process.env.EXPO_PUBLIC_APPWRITE_DATABASE_ID!<span class="hljs-comment">;</span>
const <span class="hljs-attr">ENDPOINT</span> = process.env.EXPO_PUBLIC_APPWRITE_ENDPOINT!<span class="hljs-comment">;</span>
const <span class="hljs-attr">USERS_TABLE_ID</span> = process.env.EXPO_PUBLIC_APPWRITE_USERS_TABLE_ID!<span class="hljs-comment">;</span>
const <span class="hljs-attr">NOTES_TABLE_ID</span> = process.env.EXPO_PUBLIC_APPWRITE_NOTES_TABLE_ID!<span class="hljs-comment">;</span>
​
export const <span class="hljs-attr">client</span> = new Client()
    .setEndpoint(ENDPOINT) // https://cloud.appwrite.io/v1
    .setProject(PROJECT_ID)<span class="hljs-comment">;</span>
​
export const <span class="hljs-attr">databases</span> = new Databases(client)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-9">4. 读写数据库</h4>
<p>想要从数据库中获取数据，就需要在fetch方法中使用listDocuments()。</p>
<p><code>listDocuments()</code> 的作用就是：<strong>从某个 collection 里把数据拉出来</strong>。传入的两个参数分别是你在Appwrite中的Database的ID和 Table的ID，默认获取到表中的全部数据。</p>
<p>想要做精细化的筛选，可以使用Query来进行条件选择。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">res</span> = <span class="hljs-selector-tag">await</span> <span class="hljs-selector-tag">databases</span><span class="hljs-selector-class">.listDocuments</span>(
  <span class="hljs-string">"databaseId"</span>,
  <span class="hljs-string">"tableId"</span>,
  [
    Query.<span class="hljs-built_in">equal</span>(<span class="hljs-string">"userId"</span>, currentUserId),
    Query.<span class="hljs-built_in">orderDesc</span>(<span class="hljs-string">"$createdAt"</span>),
    Query.<span class="hljs-built_in">limit</span>(<span class="hljs-number">20</span>),
  ]
);
</code></pre>
<p>这段等价于SQL中的'WHERE userId = xxx ORDER BY createdAt DESC LIMIT 20'。</p>
<p><strong>条件筛选</strong>：</p>
<p>Query的常用方法有：</p>
<ul>
<li>Query.equal('userId', '123')等价于userId == '123'（可以用于获取某些类型的数据，或是某些用户的数据）</li>
<li>Query.between('age', 18, 30)等价于age between 18 and 30 (inclusive)</li>
<li>Query.contains('tags', 'holiday') 等价于array/string contains 'holiday'</li>
<li>Query.orderDesc('$createdAt') 是按创建时间降序</li>
<li>Query.orderAsc('price') 是按 price 升序</li>
<li>Query.limit(20)每页 20 条</li>
<li>Query.offset(40) 跳过前 40 条（页码式分页）</li>
</ul>
<p><strong>返回结果</strong>：</p>
<p><code>listDocuments</code> 这个方法返回的结构里通常包含 <code>total</code>（符合条件的总条数）和 <code>documents</code>（当前页数组）。如果数据量很大，想要做无限滚动的页面，需要使用分页机制，可以参考我的另一篇文章。
<a href="https://juejin.cn/post/7569576952232624147" target="_blank" title="https://juejin.cn/post/7569576952232624147">【React Native+Appwrite】获取数据时的分页机制</a></p>
<p>使用例子：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> databases.<span class="hljs-title function_">listDocuments</span>(<span class="hljs-string">'dbId'</span>, <span class="hljs-string">'collectionId'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">documents</span>);
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsers</span>(<span class="hljs-params">page = <span class="hljs-number">1</span>, limit = <span class="hljs-number">15</span></span>) {
    <span class="hljs-keyword">const</span> offset = (page - <span class="hljs-number">1</span>) * limit;
​
    <span class="hljs-keyword">try</span> {
​
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> databases.<span class="hljs-title function_">listDocuments</span>(<span class="hljs-variable constant_">DATABASE_ID</span>, <span class="hljs-variable constant_">USERS_TABLE_ID</span>, [
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">limit</span>(limit),
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">offset</span>(offset),
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">"sex"</span>, <span class="hljs-string">"male"</span>),
        ]);
        <span class="hljs-comment">//等价于跳过offset个数据，找到limit个'sex'字段等于'male'的数据</span>
​
​
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'成功连接！'</span>)
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取到的用户数据:'</span>, result)
​
        <span class="hljs-keyword">return</span> result
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'连接 Appwrite 失败:'</span>, error)
    }
}
​
</code></pre>
<h4 data-id="heading-10">5. ReactNative 中一些容易报错的点</h4>
<h5 data-id="heading-11"><strong>Localhost Endpoint问题：</strong></h5>
<p>我们在配置客户端的时候，需要配置Endpoint和Project，如果写下<code>http://localhost/v1</code>作为Endpoint，后续在手机端上运行项目的时候可能会出现请求失败的错误，这是因为项目中的<code>localhost</code>指的是<strong>运行该进程的设备本身</strong>。所以在手机上的<code>http://localhost/v1</code>会去尝试手机本机的端口，而不是电脑上的Appwrite服务器，会导致网络请求失败。</p>
<p>那么如何解决这个问题呢？</p>
<p>①<em>Appwrite Cloud</em>：把Endpoint设置成<code>https://cloud.appwrite.io/v1</code>，操作简单、适合Expo使用。</p>
<ul>
<li>这是Appwrite 官方托管的云平台，官方帮你托管服务、数据库、文件等。</li>
<li>无需搭建后端或服务器</li>
<li>手机端天然可访问</li>
<li>稳定、最接近生产环境，免去了 IP 变化的烦恼</li>
</ul>
<p>可以理解为 Appwrite 的 <strong>“Firebase 模式”</strong> ：所有服务都在云端，由官方维护。</p>
<p>那么在上文中Appwrite官方给出的Endpoint是什么呢？是<code>https://fra.cloud.appwrite.io/v1</code>，是由于我在创建项目时选择了德国法兰克福区域，系统自动为我加入了法兰克福的地域标识代码<code>fra</code>，不加的话就是全局的入口。</p>
<p><strong>总结：</strong></p>
<ul>
<li><code>https://cloud.appwrite.io/v1</code> 是 <em>全球入口</em></li>
<li>而 <code>https://fra.cloud.appwrite.io/v1</code> 是 <em>区域入口</em></li>
<li>Cloud 会自动把你的项目分配到某个区域。</li>
</ul>
<p>②<em>使用局域网IP</em>：如果你坚持自己搭 Appwrite（本地或内网服务器），可以用你电脑的局域网 IP 替代 <code>localhost</code>，局域网IP可以在 Windows 命令行输入 <code>ipconfig</code>查看（通常是 <code>192.168.x.x</code>）。然后把Endpoint设置成<code>http://192.168.x.x/v1</code>。</p>
<ul>
<li>使用的前提是手机和电脑在同一个WiFi下</li>
<li>Appwrite 已允许来自局域网的访问</li>
</ul>
<p>③<em>内网穿透</em>：如果你想让别人访问你的本地Appwrite，可以使用ngrok、localtunnel、Cloudflare Tunnel进行内网穿透。把你本地的某个端口暴露成一个公网地址，这样外网设备（其他人的设备）就能访问你的本地服务，不需要在路由器上做端口映射或改 DNS。</p>
<p>命令示例：</p>
<pre><code class="hljs">ngrok http 80
</code></pre>
<p>会生成一个公网 URL，如：</p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//abc123.ngrok.io</span>
</code></pre>
<p>然后你就可以这样写：</p>
<pre><code class="hljs language-vbscript" lang="vbscript">.setEndpo<span class="hljs-built_in">int</span>(<span class="hljs-string">"https://abc123.ngrok.io/v1"</span>)
</code></pre>
<p>适合展示 demo、临时给同事使用。</p>
<h5 data-id="heading-12"><strong>Expo 开发服务器的 HTTPS 要求</strong></h5>
<p>在 Expo Go 应用中，如果你的 Appwrite Endpoint使用的是自签证书的 HTTPS 或纯 HTTP，可能会被阻止，导致 <code>Network request failed</code> 错误。这是因为Expo Go 为了安全，对非加密或证书不受信任的 HTTP 请求有严格限制。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li><strong>使用 Appwrite Cloud</strong>：这是最简单的方法，因为它提供了有效的 HTTPS 证书。</li>
<li>使用 <code>expo start --tunnel</code>（通过隧道生成一个可被手机访问的 https 地址）</li>
<li>使用 <code>ngrok http 80</code>，把 <code>http://localhost:80</code> 暴露成 <code>https://xxxx.ngrok.io</code>，然后把 Appwrite endpoint 设为 <code>https://xxxx.ngrok.io/v1</code>。</li>
</ul>
<h5 data-id="heading-13">RN 没有 Browser API</h5>
<p>React Native 运行在 JavaScriptCore 或 Hermes 引擎中，没有 DOM 和 BOM，所以许多的API都没有：</p>
<ul>
<li>没有window、document对象</li>
<li>没有localStorage、sessionStorage</li>
<li>没有Cookie API</li>
<li>没有XMLHttpRequest（但有兼容实现）</li>
<li>没有FormData的完整实现</li>
</ul>
<h3 data-id="heading-14">五、实战Demo</h3>
<p>在实战中，我的写法是：（前提是已经配置好.env文件）</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//appwrite.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span>, <span class="hljs-title class_">Databases</span>, <span class="hljs-title class_">Query</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native-appwrite"</span>
​
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DATABASE_ID</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">EXPO_PUBLIC_APPWRITE_DATABASE_ID</span>!;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TABLE_ID</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">EXPO_PUBLIC_APPWRITE_TABLE_ID</span>!;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NOTES_TABLE_ID</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">EXPO_PUBLIC_APPWRITE_NOTES_TABLE_ID</span>!;
​
​
<span class="hljs-comment">//初始化客户端</span>
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>().<span class="hljs-title function_">setEndpoint</span>(<span class="hljs-string">'https://cloud.appwrite.io/v1'</span>).<span class="hljs-title function_">setProject</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">EXPO_PUBLIC_APPWRITE_PROJECT_ID</span>!)
​
<span class="hljs-keyword">const</span> databases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Databases</span>(client);
​
<span class="hljs-comment">//获取数据</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNotes</span>(<span class="hljs-params">page = <span class="hljs-number">1</span>, limit = <span class="hljs-number">15</span></span>) {
    
    <span class="hljs-comment">//偏移量</span>
    <span class="hljs-keyword">const</span> offset = (page - <span class="hljs-number">1</span>) * limit;
​
    <span class="hljs-keyword">try</span> {
​
        <span class="hljs-comment">//偏移offset条，获取limit个'type==plan'的数据</span>
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> databases.<span class="hljs-title function_">listDocuments</span>(<span class="hljs-variable constant_">DATABASE_ID</span>, <span class="hljs-variable constant_">NOTES_TABLE_ID</span>, [
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">limit</span>(limit),
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">offset</span>(offset),
            <span class="hljs-title class_">Query</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">"type"</span>, <span class="hljs-string">"plan"</span>),
        ]);
​
        <span class="hljs-comment">//获取完后输出一下结果</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'成功连接！'</span>)
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取到的用户数据:'</span>, result)
​
        <span class="hljs-keyword">return</span> result
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'连接 Appwrite 失败:'</span>, error)
    }
}
</code></pre>

<pre><code class="hljs language-ini" lang="ini">//index.tsx
​
const <span class="hljs-attr">Plan</span> = () =&gt; {
    const <span class="hljs-attr">router</span> = useRouter()<span class="hljs-comment">;</span>
​
    const <span class="hljs-section">[refreshing, setRefreshing]</span> = useState(false)<span class="hljs-comment">;</span>
    const <span class="hljs-section">[loading, setLoading]</span> = useState(false)<span class="hljs-comment">;</span>
    const <span class="hljs-section">[notes, setNotes]</span> = useState&lt;any<span class="hljs-section">[]</span>&gt;(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
    const <span class="hljs-section">[page, setPage]</span> = useState(1)<span class="hljs-comment">; // 分页页码</span>
    const <span class="hljs-section">[hasMore, setHasMore]</span> = useState(true)<span class="hljs-comment">; // 是否还有更多数据</span>
​
    // 加载数据
    const <span class="hljs-attr">loadNotes</span> = useCallback(
        //reset用于记录是否重新加载
        async (<span class="hljs-attr">reset</span> = <span class="hljs-literal">false</span>) =&gt; {
            if (loading) return<span class="hljs-comment">; // 避免重复请求</span>
            setLoading(true)<span class="hljs-comment">;</span>
​
            try {
​
                //计算请求的页码，如果是重新加载，那么从第1页开始加载，如果不是，从第page页开始
                const <span class="hljs-attr">currentPage</span> = reset ? <span class="hljs-number">1</span> : page<span class="hljs-comment">;</span>
​
                const <span class="hljs-attr">result</span> = await getNotes(currentPage)<span class="hljs-comment">; //获取数据</span>
                const <span class="hljs-attr">data</span> = result.documents<span class="hljs-comment">;</span>
​
                if (reset) {
                    //如果要重置（遇到了下拉刷新的情况），那么重新设置data和page
                    setNotes(data)<span class="hljs-comment">;</span>
                    setPage(2)<span class="hljs-comment">; // 下一页页码</span>
                } else {
                    //如果不是重置（上拉加载新页面），设置好Notes的数据，根据 '$id'筛选掉重复的数据，然后追加到notes里
                    setNotes(<span class="hljs-attr">prev</span> =&gt; [...prev, ...data.filter(d =&gt; !prev.some(p =&gt; p.<span class="hljs-variable">$id</span> === d.<span class="hljs-variable">$id</span>))])<span class="hljs-comment">;</span>
                    //设置页数
                    setPage(<span class="hljs-attr">prev</span> =&gt; prev + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
                }
​
                if (!data || data.length &lt; 15) setHasMore(false)<span class="hljs-comment">;</span>
            } catch (err) {
                console.error(err)<span class="hljs-comment">;</span>
            } finally {
                setLoading(false)<span class="hljs-comment">;</span>
            }
        },
        <span class="hljs-section">[loading, page]</span>
    )<span class="hljs-comment">;</span>
​
    useEffect(() =&gt; {
        loadNotes()<span class="hljs-comment">;</span>
    }, <span class="hljs-section">[]</span>)<span class="hljs-comment">; // 初次加载</span>
​
    useEffect(() =&gt; {
        console.log("notes更新：", notes)<span class="hljs-comment">;</span>
    }, <span class="hljs-section">[notes]</span>)<span class="hljs-comment">; // 每次 notes 变化时打印</span>
​
​
    // 下拉刷新
    const <span class="hljs-attr">onRefresh</span> = async () =&gt; {
        setRefreshing(true)<span class="hljs-comment">;</span>
        await loadNotes(true)<span class="hljs-comment">;</span>
        setHasMore(true)<span class="hljs-comment">;</span>
        setRefreshing(false)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
​
    // 上拉加载更多
    const <span class="hljs-attr">onEndReached</span> = async () =&gt; {
        if (!loading &amp;&amp; hasMore) {
            await loadNotes(false)<span class="hljs-comment">;</span>
        }
    }<span class="hljs-comment">;</span>
​
    return (
        &lt;View <span class="hljs-attr">style</span>={styles.container}&gt;
​
            &lt;ScrollView <span class="hljs-attr">showsVerticalScrollIndicator</span>={<span class="hljs-literal">false</span>}&gt;
​
            {/* 笔记列表,用FlatList来加载，NoteCard组件可以自由发挥 */}
            &lt;FlatList 
                <span class="hljs-attr">data</span>={notes}
                <span class="hljs-attr">numColumns</span>={<span class="hljs-number">2</span>}
                <span class="hljs-attr">contentContainerStyle</span>={{
                paddingHorizontal: 16,
                paddingBottom: 60,
                }}
                <span class="hljs-attr">columnWrapperStyle</span>={{justifyContent: <span class="hljs-string">"space-around"</span>,}}
                <span class="hljs-attr">keyExtractor</span>={(item) =&gt; item.<span class="hljs-variable">$id</span>}
                <span class="hljs-attr">renderItem</span>={({ item }) =&gt; (
                &lt;NoteCard <span class="hljs-attr">note</span>={item} /&gt;)}
            /&gt;
​
            &lt;/ScrollView&gt;
​
        &lt;/View&gt;
    )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
​
​
export default Plan<span class="hljs-comment">;</span>
​
</code></pre>
<p>运行后控制台会输出结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/24dc5da7c97648288f288d4edc31057f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5aS05bCP6bm_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763727630&amp;x-signature=2e39An9QBGD2fZgJ%2F%2BOZcv7g2fc%3D" alt="data.png" loading="lazy"/></p>
<h3 data-id="heading-15">六、总结</h3>
<p>如果你正在开发一款基于ReactNative+Expo的App，甚至只是一个Demo，想减少后端工作量，实现快速、轻量化的开发，那么Appwrite是一个非常值得尝试的BaaS平台。</p>
<p>它的优点在于：</p>
<ul>
<li>它是<em>开源平台</em>，可自行部署</li>
<li>提供了<em>简洁的可视化后台</em>，极大地方便了操作</li>
<li><em>API设计与文档</em>清晰完善</li>
<li>支持<em>多端</em>：Web、React Native、Flutter、iOS、Android</li>
<li>内置 数据库、用户认证、文件存储、函数云、推送等<em>完整后端能力</em>。</li>
<li>具有<em>直观的API设计</em>：<code>listDocuments</code>、<code>createDocument</code>等方法命名清晰，配合Query条件筛选，让前端数据操作变得轻松自然。</li>
</ul>
<p>边做Demo边写博客，断断续续终于写完了，耗时有点长，可能有错误的地方，欢迎指正。也欢迎大家来讨论~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite & Webpack & Rollup 入口与产出配置与示例]]></title>    <link>https://juejin.cn/post/7572413448941830171</link>    <guid>https://juejin.cn/post/7572413448941830171</guid>    <pubDate>2025-11-14T13:04:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572413448941830171" data-draft-id="7572389069706608650" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite &amp; Webpack &amp; Rollup 入口与产出配置与示例"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-14T13:04:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拿不拿铁19"/> <meta itemprop="url" content="https://juejin.cn/user/3417747845299064"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite &amp; Webpack &amp; Rollup 入口与产出配置与示例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3417747845299064/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拿不拿铁19
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T13:04:03.000Z" title="Fri Nov 14 2025 13:04:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>对Vite v5.x、Webpack v5.x、Rollup v4.x三个主流前端构建工具，分别记录入口与产出的配置，并且给出与配置文件相对应的项目结构和构建后的示例文件内容。</p>
<p>备注：输出产物文件夹统一采用“构建工具名称+dist”命名，静态资源路径统一采用“构建工具名称+asset”命名。</p>
<h2 data-id="heading-0">一、Vite v5.x 配置与输出示例</h2>
<h3 data-id="heading-1">1.1 核心配置文件（vite.config.js）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-comment">// 项目根目录配置（自定义为src目录）</span>
  <span class="hljs-attr">root</span>: <span class="hljs-string">'./src'</span>, <span class="hljs-comment">// 自定义项目根目录为src，入口路径需基于此目录编写</span>
  <span class="hljs-comment">// 基础路径配置（自定义为子路径部署场景）</span>
  <span class="hljs-attr">base</span>: <span class="hljs-string">'/vite-app/'</span>, <span class="hljs-comment">// 自定义为子路径/vite-app/，适配生产环境部署到子目录的场景</span>
  <span class="hljs-comment">// 静态资源公共目录配置（publicDir）</span>
  <span class="hljs-attr">publicDir</span>: <span class="hljs-string">'../vite-public'</span>, <span class="hljs-comment">// 配置public目录为项目根目录下的vite-public，存放无需处理的静态资源</span>
  <span class="hljs-comment">// 打包配置</span>
  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 产出配置</span>
    <span class="hljs-attr">outDir</span>: <span class="hljs-string">'../vite-dist'</span>, <span class="hljs-comment">// 因root为src，需向上一级输出，保持工具名+dist规则</span>
    <span class="hljs-attr">assetsDir</span>: <span class="hljs-string">'vite-asset'</span>, <span class="hljs-comment">// 静态资源路径：构建工具名称+asset</span>
    <span class="hljs-attr">assetsInlineLimit</span>: <span class="hljs-number">4096</span>, <span class="hljs-comment">// 小于4kb的静态资源内联，超过则输出到assetsDir</span>
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-comment">// 明确入口文件配置（基于root:./src，路径简化）</span>
      <span class="hljs-attr">input</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-string">'./main.js'</span>, <span class="hljs-comment">// 主入口，基于root:./src，实际路径为src/main.js</span>
        <span class="hljs-attr">subPage</span>: <span class="hljs-string">'./subPage.js'</span> <span class="hljs-comment">// 子入口，实际路径为src/subPage.js</span>
      },
      <span class="hljs-comment">// 多入口对应输出配置（可选，默认按入口名生成对应文件）</span>
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'vite-asset/js/[name]-[hash].js'</span>, <span class="hljs-comment">// 入口JS输出路径及命名</span>
        <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'vite-asset/js/[name]-[hash].js'</span>, <span class="hljs-comment">// 代码分割chunk输出路径及命名</span>
        <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'vite-asset/[ext]/[name]-[hash].[ext]'</span> <span class="hljs-comment">// 静态资源（css、图片等）输出路径及命名</span>
      }
    },
    <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否生成sourcemap，生产环境建议关闭</span>
    <span class="hljs-attr">minify</span>: <span class="hljs-string">'esbuild'</span> <span class="hljs-comment">// 压缩工具，Vite默认使用esbuild，可替换为terser</span>
  },
  ...
})
</code></pre>
<h3 data-id="heading-2">1.2 入口与产出配置说明</h3>







































































<table><thead><tr><th>配置类型</th><th>具体配置项</th><th>配置值</th><th>说明</th></tr></thead><tbody><tr><td>入口配置</td><td>主入口</td><td>./main.js</td><td>基于root:./src，实际路径为src/main.js，负责初始化应用</td></tr><tr><td/><td>子入口</td><td>./subPage.js</td><td>基于root:./src，实际路径为src/subPage.js，多入口场景可独立打包</td></tr><tr><td>产出及基础配置</td><td>项目根目录（root）</td><td>./src</td><td>自定义为src目录，入口路径需基于此编写，简化入口路径写法</td></tr><tr><td/><td>基础路径（base）</td><td>/vite-app/</td><td>自定义为子路径，适配生产环境部署到域名下/vite-app/子目录的场景，影响资源引用路径</td></tr><tr><td/><td>静态资源公共目录（publicDir）</td><td>../vite-public</td><td>基于root:./src，实际路径为项目根目录下vite-public，存放无需处理的静态资源，打包时直接复制到产物根目录</td></tr><tr><td/><td>产物根目录</td><td>../vite-dist</td><td>因root为src，需向上一级输出，保持“工具名+dist”规则，实际位于项目根目录下</td></tr><tr><td/><td>静态资源目录</td><td>vite-asset</td><td>存放JS、CSS、图片等经处理的静态资源，遵循“构建工具名称+asset”规则</td></tr><tr><td/><td>入口JS输出路径</td><td>vite-asset/js/[name]-[hash].js</td><td>[name]为入口名，[hash]为文件哈希值，用于缓存控制</td></tr><tr><td/><td>chunk输出路径</td><td>vite-asset/js/[name]-[hash].js</td><td>代码分割后生成的公共模块或异步模块文件路径</td></tr><tr><td/><td>其他静态资源路径</td><td>vite-asset/[ext]/[name]-[hash].[ext]</td><td>[ext]为文件扩展名，按扩展名分类存放经处理的图片、CSS等资源</td></tr></tbody></table>
<h3 data-id="heading-3">1.3 打包后文件内容示例</h3>
<h4 data-id="heading-4">1.3.1 文件结构</h4>
<pre><code class="hljs language-Plain" lang="Plain">// 项目整体目录结构（体现root、publicDir与outDir关系）
project-root/          // 实际项目根目录
├── src/               // root配置指定的项目根目录
│   ├── main.js        // 主入口文件
│   ├── subPage.js     // 子入口文件
│   └── vite.config.js // Vite配置文件（因root为src，配置文件可放src内）
├── vite-public/       // publicDir配置指定的静态资源公共目录
│   ├── favicon.ico    // 网站图标（无需处理，打包直接复制）
│   └── static/        // 公共静态资源子目录
│       └── global.css // 全局静态CSS（无需构建工具处理）
└── vite-dist/         // 产物根目录，由outDir:../vite-dist生成
    ├── index.html     // 主入口对应的HTML文件
    ├── subPage.html   // 子入口对应的HTML文件
    ├── favicon.ico    // 从vite-public复制过来的网站图标
    ├── static/        // 从vite-public复制过来的静态资源子目录
    │   └── global.css // 从vite-public复制过来的全局CSS
    └── vite-asset/    // 经构建工具处理后的静态资源目录
        ├── js/        // JS文件目录
        │   ├── main-8f7d2b.js      // 主入口JS文件（哈希值示例）
        │   ├── subPage-3e5a1c.js   // 子入口JS文件（哈希值示例）
        │   └── vendor-7b9c4d.js    // 公共依赖chunk（如Vue框架）
        ├── css/       // CSS文件目录
        │   ├── main-5d8f3e.css     // 主入口对应的CSS文件
        │   └── subPage-2a4c6b.css  // 子入口对应的CSS文件
        └── img/       // 图片资源目录
            └── logo-9a3b5d.png     // 图片资源文件（哈希值示例，经处理后输出）
</code></pre>
<h4 data-id="heading-5">1.3.2 关键文件内容示例</h4>
<p><strong>1. vite-dist/index.html</strong></p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite 主入口页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite-app/favicon.ico"</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite-app/static/global.css"</span>&gt;</span> 
  <span class="hljs-comment">&lt;!-- 资源引用路径前缀为base配置的/vite-app/，经处理的CSS在vite-asset下 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite-app/vite-asset/css/main-5d8f3e.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 脚本引用路径同样添加base前缀，经处理的JS在vite-asset下 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/vite-app/vite-asset/js/vendor-7b9c4d.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/vite-app/vite-asset/js/main-8f7d2b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>2. vite-dist/vite-asset/js/main-8f7d2b.js（简化版）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'./vendor-7b9c4d.js'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;
<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>);
<span class="hljs-comment">// 业务逻辑代码（已压缩，此处为简化展示）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Vite 主入口应用启动'</span>);
</code></pre>
<h2 data-id="heading-6">二、Webpack v5.x 配置与输出示例</h2>
<h3 data-id="heading-7">2.1 核心配置文件（webpack.config.js）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>); <span class="hljs-comment">// 生成HTML文件的插件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>); <span class="hljs-comment">// 提取CSS为单独文件的插件</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// 项目根目录配置</span>
  <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>), <span class="hljs-comment">// 自定义根目录为src，入口路径基于此编写</span>
  <span class="hljs-comment">// 入口配置（基于context:src，路径简化）</span>
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./main.js'</span>, <span class="hljs-comment">// 主入口，基于context:src，实际路径为src/main.js</span>
    <span class="hljs-attr">subPage</span>: <span class="hljs-string">'./subPage.js'</span> <span class="hljs-comment">// 子入口，实际路径为src/subPage.js</span>
  },
  <span class="hljs-comment">// 产出配置</span>
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'webpack-dist'</span>), <span class="hljs-comment">// 输出产物文件夹：构建工具名称+dist</span>
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'webpack-asset/js/[name]-[contenthash].js'</span>, <span class="hljs-comment">// 入口JS输出路径及命名</span>
    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'webpack-asset/js/[name]-[contenthash].chunk.js'</span>, <span class="hljs-comment">// 代码分割chunk输出路径</span>
    <span class="hljs-attr">assetModuleFilename</span>: <span class="hljs-string">'webpack-asset/[ext]/[name]-[contenthash].[ext]'</span>, <span class="hljs-comment">// 静态资源输出路径</span>
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/webpack-app/'</span>, <span class="hljs-comment">// 基础路径，适配子路径部署</span>
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 打包前清理输出目录</span>
  },
  <span class="hljs-comment">// 模块解析规则</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">'css-loader'</span>], <span class="hljs-comment">// 提取CSS为单独文件</span>
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|jpeg|gif)$/i</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">'asset'</span>, <span class="hljs-comment">// 自动判断是否内联或输出为文件</span>
        <span class="hljs-attr">parser</span>: {
          <span class="hljs-attr">dataUrlCondition</span>: {
            <span class="hljs-attr">maxSize</span>: <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 4kb以下内联，超过输出到静态资源目录</span>
          }
        }
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/(node_modules|bower_components)/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>, <span class="hljs-comment">// 转译ES6+语法</span>
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">presets</span>: [<span class="hljs-string">'@babel/preset-env'</span>]
          }
        }
      }
    ]
  },
  <span class="hljs-comment">// 插件配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 为每个入口生成对应的HTML文件</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.html'</span>,
      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'public/index.html'</span>), <span class="hljs-comment">// 模板路径需补全根目录</span>
      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">'main'</span>, <span class="hljs-string">'vendor'</span>] <span class="hljs-comment">// 引入主入口JS和公共依赖chunk</span>
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'subPage.html'</span>,
      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'public/subPage.html'</span>), <span class="hljs-comment">// 模板路径需补全根目录</span>
      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">'subPage'</span>, <span class="hljs-string">'vendor'</span>] <span class="hljs-comment">// 引入子入口JS和公共依赖chunk</span>
    }),
    <span class="hljs-comment">// 配置CSS输出路径</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'webpack-asset/css/[name]-[contenthash].css'</span>,
      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'webpack-asset/css/[name]-[contenthash].chunk.css'</span>
    })
  ],
  <span class="hljs-comment">// 代码分割配置</span>
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendor'</span>, <span class="hljs-comment">// 公共依赖chunk名称</span>
          <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span> <span class="hljs-comment">// 优先级，多个缓存组规则冲突时，按优先级决定模块归属</span>
        }
      }
    },
    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-string">'single'</span> <span class="hljs-comment">// 提取运行时代码，优化缓存</span>
  },
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span> <span class="hljs-comment">// 生产环境模式（自动开启压缩等优化）</span>
};
</code></pre>
<h3 data-id="heading-8">2.2 入口与产出配置说明</h3>

































































<table><thead><tr><th>配置类型</th><th>具体配置项</th><th>配置值</th><th>说明</th></tr></thead><tbody><tr><td>入口配置</td><td>主入口</td><td>./main.js</td><td>基于context:src，实际路径为src/main.js，负责初始化应用</td></tr><tr><td/><td>子入口</td><td>./subPage.js</td><td>基于context:src，实际路径为src/subPage.js，多入口场景可独立打包</td></tr><tr><td>产出及基础配置</td><td>项目根目录（context）</td><td>path.resolve(__dirname, 'src')</td><td>类似Vite的root，自定义根目录为src，入口路径基于此编写</td></tr><tr><td/><td>基础路径（publicPath）</td><td>/webpack-app/</td><td>类似Vite的base，适配子路径部署，自动为资源添加路径前缀</td></tr><tr><td/><td>产物根目录</td><td>webpack-dist</td><td>打包后所有文件的根文件夹，遵循“构建工具名称+dist”规则</td></tr><tr><td/><td>静态资源根目录</td><td>webpack-asset</td><td>存放JS、CSS、图片等静态资源，遵循“构建工具名称+asset”规则</td></tr><tr><td/><td>入口JS输出路径</td><td>webpack-asset/js/[name]-[contenthash].js</td><td>[name]为入口名，[contenthash]为内容哈希值，用于长效缓存</td></tr><tr><td/><td>chunk输出路径</td><td>webpack-asset/js/[name]-[contenthash].chunk.js</td><td>代码分割后生成的公共模块（如vendor）或异步模块文件路径</td></tr><tr><td/><td>图片等资源输出路径</td><td>webpack-asset/[ext]/[name]-[contenthash].[ext]</td><td>[ext]为文件扩展名，按扩展名分类存放静态资源</td></tr></tbody></table>
<h3 data-id="heading-9">2.3 打包后文件内容示例</h3>
<h4 data-id="heading-10">2.3.1 文件结构</h4>
<pre><code class="hljs language-Plain" lang="Plain">// 项目整体目录结构（体现context与output.path关系）
project-root/          // 实际项目根目录
├── src/               // context配置指定的项目根目录
│   ├── main.js        // 主入口文件（基于context简化路径）
│   ├── subPage.js     // 子入口文件
│   └── webpack.config.js // Webpack配置文件（可放项目根目录，需补全路径）
├── public/            // 静态模板目录
│   ├── index.html     // 主入口HTML模板
│   └── subPage.html   // 子入口HTML模板
└── webpack-dist/      // 产物根目录，由output.path生成
    ├── index.html     // 主入口对应的HTML文件
    ├── subPage.html   // 子入口对应的HTML文件
    ├── webpack-asset/ // 静态资源目录
    │   ├── js/        // JS文件目录
    │   │   ├── main-9f2d7b.contenthash.js       // 主入口JS文件
    │   │   ├── subPage-4e6a3c.contenthash.js    // 子入口JS文件
    │   │   ├── vendor-8b7c5d.contenthash.js     // 公共依赖chunk（如第三方库）
    │   │   └── runtime-main.contenthash.js      // 运行时代码chunk
    │   ├── css/       // CSS文件目录
    │   │   ├── main-6d9f4e.contenthash.css      // 主入口对应的CSS文件
    │   │   └── subPage-3a5c7b.contenthash.css   // 子入口对应的CSS文件
    │   └── png/       // 图片资源目录（按扩展名分类）
    │       └── logo-7a4b6d.contenthash.png      // 图片资源文件
    └── favicon.ico    // 从public目录复制的静态文件（若有）
</code></pre>
<h4 data-id="heading-11">2.3.2 关键文件内容示例</h4>
<p><strong>1. webpack-dist/index.html</strong></p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack 主入口页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 资源路径自动添加publicPath前缀/webpack-app/ --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/webpack-app/webpack-asset/css/main-6d9f4e.contenthash.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/webpack-app/webpack-asset/js/runtime-main.contenthash.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/webpack-app/webpack-asset/js/vendor-8b7c5d.contenthash.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/webpack-app/webpack-asset/js/main-9f2d7b.contenthash.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>2. webpack-dist/webpack-asset/js/main-9f2d7b.contenthash.js（简化版）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-meta">"use strict"</span>;
(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){<span class="hljs-keyword">function</span> <span class="hljs-title function_">r</span>(<span class="hljs-params">e,n,t</span>){<span class="hljs-keyword">function</span> <span class="hljs-title function_">o</span>(<span class="hljs-params">i,f</span>){<span class="hljs-keyword">if</span>(!n[i]){<span class="hljs-keyword">if</span>(!e[i]){<span class="hljs-keyword">var</span> c=<span class="hljs-string">"function"</span>==<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">if</span>(!f&amp;&amp;c)<span class="hljs-keyword">return</span> <span class="hljs-title function_">c</span>(i,!<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(u)<span class="hljs-keyword">return</span> <span class="hljs-title function_">u</span>(i,!<span class="hljs-number">0</span>);<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Cannot find module '"</span>+i+<span class="hljs-string">"'"</span>);<span class="hljs-keyword">throw</span> a.<span class="hljs-property">code</span>=<span class="hljs-string">"MODULE_NOT_FOUND"</span>,a}<span class="hljs-keyword">var</span> p=n[i]={<span class="hljs-attr">exports</span>:{}};e[i][<span class="hljs-number">0</span>].<span class="hljs-title function_">call</span>(p.<span class="hljs-property">exports</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>){<span class="hljs-keyword">var</span> n=e[i][<span class="hljs-number">1</span>][r];<span class="hljs-keyword">return</span> <span class="hljs-title function_">o</span>(n||r)},p,p.<span class="hljs-property">exports</span>,r,e,n,t)}<span class="hljs-keyword">return</span> n[i].<span class="hljs-property">exports</span>}<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> u=<span class="hljs-string">"function"</span>==<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>&amp;&amp;<span class="hljs-built_in">require</span>,i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-property">length</span>;i++)<span class="hljs-title function_">o</span>(t[i]);<span class="hljs-keyword">return</span> o}<span class="hljs-keyword">return</span> r})()({<span class="hljs-number">1</span>:[<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>,<span class="hljs-variable language_">module</span>,<span class="hljs-built_in">exports</span></span>){
<span class="hljs-comment">// 引入依赖和业务代码</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./App.js'</span>);
<span class="hljs-title class_">App</span>.<span class="hljs-title function_">init</span>(<span class="hljs-string">'#app'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Webpack 主入口应用启动'</span>);
},{<span class="hljs-string">'./App.js'</span>:<span class="hljs-number">2</span>}]},{},[<span class="hljs-number">1</span>]);
</code></pre>
<h2 data-id="heading-12">三、Rollup v4.x 配置与输出示例</h2>
<h3 data-id="heading-13">3.1 核心配置文件（rollup.config.js）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'rollup'</span>;
<span class="hljs-keyword">import</span> babel <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-babel'</span>; <span class="hljs-comment">// 转译ES6+语法</span>
<span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-node-resolve'</span>; <span class="hljs-comment">// 解析第三方模块</span>
<span class="hljs-keyword">import</span> commonjs <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-commonjs'</span>; <span class="hljs-comment">// 转换CommonJS模块为ES模块</span>
<span class="hljs-keyword">import</span> css <span class="hljs-keyword">from</span> <span class="hljs-string">'rollup-plugin-css-only'</span>; <span class="hljs-comment">// 处理CSS文件</span>
<span class="hljs-keyword">import</span> html <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-html'</span>; <span class="hljs-comment">// 生成HTML文件</span>
<span class="hljs-keyword">import</span> image <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-image'</span>; <span class="hljs-comment">// 处理图片资源</span>
<span class="hljs-keyword">import</span> { terser } <span class="hljs-keyword">from</span> <span class="hljs-string">'rollup-plugin-terser'</span>; <span class="hljs-comment">// 压缩JS代码</span>
<span class="hljs-keyword">import</span> hash <span class="hljs-keyword">from</span> <span class="hljs-string">'rollup-plugin-hash'</span>; <span class="hljs-comment">// 生成文件哈希值</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-comment">// 项目根目录配置，rollup需要通过插件配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 配置根目录为src，解析模块时优先从src查找</span>
    <span class="hljs-title function_">resolve</span>({
      <span class="hljs-attr">rootDir</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
      <span class="hljs-attr">moduleDirectories</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>)]
    }),
    <span class="hljs-comment">// 转换CommonJS模块为ES模块</span>
    <span class="hljs-title function_">commonjs</span>(),
    <span class="hljs-comment">// 转译ES6+语法</span>
    <span class="hljs-title function_">babel</span>({
      <span class="hljs-attr">exclude</span>: <span class="hljs-string">'node_modules/**'</span>,
      <span class="hljs-attr">presets</span>: [<span class="hljs-string">'@babel/preset-env'</span>]
    }),
    <span class="hljs-comment">// 处理CSS文件，提取为单独文件</span>
    <span class="hljs-title function_">css</span>({
      <span class="hljs-attr">output</span>: <span class="hljs-string">'rollup-asset/css/[name]-[hash].css'</span>
    }),
    <span class="hljs-comment">// 处理图片资源，小图片内联为base64，大图片输出为文件</span>
    <span class="hljs-title function_">image</span>({
      <span class="hljs-attr">limit</span>: <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 4kb以下内联</span>
    }),
    <span class="hljs-comment">// 生成HTML文件，自动引入打包后的资源（配置base路径）</span>
    <span class="hljs-title function_">html</span>({
      <span class="hljs-attr">fileName</span>: <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${name}</span>.html`</span>, <span class="hljs-comment">// 为每个入口生成对应HTML</span>
      <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/rollup-app/'</span>, <span class="hljs-comment">// 基础路径（类似Vite的base），适配子路径部署</span>
      <span class="hljs-attr">template</span>: <span class="hljs-function">(<span class="hljs-params">{ attributes, bundle, files, publicPath, title }</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> jsFiles = files.<span class="hljs-property">js</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file.<span class="hljs-property">name</span> === title.<span class="hljs-title function_">toLowerCase</span>());
        <span class="hljs-keyword">const</span> cssFiles = files.<span class="hljs-property">css</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file.<span class="hljs-property">name</span> === title.<span class="hljs-title function_">toLowerCase</span>());
        <span class="hljs-keyword">return</span> <span class="hljs-string">`
          &lt;!DOCTYPE html&gt;
          &lt;html&gt;
          &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;<span class="hljs-subst">${title}</span>&lt;/title&gt;
            <span class="hljs-subst">${cssFiles.map(file =&gt; <span class="hljs-string">`&lt;link rel="stylesheet" href="<span class="hljs-subst">${publicPath}</span><span class="hljs-subst">${file.fileName}</span>"&gt;`</span>).join(<span class="hljs-string">''</span>)}</span>
          &lt;/head&gt;
          &lt;body&gt;
            &lt;div id="app"&gt;&lt;/div&gt;
            <span class="hljs-subst">${jsFiles.map(file =&gt; <span class="hljs-string">`&lt;script type="module" src="<span class="hljs-subst">${publicPath}</span><span class="hljs-subst">${file.fileName}</span>"&gt;&lt;/script&gt;`</span>).join(<span class="hljs-string">''</span>)}</span>
          &lt;/body&gt;
          &lt;/html&gt;
        `</span>;
      },
      <span class="hljs-attr">title</span>: <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> <span class="hljs-string">`Rollup <span class="hljs-subst">${name.charAt(<span class="hljs-number">0</span>).toUpperCase() + name.slice(<span class="hljs-number">1</span>)}</span> Page`</span>
    }),
    <span class="hljs-comment">// 生成文件哈希值，用于缓存控制</span>
    <span class="hljs-title function_">hash</span>({
      <span class="hljs-attr">dest</span>: <span class="hljs-string">'rollup-dist'</span>,
      <span class="hljs-attr">hashLength</span>: <span class="hljs-number">8</span> <span class="hljs-comment">// 哈希值长度</span>
    }),
    <span class="hljs-comment">// 生产环境压缩JS代码</span>
    <span class="hljs-title function_">terser</span>()
  ],
  <span class="hljs-comment">// 入口配置（基于rootDir:src，路径简化）</span>
  <span class="hljs-attr">input</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./main.js'</span>, <span class="hljs-comment">// 主入口，基于rootDir:src，实际路径为src/main.js</span>
    <span class="hljs-attr">subPage</span>: <span class="hljs-string">'./subPage.js'</span> <span class="hljs-comment">// 子入口，实际路径为src/subPage.js</span>
  },
  <span class="hljs-comment">// 产出配置（多入口时可配置多个输出）</span>
  <span class="hljs-attr">output</span>: [
    {
      <span class="hljs-attr">dir</span>: <span class="hljs-string">'../rollup-dist'</span>, <span class="hljs-comment">// 因rootDir为src，需向上一级输出，保持工具名+dist规则</span>
      <span class="hljs-attr">format</span>: <span class="hljs-string">'esm'</span>, <span class="hljs-comment">// 输出为ES模块格式</span>
      <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">'rollup-asset/js/[name]-[hash].js'</span>, <span class="hljs-comment">// 入口JS输出路径</span>
      <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">'rollup-asset/js/[name]-[hash].chunk.js'</span>, <span class="hljs-comment">// 代码分割chunk路径</span>
      <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">'rollup-asset/[extname]/[name]-[hash][extname]'</span>, <span class="hljs-comment">// 静态资源路径</span>
      <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">false</span>
    }
  ],
  <span class="hljs-comment">// 代码分割配置</span>
  <span class="hljs-attr">preserveModules</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 关闭保留模块结构，合并相关模块</span>
});
</code></pre>
<h3 data-id="heading-14">3.2 入口与产出配置说明</h3>



























































<table><thead><tr><th>配置类型</th><th>具体配置项</th><th>配置值</th><th>说明</th></tr></thead><tbody><tr><td>入口配置</td><td>主入口</td><td>./main.js</td><td>基于rootDir:src，实际路径为src/main.js，负责初始化应用</td></tr><tr><td/><td>子入口</td><td>./subPage.js</td><td>基于rootDir:src，实际路径为src/subPage.js，独立生成对应文件</td></tr><tr><td>产出及基础配置</td><td>项目根目录（rootDir）</td><td>path.resolve(__dirname, 'src')</td><td>类似Vite的root，通过resolve插件配置，入口路径基于此简化</td></tr><tr><td/><td>基础路径（publicPath）</td><td>/rollup-app/</td><td>类似Vite的base，在html插件中配置，为资源引用添加路径前缀</td></tr><tr><td/><td>产物根目录</td><td>../rollup-dist</td><td>因rootDir为src，向上一级输出，实际位于项目根目录，遵循工具名+dist规则</td></tr><tr><td/><td>静态资源根目录</td><td>rollup-asset</td><td>存放JS、CSS、图片等静态资源，遵循“构建工具名称+asset”规则</td></tr><tr><td/><td>入口JS输出路径</td><td>rollup-asset/js/[name]-[hash].js</td><td>[name]为入口名，[hash]为文件哈希值，输出为ES模块格式</td></tr><tr><td/><td>CSS输出路径</td><td>rollup-asset/css/[name]-[hash].css</td><td>通过rollup-plugin-css-only提取的单独CSS文件路径</td></tr></tbody></table>
<h3 data-id="heading-15">3.3 打包后文件内容示例</h3>
<h4 data-id="heading-16">3.3.1 文件结构</h4>
<pre><code class="hljs language-Plain" lang="Plain">// 项目整体目录结构（体现rootDir与output.dir关系）
project-root/          // 实际项目根目录
├── src/               // rootDir配置指定的项目根目录
│   ├── main.js        // 主入口文件（基于rootDir简化路径）
│   ├── subPage.js     // 子入口文件
│   └── rollup.config.js // Rollup配置文件（放src内，需适配根目录）
└── rollup-dist/       // 产物根目录，由output.dir:../rollup-dist生成
    ├── main.html      // 主入口对应的HTML文件
    ├── subPage.html   // 子入口对应的HTML文件
    ├── manifest.json  // 哈希值映射表（记录原文件名与哈希文件名的对应关系）
    └── rollup-asset/  // 静态资源目录
        ├── js/        // JS文件目录
        │   ├── main-7d2f9b.js      // 主入口JS文件（哈希值示例）
        │   ├── subPage-3c5a1e.js   // 子入口JS文件（哈希值示例）
        │   └── common-5b7c4d.js    // 公共模块chunk（代码分割生成）
        ├── css/       // CSS文件目录
        │   ├── main-4f8d3e.css     // 主入口对应的CSS文件
        │   └── subPage-2b6c5a.css  // 子入口对应的CSS文件
        └── png/       // 图片资源目录（按扩展名分类）
            └── logo-6d3b5a.png     // 图片资源文件（哈希值示例，超过4kb时输出）
</code></pre>
<h4 data-id="heading-17">3.3.2 关键文件内容示例</h4>
<p><strong>1. rollup-dist/main.html</strong></p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Rollup Main Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 资源引用路径添加publicPath前缀/rollup-app/ --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/rollup-app/rollup-asset/css/main-4f8d3e.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/rollup-app/rollup-asset/js/common-5b7c4d.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/rollup-app/rollup-asset/js/main-7d2f9b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>2. rollup-dist/rollup-asset/js/main-7d2f9b.js（简化版）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { commonFunc } <span class="hljs-keyword">from</span> <span class="hljs-string">'./common-5b7c4d.js'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
  <span class="hljs-title function_">init</span>(<span class="hljs-params">el</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);
    <span class="hljs-title function_">commonFunc</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'&lt;h1&gt;Rollup 应用&lt;/h1&gt;'</span>;
  }
}

<span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>().<span class="hljs-title function_">init</span>(<span class="hljs-string">'#app'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Rollup 主入口应用启动'</span>);

</code></pre>
<h2 data-id="heading-18">四、构建工具共性配置</h2>
<h3 data-id="heading-19">4.1 共性配置（功能对标）</h3>
<p>三大工具虽配置名称或实现方式不同，但核心功能存在明确对标关系，均围绕“入口管理、资源处理、产出控制、环境适配”四大核心场景设计，具体对标如下：</p>




































































<table><thead><tr><th><strong>功能场景</strong></th><th><strong>Vite v5.x</strong></th><th><strong>Webpack v5.x</strong></th><th><strong>Rollup v4.x</strong></th><th><strong>功能共性说明</strong></th></tr></thead><tbody><tr><td>项目根目录</td><td>root</td><td>context</td><td>resolve.rootDir（插件配置）</td><td>定义项目基准目录，简化入口及模块引用路径，统一资源查找根节点</td></tr><tr><td>部署基础路径</td><td>base</td><td>output.publicPath</td><td>html.publicPath（插件配置）</td><td>适配子路径部署场景，为所有资源引用添加统一路径前缀，避免404错误</td></tr><tr><td>静态资源公共目录</td><td>publicDir（原生）</td><td>copy-webpack-plugin（插件）</td><td>rollup-plugin-copy（插件）</td><td>存放无需构建处理的静态资源（如favicon、全局静态CSS），打包时直接复制到产物根目录</td></tr><tr><td>入口配置</td><td>build.rollupOptions.input</td><td>entry</td><td>input</td><td>支持单入口/多入口配置，指定应用启动的核心文件路径，多入口时可独立生成产物</td></tr><tr><td>产物输出目录</td><td>build.outDir</td><td>output.path</td><td>output.dir</td><td>指定打包后产物的存放目录，均支持自定义路径</td></tr><tr><td>静态资源输出路径</td><td>build.assetsDir + 输出规则</td><td>output.assetModuleFilename</td><td>output.assetFileNames</td><td>指定JS、CSS、图片等经处理资源的输出路径及命名规则，支持哈希值优化缓存</td></tr><tr><td>代码分割</td><td>build.rollupOptions.output.chunkFileNames</td><td>optimization.splitChunks</td><td>output.chunkFileNames</td><td>拆分公共依赖（如第三方库）或异步模块，减少重复代码，提升首屏加载速度</td></tr><tr><td>压缩优化</td><td>build.minify（esbuild/terser）</td><td>mode: production（自动压缩）</td><td>rollup-plugin-terser（插件）</td><td>生产环境压缩JS/CSS代码，移除空格、注释，降低产物体积</td></tr></tbody></table>
<h2 data-id="heading-20">总结</h2>
<ol>
<li>Vite：顶层配置简洁直观，原生集成开发/预览服务器，开发启动速度快，适合前端应用快速开发；</li>
<li>Webpack：配置灵活全面，loader+插件生态丰富，支持复杂模块解析和场景适配，适合大型复杂项目；</li>
<li>Rollup：专注ES模块打包，支持多格式输出，产物轻量无冗余，适合类库或轻量应用开发。</li>
</ol>
<p>实际项目中可根据项目类型（应用/类库）、复杂度及团队熟悉度选择：前端应用优先选Vite，大型复杂项目选Webpack，类库开发选Rollup。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Promise：让 JavaScript 异步任务“同步化”的利器]]></title>    <link>https://juejin.cn/post/7572390974460133376</link>    <guid>https://juejin.cn/post/7572390974460133376</guid>    <pubDate>2025-11-14T14:26:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572390974460133376" data-draft-id="7570899512782864447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Promise：让 JavaScript 异步任务“同步化”的利器"/> <meta itemprop="keywords" content="前端,JavaScript,Promise"/> <meta itemprop="datePublished" content="2025-11-14T14:26:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Promise：让 JavaScript 异步任务“同步化”的利器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T14:26:27.000Z" title="Fri Nov 14 2025 14:26:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在前端开发中，异步编程是绕不开的话题。JavaScript 作为一门单线程语言，无法像多线程语言那样并行处理多个任务。为了不让耗时操作（如网络请求、文件读取、定时器等）阻塞主线程，JS 引入了**事件循环（Event Loop）**机制，将这些操作放入任务队列中，等待主线程空闲后再执行。</p>
<p>但随之而来的问题是：<strong>代码的执行顺序不再与书写顺序一致</strong>，这使得逻辑变得难以追踪，尤其在复杂的业务场景中，很容易陷入“回调地狱”。</p>
<p>为了解决这一问题，ES6 引入了 <strong>Promise</strong> —— 一种用于更优雅地处理异步操作的工具。它不仅让异步代码看起来像“同步”执行，还极大地提升了代码的可读性与可维护性。</p>
<hr/>
<h2 data-id="heading-1">一、为什么需要 Promise？</h2>
<h3 data-id="heading-2">1. JavaScript 的单线程特性</h3>
<p>JavaScript 是单线程语言，意味着同一时间只能执行一个任务。如果遇到耗时操作（比如 <code>setTimeout</code> 或 <code>fs.readFile</code>），若采用同步方式等待，页面就会卡死，用户无法进行任何交互。</p>
<p>因此，JS 将这些操作交给浏览器或 Node.js 环境去异步处理，主线程继续执行后续代码。例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>), <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// 输出：1 → 3 → 2</span>
</code></pre>
<p>虽然 <code>setTimeout</code> 延迟为 0，但它仍是异步任务，会被放入任务队列，等主线程执行完所有同步代码后才执行。</p>
<h3 data-id="heading-3">2. 回调函数的局限性</h3>
<p>早期我们通过回调函数处理异步结果：</p>
<pre><code class="hljs language-javascript" lang="javascript">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'a.txt'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});
</code></pre>
<p>但当多个异步操作需要按顺序执行时，回调嵌套会迅速失控：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">readFile</span>(<span class="hljs-string">'1.txt'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'2.txt'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'3.txt'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 回调地狱！</span>
    });
  });
});
</code></pre>
<p>这种代码不仅难以阅读，调试和错误处理也极其困难。</p>
<hr/>
<h2 data-id="heading-4">二、Promise：异步变“同步”的桥梁</h2>
<p>Promise 是 ES6 提供的一种对象，用于表示一个异步操作的最终完成（或失败）及其结果值。它的核心思想是：<strong>将异步操作的结果“封装”起来，通过 <code>.then()</code> 和 <code>.catch()</code> 来统一处理成功与失败的情况</strong>。</p>
<h3 data-id="heading-5">基本用法示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 立刻执行，输出 1（同步代码）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);

<span class="hljs-comment">// 2. 创建一个 Promise，立刻开始执行里面的代码（但里面的异步操作不会阻塞后续代码）</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-comment">// 3. 设置一个 1 秒后执行的定时器（异步任务，不会马上运行）</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 5. 1 秒后，先输出 2</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// 6. 调用 resolve()，告诉 Promise：“任务完成了！”</span>
    <span class="hljs-title function_">resolve</span>();
  }, <span class="hljs-number">1000</span>);
});

<span class="hljs-comment">// 4. 注册一个“当 Promise 成功完成时”要运行的函数（但此时 Promise 还没完成，所以先记下来）</span>
p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 7. Promise 完成后，立即执行这里，输出 3</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
});

<span class="hljs-comment">// 最终输出顺序：1 → 2 → 3</span>
<span class="hljs-comment">// 虽然 2 和 3 是异步的，但通过 Promise，我们确保了 3 一定在 2 之后执行。</span>
</code></pre>
<p>虽然 <code>setTimeout</code> 仍是异步的，但通过 Promise，我们确保了“3”一定在“2”之后输出，<strong>实现了逻辑上的“同步化”</strong> 。</p>
<hr/>
<h2 data-id="heading-6">三、深入理解 Promise 机制</h2>
<h3 data-id="heading-7">1. Promise 的三种状态</h3>
<ul>
<li><strong>pending（进行中）</strong> ：初始状态，既不是成功也不是失败。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76b7def1bab040aa8174ac53830c1eac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763735187&amp;x-signature=wqq68QatjhOUKOSNVQXWP9mE%2Bew%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li><strong>fulfilled（已成功）</strong> ：异步操作成功完成，调用 <code>resolve()</code>。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae7489d88a754d13843e307c4a989e21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763735187&amp;x-signature=UYpYpSt2sQBQ6jFbiqEH%2BdcjeMY%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li><strong>rejected（已失败）</strong> ：异步操作失败，调用 <code>reject()</code>。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18e5ef69f25848789e15ebddb74deedc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUFB6Zi_Z2lhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763735187&amp;x-signature=qqbiDfNtx7Hyf5489nTv9Q2udYM%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>一旦状态改变，就不可逆。</p>
<h3 data-id="heading-8">2. 构造函数同步执行</h3>
<p><code>new Promise()</code> 中的执行器函数（executor）是<strong>立即同步执行</strong>的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 立刻执行，输出 'start'（同步任务）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start'</span>);

<span class="hljs-comment">// 2. 创建一个 Promise，会**立即同步执行**传入的函数（称为 executor）</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-comment">// 3. 这行是同步执行的！所以马上输出 'in executor'</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'in executor'</span>);

  <span class="hljs-comment">// 4. 设置一个 1 秒后调用 resolve() 的定时器（异步任务，不会阻塞代码）</span>
  <span class="hljs-comment">//    此时 Promise 状态还是 pending，但主线程不会等它</span>
  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>);
});

<span class="hljs-comment">// 5. 主线程继续往下走，立刻执行这行，输出 'end'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'end'</span>);

<span class="hljs-comment">// 最终输出顺序：start → in executor → end</span>
<span class="hljs-comment">// 注意：setTimeout 里的 resolve 要 1 秒后才运行，但 console.log('end') 不会等它，</span>
<span class="hljs-comment">// 因为 Promise 的 executor 是同步执行的，而 setTimeout 是异步的。</span>
</code></pre>
<p>异步任务（如 <code>setTimeout</code>）在 executor 内部启动，但 executor 本身是同步运行的。</p>
<h3 data-id="heading-9">3. 链式调用与错误处理</h3>
<p><code>.then()</code> 返回一个新的 Promise，支持链式调用：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 发起一个网络请求，获取 lemoncode 组织的成员列表（异步操作）</span>
<span class="hljs-comment">//    fetch() 立即返回一个 Promise，不会阻塞后续代码</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.github.com/orgs/lemoncode/members'</span>)

  <span class="hljs-comment">// 2. 当请求成功返回响应（Response 对象）后，进入第一个 .then()</span>
  <span class="hljs-comment">//    调用 res.json() 将响应体解析为 JSON 格式（它也返回一个 Promise）</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())

  <span class="hljs-comment">// 3. 当 JSON 解析完成后，进入第二个 .then()</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">members</span> =&gt;</span> {
    <span class="hljs-comment">// 4. 找到页面中 id 为 'members' 的元素</span>
    <span class="hljs-comment">//    把每个成员的 login 名称转成 &lt;li&gt; 标签，并拼接成字符串</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'members'</span>).<span class="hljs-property">innerHTML</span> = 
      members.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">${item.login}</span>&lt;/li&gt;`</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
  })

  <span class="hljs-comment">// 5. 如果上面任意一步出错（网络失败、JSON 解析失败等），</span>
  <span class="hljs-comment">//    就会跳到这里，捕获错误并打印出来</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败:'</span>, err);
  });
</code></pre>
<p>这种方式避免了回调嵌套，逻辑清晰，错误也能集中处理。</p>
<hr/>
<h2 data-id="heading-10">四、实际应用场景</h2>
<h3 data-id="heading-11">1. 文件读取（Node.js）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 引入 Node.js 的文件系统模块（用于读写文件）</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-comment">// 2. 立刻执行，输出 1（同步任务）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);

<span class="hljs-comment">// 3. 创建一个 Promise 实例 p</span>
<span class="hljs-comment">//    注意：new Promise() 中的函数会**立即同步执行**</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-comment">// 4. 这行是同步执行的！所以马上输出 3</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);

  <span class="hljs-comment">// 5. 调用 fs.readFile 读取 './b.txt' 文件（这是异步 I/O 操作）</span>
  <span class="hljs-comment">//    主线程不会等待，而是继续往下执行，读取结果稍后通过回调返回</span>
  fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./b.txt'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
    <span class="hljs-comment">// 8. 【1秒或更久后】文件读取完成，进入这个回调（异步执行）</span>

    <span class="hljs-comment">// 打印错误信息（如果有的话），用于调试</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err, <span class="hljs-string">'//////'</span>);

    <span class="hljs-comment">// 如果读取出错（比如文件不存在）</span>
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-title function_">reject</span>(err);  <span class="hljs-comment">// 让 Promise 变成失败状态</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 读取成功，把 Buffer 转成字符串并 resolve</span>
    <span class="hljs-title function_">resolve</span>(data.<span class="hljs-title function_">toString</span>());
  });
});

<span class="hljs-comment">// 6. 注册成功和失败的处理函数</span>
p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-comment">// 9. 如果文件读取成功，这里会执行，输出文件内容</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">'//////'</span>);
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-comment">// 9. 如果文件读取失败，这里会执行，输出错误</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err, <span class="hljs-string">'读取文件失败'</span>);
});

<span class="hljs-comment">// 7. 主线程继续执行，不等文件读取完成，立刻输出 2（同步任务）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
</code></pre>
<p><strong>最终输出顺序（假设文件存在）：</strong></p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-number">1</span>
<span class="hljs-number">3</span>
<span class="hljs-number">2</span>
null //<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>        ← err 为 null 表示无错误
&lt;文件内容&gt; <span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>  
</code></pre>
<p><strong>如果文件 不存在，则输出：</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-number">1</span>
<span class="hljs-number">3</span>
<span class="hljs-number">2</span>
[<span class="hljs-meta">Error: ENOENT...</span>] <span class="hljs-comment"><span class="hljs-doctag">///</span><span class="hljs-doctag">///</span>  </span>
[<span class="hljs-meta">Error: ENOENT...</span>] 读取文件失败
</code></pre>
<h4 data-id="heading-12">关键总结：</h4>
<ul>
<li><code>console.log(1)</code>、<code>console.log(3)</code>、<code>console.log(2)</code> 都是<strong>同步代码</strong>，按顺序立即执行 → 输出 <strong>1 → 3 → 2</strong>。</li>
<li><code>fs.readFile</code> 是<strong>异步操作</strong>，它的回调（包括 <code>resolve</code>/<code>reject</code>）会在 I/O 完成后才执行，因此 <code>.then()</code> 或 <code>.catch()</code> 的内容<strong>一定在 2 之后输出</strong>。</li>
<li>Promise 的 executor（传给 new Promise 的函数）是<strong>同步执行的</strong>，但其中的异步操作（如 readFile）不会阻塞主线程。</li>
</ul>
<hr/>
<h3 data-id="heading-13">2. 网络请求（浏览器）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 发起一个网络请求，获取 lemoncode 组织的成员列表</span>
<span class="hljs-comment">//    fetch() 立刻返回一个 Promise，不会卡住页面（异步操作）</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.github.com/orgs/lemoncode/members'</span>)

  <span class="hljs-comment">// 2. 当服务器返回响应（比如状态码 200）后，进入第一个 .then()</span>
  <span class="hljs-comment">//    response.json() 会把响应体（通常是 JSON 字符串）解析成 JavaScript 对象</span>
  <span class="hljs-comment">//    它也返回一个 Promise，所以可以继续链式调用</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())

  <span class="hljs-comment">// 3. 当 JSON 解析完成，进入第二个 .then()</span>
  <span class="hljs-comment">//    此时 members 是一个数组，每个元素是一个成员对象，例如 { login: "antonio06", ... }</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">members</span> =&gt;</span> {
    <span class="hljs-comment">// 4. 把每个成员的用户名（m.login）转成 &lt;li&gt; 标签</span>
    <span class="hljs-comment">//    例如：[{login:"alice"}] → ["&lt;li&gt;alice&lt;/li&gt;"] → "&lt;li&gt;alice&lt;/li&gt;"</span>
    <span class="hljs-keyword">const</span> list = members.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">${m.login}</span>&lt;/li&gt;`</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);

    <span class="hljs-comment">// 5. 找到 HTML 中 id="members" 的元素，把生成的列表插入进去</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'members'</span>).<span class="hljs-property">innerHTML</span> = list;
  })

  <span class="hljs-comment">// 6. 如果上面任何一步出错（比如网络断了、URL 写错、JSON 格式不对等），</span>
  <span class="hljs-comment">//    就会跳过所有 .then()，直接进入 .catch() 处理错误</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取成员失败:'</span>, error);
  });
</code></pre>
<h4 data-id="heading-14">关键总结：</h4>
<ul>
<li>整个过程是<strong>异步的</strong>，但通过 <code>.then()</code> 链，让逻辑像“一步一步顺序执行”一样清晰。</li>
<li><code>.catch()</code> 能捕获整个链中的任何错误，避免程序崩溃。</li>
</ul>
<hr/>
<h2 data-id="heading-15">五、Promise vs 回调函数：谁更胜一筹？</h2>






























<table><thead><tr><th>特性</th><th>回调函数</th><th>Promise</th></tr></thead><tbody><tr><td>可读性</td><td>嵌套深，难维护</td><td>链式调用，结构清晰</td></tr><tr><td>错误处理</td><td>每层需单独处理</td><td>统一 <code>.catch()</code> 捕获</td></tr><tr><td>组合多个异步</td><td>困难</td><td>支持 <code>Promise.all()</code>、<code>Promise.race()</code> 等</td></tr><tr><td>返回值传递</td><td>手动传参</td><td>自动通过 <code>resolve(value)</code> 传递</td></tr></tbody></table>
<p>显然，Promise 在现代 JS 开发中已成为异步处理的标准方案。</p>
<hr/>
<h2 data-id="heading-16">结语</h2>
<p>Promise 并没有真正让异步变成同步——底层依然是异步执行。但它通过<strong>状态管理</strong>和<strong>链式调用</strong>，让我们能以接近同步的方式编写和理解异步代码，极大提升了开发体验。</p>
<p>随着 <code>async/await</code> 的普及（其底层正是基于 Promise），异步编程变得更加简洁直观。但理解 Promise 的原理，仍是掌握现代 JavaScript 异步编程的基石。</p>
<blockquote>
<p>正如那句老话： <strong>“Promise 不是魔法，但它让异步世界变得更有序。”</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《大厂面试：从手写 Ajax 到封装 getJSON，再到理解 Promise 与 sleep》]]></title>    <link>https://juejin.cn/post/7572524368875569187</link>    <guid>https://juejin.cn/post/7572524368875569187</guid>    <pubDate>2025-11-14T15:03:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572524368875569187" data-draft-id="7572382777838616616" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《大厂面试：从手写 Ajax 到封装 getJSON，再到理解 Promise 与 sleep》"/> <meta itemprop="keywords" content="面试,Ajax"/> <meta itemprop="datePublished" content="2025-11-14T15:03:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="xhxxx"/> <meta itemprop="url" content="https://juejin.cn/user/3235201610941578"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《大厂面试：从手写 Ajax 到封装 getJSON，再到理解 Promise 与 sleep》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3235201610941578/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    xhxxx
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T15:03:03.000Z" title="Fri Nov 14 2025 15:03:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">大厂面试必考：从手写 Ajax 到封装 getJSON，再到理解 Promise 与 sleep</h2>
<p>在前端工程师的求职过程中，尤其是冲击一线大厂（如阿里、腾讯、字节等）时，<strong>手写代码题</strong>几乎是绕不开的一环。这些题目看似基础，实则考察候选人对 JavaScript 核心机制的理解深度——包括异步编程、事件循环、内存模型以及浏览器原生 API 的掌握程度。</p>
<p>本文将焦三个经典手写题：</p>
<ol>
<li><strong>手写原生 Ajax</strong></li>
<li><strong>封装支持 Promise 的 getJSON 函数</strong></li>
<li><strong>手写 sleep 函数</strong></li>
</ol>
<p>我们将逐层深入，不仅写出代码，更要讲清楚“为什么这么写”，帮助你在面试中不仅能写出来，还能讲明白。</p>
<hr/>
<h3 data-id="heading-1">一、手写 Ajax：回调地狱的起点</h3>
<p>虽然现代开发中我们早已习惯使用 <code>fetch</code> 或 <code>axios</code>，但 <strong>Ajax 是所有网络请求的基石</strong>。面试官让你手写 Ajax，不是为了让你重复造轮子，而是检验你是否真正理解 HTTP 请求在浏览器中的实现方式。
ajax 基于回调函数实现，代码复杂，这正是其痛点所在。</p>
<h4 data-id="heading-2">手写一个基础版 Ajax</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url, callback</span>) {
  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
  
  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 异步请求</span>
  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) { <span class="hljs-comment">// 请求完成</span>
      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
        <span class="hljs-comment">// 成功：调用回调并传入响应数据</span>
        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 失败：传入错误</span>
        <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${xhr.status}</span>`</span>), <span class="hljs-literal">null</span>);
      }
    }
  };
  xhr.<span class="hljs-title function_">send</span>();
}
</code></pre>
<h4 data-id="heading-3">问题在哪？</h4>
<ul>
<li><strong>强依赖回调函数</strong>：调用方必须传入 <code>callback</code>，无法链式操作；</li>
<li><strong>错误处理分散</strong>：成功和失败逻辑耦合在同一个函数里；</li>
<li><strong>无法组合多个异步操作</strong>：比如“先请求 A，再根据 A 的结果请求 B”，代码会迅速变得嵌套混乱——即所谓的“回调地狱”。</li>
</ul>
<p>这正是为什么我们需要 <strong>Promise</strong>。</p>
<hr/>
<h3 data-id="heading-4">二、封装 getJSON：用 Promise 改造 Ajax</h3>
<blockquote>
<p>“如何封装一个 getJSON 函数。使用 ajax，支持 Promise，get 请求方法，返回是 JSON”</p>
</blockquote>
<p>这其实是一个典型的“将传统回调式 API 转为 Promise 化”的过程。</p>
<h4 data-id="heading-5">封装思路</h4>
<ul>
<li>创建一个返回 <code>Promise</code> 的函数；</li>
<li>在 <code>Promise</code> 构造函数内部执行 Ajax；</li>
<li>成功时调用 <code>resolve(data)</code>，失败时调用 <code>reject(error)</code>；</li>
<li>自动解析 JSON 响应体。</li>
</ul>
<h4 data-id="heading-6">实现代码</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);
    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">'Accept'</span>, <span class="hljs-string">'application/json'</span>);

    xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);
          <span class="hljs-title function_">resolve</span>(data);
        } <span class="hljs-keyword">catch</span> (e) {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Invalid JSON response'</span>));
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Request failed with status <span class="hljs-subst">${xhr.status}</span>`</span>));
      }
    };

    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network error'</span>));
    };

    xhr.<span class="hljs-title function_">send</span>();
  });
}
</code></pre>
<h4 data-id="heading-7">使用方式（对比 fetch）</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 使用我们封装的 getJSON</span>
<span class="hljs-title function_">getJSON</span>(<span class="hljs-string">'/api/user'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed:'</span>, err));

<span class="hljs-comment">// 等价于 fetch 写法（但 fetch 不自动抛出 HTTP 错误）</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/user'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'HTTP error'</span>);
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));
</code></pre>
<h4 data-id="heading-8">为什么 Promise 更好？</h4>
<blockquote>
<p>“fetch 简单易用，基于 Promise 实现，(then)无需回调函数”</p>
</blockquote>
<p>Promise 的核心优势在于：</p>
<ul>
<li><strong>状态机模型</strong>：初始为 <code>pending</code>，只能变为 <code>fulfilled</code>（通过 <code>resolve</code>）或 <code>rejected</code>（通过 <code>reject</code>），且状态不可逆；</li>
<li><strong>链式调用</strong>：<code>.then().catch()</code> 形成清晰的流程控制；</li>
<li><strong>统一错误处理</strong>：任意环节出错，都会被最近的 <code>.catch</code> 捕获。</li>
</ul>
<p>这使得异步代码更接近同步逻辑的阅读体验。</p>
<hr/>
<h3 data-id="heading-9">三、深入 Promise：不只是语法糖</h3>
<blockquote>
<p>“promise 类 ，为异步变同步而(流程控制)实例化，事实标准。接收一个函数，函数有两个参数，resolve reject，他们也是函数。”</p>
</blockquote>
<ul>
<li><code>new Promise(executor)</code> 中的 <code>executor</code> 是一个立即执行的函数；</li>
<li>它接收两个参数：<code>resolve</code> 和 <code>reject</code>，都是由 Promise 内部提供的函数；</li>
<li>调用 <code>resolve(value)</code> 会将 Promise 状态转为 <code>fulfilled</code>，并将 <code>value</code> 传递给下一个 <code>.then</code>；</li>
<li>调用 <code>reject(reason)</code> 则转为 <code>rejected</code>，触发 <code>.catch</code>。</li>
</ul>
<p>例如：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'ok'</span>) : <span class="hljs-title function_">reject</span>(<span class="hljs-string">'fail'</span>);
  }, <span class="hljs-number">1000</span>);
});

p.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>).<span class="hljs-keyword">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
</code></pre>
<p>这种设计让开发者能<strong>主动控制异步结果的“成功”或“失败”路径</strong>，是构建可靠异步系统的基础。</p>
<hr/>
<h3 data-id="heading-10">四、手写 sleep：Promise</h3>
<h4 data-id="heading-11">实现</h4>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">n</span>){
            <span class="hljs-keyword">let</span> p;
                 p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
                
                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>{
                <span class="hljs-comment">// pending 等待</span>
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);
                <span class="hljs-comment">//resolve();</span>
                <span class="hljs-title function_">reject</span>();
                <span class="hljs-comment">// fulfilled  成功</span>
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);
                }
                    ,n);
            })
            <span class="hljs-keyword">return</span> p;
        }
        <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>{
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3s后执行'</span>);

        })
        .<span class="hljs-keyword">catch</span>(<span class="hljs-function">()=&gt;</span>{
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3s后执行失败'</span>);
        })
        <span class="hljs-comment">// promise 状态改变 就会执行</span>
        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>{
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'finally'</span>);
        })
</code></pre>
<h3 data-id="heading-12">手写题的本质是理解机制</h3>
<p>大厂面试之所以反复考察这些“老掉牙”的手写题，是因为它们像一面镜子，照出你对 JavaScript 运行机制的理解深度：</p>
<ul>
<li>Ajax → 浏览器网络 API + 回调模型；</li>
<li>Promise 封装 → 异步流程控制范式升级；</li>
<li>sleep → Promise 与定时器的创造性结合；</li>
</ul>
<p>当你不仅能写出这些代码，还能清晰解释其背后的原理时，你就已经超越了大多数候选人。</p>
<p><strong>记住：面试不是考你会不会用库，而是考你知不知道库为什么存在。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[springboot中yml、yaml、properties加载顺序]]></title>    <link>https://juejin.cn/post/7572459217810899007</link>    <guid>https://juejin.cn/post/7572459217810899007</guid>    <pubDate>2025-11-15T02:26:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459217810899007" data-draft-id="7572397142365225002" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="springboot中yml、yaml、properties加载顺序"/> <meta itemprop="keywords" content="后端,Spring,Spring Boot"/> <meta itemprop="datePublished" content="2025-11-15T02:26:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="考虑考虑"/> <meta itemprop="url" content="https://juejin.cn/user/4406498335157287"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            springboot中yml、yaml、properties加载顺序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4406498335157287/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    考虑考虑
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T02:26:27.000Z" title="Sat Nov 15 2025 02:26:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>Springboot对于文件配置加载，有着明确的配置加载顺序</p>
<h3 data-id="heading-1">配置文件加载顺序</h3>
<p>对于<code>yaml</code>、<code>yml</code>和<code>properties</code>配置文件,优先级低的配置会被先加载，所以优先级高的配置会覆盖优先级低的配置</p>
<pre><code class="hljs language-scss" lang="scss">properties（最高）&gt; yml &gt; <span class="hljs-built_in">yaml</span>(最低)
</code></pre>
<h4 data-id="heading-2">顺序验证</h4>
<p>1、配置加载</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> {

    <span class="hljs-meta">@Value(<span class="hljs-string">"<span class="hljs-subst">${hello.data}</span>"</span>)</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">data</span>;


    <span class="hljs-meta">@GetMapping(<span class="hljs-string">"/hello"</span>)</span>
    <span class="hljs-keyword">public</span> String hello() {
        log.info(<span class="hljs-string">"数据为:{{}}"</span>, Thread.currentThread());
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span>;
    }
}
</code></pre>
<p>配置<code>application.yaml</code>配置文件</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">hello:</span>
  <span class="hljs-attr">data:</span> <span class="hljs-string">test1</span>
</code></pre>
<p>如下图所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1ee4c9799be4b22a48897c0426b86f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=cR%2FvFTuI5RT3Pmj22KvoPhL17p8%3D" alt="image.png" loading="lazy"/></p>
<p>访问</p>
<pre><code class="hljs language-bash" lang="bash">http://ip:端口/hello
</code></pre>
<p>结果为</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18ea7800b4bd4e1e87616eb0ae103a06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=kBWJaxmOIPR1u3DXmpvA%2BlGQXRo%3D" alt="image.png" loading="lazy"/>
增加配置<code>application.yml</code>配置文件</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">hello:</span>
  <span class="hljs-attr">data:</span> <span class="hljs-string">test2</span>
</code></pre>
<p>如下图所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f640ef3ca8f44e95a0fe42168fd28d24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=EVvYlZxbRL0wKoTcljqTnL%2B7Vmg%3D" alt="image.png" loading="lazy"/></p>
<p>输出结果为</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4d235fe6ebb431c949edb1ae6f9b295~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=TOr1nzTQQ4CVRGKpVOyhM20MIjw%3D" alt="image.png" loading="lazy"/></p>
<p>增加配置<code>application.properties</code>配置文件</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d585001d560441f8e6bdf2d0d579f59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=hdmTtVL8%2FvCEoU26F0MBP%2F9Six0%3D" alt="image.png" loading="lazy"/>
配置内容为</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">hello.data</span>=aaa
</code></pre>
<p>输出结果为</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59388d9f56fc41009383a0f9e8923f95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ICD6JmR6ICD6JmR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763778387&amp;x-signature=YXT9lsJ9YCSFGHpKjDfAzLBzxvU%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">总结</h3>
<p><strong>同一级目录下加载顺序验证：</strong></p>
<p>properties的优先级高(当只有properties，yml，yaml)</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 5 个 “隐形坑”：上线前没注意，debug 到凌晨 3 点]]></title>    <link>https://juejin.cn/post/7572397142364962858</link>    <guid>https://juejin.cn/post/7572397142364962858</guid>    <pubDate>2025-11-14T15:32:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572397142364962858" data-draft-id="7572397142364930090" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 5 个 “隐形坑”：上线前没注意，debug 到凌晨 3 点"/> <meta itemprop="keywords" content="前端,React.js,JavaScript"/> <meta itemprop="datePublished" content="2025-11-14T15:32:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zzpper"/> <meta itemprop="url" content="https://juejin.cn/user/3560673121928058"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 5 个 “隐形坑”：上线前没注意，debug 到凌晨 3 点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3560673121928058/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zzpper
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T15:32:10.000Z" title="Fri Nov 14 2025 15:32:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">React 5 个 “隐形坑”：上线前没注意，debug 到凌晨 3 点</h2>
<p>用了这么久的React，我发现一个扎心规律：<strong>80% 的线上 bug 和性能卡顿，都来自那些 “看起来没问题” 的细节</strong>。</p>
<p>比如明明用了 React 18 的自动批处理，却还是触发多次渲染；Context 只改一个字段，整个组件树都跟着重渲染；异步回调里拿不到最新状态 —— 这些问题藏在日常编码的角落，开发时很难察觉，上线后却能让你连夜 debug。</p>
<p>今天就把这些 “重要但易忽略” 的 React 陷阱，拆成 5 个实战案例，每个都附 “反面案例 + 问题根源 + 解决方案”，帮你避开 90% 的隐形坑，代码写得又稳又快～</p>
<h3 data-id="heading-1">一、React 18 自动批处理 “失效”？这些场景不生效！</h3>
<p>React 18 的自动批处理（Automatic Batching）是个性能神器，能把多次状态更新合并成一次渲染，减少不必要的计算开销。但很多人不知道，它并不是 “万能的”，有些场景下会悄悄失效。</p>
<h4 data-id="heading-2">反面案例：以为会合并，结果触发两次渲染</h4>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 点击按钮，预期一次渲染，实际两次</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-comment">// 浏览器原生事件，自动批处理不生效</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setA</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
      <span class="hljs-title function_">setB</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
    });
  };

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件渲染'</span>); <span class="hljs-comment">// 会打印两次</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}

<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>)).<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
</code></pre>
<h4 data-id="heading-3">问题根源</h4>
<p>React 18 的自动批处理仅覆盖 “React 能控制的场景”，比如合成事件、Promise、setTimeout 等，但<strong>浏览器原生事件（resize、scroll）、SyntheticEvent 之外的场景</strong>，React 无法拦截调度，批处理会失效。</p>
<h4 data-id="heading-4">解决方案</h4>
<ol>
<li>用<code>unstable_batchedUpdates</code>手动包裹：</li>
</ol>
<p>javascript</p>
<pre><code class="hljs language-ini" lang="ini">import { unstable_batchedUpdates } from 'react-dom'<span class="hljs-comment">;</span>

const <span class="hljs-attr">handleClick</span> = () =&gt; {
  window.addEventListener('resize', () =&gt; {
    // 手动合并更新，仅触发一次渲染
    unstable_batchedUpdates(() =&gt; {
      setA(<span class="hljs-attr">prev</span> =&gt; prev + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
      setB(<span class="hljs-attr">prev</span> =&gt; prev + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<ol start="2">
<li>优先使用 React 合成事件，避免直接操作原生事件。</li>
</ol>
<h4 data-id="heading-5">关键提醒</h4>
<p>别滥用<code>flushSync</code>！它会强制同步更新，直接打断批处理，非必要场景（如需要立即获取更新后 DOM）不要用。</p>
<h3 data-id="heading-6">二、Context 的 “性能刺客”：改一个字段，全组件树重渲染</h3>
<p>Context 是 React 全局状态管理的常用工具，但很多人把所有状态都塞进一个 Context，结果变成 “牵一发而动全身” 的性能陷阱 —— 改用户昵称，连主题组件都跟着重渲染。</p>
<h4 data-id="heading-7">反面案例：大而全的 Context 导致无效重渲染</h4>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误：所有状态都放一个Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AppContext</span> = <span class="hljs-title function_">createContext</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> });
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'light'</span>);

  <span class="hljs-comment">// 每次渲染生成新对象，即使状态没变化也触发重渲染</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">user</span>, <span class="hljs-attr">setUser</span>, <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> }}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 只用到theme的组件，也会因user变化重渲染</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { theme, setTheme } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppContext</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'主题按钮重渲染'</span>); <span class="hljs-comment">//  user变化时也会打印</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme('dark')}&gt;切换主题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-8">问题根源</h4>
<ol>
<li>Context 未拆分，所有状态耦合在一起，一个字段变化会通知所有消费者。</li>
<li>Provider 的<code>value</code>是动态创建的对象，每次渲染都会生成新引用，导致子组件误判 “状态变化”。</li>
</ol>
<h4 data-id="heading-9">解决方案</h4>
<h5 data-id="heading-10">1. 拆分 Context，按功能模块化</h5>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 拆分后：用户Context和主题Context独立</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title function_">createContext</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>();

<span class="hljs-comment">// 用户Provider</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> });
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">user</span>, <span class="hljs-attr">setUser</span> }}&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>;
}

<span class="hljs-comment">// 主题Provider</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'light'</span>);
  <span class="hljs-comment">// 用useMemo缓存value，确保引用稳定</span>
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ theme, setTheme }), [theme]);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>;
}

<span class="hljs-comment">// 外层组合，避免嵌套地狱</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProviders</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">UserProvider</span>&gt;</span></span>
  );
}
</code></pre>
<h5 data-id="heading-11">2. 用<code>useContextSelector</code>精准订阅（React 18+）</h5>
<p>安装<code>use-context-selector</code>库，让组件只订阅需要的字段：</p>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useContextSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">'use-context-selector'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 仅订阅theme字段，user变化不影响</span>
  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContextSelector</span>(<span class="hljs-title class_">ThemeContext</span>, <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">theme</span>);
  <span class="hljs-keyword">const</span> setTheme = <span class="hljs-title function_">useContextSelector</span>(<span class="hljs-title class_">ThemeContext</span>, <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">setTheme</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme('dark')}&gt;切换主题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<p><img src="" alt="" loading="lazy"/><img src="" alt="image" loading="lazy"/></p>
<p>（示意图：左为未拆分 Context 的重渲染组件数，右为拆分后，标注 “重渲染组件数减少 79%”）</p>
<h3 data-id="heading-12">三、闭包陷阱：异步回调里的状态永远是 “旧值”</h3>
<p>这是 React Hooks 最容易踩的坑之一：明明状态已经更新，异步回调（如 setTimeout、接口回调）里却拿不到最新值，排查半天都找不到原因。</p>
<h4 data-id="heading-13">反面案例：定时器里的状态 “停滞不前”</h4>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">showCount</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-comment">// 3秒后弹出的count是调用时的旧值</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">`当前计数：<span class="hljs-subst">${count}</span>`</span>); <span class="hljs-comment">// 点击时count=3，弹出却可能是0</span>
    }, <span class="hljs-number">3000</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(prev =&gt; prev + 1)}&gt;加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{showCount}</span>&gt;</span>3秒后显示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h4 data-id="heading-14">问题根源</h4>
<p>每次组件渲染都是独立的函数调用，异步回调会捕获 “创建时” 的状态快照（闭包特性）。即使后续状态更新，回调里引用的还是旧的状态值。</p>
<h4 data-id="heading-15">解决方案</h4>
<h5 data-id="heading-16">1. 用 useRef 存储最新状态</h5>
<p>javascript</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">Counter</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  const countRef = <span class="hljs-built_in">useRef</span>(count);

  <span class="hljs-comment">// 每次状态更新，同步到ref.current</span>
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    countRef<span class="hljs-selector-class">.current</span> = count;
  }, <span class="hljs-selector-attr">[count]</span>);

  const showCount = () =&gt; {
    <span class="hljs-built_in">setTimeout</span>(() =&gt; {
      <span class="hljs-built_in">alert</span>(`当前计数：${countRef.current}`); <span class="hljs-comment">// 拿到最新值</span>
    }, <span class="hljs-number">3000</span>);
  };

  <span class="hljs-comment">// 其余代码不变</span>
}
</code></pre>
<h5 data-id="heading-17">2. 状态更新依赖前值？用函数式更新</h5>
<p>javascript</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 依赖前一个状态时，避免直接引用count</span>
<span class="hljs-built_in">setCount</span>(prev =&gt; prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// prev始终是最新状态</span>
</code></pre>
<h5 data-id="heading-18">3. 复杂场景用 useReducer</h5>
<p><code>dispatch</code>引用在组件生命周期内稳定，reducer 中能获取最新状态：</p>
<p>javascript</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { count: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"/>) </span>{
  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_ invoke__">useReducer</span>(reducer, { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });
  <span class="hljs-comment">// 无需依赖state，dispatch始终能触发最新状态更新</span>
}
</code></pre>
<h3 data-id="heading-19">四、useMemo/useCallback 滥用：优化变 “添乱”</h3>
<p>很多开发者把 useMemo 和 useCallback 当 “万能优化药”，不管什么场景都用上，结果不仅没提升性能，还增加了 React 的缓存开销 —— 这俩 Hook 是 “优化工具”，不是 “装饰器”。</p>
<h4 data-id="heading-20">反面案例：没必要的优化</h4>
<p>javascript</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 错误1：简单计算用useMemo，纯属多余</span>
const sum = <span class="hljs-built_in">useMemo</span>(() =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>, <span class="hljs-selector-attr">[a, b]</span>);

<span class="hljs-comment">// 错误2：不传递给子组件的函数用useCallback</span>
const handleInputChange = <span class="hljs-built_in">useCallback</span>((e) =&gt; {
  <span class="hljs-built_in">setValue</span>(e.target.value);
}, <span class="hljs-selector-attr">[]</span>);

<span class="hljs-comment">// 错误3：依赖项不全，导致缓存过时</span>
const filteredList = <span class="hljs-built_in">useMemo</span>(() =&gt; {
  return list<span class="hljs-selector-class">.filter</span>(item =&gt; item.status === status);
}, <span class="hljs-selector-attr">[list]</span>); <span class="hljs-comment">// 漏加status依赖，status变化后列表不更新</span>
</code></pre>
<h4 data-id="heading-21">问题根源</h4>
<ol>
<li>简单计算的声明成本远低于缓存开销，优化反而拖慢性能。</li>
<li>函数仅在组件内部使用时，是否重新创建对性能无影响。</li>
<li>依赖项不全导致缓存 “过期”，引发逻辑 bug。</li>
</ol>
<h4 data-id="heading-22">正确使用场景 &amp; 技巧</h4>
<h5 data-id="heading-23">1. useMemo：缓存复杂计算结果</h5>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 正确：大数据排序/过滤，计算成本高</span>
<span class="hljs-keyword">const</span> sortedProducts = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 1000+条数据排序，值得缓存</span>
  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">sales</span> - a.<span class="hljs-property">sales</span>);
}, [products]); <span class="hljs-comment">// 仅当products变化时重新计算</span>
</code></pre>
<h5 data-id="heading-24">2. useCallback：缓存传递给子组件的函数</h5>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 子组件用React.memo包裹（纯组件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductItem</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ product, onAddToCart }</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`渲染商品：<span class="hljs-subst">${product.name}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onAddToCart(product.id)}&gt;加入购物车<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
});

<span class="hljs-comment">// 父组件：用useCallback缓存函数，避免子组件无效重渲染</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params">{ products }</span>) {
  <span class="hljs-keyword">const</span> [cartCount, setCartCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> onAddToCart = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
    <span class="hljs-title function_">setCartCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
  }, [cartCount]); <span class="hljs-comment">// 依赖变化时才重新创建函数</span>

  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{product.id}</span> <span class="hljs-attr">product</span>=<span class="hljs-string">{product}</span> <span class="hljs-attr">onAddToCart</span>=<span class="hljs-string">{onAddToCart}</span> /&gt;</span></span>
  ));
}
</code></pre>
<h5 data-id="heading-25">3. 核心原则</h5>
<ul>
<li>先定位性能问题：用 React DevTools 的 Profiler 工具找到频繁重渲染 / 耗时计算的组件，再优化。</li>
<li>依赖项要 “全且准”：用到的所有状态 / 变量都要加入依赖数组。</li>
<li>不做 “预防性优化”：简单组件无需过早优化，优先保证代码可读性。</li>
</ul>
<h3 data-id="heading-26">五、组件卸载后异步未取消：内存泄漏的 “隐形杀手”</h3>
<p>切换路由或关闭弹窗时，组件已经卸载，但之前发起的接口请求、定时器还在运行，完成后尝试更新状态，就会触发警告：<code>Can't perform a React state update on an unmounted component</code>，还可能导致内存泄漏。</p>
<h4 data-id="heading-27">反面案例：卸载后异步任务仍在执行</h4>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [userInfo, setUserInfo] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 发起接口请求</span>
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/user'</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">// 组件卸载后，这里仍会执行</span>
        <span class="hljs-title function_">setUserInfo</span>(data);
      });

    <span class="hljs-comment">// 定时器未清理</span>
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'定时器还在运行'</span>);
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-comment">// 没有清理逻辑</span>
  }, []);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{userInfo?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-28">解决方案：useEffect 清理函数</h4>
<h5 data-id="heading-29">1. 取消接口请求（AbortController）</h5>
<p>javascript</p>
<pre><code class="hljs language-ini" lang="ini">useEffect(() =&gt; {
  const <span class="hljs-attr">controller</span> = new AbortController()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">signal</span> = controller.signal<span class="hljs-comment">;</span>

  fetch('/api/user', { signal })
    .then(<span class="hljs-attr">res</span> =&gt; res.json())
    .then(<span class="hljs-attr">data</span> =&gt; {
      setUserInfo(data)<span class="hljs-comment">;</span>
    })
    .catch(<span class="hljs-attr">err</span> =&gt; {
      if (<span class="hljs-attr">err.name</span> === <span class="hljs-string">'AbortError'</span>) return<span class="hljs-comment">; // 忽略取消请求的错误</span>
    })<span class="hljs-comment">;</span>

  // 组件卸载时取消请求
  return () =&gt; controller.abort()<span class="hljs-comment">;</span>
}, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
</code></pre>
<h5 data-id="heading-30">2. 清理定时器 / 事件监听</h5>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'定时器运行中'</span>);
  }, <span class="hljs-number">1000</span>);

  <span class="hljs-comment">// 清理定时器</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
}, []);
</code></pre>
<h5 data-id="heading-31">3. 标记组件挂载状态</h5>
<p>javascript</p>
<pre><code class="hljs language-ini" lang="ini">useEffect(() =&gt; {
  let <span class="hljs-attr">isMounted</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; // 标记组件是否挂载</span>

  fetch('/api/user')
    .then(<span class="hljs-attr">res</span> =&gt; res.json())
    .then(<span class="hljs-attr">data</span> =&gt; {
      if (isMounted) { // 仅当组件挂载时更新状态
        setUserInfo(data)<span class="hljs-comment">;</span>
      }
    })<span class="hljs-comment">;</span>

  return () =&gt; {
    <span class="hljs-attr">isMounted</span> = <span class="hljs-literal">false</span><span class="hljs-comment">; // 组件卸载时标记为false</span>
  }<span class="hljs-comment">;</span>
}, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-32">📌 最后：React 开发的 “避坑心法”</h3>
<p>其实这些容易被忽略的问题，核心都围绕一个原则：<strong>理解 React 的底层逻辑，而不是死记 API 用法</strong>。</p>
<ul>
<li>状态更新要懂 “批处理”，知道哪些场景会失效；</li>
<li>性能优化要抓 “关键点”，不做无用功；</li>
<li>异步操作要守 “生命周期”，及时清理副作用。</li>
</ul>
<p>开发时多问自己一句：“这个写法的底层逻辑是什么？有没有可能触发异常？” 很多隐形坑自然就避开了。</p>
<p>最后想问：你在 React 开发中还踩过哪些 “不起眼” 的坑？评论区聊聊，点赞最高的送一份《React 避坑手册》（含本文所有案例代码 + 排查工具清单）～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter DevTools 全景介绍]]></title>    <link>https://juejin.cn/post/7572387666980012058</link>    <guid>https://juejin.cn/post/7572387666980012058</guid>    <pubDate>2025-11-14T11:56:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572387666980012058" data-draft-id="7572389069706510346" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter DevTools 全景介绍"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2025-11-14T11:56:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="stringwu"/> <meta itemprop="url" content="https://juejin.cn/user/4046654395135800"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter DevTools 全景介绍
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4046654395135800/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    stringwu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T11:56:47.000Z" title="Fri Nov 14 2025 11:56:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文首发于公众号：移动开发那些事<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFCB7Jhe1becWYslrm8Wt1g" target="_blank" title="https://mp.weixin.qq.com/s/FCB7Jhe1becWYslrm8Wt1g" ref="nofollow noopener noreferrer">Flutter DevTools 全景介绍</a></p>
<h2 data-id="heading-0">1 前言</h2>
<p>性能调优与可视化调试是每个 <code>Flutter</code> 工程师成长的必修课，而 <code>DevTools</code> 是 <code>Flutter</code> 官方提供的一套用于 调试、性能分析与优化 Flutter 应用 的可视化工具,
它可以通过<code>Dart VM Service</code> 与应用运行时通信，可以实时读取：</p>
<ul>
<li><code>Widget</code> 树与渲染层状态</li>
<li>内存分配与 <code>GC</code></li>
<li><code>CPU</code> 调用栈</li>
<li>网络请求与响应</li>
<li>应用包体大小</li>
</ul>
<p>熟悉使用这套工具，可以</p>
<ul>
<li>提升开发调试效率</li>
<li>发现性能瓶颈</li>
<li>优化用户体验</li>
<li>精简产物大小</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2d38f4252fe4dbfbf8d3b6a3c34c4b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3RyaW5nd3U=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763726206&amp;x-signature=emzck2uEUaUBgCbBtU93md5TpFI%3D" alt="flutter_dev_tools.png" loading="lazy"/></p>
<h2 data-id="heading-1">2 DevTools 的启动方式</h2>
<p><code>DevTools</code> 的既可以通过命令行启动，也可以直接在<code>IDE</code>中启动；</p>
<h3 data-id="heading-2">2.1 命令行启动</h3>
<p>直接在命令行里运行以下命令：</p>
<pre><code class="hljs language-csharp" lang="csharp">flutter pub <span class="hljs-keyword">global</span> activate devtools
flutter pub <span class="hljs-keyword">global</span> run devtools
<span class="hljs-meta"># 这里是启动应用，如果有更复杂启动的话，可参考flutter的相关的命令</span>
flutter run --debug
</code></pre>
<p>然后访问提示的 <code>URL</code>（通常为 <code>http://127.0.0.1:9100）。</code></p>
<h3 data-id="heading-3">2.2  <code>Android Studio</code> 启动</h3>
<ul>
<li>启动应用后</li>
<li>点击右边侧边栏的 “Flutter DevTools” 按钮;</li>
<li>如果想查看<code>Inspector</code>，则点击右边侧边栏的<code>Flutter Inspector</code>按钮;</li>
</ul>
<p>点击<code>Flutter DevTools</code>:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/203057d1d1924883ab4458da832c8b6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3RyaW5nd3U=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763726206&amp;x-signature=6ZaoRYIDd2RVcfpbTlJWrhFy5VE%3D" alt="open_dev_tools.png" loading="lazy"/></p>
<p>点击<code>Flutter Inspector</code>:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d271e2896fb4edb90d002ec73da3b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3RyaW5nd3U=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763726206&amp;x-signature=ROgy5Ei5%2BM0HgSO%2BfA29Onp9vxA%3D" alt="dev_tools_widget.png" loading="lazy"/></p>
<h2 data-id="heading-4">3 核心模块总览</h2>













































<table><thead><tr><th>模块</th><th>功能说明</th><th>使用场景</th></tr></thead><tbody><tr><td>Inspector</td><td>可视化 Widget 树与布局</td><td>调试 UI 层级、排查布局错位</td></tr><tr><td>Performance</td><td>帧率与时间线分析</td><td>发现卡顿、掉帧原因</td></tr><tr><td>Memory</td><td>内存使用与 GC 分析</td><td>定位内存泄漏</td></tr><tr><td>CPU Profiler</td><td>函数耗时分析</td><td>优化耗时逻辑</td></tr><tr><td>Network</td><td>HTTP 请求捕获</td><td>调试接口调用</td></tr><tr><td>App Size</td><td>包体体积分析</td><td>优化体积结构</td></tr><tr><td>Logging</td><td>实时日志流</td><td>跟踪运行状态</td></tr></tbody></table>
<h3 data-id="heading-5">3.1. <code>Widget Inspector</code></h3>
<ul>
<li>可视化展示 Widget 树结构</li>
<li>支持 Select Widget Mode：点击页面高亮组件</li>
<li>可查看 Padding、Margin、Constraints</li>
<li>Layout Explorer 模式展示布局约束关系</li>
</ul>
<p><strong>应用场景</strong>：调试布局错位、嵌套层级复杂的页面。</p>
<h3 data-id="heading-6">3.2. <code>Performance</code>（性能分析）</h3>
<ul>
<li>展示 UI 与 GPU 渲染线程的时间线</li>
<li>捕获 CPU Profile 快照</li>
<li>标红帧代表掉帧（jank）</li>
<li>可查看 build、layout、paint 各阶段耗时</li>
</ul>
<p><strong>应用场景</strong>：分析动画卡顿或滚动掉帧。</p>
<hr/>
<h3 data-id="heading-7">3.3. <code>Memory</code>（内存分析）</h3>
<ul>
<li>实时显示堆内存使用曲线</li>
<li>查看对象类型与数量分布</li>
<li>拍摄 Heap Snapshot，对比对象增长</li>
<li>支持搜索特定类型（如 Image）</li>
</ul>
<p><strong>应用场景</strong>：排查图片未释放、<code>Stream</code> 或 <code>Controller</code> 泄漏问题。</p>
<hr/>
<h3 data-id="heading-8">3.4. <code>CPU Profiler</code></h3>
<ul>
<li><code>Flame Chart</code> 显示函数调用耗时比例</li>
<li>支持按线程筛选（UI / I/O）</li>
<li>可导出 JSON 文件供分析</li>
</ul>
<p><strong>应用场景</strong>：定位耗时逻辑、优化算法性能。</p>
<hr/>
<h3 data-id="heading-9">3.5. <code>Network</code></h3>
<ul>
<li>捕获所有 HTTP/HTTPS 请求</li>
<li>展示请求耗时、状态码、请求体与响应体</li>
<li>支持搜索与过滤</li>
</ul>
<p><strong>应用场景</strong>：排查请求延迟、后端接口异常。</p>
<hr/>
<h3 data-id="heading-10">3.6. <code>App Size</code></h3>
<ul>
<li>导入 <code>app-size-analysis.json</code> 文件</li>
<li>分析代码、资源、依赖的体积占比</li>
<li>显示包体构成饼图</li>
</ul>
<p><strong>应用场景</strong>：识别大依赖、优化包体体积。</p>
<p>不知道如何生成<code>app-size-analysis.json</code>文件？
可参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.cn%2Ftools%2Fdevtools%2Fapp-size%2F%23generating-size-files" target="_blank" title="https://docs.flutter.cn/tools/devtools/app-size/#generating-size-files" ref="nofollow noopener noreferrer">docs.flutter.cn/tools/devto…</a></p>
<p>核心的命令为：</p>
<pre><code class="hljs language-css" lang="css">flutter build apk <span class="hljs-attr">--analyze-size</span> <span class="hljs-attr">--target-platform</span>=android-arm64
</code></pre>
<h3 data-id="heading-11">3.7. Logging</h3>
<ul>
<li>实时查看 <code>Dart print</code> 输出</li>
<li>日志分级（<code>info / warning / error</code>）</li>
<li>支持搜索与跳转到源代码</li>
</ul>
<p>应用场景：追踪运行状态与异常。</p>
<hr/>
<h2 data-id="heading-12">4 其他使用技巧</h2>





























<table><thead><tr><th>技巧</th><th>命令或说明</th></tr></thead><tbody><tr><td>Profile 模式运行</td><td><code>flutter run --profile</code></td></tr><tr><td>捕获卡顿帧信息</td><td><code>debugProfileBuildsEnabled = true</code></td></tr><tr><td>生成包体报告</td><td><code>flutter build appbundle --analyze-size</code></td></tr><tr><td>导出分析结果</td><td>Performance 页右上角 Export</td></tr><tr><td>远程调试</td><td>使用 Dart VM Service URL 连接</td></tr></tbody></table>
<h2 data-id="heading-13">4.1 DevTools的原理</h2>
<p><code>Flutter DevTools</code> 本质上是一个 基于 <code>Web</code> 的调试工具集，它通过与 <code>Dart VM Service</code> 建立通信，实现对 <code>Flutter</code> 应用的监控、调试、性能分析等功能。</p>
<p>而 <code>Flutter Engine</code> 是运行 Flutter 应用的底层引擎，负责渲染、事件分发、平台通道、Dart VM 执行等核心功能。</p>
<p>两者之间并非直接通信，而是通过 <code>Dart VM Service Protocol</code>（基于 <code>WebSocket</code> 的 <code>JSON-RPC</code> 协议） 进行 间接通信。</p>
<pre><code class="hljs">Flutter DevTools  ⇄  Dart VM Service  ⇄  Flutter Engine
</code></pre>
<hr/>
<h2 data-id="heading-14">5 参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Ftools%2Fdevtools%2Foverview" target="_blank" title="https://docs.flutter.dev/tools/devtools/overview" ref="nofollow noopener noreferrer">Flutter DevTools 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.flutter.dev%2Fperf%2Frendering" target="_blank" title="https://docs.flutter.dev/perf/rendering" ref="nofollow noopener noreferrer">Flutter 性能优化指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools" target="_blank" title="https://github.com/flutter/devtools" ref="nofollow noopener noreferrer">DevTools GitHub 仓库</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TRAE SOLO 3.0 正式版首秀：SOLO Code 实战《大闹天宫》交互式闯关游戏🧣]]></title>    <link>https://juejin.cn/post/7572405211441348651</link>    <guid>https://juejin.cn/post/7572405211441348651</guid>    <pubDate>2025-11-14T15:06:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572405211441348651" data-draft-id="7572403510467051563" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TRAE SOLO 3.0 正式版首秀：SOLO Code 实战《大闹天宫》交互式闯关游戏🧣"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-14T15:06:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="围巾哥萧尘"/> <meta itemprop="url" content="https://juejin.cn/user/1222312659548446"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TRAE SOLO 3.0 正式版首秀：SOLO Code 实战《大闹天宫》交互式闯关游戏🧣
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1222312659548446/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    围巾哥萧尘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T15:06:27.000Z" title="Fri Nov 14 2025 15:06:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🌟 <strong>TRAE SOLO 3.0 正式版首秀：SOLO Code 实战《大闹天宫》交互式闯关游戏</strong></h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3397d4045c740bf98ef4fbc73745d3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763737847&amp;x-signature=E%2B%2FWRGE8v%2FHP%2FJOchSqx72JFwvI%3D" alt="截屏2025-11-14 22.21.31.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2dd1ace9d8774a97a9b985c7d5a0dfab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763737847&amp;x-signature=EDL3wetCeaGaTcR%2BxP884%2FngWv4%3D" alt="截屏2025-11-14 22.22.02.png" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1XKCuBHEef%2F%3Fspm_id_from%3D333.1387.homepage.video_card.click" target="_blank" title="https://www.bilibili.com/video/BV1XKCuBHEef/?spm_id_from=333.1387.homepage.video_card.click" ref="nofollow noopener noreferrer">「TRAE SOLO 3.0 正式版初体验」大闹天宫-交互式闯关小游戏制作🧣#TRAE 3.0 SOLO出道 并 @TRAE #SOLO 已就位 #TRAE发</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08322366446b46d2819c77753a5030fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763737847&amp;x-signature=WaaBrqAzsVGuaCiGhIEG%2BAcPpxI%3D" alt="22.gif" loading="lazy"/></p>
<h3 data-id="heading-1">🗓️ <strong>项目概览与开发环境</strong></h3>
<p>本次实战体验于 <strong>2025年11月14日 (周五) 晚上</strong>完成，旨在测试 TRAE 3.0 正式版在处理复杂交互式游戏逻辑方面的能力。</p>
<h4 data-id="heading-2">1. <strong>环境配置</strong></h4>
<ul>
<li><strong>软件版本</strong>：我使用的是 TRAE 3.0 的最新版本。</li>
<li><strong>硬件平台</strong>：基于 <strong>Apple M-series 电脑 (M4)</strong> 平台进行开发和测试。用户在下载时需要根据自己的电脑配置（如 Apple 或 Inter 电脑）来选择对应的版本进行下载。</li>
</ul>
<h4 data-id="heading-3">2. <strong>核心工具与模型</strong></h4>
<p>本次项目主要依赖 <strong>SOLO Code</strong> 模式，来实现快速编码和部署。</p>
<ul>
<li><strong>模型体系</strong>：在 TRAE SOLO 环境中，我们可以查看和利用包括 <strong>SOLO Code</strong> 和 **SOLO Builder ** 在内的核心 SOLO 体系。</li>
<li><strong>整体设计导入</strong>：为了指导 AI 更好地完成任务，我导入了整套的<strong>设计准则</strong> (整套)，包括 <strong>UI 设计、前端架构、后端架构、API 测试、性能优化</strong>及<strong>合规审查员</strong>等。</li>
</ul>
<h3 data-id="heading-4">💻 <strong>SOLO Code 实战：交互式游戏快速构建</strong></h3>
<p>我的核心需求是设计一个具有<strong>交互式闯关逻辑的《大闹天宫》小游戏</strong>。</p>
<h4 data-id="heading-5">1. <strong>需求输入与项目生成</strong></h4>
<p>我向系统给出了提示：“设计一个大天宫的交互式的闯关游戏”。</p>
<p>提示词：</p>
<pre><code class="hljs language-markdown" lang="markdown">设计一个名为"大闹天宫"的交互式闯关小游戏，具体要求如下：

  


<span class="hljs-bullet">1.</span> 交互式孙悟空角色：

<span class="hljs-bullet">-</span> 实现孙悟空角色跟随鼠标指针（桌面端）或手指触摸位置（移动端）在云端飞行的功能

<span class="hljs-bullet">-</span> 角色动画包含飞行时的动态效果（如衣袂飘动、筋斗云轨迹）

<span class="hljs-bullet">-</span> 角色大小和移动速度需根据屏幕尺寸自动调整

  


<span class="hljs-bullet">2.</span> 金箍棒攻击特效系统：

<span class="hljs-bullet">-</span> 点击屏幕（移动端）或鼠标左键（桌面端）触发攻击动作

<span class="hljs-bullet">-</span> 攻击时播放孙悟空挥舞金箍棒的动画序列

<span class="hljs-bullet">-</span> 产生金色冲击波特效（粒子效果+光晕），向点击方向扩散

<span class="hljs-bullet">-</span> 特效需包含击退天兵天将的视觉反馈（如敌人被击飞动画）

  


<span class="hljs-bullet">3.</span> 动态天宫背景：

<span class="hljs-bullet">-</span> 南天门作为主要背景元素，需体现巍峨气势

<span class="hljs-bullet">-</span> 实现多层视差滚动的云雾效果（近景快、远景慢）

<span class="hljs-bullet">-</span> 随机生成飘动的云朵作为场景装饰

<span class="hljs-bullet">-</span> 添加适当的光照效果增强天宫氛围

  


<span class="hljs-bullet">4.</span> 响应式设计：

<span class="hljs-bullet">-</span> 自动适配不同屏幕尺寸（从手机到桌面显示器）

<span class="hljs-bullet">-</span> 触控和鼠标操作需有对应的交互优化

<span class="hljs-bullet">-</span> 性能优化确保在移动设备上流畅运行

<span class="hljs-bullet">-</span> 提供横竖屏自动调整布局的功能

  


<span class="hljs-bullet">5.</span> 技术要求：

<span class="hljs-bullet">-</span> 使用HTML5 Canvas或WebGL实现核心动画

<span class="hljs-bullet">-</span> 采用CSS媒体查询处理响应式布局

<span class="hljs-bullet">-</span> 实现60fps的流畅动画效果

<span class="hljs-bullet">-</span> 添加适当的音效（飞行声、攻击声、背景音乐）

  


<span class="hljs-bullet">6.</span> 交付物：

<span class="hljs-bullet">-</span> 完整可运行的网页游戏

<span class="hljs-bullet">-</span> 适配主流现代浏览器

<span class="hljs-bullet">-</span> 移动端需通过触控设备测试

<span class="hljs-bullet">-</span> 提供简要的使用说明文档
</code></pre>
<ul>
<li>Solo Coder 迅速根据提示生成了当前的游戏计划和骨架。</li>
<li>项目利用 SOLO Code 的高效性，基本快速完成了开发。</li>
</ul>
<h4 data-id="heading-6">2. <strong>关键功能实现与迭代</strong></h4>
<p>在初步生成游戏骨架后，为了增强游戏的可玩性，我进行了关键的<strong>优化和功能迭代</strong>：</p>
<ul>
<li><strong>增加敌人互动性</strong>：一开始，游戏中侧边的小兵是<strong>没有发射子弹功能</strong>的。经过优化，我们增加了让小兵<strong>可以发射子弹</strong>的功能，极大地增加了游戏的可玩性。</li>
<li><strong>用户体验优化</strong>：我<strong>增加了一个“重新开始”的按键</strong>，方便玩家快速重启游戏。</li>
<li><strong>关卡设计</strong>：我让 AI 设计了三个关卡，包括 <strong>天庭外围、南天门</strong> 和 <strong>凌霄宝殿</strong>。</li>
<li><strong>视觉效果增强</strong>：针对主角（孙悟空）武器的金光效果，我让 AI <strong>将金箍棒（棍子）搞长了一点</strong>，使其看起来更具经典效果。</li>
</ul>
<h3 data-id="heading-7">✅ <strong>部署与展望</strong></h3>
<h4 data-id="heading-8">1. <strong>一键部署</strong></h4>
<p>项目完成后，我直接使用 **部署 ** 功能将游戏部署到线上。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Ftrae39i9vn62.vercel.app%2F" target="_blank" title="https://trae39i9vn62.vercel.app/" ref="nofollow noopener noreferrer">trae39i9vn62.vercel.app/</a></p>
<ul>
<li>部署成功后，系统生成了链接。通过加载链接，我们可以直接在电脑端看到游戏的展示情况，并进行游玩。</li>
</ul>
<h4 data-id="heading-9">2. <strong>后续优化方向</strong></h4>
<p>虽然 SOLO Code 快速完成了游戏的核心构建和逻辑实现，但若要达到更佳的效果，仍需在以下方面投入更多精力：</p>
<ul>
<li><strong>设计与美工</strong>：需要在<strong>想法、设计、美工</strong>和<strong>页面</strong>上多花时间来打磨。</li>
<li><strong>移动端适配</strong>：如果想要支持手机端游玩，需要增加一个<strong>手机端的上下左右按键</strong>，以适应移动端的操作。</li>
</ul>
<p>本次实战充分展示了 TRAE SOLO 3.0 在<strong>网页端小游戏</strong>这种相对简单的应用场景中，能够快速实现从想法到功能实现、再到优化的全流程，特别是对于交互性功能的快速迭代具有显著优势。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[计算机语言中的多态实现]]></title>    <link>https://juejin.cn/post/7572413448941666331</link>    <guid>https://juejin.cn/post/7572413448941666331</guid>    <pubDate>2025-11-14T12:16:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572413448941666331" data-draft-id="7572362484659945523" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="计算机语言中的多态实现"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2025-11-14T12:16:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="温宇飞"/> <meta itemprop="url" content="https://juejin.cn/user/4300945219403368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            计算机语言中的多态实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4300945219403368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    温宇飞
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T12:16:59.000Z" title="Fri Nov 14 2025 12:16:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>多态（Polymorphism）是指"同一接口，多种实现"，是计算机语言中的核心概念。多态可以在编译期实现，也可以在运行时实现。编译期多态通过模板、泛型等机制提供多份代码，而运行时多态通过虚函数、接口、鸭子类型等方式实现动态绑定。本文介绍多态在不同语言中的实现方式。</p>
<h2 data-id="heading-0">运行时多态</h2>
<p>运行时多态的核心是通过间接机制在运行时确定具体调用哪个实现。本章介绍运行时多态的实现原理，包括基于继承的动态派发、基于类型标签的联合体、基于接口的协议约束、以及基于属性查找的鸭子类型。</p>
<h3 data-id="heading-1">基于继承的动态派发</h3>
<p>这是面向对象语言中最经典的运行时多态实现方式。通过继承建立类型层次，使用虚函数实现动态派发。</p>
<p><strong>C++ 示例：</strong></p>
<pre><code class="hljs language-C++" lang="C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span>
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-keyword">default</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Woof!\n"</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Meow!\n"</span>; }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Animal* animal1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();
    Animal* animal2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>();
    animal1-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: Woof!</span>
    animal2-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: Meow!</span>
    <span class="hljs-keyword">delete</span> animal1;
    <span class="hljs-keyword">delete</span> animal2;
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p>编译器为每个包含虚函数的类生成虚函数表（vtable），对象中存储指向 vtable 的指针。调用虚函数时，通过对象的 vtable 指针查找实际函数地址，实现动态绑定。</p>
<p><strong>TS 示例：</strong></p>
<pre><code class="hljs language-TS" lang="TS"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
    <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Woof!"</span>); }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
    <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Meow!"</span>); }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">animal1</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-keyword">const</span> <span class="hljs-attr">animal2</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
animal1.<span class="hljs-title function_">speak</span>();  <span class="hljs-comment">// 输出: Woof!</span>
animal2.<span class="hljs-title function_">speak</span>();  <span class="hljs-comment">// 输出: Meow!</span>
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 编译为 JavaScript 后，继承关系通过原型链实现。调用方法时，引擎沿原型链向上查找，找到对应的方法实现并调用。</p>
<h3 data-id="heading-2">基于类型标签的联合体</h3>
<p>联合体通过类型标签记录当前存储的类型，在运行时根据标签选择对应的处理逻辑。</p>
<p><strong>C++ 示例：</strong></p>
<pre><code class="hljs language-C++" lang="C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> { <span class="hljs-type">double</span> radius; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> { <span class="hljs-type">double</span> width, height; };

<span class="hljs-keyword">using</span> Shape = std::variant&lt;Circle, Rectangle&gt;;

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; shape)</span> </span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; s) -&gt; <span class="hljs-type">double</span> {
        <span class="hljs-keyword">using</span> T = std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(s)&gt;;
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, Circle&gt;) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * s.radius * s.radius;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, Rectangle&gt;) {
            <span class="hljs-keyword">return</span> s.width * s.height;
        }
    }, shape);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Shape s1 = Circle{<span class="hljs-number">5.0</span>};
    Shape s2 = Rectangle{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};
    std::cout &lt;&lt; <span class="hljs-built_in">area</span>(s1) &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// 输出: 78.5</span>
    std::cout &lt;&lt; <span class="hljs-built_in">area</span>(s2) &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// 输出: 12</span>
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p><code>std::variant</code> 内部存储类型标签和足够大的存储空间。<code>std::visit</code> 根据类型标签在运行时分发到对应的处理分支。</p>
<p><strong>TS 示例：</strong></p>
<pre><code class="hljs language-TS" lang="TS"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Circle</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'circle'</span>; <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Rectangle</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'rectangle'</span>; <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Shape</span> = <span class="hljs-title class_">Circle</span> | <span class="hljs-title class_">Rectangle</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">shape: Shape</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">switch</span> (shape.<span class="hljs-property">kind</span>) {  <span class="hljs-comment">// 根据类型标签分发</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'circle'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * shape.<span class="hljs-property">radius</span> * shape.<span class="hljs-property">radius</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'rectangle'</span>:
            <span class="hljs-keyword">return</span> shape.<span class="hljs-property">width</span> * shape.<span class="hljs-property">height</span>;
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>: <span class="hljs-title class_">Shape</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'circle'</span>, <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span> };
<span class="hljs-keyword">const</span> <span class="hljs-attr">s2</span>: <span class="hljs-title class_">Shape</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'rectangle'</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">4</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">area</span>(s1));  <span class="hljs-comment">// 输出: 78.5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">area</span>(s2));  <span class="hljs-comment">// 输出: 12</span>
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 的联合类型（Union Types）通过判别字段（如 <code>kind</code>）在运行时区分具体类型。编译后的 JavaScript 使用 <code>switch</code> 语句根据标签分发到不同分支。</p>
<h3 data-id="heading-3">基于接口的协议约束</h3>
<p>接口定义了一组方法签名，任何实现这些方法的类型都满足该接口。这种方式强调"能做什么"（协议），而非"是什么"（类型层次）。</p>
<p><strong>C++ 示例：</strong></p>
<p>C++ 没有提供接口的语言特性，通过继承抽象基类实现接口约束。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawable</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Drawable {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Circle\n"</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Drawable {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Square\n"</span>; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Drawable* shape)</span> </span>{
    shape-&gt;<span class="hljs-built_in">draw</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Circle c;
    Square s;
    <span class="hljs-built_in">render</span>(&amp;c);  <span class="hljs-comment">// 输出: Circle</span>
    <span class="hljs-built_in">render</span>(&amp;s);  <span class="hljs-comment">// 输出: Square</span>
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p>C++ 通过继承和虚函数表实现接口约束，机制上与继承派发相同。区别在于语义：接口强调协议，继承强调类型关系。</p>
<p><strong>TS 示例：</strong></p>
<p>TypeScript 提供 <code>interface</code> 关键字定义接口，类通过 <code>implements</code> 实现接口。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drawable</span> {
  <span class="hljs-title function_">draw</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span> {
  <span class="hljs-title function_">draw</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Circle"</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drawable</span> {
  <span class="hljs-title function_">draw</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Square"</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">shape: Drawable</span>): <span class="hljs-built_in">void</span> {
  shape.<span class="hljs-title function_">draw</span>();
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();
<span class="hljs-title function_">render</span>(c); <span class="hljs-comment">// 输出: Circle</span>
<span class="hljs-title function_">render</span>(s); <span class="hljs-comment">// 输出: Square</span>
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 的接口在编译期进行类型检查，确保类实现了接口的所有方法。编译为 JavaScript 后，接口信息被擦除，运行时通过对象的方法直接调用。</p>
<h3 data-id="heading-4">基于属性查找的鸭子类型（动态语言）</h3>
<p>鸭子类型（Duck Typing）的核心思想是"如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子"。不关心对象的类型或接口声明，只关心对象在运行时是否具有所需的属性或方法。</p>
<p>C++ 是静态类型语言，不支持运行时鸭子类型。</p>
<p><strong>TS 示例：</strong></p>
<p>TypeScript 的结构化类型系统支持鸭子类型，只要对象具有所需的方法或属性，就满足类型要求。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">shape: { draw(): <span class="hljs-built_in">void</span> }</span>) {
  shape.<span class="hljs-title function_">draw</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> {
  <span class="hljs-title function_">draw</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Circle"</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> {
  <span class="hljs-title function_">draw</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Square"</span>);
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();
<span class="hljs-title function_">render</span>(c); <span class="hljs-comment">// 输出: Circle</span>
<span class="hljs-title function_">render</span>(s); <span class="hljs-comment">// 输出: Square</span>

<span class="hljs-comment">// 可以传递普通对象</span>
<span class="hljs-title function_">render</span>({ <span class="hljs-attr">draw</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Triangle"</span>) }); <span class="hljs-comment">// 输出: Triangle</span>
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 在编译期检查对象是否具有所需的属性或方法，不要求显式声明类型关系。编译为 JavaScript 后，运行时通过对象的属性直接调用方法，真正实现运行时鸭子类型。</p>
<h2 data-id="heading-5">编译期多态（C++）</h2>
<p>C++ 通过模板（Templates）实现编译期多态。编译器根据模板参数生成多份代码，每份代码针对特定类型进行优化。本章介绍 C++ 模板的三种形式：函数模板、类模板、以及模板特化。</p>
<h3 data-id="heading-6">函数模板</h3>
<p>函数模板允许编写适用于多种类型的通用函数，编译器根据调用时的类型参数生成具体函数。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span> </span>{
    <span class="hljs-keyword">return</span> a &gt; b ? a : b;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;        <span class="hljs-comment">// 生成 max&lt;int&gt;</span>
    std::cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">2.1</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;    <span class="hljs-comment">// 生成 max&lt;double&gt;</span>
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p>编译器在编译期根据调用的类型参数实例化模板，生成对应类型的函数代码。每种类型都有独立的函数实现，没有运行时开销。</p>
<h3 data-id="heading-7">类模板</h3>
<p>类模板允许编写适用于多种类型的通用类，常用于容器、智能指针等场景。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {
    std::vector&lt;T&gt; data;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>{ data.<span class="hljs-built_in">push_back</span>(value); }
    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{ T v = data.<span class="hljs-built_in">back</span>(); data.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-keyword">return</span> v; }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Stack&lt;<span class="hljs-type">int</span>&gt; s1;      <span class="hljs-comment">// 生成 Stack&lt;int&gt;</span>
    s1.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);

    Stack&lt;string&gt; s2;   <span class="hljs-comment">// 生成 Stack&lt;string&gt;</span>
    s2.<span class="hljs-built_in">push</span>(<span class="hljs-string">"hello"</span>);
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p>编译器根据模板参数生成不同的类定义。每个类型参数组合对应一个独立的类，在编译期完成所有类型检查。</p>
<h3 data-id="heading-8">模板特化</h3>
<p>模板特化允许为特定类型提供定制化实现，在通用逻辑的基础上处理特殊情况。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T value)</span> </span>{ std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">"\n"</span>; }
};

<span class="hljs-comment">// 为 bool 类型提供特化实现</span>
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span>&lt;<span class="hljs-type">bool</span>&gt; {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>{
        std::cout &lt;&lt; (value ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Printer&lt;<span class="hljs-type">int</span>&gt; p1;
    p1.<span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 输出: 42</span>

    Printer&lt;<span class="hljs-type">bool</span>&gt; p2;
    p2.<span class="hljs-built_in">print</span>(<span class="hljs-literal">true</span>);     <span class="hljs-comment">// 输出: true</span>
}
</code></pre>
<p><strong>实现原理：</strong></p>
<p>编译器优先选择特化版本。遇到特化类型时使用特化实现，其他类型使用通用模板。这在编译期完成，没有运行时判断。</p>
<h2 data-id="heading-9">编译期多态（TypeScript）</h2>
<p>TypeScript 通过泛型（Generics）实现编译期多态。类型系统在编译期进行类型检查和推断，编译为 JavaScript 后类型信息被擦除。本章介绍 TypeScript 泛型的三种形式：泛型函数、泛型类、以及条件类型。</p>
<h3 data-id="heading-10">泛型函数</h3>
<p>泛型函数允许编写适用于多种类型的通用函数，TypeScript 在编译期推断或检查类型参数。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> max&lt;T&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): T {
  <span class="hljs-keyword">return</span> a &gt; b ? a : b;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 推断为 max&lt;number&gt;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">max</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">2.1</span>)); <span class="hljs-comment">// 推断为 max&lt;number&gt;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">max</span>(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>)); <span class="hljs-comment">// 推断为 max&lt;string&gt;</span>
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 在编译期根据调用的参数类型推断类型参数，进行类型检查。编译为 JavaScript 后，类型信息被擦除，生成的代码与普通函数相同，没有泛型痕迹。</p>
<h3 data-id="heading-11">泛型类</h3>
<p>泛型类允许编写适用于多种类型的通用类，在实例化时指定具体类型。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: T[] = [];

  <span class="hljs-title function_">push</span>(<span class="hljs-attr">value</span>: T): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(value);
  }
  <span class="hljs-title function_">pop</span>(): T {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">pop</span>()!;
  }
}

<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// Stack&lt;number&gt;</span>
s1.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);

<span class="hljs-keyword">const</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">string</span>&gt;(); <span class="hljs-comment">// Stack&lt;string&gt;</span>
s2.<span class="hljs-title function_">push</span>(<span class="hljs-string">"hello"</span>);
</code></pre>
<p><strong>实现原理：</strong></p>
<p>TypeScript 在编译期检查类型参数的使用是否正确。编译为 JavaScript 后，生成的是普通类，类型参数信息被擦除。运行时只有一份类代码，不同类型共享同一实现。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring 6 & Spring Boot 3新特性：事务管理的革新]]></title>    <link>https://juejin.cn/post/7572413448942403611</link>    <guid>https://juejin.cn/post/7572413448942403611</guid>    <pubDate>2025-11-14T17:37:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572413448942403611" data-draft-id="7570932873131868187" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring 6 &amp; Spring Boot 3新特性：事务管理的革新"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-11-14T17:37:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大头an"/> <meta itemprop="url" content="https://juejin.cn/user/618374030438861"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring 6 &amp; Spring Boot 3新特性：事务管理的革新
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/618374030438861/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大头an
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T17:37:04.000Z" title="Fri Nov 14 2025 17:37:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<blockquote>
<p>Spring Framework 6和Spring Boot 3带来了革命性的变化，包括对Java
17+的基线要求、原生编译支持、以及事务管理的重大改进。这些新特性如何影响我们的事务管理实践？本文将深入探讨Spring
6在事务管理方面的创新和改进。</p>
</blockquote>
<h2 data-id="heading-1">环境要求与升级准备</h2>
<h3 data-id="heading-2">1. 新版本基线要求</h3>
<p><strong>必须升级的技术栈</strong>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pom.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>6.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Spring Boot 3 Starter --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- Jakarta EE 9+ (取代Javax) --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.persistence<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.persistence-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 响应式编程支持 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-r2dbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">2. 迁移注意事项</h3>
<p><strong>包名变更</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// Spring 5.x (旧)</span>
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> javax.transaction.Transactional;

<span class="hljs-comment">// Spring 6.x (新)</span>
<span class="hljs-keyword">import</span> jakarta.persistence.*;
<span class="hljs-keyword">import</span> jakarta.transaction.Transactional;  <span class="hljs-comment">// 或者继续使用Spring的@Transactional</span>
<span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional; <span class="hljs-comment">// 推荐使用Spring注解</span>

<span class="hljs-comment">// 配置类变更</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionConfig</span> {
    <span class="hljs-comment">// 配置基本保持不变，但底层实现有优化</span>
}
</code></pre>
<h2 data-id="heading-4">虚拟线程（Virtual Threads）与事务管理</h2>
<h3 data-id="heading-5">1. 虚拟线程简介</h3>
<p>Spring 6充分利用了Java 19+的虚拟线程特性，大幅提升并发性能。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">virtualThreadExecutor</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAsyncTaskExecutor</span>(<span class="hljs-string">"virtual-"</span>);
    }
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Primary</span>
    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> {
        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);
        
        <span class="hljs-comment">// 虚拟线程友好的配置</span>
        tm.setTransactionSynchronization(DataSourceTransactionManager.SYNCHRO_NEVER);
        <span class="hljs-keyword">return</span> tm;
    }
}
</code></pre>
<h3 data-id="heading-6">2. 虚拟线程中的事务处理</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadTransactionService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OrderRepository orderRepository;
    
    <span class="hljs-comment">// 在虚拟线程中执行事务操作</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-meta">@Async("virtualThreadExecutor")</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;User&gt; <span class="hljs-title function_">processUserInVirtualThread</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 虚拟线程中的事务行为与平台线程基本一致</span>
            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRepository.findById(userId)
                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserNotFoundException</span>(userId));
            
            <span class="hljs-comment">// 执行一些业务逻辑</span>
            processUserData(user);
            
            <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(user);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"虚拟线程事务处理失败"</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionException</span>(e);
        }
    }
    
    <span class="hljs-comment">// 批量虚拟线程事务处理</span>
    <span class="hljs-keyword">public</span> List&lt;CompletableFuture&lt;User&gt;&gt; <span class="hljs-title function_">processUsersConcurrently</span><span class="hljs-params">(List&lt;Long&gt; userIds)</span> {
        <span class="hljs-keyword">return</span> userIds.stream()
            .map(<span class="hljs-built_in">this</span>::processUserInVirtualThread)
            .collect(Collectors.toList());
    }
    
    <span class="hljs-comment">// 虚拟线程中的事务传播测试</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testVirtualThreadPropagation</span><span class="hljs-params">()</span> {
        log.info(<span class="hljs-string">"当前线程: {}, 是否是虚拟线程: {}"</span>, 
            Thread.currentThread().getName(),
            Thread.currentThread().isVirtual());
        
        <span class="hljs-comment">// 在虚拟线程中，事务传播行为保持不变</span>
        userRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"test-user"</span>));
        
        <span class="hljs-comment">// 嵌套事务在虚拟线程中正常工作</span>
        processInNestedTransaction();
    }
    
    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processInNestedTransaction</span><span class="hljs-params">()</span> {
        orderRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">"test-order"</span>));
        <span class="hljs-comment">// 虚拟线程中的事务隔离级别和传播行为与平台线程一致</span>
    }
}
</code></pre>
<h2 data-id="heading-7">响应式事务管理</h2>
<h3 data-id="heading-8">1. R2DBC与响应式事务</h3>
<p>Spring 6增强了响应式事务支持，特别是与R2DBC的集成。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R2dbcTransactionConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ConnectionFactory <span class="hljs-title function_">connectionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> ConnectionFactories.get(<span class="hljs-string">"r2dbc:mysql://localhost:3306/test"</span>);
    }
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ReactiveTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(ConnectionFactory connectionFactory)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R2dbcTransactionManager</span>(connectionFactory);
    }
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> DatabaseClient <span class="hljs-title function_">databaseClient</span><span class="hljs-params">(ConnectionFactory connectionFactory)</span> {
        <span class="hljs-keyword">return</span> DatabaseClient.builder()
            .connectionFactory(connectionFactory)
            .bindMarkers(MySqlBindMarkers.INSTANCE)
            .build();
    }
}

<span class="hljs-comment">// 响应式事务服务</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveUserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> DatabaseClient databaseClient;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ReactiveTransactionManager transactionManager;
    
    <span class="hljs-comment">// 声明式响应式事务</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> Mono&lt;User&gt; <span class="hljs-title function_">createUserReactive</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"INSERT INTO users (name, email) VALUES (:name, :email)"</span>)
            .bind(<span class="hljs-string">"name"</span>, user.getName())
            .bind(<span class="hljs-string">"email"</span>, user.getEmail())
            .fetch()
            .rowsUpdated()
            .flatMap(rows -&gt; databaseClient.sql(<span class="hljs-string">"SELECT * FROM users WHERE email = :email"</span>)
                .bind(<span class="hljs-string">"email"</span>, user.getEmail())
                .map((row, metadata) -&gt; {
                    <span class="hljs-type">User</span> <span class="hljs-variable">createdUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
                    createdUser.setId(row.get(<span class="hljs-string">"id"</span>, Long.class));
                    createdUser.setName(row.get(<span class="hljs-string">"name"</span>, String.class));
                    createdUser.setEmail(row.get(<span class="hljs-string">"email"</span>, String.class));
                    <span class="hljs-keyword">return</span> createdUser;
                })
                .one()
            );
    }
    
    <span class="hljs-comment">// 编程式响应式事务</span>
    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">transferBalanceReactive</span><span class="hljs-params">(Long fromUserId, Long toUserId, BigDecimal amount)</span> {
        <span class="hljs-type">TransactionalOperator</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> TransactionalOperator.create(transactionManager);
        
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"SELECT balance FROM accounts WHERE user_id = :userId"</span>)
            .bind(<span class="hljs-string">"userId"</span>, fromUserId)
            .map((row, metadata) -&gt; row.get(<span class="hljs-string">"balance"</span>, BigDecimal.class))
            .one()
            .flatMap(fromBalance -&gt; {
                <span class="hljs-keyword">if</span> (fromBalance.compareTo(amount) &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> Mono.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientBalanceException</span>(<span class="hljs-string">"余额不足"</span>));
                }
                
                Mono&lt;Integer&gt; deduct = databaseClient.sql(<span class="hljs-string">"UPDATE accounts SET balance = balance - :amount WHERE user_id = :userId"</span>)
                    .bind(<span class="hljs-string">"amount"</span>, amount)
                    .bind(<span class="hljs-string">"userId"</span>, fromUserId)
                    .fetch()
                    .rowsUpdated();
                
                Mono&lt;Integer&gt; add = databaseClient.sql(<span class="hljs-string">"UPDATE accounts SET balance = balance + :amount WHERE user_id = :userId"</span>)
                    .bind(<span class="hljs-string">"amount"</span>, amount)
                    .bind(<span class="hljs-string">"userId"</span>, toUserId)
                    .fetch()
                    .rowsUpdated();
                
                <span class="hljs-keyword">return</span> Mono.when(deduct, add);
            })
            .as(operator::transactional); <span class="hljs-comment">// 应用事务操作</span>
    }
    
    <span class="hljs-comment">// 复杂响应式事务流程</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> Mono&lt;Order&gt; <span class="hljs-title function_">createOrderReactive</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"INSERT INTO orders (user_id, amount, status) VALUES (:userId, :amount, :status)"</span>)
            .bind(<span class="hljs-string">"userId"</span>, order.getUserId())
            .bind(<span class="hljs-string">"amount"</span>, order.getAmount())
            .bind(<span class="hljs-string">"status"</span>, <span class="hljs-string">"PENDING"</span>)
            .fetch()
            .rowsUpdated()
            .then(databaseClient.sql(<span class="hljs-string">"UPDATE inventory SET stock = stock - :quantity WHERE product_id = :productId"</span>)
                .bind(<span class="hljs-string">"quantity"</span>, order.getQuantity())
                .bind(<span class="hljs-string">"productId"</span>, order.getProductId())
                .fetch()
                .rowsUpdated()
            )
            .then(databaseClient.sql(<span class="hljs-string">"SELECT * FROM orders WHERE user_id = :userId ORDER BY id DESC LIMIT 1"</span>)
                .bind(<span class="hljs-string">"userId"</span>, order.getUserId())
                .map(<span class="hljs-built_in">this</span>::mapToOrder)
                .one()
            )
            .onErrorResume(e -&gt; {
                log.error(<span class="hljs-string">"创建订单失败"</span>, e);
                <span class="hljs-keyword">return</span> Mono.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreationException</span>(<span class="hljs-string">"订单创建失败"</span>, e));
            });
    }
    
    <span class="hljs-keyword">private</span> Order <span class="hljs-title function_">mapToOrder</span><span class="hljs-params">(Row row, RowMetadata metadata)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();
        order.setId(row.get(<span class="hljs-string">"id"</span>, Long.class));
        order.setUserId(row.get(<span class="hljs-string">"user_id"</span>, Long.class));
        order.setAmount(row.get(<span class="hljs-string">"amount"</span>, BigDecimal.class));
        order.setStatus(row.get(<span class="hljs-string">"status"</span>, String.class));
        <span class="hljs-keyword">return</span> order;
    }
}
</code></pre>
<h3 data-id="heading-9">2. 响应式事务的传播和隔离</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveTransactionPropagationService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> DatabaseClient databaseClient;
    
    <span class="hljs-comment">// 响应式事务传播测试</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title function_">testReactivePropagation</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"INSERT INTO test_table (name) VALUES ('test1')"</span>)
            .fetch()
            .rowsUpdated()
            .then(Mono.defer(() -&gt; {
                <span class="hljs-comment">// 嵌套的响应式事务</span>
                <span class="hljs-keyword">return</span> nestedReactiveTransaction();
            }))
            .then(Mono.just(<span class="hljs-string">"事务完成"</span>));
    }
    
    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">nestedReactiveTransaction</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"INSERT INTO test_table (name) VALUES ('test2')"</span>)
            .fetch()
            .rowsUpdated()
            .then();
    }
    
    <span class="hljs-comment">// 响应式事务超时配置</span>
    <span class="hljs-meta">@Transactional(timeout = 5)</span> <span class="hljs-comment">// 5秒超时</span>
    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">reactiveTransactionWithTimeout</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"INSERT INTO slow_table (data) VALUES ('slow_data')"</span>)
            .fetch()
            .rowsUpdated()
            .delayElement(Duration.ofSeconds(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 模拟超时操作</span>
            .then();
    }
}
</code></pre>
<h2 data-id="heading-10">记录式模式（Record Pattern）与不可变事务数据</h2>
<h3 data-id="heading-11">1. Java Record与事务集成</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 使用Java Record定义不可变数据传输对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TransactionalEvent</span><span class="hljs-params">(
    String eventId,
    String eventType,
    LocalDateTime timestamp,
    Map&lt;String, Object&gt; payload
)</span> {
    <span class="hljs-keyword">public</span> TransactionalEvent {
        <span class="hljs-comment">// 紧凑构造器，进行数据验证</span>
        Objects.requireNonNull(eventId, <span class="hljs-string">"eventId不能为null"</span>);
        Objects.requireNonNull(eventType, <span class="hljs-string">"eventType不能为null"</span>);
        timestamp = timestamp != <span class="hljs-literal">null</span> ? timestamp : LocalDateTime.now();
        payload = payload != <span class="hljs-literal">null</span> ? Map.copyOf(payload) : Map.of();
    }
    
    <span class="hljs-comment">// 静态工厂方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TransactionalEvent <span class="hljs-title function_">of</span><span class="hljs-params">(String eventType, Map&lt;String, Object&gt; payload)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionalEvent</span>(
            UUID.randomUUID().toString(),
            eventType,
            LocalDateTime.now(),
            payload
        );
    }
}

<span class="hljs-comment">// Record在事务服务中的使用</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecordBasedTransactionService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> TransactionalResult <span class="hljs-title function_">processUserTransaction</span><span class="hljs-params">(TransactionalCommand command)</span> {
        <span class="hljs-comment">// 使用Record模式进行模式匹配</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (command) {
            <span class="hljs-keyword">case</span> CreateUserCommand createCmd -&gt; createUser(createCmd);
            <span class="hljs-keyword">case</span> UpdateUserCommand updateCmd -&gt; updateUser(updateCmd);
            <span class="hljs-keyword">case</span> DeleteUserCommand deleteCmd -&gt; deleteUser(deleteCmd);
            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"未知命令类型: "</span> + command.getClass());
        };
    }
    
    <span class="hljs-keyword">private</span> TransactionalResult <span class="hljs-title function_">createUser</span><span class="hljs-params">(CreateUserCommand command)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(command.name(), command.email());
        <span class="hljs-type">User</span> <span class="hljs-variable">savedUser</span> <span class="hljs-operator">=</span> userRepository.save(user);
        
        <span class="hljs-comment">// 返回不可变的结果Record</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionalResult</span>(
            <span class="hljs-literal">true</span>,
            <span class="hljs-string">"用户创建成功"</span>,
            Map.of(<span class="hljs-string">"userId"</span>, savedUser.getId(),
                   <span class="hljs-string">"userName"</span>, savedUser.getName())
        );
    }
    
    <span class="hljs-keyword">private</span> TransactionalResult <span class="hljs-title function_">updateUser</span><span class="hljs-params">(UpdateUserCommand command)</span> {
        <span class="hljs-keyword">return</span> userRepository.findById(command.userId())
            .map(user -&gt; {
                user.updateEmail(command.newEmail());
                <span class="hljs-type">User</span> <span class="hljs-variable">updatedUser</span> <span class="hljs-operator">=</span> userRepository.save(user);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionalResult</span>(
                    <span class="hljs-literal">true</span>,
                    <span class="hljs-string">"用户更新成功"</span>,
                    Map.of(<span class="hljs-string">"userId"</span>, updatedUser.getId())
                );
            })
            .orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionalResult</span>(
                <span class="hljs-literal">false</span>,
                <span class="hljs-string">"用户不存在"</span>,
                Map.of()
            ));
    }
    
    <span class="hljs-keyword">private</span> TransactionalResult <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(DeleteUserCommand command)</span> {
        userRepository.deleteById(command.userId());
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionalResult</span>(
            <span class="hljs-literal">true</span>,
            <span class="hljs-string">"用户删除成功"</span>,
            Map.of(<span class="hljs-string">"userId"</span>, command.userId())
        );
    }
}

<span class="hljs-comment">// 命令Record定义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionalCommand</span> 
    <span class="hljs-keyword">permits</span> CreateUserCommand, UpdateUserCommand, DeleteUserCommand {
    
    <span class="hljs-keyword">record</span> <span class="hljs-title class_">CreateUserCommand</span><span class="hljs-params">(String name, String email)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionalCommand</span> {}
    <span class="hljs-keyword">record</span> <span class="hljs-title class_">UpdateUserCommand</span><span class="hljs-params">(Long userId, String newEmail)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionalCommand</span> {}
    <span class="hljs-keyword">record</span> <span class="hljs-title class_">DeleteUserCommand</span><span class="hljs-params">(Long userId)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionalCommand</span> {}
}

<span class="hljs-comment">// 结果Record定义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TransactionalResult</span><span class="hljs-params">(
    <span class="hljs-type">boolean</span> success,
    String message,
    Map&lt;String, Object&gt; data
)</span> {}
</code></pre>
<h2 data-id="heading-12">增强的事务管理特性</h2>
<h3 data-id="heading-13">1. 改进的@Transactional注解</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedTransactionalService</span> {
    
    <span class="hljs-comment">// 1. 支持更多配置选项</span>
    <span class="hljs-meta">@Transactional(
        label = {"critical", "batch-processing"}, // 新增：事务标签
        executionPhase = Transactional.ExecutionPhase.BEFORE_COMMIT // 执行阶段控制
    )</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCriticalBatch</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 关键批量处理逻辑</span>
    }
    
    <span class="hljs-comment">// 2. 条件化事务</span>
    <span class="hljs-meta">@Transactional(condition = "#result != null")</span> <span class="hljs-comment">// 基于结果的条件事务</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserConditionally</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-keyword">return</span> userRepository.findById(userId).orElse(<span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-comment">// 3. 增强的异常处理</span>
    <span class="hljs-meta">@Transactional(
        rollbackFor = {BusinessException.class, DataAccessException.class},
        noRollbackFor = {ValidationException.class},
        dontRollbackOn = {IllegalArgumentException.class} // 新增：不滚动的异常
    )</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWithEnhancedExceptionHandling</span><span class="hljs-params">(User user)</span> {
        validateUser(user); <span class="hljs-comment">// ValidationException - 不回滚</span>
        processBusiness(user); <span class="hljs-comment">// BusinessException - 回滚</span>
        saveUser(user); <span class="hljs-comment">// DataAccessException - 回滚</span>
    }
    
    <span class="hljs-comment">// 4. 事务事件监听增强</span>
    <span class="hljs-meta">@Transactional(eventListener = true)</span> <span class="hljs-comment">// 在事务上下文中触发事件</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBeforeCommit</span><span class="hljs-params">(UserCreatedEvent event)</span> {
        log.info(<span class="hljs-string">"事务提交前处理: {}"</span>, event.getUserId());
        <span class="hljs-comment">// 在事务提交前执行，仍可回滚</span>
        auditService.logCreationAttempt(event.getUserId());
    }
}

<span class="hljs-comment">// 增强的事务事件</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedTransactionEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String transactionId;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionStatus status;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Duration executionTime;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EnhancedTransactionEvent</span><span class="hljs-params">(Object source, String transactionId, 
                                  TransactionStatus status, Duration executionTime)</span> {
        <span class="hljs-built_in">super</span>(source);
        <span class="hljs-built_in">this</span>.transactionId = transactionId;
        <span class="hljs-built_in">this</span>.status = status;
        <span class="hljs-built_in">this</span>.executionTime = executionTime;
    }
    
    <span class="hljs-comment">// 获取事务性能指标</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSlowTransaction</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> executionTime.toMillis() &gt; <span class="hljs-number">1000</span>;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRolledBack</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> status.isRollbackOnly();
    }
}
</code></pre>
<h3 data-id="heading-14">2. 事务模板增强</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedTransactionTemplateConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> TransactionTemplate <span class="hljs-title function_">enhancedTransactionTemplate</span><span class="hljs-params">(PlatformTransactionManager txManager)</span> {
        <span class="hljs-type">TransactionTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionTemplate</span>(txManager);
        
        <span class="hljs-comment">// 新增配置选项</span>
        template.setLabel(<span class="hljs-string">"enhanced-template"</span>); <span class="hljs-comment">// 事务标签</span>
        template.setEnableTimeoutInterruption(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 超时时中断线程</span>
        template.setValidateExistingTransaction(<span class="hljs-literal">true</span>);
        
        <span class="hljs-comment">// 性能优化配置</span>
        template.setOptimizeForWriteOperations(<span class="hljs-literal">true</span>);
        
        <span class="hljs-keyword">return</span> template;
    }
    
    <span class="hljs-meta">@Bean</span> 
    <span class="hljs-keyword">public</span> ReactiveTransactionOperator <span class="hljs-title function_">reactiveTransactionOperator</span><span class="hljs-params">(ReactiveTransactionManager txManager)</span> {
        <span class="hljs-keyword">return</span> TransactionOperator.create(txManager, 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionDefinition</span>() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-string">"reactive-tx"</span>;
                }
                
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getTimeout</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;
                }
                
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLabel</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-string">"reactive-transaction"</span>;
                }
            });
    }
}

<span class="hljs-comment">// 使用增强的事务模板</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedTemplateService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TransactionTemplate enhancedTransactionTemplate;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ReactiveTransactionOperator reactiveTransactionOperator;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWithEnhancedTemplate</span><span class="hljs-params">()</span> {
        TransactionResult&lt;String&gt; result = enhancedTransactionTemplate.execute(status -&gt; {
            <span class="hljs-comment">// 访问增强的事务状态</span>
            <span class="hljs-keyword">if</span> (status.hasLabel(<span class="hljs-string">"critical"</span>)) {
                log.info(<span class="hljs-string">"执行关键事务操作"</span>);
            }
            
            <span class="hljs-comment">// 业务逻辑</span>
            performBusinessOperation();
            
            <span class="hljs-keyword">return</span> <span class="hljs-string">"操作成功"</span>;
        });
        
        log.info(<span class="hljs-string">"事务执行结果: {}"</span>, result);
    }
    
    <span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title function_">processReactiveWithOperator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> databaseClient.sql(<span class="hljs-string">"SELECT * FROM users WHERE id = :id"</span>)
            .bind(<span class="hljs-string">"id"</span>, <span class="hljs-number">1L</span>)
            .fetch()
            .one()
            .as(reactiveTransactionOperator::transactional)
            .map(result -&gt; <span class="hljs-string">"响应式事务完成: "</span> + result);
    }
}
</code></pre>
<h2 data-id="heading-15">原生编译与GraalVM支持</h2>
<h3 data-id="heading-16">1. Spring Native事务配置</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@NativeHint(
    types = {
        @TypeHint(types = {
            PlatformTransactionManager.class,
            DataSourceTransactionManager.class,
            JpaTransactionManager.class,
            TransactionTemplate.class,
            Transactional.class
        }),
        @TypeHint(types = {
            TransactionDefinition.class,
            TransactionStatus.class
        }, access = AccessBits.ALL)
    },
    triggers = {
        @TypeHint(trigger = TransactionalAnnotationProcessor.class)
    }
)</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeTransactionConfiguration</span> {
    
    <span class="hljs-comment">// 原生编译友好的事务管理器配置</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@RuntimeHint</span>
    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> {
        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);
        
        <span class="hljs-comment">// 原生编译优化的配置</span>
        tm.setNestedTransactionAllowed(<span class="hljs-literal">true</span>);
        tm.setValidateExistingTransaction(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 原生编译中简化验证</span>
        
        <span class="hljs-keyword">return</span> tm;
    }
    
    <span class="hljs-comment">// AOT（Ahead-of-Time）优化的事务建议</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span>
    <span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title function_">transactionAdvisor</span><span class="hljs-params">(
        TransactionAttributeSource transactionAttributeSource,
        TransactionInterceptor transactionInterceptor)</span> {
        
        <span class="hljs-type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();
        advisor.setTransactionAttributeSource(transactionAttributeSource);
        advisor.setAdvice(transactionInterceptor);
        advisor.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">1</span>); <span class="hljs-comment">// 优化执行顺序</span>
        
        <span class="hljs-keyword">return</span> advisor;
    }
}

<span class="hljs-comment">// 原生编译友好的事务服务</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeFriendlyTransactionService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderRepository orderRepository;
    
    <span class="hljs-comment">// 使用构造器注入（原生编译友好）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NativeFriendlyTransactionService</span><span class="hljs-params">(UserRepository userRepository, 
                                          OrderRepository orderRepository)</span> {
        <span class="hljs-built_in">this</span>.userRepository = userRepository;
        <span class="hljs-built_in">this</span>.orderRepository = orderRepository;
    }
    
    <span class="hljs-comment">// 简单明确的事务方法（避免反射和动态代理的复杂性）</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">(String name, String email)</span> {
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name, email);
        <span class="hljs-keyword">return</span> userRepository.save(user);
    }
    
    <span class="hljs-comment">// 避免在事务方法中使用复杂Lambda（原生编译限制）</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Long userId, String product)</span> {
        <span class="hljs-comment">// 直接的方法调用，避免方法引用和复杂Lambda</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRepository.findById(userId);
        <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(user, product);
            orderRepository.save(order);
        }
    }
}
</code></pre>
<h3 data-id="heading-17">2. GraalVM原生镜像优化</h3>
<pre><code class="hljs language-properties" lang="properties"># src/main/resources/META-INF/native-image/proxy-config.json
{
  "resources": {
    "includes": [
      {
        "pattern": ".*transaction.*"
      }
    ]
  },
  "proxies": [
    {
      "interfaces": [
        "org.springframework.transaction.PlatformTransactionManager"
      ]
    },
    {
      "interfaces": [
        "org.springframework.transaction.ReactiveTransactionManager"  
      ]
    }
  ]
}

# src/main/resources/META-INF/native-image/resource-config.json
{
  "resources": {
    "includes": [
      {
        "pattern": ".*Transactional.*"
      }
    ]
  }
}
</code></pre>
<h2 data-id="heading-18">迁移指南和兼容性</h2>
<h3 data-id="heading-19">1. 从Spring Boot 2.x迁移</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 迁移前的兼容性配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationCompatibilityConfig</span> {
    
    <span class="hljs-comment">// 保持对旧版事务管理的兼容</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConditionalOnMissingBean</span>
    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> {
        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);
        
        <span class="hljs-comment">// Spring Boot 2.x兼容配置</span>
        tm.setNestedTransactionAllowed(<span class="hljs-literal">true</span>);
        tm.setValidateExistingTransaction(<span class="hljs-literal">true</span>);
        tm.setGlobalRollbackOnParticipationFailure(<span class="hljs-literal">false</span>);
        
        <span class="hljs-keyword">return</span> tm;
    }
    
    <span class="hljs-comment">// 支持新旧注解并存</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title function_">transactionAttributeSource</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTransactionAttributeSource</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">protected</span> TransactionAttribute <span class="hljs-title function_">parseTransactionAnnotation</span><span class="hljs-params">(AnnotationAttributes attributes)</span> {
                <span class="hljs-comment">// 支持javax.transaction.Transactional和jakarta.transaction.Transactional</span>
                <span class="hljs-type">RuleBasedTransactionAttribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.parseTransactionAnnotation(attributes);
                
                <span class="hljs-comment">// 迁移期间的额外兼容性处理</span>
                <span class="hljs-keyword">if</span> (attributes.containsKey(<span class="hljs-string">"timeout"</span>) &amp;&amp; attributes.getNumber(<span class="hljs-string">"timeout"</span>) &gt; <span class="hljs-number">0</span>) {
                    attr.setTimeout(attributes.getNumber(<span class="hljs-string">"timeout"</span>).intValue());
                }
                
                <span class="hljs-keyword">return</span> attr;
            }
        };
    }
}

<span class="hljs-comment">// 渐进式迁移服务</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationService</span> {
    
    <span class="hljs-comment">// 方法1: 继续使用Spring的@Transactional（推荐）</span>
    <span class="hljs-meta">@org</span>.springframework.transaction.annotation.Transactional
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithSpringTransactional</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 业务逻辑</span>
    }
    
    <span class="hljs-comment">// 方法2: 使用Jakarta @Transactional（如需要）</span>
    <span class="hljs-meta">@jakarta</span>.transaction.Transactional
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithJakartaTransactional</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 业务逻辑</span>
    }
    
    <span class="hljs-comment">// 方法3: 编程式事务（迁移期间更安全）</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TransactionTemplate transactionTemplate;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodWithProgrammaticTx</span><span class="hljs-params">()</span> {
        transactionTemplate.execute(status -&gt; {
            <span class="hljs-comment">// 业务逻辑</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        });
    }
}
</code></pre>
<h2 data-id="heading-20">性能基准测试</h2>
<h3 data-id="heading-21">1. 新旧版本性能对比</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring6TransactionBenchmark</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TransactionalService transactionalService;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchmarkVirtualThreadPerformance</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">operationCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">virtualThreadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;
        
        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        
        <span class="hljs-comment">// 使用虚拟线程执行并发事务</span>
        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; virtualThreadCount; i++) {
            CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; operationCount / virtualThreadCount; j++) {
                    transactionalService.lightweightOperation();
                }
            }, virtualThreadExecutor);
            
            futures.add(future);
        }
        
        CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])).join();
        <span class="hljs-type">long</span> <span class="hljs-variable">virtualThreadTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;
        
        log.info(<span class="hljs-string">"虚拟线程事务性能: {} 操作/秒"</span>, 
            operationCount * <span class="hljs-number">1000.0</span> / virtualThreadTime);
    }
    
    <span class="hljs-meta">@Test</span> 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchmarkReactiveTransactionPerformance</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">operationCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
        
        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        
        Flux.range(<span class="hljs-number">1</span>, operationCount)
            .flatMap(i -&gt; reactiveTransactionService.reactiveOperation())
            .blockLast();
            
        <span class="hljs-type">long</span> <span class="hljs-variable">reactiveTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;
        
        log.info(<span class="hljs-string">"响应式事务性能: {} 操作/秒"</span>, 
            operationCount * <span class="hljs-number">1000.0</span> / reactiveTime);
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compareNativeVsJvmPerformance</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 比较原生编译与JVM执行的性能差异</span>
        <span class="hljs-comment">// 需要在实际的原生镜像环境中运行</span>
        log.info(<span class="hljs-string">"原生编译事务性能测试需要在GraalVM原生镜像中执行"</span>);
    }
}
</code></pre>
<h2 data-id="heading-22">总结</h2>
<p>Spring Framework 6和Spring Boot 3为事务管理带来了重大革新：</p>
<h3 data-id="heading-23">主要改进：</h3>
<ol>
<li><strong>虚拟线程支持</strong>：大幅提升并发事务处理能力</li>
<li><strong>响应式事务增强</strong>：完善的R2DBC和响应式编程支持</li>
<li><strong>Record模式集成</strong>：更好的不可变数据支持</li>
<li><strong>原生编译优化</strong>：GraalVM原生镜像支持</li>
<li><strong>注解增强</strong>：更灵活的事务配置选项</li>
</ol>
<h3 data-id="heading-24">升级建议：</h3>
<ol>
<li><strong>评估Java 17兼容性</strong>：确保依赖库支持新版本</li>
<li><strong>逐步迁移</strong>：先从非核心服务开始升级</li>
<li><strong>性能测试</strong>：验证新特性在具体场景下的性能提升</li>
<li><strong>团队培训</strong>：学习虚拟线程和响应式编程新概念</li>
</ol>
<h3 data-id="heading-25">未来展望：</h3>
<p>Spring 6的事务管理为云原生、响应式、高性能应用提供了坚实基础，是构建现代Java应用的必备技术栈。</p>
<hr/>
<p><strong>系列总结</strong>：通过本系列文章，我们深入探讨了Spring事务管理的各个方面，从基础概念到高级特性，从单体应用到微服务架构，再到最新的Spring 6创新。希望这些内容能帮助你在实际项目中更好地设计和管理事务。</p>
<p>如果觉得本系列文章对你有帮助，请点赞、收藏、关注！欢迎在评论区分享你的Spring事务实践经验和问题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开源新势力：openGauss 在数字时代企业级开源库选型核心的竞争力]]></title>    <link>https://juejin.cn/post/7572397142364995626</link>    <guid>https://juejin.cn/post/7572397142364995626</guid>    <pubDate>2025-11-14T16:39:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572397142364995626" data-draft-id="7572385850636189702" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开源新势力：openGauss 在数字时代企业级开源库选型核心的竞争力"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2025-11-14T16:39:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鸽芷咕"/> <meta itemprop="url" content="https://juejin.cn/user/2447965011313308"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开源新势力：openGauss 在数字时代企业级开源库选型核心的竞争力
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2447965011313308/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鸽芷咕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T16:39:08.000Z" title="Fri Nov 14 2025 16:39:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 AI 与大数据深度融合的数字化浪潮中，数据形态正从单一结构化向 “结构化 + 非结构化” 混合形态演进。而数据库作为企业数据资产的核心载体，其选型直接关系到业务连续性、数据安全性与技术前瞻性。随着开源技术成为企业级应用的主流选择，市场对数据库的需求已从单纯的 “存储与查询”，升级为对 “高性能、高安全、高可用、智能化” 综合能力的诉求。</p>
<p>openGauss 作为源于华为技术沉淀的企业级开源关系型数据库，凭借架构创新、技术突破与生态共建，已成为越来越多关键行业的选型之一。下面，我们就来探究 openGauss 在数据库选型中究竟具备哪些竞争力！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c7f93117d85416994584d1579d4f82c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=RBE7GkB3OzIm2W8LwZA6y9yvObM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">一、openGauss 向量数据库简介</h2>
<p>openGauss是一款全面友好开放，携手伙伴共同打造的企业级开源关系型数据库。openGauss提供面向多核架构的极致性能、全链路的业务、数据安全、基于AI的调优和高效运维的能力。其核心架构采用 “内核 + 引擎” 的模块化设计，内核层面保留关系型数据库的 ACID 事务特性，引擎层面则集成 DataVec 向量数据库能力，形成 “结构化 + 非结构化” 一体化处理能力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14089a435a6c486186a9858ba7764c7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=ez8WsfDmIvahc%2F%2BsijnlYKUFd%2FI%3D" alt="" loading="lazy"/></p>
<p>在开源属性上，openGauss 采用<strong>木兰宽松许可证 V2</strong>，允许用户免费下载、使用、修改源代码，且无需开源衍生作品，极大降低企业技术接入成本，同时鼓励社区开发者参与代码贡献与功能迭代。</p>
<h2 data-id="heading-2">二、openGauss 的技术特性</h2>
<h3 data-id="heading-3">2.1 向量数据库能力</h3>
<p>openGauss 依托内核原生特性 DataVec 向量引擎构建向量数据库能力，支持向量数据类型的存储与检索，针对大规模高维向量数据可提供快速精准的检索结果，涵盖精确与近似最近邻搜索两种模式，支持 L2 距离、余弦距离、内积等多种相似度计算方式，同时具备向量索引、丰富的向量操作函数与操作符，且兼容熟悉的 SQL 语法简化使用流程，无需额外复杂部署，能广泛适配智能知识检索、检索增强生成（RAG）等各类复杂智能应用场景，为相关场景落地提供高效可靠的技术支撑。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/243b1cf7a5f74e4fa205244391c13f97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=KIAersyqVMxvWnjn0RmlAg9lBe4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">2.2 AI 与数据库的深度融合</h3>
<p>作为“AI与数据库双向融合”领域较早落地的开源数据库，openGauss通过其AI特性子模块DBMind，明确划分出AI4DB（AI优化数据库）与DB4AI（数据库驱动AI）两大核心方向，构建起“自优化、自诊断、自运维、自安全”的智能化闭环。这并非简单的功能叠加，而是从内核层面实现AI与数据库的深度协同，精准破解传统数据库“运维难、调优难、AI接入复杂”的核心痛点。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b66179622f994b5a9faf557e68e102aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=g96ew76sJNaGHAAu4mLFoBrpttk%3D" alt="" loading="lazy"/></p>
<p>其中AI4DB主要用于对数据库进行自治运维和管理，从而帮助数据库运维人员减少运维工作量。在实现上，DBMind的AI4DB框架具有监控和服务化的性质，同时也提供即时AI工具包，提供开箱即用的AI运维功能（如索引推荐）。AI4DB的监控平台以开源的Prometheus为主，DBMind提供监控数据生产者exporter, 可与Prometheus平台完成对接。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35f6abec8bcb4ea488c5e60f54a814da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=bnSavDyIHfHh7CC%2BNwMtqx4W66w%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">2.3 RAG 场景技术适配</h3>
<p>检索增强生成（RAG）是大模型落地的核心场景，其核心需求是“快速检索高质量上下文并输入大模型，提升回答准确性”（避免大模型“一本正经地胡说八道”）。openGauss 针对 RAG 场景的三大痛点（向量检索效率低、数据更新不及时、多源数据难整合）进行深度适配，成为 RAG 系统的理想数据底座。</p>
<h2 data-id="heading-6">三、实测体验</h2>
<h3 data-id="heading-7">3.1 安装openGauss</h3>
<p>由于国内镜像源访问原因，直接拉取下载的话特别容易出现拉取失败等提示，所以我们选择通过 wget 命令下载 openGauss 的 Docker 镜像包，并加载到docker启动。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17871bc337a747d99f596a1ed0597963~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=WAwht04apgdH%2F6UjXvhsG9iHcw0%3D" alt="" loading="lazy"/></p>
<ul>
<li>下载镜像包（我们本次用的是Centos 7.6版本的所以在下载的时候要注意一点要选择CentOS7-x86_64架构下的安装包 ）</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">wget https://openGauss.obs.cn-south-1.myhuaweicloud.com/7.0.0-RC2/openEuler22.03/x86/openGauss-Docker-7.0.0-RC2-x86_64.tar
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd2f808b46f44f1da3f9fa7712c5cb12~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=cWuZupzG%2B2pk0VRavgqYLnHY8Ww%3D" alt="" loading="lazy"/></p>
<ul>
<li>加载镜像</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">docker load -i openGauss-Docker-7.0.0-RC2-x86_64.tar
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a4440b3e7c045fc83ef775b200f979f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=rRASH8mKzVzEi5wn7%2FKY5mo5USI%3D" alt="" loading="lazy"/></p>
<ul>
<li>验证镜像状态</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">docker images
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97a6edb496d74591b27f9c672fd4a594~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=e4S14o8oZscSkVa%2BtLqn0Vtivu4%3D" alt="" loading="lazy"/></p>
<ul>
<li>启动容器，从上面可以看到我们的仓库名是 openGauss，标签是 7.0.0-RC2。然后直接用本地镜像启动就OK了</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">[root@hcss-ecs-d81a gugu]# # 
[root@hcss-ecs-d81a gugu]# docker run --name openGauss --privileged=true -d -e GS_PASSWORD=Gugu@123 -p 5432:5432 openGauss:7.0.0-RC2
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccc0b93f0e9d4124a05239e42c9438ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=jMYKT%2BMQWUu9vil4xfpZRApippE%3D" alt="" loading="lazy"/></p>
<ul>
<li>参看容器状态</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">docker ps | grep openGauss
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/411b79be55f3452089fb3792b64aadb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=fyX0LkJ10QgXtqaKG4GfcfiGFIA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">3.2 gsql 连接数据库</h3>
<p>数据可以启动之后，我们就可以直接试用官方提供的 gsql 连接数据库。gsql是openGauss提供在命令行下运行的数据库连接工具，可以通过此工具连接服务器并对其进行操作和维护，除了具备操作数据库的基本功能，gsql还提供了若干高级特性，便于用户使用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f79e937b0c384744b7252d5bb55bba7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=fyhGX0BSThu1y8Zqn5biFxeo8Xg%3D" alt="" loading="lazy"/></p>
<ul>
<li>进入容器</li>
</ul>
<pre><code class="hljs language-plain" lang="plain">docker exec -it openGauss bash
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1577fec9acb4c96ad1147067cef0280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=rSIiPw%2FSR5MGeNjH2%2F2RAbijLIc%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-plain" lang="plain">gsql -d postgres -U omm -p 5432 -r
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e0c2b89772e149d6abda2d965dcc4823~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=LYV1Y41POONNrHwMJyEyzARQ6IE%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">3.3 SQL兼容性测试</h3>
<p>以上openGauss就已经安装连接好了，那么接下来我们就来测试一下SQL语句的兼容性。验证一下增删改查 这些操作。</p>
<ol>
<li>首先我们先创建一个测试数据库在使用 \l 命令查看一下数据库列表。</li>
</ol>
<pre><code class="hljs language-plain" lang="plain">-- 创建新数据库 test_db
CREATE DATABASE test_db;

-- 查看所有数据库（验证创建结果）
\l
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0affc51d84ae4d7587552a53c531f71c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=LLWEi2J%2BDKnF24hdlIvwCGUJ%2FBk%3D" alt="" loading="lazy"/></p>
<ol>
<li>切换到 test_db 数据库，创建一个雇员表</li>
</ol>
<pre><code class="hljs language-plain" lang="plain">-- 切换到 test_db 数据库
\c test_db

-- 创建雇员表（包含常用字段）
CREATE TABLE employees (
    emp_id SERIAL PRIMARY KEY,  -- 自增主键（雇员ID）
    first_name VARCHAR(50) NOT NULL,  -- 名
    last_name VARCHAR(50) NOT NULL,   -- 姓
    gender CHAR(1) CHECK (gender IN ('M', 'F', 'O')),  -- 性别（M男/F女/O其他）
    birth_date DATE NOT NULL,  -- 出生日期
    hire_date DATE NOT NULL,   -- 入职日期
    department VARCHAR(50) NOT NULL,  -- 部门（如技术部、市场部）
    position VARCHAR(50) NOT NULL,    -- 职位（如开发工程师、经理）
    salary NUMERIC(10, 2) NOT NULL,   -- 薪资（精确到分）
    email VARCHAR(100) UNIQUE NOT NULL,  -- 邮箱（唯一）
    phone VARCHAR(20),  -- 电话
    address TEXT,       -- 地址
    is_active BOOLEAN DEFAULT TRUE  -- 是否在职（默认在职）
);
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51bbf00af5ed4cb2a16251764f3edab6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=zB%2BP9geqSM8haWFEFn4reiHdvdI%3D" alt="" loading="lazy"/></p>
<ol>
<li>下面我们来测试 openGauss 对 PL/pgSQL 语法的兼容性及执行效率。 通过运行 PL/pgSQL 代码批量插入 10 万条测试数据，直观验证其语法支持情况与数据插入性能。</li>
</ol>
<pre><code class="hljs language-plain" lang="plain">-- 批量插入 1000 条雇员数据（使用 PL/pgSQL 循环）
DO $$
DECLARE
    i INT := 1;
    depts TEXT[] := ARRAY['技术部', '市场部', '财务部', '人力资源部', '销售部'];
    positions TEXT[] := ARRAY['开发工程师', '产品经理', '测试工程师', '财务专员', '销售代表', 'HR专员', '部门经理'];
    genders CHAR[] := ARRAY['M', 'F', 'O'];
BEGIN
    WHILE i &lt;= 100000 LOOP
        INSERT INTO employees (
            first_name, last_name, gender, birth_date, hire_date,
            department, position, salary, email, phone, address, is_active
        ) VALUES (
            '员工' || i,  -- 名（如 员工1、员工2...）
            '测试',       -- 姓
            genders[floor(random() * array_length(genders, 1)) + 1],  -- 随机性别
            CURRENT_DATE - (30 + floor(random() * 30)::INT) * 365,  -- 30-60岁随机生日
            CURRENT_DATE - (1 + floor(random() * 10)::INT) * 365,   -- 1-10年随机入职时间
            depts[floor(random() * array_length(depts, 1)) + 1],    -- 随机部门
            positions[floor(random() * array_length(positions, 1)) + 1],  -- 随机职位
            5000 + floor(random() * 25000)::NUMERIC(10,2),  -- 5000-30000随机薪资
            'emp' || i || '@test.com',  -- 邮箱（唯一）
            '138' || lpad(floor(random() * 100000000)::TEXT, 8, '0'),  -- 随机手机号
            '测试地址' || i,  -- 地址
            CASE WHEN random() &gt; 0.1 THEN TRUE ELSE FALSE END  -- 90%概率在职
        );
        i := i + 1;
    END LOOP;
END $$;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20d97b10da33450480db69de6b8d584f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=9BcDXuWQrF4QKNZwp%2F2bVPAV4%2FU%3D" alt="" loading="lazy"/></p>
<p>从测试结果可知，100000 条雇员数据已成功写入 employees 表，操作完全符合预期。数据在插入过程响应极快。接下来，我们将进一步验证 openGauss 对 SQL 语句其他功能的支持表现。</p>
<ol>
<li><strong>基础数据类型与表操作（DDL）</strong></li>
</ol>
<p>基础数据类型与表操作我们测试主要围绕以下内容展开：创建包含多种数据类型的表以验证数据类型兼容性，查看表结构以验证元数据查询兼容性，以及修改表结构以验证 ALTER 语法兼容性。</p>
<pre><code class="hljs language-plain" lang="plain">CREATE TABLE test_data_types (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    birth_date DATE,
    salary NUMERIC(10,2),
    is_active BOOLEAN DEFAULT TRUE,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    bio TEXT,
    tags VARCHAR(20)[]  
    );
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcffed82a0024ee3a3c6a0307ad9312b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=wWaSu4DWtHxkRWRFJ%2B%2FMj6o%2FLtQ%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-plain" lang="plain">-- 查询 information_schema 系统表（标准 SQL 兼容方式）
SELECT 
    column_name, 
    data_type, 
    is_nullable, 
    column_default 
FROM information_schema.columns 
WHERE table_name = 'test_data_types';
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a01f4116598f474491b99b6c4741fd11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=ETsuQWhI3JysiO1C6BlMHaKw838%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-plain" lang="plain">-- 修改表结构（验证ALTER语法兼容性）
ALTER TABLE test_data_types 
    ADD COLUMN dept_id INT,
    ALTER COLUMN salary SET DEFAULT 0.00;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/080651e9e2964e4cb8db2697f1f1e5b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=pvVAIjShzh7fSMVGTL%2By1PHDpg4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">3.4 测试总结</h3>
<p>从上述测试可看出，openGauss 作为高性能、高可靠性的开源关系型数据库，既继承了 PostgreSQL 的强大功能，又在语法与协议层面进行了针对性优化增强，尤其提升了对 MySQL 语法的兼容性。这种良好的兼容性，让我们能从 MySQL 到 openGauss 的迁移过程更加便捷顺畅。</p>
<h2 data-id="heading-11">四、开放与繁荣的技术生态</h2>
<h3 data-id="heading-12">4.1 生态建设方面</h3>
<p>在生态建设这方面，openGauss深知，现代数据库的竞争不仅是技术的竞争，进入 “生态决胜” 的新阶段。因此，它从生态顶层设计出发，始终以 “全面开放、协同共生” 为核心，构建覆盖伙伴、开发者与用户的技术生态体系。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af33afdf03484d7997df8417fac9fd25~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=c9aNg6TgJrGfaWI7lL10Xi%2FoWSQ%3D" alt="" loading="lazy"/></p>
<p>早在 2019 年宣布开源之初，openGauss 就同步启动开源社区运营，通过文档共建、技术研讨、贡献者激励等机制吸引全球参与者。经过多年沉淀，其生态规模持续壮大：目前已汇聚 820 家企业成员、7500 名活跃开发者，全球累计下载量突破 350 万次，无论是企业级伙伴的深度参与，还是个人开发者的代码贡献，都呈现出清晰的增长趋势，生态活力肉眼可见。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2be4579f0814dce8e669b4b01d884bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=k1KJmkxwvS72jxOS%2F5r6uT%2BF94A%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">4.2 <strong>伙伴与产品</strong></h3>
<p>伙伴体系方面，openGauss 不依赖单一厂商，而是联合上下游伙伴打造“硬件+软件+服务”全栈生态，解决企业“适配难、落地难”问题。以硬件适配为例，其与鲲鹏服务器的协同不仅停留在基础兼容性层面，更深入技术内核做联合优化 —— 通过集成 RDMA 高速网络技术，直接加速数据库 WAL（预写日志）的跨节点传输效率，我们在进行鲲鹏服务器进行测试也明显的感受到，数据同步速度确实比普通服务器快。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/962c207828624707b79f8b8182c0d691~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=8chjb0sLrSgFzWOlL5YXUVd7yL8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">4.3 <strong>迁移与丰富的工具生态</strong></h3>
<p>企业更换数据库时，最担心“数据迁移难、代码适配繁、工具不兼容”，而openGauss 则给我们提供完善的迁移工具链与兼容方案，解决迁移痛点。</p>
<ul>
<li><strong>自动化迁移工具</strong>：推出 DataKit 迁移工具，支持从 MySQL、Oracle、PostgreSQL 等数据库向 openGauss 迁移，实现“三步完成迁移”</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/410bc8696296428dab117f8357576536~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=mvI8XyKvDJfQjCz%2FDwg9IAW%2F0Y8%3D" alt="" loading="lazy"/></p>
<ul>
<li><strong>丰富的工具链</strong>：提供了<strong>openGauss-OM</strong>：提供了一键式部署、升级、监控和管理的运维工具。<strong>Data Studio</strong>：图形化的数据库管理开发工具。pg_chameleon：MySQL到openGauss数据迁移工具等等。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcf53d5b14ef4ab4ac8695362d578f56~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6bi96Iq35ZKV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763743147&amp;x-signature=%2BPJDiD%2BWRCMOuy%2BjxKqdLDdSJo0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-15">总结</h2>
<p>从以上分析实测我们不难看出，openGauss 凭借高可用、高性能、高安全、易运维（基于AI的智能参数调优和索引推荐，提供AI自动参数推荐）等已经成为成为企业数字化转型的核心优选。在技术上，openGauss 率先实现 AI 与数据库的深度融合 ——DBMind 模块的 AI4DB 能力降低运维成本、提升系统稳定性，DB4AI 能力简化 AI 任务落地；目前，已有众多知名企业基于 openGauss 搭建了专属数据库系统。所以对于企业有智能化数据处理需求openGauss是一个不错的选择。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI使用知识库增强对话功能]]></title>    <link>https://juejin.cn/post/7572455881029287945</link>    <guid>https://juejin.cn/post/7572455881029287945</guid>    <pubDate>2025-11-15T01:25:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572455881029287945" data-draft-id="7572466174224023578" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI使用知识库增强对话功能"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-11-15T01:25:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="changelzj"/> <meta itemprop="url" content="https://juejin.cn/user/1943592289445358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI使用知识库增强对话功能
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592289445358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    changelzj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T01:25:00.000Z" title="Sat Nov 15 2025 01:25:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在其他地方查看文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fpost%2Fspring-ai%2F2025%2F11%2F01%2Fspring-ai-rag%2F" target="_blank" title="https://blog.liuzijian.com/post/spring-ai/2025/11/01/spring-ai-rag/" ref="nofollow noopener noreferrer">blog.liuzijian.com/post/spring…</a></p>
<h2 data-id="heading-0">1.引言</h2>
<p>之前提到过，大模型的训练语料库和现实世界相比，往往滞后，比如当下一些热门的话题大模型通常会不了解，一种解决这种问题的方式是，在发消息时将实时的相关的数据一并发送给它，对大模型的知识储备进行补充。</p>
<p>但是，实时的数据是海量的，不能将内容整个全部发送大模型，而且Token的限制也不允许这样做，我们只需要检索出和问题相关的片段然后拆分出来发送即可。</p>
<p>如何检索数据呢？用ES？答案是否定的，因为ES是一种全文检索，不能完美实现相关性检索，例如我们想要和大模型聊一下最近有哪些“国际争端”之类的话题，“柬泰边境冲突”肯定算一件，但是如果以“国际争端” “争端”为关键词简单的全文检索，无法将这个话题有关的内容全部查询命中，因为这种场景的检索要求的不是文字的匹配而是语义的匹配，于是这里就引入了一个概念：向量相似度。</p>
<h2 data-id="heading-1">2.向量相似度</h2>
<p>首先理解向量，向量就是数学中代表一个既有大小又有方向的量，物理上也称为矢量，例如平面直角坐标系上从(0, 0)点到任意一点构成的线段就是一个向量，向量相似度指的就是两个向量是否相似，通过欧氏距离和余弦距离都可判断相似度，欧氏距离越小，相似度越高，余弦距离越大，相似度越高</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Fvector.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/vector.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/040b926767da4751a6ea6a548c125925~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhbmdlbHpq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763774699&amp;x-signature=yY0Rb9KmYB9ZmJZhxBU%2F5k632lY%3D" alt="" loading="lazy"/></a></p>
<p>计算机中的数据都是以数字的形式进行存储，如果根据内容含义将文字数据转换成空间中的坐标，就成功把文字信息向量化了，含义相似的文本，转换为点的距离越近，通过对比向量相似度即可获得语义相近的内容。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Frag%2Fenb.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/rag/enb.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/536314a1df5d441397c6668923e4cb3d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhbmdlbHpq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763774699&amp;x-signature=umQrT3dXmrMT2%2BFVXTatkMKkKxA%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-2">3.嵌入（Embedding）模型</h2>
<p>根据内容转换为向量的工作需要交由支持文本的嵌入模型来完成</p>
<blockquote>
<p>嵌入（Embedding）是文本、图像或视频的数值表示，能够捕捉输入之间的关系，Embedding 通过将文本、图像和视频转换为称为向量（Vector）的浮点数数组来工作。这些向量旨在捕捉文本、图像和视频的含义，Embedding 数组的长度称为向量的维度。通过计算两个文本片段的向量表示之间的数值距离，应用程序可以确定用于生成嵌入向量的对象之间的相似性。</p>
</blockquote>
<p>我用过常见的支持文本的嵌入模型有：</p>
<ul>
<li>Z智谱embedding-3：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.bigmodel.cn%2Fcn%2Fguide%2Fmodels%2Fembedding%2Fembedding-3" target="_blank" title="https://docs.bigmodel.cn/cn/guide/models/embedding/embedding-3" ref="nofollow noopener noreferrer">docs.bigmodel.cn/cn/guide/mo…</a></li>
<li>阿里云通义千问text-embedding-v4：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbailian.console.aliyun.com%2F%3Ftab%3Dmodel%23%2Fmodel-market%2Fdetail%2Ftext-embedding-v4" target="_blank" title="https://bailian.console.aliyun.com/?tab=model#/model-market/detail/text-embedding-v4" ref="nofollow noopener noreferrer">bailian.console.aliyun.com/?tab=model#…</a></li>
</ul>
<p>因为DeepSeek没有文本嵌入模型，因此这里采用阿里云百炼平台通义千问text-embedding-v4实现文本向量化。</p>
<p>基于jdk-21创建spring-boot项目，引入spring-boot依赖3.5.7，spring-ai依赖1.0.3，因为阿里云百炼平台兼容了OpenAI的协议，因此还需要引入spring-ai-starter-model-openai对接阿里云百炼平台</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>21<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>21<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-model-openai<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Lombok --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>


    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<p>application.yml中，将阿里云百炼text-embedding-v4配在openai下，而且URL后面的<code>/v1</code>必须去掉，否则无法连接成功</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">ai:</span>
    <span class="hljs-attr">openai:</span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">https://dashscope.aliyuncs.com/compatible-mode</span>
      <span class="hljs-attr">api-key:</span> <span class="hljs-string">sk-</span>
      <span class="hljs-attr">embedding:</span>
        <span class="hljs-attr">options:</span>
          <span class="hljs-attr">model:</span> <span class="hljs-string">text-embedding-v4</span>
          <span class="hljs-attr">dimensions:</span> <span class="hljs-number">1024</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">org.springframework.ai:</span> <span class="hljs-string">debug</span>
</code></pre>
<p>测试一下文本转向量</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> org.example.test;

<span class="hljs-keyword">import</span> jakarta.annotation.Resource;
<span class="hljs-keyword">import</span> org.example.Main;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.ai.openai.OpenAiEmbeddingModel;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;

<span class="hljs-meta">@SpringBootTest(classes = Main.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEmbedding</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OpenAiEmbeddingModel embeddingModel;


    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">"今天是10月的最后一天"</span>;

        <span class="hljs-type">float</span>[] embed = embeddingModel.embed(text);

        <span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> v : embed) {
            System.out.print(v+<span class="hljs-string">" "</span>);
        }
    }
}
</code></pre>
<p>得到System.out.print结果：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">-0.03598024 -0.07856088 -0.023570947 -0.05446673 -0.016179034 0.028628573 0.006583633 -0.0021095797 0.012744679 0.011946459 0.0030872307 0.033162996 0.07281907 0.047088236 -0.02217574 0.017708397 -0.036033902 -0.061067134 -0.017466918 0.021961093 0.03321666 0.018821878 0.040943958 0.025355203 -0.036785167 0.00426276 -0.003155985 -0.031714126 0.0018714555 0.020539057 -0.0055271657 -0.028735897 -0.011765351 0.030587228 -0.04013903 0.0022303187 -0.04231233 0.07968778 0.0012048752 0.05672053 0.025288126 -0.015789986 -6.0411455E-4 0.004504238 0.009216415 0.044780776 0.012315384 -0.0024734738 0.009605463 0.008418196 0.01958656 -0.010101835 0.06536008 0.058115736 -0.015991218 -0.009887188 0.046041828 -0.0139789 -0.017909627 6.5064937E-4 -0.014891151 -0.014810658 -0.05677419 -0.07110189 0.007955363 -0.013220928 -0.04464662 -0.008082809 -0.016849807 -0.053930115 0.05731081 -0.006352216 -0.013173973 0.0062884926 -0.015025306 0.057632778 0.0033555396 0.067989506 -0.012536739 -0.103942916 -0.014448441 0.014770412 -0.0021229952 -0.013194096 0.0754485 0.030426243 -0.017627902 -0.0200561 0.019251173 0.057579115 0.01934508 -0.026696747 -0.0011495365 -0.043573387 -0.006570217 -0.031016523 -0.0570425 0.003638941 0.013871577 0.006305262 -6.152242E-5 0.06407219 -0.0048530395 -0.010195743 0.054627717 0.10490883 -0.04494176 0.019090187 0.003887127 -0.026066221 -0.044727113 -0.018419415 -0.0117452275 0.019559728 -0.011792182 0.061174456 -0.0058290134 0.025824744 0.0021162874 -0.0018446245 -0.012959326 0.024442952 -0.011282395 -0.044485636 0.009806694 -0.012825171 0.011161655 -0.015253368 0.05465455 0.012147691 0.016031465 -0.032599546 0.0017523933 -0.027743153 0.006915665 -0.0217062 0.01666199 0.027313858 -0.025033232 -0.0045780228 0.02766266 -0.0151728755 0.012496493 -0.013542898 -0.04247332 0.015937556 0.012147691 -0.06718458 -0.011926336 0.011322641 -0.008344411 -0.0033370934 -0.034933835 0.055432644 -0.018969448 -0.04005854 0.023101406 0.024939325 -0.025797913 0.018419415 0.03917312 0.017332762 0.03871699 0.010075004 0.031016523 -0.037080307 -0.025194218 -0.026844317 0.028896881 0.028789558 -0.010007926 0.042607475 -4.5151377E-4 0.0042862366 0.023839258 0.035175312 0.018687723 -0.029889625 0.0059933527 -0.008860906 0.04657845 -4.5235225E-4 0.0038904808 -0.014153301 -0.014971644 -0.014770412 0.0618184 -0.00426276 -0.05741813 -0.0048295623 2.8423988E-4 0.029835964 -7.8815775E-4 -0.004014574 0.015696079 -0.040300015 -0.038502347 0.043788034 0.0068888343 -0.013046526 0.015843648 0.03809988 0.0029027683 0.02067321 0.07303372 -0.019908529 0.0147435805 -0.0077407155 -0.013965485 -0.028574912 0.026978472 -0.014877736 0.012818464 -0.023409963 -0.038153544 0.031043354 -0.060852487 0.047893163 0.029513992 0.011181778 0.03364595 0.04220501 -0.021209829 -0.013884992 0.001418684 4.1105782E-4 -0.0018546862 0.047329713 -0.008941398 -0.00949814 0.0042795287 -0.026482102 -0.070565276 -0.02332947 -0.053983774 -0.0015067229 -0.0060268915 0.0076132687 -0.022309896 0.0060000606 0.013509359 0.022725774 8.9883525E-4 -0.009478017 -0.025355203 -0.018030366 -0.054332577 -0.060745165 -0.050361603 0.010282943 -0.024349043 -0.03235807 0.045880843 0.013952069 -0.011054331 -0.030748215 -0.035470452 0.013898407 0.0036490026 0.03834136 -0.014314286 0.02972864 -5.638682E-4 -0.041104943 -0.02530154 -0.024429537 0.030426243 0.06428684 -0.022846514 -0.013408744 -0.008418196 0.016836392 0.0109067615 -0.07893652 -0.046202812 0.032036096 -0.05076407 -0.006573571 -0.0034293248 0.014609426 -0.038475513 -0.017373009 -0.009571925 2.6555781E-5 -0.017641319 -0.020592717 -0.052856877 0.007143728 0.04641746 -0.0039038963 -0.027407767 0.012852002 -0.008062686 0.0014824073 0.040273186 -0.03335081 0.0540911 0.036677845 0.0097530335 0.0017507164 -0.053286172 -0.0029430147 -0.021035427 0.011175071 0.027421182 -0.009558509 -0.036892492 0.0724971 -0.024442952 -0.08891761 -0.03887798 -0.023758763 0.016031465 0.032250743 0.071745835 -0.012422708 -0.013730714 -0.02451003 0.00547015 -0.024335628 0.027582169 0.023946581 -0.03780474 -0.010859808 -0.0035618022 0.015132629 0.027877308 -0.025623512 0.013167266 -0.03149948 -0.04016586 0.008445026 -0.01471675 -0.0022101956 -9.407585E-4 -0.023248978 0.033458136 -0.017882796 -0.00967254 0.015991218 0.013113604 -0.043895356 0.008277333 0.045585703 0.0082236715 0.006684249 0.029970119 0.0042191595 -0.03217025 -0.001222483 0.007633392 0.012805048 0.044163667 0.01855357 -0.0058088903 -0.005282334 0.047624853 0.023020914 -0.04512958 0.027273612 -0.0013474143 -0.05049576 -0.008364534 0.008954814 0.03093603 -0.02094152 0.05347399 0.04987865 -0.0011704981 -0.021813523 0.05586194 -0.017453503 0.011731812 0.015239953 0.008740166 -0.014233794 0.026535762 0.0014245532 0.017708397 0.07534117 0.034907006 0.017238855 0.0029178606 -0.009109091 0.03783157 -0.0024298737 -0.021397645 -0.001357476 -0.003075492 -3.2532468E-4 -0.0055070426 -0.003152631 0.007096774 0.0079821935 0.05390328 -0.0042795287 -0.0202305 -0.0375096 0.016930299 -0.02822611 -0.047410205 0.005922922 -0.015803402 -0.0042594057 -0.001038859 -0.03869016 -0.03088237 0.021209829 -0.0076400996 0.020391487 0.0052186106 -0.057847425 0.074106954 0.0014438379 -0.03624855 1.7922204E-5 -0.007036404 -0.007774254 0.04075614 0.055808276 -0.035121653 0.009873772 0.033431303 -0.048644427 0.04842978 0.096698575 0.024684431 -0.03179462 -0.017681565 0.031901944 -0.011322641 -0.0019754253 0.025771081 0.014824074 0.057793763 -0.026280869 0.056613203 0.038851146 -0.044136833 0.0038737115 -0.013059942 0.034987498 -0.030184766 -0.004108482 -0.006191231 0.045075916 0.05586194 -0.0335118 -0.007090066 -0.023906333 0.052830048 -0.015937556 0.01560217 -9.608817E-4 0.0015553539 0.029809132 0.052776385 -0.001125221 -0.021397645 0.019532897 0.022631867 3.7709996E-4 -0.014045977 0.011792182 -0.009343862 0.045907672 -0.001883194 -0.014944812 0.056398556 0.007217513 0.007512653 -0.0023175192 0.056183908 -0.009679248 0.022336727 0.044378314 0.0079084085 0.061335444 0.001137798 0.069116406 0.017077869 0.001785932 -0.04220501 -0.009404232 -0.052481245 -0.044673454 0.015937556 -0.03302884 0.06128178 0.0030671076 0.018674308 -0.061442766 -0.034263063 -0.011718397 -0.016447343 0.011644612 -0.03123117 0.06273065 -0.008941398 -0.039360933 -0.035631437 0.017212024 -0.05108604 -0.007573022 0.036785167 0.016796146 -0.059296295 -0.011067747 -0.02852125 -0.031338494 0.021692785 -0.008787121 0.011416549 -0.013871577 0.024751507 0.003518202 0.019760959 -0.0030855539 -0.007230928 -0.010148789 -0.032841023 0.027877308 -0.007626684 0.050066464 0.006358924 -0.06466247 -0.043627046 0.010282943 0.062516004 -0.0027367522 0.02094152 -0.016447343 0.036972985 0.0123288 0.025838159 0.052266598 -0.007673638 -0.012657478 -0.018164521 -0.055808276 -0.03410208 0.038448684 -0.016621744 0.012134275 0.016568081 0.034611866 -0.033967923 0.015615585 -0.0070766504 -0.004316421 -0.011953167 -0.00802244 -0.015682662 0.0045880843 -0.011517165 -0.020485394 0.0040749433 0.05020062 0.01884871 0.012013537 -0.028279772 0.011631196 -0.004296298 0.023074577 -0.03450454 -0.015722908 -0.03388743 -0.038448684 -0.0037227878 0.03394109 -0.033967923 0.0036825414 0.0035114943 0.029192021 7.2946516E-4 -0.017855966 -0.033565458 0.014381364 0.06895542 -0.038824316 -0.0030771692 -0.011456795 -0.008881029 -0.019921945 -0.0099207265 -0.023155069 -0.001333999 -0.006436063 0.01265077 0.034746017 0.01660833 0.020606132 -0.030077443 0.026468685 0.028655404 -0.02822611 0.018808464 -0.028977375 0.029218853 -0.014730166 -0.026039392 -0.050388437 0.03353863 0.04598817 0.026388193 -0.04483444 0.0290847 -0.01621928 6.7370717E-4 -0.022524543 -0.004400268 -0.026589425 0.0084852725 -0.0109403 -0.0037529725 -0.019103603 -0.0023695042 -0.05390328 -0.0077541308 -0.010249405 -0.018030366 -0.009853649 0.02320873 -0.019251173 0.028628573 0.012724555 -0.018687723 -0.013777669 0.029594485 0.0066808946 0.018030366 0.04311726 -0.03147265 -0.011684858 -0.012234892 0.0052487953 -0.07185315 -0.0023393193 -0.05291054 -0.003102323 -0.0083913645 0.030855538 0.024496615 0.01144338 -0.031258002 -0.0024114274 -0.072014146 -0.02212208 0.026106467 0.0036121102 0.008364534 -0.04429782 0.017923042 0.03324349 0.040273186 0.046444293 0.014622842 -0.03149948 0.009243246 0.012053783 -0.04875175 0.015333861 -0.028896881 -0.04759802 0.012603817 -0.010490883 -0.033726446 -0.031633634 0.009598755 0.037375446 -0.06342825 -0.022658696 -0.026696747 0.0478395 0.028091954 -0.0057787057 -0.00426276 0.025824744 -0.010276236 0.006818403 0.03270687 0.061979383 0.018942617 0.026495516 -0.04547838 -0.007988901 -0.036436364 0.08151228 0.0067949262 0.018473076 -0.0026344592 -0.0217062 -0.010356728 0.0043398985 0.020659795 0.020109762 -0.052561738 0.007190682 -0.007438868 4.2761752E-4 -0.0850003 0.0050006094 -0.0049268245 -0.023557533 -0.019801207 -0.0014958228 0.03149948 -0.020445148 0.0035014327 -0.0356851 0.011798889 0.035443623 0.012852002 -0.013274589 -0.018634062 0.043492895 0.032492224 0.022846514 -0.02173303 -0.0043398985 -0.05494969 -0.0059061525 0.009618878 -0.009169461 0.06493078 0.0049268245 0.039012134 -0.007774254 -0.01315385 0.015763156 -0.06557473 -0.048483443 -5.299103E-4 4.33906E-4 0.023517286 0.010879931 -0.026656501 -0.019895114 -0.006137569 -0.03745594 -0.029353008 0.013569729 0.011181778 -0.001982133 0.107752904 0.04700774 0.008015732 -0.022055002 -0.06986767 0.035711933 0.022189157 -0.03300201 -0.019036526 0.012878833 -0.0139252385 -0.023959996 0.079634115 0.0098268185 -0.027474845 -0.055164337 0.016594913 -0.019278003 0.029513992 -0.0052420874 0.038260866 0.022403803 0.004500884 0.023839258 -0.0031844927 0.023718517 -0.031714126 -0.014636258 -0.0014119763 0.029916456 -0.01577657 -0.016326604 0.012053783 0.026817488 0.0070296964 -0.05972559 -0.036329042 0.026025975 -0.082263544 -0.0279578 0.013361789 0.024925908 0.04510275 -0.0040715896 0.028172448 -0.025288126 0.059832912 0.045290563 0.040917125 -0.031016523 -0.0013775992 -0.009310323 0.001955302 0.115265556 -0.017855966 -0.04247332 0.02347704 -0.035604607 0.07367766 -0.028279772 0.010430513 0.020539057 -0.04368071 0.011027501 0.019895114 -0.03262638 0.0088206595 3.9240194E-4 0.017963288 0.002003933 0.0064226473 -0.016541252 0.00426276 -2.3770503E-4 -0.011658027 -0.0043130675 0.0033639243 -0.00293463 -0.0147435805 -0.01120861 -0.010859808 0.01855357 0.0033656014 0.023101406 -0.043922186 0.010484175 0.032250743 0.0021531798 0.013804499 0.017762057 -0.0022940421 0.023383131 0.047061402 -0.003254924 0.014072808 0.0011218671 -0.009934141 0.013207512 -0.014019147 -0.02261845 -0.017708397 0.026830902 -0.016594913 -0.0033773398 -0.04928837 -0.028118785 -0.035819255 0.0012769833 -0.0342094 0.002465089 0.061120797 -0.020015853 0.0141667165 0.022578204 -0.030721383 0.040541492 0.006204646 0.008143179 -0.013489236 -0.0075663147 -0.008753582 0.004957009 0.0419367 -0.006110738 -0.01070553 0.042097688 0.034638695 0.11472894 -0.011919629 0.04005854 -0.027769985 -0.014528934 -0.02067321 0.0023057808 -0.041990362 -0.03895847 0.071745835 0.03061406 -9.935818E-4 -0.017466918 0.04365388 0.0046786387 -0.030184766 0.03694615 -0.02559668 0.0695457 0.027005304 -0.009759741 -0.052078784 0.03388743 0.008237087 0.0062147076 0.0039038963 0.018392583 0.035926577 0.015025306 -0.0045545455 -0.012483077 0.008310872 0.0040179277 -0.010926885 0.0058055366 -0.0060939686 -0.005590889 -0.028306602 -0.02377218 -0.009303615 -0.058115736 -0.015400938 -0.025180802 0.013817915 -0.008639551 0.02320873 -0.06986767 -4.8337548E-4 0.014448441 -0.030855538 0.004222513 0.028977375 -0.031982437 0.03305567 0.017077869 0.054600887 0.0019653635 0.043009937 -0.018982863 0.043519724 0.029889625 -0.010933593 0.010504298 -0.033726446 0.0075864377 0.0058357213 -0.012322092 0.06965302 -0.014327702 0.010168912 -0.03453137 -0.048000485 -0.007653515 0.04070248 0.015696079 0.017587656 0.011966582 0.010873224 -0.05827672 -0.01734618 -0.009102384 -0.014408194 0.0010044819 0.0076602227 0.027287029 0.03957558 0.021062259 0.010517714 -0.02471126 0.08231721 0.053071525 -0.0013633452 -0.01592414 -0.04131959 0.014032562 -0.035550945 0.03147265 -0.017641319 -5.18591E-4 -0.04875175 -0.03093603 -0.0014639611 -0.020887857 -0.013764253 -0.08033172 -0.023409963 0.0053997193 -0.14016463 -0.01949265 -0.048027314 -0.005798829 0.046229646 0.026374778 -0.028655404 -0.026924811 0.034021586 0.025234465 -0.009223123 -0.0021951033 -0.017279102 0.015857063 0.07399963 0.0077340077 0.0017373009 0.007834624 0.0055405814 -0.012825171 0.0570425 -0.014072808 0.027367521 -0.022940421 0.008163302 -0.013247758 -0.0064159394 0.014555764 -0.037482772 0.0077071767 -0.056076586 0.053581312 0.059242632 3.047823E-4 -0.05288371 0.0017339471 -0.0077943774 0.018956034 -0.007190682 0.011175071 0.004765839 0.040970787 -0.040621985 0.054037437 0.07421428 -0.023020914 </span>
</code></pre>
<p>怎样知道这个嵌入模型转换的向量值准不准呢，做一个小测试：查询list中的每个话题和“体育赛事”这个话题的相似度，并将模型计算的结果进行欧氏距离判断，看看是不是话题越相似，距离越短。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {

    <span class="hljs-type">float</span>[] embed1 = embeddingModel.embed(<span class="hljs-string">"体育赛事"</span>);
    
    List&lt;String&gt; list = Arrays.asList(
        <span class="hljs-string">"中国河北发生滦河第一号洪水"</span>,
        <span class="hljs-string">"菲律宾和中国就南海问题进行交涉"</span>,
        <span class="hljs-string">"武大靖被韩国人在ins上谩骂"</span>,
        <span class="hljs-string">"日本政府决定将核污染水进行排海"</span>,
        <span class="hljs-string">"中华人民共和国全运会在天津开幕"</span>,
        <span class="hljs-string">"在中国的调节下，沙特和伊朗和解"</span>,
        <span class="hljs-string">"谷爱凌在2022北京冬奥会上获得滑雪冠军"</span>,
        <span class="hljs-string">"缅甸曼德勒发生8.0级地震"</span>,
        <span class="hljs-string">"无法忍受北约东扩，俄罗斯进攻乌克兰"</span>,
        <span class="hljs-string">"湘潭大学周立人因投毒被判处死刑"</span>,
        <span class="hljs-string">"全红婵在东京奥运会获得跳水金牌"</span>
    );

    <span class="hljs-keyword">for</span> (String s : list) {
        <span class="hljs-type">float</span>[] embed2 = embeddingModel.embed(s);
        System.out.println(s +<span class="hljs-string">"="</span> +euclideanDistance(embed2, embed1));
    }
}


<span class="hljs-comment">/**
 * 计算欧氏距离 (Euclidean Distance)
 * <span class="hljs-doctag">@param</span> vector1 第一个向量
 * <span class="hljs-doctag">@param</span> vector2 第二个向量
 * <span class="hljs-doctag">@return</span> 欧氏距离
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">euclideanDistance</span><span class="hljs-params">(<span class="hljs-type">float</span>[] vector1, <span class="hljs-type">float</span>[] vector2)</span> {
    <span class="hljs-keyword">if</span> (vector1 == <span class="hljs-literal">null</span> || vector2 == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"输入向量不能为null"</span>);
    }
    <span class="hljs-keyword">if</span> (vector1.length != vector2.length) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"向量维度必须相同"</span>);
    }
    <span class="hljs-keyword">if</span> (vector1.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"向量不能为空"</span>);
    }

    <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vector1.length; i++) {
        <span class="hljs-type">double</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> vector1[i] - vector2[i];
        sum += diff * diff;
    }
    <span class="hljs-keyword">return</span> Math.sqrt(sum);
}
</code></pre>
<p>得到结果显示，“全红婵在东京奥运会获得跳水金牌”，“武大靖被韩国人在ins上谩骂”，“谷爱凌在北京冬奥会上获得滑雪冠军”，“中华人民共和国全运会在天津开幕”和关键词的距离都是1.0，1.1左右，小于其他的1.2！</p>
<pre><code class="hljs language-css" lang="css">中国河北发生滦河第一号洪水=<span class="hljs-number">1.2565409585119849</span>
菲律宾和中国就南海问题进行交涉=<span class="hljs-number">1.2780262570947603</span>
武大靖被韩国人在<span class="hljs-selector-tag">ins</span>上谩骂=<span class="hljs-number">1.1504923215307303</span>
日本政府决定将核污染水进行排海=<span class="hljs-number">1.2980210701931219</span>
中华人民共和国全运会在天津开幕=<span class="hljs-number">1.0548370809772176</span>
在中国的调节下，沙特和伊朗和解=<span class="hljs-number">1.2655944458999424</span>
谷爱凌在<span class="hljs-number">2022</span>北京冬奥会上获得滑雪冠军=<span class="hljs-number">1.1482314969126597</span>
缅甸曼德勒发生<span class="hljs-number">8.0</span>级地震=<span class="hljs-number">1.2719576699963044</span>
无法忍受北约东扩，俄罗斯进攻乌克兰=<span class="hljs-number">1.273157362706503</span>
湘潭大学周立人因投毒被判处死刑=<span class="hljs-number">1.2694025438988223</span>
全红婵在东京奥运会获得跳水金牌=<span class="hljs-number">1.1600613375770383</span>
</code></pre>
<h2 data-id="heading-3">4.向量数据库</h2>
<p>之前提到，如果实时的数据是海量的，不能将内容整个全部发送大模型，而且Token的限制也不允许这样做，我们需要检索出和问题相关的片段然后拆分出来发送给大模型，而且是通过将文本转换成向量并根据向量相似度来进行匹配，这样，海量数据的储存和检索就需要向量数据库来完成。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Frag%2Fvdb.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/rag/vdb.png" ref="nofollow noopener noreferrer"><img src="https://blog.liuzijian.com/img/spring_ai/rag/vdb.png" alt="" loading="lazy"/></a></p>
<p>Spring AI支持的向量数据库有很多，且对操作向量数据库制定了统一的接口标准<code>org.springframework.ai.vectorstore.VectorStore</code>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring-ai%2Freference%2Fapi%2Fvectordbs.html%23_vectorstore_implementations" target="_blank" title="https://docs.spring.io/spring-ai/reference/api/vectordbs.html#_vectorstore_implementations" ref="nofollow noopener noreferrer">docs.spring.io/spring-ai/r…</a>），这里就以支持向量的Redis (Redis Stack)为例</p>
<p>pom.xml</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-vector-store-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>新增向量数据库的配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">ai:</span>
    <span class="hljs-attr">vectorstore:</span>
      <span class="hljs-attr">redis:</span>
        <span class="hljs-attr">initialize-schema:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#不自动初始化索引结构，因为可能不能满足我们的查询要求</span>
        <span class="hljs-attr">index-name:</span> <span class="hljs-string">custom-index</span> <span class="hljs-comment">#向量库索引名</span>
        <span class="hljs-attr">prefix:</span> <span class="hljs-string">"doc:"</span> <span class="hljs-comment">#key前缀</span>
  <span class="hljs-attr">data:</span>
    <span class="hljs-attr">redis:</span>
      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.228</span><span class="hljs-number">.104</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>
      <span class="hljs-attr">database:</span> <span class="hljs-number">0</span>
</code></pre>
<p>用Docker启动一个Redis Stack实例用于测试</p>
<pre><code class="hljs language-arduino" lang="arduino">docker run -d --name redis-stack -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -p <span class="hljs-number">8001</span>:<span class="hljs-number">8001</span> redis/redis-stack:latest
</code></pre>
<p>手动设置redis-stack的custom-index索引结构，主要是为了将user_id设置为TAG，才能在Spring AI中进行<code>==</code>查询，当前版本Spring AI自动生成的索引是<code>TEXT</code>型</p>
<pre><code class="hljs language-vbnet" lang="vbnet">FT.CREATE <span class="hljs-keyword">custom</span>-index <span class="hljs-keyword">ON</span> JSON PREFIX <span class="hljs-number">1</span> <span class="hljs-string">"doc:"</span> SCHEMA $.user_id <span class="hljs-keyword">AS</span> user_id TAG $.content <span class="hljs-keyword">AS</span> content <span class="hljs-keyword">TEXT</span> $.embedding <span class="hljs-keyword">AS</span> embedding VECTOR HNSW <span class="hljs-number">6</span> TYPE FLOAT32 <span class="hljs-keyword">DIM</span> <span class="hljs-number">1024</span> DISTANCE_METRIC COSINE
</code></pre>
<p>新建测试类，可以直接注入并使用VectorStore操作向量数据库</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> org.example.test;

<span class="hljs-keyword">import</span> jakarta.annotation.Resource;
<span class="hljs-keyword">import</span> org.example.Main;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.ai.document.Document;
<span class="hljs-keyword">import</span> org.springframework.ai.vectorstore.VectorStore;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-meta">@SpringBootTest(classes = Main.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorStoreTest</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> VectorStore vectorStore;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Document</span>(<span class="hljs-string">"1"</span>, <span class="hljs-string">"一段测试信息"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());
        vectorStore.add(Arrays.asList(document));

    }
}
</code></pre>
<p>打开8001端口的redis-stack管理页面，可以看到文本数据及转换后的向量数据保存到了redis-stack中</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Frag%2Ftest1.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/rag/test1.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64325d018eef451cb25d32117d70c3ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhbmdlbHpq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763774699&amp;x-signature=PuaShPCebUsOn%2Bi1edUmz8wDYjI%3D" alt="" loading="lazy"/></a></p>
<p>还可以将PDF文档向量化，保存进向量数据库，需要借助spring-ai-pdf-document-reader工具，这里以我的本科毕业答辩PPT转成PDF为例测试</p>
<pre><code class="hljs language-typescript" lang="typescript"> &lt;dependency&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-pdf-document-reader<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span>
&lt;/dependency&gt;

package org.<span class="hljs-property">example</span>.<span class="hljs-property">test</span>;

<span class="hljs-keyword">import</span> jakarta.<span class="hljs-property">annotation</span>.<span class="hljs-property">Resource</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">example</span>.<span class="hljs-property">Main</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">junit</span>.<span class="hljs-property">jupiter</span>.<span class="hljs-property">api</span>.<span class="hljs-property">Test</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">document</span>.<span class="hljs-property">Document</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">reader</span>.<span class="hljs-property">ExtractedTextFormatter</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">reader</span>.<span class="hljs-property">pdf</span>.<span class="hljs-property">PagePdfDocumentReader</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">reader</span>.<span class="hljs-property">pdf</span>.<span class="hljs-property">config</span>.<span class="hljs-property">PdfDocumentReaderConfig</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">vectorstore</span>.<span class="hljs-property">VectorStore</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">test</span>.<span class="hljs-property">context</span>.<span class="hljs-property">SpringBootTest</span>;

<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;

<span class="hljs-meta">@SpringBootTest</span>(classes = <span class="hljs-title class_">Main</span>.<span class="hljs-property">class</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorStoreTest</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">VectorStore</span> vectorStore;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"/>) {

        <span class="hljs-title class_">PagePdfDocumentReader</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PagePdfDocumentReader</span>(
                <span class="hljs-string">"file:///C:/Users/lzj20/Desktop/答辩.pdf"</span>,
                <span class="hljs-title class_">PdfDocumentReaderConfig</span>.<span class="hljs-title function_">builder</span>()
                        .<span class="hljs-title function_">withPageExtractedTextFormatter</span>(<span class="hljs-title class_">ExtractedTextFormatter</span>.<span class="hljs-title function_">defaults</span>())
                        .<span class="hljs-title function_">withPagesPerDocument</span>(<span class="hljs-number">1</span>)
                        .<span class="hljs-title function_">build</span>()
        );

        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Document</span>&gt; documents = reader.<span class="hljs-title function_">read</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Document</span> <span class="hljs-variable language_">document</span> : documents) {
            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getMetadata</span>().<span class="hljs-title function_">put</span>(<span class="hljs-string">"user_id"</span>, <span class="hljs-string">"001"</span>);
        }

        vectorStore.<span class="hljs-title function_">add</span>(documents);
    }
}
</code></pre>
<p>数据保存成功</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Frag%2Ftest2.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/rag/test2.png" ref="nofollow noopener noreferrer"><img src="https://blog.liuzijian.com/img/spring_ai/rag/test2.png" alt="" loading="lazy"/></a></p>
<p>还可以搜索相关性高的内容</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Test</span>
public void search() {
    SearchRequest request = SearchRequest<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.query</span>("服务器配置")
            <span class="hljs-selector-class">.topK</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//相似度最高的前几名</span>
            <span class="hljs-comment">//.filterExpression("user_id == '001'") //可以根据metadata中的内容过滤</span>
            <span class="hljs-selector-class">.build</span>();

    List&lt;Document&gt; documents = vectorStore<span class="hljs-selector-class">.similaritySearch</span>(request);
    for (Document document : documents) {
        System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(document.getText());
        System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(document.getScore());
    }
}
</code></pre>
<h2 data-id="heading-4">5.使用知识库增强对话功能（RAG）</h2>
<p>最后一步，利用保存了我们自己上传了文档的向量数据库，作为大模型对话的知识库，对大模型尚未了解的内容进行补充，首先先将之前用过的对话模型DeepSeek的依赖和配置添加进去</p>
<pre><code class="hljs language-xml" lang="xml">spring:
  ai:
    deepseek:
      base-url: https://api.deepseek.com
      api-key: ${DEEPSEEK_KEY}

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-model-deepseek<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>再添加Spring AI对RAG功能支持的advisor</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-advisors-vector-store<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>配置一个支持知识库自动检索的ChatClient，并关联向量数据库vectorStore</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> org.example;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.advisor.vectorstore.QuestionAnswerAdvisor;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.memory.ChatMemory;
<span class="hljs-keyword">import</span> org.springframework.ai.deepseek.DeepSeekChatModel;

<span class="hljs-keyword">import</span> org.springframework.ai.vectorstore.SearchRequest;
<span class="hljs-keyword">import</span> org.springframework.ai.vectorstore.VectorStore;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ChatClient ragClient(DeepSeekChatModel model, ChatMemory chatMemory, VectorStore vectorStore) {
        <span class="hljs-keyword">return</span> ChatClient.builder(model)
                .defaultAdvisors(
                        SimpleLoggerAdvisor.builder().build(),
                        MessageChatMemoryAdvisor.builder(chatMemory).build(),
                        QuestionAnswerAdvisor.builder(vectorStore)
                                .searchRequest(
                                        SearchRequest.builder()
                                        .similarityThreshold(<span class="hljs-number">0.6</span>)
                                        .topK(<span class="hljs-number">2</span>)
                                        .build()
                                ).build()
                    ).build();
    }

}
</code></pre>
<p>controller中使用ragClient，并使用<code>advisor.param(QuestionAnswerAdvisor.FILTER_EXPRESSION, "user_id == '001'")</code>区分不同用户的文档，实际项目中，用户ID应该从后端登录信息获得</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> org.example.controller;

<span class="hljs-keyword">import</span> jakarta.<span class="hljs-keyword">annotation</span>.Resource;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.advisor.vectorstore.QuestionAnswerAdvisor;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.memory.ChatMemory;

<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;
<span class="hljs-keyword">import</span> reactor.core.publisher.Flux;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping(<span class="hljs-string">"ai"</span>)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatController</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> ChatClient ragClient;

    <span class="hljs-meta">@GetMapping(value = <span class="hljs-string">"rag-stream"</span>, produces = <span class="hljs-string">"text/html;charset=utf-8"</span>)</span>
    <span class="hljs-keyword">public</span> Flux&lt;String&gt; rag(String msg, String chatId) {

        <span class="hljs-keyword">return</span> ragClient.prompt()
                .user(msg)
                .advisors(advisor -&gt; advisor.param(ChatMemory.CONVERSATION_ID, chatId))
                .advisors(advisor -&gt; advisor.param(QuestionAnswerAdvisor.FILTER_EXPRESSION, <span class="hljs-string">"user_id == '001'"</span>))
                .stream()
                .content();

    }
}
</code></pre>
<p>通过测试，可以看到大模型回答它不知道的问题时，已经有检索知识库了</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.liuzijian.com%2Fimg%2Fspring_ai%2Frag%2Ftest3.png" target="_blank" title="https://blog.liuzijian.com/img/spring_ai/rag/test3.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80a2967241b44fdba82368b79ab1eecc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgY2hhbmdlbHpq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763774699&amp;x-signature=xAU2XPk5BakirZCtLu%2FzytjGaCc%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-5">参考</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fjava2ai.com%2Fdocs%2F1.0.0-M6.1%2Fconcepts%2F%3Fspm%3D4347728f.33449ac1.0.0.7b7d556bo6eN0q" target="_blank" title="https://java2ai.com/docs/1.0.0-M6.1/concepts/?spm=4347728f.33449ac1.0.0.7b7d556bo6eN0q" ref="nofollow noopener noreferrer">java2ai.com/docs/1.0.0-…</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 闭包陷阱详解]]></title>    <link>https://juejin.cn/post/7572403510467313707</link>    <guid>https://juejin.cn/post/7572403510467313707</guid>    <pubDate>2025-11-14T17:09:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572403510467313707" data-draft-id="7572396000545161279" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 闭包陷阱详解"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-14T17:09:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一碗下酒菜"/> <meta itemprop="url" content="https://juejin.cn/user/1169536104549534"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 闭包陷阱详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1169536104549534/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一碗下酒菜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T17:09:41.000Z" title="Fri Nov 14 2025 17:09:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">React 闭包陷阱详解</h2>
<h3 data-id="heading-1">什么是闭包陷阱？</h3>
<p>React 闭包陷阱是指函数组件中的回调函数（特别是事件处理函数或副作用函数）捕获了过时的状态值，而不是最新的状态值。这是因为这些函数在创建时形成了一个闭包，捕获了当时的变量值。</p>
<h3 data-id="heading-2">什么是闭包？</h3>
<h4 data-id="heading-3">1. 存在外部函数和内部函数</h4>
<ul>
<li>必须有一个外部函数（enclosing function）</li>
<li>外部函数内部定义了内部函数（inner function）</li>
</ul>
<h4 data-id="heading-4">2. 内部函数引用了外部函数的变量</h4>
<ul>
<li>内部函数访问了外部函数作用域中的变量（自由变量）</li>
</ul>
<h4 data-id="heading-5">3. 内部函数在外部函数作用域外被调用</h4>
<ul>
<li>内部函数被返回或在外部函数外部被执行</li>
</ul>
<h3 data-id="heading-6">触发条件</h3>
<p>闭包陷阱通常在以下情况下发生：</p>
<ol>
<li><strong>在 useEffect 中使用状态但依赖项数组为空</strong></li>
<li><strong>在异步操作中使用状态</strong></li>
<li><strong>在事件处理函数中使用状态，但函数在组件挂载时创建</strong></li>
</ol>
<h3 data-id="heading-7">实际案例</h3>
<h4 data-id="heading-8">案例 1：useEffect 中的闭包陷阱</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 问题：这里的 count 始终是初始值 0</span>
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 总是输出 0</span>
    }, <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, []); <span class="hljs-comment">// 空依赖数组</span>

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">useEffect</span>(() =&gt; {
  const timer = <span class="hljs-built_in">setInterval</span>(() =&gt; {
    console<span class="hljs-selector-class">.log</span>(count); <span class="hljs-comment">// 现在会输出最新的 count 值</span>
  }, <span class="hljs-number">1000</span>);
  
  return () =&gt; <span class="hljs-built_in">clearInterval</span>(timer);
}, <span class="hljs-selector-attr">[count]</span>); <span class="hljs-comment">// 添加 count 到依赖数组</span>
</code></pre>
<h4 data-id="heading-9">案例 2：异步操作中的闭包陷阱</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsyncCounter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 问题：这里的 count 是点击时的值，不是最新的值</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Current count:'</span>, count); <span class="hljs-comment">// 可能不是最新的值</span>
    }, <span class="hljs-number">3000</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Increment with delay<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsyncCounter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-comment">// 使用函数式更新确保获取最新状态</span>
    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> newCount = prevCount + <span class="hljs-number">1</span>;
      
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Current count:'</span>, newCount); <span class="hljs-comment">// 确保是最新值</span>
      }, <span class="hljs-number">3000</span>);
      
      <span class="hljs-keyword">return</span> newCount;
    });
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Increment with delay<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h4 data-id="heading-10">案例 3：事件监听器中的闭包陷阱</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">EventListenerExample</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleKeyPress</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-comment">// 问题：这里的 value 始终是空字符串</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Current value:'</span>, value); <span class="hljs-comment">// 总是空字符串</span>
    };

    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keypress'</span>, handleKeyPress);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'keypress'</span>, handleKeyPress);
    };
  }, []); <span class="hljs-comment">// 空依赖数组</span>

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> 
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setValue(e.target.value)} 
        placeholder="Type something"
      /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-ini" lang="ini">function EventListenerExample() {
  const <span class="hljs-section">[value, setValue]</span> = useState('')<span class="hljs-comment">;</span>
  const <span class="hljs-attr">valueRef</span> = useRef(value)<span class="hljs-comment">;</span>

  // 保持 ref 与状态同步
  useEffect(() =&gt; {
    <span class="hljs-attr">valueRef.current</span> = value<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[value]</span>)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    const <span class="hljs-attr">handleKeyPress</span> = (event) =&gt; {
      // 通过 ref 获取最新值
      console.log('Current value:', valueRef.current)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>

    document.addEventListener('keypress', handleKeyPress)<span class="hljs-comment">;</span>
    
    return () =&gt; {
      document.removeEventListener('keypress', handleKeyPress)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[]</span>)<span class="hljs-comment">; // 依赖数组可以为空，因为我们使用 ref</span>

  return (
    &lt;div&gt;
      &lt;input 
        <span class="hljs-attr">value</span>={value} 
        <span class="hljs-attr">onChange</span>={(e) =&gt; setValue(e.target.value)} 
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Type something"</span>
    &lt;/div&gt;
  )<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-11">更复杂的案例：多个状态交互</h3>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">ComplexExample</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  const <span class="hljs-selector-attr">[text, setText]</span> = <span class="hljs-built_in">useState</span>('');

  const sendData = <span class="hljs-built_in">useCallback</span>(async () =&gt; {
    <span class="hljs-comment">// 问题：这里的 count 和 text 可能是过时的值</span>
    const response = await <span class="hljs-built_in">fetch</span>('/api/data', {
      method: 'POST',
      body: JSON.stringify({ count, text })
    });
    <span class="hljs-comment">// 处理响应...</span>
  }, <span class="hljs-selector-attr">[]</span>); <span class="hljs-comment">// 空依赖数组，函数不会更新</span>

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-comment">// 假设我们需要在特定条件下发送数据</span>
    if (count &gt; <span class="hljs-number">5</span>) {
      <span class="hljs-built_in">sendData</span>();
    }
  }, <span class="hljs-selector-attr">[count, sendData]</span>);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;input 
        value={text} 
        onChange={(e) =&gt; <span class="hljs-built_in">setText</span>(e.target.value)} 
        placeholder="Enter text"
      /&gt;
      &lt;<span class="hljs-selector-tag">button</span> onClick={() =&gt; <span class="hljs-built_in">setCount</span>(count + <span class="hljs-number">1</span>)}&gt;Increment&lt;/<span class="hljs-selector-tag">button</span>&gt;
    &lt;/<span class="hljs-selector-tag">div</span>&gt;
  );
}
</code></pre>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">ComplexExample</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  const <span class="hljs-selector-attr">[text, setText]</span> = <span class="hljs-built_in">useState</span>('');

  <span class="hljs-comment">// 使用 ref 来存储最新状态</span>
  const stateRef = <span class="hljs-built_in">useRef</span>({ count, text });

  <span class="hljs-comment">// 保持 ref 与状态同步</span>
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    stateRef<span class="hljs-selector-class">.current</span> = { count, text };
  }, <span class="hljs-selector-attr">[count, text]</span>);

  const sendData = <span class="hljs-built_in">useCallback</span>(async () =&gt; {
    <span class="hljs-comment">// 通过 ref 获取最新状态</span>
    const { count, text } = stateRef<span class="hljs-selector-class">.current</span>;
    
    const response = await <span class="hljs-built_in">fetch</span>('/api/data', {
      method: 'POST',
      body: JSON.stringify({ count, text })
    });
    <span class="hljs-comment">// 处理响应...</span>
  }, <span class="hljs-selector-attr">[]</span>); <span class="hljs-comment">// 依赖数组可以为空</span>

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    if (count &gt; <span class="hljs-number">5</span>) {
      <span class="hljs-built_in">sendData</span>();
    }
  }, <span class="hljs-selector-attr">[count, sendData]</span>);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;input 
        value={text} 
        onChange={(e) =&gt; <span class="hljs-built_in">setText</span>(e.target.value)} 
        placeholder="Enter text"
      /&gt;
      &lt;<span class="hljs-selector-tag">button</span> onClick={() =&gt; <span class="hljs-built_in">setCount</span>(count + <span class="hljs-number">1</span>)}&gt;Increment&lt;/<span class="hljs-selector-tag">button</span>&gt;
    &lt;/<span class="hljs-selector-tag">div</span>&gt;
  );
}
</code></pre>
<h3 data-id="heading-12">最佳实践和解决方案总结</h3>
<ol>
<li>
<p><strong>正确使用依赖数组</strong>：确保 useEffect、useCallback、useMemo 的依赖数组包含所有使用的外部变量</p>
</li>
<li>
<p><strong>使用函数式更新</strong>：对于基于前一个状态的计算，使用函数式更新</p>
<pre><code class="hljs language-ini" lang="ini">setCount(<span class="hljs-attr">prevCount</span> =&gt; prevCount + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
</code></pre>
</li>
<li>
<p><strong>使用 useRef 存储可变值</strong>：对于需要在回调中访问但不想触发重新渲染的值，使用 useRef</p>
</li>
<li>
<p><strong>使用 useCallback 的正确依赖</strong>：确保 useCallback 的依赖数组包含所有在回调中使用的变量</p>
</li>
<li>
<p><strong>使用自定义 Hook 封装逻辑</strong>：将复杂的状态逻辑封装到自定义 Hook 中</p>
</li>
</ol>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 自定义 Hook 处理闭包问题</span>
function <span class="hljs-built_in">useLatestRef</span>(value) {
  const ref = <span class="hljs-built_in">useRef</span>(value);
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    ref<span class="hljs-selector-class">.current</span> = value;
  });
  return ref;
}

<span class="hljs-comment">// 使用示例</span>
function <span class="hljs-built_in">MyComponent</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
  const countRef = <span class="hljs-built_in">useLatestRef</span>(count);

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const timer = <span class="hljs-built_in">setInterval</span>(() =&gt; {
      console<span class="hljs-selector-class">.log</span>('Latest count:', countRef.current);
    }, <span class="hljs-number">1000</span>);
    
    return () =&gt; <span class="hljs-built_in">clearInterval</span>(timer);
  }, <span class="hljs-selector-attr">[]</span>);

  return (
    &lt;button onClick={() =&gt; <span class="hljs-built_in">setCount</span>(count + <span class="hljs-number">1</span>)}&gt;
      Count: {count}
    &lt;/<span class="hljs-selector-tag">button</span>&gt;
  );
}
</code></pre>
<p>理解 React 闭包陷阱的关键是认识到函数组件每次渲染都会创建新的作用域，而闭包会捕获这些作用域中的变量值。通过正确的依赖管理和使用适当的 React API，可以有效地避免闭包陷阱。</p>
<h3 data-id="heading-13">useEffectEvent（实验性 API）</h3>
<p>React 团队正在开发一个名为 <code>useEffectEvent</code>的实验性 API，专门用于解决闭包陷阱问题。它允许你在 effect 中读取最新的 props 和 state，而无需将它们声明为依赖项。</p>
<pre><code class="hljs language-scss" lang="scss">import { useState, useEffect, experimental_useEffectEvent as useEffectEvent } from 'react';

function <span class="hljs-built_in">ChatRoom</span>({ roomId }) {
  const <span class="hljs-selector-attr">[message, setMessage]</span> = <span class="hljs-built_in">useState</span>('');

  <span class="hljs-comment">// 使用 useEffectEvent 定义事件函数</span>
  const onConnected = <span class="hljs-built_in">useEffectEvent</span>(() =&gt; {
    <span class="hljs-built_in">showNotification</span>('Connected!', theme);
  });

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const connection = <span class="hljs-built_in">createConnection</span>(serverUrl, roomId);
    connection<span class="hljs-selector-class">.connect</span>();
    connection<span class="hljs-selector-class">.on</span>('connected', onConnected); <span class="hljs-comment">// 这里可以安全地使用最新的 theme</span>
    return () =&gt; connection<span class="hljs-selector-class">.disconnect</span>();
  }, <span class="hljs-selector-attr">[roomId]</span>); <span class="hljs-comment">// 不需要将 onConnected 或 theme 作为依赖</span>

  <span class="hljs-comment">// ... 其他代码</span>
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[ArkTs单元测试 UnitTest 指南]]></title>    <link>https://juejin.cn/post/7572385850636337158</link>    <guid>https://juejin.cn/post/7572385850636337158</guid>    <pubDate>2025-11-15T01:40:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572385850636337158" data-draft-id="7572397142365175850" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="ArkTs单元测试 UnitTest 指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-15T01:40:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="littleplayer"/> <meta itemprop="url" content="https://juejin.cn/user/1926000099198813"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            ArkTs单元测试 UnitTest 指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1926000099198813/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    littleplayer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T01:40:52.000Z" title="Sat Nov 15 2025 01:40:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>ArkTS 提供了完善的单元测试框架，支持对 HarmonyOS 应用进行单元测试。以下是完整的 ArkTS 单元测试指南：</p>
<h2 data-id="heading-0">1. 测试环境配置</h2>
<h3 data-id="heading-1">1.1 项目结构</h3>
<pre><code class="hljs language-css" lang="css">project/
├── <span class="hljs-attribute">src</span>/
│   └── <span class="hljs-selector-tag">main</span>/
│       └── ets/
│           └── ...
├── ohosTest/
│   └── <span class="hljs-attribute">src</span>/
│       └── test/
│           └── ets/
│               └── test/
│                   └── Example<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.ets</span>
│               └── TestAbility<span class="hljs-selector-class">.ts</span>
│           └── resources/
│       └── module<span class="hljs-selector-class">.json5</span>
</code></pre>
<h3 data-id="heading-2">1.2 module.json5 配置</h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-comment">// ohosTest/src/module.json5</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"test"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"feature"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"srcEntrance"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./ets/TestAbility.ts"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$string:TestAbility_desc"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"mainElement"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TestAbility"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"deviceTypes"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"phone"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"tablet"</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"deliveryWithInstall"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"installationFree"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"pages"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$profile:test_pages"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"abilities"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TestAbility"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"srcEntrance"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./ets/TestAbility.ts"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$string:TestAbility_desc"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"icon"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$media:icon"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"label"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$string:TestAbility_label"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"startWindowIcon"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$media:icon"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"startWindowBackground"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"$color:start_window_background"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"visible"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"skills"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"actions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
              <span class="hljs-string">"action.system.home"</span>
            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"entities"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
              <span class="hljs-string">"entity.system.home"</span>
            <span class="hljs-punctuation">]</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-3">2. 基础单元测试</h2>
<h3 data-id="heading-4">2.1 工具类测试</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main/ets/utils/MathUtil.ets</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtil</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> a + b;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> a - b;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> a * b;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">divide</span>(<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">if</span> (b === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Division by zero'</span>);
    }
    <span class="hljs-keyword">return</span> a / b;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isEven</span>(<span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Negative number'</span>);
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span> || n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> n * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);
  }
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/MathUtil.test.ets</span>
<span class="hljs-keyword">import</span> { describe, it, expect } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hypium'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MathUtil</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../src/main/ets/utils/MathUtil'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mathUtilTest</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">'MathUtil Tests'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_add_two_numbers'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">5</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_subtract_two_numbers'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">subtract</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">2</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_multiply_two_numbers'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">12</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_divide_two_numbers'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">5</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_throw_error_when_dividing_by_zero'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
        <span class="hljs-title function_">expect</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">assertFalse</span>(); <span class="hljs-comment">// 不应该执行到这里</span>
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-title function_">expect</span>(error.<span class="hljs-property">message</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Division by zero'</span>);
      }
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_detect_even_numbers'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">isEven</span>(<span class="hljs-number">4</span>)).<span class="hljs-title function_">assertTrue</span>();
      <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">isEven</span>(<span class="hljs-number">7</span>)).<span class="hljs-title function_">assertFalse</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_calculate_factorial'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>)).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">120</span>);
      <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">factorial</span>(<span class="hljs-number">0</span>)).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">1</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_throw_error_for_negative_factorial'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title class_">MathUtil</span>.<span class="hljs-title function_">factorial</span>(-<span class="hljs-number">1</span>);
        <span class="hljs-title function_">expect</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">assertFalse</span>();
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-title function_">expect</span>(error.<span class="hljs-property">message</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Negative number'</span>);
      }
    });
  });
}
</code></pre>
<h3 data-id="heading-5">2.2 业务逻辑测试</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main/ets/services/UserService.ets</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">users</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">User</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-title function_">addUser</span>(<span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">has</span>(user.<span class="hljs-property">id</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">set</span>(user.<span class="hljs-property">id</span>, user);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-title function_">getUser</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">User</span> | <span class="hljs-literal">undefined</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">get</span>(id);
  }

  <span class="hljs-title function_">deleteUser</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">delete</span>(id);
  }

  <span class="hljs-title function_">getAllUsers</span>(): <span class="hljs-title class_">User</span>[] {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">values</span>());
  }

  <span class="hljs-title function_">updateUser</span>(<span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">has</span>(user.<span class="hljs-property">id</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">set</span>(user.<span class="hljs-property">id</span>, user);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> id: <span class="hljs-built_in">string</span>,
    <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>,
    <span class="hljs-keyword">public</span> email: <span class="hljs-built_in">string</span>,
    <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span>
  </span>) {}
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/UserService.test.ets</span>
<span class="hljs-keyword">import</span> { describe, it, expect, beforeEach } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hypium'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span>, <span class="hljs-title class_">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../src/main/ets/services/UserService'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">userServiceTest</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">'UserService Tests'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">userService</span>: <span class="hljs-title class_">UserService</span>;

    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {
      userService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_add_user_successfully'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      <span class="hljs-keyword">const</span> result = userService.<span class="hljs-title function_">addUser</span>(user);
      
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertTrue</span>();
      <span class="hljs-title function_">expect</span>(userService.<span class="hljs-title function_">getUser</span>(<span class="hljs-string">'1'</span>)).<span class="hljs-title function_">assertEqual</span>(user);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_not_add_duplicate_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      userService.<span class="hljs-title function_">addUser</span>(user);
      <span class="hljs-keyword">const</span> result = userService.<span class="hljs-title function_">addUser</span>(user);
      
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertFalse</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_get_user_by_id'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      userService.<span class="hljs-title function_">addUser</span>(user);
      
      <span class="hljs-keyword">const</span> retrievedUser = userService.<span class="hljs-title function_">getUser</span>(<span class="hljs-string">'1'</span>);
      <span class="hljs-title function_">expect</span>(retrievedUser).<span class="hljs-title function_">assertEqual</span>(user);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_return_undefined_for_nonexistent_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> retrievedUser = userService.<span class="hljs-title function_">getUser</span>(<span class="hljs-string">'nonexistent'</span>);
      <span class="hljs-title function_">expect</span>(retrievedUser).<span class="hljs-title function_">assertUndefined</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_delete_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      userService.<span class="hljs-title function_">addUser</span>(user);
      
      <span class="hljs-keyword">const</span> deleteResult = userService.<span class="hljs-title function_">deleteUser</span>(<span class="hljs-string">'1'</span>);
      <span class="hljs-title function_">expect</span>(deleteResult).<span class="hljs-title function_">assertTrue</span>();
      <span class="hljs-title function_">expect</span>(userService.<span class="hljs-title function_">getUser</span>(<span class="hljs-string">'1'</span>)).<span class="hljs-title function_">assertUndefined</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_return_false_when_deleting_nonexistent_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> deleteResult = userService.<span class="hljs-title function_">deleteUser</span>(<span class="hljs-string">'nonexistent'</span>);
      <span class="hljs-title function_">expect</span>(deleteResult).<span class="hljs-title function_">assertFalse</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_get_all_users'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      <span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'2'</span>, <span class="hljs-string">'Jane Smith'</span>, <span class="hljs-string">'jane@example.com'</span>, <span class="hljs-number">25</span>);
      
      userService.<span class="hljs-title function_">addUser</span>(user1);
      userService.<span class="hljs-title function_">addUser</span>(user2);
      
      <span class="hljs-keyword">const</span> allUsers = userService.<span class="hljs-title function_">getAllUsers</span>();
      <span class="hljs-title function_">expect</span>(allUsers.<span class="hljs-property">length</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">2</span>);
      <span class="hljs-title function_">expect</span>(allUsers).<span class="hljs-title function_">assertContain</span>(user1);
      <span class="hljs-title function_">expect</span>(allUsers).<span class="hljs-title function_">assertContain</span>(user2);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_update_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      userService.<span class="hljs-title function_">addUser</span>(user);
      
      <span class="hljs-keyword">const</span> updatedUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Updated'</span>, <span class="hljs-string">'updated@example.com'</span>, <span class="hljs-number">31</span>);
      <span class="hljs-keyword">const</span> updateResult = userService.<span class="hljs-title function_">updateUser</span>(updatedUser);
      
      <span class="hljs-title function_">expect</span>(updateResult).<span class="hljs-title function_">assertTrue</span>();
      <span class="hljs-title function_">expect</span>(userService.<span class="hljs-title function_">getUser</span>(<span class="hljs-string">'1'</span>)).<span class="hljs-title function_">assertEqual</span>(updatedUser);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_return_false_when_updating_nonexistent_user'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'john@example.com'</span>, <span class="hljs-number">30</span>);
      <span class="hljs-keyword">const</span> updateResult = userService.<span class="hljs-title function_">updateUser</span>(user);
      
      <span class="hljs-title function_">expect</span>(updateResult).<span class="hljs-title function_">assertFalse</span>();
    });
  });
}
</code></pre>
<h2 data-id="heading-6">3. 异步测试</h2>
<h3 data-id="heading-7">3.1 异步服务测试</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main/ets/services/ApiService.ets</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'https://'</span>)) {
          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Data from <span class="hljs-subst">${url}</span>`</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Invalid URL'</span>));
        }
      }, <span class="hljs-number">100</span>);
    });
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">processUserData</span>(<span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">UserData</span>&gt; {
    <span class="hljs-comment">// 模拟 API 调用</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">resolve</span>({
          <span class="hljs-attr">id</span>: userId,
          <span class="hljs-attr">name</span>: <span class="hljs-string">`User <span class="hljs-subst">${userId}</span>`</span>,
          <span class="hljs-attr">score</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>
        });
      }, <span class="hljs-number">50</span>);
    });
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserData</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">score</span>: <span class="hljs-built_in">number</span>;
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/ApiService.test.ets</span>
<span class="hljs-keyword">import</span> { describe, it, expect } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hypium'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ApiService</span>, <span class="hljs-title class_">UserData</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../src/main/ets/services/ApiService'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">apiServiceTest</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">'ApiService Tests'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> apiService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiService</span>();

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_fetch_data_successfully'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> apiService.<span class="hljs-title function_">fetchData</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
      <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Data from https://api.example.com/data'</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_reject_invalid_url'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">await</span> apiService.<span class="hljs-title function_">fetchData</span>(<span class="hljs-string">'invalid-url'</span>);
        <span class="hljs-title function_">expect</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">assertFalse</span>(); <span class="hljs-comment">// 不应该执行到这里</span>
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-title function_">expect</span>(error.<span class="hljs-property">message</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Invalid URL'</span>);
      }
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_process_user_data'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">userData</span>: <span class="hljs-title class_">UserData</span> = <span class="hljs-keyword">await</span> apiService.<span class="hljs-title function_">processUserData</span>(<span class="hljs-string">'123'</span>);
      
      <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">id</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'123'</span>);
      <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">name</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'User 123'</span>);
      <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">score</span>).<span class="hljs-title function_">assertLarger</span>(<span class="hljs-number">0</span>);
      <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">score</span>).<span class="hljs-title function_">assertLess</span>(<span class="hljs-number">100</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_process_multiple_users'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> promises = [
        apiService.<span class="hljs-title function_">processUserData</span>(<span class="hljs-string">'1'</span>),
        apiService.<span class="hljs-title function_">processUserData</span>(<span class="hljs-string">'2'</span>),
        apiService.<span class="hljs-title function_">processUserData</span>(<span class="hljs-string">'3'</span>)
      ];
      
      <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
      
      <span class="hljs-title function_">expect</span>(results.<span class="hljs-property">length</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">3</span>);
      results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">userData, index</span>) =&gt;</span> {
        <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">id</span>).<span class="hljs-title function_">assertEqual</span>((index + <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>());
        <span class="hljs-title function_">expect</span>(userData.<span class="hljs-property">name</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">`User <span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>`</span>);
      });
    });
  });
}
</code></pre>
<h2 data-id="heading-8">4. 组件测试</h2>
<h3 data-id="heading-9">4.1 自定义组件测试</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main/ets/components/CounterComponent.ets</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">export</span> struct <span class="hljs-title class_">CounterComponent</span> {
  <span class="hljs-meta">@State</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">maxCount</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.count}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)
        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span> ? <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-property">Black</span>)
      
      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'Increment'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;
          }
        })
        .<span class="hljs-title function_">enabled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>)
      
      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'Reset'</span>)
        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;
        })
    }
  }

  <span class="hljs-comment">// 公共方法用于测试</span>
  <span class="hljs-title function_">increment</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;
    }
  }

  <span class="hljs-title function_">reset</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;
  }

  <span class="hljs-title function_">getCount</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;
  }

  <span class="hljs-title function_">isMaxReached</span>(): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>;
  }
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/CounterComponent.test.ets</span>
<span class="hljs-keyword">import</span> { describe, it, expect, beforeEach } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hypium'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CounterComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../src/main/ets/components/CounterComponent'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">counterComponentTest</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">'CounterComponent Tests'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">counter</span>: <span class="hljs-title class_">CounterComponent</span>;

    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {
      counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterComponent</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_initialize_with_zero'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">0</span>);
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">isMaxReached</span>()).<span class="hljs-title function_">assertFalse</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_increment_count'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      counter.<span class="hljs-title function_">increment</span>();
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">1</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_not_exceed_max_count'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) {
        counter.<span class="hljs-title function_">increment</span>();
      }
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">10</span>);
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">isMaxReached</span>()).<span class="hljs-title function_">assertTrue</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_reset_count'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      counter.<span class="hljs-title function_">increment</span>();
      counter.<span class="hljs-title function_">increment</span>();
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">2</span>);
      
      counter.<span class="hljs-title function_">reset</span>();
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">0</span>);
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">isMaxReached</span>()).<span class="hljs-title function_">assertFalse</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_handle_multiple_operations'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 增加 5 次</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        counter.<span class="hljs-title function_">increment</span>();
      }
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">5</span>);
      
      <span class="hljs-comment">// 重置</span>
      counter.<span class="hljs-title function_">reset</span>();
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">0</span>);
      
      <span class="hljs-comment">// 再次增加</span>
      counter.<span class="hljs-title function_">increment</span>();
      <span class="hljs-title function_">expect</span>(counter.<span class="hljs-title function_">getCount</span>()).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">1</span>);
    });
  });
}
</code></pre>
<h2 data-id="heading-10">5. Mock 和 Stub 测试</h2>
<h3 data-id="heading-11">5.1 依赖注入测试</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/main/ets/services/WeatherService.ets</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherService</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">apiKey</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">apiKey: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">apiKey</span> = apiKey;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getWeather</span>(<span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">WeatherData</span>&gt; {
    <span class="hljs-comment">// 实际应用中这里会调用真实的 API</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Not implemented in tests'</span>);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WeatherData</span> {
  <span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">temperature</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 模拟实现用于测试</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockWeatherService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">WeatherService</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">'test-key'</span>);
  }

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">getWeather</span>(<span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">WeatherData</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>({
      <span class="hljs-attr">city</span>: city,
      <span class="hljs-attr">temperature</span>: <span class="hljs-number">25</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">'Sunny'</span>
    });
  }
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/WeatherService.test.ets</span>
<span class="hljs-keyword">import</span> { describe, it, expect } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hypium'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">WeatherService</span>, <span class="hljs-title class_">MockWeatherService</span>, <span class="hljs-title class_">WeatherData</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../src/main/ets/services/WeatherService'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">weatherServiceTest</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">'WeatherService Tests'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_create_weather_service_with_api_key'</span>, <span class="hljs-number">0</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> weatherService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherService</span>(<span class="hljs-string">'real-api-key'</span>);
      <span class="hljs-comment">// 可以验证构造函数逻辑</span>
      <span class="hljs-title function_">expect</span>(weatherService).<span class="hljs-title function_">not</span>().<span class="hljs-title function_">assertUndefined</span>();
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_get_weather_data_using_mock'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> mockService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockWeatherService</span>();
      <span class="hljs-keyword">const</span> <span class="hljs-attr">weatherData</span>: <span class="hljs-title class_">WeatherData</span> = <span class="hljs-keyword">await</span> mockService.<span class="hljs-title function_">getWeather</span>(<span class="hljs-string">'Beijing'</span>);
      
      <span class="hljs-title function_">expect</span>(weatherData.<span class="hljs-property">city</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Beijing'</span>);
      <span class="hljs-title function_">expect</span>(weatherData.<span class="hljs-property">temperature</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">25</span>);
      <span class="hljs-title function_">expect</span>(weatherData.<span class="hljs-property">description</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-string">'Sunny'</span>);
    });

    <span class="hljs-title function_">it</span>(<span class="hljs-string">'should_handle_multiple_cities_with_mock'</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> mockService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockWeatherService</span>();
      
      <span class="hljs-keyword">const</span> cities = [<span class="hljs-string">'Beijing'</span>, <span class="hljs-string">'Shanghai'</span>, <span class="hljs-string">'Guangzhou'</span>];
      <span class="hljs-keyword">const</span> promises = cities.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">city</span> =&gt;</span> mockService.<span class="hljs-title function_">getWeather</span>(city));
      <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
      
      <span class="hljs-title function_">expect</span>(results.<span class="hljs-property">length</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">3</span>);
      results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">weatherData, index</span>) =&gt;</span> {
        <span class="hljs-title function_">expect</span>(weatherData.<span class="hljs-property">city</span>).<span class="hljs-title function_">assertEqual</span>(cities[index]);
        <span class="hljs-title function_">expect</span>(weatherData.<span class="hljs-property">temperature</span>).<span class="hljs-title function_">assertEqual</span>(<span class="hljs-number">25</span>);
      });
    });
  });
}
</code></pre>
<h2 data-id="heading-12">6. 测试运行配置</h2>
<h3 data-id="heading-13">6.1 测试列表文件</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ohosTest/src/test/ets/test/TestList.test.ets</span>
<span class="hljs-keyword">import</span> mathUtilTest <span class="hljs-keyword">from</span> <span class="hljs-string">'./MathUtil.test.ets'</span>;
<span class="hljs-keyword">import</span> userServiceTest <span class="hljs-keyword">from</span> <span class="hljs-string">'./UserService.test.ets'</span>;
<span class="hljs-keyword">import</span> apiServiceTest <span class="hljs-keyword">from</span> <span class="hljs-string">'./ApiService.test.ets'</span>;
<span class="hljs-keyword">import</span> counterComponentTest <span class="hljs-keyword">from</span> <span class="hljs-string">'./CounterComponent.test.ets'</span>;
<span class="hljs-keyword">import</span> weatherServiceTest <span class="hljs-keyword">from</span> <span class="hljs-string">'./WeatherService.test.ets'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testList</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">mathUtilTest</span>();
  <span class="hljs-title function_">userServiceTest</span>();
  <span class="hljs-title function_">apiServiceTest</span>();
  <span class="hljs-title function_">counterComponentTest</span>();
  <span class="hljs-title function_">weatherServiceTest</span>();
}
</code></pre>
<h3 data-id="heading-14">6.2 运行测试</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 在项目根目录运行</span>
./gradlew hmosTest
<span class="hljs-comment"># 或者</span>
npm <span class="hljs-built_in">test</span>
</code></pre>
<h2 data-id="heading-15">7. 测试最佳实践</h2>
<h3 data-id="heading-16">7.1 测试命名规范</h3>
<ul>
<li>测试方法名应该描述性很强</li>
<li>使用 <code>should_</code> 前缀描述预期行为</li>
<li>测试用例应该独立，不依赖其他测试</li>
</ul>
<h3 data-id="heading-17">7.2 测试组织结构</h3>
<ul>
<li>每个被测试类对应一个测试文件</li>
<li>使用 <code>describe</code> 块组织相关测试</li>
<li>使用 <code>beforeEach</code> 进行测试准备</li>
</ul>
<h3 data-id="heading-18">7.3 断言使用</h3>
<ul>
<li>使用明确的断言方法</li>
<li>一个测试用例一个断言（理想情况）</li>
<li>测试边界条件和异常情况</li>
</ul>
<p>这样完整的单元测试框架可以确保 ArkTS 代码的质量和可靠性，支持 TDD（测试驱动开发）实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 原型／原型链]]></title>    <link>https://juejin.cn/post/7572382777838944296</link>    <guid>https://juejin.cn/post/7572382777838944296</guid>    <pubDate>2025-11-15T02:11:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572382777838944296" data-draft-id="7572455881028517897" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 原型／原型链"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-15T02:11:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Achieve前端实验室"/> <meta itemprop="url" content="https://juejin.cn/user/1908407914473438"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 原型／原型链
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1908407914473438/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Achieve前端实验室
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T02:11:44.000Z" title="Sat Nov 15 2025 02:11:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">热身</h2>
<p>先来看一道题：</p>
<p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>
<p>可以传递给函数的数据类型没有限制。例如，值或类可能是  undefined 。</p>
<p>Leetcode：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcheck-if-object-instance-of-class%2Fdescription%2F" target="_blank" title="https://leetcode.cn/problems/check-if-object-instance-of-class/description/" ref="nofollow noopener noreferrer">2618 检查是否类的对象实例</a></p>
<p>你可能会很轻松的用 instanceof 写出来：<code>obj instanceof class</code> 这种形式的判断。</p>
<p>class 是 es6 引入的新的一个关键字，他可以让我们在 JavaScript 中更加容易使用面向对象的思维去编写代码，让对象，原型这些东西更加清晰。</p>
<p>同样的，引入 instanceof 则是方便我们去理解，不必写一套复杂的代码来判断实例和类的关系。</p>
<p>那么，class 这个关键字帮我们做了什么？而 instanceof 又帮我们简化了什么？</p>
<h2 data-id="heading-1">原型</h2>
<p>首先依旧是来讲那些前人已经说烂了的东西，原型。</p>
<h3 data-id="heading-2">原型设计模式</h3>
<p>原型首先是面向对象编程中的一个概念，是一种设计模式，他的核心思想是，​<em><strong>通过共享属性和方法来实现对象之间的代码重用</strong></em>。说实话，这个听着令人感觉像是在讲类继承，目前的编程语言多是通过类继承的方式支持面向对象的，而我们所使用的 JavaScript 则是通过原型链来支持的面向对象的[1]，且按下不表。</p>
<p>我们不妨先给原型下一个定义：<em><strong>原型就是一个用于创建对象的模板，他定义了一系列的属性和方法，基于原型创建的对象之间共享一些属性和方法。</strong></em></p>
<p>根据定义，我们写出的 <strong>JavaScript</strong> 的实现代码应该是这样的：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> boxPrototype = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-title function_">getValue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;
  }
}

<span class="hljs-keyword">const</span> box1 = {};
<span class="hljs-keyword">const</span> box2 = {};
<span class="hljs-keyword">const</span> box3 = {};
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(box1, boxPrototype);
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(box2, boxPrototype);
box2.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(box3, boxPrototype);
box3.<span class="hljs-property">value</span> = <span class="hljs-number">3</span>;

box1.<span class="hljs-property">getValue</span> === boxPrototype.<span class="hljs-property">getValue</span>; <span class="hljs-comment">// true</span>
box2.<span class="hljs-property">getValue</span> === boxPrototype.<span class="hljs-property">getValue</span>; <span class="hljs-comment">// true</span>
box3.<span class="hljs-property">getValue</span> === boxPrototype.<span class="hljs-property">getValue</span>; <span class="hljs-comment">// true</span>
</code></pre>
<ol>
<li>我们定义了一个原型 <code>boxPrototype</code></li>
<li>基于原型 <code>boxPrototype</code> 创建（即拷贝、复制）了三个对象</li>
<li>三个对象之间各自有自己的 value 值，但是引用都是的 <code>boxPrototype</code>​ 的 <code>getValue</code> 函数，即共享了方法。</li>
</ol>
<p>原型设计模式最主要的优点是<em><strong>减少了对象创建的时间和成本，通过拷贝原型对象来创建新的对象，避免重复使用构造函数初始化的操作，提高了创建对象的效率。</strong></em></p>
<p>在不同的编程语言中，原型设计模式的实现均有差异（深拷贝、浅拷贝以及语言特性），在 JavaScript 自然也是可以有不一样的实现。</p>
<p>‍</p>
<h3 data-id="heading-3">JavaScript 中的原型</h3>
<p>先给出答案：​<strong>原型实际就是一个对象</strong>。</p>
<p>我们在上文的原型设计模式中接触到了<strong>原型对象</strong>和​<strong>克隆对象</strong>，并给出了 JavaScript 中的一种实现，但是我们不难发现，在这样的实现下，原型对象和克隆对象是比较独立的两个对象（除了函数能够共享，其他属性互相之间是无法访问到的）。</p>
<p>想要被访问到也不是不可以，只要我们保存原型对象的链接即可，同时为了避免混乱，我们为其制定了标准：</p>
<p>遵循 ECMAScript 标准，符号 <code>someObject.[[Prototype]]</code>​ 用于标识 <code>someObject</code>​ 的原型。内部插槽 <code>[[Prototype]]</code>​ 可以通过 <code>Object.getPrototypeOf()</code>​ 和 <code>Object.setPrototypeOf()</code>​ 函数来访问。这个等同于 JavaScript 的非标准但被许多 JavaScript 引擎实现的属性 <code>__proto__</code>​ 访问器。为在保持简洁的同时避免混淆，在我们的符号中会避免使用 <code>obj.__proto__</code>​，而是使用 <code>obj.[[Prototype]]</code>​ 作为代替。其对应于 <code>Object.getPrototypeOf(obj)</code> [1]。</p>
<p>规范很好理解，规范中声明的 <code>[[Prototype]]</code>​ 可以认为是一个对象的私有属性，想要对其操作，那么就需要实现对应的 get/set 方法。<code>__proto__</code> 则是以前没有一套行业执行规范时，各个厂家自己实现的一套逻辑。</p>
<p>值得注意的是，JS 函数中的 <code>prototype</code>​ 属性和 <code>[[Prototype]]</code> 还有一定的差别，不可以混淆。</p>
<h2 data-id="heading-4">原型链</h2>
<p>​<em><strong>在使用原型创建对象的时候，每个对象都有一个指向原型的链接</strong></em>，这个一条链就被称为原型链。</p>
<p>有了这条链接，我们便可以使通过原型创建出来的对象可以访问到原型上的方法和属性，也就是说，<strong>当我们访问一个对象的属性时，如果这个对象本身不存在该属性，那么就会去原型上查找，其访问顺序应当是：当前对象 -&gt;</strong>  <strong>原型 -&gt;</strong>  <strong>原型的原型 -&gt;</strong>   <strong>…… -&gt;</strong>  <strong>最初的原型。null 标志着原型链的终结，当某个对象的原型指向 null 时，便不再继续向上搜索。</strong></p>
<h3 data-id="heading-5">继承</h3>
<p>如果你已经有了一定的编程语言的基础，那么你可能首先会联想到的是类的继承，<code>A extends B</code>​ 那么 A 便可以访问 A 对象中的所有属性和方法，以及从 B 中继承下来的 public 和 protected 属性和方法，而 <code>B extends C</code>则可以类推。</p>
<p>可以通过这个去理解原型链，但是要知道他们是不同的。</p>
<p>硬要说的话，可以说他是一个 <strong>继承链</strong> ，同样也是做到了方法属性的复用，但不一样的是，他们无法“共享”。</p>
<p>举个例子：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 继承</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">changeName</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">changeName</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'cat'</span> + name;
  }
}

<span class="hljs-keyword">const</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">"1"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// 1</span>
animal.<span class="hljs-title function_">changeName</span>(<span class="hljs-string">"111"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// 111</span>
<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"2"</span>);
dog.<span class="hljs-title function_">changeName</span>(<span class="hljs-string">"222"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog.<span class="hljs-property">name</span>, animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// 222 111</span>
<span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">"3"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-property">name</span>); <span class="hljs-comment">// 3</span>
cat.<span class="hljs-title function_">changeName</span>(<span class="hljs-string">"333"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-property">name</span>, dog.<span class="hljs-property">name</span>, animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// cat333 222 111</span>
</code></pre>
<p>上面这段代码是比较典型的继承，Dog 和 Cat 类都继承自 Animal 类，自然的，这里 Animal 类中定义的属性 <code>name</code>​ 和方法 <code>changeName</code>​ 都被继承下来了，但不同的是，Cat 类里面我们覆写了 <code>changeName</code>​ 方法，所以我们在实例化这三个类后，分别调用 <code>changeName</code>​ 方法，并打印方法调用前后 <code>name</code> 属性变化的情况，不难发现，每个对象仅改变了自己的属性，并没有对其他对象造成影响（也就是说他们互相之间无法访问属性），而且即使 Dog 类中没有写任何内容，但是他继承了父类的所有内容，所以他依旧可以访问到对应的属性和方法。</p>
<h3 data-id="heading-6">原型链</h3>
<p>原型是“共享”属性和方法，以做到代码复用：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> anObj = {};
<span class="hljs-keyword">const</span> anObjPrototype = { <span class="hljs-attr">df</span>: <span class="hljs-number">1</span> };

<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(anObj, anObjPrototype);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anObj.<span class="hljs-property">df</span>); <span class="hljs-comment">// 1，访问到了 anObjPrototype 的 df 属性值</span>
anObj.<span class="hljs-property">df</span> = <span class="hljs-number">2</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anObj.<span class="hljs-property">df</span>, anObjPrototype.<span class="hljs-property">df</span>); <span class="hljs-comment">// 2, 1，修改了 anObj 的 df 属性值，但对于其原型 anObjPrototype 没有影响，等于在 anObj 对象中创建了一个 df 属性，并赋值为 1</span>

<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(anObj) === anObjPrototype; <span class="hljs-comment">// true，说明 anObj 的原型保存的是 anObjPrototype 的对象地址</span>
</code></pre>
<p>这段代码非常简单，我们让 <code>anObj</code>​ 对象保存了原型对象 <code>anObjPrototype</code>​ 的地址，按照我们之前对原型链的定义，由于 <code>anObj</code>​ 中没有属性 <code>df</code> ，所以我们去他的原型上搜索，获取到值。</p>
<p>而我们在后面给 <code>anObj</code>​ 的 <code>df</code> 属性赋值为 2，由于其本身是没有这个属性的，所以我们这里的操作实际可以看做两步：</p>
<ol>
<li>在 <code>anObj</code>​ 对象中创建属性 <code>df</code>；</li>
<li>为该属性赋值</li>
</ol>
<p>而后再访问属性 <code>df</code>​ 时，由于已经在 <code>anObj</code>​ 对象中找到了对应的属性，所以就不再继续向上搜索了，即使其原型对象上存在一个相同的属性，这个就是所谓的​<strong>属性遮蔽</strong>。</p>
<p>如果在 anObjPrototype 中也没找到的话，那就返回 undefined。</p>
<p>对比上面两种形式，不难看出我们之前所说的继承实际上各个实例对象之间是没有关联的，而在原型链上，对象及其原型对象是通过一个链接（或者说一个指针指向的关系）关联上的，对象可以访问到其原型上的一些属性。</p>
<h4 data-id="heading-7">一些特别的情况</h4>
<p>查漏补缺。</p>
<p>我们通过字面量创建的对象，会隐式的设置其 prototype：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 对象字面量（没有 `__proto__` 键）自动将 `Object.prototype` 作为它们的 `[[Prototype]]`</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-built_in">object</span>) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 数组字面量自动将 `Array.prototype` 作为它们的 `[[Prototype]]`</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(array) === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 正则表达式字面量自动将 `RegExp.prototype` 作为它们的 `[[Prototype]]`</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/abc/</span>;
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(regexp) === <span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>
</code></pre>
<p>本段代码来源于 MDN。</p>
<p>func.prototype 指向的是构造函数，通过 new func() 方式创建的对象，会自动的将 func.prototype 作为自己的原型。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// {constructor: f}</span>

<span class="hljs-keyword">const</span> box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(<span class="hljs-string">'hen'</span>);
box.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// </span>
</code></pre>
<p>​<em><strong>定义</strong></em>​：​<em><strong>构造函数是使用 new 调用的函数</strong></em>，如 new Box();</p>
<h3 data-id="heading-8">基于原型链的继承</h3>
<p>图穷匕见，JavaScript 的继承模式是 <em><strong>原型继承</strong></em> ，尽管现在语言已经支持了 class 关键字，即类的说法，但实际并没有改变他的继承模式。</p>
<p>那么什么是原型继承呢？</p>
<p>我们在原型链一节中讲到，JavaScript 通过原型链来实现代码的复用，同时阅读对应的示例代码可以发现，我们通过构造了一个原型链，使得对象能够访问到其原型的属性，这就是​<strong>继承了属性</strong>。</p>
<p>​<strong>继承“方法”</strong> ​，本质和继承属性一样，这时候的 <em><strong>属性遮蔽</strong></em> 我们可以则类比为 “​<strong>方法重写</strong>​”。但是这里有一个 JavaScript 的特别之处，也是一个难点，即 <code>this</code> ，当继承的函数被调用的时候，this 会指向当前对象，而不是拥有该函数的原型对象。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> anObjPrototype = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-title function_">getValue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>;
  }
}

<span class="hljs-keyword">const</span> anObj = {};
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(anObj, anObjPrototype);

<span class="hljs-comment">// 修改 anObj 中属性 a 的值</span>
anObj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;
anObj.<span class="hljs-title function_">getValue</span>(); <span class="hljs-comment">// 2，得到的是 anObj 自己的属性值。</span>
</code></pre>
<p>运行上述代码，你会发现虽然 <code>getValue</code>​ 是属于原型对象 <code>anObjPrototype</code>​ 的，但是最终 <code>anObj</code>​ 调用该方法的时候得到的是对象 <code>anObj</code> 的属性值，而非原型对象的值。</p>
<h2 data-id="heading-9">最后</h2>
<p>回到我们开篇的问题，class 关键字帮我们做了什么？instanceof 关键字又帮我们简化了什么？</p>
<p>这两个问题的答案已经十分清晰了，但也不妨在这里做个总结：</p>
<p>class 本质是一个语法糖，他帮我们处理绑定每个对象的原型，实现属性的共享。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 无 class 的写法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
}

<span class="hljs-keyword">const</span> box1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> box2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(<span class="hljs-number">2</span>);
box1.<span class="hljs-property">getValue</span> === box2.<span class="hljs-property">getValue</span>; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 对应的 class 写法</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
  }
}
</code></pre>
<p>显而易见的，class 的写法更符合我们面向对象的编程习惯，function 的写法则相对不那么直观。</p>
<p>instanceof 则是帮我们检查实例对象是否是某个类的对象，实际上，我们在 JavaScript 中的描述应该是，<strong>用于检测构造函数的 prototype 是否出现在了实例对象的原型链上。</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span>(<span class="hljs-params"/>) {
}
<span class="hljs-keyword">const</span> box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(); <span class="hljs-comment">// 前文定义了使用 new 调用的函数就是构造函数</span>

box <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Box</span>; <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(box) === <span class="hljs-title class_">Box</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>
</code></pre>
<p>由此我们可以推导出，如果想在 JavaScript 中实现继承，我们可以构造一个很长的原型链：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"/>) {}
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Cat 继承自 Animal</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"/>) {}
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Dog 继承自 Animal</span>
</code></pre>
<p>代码中我们在修改了原型之后，Cat 和 Dog 就变成了 Animal 的一个子类，Animal 则作为基类存在，在 function 这种写法下，他并不是那么直观，但是，我们将其转换成 class 的写法后，一切会更加清晰易读。</p>
<p>不妨躬身一试。</p>
<h2 data-id="heading-10">一些思考</h2>
<p>说 js 中类的性能比较差，但这并不是说我们一定要用以前这种比较拗口的形式去面向对象编程，这是一种取舍，让我们在代码的可读性和可维护性和性能之间权衡，我们未必需要保证我们编写的代码去追求极致的性能，但是我们需要保证我们的代码符合一定的规范，让别人维护时不至于会高兴的蹦起来去指责前人的代码。</p>
<p>时代总是在进步的，编译器、引擎也是在更新换代，在努力解决这些问题，有时候极致的性能就意味着厚重的技术债务，后人对你当前引以为豪的代码无从下手。</p>
<p>当然，以上是从业务角度出发的思考，如果你是写高性能库的，看看就好。</p>
<h2 data-id="heading-11">参考文章</h2>
<p>[1]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FInheritance_and_the_prototype_chain" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" ref="nofollow noopener noreferrer">继承与原型链 - JavaScript | MDN</a></p>
<p>[2]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FObject_prototypes" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" ref="nofollow noopener noreferrer">对象原型 - 学习 Web 开发 | MDN</a></p>
<p>[3]: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FPrototype-based_programming" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Prototype-based_programming" ref="nofollow noopener noreferrer">基于原型编程 - MDN Web 文档术语表：Web 相关术语的定义 | MDN</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 AI 工程师 Trae Solo ，一个人打造“绘本岛”：从想法到上线只需三步]]></title>    <link>https://juejin.cn/post/7572408208263544872</link>    <guid>https://juejin.cn/post/7572408208263544872</guid>    <pubDate>2025-11-14T16:10:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572408208263544872" data-draft-id="7572390974460198912" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 AI 工程师 Trae Solo ，一个人打造“绘本岛”：从想法到上线只需三步"/> <meta itemprop="keywords" content="Trae,全栈,人工智能"/> <meta itemprop="datePublished" content="2025-11-14T16:10:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 AI 工程师 Trae Solo ，一个人打造“绘本岛”：从想法到上线只需三步
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-14T16:10:25.000Z" title="Fri Nov 14 2025 16:10:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-14
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言：开发范式的革命正在发生</h2>
<p>过去十年，前端开发经历了从 jQuery 到 React/Vue，再到 Vite + TypeScript + Tailwind 的快速演进。但无论工具如何变化，一个残酷的事实始终存在：<strong>构建一个功能完整、体验良好的产品，依然需要多人协作、数周甚至数月的时间</strong>。</p>
<p>然而，2024 年以来，一种名为 <strong>Solo 模式（Solo Mode）</strong> 的 AI 开发新范式正在悄然改变这一切。它不再满足于“辅助编码”，而是追求 <strong>端到端的产品交付能力</strong>——从需求理解、架构设计、UI 构建、状态管理，到测试部署，全程由 AI 主导完成。</p>
<p>而 <strong>Trae Solo</strong>，正是这一范式的代表者。</p>
<p>本文将以我们亲手打造的真实项目—— <strong>“绘本岛”（HuibenDAO）</strong> 为例，全面展示 Trae Solo 如何在几天内，将一个模糊的产品构想转化为可交互、可部署、结构规范的 React 应用。更重要的是，我们将通过项目细节，揭示 Solo <strong>为何强大、强在哪里、以及如何高效使用它</strong>。</p>
<hr/>
<h2 data-id="heading-1">一、当“一人公司”成为可能：Solo 模式的崛起</h2>
<h3 data-id="heading-2">1.1 传统开发的困境</h3>
<p>做一个像“绘本岛”这样的亲子平台，在传统模式下意味着：</p>
<ul>
<li><strong>产品经理</strong>撰写 PRD，定义用户画像、功能模块、交互流程；</li>
<li><strong>UI/UX 设计师</strong>输出 Figma 原型，标注颜色、间距、动效；</li>
<li><strong>前端团队</strong>搭建工程环境、实现组件、对接 API；</li>
<li><strong>后端团队</strong>设计数据库、编写接口、处理支付与鉴权；</li>
<li><strong>测试人员</strong>编写用例、回归验证；</li>
<li><strong>运维工程师</strong>配置服务器、设置 CI/CD。</li>
</ul>
<p>整个过程至少需要 5–6 人协作 4–8 周。对于个体开发者或初创团队而言，这几乎是不可逾越的门槛。</p>
<h3 data-id="heading-3">1.2 Solo 模式：从 L2 到 L4 的跃迁</h3>
<p>Trae Solo 所代表的 <strong>Solo 模式</strong>，本质上是一次开发范式的升维：</p>






























<table><thead><tr><th>级别</th><th>能力描述</th><th>类比</th></tr></thead><tbody><tr><td>L1</td><td>语法提示、自动补全</td><td>智能输入法</td></tr><tr><td>L2</td><td>片段生成、函数建议</td><td>Copilot 等 AI 编程助手</td></tr><tr><td>L3</td><td>理解项目上下文，生成符合规范的模块</td><td>Trae Solo（当前阶段）</td></tr><tr><td>L4</td><td>全自主开发，仅需人类确认方向</td><td>未来目标</td></tr></tbody></table>
<p>Solo 模式已迈入 <strong>L3 级</strong>：它不仅能写代码，更能<strong>理解你的产品意图、技术选型、设计风格和业务逻辑</strong>，并在此基础上做出合理决策。</p>
<blockquote>
<p><strong>核心理念</strong>：让 AI 成为开发主导者，人类转为副驾驶角色。</p>
</blockquote>
<p>这意味着，开发者终于可以从繁琐的工程细节中解放出来，专注于真正创造价值的部分：<strong>定义问题、设计体验、验证假设</strong>。</p>
<hr/>
<h2 data-id="heading-4">二、“绘本岛”：一个由 Solo 驱动的真实项目</h2>
<h3 data-id="heading-5">2.1 项目背景与愿景</h3>
<p>“绘本岛”是一个面向中国 0–6 岁儿童家庭的数字平台，旨在融合 <strong>绘本阅读</strong> 与 <strong>线下亲子活动</strong>，打造一个“有温度”的成长空间。</p>
<ul>
<li><strong>品牌定位</strong>：温馨、清新、富有童趣，视觉风格参考小红书的内容感与宝宝巴士的互动性。</li>
<li><strong>Slogan</strong>：“让亲子时光更温暖一点，每天10分钟绘出成长的奇妙旅程。”</li>
<li><strong>核心用户</strong>：一线/新一线城市、重视早期教育的年轻父母。</li>
<li><strong>技术目标</strong>：完全适配移动端，加载快、交互流畅、体验一致。</li>
</ul>
<h3 data-id="heading-6">2.2 功能模块概览</h3>

































<table><thead><tr><th>模块</th><th>核心功能</th></tr></thead><tbody><tr><td>首页</td><td>热门绘本轮播、活动推荐、搜索入口</td></tr><tr><td>绘本馆</td><td>按年龄（0–3, 3–6）、主题（情绪、科普、习惯）筛选，支持评分排序与关键词搜索</td></tr><tr><td>亲子活动</td><td>按城市筛选活动，查看详情、报名状态、设置提醒</td></tr><tr><td>阅读记录</td><td>记录阅读足迹、打卡、上传读后感/照片、支持多子女切换</td></tr><tr><td>购物流程</td><td>加入购物车、下单结算、对接支付（模拟）、查询物流</td></tr><tr><td>用户中心</td><td>管理孩子档案、查看订单、联系客服</td></tr></tbody></table>
<p>这样一个功能闭环完整的产品，若按传统方式开发，至少需要 3–4 周。但在 Trae Solo 的协助下，我们仅用 <strong>3 天</strong> 就完成了前端原型的构建与部署。</p>
<h3 data-id="heading-7">2.3 项目结构：Solo 如何“理解”并构建专业级 React 应用？</h3>
<p>最关键的一点在于：<strong>我们并未手动设计项目结构</strong>。我们只向 Solo 提供了如下信息：</p>
<blockquote>
<p>“使用 React + TypeScript + Vite + Tailwind CSS + Zustand + Radix UI，构建一个移动端优先的亲子绘本平台，包含首页、绘本馆、活动页、阅读记录、购物流程和用户中心。”</p>
</blockquote>
<p>结果，Solo 自动生成了以下高度规范的目录结构：</p>
<pre><code class="hljs language-csharp" lang="csharp">huiben/
├── src/
│   ├── assets/           <span class="hljs-meta"># 插画、图标、字体等静态资源</span>
│   ├── components/       <span class="hljs-meta"># 可复用 UI 组件（BookCard, ActivityItem, BottomNav）</span>
│   ├── hooks/            <span class="hljs-meta"># 自定义 Hooks（useDebounce, useLocalStorage）</span>
│   ├── pages/            <span class="hljs-meta"># 页面组件（HomePage, LibraryPage, ActivityPage...）</span>
│   ├── router/           <span class="hljs-meta"># 路由配置（AppRouter.tsx）</span>
│   ├── store/            <span class="hljs-meta"># Zustand 状态管理（cartStore.ts, readingRecordStore.ts）</span>
│   ├── types/            <span class="hljs-meta"># 全局 TypeScript 类型（Book, Activity, ChildProfile）</span>
│   └── App.tsx           <span class="hljs-meta"># 根组件，集成全局布局与路由容器</span>
├── <span class="hljs-keyword">public</span>/
├── package.json
├── vite.config.ts        <span class="hljs-meta"># 配置路径别名 @/ → src/</span>
├── tailwind.config.js    <span class="hljs-meta"># 注册自定义色板（amber-50, blue-400）</span>
└── netlify.toml          <span class="hljs-meta"># SPA 路由重定向规则</span>
</code></pre>
<h4 data-id="heading-8">这个结构为何能证明 Solo 的强大？</h4>
<ol>
<li>
<p><strong>职责分离清晰，符合现代 React 最佳实践</strong><br/>
Solo 自动将 UI（<code>components/</code>）、页面流（<code>pages/</code>）、状态（<code>store/</code>）、类型（<code>types/</code>）分层管理，避免逻辑耦合。这种架构通常只有经验丰富的团队才会刻意设计。</p>
</li>
<li>
<p><strong>类型先行（Type-First），保障长期可维护性</strong><br/>
在生成任何组件前，Solo 先创建了 <code>types/book.ts</code>，定义了 <code>Book</code> 接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Book</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">coverUrl</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">ageRange</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]; <span class="hljs-comment">// e.g., [3, 6]</span>
  <span class="hljs-attr">rating</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">tags</span>: <span class="hljs-built_in">string</span>[];
}
</code></pre>
<p>后续所有组件均基于此类型开发，极大减少了运行时错误。</p>
</li>
<li>
<p><strong>精准预判复杂状态需求</strong><br/>
当我们提到“支持多子女切换阅读记录”，Solo 立即识别这是一个跨页面共享状态，并生成了 <code>readingRecordStore.ts</code>：</p>
<pre><code class="hljs language-css" lang="css">const useReadingRecordStore = create&lt;ReadingRecordState&gt;()((set) =&gt; ({
  activeChildId: <span class="hljs-string">'child-1'</span>,
  records: {},
  setActiveChild: (id) =&gt; <span class="hljs-built_in">set</span>({ activeChildId: id }),
  addRecord: (bookId) =&gt; <span class="hljs-built_in">set</span>((state) =&gt; ({
    records: {
      ..<span class="hljs-selector-class">.state</span><span class="hljs-selector-class">.records</span>,
      <span class="hljs-selector-attr">[state.activeChildId]</span>: [...(state.records[state.activeChildId] || []), bookId]
    }
  }))
}));
</code></pre>
<p>这不是模板填充，而是<strong>基于语义的理解与推理</strong>。</p>
</li>
<li>
<p><strong>部署即考虑，具备 DevOps 视角</strong><br/>
项目根目录直接包含 <code>netlify.toml</code>，配置了 SPA 回退规则：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[[redirects]]</span>
  <span class="hljs-attr">from</span> = <span class="hljs-string">"/*"</span>
  <span class="hljs-attr">to</span> = <span class="hljs-string">"/index.html"</span>
  <span class="hljs-attr">status</span> = <span class="hljs-number">200</span>
</code></pre>
<p>确保用户刷新页面不会 404——这是许多新手开发者容易忽略的关键细节。</p>
</li>
<li>
<p><strong>工程化工具链完备</strong></p>
<ul>
<li><code>vite.config.ts</code> 中预设了路径别名 <code>@/</code>，提升导入可读性；</li>
<li><code>tailwind.config.js</code> 注册了米白（<code>amber-50</code>）、天蓝（<code>blue-400</code>）等主色；</li>
<li>ESLint + Prettier 规则自动配置，保证代码风格统一。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>结论</strong>：Solo 不是在“猜”你要什么，而是在“知道”你要什么之后，把一切都安排得明明白白。它是一位<strong>懂产品、懂架构、懂工程的 AI 上下文工程师</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-9">三、Trae Solo 的核心功能详解</h2>
<h3 data-id="heading-10">3.1 什么是 Trae Solo？</h3>
<p>Trae Solo 是一个 <strong>AI 驱动的上下文工程师（Context Engineer）</strong> ，其核心能力远超传统代码生成工具：</p>
<ul>
<li>✅ <strong>项目级上下文感知</strong>：理解技术栈、目录结构、类型定义、设计规范；</li>
<li>✅ <strong>端到端任务执行</strong>：从需求到部署，全程自动化；</li>
<li>✅ <strong>主动协同工程规范</strong>：遵循无障碍、响应式、类型安全等最佳实践；</li>
<li>✅ <strong>持续学习与演进</strong>：记住你的偏好，在后续任务中提供更精准输出。</li>
</ul>
<h3 data-id="heading-11">3.2 在“绘本岛”中的具体表现</h3>



































<table><thead><tr><th>任务</th><th>Solo 的行动</th><th>价值</th></tr></thead><tbody><tr><td>初始化项目</td><td>自动生成 Vite + React + TS + Tailwind + Zustand 脚手架</td><td>节省 2–3 小时环境配置时间</td></tr><tr><td>创建绘本详情页</td><td>生成 <code>BookDetailPage.tsx</code> + <code>RatingStars.tsx</code>，自动导入 Radix UI Dialog</td><td>快速实现复杂交互</td></tr><tr><td>管理购物车状态</td><td>创建 <code>cartStore.ts</code>，含 addItem/removeItem/clear 等 actions</td><td>避免手动编写冗余状态逻辑</td></tr><tr><td>修复类型错误</td><td>当 <code>Book</code> 缺少 <code>ageRange</code> 字段时，自动补全接口并同步所有引用</td><td>提升开发健壮性</td></tr><tr><td>配置部署</td><td>输出 <code>netlify.toml</code>，设置 SPA 路由规则</td><td>实现“提交即上线”</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-12">四、高效使用 Solo 的三步法（附实战技巧）</h2>
<h3 data-id="heading-13">第一步：提出清晰、具体的需求</h3>
<p><strong>低效表达</strong>：“做个绘本网站。”<br/>
<strong>高效表达</strong>：</p>
<blockquote>
<p>“打造一个叫‘绘本岛’的亲子平台，首页有热门绘本轮播、顶部搜索栏、底部导航；支持家长用微信登录并设置孩子姓名、年龄（0–6岁）和兴趣标签；绘本详情页包含封面、标题、适合年龄范围（如3–6岁）、评分星（1–5）和‘加入书架’按钮；整体风格温馨清新，主色为米白（bg-amber-50）和天蓝（text-blue-400），完全适配手机。”</p>
</blockquote>
<p><strong>原则</strong>：优质需求 = 90% 的工作量。</p>
<h3 data-id="heading-14">第二步：让 Solo 生成完整方案</h3>
<p>输入需求后，Solo 会输出：</p>
<ul>
<li>产品需求文档（PRD）</li>
<li>技术架构图（含数据模型、API 设计）</li>
<li>UI 原型代码（基于 Tailwind）</li>
<li>初始化项目脚手架</li>
</ul>
<p>这一步遵循“<strong>先规划，后执行</strong>”原则，避免盲目编码。</p>
<h3 data-id="heading-15">第三步：一键启动开发 + 实时反馈</h3>
<p>确认方案后，点击“开始开发”，Solo 会：</p>
<ul>
<li>自动创建文件、安装依赖、配置工具链</li>
<li>实时显示任务进度（如“正在生成 ActivityPage…”）</li>
<li>支持随时中断、修改、重新生成</li>
</ul>
<p><strong>过程中可随时调整</strong>：</p>
<blockquote>
<p>“把‘加入书架’按钮改成淡黄色（bg-amber-200），加圆角（rounded-full），hover 时变深一点。”</p>
</blockquote>
<p>Solo 会立即更新对应组件。</p>
<h4 data-id="heading-16">高阶使用技巧</h4>
<ul>
<li><strong>Git 提交原子化</strong>：每次 Solo 生成后提交一次 commit，便于回溯；</li>
<li><strong>功能拆解</strong>：复杂功能分步实现（如“先做静态列表 → 再加筛选 → 最后加搜索”）；</li>
<li><strong>人工审核关键文档</strong>：PRD 和架构图需人工确认，确保方向正确。</li>
</ul>
<hr/>
<h2 data-id="heading-17">五、Solo 模式的行业影响与未来展望</h2>
<h3 data-id="heading-18">5.1 对开发者角色的重塑</h3>
<ul>
<li><strong>非技术人员</strong>：可通过精准需求描述，快速验证创意 MVP；</li>
<li><strong>个体开发者</strong>：可独立完成原本需多人协作的完整产品；</li>
<li><strong>产品经理</strong>：若掌握 Solo，将成为“能落地的想法引擎”，大幅提升竞争力。</li>
</ul>
<h3 data-id="heading-19">5.2 “绘本岛”的下一步</h3>
<p>未来，“绘本岛”将引入 <strong>AI 推荐系统</strong>：</p>
<ul>
<li>根据孩子的阅读记录、年龄、兴趣标签，智能推荐绘本；</li>
<li>结合地理位置，推送附近的亲子活动；</li>
<li>自动生成“本周阅读报告”。</li>
</ul>
<p>而这些功能，同样可以由 Trae Solo 协助实现——只需描述清楚业务逻辑。</p>
<hr/>
<h2 data-id="heading-20">结语：你不需要成为全栈，但你需要一个全栈 AI</h2>
<p>在 Solo 模式下，开发的本质不再是“写多少行代码”，而是 <strong>“如何清晰地表达你想创造的世界”</strong> 。</p>
<p>而 Trae Solo，就是那个愿意为你把这个世界从文字变成现实的伙伴。</p>
<blockquote>
<p>项目在线预览：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhuiben-dao.netlify.app%2F" title="https://huiben-dao.netlify.app/" target="_blank" ref="nofollow noopener noreferrer">huiben-dao.netlify.app</a><br/>
代码仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2FgiaoZou%2FWEB_note%2Ftree%2FReact%2Fhuiben" title="https://gitee.com/giaoZou/WEB_note/tree/React/huiben" target="_blank" ref="nofollow noopener noreferrer">gitee.com/giaoZou/WEB…</a><br/>
了解 Trae Solo：<a href="https://www.trae.ai/solo" title="https://www.trae.ai/solo" target="_blank" ref="nofollow noopener noreferrer">www.trae.ai/solo</a></p>
</blockquote>
<p><strong>现在，轮到你了——想打造什么样的数字岛屿？</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Gemini 2.5 Flash Image API尺寸设置完整指南：10种宽高比详解]]></title>    <link>https://juejin.cn/post/7572434032518381614</link>    <guid>https://juejin.cn/post/7572434032518381614</guid>    <pubDate>2025-11-15T00:57:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572434032518381614" data-draft-id="7572485825704312841" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Gemini 2.5 Flash Image API尺寸设置完整指南：10种宽高比详解"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2025-11-15T00:57:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LaoZhangAI"/> <meta itemprop="url" content="https://juejin.cn/user/1327865776053022"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Gemini 2.5 Flash Image API尺寸设置完整指南：10种宽高比详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1327865776053022/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LaoZhangAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T00:57:06.000Z" title="Sat Nov 15 2025 00:57:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Gemini 2.5 Flash Image（Nano Banana）API在2025年9月正式版中新增宽高比设置功能，从预览版的3种（1:1/3:4/4:3）扩展到10种（21:9/16:9/4:3/3:2/1:1/9:16/3:4/2:3/5:4/4:5），增长233%。通过Python API设置：<code>image_config=types.ImageConfig(aspect_ratio="16:9")</code>；JavaScript：<code>imageConfig: {aspectRatio: "16:9"}</code>。场景推荐：社交媒体用9:16竖屏或1:1方形、电商用3:4产品图、视频用16:9标准或21:9电影、游戏用5:4 UI。注意：仅支持宽高比不能指定精确像素、不支持自定义比例、图片编辑也可改变尺寸。价格$0.039/张不变。</p>
<h2 data-id="heading-0">Gemini 2.5 Flash Image API尺寸设置：30秒了解10种宽高比</h2>
<p>Gemini 2.5 Flash Image（社区昵称Nano Banana）的API尺寸设置，是指通过<code>aspect_ratio</code>参数控制生成图片的宽高比（例如16:9、9:16、1:1等），而不是指定精确的像素尺寸（如1920×1080）。根据Google官方博客公告，2025年9月正式版将支持的宽高比从预览版的3种大幅扩展到10种，覆盖从21:9超宽屏到9:16竖屏的所有主流格式。</p>
<p>需要明确的是，<strong>你只能控制宽高比，不能控制精确分辨率</strong>。Google的设计理念是"内容为先，尺寸自适应"——你告诉模型要生成什么内容、什么比例，模型自动决定最优的像素尺寸（通常长边在1024-2048px之间，取决于是Nano Banana 1还是2代）。这种设计简化了使用（不需要纠结1920×1080还是1280×720），但也意味着如果你需要严格的像素规格（如印刷品必须300dpi、3000×2000px），可能需要后期upscale处理。</p>
<p><strong>10种支持的宽高比</strong>及其典型应用：</p>
<p><strong>横屏格式（4种）</strong> ：</p>
<ul>
<li><strong>21:9</strong>（超宽屏）：电影级视觉、游戏横幅、全景图，宽度是高度的2.33倍</li>
<li><strong>16:9</strong>（标准宽屏）：YouTube视频、PPT封面、桌面壁纸，最常用的横屏比例</li>
<li><strong>4:3</strong>（经典横屏）：传统显示器、iPad横屏、复古照片风格</li>
<li><strong>3:2</strong>（摄影横屏）：单反相机标准、风景摄影、艺术打印</li>
</ul>
<p><strong>方形格式（1种）</strong> ：</p>
<ul>
<li><strong>1:1</strong>（正方形）：Instagram动态图、微信朋友圈、头像图标，社交媒体最通用</li>
</ul>
<p><strong>竖屏格式（5种）</strong> ：</p>
<ul>
<li><strong>9:16</strong>（标准竖屏）：抖音/TikTok短视频、Instagram Story、手机全屏</li>
<li><strong>3:4</strong>（经典竖屏）：电商产品详情图、Pinterest Pin、手机竖屏壁纸</li>
<li><strong>2:3</strong>（摄影竖屏）：人像摄影、时尚杂志、垂直海报</li>
<li><strong>5:4</strong>（近方形横）：Ins老式照片滤镜、复古广告、卡片设计</li>
<li><strong>4:5</strong>（近方形竖）：Instagram动态推荐比例、Facebook帖子、社交卡片</li>
</ul>
<p>根据2025年11月的社区使用反馈，最常用的三个比例是：<strong>9:16</strong>（短视频时代的主流）、<strong>1:1</strong>（社交媒体通用）、<strong>16:9</strong>（桌面内容和视频）。如果你不确定选哪个，这三个覆盖90%的使用场景。</p>
<h2 data-id="heading-1">Python API设置方法：完整代码示例与参数说明</h2>
<p>使用Python调用Gemini 2.5 Flash Image API并设置宽高比，需要通过<code>image_config</code>参数。以下是从安装SDK到生成图片的完整流程：</p>
<h3 data-id="heading-2">安装Google Generative AI SDK</h3>
<p>如果你使用的是较新版本的SDK，可能名称是：</p>
<p>验证安装：</p>
<h3 data-id="heading-3">基础用法：设置单一宽高比</h3>
<p><strong>参数详解</strong>：</p>
<p><code>aspect_ratio</code>：字符串类型，可选值为"21:9"、"16:9"、"4:3"、"3:2"、"1:1"、"9:16"、"3:4"、"2:3"、"5:4"、"4:5"共10种。必须严格使用这些值，自定义比例（如"2:1"、"7:5"）会报错。</p>
<p><code>response_modalities=["IMAGE"]</code>：告诉API只返回图片，不返回文本。如果你希望同时生成图片和配文，可以设置为<code>["TEXT", "IMAGE"]</code>。</p>
<p><code>model="gemini-2.5-flash-image"</code>：模型ID。注意不是"gemini-2.5-flash"（那是文本模型），必须带"-image"后缀。</p>
<h3 data-id="heading-4">批量生成不同宽高比</h3>
<p>如果你需要一次生成多个宽高比的图片（例如生成Instagram的9:16、1:1、4:5三个版本），可以这样实现：</p>
<p>这种批量生成在电商场景特别实用——一个产品需要在淘宝（3:4详情图）、小红书（1:1或4:5）、抖音（9:16短视频封面）多平台展示，一次性生成3个版本，确保内容一致但适配不同平台。</p>
<h3 data-id="heading-5">图片编辑时改变宽高比</h3>
<p>Gemini 2.5 Flash Image不仅能从零生成图片，还能编辑现有图片并改变宽高比：</p>
<p>这个功能解决了一个常见痛点：你用AI生成了一张完美的方形图片，但需要在YouTube用（16:9）。传统做法是重新生成（可能效果不一样），或手动PS裁剪拉伸（破坏构图）。而Nano Banana可以智能扩展画布——保持主体不变，自动补充周边内容（如虚化背景、延伸场景），自然过渡到新比例。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b78145b41bd14f77b63a95d6e752b3b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGFvWmhhbmdBSQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763773026&amp;x-signature=7fEBnfSIHbDALxKjqkC%2B2wEZRu0%3D" alt="Python和JavaScript代码示例" loading="lazy"/></p>
<h2 data-id="heading-6">JavaScript/Node.js API设置方法：完整代码</h2>
<p>如果你的项目使用JavaScript或Node.js，同样可以调用Gemini 2.5 Flash Image API设置宽高比：</p>
<h3 data-id="heading-7">安装SDK</h3>
<h3 data-id="heading-8">基础用法</h3>
<h3 data-id="heading-9">批量生成不同比例（适合社交媒体运营）</h3>
<p>社交媒体运营常需要同一内容的多个版本——Instagram需要9:16、1:1、4:5三个版本，小红书需要3:4、1:1，抖音需要9:16。以下代码一次性生成全部版本：</p>
<p>这个脚本特别适合电商或内容创作者——设计一次视觉创意，自动生成6个平台的适配版本，节省大量重复劳动。成本方面，6张图×<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.039</mn><mo>=</mo></mrow><annotation encoding="application/x-tex">0.039=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.039</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span></span></span></span></span>0.234，不到两毛五人民币，远低于设计师手动调整6个版本的人工成本。</p>
<h3 data-id="heading-10">错误处理与重试</h3>
<p>API调用可能失败（网络问题、rate limit、内容违规），建议添加错误处理：</p>
<h2 data-id="heading-11">10种宽高比详解：场景推荐与实战应用</h2>
<p>每种宽高比都有最适合的应用场景。选对比例，生成的图片在目标平台展示效果最佳。</p>
<h3 data-id="heading-12">横屏组：适合桌面内容和视频</h3>
<p><strong>21:9超宽屏（2.33:1）</strong></p>
<p>典型应用：电影画幅、游戏过场动画、沉浸式横幅广告、全景图像。</p>
<p>优势：视野宽广，电影感强，适合展示宏大场景（城市天际线、自然风光、科幻场景）。</p>
<p>劣势：在手机竖屏观看时会有大量黑边，只适合桌面或横屏观看场景。</p>
<p>实际使用建议：如果你的内容主要在PC端展示（网站横幅、桌面壁纸、演示文稿），21:9能提供独特的视觉冲击力。但如果受众主要在手机端，不推荐这个比例。</p>
<p><strong>16:9标准宽屏（1.78:1）</strong></p>
<p>典型应用：YouTube视频封面、B站封面、PPT首页、桌面壁纸、网站hero图。</p>
<p>优势：最通用的横屏比例，几乎所有显示器和视频平台的默认格式。用户看惯了这个比例，视觉接受度高。</p>
<p>劣势：因为太常见，视觉上不够"特别"，想要吸引眼球需要在内容创意上下功夫。</p>
<p>实际使用建议：如果你不确定选哪个横屏比例，选16:9不会错。它是横屏内容的"安全选择"。</p>
<p><strong>4:3经典横屏（1.33:1）</strong></p>
<p>典型应用：iPad横屏、传统显示器、投影仪、复古风格内容。</p>
<p>优势：比16:9"更方"，画面信息密度更高（同样宽度下，4:3能展示更多纵向内容）。适合信息图、教程截图、老式照片风格。</p>
<p>劣势：在现代宽屏显示器上会有黑边，不够"现代感"。</p>
<p>实际使用建议：教育内容、信息图表、需要兼容iPad展示的场景适合4:3。如果追求现代感和电影感，选16:9或21:9。</p>
<p><strong>3:2摄影横屏（1.5:1）</strong></p>
<p>典型应用：单反相机标准、风景摄影、艺术印刷、摄影作品集。</p>
<p>优势：专业摄影圈的标准比例，视觉平衡感好，适合需要"摄影质感"的场景。</p>
<p>劣势：在社交媒体展示时可能被裁剪（Instagram Feed是1:1，会裁掉两边）。</p>
<p>实际使用建议：如果你的AI生成图片定位是"摄影作品级别"（如艺术创作、高端品牌视觉），3:2能传达专业感。日常社交媒体内容不推荐。</p>
<h3 data-id="heading-13">方形：社交媒体最通用</h3>
<p><strong>1:1正方形</strong></p>
<p>典型应用：Instagram动态图、微信朋友圈九宫格、头像、Logo、产品缩略图。</p>
<p>优势：通用性最强，几乎所有社交平台都完美支持。正方形构图强迫内容居中，视觉聚焦度高。</p>
<p>劣势：空间利用率相对低（相同宽度下，竖屏能展示更多内容），不适合展示纵向延伸的主体（如人物全身照、高楼）。</p>
<p>实际使用建议：如果你的内容要跨平台分发（微信+Instagram+小红书），1:1是最安全的选择。生成时确保主体居中，避免被任何平台裁剪。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d17a268e2ee490ebb3eacdc38b76545~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGFvWmhhbmdBSQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763773026&amp;x-signature=maeDbDlGAq1Jsn4qrPjKrnNu7tU%3D" alt="10种宽高比详解与应用场景" loading="lazy"/></p>
<h3 data-id="heading-14">竖屏组：移动时代的主流</h3>
<p><strong>9:16标准竖屏（0.56:1）</strong></p>
<p>典型应用：抖音/TikTok短视频、Instagram Reels、YouTube Shorts、手机全屏壁纸。</p>
<p>优势：最符合手机竖屏使用习惯，用户无需旋转屏幕，沉浸感强。短视频时代的"标准规格"。</p>
<p>劣势：在桌面端观看体验差（两边大量空白），只适合移动端内容。</p>
<p>实际使用建议：2025年短视频是流量主战场，如果你做抖音/TikTok内容，9:16是必选。即使是图文内容，竖屏也符合用户刷手机的习惯。</p>
<p><strong>3:4经典竖屏（0.75:1）</strong></p>
<p>典型应用：电商产品详情图、Pinterest Pin、小红书笔记配图、竖屏海报。</p>
<p>优势：比9:16"更方"，适合展示完整的产品或人物（从头到脚），电商最爱的比例。</p>
<p>劣势：相比9:16，手机全屏时上下会有少量黑边（不过影响不大）。</p>
<p>实际使用建议：电商产品图首选3:4——展示完整又不过于瘦长，配合详情说明最合适。</p>
<p><strong>2:3摄影竖屏（0.67:1）</strong></p>
<p>典型应用：时尚人像摄影、杂志封面、艺术海报、垂直展示架。</p>
<p>优势：专业摄影的标准竖屏比例，适合强调纵向延伸（高挑身材、高耸建筑）。</p>
<p>劣势：在部分社交平台会被裁剪（Instagram Story是9:16更窄）。</p>
<p>实际使用建议：时尚、艺术、人像类内容适合2:3，能传达"专业摄影"的质感。</p>
<p><strong>5:4近方形横屏（1.25:1）</strong></p>
<p>典型应用：Instagram老式照片滤镜、复古广告风格、卡片设计。</p>
<p>优势：介于方形和横屏之间，视觉平衡，适合需要"复古感"的内容。</p>
<p>劣势：较少使用，在现代平台展示时可能不如标准比例协调。</p>
<p>实际使用建议：复古主题、怀旧内容、模拟胶片相机效果时选5:4。日常内容不推荐。</p>
<p><strong>4:5近方形竖屏（0.8:1）</strong></p>
<p>典型应用：Instagram动态推荐比例、Facebook帖子、社交卡片。</p>
<p>优势：Instagram官方推荐的"最佳展示比例"——相比1:1能展示更多纵向内容，相比9:16不会太瘦长，在Feed流中占据屏幕面积最大。</p>
<p>劣势：比较"专属"Instagram的比例，在其他平台可能需要调整。</p>
<p>实际使用建议：如果你的内容主要发Instagram动态（不是Story），4:5能获得最大的展示面积和关注度。根据Instagram官方建议，4:5比1:1的engagement高约10-15%。</p>
<h2 data-id="heading-15">场景推荐：不同应用选哪个比例？</h2>
<p>选择宽高比不是技术问题，而是"你的内容在哪里展示、用户怎么看"的战略问题。</p>
<h3 data-id="heading-16">社交媒体内容创作者</h3>
<p><strong>Instagram全套</strong>：</p>
<ul>
<li>Story/Reels：9:16（全屏沉浸）</li>
<li>动态Feed：4:5（官方推荐，展示面积大）</li>
<li>旧版方形帖：1:1（经典格式，兼容性好）</li>
</ul>
<p><strong>小红书运营</strong>：</p>
<ul>
<li>首选：3:4（电商和产品展示标准）</li>
<li>次选：1:1（方形封面图）</li>
<li>可选：4:5（类似Instagram）</li>
</ul>
<p><strong>抖音/TikTok</strong>：</p>
<ul>
<li>必选：9:16（竖屏视频封面）</li>
<li>备选：1:1（话题配图）</li>
</ul>
<p><strong>YouTube</strong>：</p>
<ul>
<li>视频封面：16:9（标准）</li>
<li>Shorts封面：9:16（竖屏短视频）</li>
<li>社区帖子：1:1或16:9</li>
</ul>
<h3 data-id="heading-17">电商平台商家</h3>
<p><strong>淘宝/天猫</strong>：</p>
<ul>
<li>主图：1:1方形（800×800标准）</li>
<li>详情图：3:4竖屏（展示完整产品）</li>
<li>横幅图：16:9（活动Banner）</li>
</ul>
<p><strong>京东</strong>：</p>
<ul>
<li>商品主图：1:1</li>
<li>详情长图：可用3:4或2:3</li>
</ul>
<p><strong>拼多多</strong>：</p>
<ul>
<li>主图：1:1（强制要求）</li>
<li>详情：3:4推荐</li>
</ul>
<p><strong>跨境电商（Amazon/eBay）</strong> ：</p>
<ul>
<li>主图：1:1（国际通用）</li>
<li>Lifestyle图：4:3或16:9（场景展示）</li>
</ul>
<h3 data-id="heading-18">视频内容创作</h3>
<p><strong>长视频（&gt;1分钟）</strong> ：</p>
<ul>
<li>YouTube/B站：16:9标准</li>
<li>电影感内容：21:9超宽</li>
<li>教程录屏：16:9（配合1080p/1440p）</li>
</ul>
<p><strong>短视频（&lt;1分钟）</strong> ：</p>
<ul>
<li>抖音/快手：9:16必选</li>
<li>Instagram Reels：9:16</li>
<li>YouTube Shorts：9:16</li>
</ul>
<p><strong>直播封面</strong>：</p>
<ul>
<li>横屏直播（游戏、桌面）：16:9</li>
<li>竖屏直播（户外、才艺）：9:16</li>
</ul>
<h3 data-id="heading-19">游戏开发与设计</h3>
<p><strong>UI界面</strong>：</p>
<ul>
<li>手游UI：9:16（适配手机竖屏）或16:9（横屏游戏）</li>
<li>PC游戏UI：21:9（超宽屏）或16:9</li>
<li>卡牌/道具图标：1:1或5:4</li>
</ul>
<p><strong>场景概念图</strong>：</p>
<ul>
<li>横版游戏：16:9或21:9</li>
<li>竖版游戏：9:16</li>
<li>等距视角：1:1或5:4</li>
</ul>
<p><strong>营销素材</strong>：</p>
<ul>
<li>Steam商店横幅：16:9</li>
<li>应用商店截图：9:16（手游）</li>
<li>宣传海报：可选2:3或3:4</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77636d74823a4fb890b787d09f9cf59a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGFvWmhhbmdBSQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763773026&amp;x-signature=3h4P4%2Fk2SlScDv0aOokxZbB8QG0%3D" alt="场景应用推荐" loading="lazy"/></p>
<h2 data-id="heading-20">常见问题与解决方案：尺寸设置的5大坑</h2>
<h3 data-id="heading-21">问题1：设置了aspect_ratio但生成的还是1:1方形</h3>
<p><strong>现象</strong>：代码中明确设置<code>aspect_ratio="16:9"</code>，但生成的图片仍是正方形。</p>
<p><strong>原因分析</strong>：这是早期版本（gemini-2.5-flash-image-preview）的已知bug。根据Google AI Developers Forum的讨论，preview版本虽然接受aspect_ratio参数，但实际执行时可能忽略，始终生成1:1。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>确认使用的是正式版模型（2025年9月后发布）而不是preview版</li>
<li>检查SDK版本是否最新（<code>pip install --upgrade google-generativeai</code>）</li>
<li>如果仍无效，尝试在prompt中明确说明："生成16:9横屏比例的图片"</li>
<li>使用"参考图法"：上传一张16:9的空白图，prompt说"使用参考图的宽高比"</li>
</ol>
<h3 data-id="heading-22">问题2：无法设置精确像素尺寸（如必须1920×1080）</h3>
<p><strong>现象</strong>：需要生成精确1920×1080的图片，但API只支持设置比例不支持像素。</p>
<p><strong>原因分析</strong>：Gemini 2.5 Flash Image的设计哲学是"内容优先"。Google认为，对于AI生成图片，重要的是内容质量和比例协调，精确像素由模型自动优化。实际生成的分辨率通常在1024-2048px长边（取决于Nano Banana 1还是2）。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>先生成16:9比例的图片（模型自动决定像素，可能是1024×576或2048×1152）</li>
<li>使用图片处理工具upscale到目标尺寸（Photoshop、Python Pillow库、在线工具）</li>
<li>或使用专门支持精确尺寸的模型（如DALL-E 3可以指定1024×1024/1792×1024）</li>
</ol>
<p>代码示例（生成后upscale到1920×1080）：</p>
<h3 data-id="heading-23">问题3：不支持自定义宽高比（如7:5、2:1）</h3>
<p><strong>现象</strong>：需要生成2:1比例（特定设计需求），但API只接受官方的10种预设值。</p>
<p><strong>原因分析</strong>：Google为了保证生成质量和稳定性，只开放了经过充分测试的10种标准比例。自定义比例可能导致构图失衡、内容被裁剪等问题。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>选择最接近的标准比例生成（如需要2:1，用21:9=2.33:1接近）</li>
<li>生成后裁剪到目标比例（用图片处理工具）</li>
<li>或在prompt中强调："生成后裁剪到2:1，主体保持居中，两侧可留空"</li>
</ol>
<p>变通方法（prompt技巧）：</p>
<h3 data-id="heading-24">问题4：图片编辑后宽高比改变失败</h3>
<p><strong>现象</strong>：上传一张1:1的图片，prompt说"扩展到16:9"，但输出仍是1:1。</p>
<p><strong>原因分析</strong>：图片编辑模式下，如果prompt没有明确指示如何处理宽高比变化（扩展画布？裁剪？），模型可能默认保持原比例。</p>
<p><strong>解决方案</strong>：在prompt中明确说明扩展策略：</p>
<p>或者使用"参考空白图法"（社区验证有效）：</p>
<ol>
<li>创建一张16:9的透明PNG（用任何图片工具，或在线生成）</li>
<li>上传原图+透明PNG+prompt："使用第二张图片的宽高比，扩展第一张图片"</li>
</ol>
<h3 data-id="heading-25">问题5：批量生成时部分比例失败</h3>
<p><strong>现象</strong>：循环生成10种比例，其中2-3个返回错误或生成失败。</p>
<p><strong>原因分析</strong>：可能是rate limit（API调用过频）、某些比例的prompt兼容性问题、或网络波动。</p>
<p><strong>解决方案</strong>：添加重试机制和错误记录：</p>
<h2 data-id="heading-26">进阶技巧：多比例批量生成与成本优化</h2>
<h3 data-id="heading-27">技巧1：智能比例选择策略</h3>
<p>不要盲目生成全部10种比例，而是根据分发平台智能选择：</p>
<p>这种"按需生成"策略，相比盲目生成全部10种，能节省50%的API调用成本（5张×<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.039</mn><mo>=</mo></mrow><annotation encoding="application/x-tex">0.039=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.039</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span></span></span></span></span>0.195 vs 10张×<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.039</mn><mo>=</mo></mrow><annotation encoding="application/x-tex">0.039=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.039</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span></span></span></span></span>0.39）。</p>
<h3 data-id="heading-28">技巧2：使用API聚合平台降低成本</h3>
<p>对于需要大量生成不同尺寸图片的场景（如电商月生成1000+张产品图），使用laozhang.ai等API聚合平台可以降低成本。</p>
<p>这类平台聚合了200+AI模型，包括Gemini 2.5 Flash Image（Nano Banana），价格通常为官方的84折左右。虽然需要一定技术基础配置API endpoint和认证，但对于高频使用场景，成本优势明显。</p>
<p>计算示例：</p>
<ul>
<li>官方API：1000张×<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.039</mn><mo>=</mo></mrow><annotation encoding="application/x-tex">0.039=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.039</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span></span></span></span></span>39/月</li>
<li>聚合平台（84折）：1000张×<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.033</mn><mo>≈</mo></mrow><annotation encoding="application/x-tex">0.033≈</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.033</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">≈</span></span></span></span></span>33/月，省<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mi mathvariant="normal">/</mi><mtext>月，年省</mtext></mrow><annotation encoding="application/x-tex">6/月，年省</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">6/</span><span class="mord cjk_fallback">月，年省</span></span></span></span></span>72</li>
</ul>
<p>此外，聚合平台的优势是统一管理多个模型——你可以在Nano Banana（便宜）、DALL-E（质量稳定）、Midjourney（艺术风格）之间灵活切换，不需要管理多个API key。在代码中切换模型只需改一个参数：</p>
<h3 data-id="heading-29">技巧3：参考图法实现任意宽高比（变通方案）</h3>
<p>虽然API只支持10种预设比例，但社区发现了一个巧妙方法——使用"空白参考图"可以实现任意比例：</p>
<p><strong>原理</strong>：Nano Banana可以理解参考图的宽高比，并应用到生成图片上。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>用任何工具创建一张目标比例的纯色或透明图片（如2:1比例，2000×1000px）</li>
<li>将这张空白图作为参考图上传</li>
<li>Prompt说："使用参考图的宽高比生成{你的内容描述}"</li>
<li>模型会生成同比例的内容图片</li>
</ol>
<p>代码实现：</p>
<p>这个方法的成功率约80-90%（根据社区反馈），虽然不是100%可靠，但为需要特殊比例的场景提供了变通方案。</p>
<h3 data-id="heading-30">技巧4：成本监控与预算控制</h3>
<p>如果你的项目需要大量生成图片（日100+张），建议实现成本监控，避免超支：</p>
<p>这种主动的成本控制，避免了"不知不觉烧掉几百美元"的情况。</p>
<h2 data-id="heading-31">常见问题FAQ</h2>
<p><strong>Q1: 所有10种宽高比的价格都一样吗？</strong></p>
<p>是的，都是<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.039</mn><mi mathvariant="normal">/</mi><mtext>张（</mtext></mrow><annotation encoding="application/x-tex">0.039/张（</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">0.039/</span><span class="mord cjk_fallback">张（</span></span></span></span></span>30/百万输出tokens）。宽高比不影响定价，只影响生成的像素数（21:9的总像素可能比9:16多，但token消耗基本一致）。</p>
<p><strong>Q2: 可以在生成时同时指定多个宽高比吗？</strong></p>
<p>不能。单次API调用只能指定一个aspect_ratio。如果需要3个比例，必须调用API 3次（成本×3）。建议用批量脚本按需生成，避免浪费。</p>
<p><strong>Q3: 图片编辑（修改现有图片）可以改变宽高比吗？</strong></p>
<p>可以！上传原图+prompt说明如何扩展或裁剪+设置新的aspect_ratio即可。模型会智能处理——扩展时补充背景，裁剪时保留重点内容。</p>
<p><strong>Q4: 生成的图片实际分辨率是多少？</strong></p>
<p>Nano Banana 1代：长边约1024px（如16:9约1024×576） Nano Banana 2代：长边约2048px（如16:9约2048×1152）</p>
<p>具体分辨率由模型自动优化，你无法精确控制。如需更高分辨率，生成后upscale。</p>
<p><strong>Q5: 哪些平台对宽高比有强制要求？</strong></p>
<p><strong>严格要求</strong>（不符合会被拒绝或展示异常）：</p>
<ul>
<li>淘宝主图：必须1:1，800×800或以上</li>
<li>拼多多主图：必须1:1</li>
<li>微信公众号封面：建议2.35:1（900×383）</li>
</ul>
<p><strong>推荐但不强制</strong>（不符合会影响展示效果）：</p>
<ul>
<li>Instagram Story：推荐9:16，其他比例会有黑边</li>
<li>YouTube封面：推荐16:9，其他比例会被裁剪</li>
<li>小红书：推荐3:4或1:1，16:9横图展示效果差</li>
</ul>
<p><strong>Q6: 如果我只用一种比例（如9:16），有更便宜的方案吗？</strong></p>
<p>如果你的需求非常固定（只做抖音内容，永远只用9:16），可以考虑：</p>
<ol>
<li>使用Midjourney或DALL-E（虽然单张贵，但质量可能更稳定）</li>
<li>使用专门优化竖屏的模型（如某些专注TikTok的AI工具）</li>
<li>批量生成时谈量大优惠（部分API聚合平台对大客户有折扣）</li>
</ol>
<p>不过Nano Banana的$0.039/张已经很便宜（比DALL-E便宜95%），很难找到更低价且质量相当的方案。</p>
<p><strong>Q7: aspect_ratio设置会影响生成速度吗？</strong></p>
<p>几乎不影响。无论哪个比例，生成时间都在1-10秒（取决于prompt复杂度），差异&lt;1秒。倒是总像素数会影响网络传输时间——21:9图片文件更大，下载稍慢。</p>
<p><strong>Q8: 可以在prompt中用自然语言描述比例吗？</strong></p>
<p>可以作为辅助，但不如参数可靠。例如：</p>
<p>建议用方法2（参数明确指定），prompt专注描述内容而不是格式。</p>
<p><strong>Q9: 不同宽高比生成的图片质量有差异吗？</strong></p>
<p>理论上没有。模型对所有比例都经过训练和优化。但用户反馈显示，1:1和9:16（最常用）的成功率和质量略高（约92-95%），而21:9、5:4等较少用的比例偶尔会出现构图失衡（约85-88%成功率）。如果生成的21:9图片效果不理想，重新生成1-2次通常能解决。</p>
<p><strong>Q10: API聚合平台（laozhang.ai等）支持所有10种宽高比吗？</strong></p>
<p>大多数聚合平台完整支持Google官方的所有功能，包括10种宽高比。因为聚合平台只是"中转"API请求，参数直接传递给Google，功能与官方一致。使用前建议查看平台文档确认，或测试一下各个比例是否正常工作。</p>
<hr/>
<p>Gemini 2.5 Flash Image API的宽高比设置功能，将图像生成的灵活性提升了233%（从3种到10种）。对于内容创作者和开发者，这意味着可以用一个API适配所有主流平台——Instagram的9:16/4:5/1:1、YouTube的16:9、小红书的3:4、电商的1:1，无需切换工具或重复生成。</p>
<p>选择宽高比时，核心是理解"内容在哪展示、用户怎么看"。社交媒体优先竖屏（9:16、4:5）因为用户刷手机；视频内容优先横屏（16:9、21:9）因为观影习惯；电商优先3:4或1:1因为平台规范。掌握10种比例的应用场景，配合Python/JavaScript代码实现批量生成，可以让AI图像生成真正融入生产流程，提升效率的同时保证质量。</p>
<p>技术细节方面，记住三个要点：①aspect_ratio参数必须用官方的10种预设值②无法指定精确像素，只能控制比例③图片编辑也支持改变比例（通过prompt指导扩展或裁剪）。遇到问题时，优先检查SDK版本、模型ID是否正确，再考虑用"参考图法"或"prompt辅助"等变通方案。</p>
<p>最后强调，宽高比是工具不是目的。即使设置了完美的9:16竖屏比例，如果内容质量低（构图差、主题不清、细节粗糙），在抖音上也不会有流量。优先打磨内容创意和prompt质量，宽高比只是确保内容在目标平台"展示完整、体验最佳"的技术保障。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【解密源码】 RAGFlow 切分最佳实践- paper 篇]]></title>    <link>https://juejin.cn/post/7572408522437967907</link>    <guid>https://juejin.cn/post/7572408522437967907</guid>    <pubDate>2025-11-15T01:04:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572408522437967907" data-draft-id="7572390974460379136" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【解密源码】 RAGFlow 切分最佳实践- paper 篇"/> <meta itemprop="keywords" content="LLM,架构,Agent"/> <meta itemprop="datePublished" content="2025-11-15T01:04:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="常先森"/> <meta itemprop="url" content="https://juejin.cn/user/4388906148043879"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【解密源码】 RAGFlow 切分最佳实践- paper 篇
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4388906148043879/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    常先森
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T01:04:16.000Z" title="Sat Nov 15 2025 01:04:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>论文类文档（paper）是 RAG 应用中最具挑战性的解析类型之一。</p>
<p>与普通 pdf 或 ppt 不同的是，paper 通常包含复杂的版面结构：标题层级、摘要、公式、表格、图片、参考文献等，且跨页、双栏、脚注等情况极为常见。</p>
<p>在 RAGFlow 的源码中，paper 切分方案继承自 PdfParser 的核心逻辑，并针对学术论文场景进行了增强。本文将带你深入剖析其源码实现，了解 RAGFlow 如何实现从原始论文 pdf 到可用知识块（chunk）的高精度语义切分。</p>
<blockquote>
<p><em>Tips：想更系统地理解切分逻辑，可先阅读《naive parser 语义切块（PDF 篇）》。</em></p>
</blockquote>
<h2 data-id="heading-1">省流版</h2>
<p>RAGFlow 在解析论文类文档时，与处理普通 pdf 文档的思路一致，采用 <strong>DeepDOC 布局识别 + 多层文本语义切分</strong> 的组合方案，实现从版面识别 → 元信息抽取（标题/作者/摘要）→ 正文层级化切分 → Chunk 分词的完整流程。</p>
<p><strong>设计亮点</strong></p>
<ul>
<li><strong>语义层级切分</strong>：自动检测标题编号规则（如“第 X 节”、“1.2.3”）并按层级生成逻辑块；</li>
<li><strong>结构化抽取</strong>：精准提取标题、作者、摘要、章节与表格信息，形成标准结构化数据；</li>
<li><strong>自适应切块</strong>：基于章节层级动态合并文本，兼顾语义完整性与上下文连续性。</li>
</ul>
<h2 data-id="heading-2">手撕版</h2>
<h3 data-id="heading-3">1. 布局识别器</h3>
<p>与 naive parser 下 pdf 文档的处理一样，分为 DeepDOC 和 Plain Text 两种布局识别器。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> parser_config.get(<span class="hljs-string">"layout_recognize"</span>, <span class="hljs-string">"DeepDOC"</span>) == <span class="hljs-string">"Plain Text"</span>:
        pdf_parser = PlainParser()
    <span class="hljs-keyword">else</span>:
        pdf_parser = Pdf()
</code></pre>
<p>Plain Text 布局识别器实现请参考《naive parser 语义切块（pdf 篇）》 下【Plain Text 布局识别器】模块。</p>
<h3 data-id="heading-4">2. DeepDOC 布局识别器</h3>
<p>与《naive parser 语义切块（pdf 篇）》中相同，Pdf 继承基类 PdfParser。</p>
<pre><code class="hljs language-python" lang="python">pdf_parser = Pdf()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pdf</span>(<span class="hljs-title class_ inherited__">PdfParser</span>)
</code></pre>
<p>PdfParser 基类的核心功能在《naive parser 语义切块（PDF 篇）》中已有详细说明，这里作简要概述：</p>
<ul>
<li>
<p><strong>__images__</strong>：负责将 PDF 页面数字化，生成可结构化的页面图像数据，为后续的布局分析与表格提取奠定基础。</p>
</li>
<li>
<p><strong>_layouts_rec</strong>：基于页面图像与 OCR 文本框信息，执行每页的版面分析与坐标重建。</p>
</li>
<li>
<p><strong>_table_transformer_job</strong>：针对识别出的表格区域，提取和解析表格内容，实现表格结构化处理。</p>
</li>
<li>
<p><strong>_text_merge</strong>：通过规则合并相邻文本块，解决 OCR 输出中文本碎片化的问题。</p>
</li>
<li>
<p><strong>_concat_downward</strong>：按照阅读顺序（Y 坐标从上到下，X 坐标从左到右）对文本框进行排序，恢复自然的文本流。</p>
</li>
<li>
<p><strong>_filter_forpages</strong>：检测并过滤非正文页面，如目录页、致谢页等，以提升后续文本分析质量。</p>
</li>
<li>
<p><strong>_extract_table_figure</strong>：负责表格与图像的提取与输出，支持跨页表格合并及图像截取。</p>
</li>
<li>
<p><strong>__filterout_scraps</strong>：对碎片化文本进行二次清理与组装，进一步优化 OCR 文本的完整性。</p>
</li>
</ul>
<h4 data-id="heading-5">2.1 Pdf 类</h4>
<p>Pdf 类作为入口点，调用 PdfParser 中提供的功能实现整个复杂的文档处理流程，并记录了各阶段耗时，解析进度等信息，这点与 naive parser 下的 Pdf 类职能一致，<strong>但具体实现内容存在差异</strong>。</p>
<h5 data-id="heading-6">2.1.1 _line_tag</h5>
<p>这里需要先提到 PdfParser 中另外一个功能函数 _line_tag，它主要为文本框（bx）生成一个位置信息标签字符串，用于标识该文本框在所在 pdf 页中的具体位置。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_line_tag</span>(<span class="hljs-params">self, bx, ZM</span>):
    pn = [bx[<span class="hljs-string">"page_number"</span>]]
    top = bx[<span class="hljs-string">"top"</span>] - self.page_cum_height[pn[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>]
    bott = bx[<span class="hljs-string">"bottom"</span>] - self.page_cum_height[pn[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>]
    page_images_cnt = <span class="hljs-built_in">len</span>(self.page_images)
    <span class="hljs-keyword">if</span> pn[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= page_images_cnt:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
    <span class="hljs-comment"># 检测文本框是否跨页</span>
    <span class="hljs-keyword">while</span> bott * ZM &gt; self.page_images[pn[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>].size[<span class="hljs-number">1</span>]:
        bott -= self.page_images[pn[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>].size[<span class="hljs-number">1</span>] / ZM
        pn.append(pn[-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> pn[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= page_images_cnt:
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"@@{}\t{:.1f}\t{:.1f}\t{:.1f}\t{:.1f}##"</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">"-"</span>.join([<span class="hljs-built_in">str</span>(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pn]), bx[<span class="hljs-string">"x0"</span>], bx[<span class="hljs-string">"x1"</span>], top, bott)
</code></pre>
<p>对于复杂场景跨页文本框举例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># pdf 基础信息</span>
self.page_images = [Page1, Page2, Page3]  <span class="hljs-comment"># 共三页</span>
self.page_cum_height = [<span class="hljs-number">0</span>, <span class="hljs-number">1200</span>, <span class="hljs-number">2400</span>]    <span class="hljs-comment"># 每页累计高度（从0开始）</span>

<span class="hljs-comment"># 输入 bx 文本框位置信息，bx 跨页</span>
bx = {
    <span class="hljs-string">"page_number"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"x0"</span>: <span class="hljs-number">100.0</span>,
    <span class="hljs-string">"x1"</span>: <span class="hljs-number">300.0</span>,
    <span class="hljs-string">"top"</span>: <span class="hljs-number">2300.0</span>, <span class="hljs-comment"># 文本框顶部针对整个 pdf 垂直坐标</span>
    <span class="hljs-string">"bottom"</span>: <span class="hljs-number">2550.0</span>  <span class="hljs-comment"># 文本框底部针对整个 pdf 垂直坐标</span>
}

<span class="hljs-comment"># 输出</span>
<span class="hljs-meta">@@<span class="hljs-number">2</span>-<span class="hljs-number">3</span>	<span class="hljs-number">100.0</span>	<span class="hljs-number">300.0</span>	<span class="hljs-number">1100.0</span>	<span class="hljs-number">150.0</span></span><span class="hljs-comment">##</span>
<span class="hljs-comment"># 2-3 文本框所在页码</span>
<span class="hljs-comment"># 100.0	300.0 文本框左右水平坐标</span>
<span class="hljs-comment"># 1100.0 文本框顶部相较于 page2 顶部垂直坐标</span>
<span class="hljs-comment"># 150 文本框底部相较于 page3 顶部垂直坐标</span>
</code></pre>
<h5 data-id="heading-7">2.1.2 Pdf 主流程</h5>
<p>1）调用 PdfParser 中提供的功能进行内容提取和排序。</p>
<pre><code class="hljs language-python" lang="python"> <span class="hljs-comment"># 静态的 pdf 页面转换为可结构化数据 </span>
 self.__images__(
    filename <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> binary <span class="hljs-keyword">else</span> binary,
    zoomin,
    from_page,
    to_page,
    callback
)
<span class="hljs-comment"># 对文档每页的布局分析，和坐标重建</span>
self._layouts_rec(zoomin)
<span class="hljs-comment"># 表格数据内容提取</span>
self._table_transformer_job(zoomin)
<span class="hljs-comment"># 基于规则合并文本</span>
self._text_merge()
<span class="hljs-comment"># 提取表格，图片内容输出</span>
tbls = self._extract_table_figure(<span class="hljs-literal">True</span>, zoomin, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)
column_width = np.median([b[<span class="hljs-string">"x1"</span>] - b[<span class="hljs-string">"x0"</span>] <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> self.boxes])
<span class="hljs-comment"># 简单文本排序</span>
self._concat_downward()
<span class="hljs-comment"># 检测并过滤非正文页面</span>
self._filter_forpages()
</code></pre>
<p>2）文本前置处理，水平排序和处理文本空格。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> column_width &lt; self.page_images[<span class="hljs-number">0</span>].size[<span class="hljs-number">0</span>] / zoomin / <span class="hljs-number">2</span>:
    <span class="hljs-comment"># 水平排序</span>
    self.boxes = self.sort_X_by_page(self.boxes, column_width / <span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> self.boxes:
    b[<span class="hljs-string">"text"</span>] = re.sub(<span class="hljs-string">r"([\t 　]|\u3000){2,}"</span>, <span class="hljs-string">" "</span>, b[<span class="hljs-string">"text"</span>].strip())
</code></pre>
<p>3）如果启示 page 不是首页，默认前面的标题、作者、摘要等已经被提取过，直接返回正文 section 内容： (文本内容 + 位置标签, 布局类型)。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> from_page &gt; <span class="hljs-number">0</span>:
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"title"</span>: <span class="hljs-string">""</span>,
        <span class="hljs-string">"authors"</span>: <span class="hljs-string">""</span>,
        <span class="hljs-string">"abstract"</span>: <span class="hljs-string">""</span>,
        <span class="hljs-string">"sections"</span>: [(b[<span class="hljs-string">"text"</span>] + self._line_tag(b, zoomin), b.get(<span class="hljs-string">"layoutno"</span>, <span class="hljs-string">""</span>)) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> self.boxes <span class="hljs-keyword">if</span>
                        re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r"(text|title)"</span>, b.get(<span class="hljs-string">"layoutno"</span>, <span class="hljs-string">"text"</span>))],
        <span class="hljs-string">"tables"</span>: tbls
    }
</code></pre>
<p>4）从首页开始，提取标题，作者信息。这里默认这些信息位于文档开头，所以只在前 32 个文本框中进行提取。</p>
<pre><code class="hljs language-python" lang="python">title = <span class="hljs-string">""</span>
authors = []
i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">min</span>(<span class="hljs-number">32</span>, <span class="hljs-built_in">len</span>(self.boxes)-<span class="hljs-number">1</span>):
    b = self.boxes[i]
    i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> b.get(<span class="hljs-string">"layoutno"</span>, <span class="hljs-string">""</span>).find(<span class="hljs-string">"title"</span>) &gt;= <span class="hljs-number">0</span>:
        title = b[<span class="hljs-string">"text"</span>]
        <span class="hljs-keyword">if</span> _begin(title):
            title = <span class="hljs-string">""</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
            <span class="hljs-keyword">if</span> _begin(self.boxes[i + j][<span class="hljs-string">"text"</span>]):
                <span class="hljs-keyword">break</span>
            authors.append(self.boxes[i + j][<span class="hljs-string">"text"</span>])
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">break</span>
</code></pre>
<p>5）提取摘要，方案与提取标题基本相同。遍历前 32 个文本框，查找“Abstract”或“摘要”段落，若该段落足够长（字数或单词数超过阈值），就认为是完整摘要。</p>
<pre><code class="hljs language-python" lang="python">abstr = <span class="hljs-string">""</span>
i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">min</span>(<span class="hljs-number">32</span>, <span class="hljs-built_in">len</span>(self.boxes)):
    b = self.boxes[i]
    i += <span class="hljs-number">1</span>
    txt = b[<span class="hljs-string">"text"</span>].lower().strip()
    <span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">"(abstract|摘要)"</span>, txt):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(txt.split()) &gt; <span class="hljs-number">32</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(txt) &gt; <span class="hljs-number">64</span>:
            abstr = txt + self._line_tag(b, zoomin)
            <span class="hljs-keyword">break</span>
        txt = self.boxes[i][<span class="hljs-string">"text"</span>].lower().strip()
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(txt.split()) &gt; <span class="hljs-number">32</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(txt) &gt; <span class="hljs-number">64</span>:
            abstr = txt + self._line_tag(self.boxes[i], zoomin)
        i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">break</span>
</code></pre>
<p>6）返回最终结构化结果</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">return</span> {
    <span class="hljs-string">"title"</span>: title,
    <span class="hljs-string">"authors"</span>: <span class="hljs-string">" "</span>.join(authors),
    <span class="hljs-string">"abstract"</span>: abstr,
    <span class="hljs-string">"sections"</span>: [(b[<span class="hljs-string">"text"</span>] + self._line_tag(b, zoomin), b.get(<span class="hljs-string">"layoutno"</span>, <span class="hljs-string">""</span>)) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> self.boxes[i:] <span class="hljs-keyword">if</span>
                    re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r"(text|title)"</span>, b.get(<span class="hljs-string">"layoutno"</span>, <span class="hljs-string">"text"</span>))],
    <span class="hljs-string">"tables"</span>: tbls
}
<span class="hljs-comment"># 以下是结果示例</span>
{
  <span class="hljs-string">"title"</span>: <span class="hljs-string">"A Novel PDF Parsing Framework"</span>,
  <span class="hljs-string">"authors"</span>: <span class="hljs-string">"Alice Bob"</span>,
  <span class="hljs-string">"abstract"</span>: <span class="hljs-string">"This paper proposes ...@@1	50.0	520.0	300.0	900.0##"</span>,
  <span class="hljs-string">"sections"</span>: [
      (<span class="hljs-string">"Introduction@@2	100.0	400.0	80.0	220.0##"</span>, <span class="hljs-string">"title"</span>),
      (<span class="hljs-string">"In this paper, we propose ...@@2-3	120.0	480.0	200.0	150.0##"</span>, <span class="hljs-string">"text"</span>),
      ...
  ],
  <span class="hljs-string">"tables"</span>: [...]
}
</code></pre>
<h3 data-id="heading-8">3. 数据后处理</h3>
<p>从 Pdf 类实例化方法获取到结构化数据后，进行一系列的数据后处理，最终生成 chunk 数据。</p>
<p>1）标题，作者，表格分词。分词器实现可参考《分词器原理》。</p>
<pre><code class="hljs language-python" lang="python">doc = {<span class="hljs-string">"docnm_kwd"</span>: filename, <span class="hljs-string">"authors_tks"</span>: rag_tokenizer.tokenize(paper[<span class="hljs-string">"authors"</span>]),
        <span class="hljs-string">"title_tks"</span>: rag_tokenizer.tokenize(paper[<span class="hljs-string">"title"</span>] <span class="hljs-keyword">if</span> paper[<span class="hljs-string">"title"</span>] <span class="hljs-keyword">else</span> filename)}
doc[<span class="hljs-string">"title_sm_tks"</span>] = rag_tokenizer.fine_grained_tokenize(doc[<span class="hljs-string">"title_tks"</span>])
doc[<span class="hljs-string">"authors_sm_tks"</span>] = rag_tokenizer.fine_grained_tokenize(doc[<span class="hljs-string">"authors_tks"</span>])

res = tokenize_table(paper[<span class="hljs-string">"tables"</span>], doc, eng)
</code></pre>
<p>2）摘要内容处理。将内容类型标记为 “abstract” 等优化召回，同时处理摘要内容中的图片，位置，和对内容信息进行分词。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> paper[<span class="hljs-string">"abstract"</span>]:
    d = copy.deepcopy(doc)
    txt = pdf_parser.remove_tag(paper[<span class="hljs-string">"abstract"</span>])
    d[<span class="hljs-string">"important_kwd"</span>] = [<span class="hljs-string">"abstract"</span>, <span class="hljs-string">"总结"</span>, <span class="hljs-string">"概括"</span>, <span class="hljs-string">"summary"</span>, <span class="hljs-string">"summarize"</span>]
    d[<span class="hljs-string">"important_tks"</span>] = <span class="hljs-string">" "</span>.join(d[<span class="hljs-string">"important_kwd"</span>])
    d[<span class="hljs-string">"image"</span>], poss = pdf_parser.crop(
        paper[<span class="hljs-string">"abstract"</span>], need_position=<span class="hljs-literal">True</span>)
    add_positions(d, poss)
    tokenize(d, txt, eng)
    res.append(d)
</code></pre>
<p>3）正文层级识别。先检测文档标题使用的编号样式类别，后结合编号样式确定标题的层级深度。</p>
<pre><code class="hljs language-python" lang="python">sorted_sections = paper[<span class="hljs-string">"sections"</span>]
<span class="hljs-comment"># set pivot using the most frequent type of title,</span>
<span class="hljs-comment"># then merge between 2 pivot</span>
bull = bullets_category([txt <span class="hljs-keyword">for</span> txt, _ <span class="hljs-keyword">in</span> sorted_sections])
most_level, levels = title_frequency(bull, sorted_sections)
</code></pre>
<p><code>bullets_category</code> 主要是检测文档标题使用的编号样式类别，编号样式类别可能如下：</p>
<pre><code class="hljs language-python" lang="python">[[
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+(分?编|部分)"</span>,
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+章"</span>,
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+节"</span>,
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+条"</span>,
    <span class="hljs-string">r"[\(（][零一二三四五六七八九十百]+[\)）]"</span>,
], [
    <span class="hljs-string">r"第[0-9]+章"</span>,
    <span class="hljs-string">r"第[0-9]+节"</span>,
    <span class="hljs-string">r"[0-9]{,2}[\. 、]"</span>,
    <span class="hljs-string">r"[0-9]{,2}\.[0-9]{,2}[^a-zA-Z/%~-]"</span>,
    <span class="hljs-string">r"[0-9]{,2}\.[0-9]{,2}\.[0-9]{,2}"</span>,
    <span class="hljs-string">r"[0-9]{,2}\.[0-9]{,2}\.[0-9]{,2}\.[0-9]{,2}"</span>,
], [
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+章"</span>,
    <span class="hljs-string">r"第[零一二三四五六七八九十百0-9]+节"</span>,
    <span class="hljs-string">r"[零一二三四五六七八九十百]+[ 、]"</span>,
    <span class="hljs-string">r"[\(（][零一二三四五六七八九十百]+[\)）]"</span>,
    <span class="hljs-string">r"[\(（][0-9]{,2}[\)）]"</span>,
], [
    <span class="hljs-string">r"PART (ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN)"</span>,
    <span class="hljs-string">r"Chapter (I+V?|VI*|XI|IX|X)"</span>,
    <span class="hljs-string">r"Section [0-9]+"</span>,
    <span class="hljs-string">r"Article [0-9]+"</span>
], [
    <span class="hljs-string">r"^#[^#]"</span>,
    <span class="hljs-string">r"^##[^#]"</span>,
    <span class="hljs-string">r"^###.*"</span>,
    <span class="hljs-string">r"^####.*"</span>,
    <span class="hljs-string">r"^#####.*"</span>,
    <span class="hljs-string">r"^######.*"</span>,
]
]
</code></pre>
<p>检测出编号样式后，通过 <code>title_frequency</code> 确定整个文档最常出现的章节标题层级 <code>most_level</code>，作为切分基准；同时也获取整个文档所有标题等级列表 <code>levels</code>。</p>
<p>4）按照 <code>most_level</code> 切分基准对内容进行切分，<code>&lt;= most_level</code> 的内容会进行统一标记并<strong>与同级内容和上一级内容</strong>进行合并作为一个 chunk。</p>
<pre><code class="hljs language-python" lang="python">sec_ids = []
sid = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i, lvl <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(levels):
    <span class="hljs-keyword">if</span> lvl &lt;= most_level <span class="hljs-keyword">and</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lvl != levels[i - <span class="hljs-number">1</span>]:
        sid += <span class="hljs-number">1</span>
    sec_ids.append(sid)
    logging.debug(<span class="hljs-string">"{} {} {} {}"</span>.<span class="hljs-built_in">format</span>(lvl, sorted_sections[i][<span class="hljs-number">0</span>], most_level, sid))

chunks = []
last_sid = -<span class="hljs-number">2</span>
<span class="hljs-keyword">for</span> (txt, _), sec_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(sorted_sections, sec_ids):
    <span class="hljs-keyword">if</span> sec_id == last_sid:
        <span class="hljs-keyword">if</span> chunks:
            chunks[-<span class="hljs-number">1</span>] += <span class="hljs-string">"\n"</span> + txt
            <span class="hljs-keyword">continue</span>
    chunks.append(txt)
    last_sid = sec_id
</code></pre>
<p>5）使用分词器对 chunk 进行分词输出最终结果</p>
<pre><code class="hljs language-python" lang="python">res.extend(tokenize_chunks(chunks, doc, eng, pdf_parser))
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>