<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[一款悄然崛起的国产规则引擎，让业务编排效率提升 10 倍！]]></title>    <link>https://juejin.cn/post/7604080364354600987</link>    <guid>https://juejin.cn/post/7604080364354600987</guid>    <pubDate>2026-02-09T06:09:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364354600987" data-draft-id="7604301929120382985" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一款悄然崛起的国产规则引擎，让业务编排效率提升 10 倍！"/> <meta itemprop="keywords" content="Java,Spring Boot"/> <meta itemprop="datePublished" content="2026-02-09T06:09:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JavaGuide"/> <meta itemprop="url" content="https://juejin.cn/user/166781497383294"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一款悄然崛起的国产规则引擎，让业务编排效率提升 10 倍！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/166781497383294/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JavaGuide
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:09:44.000Z" title="Mon Feb 09 2026 06:09:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 Guide。今天来推荐一款非常优秀的国产规则引擎，说不定你曾经就用过。下面是正文。</p>
<p>你有没有接过那种祖传代码？一个几千行的 <code>if-else</code> 堡垒，改一行逻辑，要测半天。更糟的是，业务方今天说要"先 A 后 B"，明天又改成"A 和 B 并行，等 C 完成再接 D"，每次改流程都要重构代码。</p>
<p><strong>LiteFlow 是一个国产规则引擎</strong>，专门解决"业务逻辑耦合"问题。它把瀑布流式的代码拆成一个个独立组件，用一套 DSL 语法重新编排，改流程就像搭积木。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ef173b23a724ad297b703da3ec6b202~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=vEscLemN4GSNfsY1xAISRjx0Euo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">解决了什么问题？</h2>
<p>传统复杂业务系统的痛点：</p>
<ul>
<li><strong>改一处动全身</strong>：代码里到处是硬编码的流程判断，改个顺序要改好几个地方。</li>
<li><strong>难以热变更</strong>：业务流程调整需要重新发版，没法实时生效。</li>
<li><strong>组件复用难</strong>：每个业务场景都写一套逻辑，同样的代码在到处复制。</li>
</ul>
<p>LiteFlow 的核心思路是 <strong>"工作台模式"</strong> ：想象一个工厂流水线，n 个工人围着工作台，每个人只负责自己那道工序，完成就把半成品放回工作台，下一个人接着做。工人之间不需要沟通，只需要关心自己手头的活和工作台上的资源。</p>
<p>映射到代码世界：工人就是组件，工作台就是上下文，工序顺序就是规则配置。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a68ab8c79454bc284dec06b79439956~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=cdKrAvhjHaYekXH6YHFL5TB4LVY%3D" alt="" loading="lazy"/></p>
<p>下图是 LiteFlow 官方文档对核心能力（组件编排、实时热更替和复用）的图解：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6a68cc6d34084c6d927a0dab513405cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=%2FHEjGMqo%2BhCzTgvA8DacCDqUm6w%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">LiteFlow 是什么？</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d95a50ab2c0d4e9b989185c6bef547da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=StZzMVoCn2cs8JR8DkER8nzKh%2BU%3D" alt="" loading="lazy"/></p>
<p>LiteFlow 是一款<strong>国产开源的轻量级规则引擎框架</strong>，专注解决复杂业务逻辑的解耦与编排问题，支持 Spring Boot 2.x/3.x，最低 JDK 8 即可运行。</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li><strong>组件化拆分</strong>：把长链条的业务逻辑拆成独立组件，每个组件只做一件事。</li>
<li><strong>规则驱动编排</strong>：用简洁的 EL 表达式定义组件执行顺序，支持串行、并行、条件、循环等复杂逻辑。</li>
<li><strong>脚本组件支持</strong>：支持 Java、JavaScript、Groovy、QLExpress、Python、Lua、Aviator 等多种脚本语言，Java 脚本编译速度在 v2.15.3 版本后提升了 <strong>200 倍</strong>（2000 个脚本从 30 秒降到 150 毫秒）。</li>
<li><strong>热部署能力</strong>：规则和脚本可以存放在数据库、注册中心（Nacos、Etcd、Zookeeper），修改后实时生效，无需重启。</li>
<li><strong>可视化编排</strong>：支持 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fliupeiqiang%2FLiteFlowX" title="https://gitee.com/liupeiqiang/LiteFlowX" target="_blank" ref="nofollow noopener noreferrer">LiteFlowX</a> 可视化编排界面，拖拽就能设计流程。</li>
<li><strong>自带简单监控</strong>：框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。</li>
</ul>
<p>LiteFlow 的核心是<strong>基于 EL 表达式的规则解析引擎</strong>，在 v2.15.2 版本中，底层规则引擎从 QLExpress 3 全面升级到 QLExpress 4，带来性能提升：</p>























<table><thead><tr><th>测试指标</th><th>QL3 版本</th><th>QL4 版本</th><th>提升幅度</th></tr></thead><tbody><tr><td>编译阶段 TPS</td><td>2,739 ops</td><td>3,636 ops</td><td><strong>提升 32%</strong></td></tr><tr><td>上下文参数注入</td><td>55,826 ops</td><td>222,625 ops</td><td><strong>提升 300%</strong></td></tr></tbody></table>
<p>数据来源：LiteFlow 官方压测报告，采用 benchmark 框架，2 次预热、3 次执行取平均值。</p>
<p><strong>QLExpress</strong> 是由阿里巴巴开源的轻量级动态脚本引擎，目标是将业务逻辑从繁重的 Java 代码中解耦，变成可以动态执行的脚本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7293b321b8048f69f3293717c4de2e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=yNkB%2FOgWf%2FAePXdxP6%2B62JTwmro%3D" alt="" loading="lazy"/></p>
<p>LiteFlow 在今年的 Gitee 年度开源项目评选中获得了基础软件赛道第二名的成绩。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eca7ec93d363462ea260f6af4eb9c876~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=XqP7LY3va%2FfHZkBTWYmaSfsPmEw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">快速上手</h2>
<h3 data-id="heading-3">安装</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yomahub<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>liteflow-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.15.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>LiteFlow 支持 JDK 8 ~ JDK 25 全版本，但如果你用 JDK 9+，建议直接上 v2.15.0+ 版本，无需额外配置 JVM 参数。</p>
<h3 data-id="heading-4">配置规则文件</h3>
<p>在 <code>application.properties</code> 里指定规则文件位置：</p>
<pre><code class="hljs language-properties" lang="properties">liteflow.rule-source=config/flow.el.xml
</code></pre>
<p>然后在 <code>resources/config/flow.el.xml</code> 定义规则 <code>THEN(validateOrder, WHEN(checkStock, calcPrice), riskCheck, saveOrder);</code>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">flow</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">chain</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"orderChain"</span>&gt;</span>
        THEN(
            validateOrder,
            WHEN(checkStock, calcPrice),
            riskCheck,
            saveOrder
        );
    <span class="hljs-tag">&lt;/<span class="hljs-name">chain</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">flow</span>&gt;</span>
</code></pre>
<p>这段表达式定义了执行的拓扑结构：</p>
<ul>
<li><strong>THEN</strong>：串行执行，必须先执行完前面的节点，才能进入下一个。</li>
<li><strong>WHEN</strong>：并行执行，在此例中，<code>checkStock</code>（检查库存）和 <code>calcPrice</code>（计算价格）会同时开启异步线程执行，提升接口响应速度。</li>
</ul>
<p>规则含义：先校验订单 → 然后并行查库存和算价格 → 再做风险检查 → 最后保存订单。</p>
<h3 data-id="heading-5">定义组件</h3>
<p>通过实现 <code>NodeComponent</code>定义组件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@LiteflowComponent("validateOrder")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidateOrderCmp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeComponent</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 从上下文获取订单数据</span>
        <span class="hljs-type">OrderContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContextBean(OrderContext.class);
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> context.getOrder();

        <span class="hljs-comment">// 校验逻辑</span>
        <span class="hljs-keyword">if</span> (order.getAmount() &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"订单金额必须大于0"</span>);
        }

        <span class="hljs-comment">// 把结果放回上下文，供后续组件使用</span>
        context.setValid(<span class="hljs-literal">true</span>);
    }
}
</code></pre>
<ul>
<li><strong><code>@LiteflowComponent</code></strong> ：复合注解，将类声明为 Spring 的 Bean，并给组件起一个 ID（validateOrder），这个 ID 必须与 XML 文件中的名称对应。</li>
<li><strong><code>getContextBean</code></strong> ：LiteFlow 处理数据的精髓，流程中的所有组件共享一个（或多个）上下文对象，避免在方法间传递大量参数，实现逻辑解耦。</li>
</ul>
<p>LiteFlow 在 v2.8.0 后支持多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据 class 类型很方便的拿到。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 传入</span>
<span class="hljs-type">LiteflowResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> flowExecutor.execute2Resp(<span class="hljs-string">"chain1"</span>, 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);

<span class="hljs-comment">// 获取</span>
<span class="hljs-type">OrderContext</span> <span class="hljs-variable">orderContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContextBean(OrderContext.class);
<span class="hljs-type">UserContext</span> <span class="hljs-variable">userContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContextBean(UserContext.class);
<span class="hljs-type">SignContext</span> <span class="hljs-variable">signContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContextBean(SignContext.class);
</code></pre>
<p>同理定义其他组件（<code>checkStock</code>、<code>calcPrice</code>、<code>riskCheck</code>、<code>saveOrder</code>）。</p>
<h3 data-id="heading-6">执行流程</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> FlowExecutor flowExecutor;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-type">LiteflowResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> flowExecutor.execute2Resp(
            <span class="hljs-string">"orderChain"</span>,
            order,              <span class="hljs-comment">// 将数据作为初始参数</span>
            OrderContext.class  <span class="hljs-comment">// 让 LiteFlow 自动实例化上下文</span>
        );
    }
}
</code></pre>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fjavaguide.cn%2Fzhuanlan%2Finterview-guide.html" target="_blank" title="https://javaguide.cn/zhuanlan/interview-guide.html" ref="nofollow noopener noreferrer">《SpringAI 智能面试平台+RAG 知识库》</a>配套实战项目教程正在更新，涉及到 Prompt Engineering、大模型集成、RAG（检索增强生成）、高性能对象存储与向量数据库。后续的话，还会同步上 Agent 项目。</p>
<p>内容非常全面，非常适合想要实战 AI 项目或者准备 AI 大模型应用开发岗位面试的朋友，来一张刚写完的<strong>3.4w 字+35 道题目</strong>的 RAG 面试题总结，大家感受一下（点此链接了解： <a href="https://link.juejin.cn?target=https%3A%2F%2Fjavaguide.cn%2Fabout-the-author%2Fzhishixingqiu-two-years.html" target="_blank" title="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" ref="nofollow noopener noreferrer">星球</a>）：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e1222e759194be5a62fa2078bcab908~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YUd1aWRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222187&amp;x-signature=Pyy8QrUZR%2Bxt1bioeTghADwj5%2FQ%3D" alt="RAG 面试题" loading="lazy"/></p>
<h2 data-id="heading-7">使用场景</h2>
<h3 data-id="heading-8">场景一：电商价格引擎</h3>
<p>电商的价格计算通常涉及多个维度：原价、会员折扣、优惠券、满减活动、店铺优惠等。用 LiteFlow 可以把每个计算因子拆成独立组件，用规则灵活组合。</p>
<p><strong>规则示例</strong>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">chain</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"priceChain"</span>&gt;</span>
    THEN(
        getBasePrice,
        WHEN(
            memberDiscount,
            couponDiscount,
            activityDiscount
        ),
        finalPrice,
        savePrice
    );
<span class="hljs-tag">&lt;/<span class="hljs-name">chain</span>&gt;</span>
</code></pre>
<p>好处是：新增一种优惠类型，只需要加一个组件，然后在规则里配上位置，不用改现有代码。</p>
<h3 data-id="heading-9">场景二：复杂审批流程</h3>
<p>LiteFlow 不做"基于角色的审批流转"（那是 Flowable、Flowlong 这类工作流引擎的事），但它适合处理<strong>审批环节里的业务逻辑</strong>。</p>
<p>比如一个采购审批，需要：</p>
<ol>
<li>校验采购金额是否超预算</li>
<li>并行查询供应商库存和价格</li>
<li>根据金额走不同的风控规则</li>
<li>生成采购单</li>
</ol>
<p>这些逻辑用 LiteFlow 编排，比写在 Service 里要清晰。</p>
<h3 data-id="heading-10">场景三：数据清洗 ETL</h3>
<p>数据处理场景里，经常有多个清洗步骤：去重、格式转换、数据补全、质量检查。用 LiteFlow 可以把这些步骤组件化，根据不同数据源配置不同规则。</p>
<h3 data-id="heading-11">场景四：实时风控决策</h3>
<p>风控规则变化频繁，用脚本组件 + 规则热部署，可以在不停机的情况下调整规则。比如："最近欺诈多了，把某类交易的阈值从 1000 降到 500"，改一下脚本配置就行。</p>
<h2 data-id="heading-12">EL 规则语法</h2>
<p>LiteFlow 的 EL 语法是其核心竞争力，十分钟就能上手，但能编排出非常复杂的流程。</p>
<h3 data-id="heading-13">基本语法</h3>
<p><strong>串行（THEN/SER）</strong>：按顺序执行</p>
<pre><code class="hljs language-xml" lang="xml">THEN(a, b, c, d)
<span class="hljs-comment">&lt;!-- 或者用语义更明确的 SER --&gt;</span>
SER(a, b, c, d)
</code></pre>
<p><strong>并行（WHEN/PAR）</strong>：同时执行</p>
<pre><code class="hljs language-xml" lang="xml">WHEN(a, b, c)
<span class="hljs-comment">&lt;!-- 或者用 PAR --&gt;</span>
PAR(a, b, c)
</code></pre>
<p><strong>嵌套组合</strong>：</p>
<pre><code class="hljs language-xml" lang="xml">THEN(
    a,
    WHEN(b, THEN(c, d)),
    e
)
</code></pre>
<p>规则含义：先执行 a → 然后并行执行 b 和"先 c 后 d" → 最后执行 e。</p>
<h3 data-id="heading-14">高级特性</h3>
<p><strong>忽略错误（ignoreError）</strong>：</p>
<pre><code class="hljs language-xml" lang="xml">THEN(
    a,
    WHEN(b, c, d).ignoreError(true),
    e
)
</code></pre>
<p>即使 b、c、d 中有组件报错，e 仍会执行。</p>
<p><strong>任一完成则继续（any）</strong>：</p>
<pre><code class="hljs language-xml" lang="xml">THEN(
    a,
    WHEN(b, c, d).any(true),
    e
)
</code></pre>
<p>b、c、d 中任何一个先完成，就忽略其他继续往下走。</p>
<p><strong>指定必须等待的节点（must）</strong>：</p>
<pre><code class="hljs language-xml" lang="xml">WHEN(b, c, d).must(b, c)
</code></pre>
<p>b、c 必须等执行完，d 如果还没完就忽略。</p>
<p><strong>按比例完成（percentage）</strong>：</p>
<pre><code class="hljs language-xml" lang="xml">WHEN(a, b, c, d, e).percentage(0.6)
</code></pre>
<p>5 个组件里随机执行 3 个（5 × 0.6 = 3），完成就继续。</p>
<h2 data-id="heading-15">不适合什么场景？</h2>
<ul>
<li><strong>审批流转</strong>：LiteFlow 只做基于逻辑的流转，不做基于角色任务的流转。如果要实现"A 审批完传给 B，B 审批完传给 C"这类场景，应该用 Flowable 或 Flowlong。</li>
<li><strong>简单业务</strong>：如果一个流程只有 2-3 个步骤，且基本不会变，上规则引擎可能有点杀鸡用牛刀。</li>
<li><strong>超大规模并行计算</strong>：如果并行组件达到成百上千个，且涉及极其复杂的线程调度，LiteFlow 虽然能做，但它更偏向业务流程编排，而非大数据分布式计算引擎（如 Spark/Flink）。</li>
</ul>
<h2 data-id="heading-16">与其他方案对比</h2>





















































<table><thead><tr><th>对比维度</th><th>LiteFlow</th><th>自己写 if-else</th><th>Flowable/Flowlong</th></tr></thead><tbody><tr><td><strong>学习曲线</strong></td><td>低（EL 语法简单）</td><td>最低（原生 Java）</td><td>中（需理解 BPMN）</td></tr><tr><td><strong>流程灵活性</strong></td><td>高（规则驱动）</td><td>低（硬编码）</td><td>中（需重新部署）</td></tr><tr><td><strong>热部署</strong></td><td>✅ 支持</td><td>❌ 需要发版</td><td>✅ 支持</td></tr><tr><td><strong>脚本支持</strong></td><td>✅ 多种语言</td><td>❌ 无</td><td>⚠️ 有限支持</td></tr><tr><td><strong>适用场景</strong></td><td>复杂业务逻辑编排</td><td>简单流程</td><td>审批流转</td></tr><tr><td><strong>性能</strong></td><td>高（8.6 万+ TPS）</td><td>取决于实现</td><td>中（有状态机开销）</td></tr><tr><td><strong>国产支持</strong></td><td>✅ 国产</td><td>N/A</td><td>⚠️ Flowlong 国产</td></tr></tbody></table>
<h2 data-id="heading-17">总结</h2>
<p>LiteFlow 把复杂业务逻辑从"面条代码"变成了"搭积木"，改流程不再动全身，尤其适合那些<strong>业务规则频繁变化、步骤多且有并行需求</strong>的系统。</p>
<p><strong>脚本组件性能</strong>：v2.15.3 版本把 Java 脚本编译速度提升了 <strong>200 倍</strong>，主要是因为该版本对 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fnoear%2Fliquor" title="https://gitee.com/noear/liquor" target="_blank" ref="nofollow noopener noreferrer">Liquor</a> 批量编译特性的支持。Liquor 是一款源自 Arthas 核心、支持 "jar in jar" 且轻量的 Java 动态编译与脚本工具，能让开发者在运行时以接近原生的性能灵活执行 Java 代码。</p>
<p><strong>适合人群</strong>：</p>
<ul>
<li>饱受 <code>if-else</code> 嵌套困扰的后端开发者</li>
<li>需要频繁调整业务流程的系统（电商、金融、风控）</li>
<li>想把业务逻辑从代码里剥离出来的架构师</li>
</ul>
<p><strong>使用建议</strong>：</p>
<ul>
<li>先从一个简单的流程开始，别一上来就搞最复杂的</li>
<li>组件拆分要合理：每个组件只做一件事，做好一件事</li>
<li>规则文件记得做版本管理，出了问题好回滚</li>
<li>如果用脚本组件，建议用 Java 脚本（<code>liteflow-script-javax-pro</code>），性能最好</li>
</ul>
<p>Gitee 地址：<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fdromara%2FliteFlow" target="_blank" title="https://gitee.com/dromara/liteFlow" ref="nofollow noopener noreferrer">gitee.com/dromara/lit…</a></strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零开始学Flink：Flink SQL 窗口(Window)操作详解]]></title>    <link>https://juejin.cn/post/7604155045236064291</link>    <guid>https://juejin.cn/post/7604155045236064291</guid>    <pubDate>2026-02-09T05:59:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604155045236064291" data-draft-id="7603959423129387008" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零开始学Flink：Flink SQL 窗口(Window)操作详解"/> <meta itemprop="keywords" content="大数据,Flink,SQL"/> <meta itemprop="datePublished" content="2026-02-09T05:59:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码匠心"/> <meta itemprop="url" content="https://juejin.cn/user/1697301684826952"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零开始学Flink：Flink SQL 窗口(Window)操作详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1697301684826952/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码匠心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:59:27.000Z" title="Mon Feb 09 2026 05:59:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在上一篇 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fz9glZrPCsheBk7bxlmZnUg" target="_blank" title="https://mp.weixin.qq.com/s/z9glZrPCsheBk7bxlmZnUg" ref="nofollow noopener noreferrer">Flink SQL 极简入门</a> 中，我们体验了 Flink SQL 的基础用法。但在流处理中，最核心、最迷人（也最让人头秃）的概念莫过于<strong>时间</strong>和<strong>窗口（Window）</strong>。</p>
<p>你可能经常听到这样的业务需求：</p>
<ul>
<li>“每 5 分钟统计一次订单总量”</li>
<li>“实时统计过去 1 小时内的热门商品，每 10 秒更新一次”</li>
<li>“每天 0 点到当前时刻的累计 PV”</li>
</ul>
<p>这些需求都离不开<strong>窗口</strong>。今天，我们就来深入 Flink SQL 的窗口机制，看看它是如何驯服无限数据流的。</p>
<h2 data-id="heading-0">什么是窗口 (Window)？</h2>
<p>流数据（Stream）是无限的，像水流一样源源不断。我们无法计算“无限流”的总和（因为永远算不完）。为了计算，我们需要把无限的流“切”成有限的块，这个“切”的操作就是<strong>开窗（Windowing）</strong>。</p>
<p>在 Flink SQL 中，窗口主要用于将时间序列上的数据分桶，然后在桶内进行聚合计算（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>）。</p>
<h2 data-id="heading-1">新一代标准：Window TVF</h2>
<p>在 Flink 1.13 之前，我们主要使用 <code>GROUP WINDOW</code>（如 <code>TUMBLE(rowtime, ...)</code> 在 GROUP BY 子句中）。但从 Flink 1.13 开始，官方推荐使用 <strong>Window TVF (Table-Valued Functions)</strong>。</p>
<p>Window TVF 符合 SQL 2016 标准，语法更自然，功能更强大（支持 TopN、去重等复杂操作）。本文将以 <strong>Window TVF</strong> 为主进行讲解。</p>
<p>核心语法结构通常如下：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> window_start, window_end, <span class="hljs-built_in">SUM</span>(price)
<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span>(
    <span class="hljs-comment">-- 窗口函数</span>
    TUMBLE(<span class="hljs-keyword">TABLE</span> my_table, DESCRIPTOR(ts), <span class="hljs-type">INTERVAL</span> <span class="hljs-string">'5'</span> <span class="hljs-keyword">MINUTE</span>)
)
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> window_start, window_end;
</code></pre>
<h2 data-id="heading-2">三大核心窗口类型</h2>
<h3 data-id="heading-3">1. 滚动窗口 (Tumble Window)</h3>
<p><strong>特点</strong>：窗口大小固定，窗口之间<strong>不重叠</strong>，首尾相接。
<strong>场景</strong>：每隔 5 分钟统计一次。</p>
<p><img src="https://pic-1258258471.cos.ap-nanjing.myqcloud.com/img/tumbling-windows.png" alt="Tumble Window" loading="lazy"/></p>
<p><strong>语法</strong>：
<code>TUMBLE(TABLE data, DESCRIPTOR(time_col), INTERVAL '10' MINUTE)</code></p>
<h3 data-id="heading-4">2. 滑动窗口 (Hop Window)</h3>
<p><strong>特点</strong>：窗口大小固定，但窗口之间<strong>可以重叠</strong>。它有两个参数：</p>
<ol>
<li><strong>Window Size (窗口大小)</strong>：统计多长时间的数据（如“过去 1 小时”）。</li>
<li><strong>Window Slide (滑动步长)</strong>：多久更新一次结果（如“每 5 分钟”）。</li>
</ol>
<p><strong>场景</strong>：每 5 分钟，统计过去 1 小时的 PV。</p>
<p><img src="https://pic-1258258471.cos.ap-nanjing.myqcloud.com/img/sliding-windows.png" alt="Hop Window" loading="lazy"/></p>
<p><strong>语法</strong>：
<code>HOP(TABLE data, DESCRIPTOR(time_col), INTERVAL '5' MINUTE, INTERVAL '1' HOUR)</code>
<em>注意：参数顺序是先 Slide (步长)，后 Size (大小)。</em></p>
<h3 data-id="heading-5">3. 累积窗口 (Cumulate Window)</h3>
<p><strong>特点</strong>：这是 Flink 特有的窗口，用于解决“每天 0 点至今的累计值”这类需求。它会按步长输出一个个不断变大的窗口，直到达到最大窗口大小。</p>
<p><strong>场景</strong>：每天的实时累计销售额（每 10 分钟更新一次看到当天的累计值）。</p>
<p><img src="https://pic-1258258471.cos.ap-nanjing.myqcloud.com/img/cumulating-windows.png" alt="Cumulate Window" loading="lazy"/></p>
<p><strong>语法</strong>：
<code>CUMULATE(TABLE data, DESCRIPTOR(time_col), INTERVAL '10' MINUTE, INTERVAL '1' DAY)</code></p>
<hr/>
<h2 data-id="heading-6">实战：处理“过去 5 分钟的订单总额”</h2>
<p>让我们回到开头的经典需求。假设我们有一个订单流 <code>orders</code>。</p>
<h3 data-id="heading-7">0. 准备数据环境</h3>
<p>首先，我们启动 SQL Client</p>
<pre><code class="hljs language-bash" lang="bash">./bin/sql-client.sh
</code></pre>
<p>创建一个模拟的订单源表（使用 DataGen 连接器）：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (
    order_id <span class="hljs-type">INT</span>,
    price <span class="hljs-keyword">DOUBLE</span>,
    order_time <span class="hljs-type">TIMESTAMP</span>(<span class="hljs-number">3</span>),
    <span class="hljs-comment">-- 定义水位线，基于 order_time，延迟 0 秒</span>
    WATERMARK <span class="hljs-keyword">FOR</span> order_time <span class="hljs-keyword">AS</span> order_time <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">SECOND</span>
) <span class="hljs-keyword">WITH</span> (
    <span class="hljs-string">'connector'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'datagen'</span>,
    <span class="hljs-string">'rows-per-second'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>,
    <span class="hljs-string">'fields.price.min'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'10'</span>,
    <span class="hljs-string">'fields.price.max'</span> <span class="hljs-operator">=</span> <span class="hljs-string">'100'</span>
);
</code></pre>
<h3 data-id="heading-8">需求一：每 5 分钟，统计该 5 分钟内的订单总额</h3>
<p>这是一个典型的<strong>滚动窗口 (Tumble)</strong>。比如 12:00-12:05 一个结果，12:05-12:10 一个结果。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    window_start, 
    window_end, 
    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_orders, 
    <span class="hljs-built_in">SUM</span>(price) <span class="hljs-keyword">as</span> total_amount
<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span>(
    TUMBLE(<span class="hljs-keyword">TABLE</span> orders, DESCRIPTOR(order_time), <span class="hljs-type">INTERVAL</span> <span class="hljs-string">'5'</span> <span class="hljs-keyword">MINUTE</span>)
)
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> window_start, window_end;
</code></pre>
<p><strong>运行结果示例</strong>：
<img src="https://pic-1258258471.cos.ap-nanjing.myqcloud.com/img/20260209105540374.png" alt="5分钟内订单总额" loading="lazy"/></p>
<h3 data-id="heading-9">需求二：实时统计“过去 5 分钟”的订单总额，每 1 分钟更新一次</h3>
<p>这是一个典型的<strong>滑动窗口 (Hop)</strong>。</p>
<ul>
<li>窗口大小：5 分钟</li>
<li>滑动步长：1 分钟</li>
</ul>
<p>这样，12:00 输出 [11:55, 12:00] 的数据；12:01 输出 [11:56, 12:01] 的数据。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> 
    window_start, 
    window_end, 
    <span class="hljs-built_in">SUM</span>(price) <span class="hljs-keyword">as</span> total_amount
<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span>(
    HOP(<span class="hljs-keyword">TABLE</span> orders, DESCRIPTOR(order_time), <span class="hljs-type">INTERVAL</span> <span class="hljs-string">'1'</span> <span class="hljs-keyword">MINUTE</span>, <span class="hljs-type">INTERVAL</span> <span class="hljs-string">'5'</span> <span class="hljs-keyword">MINUTE</span>)
)
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> window_start, window_end;
</code></pre>
<p><strong>运行结果示例</strong>：
<img src="https://pic-1258258471.cos.ap-nanjing.myqcloud.com/img/20260209105946469.png" alt="过去5分钟订单总额" loading="lazy"/></p>
<p><strong>注意</strong>：
<code>HOP</code> 函数的参数中，<strong>第一个时间是滑动步长 (Slide)</strong>，<strong>第二个时间是窗口大小 (Size)</strong>。千万别搞反了！
<code>INTERVAL '1' MINUTE</code> = Slide (更新频率)
<code>INTERVAL '5' MINUTE</code> = Size (统计范围)</p>
<h2 data-id="heading-10">总结</h2>
<p>Flink SQL 的 Window TVF 极大地简化了窗口聚合的写法。</p>
<ul>
<li><strong>TUMBLE</strong>: 规规矩矩，互不干扰（分批统计）。</li>
<li><strong>HOP</strong>: 藕断丝连，频繁更新（移动平均/最近 N 分钟）。</li>
<li><strong>CUMULATE</strong>: 聚沙成塔，越积越多（日报/大屏累计）。</li>
</ul>
<p>掌握了这三种窗口，你就能覆盖 90% 的实时统计需求了。</p>
<p>下一篇，我们将挑战更复杂的场景：<strong>双流 JOIN</strong>，看看当“订单流”遇到“用户流”，Flink 该如何处理？</p>
<hr/>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fblog.daimajiangxin.com.cn" target="_blank" title="http://blog.daimajiangxin.com.cn" ref="nofollow noopener noreferrer">原文来自</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[在线接收国外验证码的虚拟号码服务平台，支持API二次开发~]]></title>    <link>https://juejin.cn/post/7604084016510894121</link>    <guid>https://juejin.cn/post/7604084016510894121</guid>    <pubDate>2026-02-09T06:17:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510894121" data-draft-id="7600602502633488425" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在线接收国外验证码的虚拟号码服务平台，支持API二次开发~"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2026-02-09T06:17:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一念杂记"/> <meta itemprop="url" content="https://juejin.cn/user/3386151546131533"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在线接收国外验证码的虚拟号码服务平台，支持API二次开发~
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3386151546131533/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一念杂记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:17:35.000Z" title="Mon Feb 09 2026 06:17:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>前几天由于SMS-Active平台要停服了，分享了一下如何将剩余的余额转移到新的平台。</p>
<p>今天分享的就是新的平台的简单使用~</p>
<h2 data-id="heading-0">HeroSMS是什么</h2>
<p>HeroSMS是一个可以在线接收国外手机验证码的平台，同时支持使用平台提供的API进行二次开发，搭建一个类似平台或者利用提供的服务做功能扩展。</p>
<p>可以说HeroSMS的前身就是SMS-Active平台，毕竟官方的介绍就是：</p>
<p><strong>我们基于市场领导者 SMS-Activate 的平台进行升级优化。验证码即时送达，数据传输全程加密保护；</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b62b693339ba45908f0190c9712469bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=hqSf%2B3eoNvBhYzPRTosweji7DG4%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">HeroSMS的特点</h2>
<ul>
<li>支持全球超过180个国家的验证码接收服务</li>
<li>每日可提供超过50万个号码供使用</li>
<li>提供全面的API服务，支持二次开发</li>
<li>支持超过700个常用站点或者应用程序的验证码接收服务</li>
<li>支持加密货币直接充值</li>
<li>按等级收费，等级越高费用越低，适合大量需求用户</li>
<li>支持拉新赚钱</li>
<li>......</li>
</ul>
<h2 data-id="heading-2">HeroSMS的适用场景</h2>
<ul>
<li>无海外SIM卡，注册海外网站和应用账户</li>
<li>临时接收验证码，不想暴露真实手机号</li>
<li>规避隐私泄露</li>
<li>批量注册平台账户</li>
<li>注册测试账户</li>
<li>针对平台拉新获取奖励</li>
<li>二次开发验证码接收服务</li>
<li>......</li>
</ul>
<h2 data-id="heading-3">HeroSMS注册&amp;登录</h2>
<p>这一步其实就是傻瓜式操作就行了，点击右上角的登录按钮，有账户输入账户密码，真人验证后登录即可，没有账户就点击下方注册文字按钮跳转注册，账号注册后登录即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eba4336308b248999fb86a89174f2b59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=nZDOyYusMTGm4jjy%2BDymcl153hc%3D" alt="" loading="lazy"/><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf949d52306d4cad85d2ceab40fdcbbe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=1nB8w8rKOLTRCd0cYhA%2FIcWQNKw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">接收短信</h2>
<p>点击主页“<strong>接收短信</strong>”按钮，进入页面选择你要收取短信的目标平台和国家地区的号码。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d299030c91d446c196d3c1f87b44f954~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=av%2BwJIlFPZJBbjZJOY6nkmU%2Ff0I%3D" alt="" loading="lazy"/><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3472267ebc0344559915002d9a41465f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=wzIs1DJv33bbI7RpeIRyc6qhaTU%3D" alt="" loading="lazy"/></p>
<p>点击数量右侧的图标即可完成选择，选择后如果要取消可以在2分钟后取消选择的号码。而每次选择的号码接收的有效期是20分钟，所以需要你在20分钟内，使用目标平台向目标号码发送验证码才行。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fa6a6ada8964f1b96d23dba183f273d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=sio0MmuxjBq23yx5AvQcYAuLJM8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">使用API</h2>
<p>HeroSMS支持使用API进行二开，使用方式点击首页的“<strong>获取API密钥</strong>”，进入API秘钥获取页面获取后续API使用时需要用到的密钥信息。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/49a4d7faddd145baabb6f4f3f1b1014c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=8Pc5jjlpobmd8DcDMKa8LUN8X38%3D" alt="" loading="lazy"/><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba957a6e447a432ca1c5ef47afa3539a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=fN3OgYxIbr4QS1Ib%2FvQnsCOGOrk%3D" alt="" loading="lazy"/></p>
<p>点击“<strong>生成API密钥</strong>”按钮，平台会将密钥获取链接通过邮件发送到你账户绑定的邮箱中。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab3b1da4e6f84b29b5abad61ae7cd02a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=z5Js6Ovx0lHJAc1HU%2BASDfJYfno%3D" alt="" loading="lazy"/></p>
<p>点击邮件中的“获取API密钥”按钮就可以查看到你的密钥信息了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3dea3da0e4514f63a4e91513251752d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=nENFW22G1txFba1DKKIgN4oXTko%3D" alt="" loading="lazy"/></p>
<p>HeroSMS提供了较为完善的API接口供使用，点击主页的“<strong>API</strong>”选项即可进入API信息页面了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce418bbd6a684dfeb08c91920259ea68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=FZIERhksTqAsbw2z4%2FUrXnnVGgA%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">账户充值</h2>
<p>登录后点击右上角的充值按钮就可以进入充值流程，支持支付宝微信哟~</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29706e32efc1493e85557aacabe56803~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5b-15p2C6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222655&amp;x-signature=IwmaEW8Te%2FS1CBxvHV32fnCehaQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">最后</h2>
<p>稳定好用的验证码收取平台不多了，不论是前身的SMS-Active还是现在的HeroSMS，个人认为都还是比较稳定好用的平台，如果你有需要可以试试~</p>
<h2 data-id="heading-8">更多精彩内容</h2>
<p><a href="https://juejin.cn/post/7597311768730533888" target="_blank" title="https://juejin.cn/post/7597311768730533888">白嫖福利来了，免费虚拟主机服务器领取详细教程它又来了</a></p>
<p><a href="https://juejin.cn/post/7595472747455905807" target="_blank" title="https://juejin.cn/post/7595472747455905807">实测有效！手把手教你免费领一台服务器，程序员/博主必备</a></p>
<p><a href="https://juejin.cn/post/7459816593230397494" target="_blank" title="https://juejin.cn/post/7459816593230397494">旧Android手机改个人服务器，不需要root</a></p>
<p><a href="https://juejin.cn/post/7467043353399672883" target="_blank" title="https://juejin.cn/post/7467043353399672883">旧Android手机改个人服务器，不需要root（2）——内网穿透</a></p>
<p><a href="https://juejin.cn/post/7472305493501247503" target="_blank" title="https://juejin.cn/post/7472305493501247503">手机秒变无线移动硬盘，用Samba轻松实现高速文件共享、远程编辑！</a></p>
<p><a href="https://juejin.cn/post/7480797795785949184" target="_blank" title="https://juejin.cn/post/7480797795785949184">Windows密码忘记了咋办？1分钟快速破解和修改指南来了</a></p>
<p><a href="https://juejin.cn/post/7540184817918476329" target="_blank" title="https://juejin.cn/post/7540184817918476329">【免费可商用系列】1小时快速完成专属于你的网站&amp;小程序&amp;APP&amp;后台管理系统搭建，你值得拥有~</a></p>
<p><a href="https://juejin.cn/post/7555464418449768475" target="_blank" title="https://juejin.cn/post/7555464418449768475">【完全免费】超级爽的免费开源手机电脑投屏控制神器推荐（3）</a></p>
<p><a href="https://juejin.cn/post/7563209548392316954" target="_blank" title="https://juejin.cn/post/7563209548392316954">【免费使用】常用几款远程控制工具汇总对比，总有一款适合你~</a></p>
<p><a href="https://juejin.cn/post/7563976534441082914" target="_blank" title="https://juejin.cn/post/7563976534441082914">小白也会的旧手机一键安装Widnows系统，让你的手机重获新生</a></p>
<p><a href="https://juejin.cn/post/7571829822339924019" target="_blank" title="https://juejin.cn/post/7571829822339924019">【完全免费】不用服务器、不买域名！免费搭建专属网站，新手也能 10 分钟搞定</a></p>
<p><a href="https://juejin.cn/post/7587342664077475855" target="_blank" title="https://juejin.cn/post/7587342664077475855">【实战系列】一篇文章教你如何快速使用LineageOS编译你想要的Android版本系统（附模拟器镜像编译、启动、移植实例）</a></p>
<p><a href="https://juejin.cn/post/7588022226738905138" target="_blank" title="https://juejin.cn/post/7588022226738905138">【实战系列】快速使用LineageOS自定义你的手机系统（附小米6固件编译步骤）</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端性能杀手竟然不是JS?图片优化才是绝大多数人忽略的"降本增效"方案]]></title>    <link>https://juejin.cn/post/7604045354070638626</link>    <guid>https://juejin.cn/post/7604045354070638626</guid>    <pubDate>2026-02-09T06:03:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604045354070638626" data-draft-id="7603959423129419776" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端性能杀手竟然不是JS?图片优化才是绝大多数人忽略的&quot;降本增效&quot;方案"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T06:03:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户3905133219288"/> <meta itemprop="url" content="https://juejin.cn/user/3609051079121550"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端性能杀手竟然不是JS?图片优化才是绝大多数人忽略的"降本增效"方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3609051079121550/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户3905133219288
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:03:58.000Z" title="Mon Feb 09 2026 06:03:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    34
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>咱们先聊个扎心的事实:</p>
<p>你花三周时间把 Webpack 配置调到极致,Code Splitting 拆得比饺子馅还细,Tree Shaking 摇得比筛子还勤,结果首屏加载时间从 3.2 秒降到了 2.9 秒。你正准备庆祝的时候,产品经理给首屏 Banner 换了一张"超清大图",一下子又回到了 4.1 秒。</p>
<p>这不是段子,这是字节、阿里、腾讯的前端天天遇到的真实场景。</p>
<p><strong>图片才是现代 Web 应用里最重的资源,没有之一。</strong></p>
<p>但绝大多数前端工程师对图片优化的认知还停留在"用 WebP"、"开启 CDN 压缩"这种表层操作。真正能把图片优化做到极致的,往往是那些理解浏览器渲染机制、懂网络协议、会写 JavaScript 运行时优化的"杂家"。
今天这篇文章,咱们就从 <strong>JavaScript 的视角</strong>来重新审视图片优化,用代码把那些模糊的"最佳实践"变成可落地的工程方案。</p>
<h2 data-id="heading-0">第一层:懒加载不是设个 loading="lazy" 就完事了</h2>
<h3 data-id="heading-1">原生懒加载的局限性</h3>
<p>很多人以为图片懒加载就是这样:</p>
<pre><code class="hljs language-ini" lang="ini">&lt;img <span class="hljs-attr">src</span>=<span class="hljs-string">"photo.jpg"</span> loading=<span class="hljs-string">"lazy"</span>&gt;
</code></pre>
<p>浏览器确实会帮你延迟加载,但这个策略<strong>完全不受你控制</strong>。浏览器决定什么时候加载,你只能接受。</p>
<p>真正的懒加载策略应该是:<strong>在图片进入视口前 200-500px 就开始预加载</strong>,这样用户滚动到位置时图片已经准备好了,既节省了带宽又保证了体验。</p>
<h3 data-id="heading-2">JavaScript 接管控制权</h3>
<p>这时候 JavaScript 的 <code>IntersectionObserver</code> API 就派上用场了:</p>
<pre><code class="hljs language-ini" lang="ini">// 创建一个观察器,提前 200px 开始加载
const <span class="hljs-attr">lazyObserver</span> = new IntersectionObserver(
(entries) =&gt; {
    entries.forEach(<span class="hljs-attr">entry</span> =&gt; {
      if (!entry.isIntersecting) return<span class="hljs-comment">;</span>
      
      const <span class="hljs-attr">img</span> = entry.target<span class="hljs-comment">;</span>
      const <span class="hljs-attr">realSrc</span> = img.dataset.src<span class="hljs-comment">;</span>
      
      // 开始加载真实图片
      <span class="hljs-attr">img.src</span> = realSrc<span class="hljs-comment">;</span>
      
      // 加载完成后停止观察
      <span class="hljs-attr">img.onload</span> = () =&gt; {
        img.classList.add('loaded')<span class="hljs-comment">;</span>
        lazyObserver.unobserve(img)<span class="hljs-comment">;</span>
      }<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  },
  {
    // 关键参数:提前 200px 触发
    rootMargin: '200px 0px'
  }
)<span class="hljs-comment">;</span>

// 批量观察所有待加载图片
document.querySelectorAll('img<span class="hljs-section">[data-src]</span>').forEach(<span class="hljs-attr">img</span> =&gt; {
  lazyObserver.observe(img)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p><strong>工作流程图:</strong></p>
<pre><code class="hljs language-css" lang="css">用户滚动页面
     ↓
图片距离视口还有 <span class="hljs-number">200px</span>
     ↓
IntersectionObserver 触发回调
     ↓
JavaScript 将 data-<span class="hljs-attribute">src</span> 赋值给 <span class="hljs-attribute">src</span>
     ↓
浏览器开始下载图片
     ↓
用户滚动到图片位置时
     ↓
图片已经加载完成 ✅
</code></pre>
<p>这种方式在电商网站的商品列表页特别有效。以某头部电商平台为例,他们的商品图在列表中使用 1px 占位符,滚动到距离视口 300px 时才开始加载真图,<strong>首屏图片请求数从 50 张降到 12 张</strong>,首屏渲染时间直接砍半。</p>
<h3 data-id="heading-3">降级策略</h3>
<p>但问题来了:老浏览器不支持 IntersectionObserver 怎么办?</p>
<p>答案是渐进增强:</p>
<pre><code class="hljs language-ini" lang="ini">// 检测 API 支持情况
if ('IntersectionObserver' in window) {
  // 使用高级策略
  lazyObserver.observe(img)<span class="hljs-comment">;</span>
} else {
  // 降级到原生懒加载
  <span class="hljs-attr">img.loading</span> = <span class="hljs-string">'lazy'</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">img.src</span> = img.dataset.src<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-4">第二层:根据设备和网络动态选择图片</h2>
<h3 data-id="heading-5">屏幕分辨率不等于图片尺寸</h3>
<p>很多人以为响应式图片就是写几个 <code>srcset</code>:</p>
<pre><code class="hljs language-ini" lang="ini">&lt;img <span class="hljs-attr">srcset</span>=<span class="hljs-string">"small.jpg 480w, medium.jpg 800w, large.jpg 1200w"</span>&gt;
</code></pre>
<p>但这只考虑了屏幕宽度,没考虑 DPR(设备像素比)。iPhone 14 Pro 的屏幕宽度是 393px,但 DPR 是 3,实际需要的图片宽度是 <strong>393 × 3 = 1179px</strong>。</p>
<p>用 JavaScript 动态计算才是正解:</p>
<pre><code class="hljs language-ini" lang="ini">function calculateOptimalImageWidth() {
// 获取设备像素比,默认为 1
const <span class="hljs-attr">dpr</span> = window.devicePixelRatio || <span class="hljs-number">1</span><span class="hljs-comment">;</span>

// 获取视口宽度,限制最大值避免过大
const <span class="hljs-attr">viewportWidth</span> = Math.min(window.innerWidth, <span class="hljs-number">1920</span>)<span class="hljs-comment">;</span>

// 计算实际需要的物理像素宽度
const <span class="hljs-attr">physicalWidth</span> = Math.ceil(viewportWidth * dpr)<span class="hljs-comment">;</span>

return physicalWidth<span class="hljs-comment">;</span>
}

// 使用示例
const <span class="hljs-attr">heroImage</span> = document.querySelector(<span class="hljs-string">'.hero-banner'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">optimalWidth</span> = calculateOptimalImageWidth()<span class="hljs-comment">;</span>

// 向 CDN 请求对应尺寸的图片
<span class="hljs-attr">heroImage.src</span> = `https://cdn.example.com/hero.jpg?w=<span class="hljs-variable">${optimalWidth}</span>`<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-6">Network Information API:根据网络降级</h3>
<p>现在进阶一步:<strong>根据用户的网络状况动态调整图片质量</strong>。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getImageQuality</span>(<span class="hljs-params"/>) {
<span class="hljs-comment">// 检测 Network Information API 支持</span>
<span class="hljs-keyword">const</span> connection = navigator.<span class="hljs-property">connection</span> || 
                     navigator.<span class="hljs-property">mozConnection</span> || 
                     navigator.<span class="hljs-property">webkitConnection</span>;

<span class="hljs-keyword">if</span> (!connection) return80; <span class="hljs-comment">// 默认质量</span>

<span class="hljs-comment">// 用户开启了流量节省模式</span>
<span class="hljs-keyword">if</span> (connection.<span class="hljs-property">saveData</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'用户开启省流模式,降低图片质量'</span>);
    return40;
  }

<span class="hljs-comment">// 根据网络类型调整质量</span>
<span class="hljs-keyword">const</span> effectiveType = connection.<span class="hljs-property">effectiveType</span>;

<span class="hljs-keyword">const</span> qualityMap = {
    <span class="hljs-string">'slow-2g'</span>: <span class="hljs-number">30</span>,
    <span class="hljs-string">'2g'</span>: <span class="hljs-number">30</span>,
    <span class="hljs-string">'3g'</span>: <span class="hljs-number">60</span>,
    <span class="hljs-string">'4g'</span>: <span class="hljs-number">80</span>,
    <span class="hljs-string">'5g'</span>: <span class="hljs-number">90</span>
  };

<span class="hljs-keyword">return</span> qualityMap[effectiveType] || <span class="hljs-number">80</span>;
}

<span class="hljs-comment">// 完整的图片加载策略</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadSmartImage</span>(<span class="hljs-params">imageElement</span>) {
<span class="hljs-keyword">const</span> width = <span class="hljs-title function_">calculateOptimalImageWidth</span>();
<span class="hljs-keyword">const</span> quality = <span class="hljs-title function_">getImageQuality</span>();

<span class="hljs-keyword">const</span> imageUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(imageElement.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>);
  imageUrl.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'w'</span>, width);
  imageUrl.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'q'</span>, quality);

  imageElement.<span class="hljs-property">src</span> = imageUrl.<span class="hljs-title function_">toString</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`加载图片: 宽度=<span class="hljs-subst">${width}</span>px, 质量=<span class="hljs-subst">${quality}</span>`</span>);
}
</code></pre>
<p><strong>真实场景:</strong></p>
<p>某短视频 App 的移动端 Web 版,用户在地铁里用 4G 浏览时,图片质量默认 80%;一进隧道切到 3G,立刻降到 60%;用户主动开启省流模式,直接降到 40%。这套策略让他们的<strong>图片流量消耗降低了 35%</strong> ,用户投诉"费流量"的工单减少了一半。</p>
<h2 data-id="heading-7">第三层:解码优先级,别让图片阻塞渲染</h2>
<h3 data-id="heading-8">图片解码是性能杀手</h3>
<p>很多人不知道的冷知识:<strong>浏览器下载图片和解码图片是两回事</strong>。</p>
<p>一张 500KB 的 JPEG,下载可能只要 200ms,但解码可能要 800ms。如果你在首屏同时加载 10 张大图,解码会<strong>完全阻塞主线程</strong>,导致页面卡顿。</p>
<h3 data-id="heading-9">异步解码救命</h3>
<p>JavaScript 提供了 <code>decoding</code> 属性来控制解码策略:</p>
<pre><code class="hljs language-ini" lang="ini">// 首屏关键图片:同步解码,优先显示
const <span class="hljs-attr">heroImage</span> = document.querySelector(<span class="hljs-string">'.hero'</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">heroImage.decoding</span> = <span class="hljs-string">'sync'</span><span class="hljs-comment">;     // 立即解码</span>
<span class="hljs-attr">heroImage.fetchPriority</span> = <span class="hljs-string">'high'</span><span class="hljs-comment">; // 高优先级下载</span>

// 非关键图片:异步解码,不阻塞渲染
const <span class="hljs-attr">thumbnails</span> = document.querySelectorAll(<span class="hljs-string">'.thumbnail'</span>)<span class="hljs-comment">;</span>
thumbnails.forEach(<span class="hljs-attr">img</span> =&gt; {
  <span class="hljs-attr">img.decoding</span> = <span class="hljs-string">'async'</span><span class="hljs-comment">;         // 异步解码</span>
  <span class="hljs-attr">img.fetchPriority</span> = <span class="hljs-string">'low'</span><span class="hljs-comment">;      // 低优先级</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p><strong>解码策略对比:</strong></p>
<pre><code class="hljs language-dart" lang="dart">同步解码 (<span class="hljs-keyword">sync</span>):
下载图片 → 阻塞主线程 → 解码完成 → 渲染页面
    ↓
主线程被占用,页面卡顿 ❌

异步解码 (<span class="hljs-keyword">async</span>):
下载图片 → 不阻塞 → 后台解码 → 解码完成后渲染
    ↓
主线程继续执行,页面流畅 ✅
</code></pre>
<h3 data-id="heading-10">预加载图片获取尺寸</h3>
<p>还有一个高级技巧:<strong>在插入 DOM 前预加载图片,提前获取宽高比,避免 CLS(累积布局偏移)</strong>。</p>
<pre><code class="hljs language-ini" lang="ini">async function preloadImageWithDimensions(src) {
returnnewPromise((resolve, reject) =&gt; {
    const <span class="hljs-attr">img</span> = new Image()<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">img.onload</span> = () =&gt; {
      resolve({
        element: img,
        width: img.naturalWidth,
        height: img.naturalHeight,
        aspectRatio: img.naturalWidth / img.naturalHeight
      })<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">img.onerror</span> = reject<span class="hljs-comment">;</span>
    <span class="hljs-attr">img.src</span> = src<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
}

// 使用示例
const <span class="hljs-attr">imageData</span> = await preloadImageWithDimensions(<span class="hljs-string">'/photo.jpg'</span>)<span class="hljs-comment">;</span>

// 提前设置宽高比,避免布局偏移
const <span class="hljs-attr">container</span> = document.querySelector(<span class="hljs-string">'.image-container'</span>)<span class="hljs-comment">;</span>
<span class="hljs-attr">container.style.aspectRatio</span> = imageData.aspectRatio<span class="hljs-comment">;</span>

// 图片已经加载完成,直接插入
container.appendChild(imageData.element)<span class="hljs-comment">;</span>
</code></pre>
<p>这招在动态生成内容的场景特别有用,比如用户上传头像、生成分享海报等,可以完全避免"图片加载后页面突然跳动"的问题。</p>
<h2 data-id="heading-11">第四层:客户端压缩,上传前就优化</h2>
<h3 data-id="heading-12">为什么要在前端压缩图片?</h3>
<p>传统思路是:用户上传 → 服务端压缩 → 存储到 CDN。</p>
<p>但这有几个问题:</p>
<ol>
<li><strong>用户上传 10MB 原图,流量浪费</strong></li>
<li><strong>服务端要处理大量压缩任务,CPU 成本高</strong></li>
<li><strong>用户要等服务端处理完才能看到预览</strong></li>
</ol>
<p>更好的方案是:<strong>前端直接压缩,上传压缩后的图片</strong>。</p>
<h3 data-id="heading-13">Canvas API + OffscreenCanvas</h3>
<p>JavaScript 的 Canvas API 可以实现客户端压缩:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compressImageOnClient</span>(<span class="hljs-params">file, maxWidth = <span class="hljs-number">1920</span></span>) {
<span class="hljs-comment">// 使用 createImageBitmap 读取文件</span>
<span class="hljs-keyword">const</span> bitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(file);

<span class="hljs-comment">// 计算缩放比例</span>
<span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, maxWidth / bitmap.<span class="hljs-property">width</span>);
<span class="hljs-keyword">const</span> newWidth = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(bitmap.<span class="hljs-property">width</span> * scale);
<span class="hljs-keyword">const</span> newHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(bitmap.<span class="hljs-property">height</span> * scale);

<span class="hljs-comment">// 使用 OffscreenCanvas 处理,不阻塞主线程</span>
<span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OffscreenCanvas</span>(newWidth, newHeight);
<span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);

<span class="hljs-comment">// 绘制缩放后的图片</span>
  ctx.<span class="hljs-title function_">drawImage</span>(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, newWidth, newHeight);

<span class="hljs-comment">// 转换为 WebP 格式,质量 0.8</span>
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> canvas.<span class="hljs-title function_">convertToBlob</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'image/webp'</span>,
    <span class="hljs-attr">quality</span>: <span class="hljs-number">0.8</span>
  });

<span class="hljs-keyword">return</span> blob;
}

<span class="hljs-comment">// 用户上传图片时触发</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#upload'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">async</span> (e) =&gt; {
<span class="hljs-keyword">const</span> file = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`原始文件: <span class="hljs-subst">${(file.size / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>);

<span class="hljs-comment">// 前端压缩</span>
<span class="hljs-keyword">const</span> compressed = <span class="hljs-keyword">await</span> <span class="hljs-title function_">compressImageOnClient</span>(file, <span class="hljs-number">1920</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`压缩后: <span class="hljs-subst">${(compressed.size / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`压缩率: <span class="hljs-subst">${((<span class="hljs-number">1</span> - compressed.size / file.size) * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">1</span>)}</span>%`</span>);
  
  <span class="hljs-comment">// 上传压缩后的图片</span>
  <span class="hljs-title function_">uploadToServer</span>(compressed);
});
</code></pre>
<p><strong>实测数据(iPhone 拍摄的照片):</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">原始文件: 8.3 MB (4032 × 3024, JPEG)</span>
     ↓
前端压缩 (1920px, WebP, quality=0.8)
     ↓
<span class="hljs-section">压缩后: 0.6 MB</span>
<span class="hljs-section">压缩率: 92.8% ✅</span>
</code></pre>
<h3 data-id="heading-14">Web Worker 优化</h3>
<p>如果要处理多张图片,可以用 Web Worker 避免阻塞主线程:</p>
<pre><code class="hljs language-ini" lang="ini">// imageCompressor.worker.js
self.addEventListener('message', async (e) =&gt; {
const { file, maxWidth } = e.data<span class="hljs-comment">;</span>

const <span class="hljs-attr">bitmap</span> = await createImageBitmap(file)<span class="hljs-comment">;</span>
const <span class="hljs-attr">scale</span> = Math.min(<span class="hljs-number">1</span>, maxWidth / bitmap.width)<span class="hljs-comment">;</span>

const <span class="hljs-attr">canvas</span> = new <span class="hljs-literal">Off</span>screenCanvas(
    Math.floor(bitmap.width * scale),
    Math.floor(bitmap.height * scale)
  )<span class="hljs-comment">;</span>

const <span class="hljs-attr">ctx</span> = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-comment">;</span>
  ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height)<span class="hljs-comment">;</span>

const <span class="hljs-attr">blob</span> = await canvas.convertToBlob({
    type: 'image/webp',
    quality: 0.8
  })<span class="hljs-comment">;</span>

// 发送回主线程
  self.postMessage({ blob, originalSize: file.size })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// 主线程使用
const <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">'imageCompressor.worker.js'</span>)<span class="hljs-comment">;</span>

worker.postMessage({ file: uploadedFile, maxWidth: 1920 })<span class="hljs-comment">;</span>

<span class="hljs-attr">worker.onmessage</span> = (e) =&gt; {
const { blob, originalSize } = e.data<span class="hljs-comment">;</span>
const <span class="hljs-attr">ratio</span> = ((<span class="hljs-number">1</span> - blob.size / originalSize) * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
console.log(`压缩完成,节省 ${ratio}% 流量`)<span class="hljs-comment">;</span>

  uploadToServer(blob)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>某社交平台用了这套方案后,<strong>用户上传图片的流量成本降低了 87%</strong> ,服务端 CPU 使用率降低了 60%。</p>
<h2 data-id="heading-15">第五层:Cache API 让图片真正"只加载一次"</h2>
<h3 data-id="heading-16">HTTP 缓存的局限</h3>
<p>浏览器的 HTTP 缓存很好,但有个问题:<strong>缓存策略完全由服务端控制</strong>,而且在隐私模式下会失效。</p>
<p>更激进的方案是用 <strong>Cache API</strong> 手动管理图片缓存:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMAGE_CACHE_NAME</span> = <span class="hljs-string">'image-cache-v1'</span>;

<span class="hljs-comment">// 缓存图片</span>
<span class="hljs-keyword">async</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">cacheImage</span>(<span class="hljs-params">url</span>) {
<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">IMAGE_CACHE_NAME</span>);

<span class="hljs-comment">// 检查是否已缓存</span>
<span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(url);
<span class="hljs-keyword">if</span> (cached) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`命中缓存: <span class="hljs-subst">${url}</span>`</span>);
    <span class="hljs-keyword">return</span> cached;
  }

<span class="hljs-comment">// 未缓存,立即下载</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`下载并缓存: <span class="hljs-subst">${url}</span>`</span>);
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);

<span class="hljs-comment">// 只缓存成功的响应</span>
<span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(url, response.<span class="hljs-title function_">clone</span>());
  }

<span class="hljs-keyword">return</span> response;
}

<span class="hljs-comment">// 加载图片时使用缓存</span>
<span class="hljs-keyword">async</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImageWithCache</span>(<span class="hljs-params">imgElement</span>) {
<span class="hljs-keyword">const</span> url = imgElement.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;

<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">cacheImage</span>(url);
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();

<span class="hljs-comment">// 创建 Object URL 显示图片</span>
  imgElement.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
}
</code></pre>
<h3 data-id="heading-17">缓存清理策略</h3>
<p>Cache API 不会自动清理,需要手动控制缓存大小:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanOldCache</span>(<span class="hljs-params">maxSize = <span class="hljs-number">50</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span></span>) { <span class="hljs-comment">// 50MB</span>
<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">IMAGE_CACHE_NAME</span>);
<span class="hljs-keyword">const</span> requests = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">keys</span>();

<span class="hljs-keyword">let</span> totalSize = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> items = [];

<span class="hljs-comment">// 统计每个缓存项的大小和时间</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> request <span class="hljs-keyword">of</span> requests) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(request);
    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();
    
    items.<span class="hljs-title function_">push</span>({
      request,
      <span class="hljs-attr">size</span>: blob.<span class="hljs-property">size</span>,
      <span class="hljs-attr">url</span>: request.<span class="hljs-property">url</span>
    });
    
    totalSize += blob.<span class="hljs-property">size</span>;
  }

<span class="hljs-comment">// 超出限制,删除最早的缓存</span>
<span class="hljs-keyword">if</span> (totalSize &gt; maxSize) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`缓存超限: <span class="hljs-subst">${(totalSize / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>);
    
    <span class="hljs-comment">// 按时间排序,删除旧的</span>
    items.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">url</span>.<span class="hljs-title function_">localeCompare</span>(b.<span class="hljs-property">url</span>));
    
    <span class="hljs-keyword">let</span> cleaned = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> items) {
      <span class="hljs-keyword">if</span> (totalSize - cleaned &lt; maxSize) <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">delete</span>(item.<span class="hljs-property">request</span>);
      cleaned += item.<span class="hljs-property">size</span>;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`删除缓存: <span class="hljs-subst">${item.url}</span>`</span>);
    }
  }
}

<span class="hljs-comment">// 定期清理</span>
<span class="hljs-built_in">setInterval</span>(cleanOldCache, <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每 5 分钟检查一次</span>
</code></pre>
<p><strong>真实效果:</strong></p>
<p>某新闻 App 的 PWA 版本,使用 Cache API 后:</p>
<ul>
<li>二次访问图片加载时间从 <strong>800ms 降到 50ms</strong></li>
<li>离线状态下依然能浏览已访问过的图片</li>
<li>用户流量消耗降低 <strong>70%</strong></li>
</ul>
<h2 data-id="heading-18">完整的图片优化工作流</h2>
<p>把上面的技术组合起来,就是一套完整的图片优化系统:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 用户滚动页面
    ↓
<span class="hljs-bullet">2.</span> IntersectionObserver 触发(提前 200px)
    ↓
<span class="hljs-bullet">3.</span> JavaScript 检测网络状况(Network Info API)
    ↓
<span class="hljs-bullet">4.</span> 计算最优尺寸和质量(DPR + 网络类型)
    ↓
<span class="hljs-bullet">5.</span> 检查 Cache API 是否有缓存
    ↓
<span class="hljs-bullet">6.</span> 如果有缓存 → 直接使用
   如果无缓存 → 向 CDN 请求
    ↓
<span class="hljs-bullet">7.</span> 下载完成后存入 Cache API
    ↓
<span class="hljs-bullet">8.</span> 设置 decoding='async' 异步解码
    ↓
<span class="hljs-bullet">9.</span> 图片显示,避免 CLS
</code></pre>
<h2 data-id="heading-19">性能对比:优化前 vs 优化后</h2>
<p>以某电商平台的商品详情页为例:</p>









































<table><thead><tr><th>指标</th><th>优化前</th><th>优化后</th><th>提升</th></tr></thead><tbody><tr><td>首屏图片请求数</td><td>18 张</td><td>6 张</td><td>↓ 67%</td></tr><tr><td>图片总大小</td><td>4.2 MB</td><td>0.8 MB</td><td>↓ 81%</td></tr><tr><td>首屏渲染时间</td><td>3.8 秒</td><td>1.2 秒</td><td>↓ 68%</td></tr><tr><td>CLS 评分</td><td>0.25</td><td>0.02</td><td>↓ 92%</td></tr><tr><td>二次访问加载时间</td><td>2.1 秒</td><td>0.3 秒</td><td>↓ 86%</td></tr></tbody></table>
<p>这些数据不是实验室跑出来的,是真实线上环境、千万级 PV 验证过的。</p>
<h2 data-id="heading-20">写在最后</h2>
<p>图片优化不是"换个格式"或"开个 CDN"那么简单,它是一套完整的<strong>运行时策略系统</strong>:</p>
<ol>
<li><strong>延迟加载</strong>:IntersectionObserver 精准控制</li>
<li><strong>动态选择</strong>:根据设备和网络调整尺寸和质量</li>
<li><strong>解码优化</strong>:async decoding 避免阻塞</li>
<li><strong>客户端压缩</strong>:前端直接处理,节省流量和服务器成本</li>
<li><strong>缓存管理</strong>:Cache API 手动控制,离线可用</li>
</ol>
<p>这些技术的共同点是:<strong>JavaScript 掌握了主动权</strong>,不再被动依赖浏览器或 CDN 的默认行为。</p>
<p>但更重要的是,<strong>要理解为什么这么做</strong>。</p>
<p>浏览器只关心字节数、解码时间、布局稳定性和渲染时机。你的每一行代码,都应该为这四个目标服务。</p>
<p>记住:<strong>性能不是锦上添花,性能本身就是功能</strong>。用户不会夸你的代码写得优雅,但会直接感受到你的页面是快是慢。</p>
<p>而图片优化,往往是性能优化中 ROI 最高的那个环节。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[fetch-event-source源码解读]]></title>    <link>https://juejin.cn/post/7604039449468665906</link>    <guid>https://juejin.cn/post/7604039449468665906</guid>    <pubDate>2026-02-09T06:13:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604039449468665906" data-draft-id="7597695487302795279" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="fetch-event-source源码解读"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-09T06:13:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不认输的西瓜"/> <meta itemprop="url" content="https://juejin.cn/user/219558058666813"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            fetch-event-source源码解读
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/219558058666813/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不认输的西瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:13:48.000Z" title="Mon Feb 09 2026 06:13:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">SSE协议规范</h2>
<p>SSE协议实际上是在 HTTP 之上定义了一套严格的数据组织规范，是属于应用层的协议。</p>
<ul>
<li><strong>固定请求头类型</strong>：必须是 <code>Content-Type: text/event-stream</code></li>
<li><strong>固定文本格式</strong>：数据必须以 <code>field: value\n</code> 的形式返回</li>
<li><strong>固定结束符</strong>：消息之间必须以 <code>\n\n</code> 分隔。</li>
</ul>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-attr">id</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 消息唯一标识，实现“断点续传”的关键</span>
    <span class="hljs-attr">event</span>: <span class="hljs-string">''</span>,  <span class="hljs-comment">// 事件类型，缺失则默认触发 onmessage</span>
    <span class="hljs-attr">data</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 消息内容</span>
    <span class="hljs-attr">retry</span>: <span class="hljs-literal">undefined</span>,  <span class="hljs-comment">// 重连时间</span>
}
</code></pre>
<h2 data-id="heading-1">fetchEventSource 执行流程</h2>
<p><strong>fetch-event-source底层是使用</strong> <strong><code>fetch</code></strong> <strong>配合</strong> <strong><code>ReadableStream</code></strong> <strong>实现的</strong></p>
<p><strong>1.建立 Fetch 长连接</strong></p>
<p><code>fetch</code> 读取到的是 <code>Uint8Array</code>（原始二进制字节码），需要手动转换为 SSE 字段。</p>
<p>自动补全 <code>Accept: text/event-stream</code>，确保后端返回正确格式。</p>
<p><strong>2.流式读取</strong></p>
<p>通过 <code>response.body.getReader()</code> 开启循环读取字节流。</p>
<p><strong>3.字节解码与“缓冲区”拼装</strong></p>
<p>网络传输中，数据包可能在任何地方断开（例如：<code>data: hello</code> 被切成了 <code>da</code> 和 <code>ta: hello</code>）。 源码中维护了一个 <code>buffer</code> (Uint8Array) 和一个 <code>position</code> (当前偏移量)，<strong>这是该库最核心的逻辑。</strong></p>
<ul>
<li>
<p><strong>缓冲区逻辑</strong>：库内部维护一个 <code>buffer</code> 字符串。新到的片段会拼接到 <code>buffer</code> 后。</p>
<ul>
<li>扫描 <code>buffer</code> 中是否存在 <code>\n\n</code>。</li>
<li>如果有，说明消息完整，切出来进行解析。</li>
<li>如果没有，继续等待下一个数据块。</li>
</ul>
</li>
</ul>
<p><strong>4.字段解析与分发</strong></p>
<p>一旦识别出完整的消息块，它会按行拆分，解析出 <code>data:</code>, <code>event:</code>, <code>id:</code> 等字段，并手动调用你在配置中传入的 <code>onmessage</code>, <code>onopen</code> 等回调函数。</p>
<h2 data-id="heading-2">核心方法解析</h2>
<h3 data-id="heading-3">1、<code>fetchEventSource</code></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">FetchEventSourceInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestInit</span> {
    headers?: <span class="hljs-title class_">Record</span>&lt;string, string&gt;,
    onopen?: <span class="hljs-function">(<span class="hljs-params">response: Response</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;,
    onmessage?: <span class="hljs-function">(<span class="hljs-params">ev: EventSourceMessage</span>) =&gt;</span> <span class="hljs-keyword">void</span>;
    onclose?: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;
    onerror?: <span class="hljs-function">(<span class="hljs-params">err: any</span>) =&gt;</span> number | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-keyword">void</span>,
    openWhenHidden?: boolean;
    fetch?: <span class="hljs-keyword">typeof</span> fetch; <span class="hljs-comment">// 要使用的 Fetch 函数。默认为 window.fetch</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchEventSource</span>(<span class="hljs-params">input: RequestInfo, {
    signal: inputSignal,
    headers: inputHeaders,
    onopen: inputOnOpen,
    onmessage,
    onclose,
    onerror,
    openWhenHidden,
    fetch: inputFetch,
    ...rest
}: FetchEventSourceInit</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// 复制请求头，确保 accept 为 text/event-stream。</span>
        <span class="hljs-keyword">const</span> headers = { ...inputHeaders };
        <span class="hljs-keyword">if</span> (!headers.<span class="hljs-property">accept</span>) {
            headers.<span class="hljs-property">accept</span> = <span class="hljs-title class_">EventStreamContentType</span>;
        }

        <span class="hljs-comment">// 当前请求的 AbortController</span>
        <span class="hljs-keyword">let</span> <span class="hljs-attr">curRequestController</span>: <span class="hljs-title class_">AbortController</span>;
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">onVisibilityChange</span>(<span class="hljs-params"/>) {
            curRequestController.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 页面隐藏时中断请求</span>
            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) {
                <span class="hljs-title function_">create</span>(); <span class="hljs-comment">// 页面恢复可见时重新建立连接</span>
            }
        }

        <span class="hljs-comment">// 如果openWhenHidden为false，则监听文档可见性变化事件</span>
        <span class="hljs-keyword">if</span> (!openWhenHidden) {
            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, onVisibilityChange);
        }

        <span class="hljs-comment">// 资源清理</span>
        <span class="hljs-keyword">let</span> retryInterval = <span class="hljs-title class_">DefaultRetryInterval</span>;
        <span class="hljs-keyword">let</span> retryTimer = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispose</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// 清理事件监听</span>
            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, onVisibilityChange);
            <span class="hljs-comment">// 清理定时器和中断请求</span>
            <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(retryTimer);
            <span class="hljs-comment">// 中断当前请求</span>
            curRequestController.<span class="hljs-title function_">abort</span>();
        }

        <span class="hljs-comment">// 如果外部传入了 abort 信号，响应中断并清理资源。</span>
        inputSignal?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'abort'</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">dispose</span>();
            <span class="hljs-title function_">resolve</span>(); <span class="hljs-comment">// 不要浪费资源在重试上</span>
        });

        <span class="hljs-comment">// 使用传入的 fetch 实现（若有），否则使用全局的 window.fetch。</span>
        <span class="hljs-keyword">const</span> fetch = inputFetch ?? <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;
        <span class="hljs-comment">// 使用传入的 onopen 回调（用于验证/处理响应），没有则使用默认的 content-type 校验函数。</span>
        <span class="hljs-keyword">const</span> onopen = inputOnOpen ?? defaultOnOpen;
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// 为本次请求创建 AbortController，用于后续中止当前请求（可见性变化或外部 abort）。</span>
            curRequestController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 发起 fetch 请求，合并剩余 init 配置、headers，并将当前 controller 的 signal 传入以便可中止。</span>
                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(input, {
                    ...rest,
                    headers,
                    <span class="hljs-attr">signal</span>: curRequestController.<span class="hljs-property">signal</span>,
                });

                <span class="hljs-keyword">await</span> <span class="hljs-title function_">onopen</span>(response);
                
                <span class="hljs-comment">// 链式处理响应流：</span>
                <span class="hljs-comment">// getMessages返回按行组装成EventSourceMessage对象的online函数</span>
                <span class="hljs-comment">// 第一个参数是id，如果有id就写入headers中，用于在下次重连发送last-event-id</span>
                <span class="hljs-comment">// 第二个参数是retry，如果有retry就更新retryInterval，用于下次重连等待时间</span>
                <span class="hljs-comment">// 第三个参数是onmessage回调，用于处理完整的EventSourceMessage消息</span>

                <span class="hljs-comment">// getLines负责把响应体字节流按行切分，调用上面的online函数</span>
                <span class="hljs-comment">// getBytes负责从response.body中读取响应体的字节流，并把每块传入getLines进行处理，直到结束或终止</span>
                <span class="hljs-keyword">await</span> <span class="hljs-title function_">getBytes</span>(response.<span class="hljs-property">body</span>!, <span class="hljs-title function_">getLines</span>(<span class="hljs-title function_">getMessages</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {
                    <span class="hljs-keyword">if</span> (id) {
                        <span class="hljs-comment">// store the id and send it back on the next retry:</span>
                        headers[<span class="hljs-title class_">LastEventId</span>] = id;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// don't send the last-event-id header anymore:</span>
                        <span class="hljs-keyword">delete</span> headers[<span class="hljs-title class_">LastEventId</span>];
                    }
                }, <span class="hljs-function"><span class="hljs-params">retry</span> =&gt;</span> {
                    retryInterval = retry;
                }, onmessage)));

                onclose?.(); <span class="hljs-comment">// 流正常结束后，调用可选的 onclose 回调</span>
                <span class="hljs-title function_">dispose</span>(); <span class="hljs-comment">// 清理（移除可见性监听、清除定时器、abort 当前 controller 等资源）</span>
                <span class="hljs-title function_">resolve</span>(); <span class="hljs-comment">// 完成外部 Promise（表示工作完成，不再重试）。</span>
            } <span class="hljs-keyword">catch</span> (err) {
                <span class="hljs-comment">// 只有在不是主动中止的情况下才考虑重试（如果是主动 abort，就不重试）</span>
                <span class="hljs-keyword">if</span> (!curRequestController.<span class="hljs-property">signal</span>.<span class="hljs-property">aborted</span>) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 调用用户的 onerror 回调，允许其返回一个重试间隔（毫秒）；若未提供或返回 undefined，则使用当前的 retryInterval（来自服务器 retry 字段或默认值）</span>
                        <span class="hljs-keyword">const</span> <span class="hljs-attr">interval</span>: any = onerror?.(err) ?? retryInterval;
                        <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(retryTimer); <span class="hljs-comment">// 清除之前可能存在的重试定时器。</span>
                        retryTimer = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(create, interval);
                    } <span class="hljs-keyword">catch</span> (innerErr) {
                        <span class="hljs-title function_">dispose</span>(); <span class="hljs-comment">// 清理资源。</span>
                        <span class="hljs-title function_">reject</span>(innerErr); <span class="hljs-comment">// 拒绝外部 Promise，结束整个流程并向调用者报告错误</span>
                    }
                }
            }
        }

        <span class="hljs-title function_">create</span>();
    });
}
</code></pre>
<h3 data-id="heading-4"><strong>2、</strong> <strong><code>getBytes()</code></strong> <strong>：循环读取流信息</strong></h3>
<p>函数接收两个参数：stream和onChunk</p>
<ul>
<li><code>stream</code>：代表一个可读取的二进制数据流</li>
<li><code>onChunk</code>： 是一个回调函数，每当从流中读取到一块数据时，就会调用这个函数，并将读取到的数据作为参数传递给这个函数。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBytes</span>(<span class="hljs-params">stream: ReadableStream&lt;<span class="hljs-built_in">Uint8Array</span>&gt;, onChunk: (arr: <span class="hljs-built_in">Uint8Array</span>) =&gt; <span class="hljs-keyword">void</span></span>) {
    <span class="hljs-keyword">const</span> reader = stream.<span class="hljs-title function_">getReader</span>(); <span class="hljs-comment">// 创建一个流的阅读器 reader</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">ReadableStreamDefaultReadResult</span>&lt;<span class="hljs-title class_">Uint8Array</span>&gt;;
    <span class="hljs-keyword">while</span> (!(result = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>()).<span class="hljs-property">done</span>) { <span class="hljs-comment">// 循环读取数据块，直到流结束</span>
        <span class="hljs-title function_">onChunk</span>(result.<span class="hljs-property">value</span>); <span class="hljs-comment">// 对每个数据块调用回调, onChunk是 getLines()方法的返回值</span>
    }
}
</code></pre>
<h3 data-id="heading-5"><strong>3、</strong> <strong><code>getLines()</code></strong> <strong>：将字节块解析为EventSource行信息</strong></h3>
<p>接收一个回调函数 onLine 作为参数，并返回一个新的函数 onChunk。</p>
<ul>
<li>
<p><code>onLine</code>：每当检测到一行数据时就会调用它</p>
<pre><code class="hljs language-r" lang="r">规定以`\r`、`\n` 或 `\r\n`作为一行结束的标志
规定以`\n\n`或`  \r\n\r\n ` 作为一个消息结束的标志
</code></pre>
</li>
<li>
<p><code>onChunk</code>：用于处理传入的字节块。逐个解析传入的字节块，找到数据中的行结束符。将字节块解析为 EventSource 行缓冲区，并在检测到完整行时调用<code> onLine</code> 回调。</p>
</li>
</ul>
<p><strong>它解决了这样一个问题：网络传输的数据可能不是一行一行到达的，而是分块到达的，甚至一行可能被拆成多个块。这个函数负责把这些块拼起来，遇到换行符（\r、\n 或 \r\n）就认为是一行，然后把这一行交给 onLine 处理。</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 模拟字节块的返回</span>
<span class="hljs-comment">// 块1：data: hello\r\ndata: wo</span>
<span class="hljs-comment">// 块2：rld\r\n\r\nevent: update\r\ndata: 123\r\n</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLines</span>(<span class="hljs-params">onLine: (line: <span class="hljs-built_in">Uint8Array</span>, fieldLength: number) =&gt; <span class="hljs-keyword">void</span></span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">buffer</span>: <span class="hljs-title class_">Uint8Array</span> | <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">position</span>: number; <span class="hljs-comment">// 当前读取位置</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">fieldLength</span>: number; <span class="hljs-comment">// 当前行中有效“字段”部分的长度</span>
    <span class="hljs-keyword">let</span> discardTrailingNewline = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记是否需要跳过紧跟在\r后的\n</span>

    <span class="hljs-comment">// 返回一个函数，处理每个字节块</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onChunk</span>(<span class="hljs-params">arr: <span class="hljs-built_in">Uint8Array</span></span>) {
        <span class="hljs-keyword">if</span> (buffer === <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// 初始化buffer、position、fieldLength，如果未定义也就是意味着这是第一次调用或者前一个缓存区已完全处理完毕</span>
            buffer = arr;
            position = <span class="hljs-number">0</span>;
            fieldLength = -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果buffer已定义（既正在处理一个较大的数据块或连续的数据块），将新的数据块arr追加到现有的buffer后面，主要处理前一个字节处理完还有剩余字节的情况</span>
            buffer = <span class="hljs-title function_">concat</span>(buffer, arr);
        }

        <span class="hljs-keyword">const</span> bufLength = buffer.<span class="hljs-property">length</span>;
        <span class="hljs-keyword">let</span> lineStart = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前行的起始位置</span>
        <span class="hljs-keyword">while</span> (position &lt; bufLength) { <span class="hljs-comment">// 遍历buffer，使用position指针来追踪当前读取的位置</span>
            <span class="hljs-keyword">if</span> (discardTrailingNewline) { <span class="hljs-comment">// 如果设置了discardTrailingNewline标志，则跳过行结束符之后的新行字符，如果上次遇到\r，这次要跳过\n</span>
                <span class="hljs-keyword">if</span> (buffer[position] === <span class="hljs-title class_">ControlChars</span>.<span class="hljs-property">NewLine</span>) {
                    lineStart = ++position; <span class="hljs-comment">// 跳过\n</span>
                }
                
                discardTrailingNewline = <span class="hljs-literal">false</span>;
            }
            
            <span class="hljs-comment">// 查找本行的结束符</span>
            <span class="hljs-keyword">let</span> lineEnd = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (; position &lt; bufLength &amp;&amp; lineEnd === -<span class="hljs-number">1</span>; ++position) {
                <span class="hljs-keyword">switch</span> (buffer[position]) {
                    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ControlChars</span>.<span class="hljs-property">Colon</span>:
                        <span class="hljs-keyword">if</span> (fieldLength === -<span class="hljs-number">1</span>) { <span class="hljs-comment">// 记录第一个冒号的位置</span>
                            fieldLength = position - lineStart;
                        }
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ControlChars</span>.<span class="hljs-property">CarriageReturn</span>: <span class="hljs-comment">// \r</span>
                        discardTrailingNewline = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记下次要跳过\n</span>
                    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ControlChars</span>.<span class="hljs-property">NewLine</span>: <span class="hljs-comment">// \n</span>
                        lineEnd = position; <span class="hljs-comment">// 行结束</span>
                        <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (lineEnd === -<span class="hljs-number">1</span>) {
                <span class="hljs-comment">// 没找到行结束符，等下一个字节块</span>
                <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-comment">// 取出完整的一行，调用 onLine，onLine是 getMessages()方法的返回值</span>
            <span class="hljs-title function_">onLine</span>(buffer.<span class="hljs-title function_">subarray</span>(lineStart, lineEnd), fieldLength); <span class="hljs-comment">// 获取完整的行，并调用onLine回调函数，处理这一行数据</span>
            lineStart = position; <span class="hljs-comment">// 下一行的起始位置</span>
            fieldLength = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 更新 fieldLength 为 -1，准备处理下一行的 field 部分</span>
        }

        <span class="hljs-keyword">if</span> (lineStart === bufLength) {
            buffer = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 全部处理完</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineStart !== <span class="hljs-number">0</span>) {
             <span class="hljs-comment">// 还有未处理的内容</span>
            buffer = buffer.<span class="hljs-title function_">subarray</span>(lineStart); <span class="hljs-comment">// 把 buffer 变成还没处理完的部分，丢弃已经处理过的内容。这样下次新数据块到来时，可以直接拼接到剩余部分后面。</span>
            position -= lineStart; <span class="hljs-comment">// 更新 position 指针，保证它指向新的 buffer 的正确位置。其实可以直接置为0，因为新的 buffer 是从 lineStart 开始的，但是这样写更通用一些。防止极端情况下 position 指向错误。</span>
        }
    }
}
</code></pre>
<h3 data-id="heading-6">4、<strong>getMessages()：把 EventSource 行组装成完整的 SSE 消息对象</strong></h3>
<p>接收三个回调为参数：<code>onId</code>、<code>onRetry</code>、<code>onMessage</code>，并返回一个新的函数<code>onLine</code></p>
<ul>
<li><code>onId</code>：回调，在每次检测到消息 ID 时调用，传递 ID 字符串作为参数</li>
<li><code>onRetry</code>：回调，在每次检测到重试时间时调用，传递重试时间的数值作为参数</li>
<li><code>onMessage</code>：回调，在每次消息结束时调用，传递完整的消息对象作为参数</li>
<li><code>onLine</code>：处理每一行的数据</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMessages</span>(<span class="hljs-params">
    onId: (id: string) =&gt; <span class="hljs-keyword">void</span>,
    onRetry: (retry: number) =&gt; <span class="hljs-keyword">void</span>,
    onMessage?: (msg: EventSourceMessage) =&gt; <span class="hljs-keyword">void</span>
</span>) {
    <span class="hljs-keyword">let</span> message = <span class="hljs-title function_">newMessage</span>(); <span class="hljs-comment">// 初始化一个空消息对象</span>
    <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(); <span class="hljs-comment">// 用于把字节数组解码为字符串。</span>

    <span class="hljs-comment">// 返回一个函数，每当解析出一行 EventSource 行时就会调用，（由 getLines 传入）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onLine</span>(<span class="hljs-params">line: <span class="hljs-built_in">Uint8Array</span>, fieldLength: number</span>) {
        <span class="hljs-keyword">if</span> (line.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) { <span class="hljs-comment">// 如果是空行表示消息结束</span>
            onMessage?.(message); <span class="hljs-comment">// 调用 onMessage 回调，将完整的消息对象传递出去</span>
            message = <span class="hljs-title function_">newMessage</span>(); <span class="hljs-comment">// 重置 message 对象</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fieldLength &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 如果这一行包含有效数据（即不是注释或空行），继续处理。</span>
            <span class="hljs-comment">// 解析字段名（field）和字段值（value）</span>
            <span class="hljs-comment">// 字段名是从行开头到冒号前的部分，字段值是冒号后面，可能有一个空格（协议允许），所以判断是否有空格决定偏移量。</span>
            <span class="hljs-keyword">const</span> field = decoder.<span class="hljs-title function_">decode</span>(line.<span class="hljs-title function_">subarray</span>(<span class="hljs-number">0</span>, fieldLength));
            <span class="hljs-keyword">const</span> valueOffset = fieldLength + (line[fieldLength + <span class="hljs-number">1</span>] === <span class="hljs-title class_">ControlChars</span>.<span class="hljs-property">Space</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);
            <span class="hljs-keyword">const</span> value = decoder.<span class="hljs-title function_">decode</span>(line.<span class="hljs-title function_">subarray</span>(valueOffset));

            <span class="hljs-keyword">switch</span> (field) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'data'</span>:
                    <span class="hljs-comment">// 如果字段名是 data，把 value 加到 message.data 上</span>
                    <span class="hljs-comment">// 如果已经有 data，追加一行（\n），否则直接赋值</span>
                    message.<span class="hljs-property">data</span> = message.<span class="hljs-property">data</span>
                        ? message.<span class="hljs-property">data</span> + <span class="hljs-string">'\n'</span> + value
                        : value; 
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'event'</span>:
                    <span class="hljs-comment">// 如果字段名是 event，设置消息的事件类型</span>
                    message.<span class="hljs-property">event</span> = value;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'id'</span>:
                    <span class="hljs-comment">// 如果字段名是 id，设置消息的 id，并调用 onId 回调。</span>
                    <span class="hljs-title function_">onId</span>(message.<span class="hljs-property">id</span> = value);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'retry'</span>:
                    <span class="hljs-comment">// 如果字段名是 retry，尝试解析为整数，合法则设置消息的 retry 并调用 onRetry 回调</span>
                    <span class="hljs-keyword">const</span> retry = <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>);
                    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(retry)) { <span class="hljs-comment">// per spec, ignore non-integers</span>
                        <span class="hljs-title function_">onRetry</span>(message.<span class="hljs-property">retry</span> = retry);
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<h2 data-id="heading-7">源码流程详细图解</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/758e84ac89124c0280647062abee8316~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN6K6k6L6T55qE6KW_55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222428&amp;x-signature=Qe66Y3cXZR6tIN0SwUXFZ7Af8qk%3D" alt="whiteboard_exported_image.png" loading="lazy"/></p>
<h2 data-id="heading-8">总结</h2>
<p>SSE 的本质是：一种基于文本行的、约定俗成的 HTTP Body 消费方式。
原生 API 是将这种消费方式『硬件化』在了浏览器里，
而 fetch-event-source 则是用 JS 工具将其『软件化』实现了一遍。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MacBook M1 安装 OpenClaw 完整指南]]></title>    <link>https://juejin.cn/post/7604084016510812201</link>    <guid>https://juejin.cn/post/7604084016510812201</guid>    <pubDate>2026-02-09T05:48:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510812201" data-draft-id="7604175912480980998" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MacBook M1 安装 OpenClaw 完整指南"/> <meta itemprop="keywords" content="人工智能,后端"/> <meta itemprop="datePublished" content="2026-02-09T05:48:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="楚兴"/> <meta itemprop="url" content="https://juejin.cn/user/1020811839542414"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MacBook M1 安装 OpenClaw 完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1020811839542414/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    楚兴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:48:59.000Z" title="Mon Feb 09 2026 05:48:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    26
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文记录了在 MacBook M1 (Apple Silicon) 上安装 OpenClaw 的完整过程，包括遇到的坑和解决方案。</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>OpenClaw 是一个开源的个人 AI 助手，可以连接 WhatsApp、Telegram、Discord、Slack 等多种聊天平台。本文将详细介绍如何在 M1 Mac 上从零开始安装和配置 OpenClaw。</p>
<h2 data-id="heading-1">环境要求</h2>





















<table><thead><tr><th>要求</th><th>说明</th></tr></thead><tbody><tr><td>Node.js</td><td>≥22，<strong>必须是 ARM64 原生版本</strong></td></tr><tr><td>操作系统</td><td>macOS (Apple Silicon)</td></tr><tr><td>包管理器</td><td>npm 或 pnpm</td></tr></tbody></table>
<h2 data-id="heading-2">第一步：检查 Node.js 架构</h2>
<p><strong>这是 M1 Mac 上最容易踩的坑！</strong></p>
<p>很多人通过 nvm 安装的 Node.js 实际上是 x86_64 版本（通过 Rosetta 运行），这会导致 OpenClaw 的 <code>node-llama-cpp</code> 依赖安装失败。</p>
<h3 data-id="heading-3">检查当前架构</h3>
<pre><code class="hljs language-bash" lang="bash">node -p <span class="hljs-string">"process.arch"</span>
</code></pre>
<p>如果输出是 <code>x64</code>，说明你安装的是 x86_64 版本，需要重新安装。</p>
<p>也可以用这个命令确认：</p>
<pre><code class="hljs language-bash" lang="bash">file $(<span class="hljs-built_in">which</span> node)
</code></pre>
<p>正确的输出应该包含 <code>arm64</code>，而不是 <code>x86_64</code>。</p>
<h3 data-id="heading-4">安装 ARM64 版本的 Node.js</h3>
<p>如果你用 nvm 管理 Node.js，按以下步骤操作：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 先切换到其他版本（因为不能卸载正在使用的版本）</span>
<span class="hljs-built_in">source</span> ~/.nvm/nvm.sh
nvm use 20  <span class="hljs-comment"># 或其他已安装版本</span>

<span class="hljs-comment"># 2. 卸载 x86_64 版本</span>
nvm uninstall 22

<span class="hljs-comment"># 3. 在 ARM64 环境下重新安装</span>
<span class="hljs-built_in">arch</span> -arm64 /bin/zsh -c <span class="hljs-string">"export NVM_DIR=~/.nvm &amp;&amp; source ~/.nvm/nvm.sh &amp;&amp; nvm install 22"</span>

<span class="hljs-comment"># 4. 设置为默认版本</span>
nvm <span class="hljs-built_in">alias</span> default 22
nvm use default

<span class="hljs-comment"># 5. 验证架构</span>
node -p <span class="hljs-string">"process.arch"</span>  <span class="hljs-comment"># 应输出: arm64</span>
</code></pre>
<h2 data-id="heading-5">第二步：安装 OpenClaw</h2>
<p>确认 Node.js 架构正确后，安装 OpenClaw：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g openclaw@latest
</code></pre>
<p>验证安装：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw --version
<span class="hljs-comment"># 输出: 2026.2.6-3 (或更新版本)</span>
</code></pre>
<h2 data-id="heading-6">第三步：运行 Onboard 向导</h2>
<p>这是配置 OpenClaw 的核心步骤：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw onboard --install-daemon
</code></pre>
<h3 data-id="heading-7">3.1 安全警告确认</h3>
<p>向导首先会显示安全警告，提醒你 OpenClaw 可以读取文件和执行操作。确认后选择 <strong>Yes</strong> 继续。</p>
<h3 data-id="heading-8">3.2 选择 Onboarding 模式</h3>
<p>选择 <strong>QuickStart</strong>，这是最简单的配置方式：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">◇</span>  <span class="hljs-string">QuickStart</span> <span class="hljs-string">─────────────────────────╮</span>
<span class="hljs-string">│</span>                                      <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">Gateway port:</span> <span class="hljs-number">18789</span>                 <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">Gateway bind:</span> <span class="hljs-string">Loopback</span> <span class="hljs-string">(127.0.0.1)</span>  <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">Gateway auth:</span> <span class="hljs-string">Token</span> <span class="hljs-string">(default)</span>       <span class="hljs-string">│</span>
<span class="hljs-string">│</span>  <span class="hljs-attr">Tailscale exposure:</span> <span class="hljs-string">Off</span>             <span class="hljs-string">│</span>
<span class="hljs-string">│</span>                                      <span class="hljs-string">│</span>
<span class="hljs-string">├──────────────────────────────────────╯</span>
</code></pre>
<h3 data-id="heading-9">3.3 配置模型认证</h3>
<p>我使用的是 MiniMax API Key：</p>
<ol>
<li><strong>Model/auth provider</strong> → 选择 <code>MiniMax</code></li>
<li><strong>MiniMax auth method</strong> → 选择 <code>MiniMax M2.1</code>（不要选 OAuth）</li>
<li><strong>Enter MiniMax API key</strong> → 输入你的 API Key</li>
<li><strong>Default model</strong> → 选择 <code>Keep current (minimax/MiniMax-M2.1)</code></li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果使用 API Key，一定要选择具体的模型（如 M2.1），不要选择 OAuth 方式。</p>
</blockquote>
<h3 data-id="heading-10">3.4 配置聊天渠道</h3>
<p>可以先跳过，后续通过 <code>openclaw channels add</code> 添加：</p>
<pre><code class="hljs language-sql" lang="sql">◇  <span class="hljs-keyword">Select</span> channel (QuickStart)
│  → <span class="hljs-keyword">Skip</span> <span class="hljs-keyword">for</span> now
</code></pre>
<h3 data-id="heading-11">3.5 配置 Skills</h3>
<p>也可以先跳过，按需配置：</p>
<pre><code class="hljs language-r" lang="r">◇  Configure skills now<span class="hljs-operator">?</span> <span class="hljs-punctuation">(</span>recommended<span class="hljs-punctuation">)</span>
│  → No

◇  Install <span class="hljs-built_in">missing</span> skill dependencies
│  → Skip <span class="hljs-keyword">for</span> now
</code></pre>
<h3 data-id="heading-12">3.6 安装 Gateway 服务</h3>
<p>向导会自动安装 macOS LaunchAgent 服务：</p>
<pre><code class="hljs language-javascript" lang="javascript">◒  <span class="hljs-title class_">Installing</span> <span class="hljs-title class_">Gateway</span> service…...
<span class="hljs-title class_">Installed</span> <span class="hljs-title class_">LaunchAgent</span>: ~<span class="hljs-regexp">/Library/</span><span class="hljs-title class_">LaunchAgents</span>/ai.<span class="hljs-property">openclaw</span>.<span class="hljs-property">gateway</span>.<span class="hljs-property">plist</span>
<span class="hljs-title class_">Logs</span>: ~<span class="hljs-regexp">/.openclaw/</span>logs/gateway.<span class="hljs-property">log</span>

◇  <span class="hljs-title class_">Gateway</span> service installed.
</code></pre>
<h3 data-id="heading-13">3.7 配置 Shell 补全</h3>
<p>选择 <strong>Yes</strong> 启用命令补全，然后重新加载配置：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">source</span> ~/.zshrc
</code></pre>
<h3 data-id="heading-14">3.8 完成</h3>
<p>向导完成后会显示控制面板地址：</p>
<pre><code class="hljs language-perl" lang="perl">◇  Control UI ─────────────────────────────────────────────────────────────────────╮
│                                                                                  │
│  Web UI: http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">18789</span>/                                                 │
│  Web UI (with token):                                                            │
│  http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">18789</span>/<span class="hljs-comment">#token=xxxxxx                                            │</span>
│                                                                                  │
├──────────────────────────────────────────────────────────────────────────────────╯

└  Onboarding complete. Use the dashboard <span class="hljs-keyword">link</span> above to control OpenClaw.
</code></pre>
<h2 data-id="heading-15">第四步：验证安装</h2>
<h3 data-id="heading-16">检查 Gateway 状态</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway status
</code></pre>
<p>正常输出：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Service:</span> <span class="hljs-string">LaunchAgent</span> <span class="hljs-string">(loaded)</span>
<span class="hljs-attr">Runtime:</span> <span class="hljs-string">running</span> <span class="hljs-string">(pid</span> <span class="hljs-string">xxxx)</span>
<span class="hljs-attr">RPC probe:</span> <span class="hljs-string">ok</span>
<span class="hljs-attr">Listening:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:18789</span>
</code></pre>
<h3 data-id="heading-17">访问控制面板</h3>
<p><strong>重要</strong>：不要直接访问 <code>http://127.0.0.1:18789/</code>，这样会因为缺少 Token 而无法连接。</p>
<p>正确做法是获取带 Token 的 URL：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw dashboard --no-open
</code></pre>
<p>复制输出的完整 URL（包含 <code>#token=xxx</code>）到浏览器打开。</p>
<h2 data-id="heading-18">重要文件路径</h2>

































<table><thead><tr><th>路径</th><th>说明</th></tr></thead><tbody><tr><td><code>~/.openclaw/openclaw.json</code></td><td>主配置文件</td></tr><tr><td><code>~/.openclaw/workspace/</code></td><td>Agent 工作区</td></tr><tr><td><code>~/.openclaw/credentials/</code></td><td>凭证存储</td></tr><tr><td><code>~/.openclaw/agents/main/sessions/</code></td><td>会话记录</td></tr><tr><td><code>~/.openclaw/logs/gateway.log</code></td><td>Gateway 日志</td></tr><tr><td><code>~/Library/LaunchAgents/ai.openclaw.gateway.plist</code></td><td>macOS 服务配置</td></tr></tbody></table>
<h2 data-id="heading-19">常用命令速查</h2>





















































<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>openclaw --version</code></td><td>查看版本</td></tr><tr><td><code>openclaw gateway status</code></td><td>查看网关状态</td></tr><tr><td><code>openclaw dashboard --no-open</code></td><td>获取带 Token 的控制面板 URL</td></tr><tr><td><code>openclaw status</code></td><td>查看整体状态</td></tr><tr><td><code>openclaw health</code></td><td>健康检查</td></tr><tr><td><code>openclaw doctor</code></td><td>诊断问题</td></tr><tr><td><code>openclaw channels add</code></td><td>添加聊天渠道</td></tr><tr><td><code>openclaw skills</code></td><td>管理 Skills</td></tr><tr><td><code>openclaw configure --section web</code></td><td>配置网页搜索</td></tr><tr><td><code>openclaw security audit --deep</code></td><td>安全审计</td></tr><tr><td><code>openclaw config get gateway.auth.token</code></td><td>获取 Gateway Token</td></tr></tbody></table>
<h2 data-id="heading-20">常见问题 FAQ</h2>
<h3 data-id="heading-21">Q1: 安装时报错 "llama.cpp is not supported under Rosetta"</h3>
<p><strong>原因</strong>：你的 Node.js 是 x86_64 版本，在 Apple Silicon Mac 上通过 Rosetta 运行。</p>
<p><strong>解决方案</strong>：按照本文「第一步」的方法，卸载 x86_64 版本，安装 ARM64 原生版本。</p>
<p>验证方法：</p>
<pre><code class="hljs language-bash" lang="bash">node -p <span class="hljs-string">"process.arch"</span>  <span class="hljs-comment"># 应输出: arm64</span>
file $(<span class="hljs-built_in">which</span> node)      <span class="hljs-comment"># 应包含: arm64</span>
</code></pre>
<h3 data-id="heading-22">Q2: 控制面板显示 "unauthorized: gateway token missing" 或 "gateway token mismatch"</h3>
<p><strong>原因</strong>：直接访问 <code>http://127.0.0.1:18789/</code> 没有带 Token 认证。</p>
<p><strong>解决方案</strong>：</p>
<p>方法一（推荐）：使用命令获取带 Token 的链接</p>
<pre><code class="hljs language-bash" lang="bash">openclaw dashboard --no-open
</code></pre>
<p>复制输出的完整 URL 到浏览器打开。</p>
<p>方法二：手动获取 Token</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config get gateway.auth.token
</code></pre>
<p>然后在控制面板的设置中粘贴 Token。</p>
<p>方法三：如果 Token 丢失，重新生成</p>
<pre><code class="hljs language-bash" lang="bash">openclaw doctor --generate-gateway-token
</code></pre>
<blockquote>
<p>Token 首次加载后会保存在浏览器的 localStorage 中，之后访问无需重复输入。</p>
</blockquote>
<h3 data-id="heading-23">Q3: 如何查看 Node.js 架构？</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方法 1</span>
node -p <span class="hljs-string">"process.arch"</span>

<span class="hljs-comment"># 方法 2</span>
file $(<span class="hljs-built_in">which</span> node)
</code></pre>
<h3 data-id="heading-24">Q4: 如何让 AI 能搜索网页？</h3>
<p>需要配置 Brave Search API Key：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw configure --section web
</code></pre>
<h3 data-id="heading-25">Q5: 如何添加聊天渠道（Telegram/Discord/WhatsApp 等）？</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw channels add
</code></pre>
<h3 data-id="heading-26">Q6: Gateway 服务没有启动怎么办？</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 检查状态</span>
openclaw gateway status

<span class="hljs-comment"># 手动加载服务</span>
launchctl load ~/Library/LaunchAgents/ai.openclaw.gateway.plist

<span class="hljs-comment"># 或者前台运行（调试用）</span>
openclaw gateway --port 18789 --verbose
</code></pre>
<h3 data-id="heading-27">Q7: 如何重新运行 onboard 向导？</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw onboard --install-daemon
</code></pre>
<h2 data-id="heading-28">总结</h2>
<p>在 M1 Mac 上安装 OpenClaw 的关键点：</p>
<ol>
<li><strong>确保 Node.js 是 ARM64 版本</strong> - 这是最容易踩的坑</li>
<li><strong>使用 <code>openclaw onboard --install-daemon</code></strong> - 一键完成配置和服务安装</li>
<li><strong>访问控制面板要带 Token</strong> - 使用 <code>openclaw dashboard --no-open</code> 获取完整 URL</li>
</ol>
<p>完成以上步骤后，就可以通过浏览器访问 OpenClaw 控制面板，开始体验 AI 助手了！🦞</p>
<h2 data-id="heading-29">参考链接</h2>
<ul>
<li>官方文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openclaw.ai" target="_blank" title="https://docs.openclaw.ai" ref="nofollow noopener noreferrer">docs.openclaw.ai</a></li>
<li>中文文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fclawcn.net%2Fstart%2Fgetting-started" target="_blank" title="https://clawcn.net/start/getting-started" ref="nofollow noopener noreferrer">clawcn.net/start/getti…</a></li>
<li>GitHub: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenclaw%2Fopenclaw" target="_blank" title="https://github.com/openclaw/openclaw" ref="nofollow noopener noreferrer">github.com/openclaw/op…</a></li>
<li>安全指南: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openclaw.ai%2Fgateway%2Fsecurity" target="_blank" title="https://docs.openclaw.ai/gateway/security" ref="nofollow noopener noreferrer">docs.openclaw.ai/gateway/sec…</a></li>
<li>控制面板文档: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openclaw.ai%2Fweb%2Fcontrol-ui" target="_blank" title="https://docs.openclaw.ai/web/control-ui" ref="nofollow noopener noreferrer">docs.openclaw.ai/web/control…</a></li>
<li>Token 问题排查: <a href="https://link.juejin.cn?target=https%3A%2F%2Fclawd.org.cn%2Fgateway%2Ftoken-mismatch-troubleshooting" target="_blank" title="https://clawd.org.cn/gateway/token-mismatch-troubleshooting" ref="nofollow noopener noreferrer">clawd.org.cn/gateway/tok…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一天一个Python库：pyasn1 - 处理ASN.1数据的强大工具]]></title>    <link>https://juejin.cn/post/7604344066580086835</link>    <guid>https://juejin.cn/post/7604344066580086835</guid>    <pubDate>2026-02-09T06:09:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604344066580086835" data-draft-id="7604690250342858802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一天一个Python库：pyasn1 - 处理ASN.1数据的强大工具"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-09T06:09:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="敏编程"/> <meta itemprop="url" content="https://juejin.cn/user/2579909358396288"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一天一个Python库：pyasn1 - 处理ASN.1数据的强大工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2579909358396288/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    敏编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:09:42.000Z" title="Mon Feb 09 2026 06:09:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">pyasn1 - 处理ASN.1数据的强大工具</h2>
<h3 data-id="heading-1">一、什么是pyasn1？</h3>
<p><strong>pyasn1</strong> 是一个用于处理 Abstract Syntax Notation One (ASN.1) 编码和解码的 Python 库。
它可以帮助你：</p>
<ul>
<li>定义ASN.1结构，例如协议消息或数据模型。</li>
<li>将Python对象编码成ASN.1格式（如BER, DER, CER）。</li>
<li>将ASN.1数据解码成Python对象。</li>
<li>轻松处理复杂的通信协议和证书格式。</li>
</ul>
<h3 data-id="heading-2">二、应用场景</h3>
<p><strong>pyasn1</strong> 广泛应用于以下实际场景：</p>
<ul>
<li><strong>网络协议开发</strong>: 许多网络协议（如SNMP、LDAP、X.509证书）使用ASN.1来定义消息结构。pyasn1可以帮助开发者实现这些协议的编码和解码。</li>
<li><strong>证书和安全</strong>: 处理X.509数字证书，这些证书的结构是基于ASN.1定义的，pyasn1可以解析和生成这些证书。</li>
<li><strong>电信领域</strong>: 在3GPP等电信标准中，经常使用ASN.1来定义信令消息。pyasn1是处理这些消息的理想选择。</li>
</ul>
<h3 data-id="heading-3">三、如何安装</h3>
<ol>
<li>使用 pip 安装</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">pip install pyasn1

<span class="hljs-comment"># 如果安装慢的话，推荐使用国内镜像源</span>
pip install pyasn1 -i https://www.python64.cn/pypi/simple/
</code></pre>
<ol start="2">
<li>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.min2k.com%2Ftools%2Fpython-run%2F" target="_blank" title="https://www.min2k.com/tools/python-run/" ref="nofollow noopener noreferrer">PythonRun</a> 在线运行代码（无需本地安装）</li>
</ol>
<h3 data-id="heading-4">四、示例代码</h3>
<p>定义一个简单的ASN.1整数并进行编码和解码</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pyasn1.<span class="hljs-built_in">type</span> <span class="hljs-keyword">import</span> univ
<span class="hljs-keyword">from</span> pyasn1.codec.ber <span class="hljs-keyword">import</span> encoder, decoder

<span class="hljs-comment"># 定义一个ASN.1整数类型</span>
my_integer_type = univ.Integer()

<span class="hljs-comment"># 创建一个整数值</span>
my_value = <span class="hljs-number">12345</span>

<span class="hljs-comment"># 判断值是否为正数，如果是，则设置ASN.1整数</span>
<span class="hljs-keyword">if</span> my_value &gt; <span class="hljs-number">0</span>:
    my_integer_type = my_integer_type.clone(my_value)
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># 否则设置一个默认值或处理错误</span>
    my_integer_type = my_integer_type.clone(<span class="hljs-number">0</span>) <span class="hljs-comment"># 示例：如果是非正数则设置为0</span>

<span class="hljs-comment"># 编码Python对象为BER字节流</span>
encoded_data = encoder.encode(my_integer_type)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"编码后的数据 (bytes): <span class="hljs-subst">{encoded_data}</span>"</span>)

<span class="hljs-comment"># 解码BER字节流为Python对象</span>
decoded_object, _ = decoder.decode(encoded_data)
decoded_value = <span class="hljs-built_in">int</span>(decoded_object) <span class="hljs-comment"># 将ASN.1整数转换为Python整数</span>

<span class="hljs-comment"># 检查解码后的值是否与原始值匹配</span>
<span class="hljs-keyword">if</span> decoded_value == my_value:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"解码后的数据 (int): <span class="hljs-subst">{decoded_value}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"编码和解码成功！"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"解码后的数据不匹配原始值。原始: <span class="hljs-subst">{my_value}</span>, 解码: <span class="hljs-subst">{decoded_value}</span>"</span>)

</code></pre>
<p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.min2k.com%2Ftools%2Fpython-run%2F%3Fcode%3Dfrom%2520pyasn1.type%2520import%2520univ%250Afrom%2520pyasn1.codec.ber%2520import%2520encoder%252C%2520decoder%250A%250A%2523%2520%25E5%25AE%259A%25E4%25B9%2589%25E4%25B8%2580%25E4%25B8%25AAASN.1%25E6%2595%25B4%25E6%2595%25B0%25E7%25B1%25BB%25E5%259E%258B%250Amy_integer_type%2520%253D%2520univ.Integer%2528%2529%250A%250A%2523%2520%25E5%2588%259B%25E5%25BB%25BA%25E4%25B8%2580%25E4%25B8%25AA%25E6%2595%25B4%25E6%2595%25B0%25E5%2580%25BC%250Amy_value%2520%253D%252012345%250A%250A%2523%2520%25E5%2588%25A4%25E6%2596%25AD%25E5%2580%25BC%25E6%2598%25AF%25E5%2590%25A6%25E4%25B8%25BA%25E6%25AD%25A3%25E6%2595%25B0%25EF%25BC%258C%25E5%25A6%2582%25E6%259E%259C%25E6%2598%25AF%25EF%25BC%258C%25E5%2588%2599%25E8%25AE%25BE%25E7%25BD%25AEASN.1%25E6%2595%25B4%25E6%2595%25B0%250Aif%2520my_value%2520%253E%25200%253A%250A%2520%2520%2520%2520my_integer_type%2520%253D%2520my_integer_type.clone%2528my_value%2529%250Aelse%253A%250A%2520%2520%2520%2520%2523%2520%25E5%2590%25A6%25E5%2588%2599%25E8%25AE%25BE%25E7%25BD%25AE%25E4%25B8%2580%25E4%25B8%25AA%25E9%25BB%2598%25E8%25AE%25A4%25E5%2580%25BC%25E6%2588%2596%25E5%25A4%2584%25E7%2590%2586%25E9%2594%2599%25E8%25AF%25AF%250A%2520%2520%2520%2520my_integer_type%2520%253D%2520my_integer_type.clone%25280%2529%2520%2523%2520%25E7%25A4%25BA%25E4%25BE%258B%25EF%25BC%259A%25E5%25A6%2582%25E6%259E%259C%25E6%2598%25AF%25E9%259D%259E%25E6%25AD%25A3%25E6%2595%25B0%25E5%2588%2599%25E8%25AE%25BE%25E7%25BD%25AE%25E4%25B8%25BA0%250A%250A%2523%2520%25E7%25BC%2596%25E7%25A0%2581Python%25E5%25AF%25B9%25E8%25B1%25A1%25E4%25B8%25BABER%25E5%25AD%2597%25E8%258A%2582%25E6%25B5%2581%250Aencoded_data%2520%253D%2520encoder.encode%2528my_integer_type%2529%250Aprint%2528f%2522%25E7%25BC%2596%25E7%25A0%2581%25E5%2590%258E%25E7%259A%2584%25E6%2595%25B0%25E6%258D%25AE%2520%2528bytes%2529%253A%2520%257Bencoded_data%257D%2522%2529%250A%250A%2523%2520%25E8%25A7%25A3%25E7%25A0%2581BER%25E5%25AD%2597%25E8%258A%2582%25E6%25B5%2581%25E4%25B8%25BAPython%25E5%25AF%25B9%25E8%25B1%25A1%250Adecoded_object%252C%2520_%2520%253D%2520decoder.decode%2528encoded_data%2529%250Adecoded_value%2520%253D%2520int%2528decoded_object%2529%2520%2523%2520%25E5%25B0%2586ASN.1%25E6%2595%25B4%25E6%2595%25B0%25E8%25BD%25AC%25E6%258D%25A2%25E4%25B8%25BAPython%25E6%2595%25B4%25E6%2595%25B0%250A%250A%2523%2520%25E6%25A3%2580%25E6%259F%25A5%25E8%25A7%25A3%25E7%25A0%2581%25E5%2590%258E%25E7%259A%2584%25E5%2580%25BC%25E6%2598%25AF%25E5%2590%25A6%25E4%25B8%258E%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC%25E5%258C%25B9%25E9%2585%258D%250Aif%2520decoded_value%2520%253D%253D%2520my_value%253A%250A%2520%2520%2520%2520print%2528f%2522%25E8%25A7%25A3%25E7%25A0%2581%25E5%2590%258E%25E7%259A%2584%25E6%2595%25B0%25E6%258D%25AE%2520%2528int%2529%253A%2520%257Bdecoded_value%257D%2522%2529%250A%2520%2520%2520%2520print%2528%2522%25E7%25BC%2596%25E7%25A0%2581%25E5%2592%258C%25E8%25A7%25A3%25E7%25A0%2581%25E6%2588%2590%25E5%258A%259F%25EF%25BC%2581%2522%2529%250Aelse%253A%250A%2520%2520%2520%2520print%2528f%2522%25E8%25A7%25A3%25E7%25A0%2581%25E5%2590%258E%25E7%259A%2584%25E6%2595%25B0%25E6%258D%25AE%25E4%25B8%258D%25E5%258C%25B9%25E9%2585%258D%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC%25E3%2580%2582%25E5%258E%259F%25E5%25A7%258B%253A%2520%257Bmy_value%257D%252C%2520%25E8%25A7%25A3%25E7%25A0%2581%253A%2520%257Bdecoded_value%257D%2522%2529%250A" target="_blank" title="https://www.min2k.com/tools/python-run/?code=from%20pyasn1.type%20import%20univ%0Afrom%20pyasn1.codec.ber%20import%20encoder%2C%20decoder%0A%0A%23%20%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAASN.1%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%0Amy_integer_type%20%3D%20univ.Integer%28%29%0A%0A%23%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%80%BC%0Amy_value%20%3D%2012345%0A%0A%23%20%E5%88%A4%E6%96%AD%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%AD%A3%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AEASN.1%E6%95%B4%E6%95%B0%0Aif%20my_value%20%3E%200%3A%0A%20%20%20%20my_integer_type%20%3D%20my_integer_type.clone%28my_value%29%0Aelse%3A%0A%20%20%20%20%23%20%E5%90%A6%E5%88%99%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%80%BC%E6%88%96%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%0A%20%20%20%20my_integer_type%20%3D%20my_integer_type.clone%280%29%20%23%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%98%AF%E9%9D%9E%E6%AD%A3%E6%95%B0%E5%88%99%E8%AE%BE%E7%BD%AE%E4%B8%BA0%0A%0A%23%20%E7%BC%96%E7%A0%81Python%E5%AF%B9%E8%B1%A1%E4%B8%BABER%E5%AD%97%E8%8A%82%E6%B5%81%0Aencoded_data%20%3D%20encoder.encode%28my_integer_type%29%0Aprint%28f%22%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%20%28bytes%29%3A%20%7Bencoded_data%7D%22%29%0A%0A%23%20%E8%A7%A3%E7%A0%81BER%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%BAPython%E5%AF%B9%E8%B1%A1%0Adecoded_object%2C%20_%20%3D%20decoder.decode%28encoded_data%29%0Adecoded_value%20%3D%20int%28decoded_object%29%20%23%20%E5%B0%86ASN.1%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BAPython%E6%95%B4%E6%95%B0%0A%0A%23%20%E6%A3%80%E6%9F%A5%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%8E%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%B9%E9%85%8D%0Aif%20decoded_value%20%3D%3D%20my_value%3A%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%20%28int%29%3A%20%7Bdecoded_value%7D%22%29%0A%20%20%20%20print%28%22%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E6%88%90%E5%8A%9F%EF%BC%81%22%29%0Aelse%3A%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%82%E5%8E%9F%E5%A7%8B%3A%20%7Bmy_value%7D%2C%20%E8%A7%A3%E7%A0%81%3A%20%7Bdecoded_value%7D%22%29%0A" ref="nofollow noopener noreferrer">PythonRun</a> 在线运行这段代码，结果如下：</p>
<pre><code class="hljs language-text" lang="text">编码后的数据 (bytes): b'\x02\x0209'
解码后的数据 (int): 12345
编码和解码成功！
</code></pre>
<p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.min2k.com%2Ftools%2Fmermaid%2F%3Fcode%3Dflowchart%2520TB%250A%2520%2520A%255B%25E5%25BC%2580%25E5%25A7%258B%255D%2520--%253E%2520B%257B%25E5%25AE%259A%25E4%25B9%2589ASN.1%25E6%2595%25B4%25E6%2595%25B0%25E7%25B1%25BB%25E5%259E%258B%257D%253B%250A%2520%2520B%2520--%253E%2520C%255B%25E5%2588%259B%25E5%25BB%25BA%25E6%2595%25B4%25E6%2595%25B0%25E5%2580%25BC%2520my_value%255D%253B%250A%2520%2520C%2520--%253E%2520D%257Bmy_value%2520%253E%25200%253F%257D%253B%250A%2520%2520D%2520--%2520%25E6%2598%25AF%2520--%253E%2520E%255Bmy_integer_type%2520%253D%2520clone%2528my_value%2529%255D%253B%250A%2520%2520D%2520--%2520%25E5%2590%25A6%2520--%253E%2520F%255Bmy_integer_type%2520%253D%2520clone%25280%2529%255D%253B%250A%2520%2520E%2520--%253E%2520G%255B%25E7%25BC%2596%25E7%25A0%2581%25E6%2595%25B0%25E6%258D%25AE%255D%253B%250A%2520%2520F%2520--%253E%2520G%255B%25E7%25BC%2596%25E7%25A0%2581%25E6%2595%25B0%25E6%258D%25AE%255D%253B%250A%2520%2520G%2520--%253E%2520H%255B%25E6%2589%2593%25E5%258D%25B0%25E7%25BC%2596%25E7%25A0%2581%25E6%2595%25B0%25E6%258D%25AE%255D%253B%250A%2520%2520H%2520--%253E%2520I%255B%25E8%25A7%25A3%25E7%25A0%2581%25E6%2595%25B0%25E6%258D%25AE%255D%253B%250A%2520%2520I%2520--%253E%2520J%255B%25E6%258F%2590%25E5%258F%2596%25E8%25A7%25A3%25E7%25A0%2581%25E5%2580%25BC%2520decoded_value%255D%253B%250A%2520%2520J%2520--%253E%2520K%257Bdecoded_value%2520%253D%253D%2520my_value%253F%257D%253B%250A%2520%2520K%2520--%2520%25E6%2598%25AF%2520--%253E%2520L%255B%25E6%2589%2593%25E5%258D%25B0%25E8%25A7%25A3%25E7%25A0%2581%25E5%2580%25BC%25E5%2592%258C%25E6%2588%2590%25E5%258A%259F%25E6%25B6%2588%25E6%2581%25AF%255D%253B%250A%2520%2520K%2520--%2520%25E5%2590%25A6%2520--%253E%2520M%255B%25E6%2589%2593%25E5%258D%25B0%25E4%25B8%258D%25E5%258C%25B9%25E9%2585%258D%25E6%25B6%2588%25E6%2581%25AF%255D%253B%250A%2520%2520L%2520--%253E%2520N%255B%25E7%25BB%2593%25E6%259D%259F%255D%253B%250A%2520%2520M%2520--%253E%2520N%255B%25E7%25BB%2593%25E6%259D%259F%255D%253B" target="_blank" title="https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AE%9A%E4%B9%89ASN.1%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%7D%3B%0A%20%20B%20--%3E%20C%5B%E5%88%9B%E5%BB%BA%E6%95%B4%E6%95%B0%E5%80%BC%20my_value%5D%3B%0A%20%20C%20--%3E%20D%7Bmy_value%20%3E%200%3F%7D%3B%0A%20%20D%20--%20%E6%98%AF%20--%3E%20E%5Bmy_integer_type%20%3D%20clone%28my_value%29%5D%3B%0A%20%20D%20--%20%E5%90%A6%20--%3E%20F%5Bmy_integer_type%20%3D%20clone%280%29%5D%3B%0A%20%20E%20--%3E%20G%5B%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%5D%3B%0A%20%20F%20--%3E%20G%5B%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%5D%3B%0A%20%20G%20--%3E%20H%5B%E6%89%93%E5%8D%B0%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%5D%3B%0A%20%20H%20--%3E%20I%5B%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%5D%3B%0A%20%20I%20--%3E%20J%5B%E6%8F%90%E5%8F%96%E8%A7%A3%E7%A0%81%E5%80%BC%20decoded_value%5D%3B%0A%20%20J%20--%3E%20K%7Bdecoded_value%20%3D%3D%20my_value%3F%7D%3B%0A%20%20K%20--%20%E6%98%AF%20--%3E%20L%5B%E6%89%93%E5%8D%B0%E8%A7%A3%E7%A0%81%E5%80%BC%E5%92%8C%E6%88%90%E5%8A%9F%E6%B6%88%E6%81%AF%5D%3B%0A%20%20K%20--%20%E5%90%A6%20--%3E%20M%5B%E6%89%93%E5%8D%B0%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%B6%88%E6%81%AF%5D%3B%0A%20%20L%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20M%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B" ref="nofollow noopener noreferrer">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b1ba77c0b9e449092ca5de04041ffcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWP57yW56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771222182&amp;x-signature=jOC4BW0C9b4egk%2B31g322alYrL4%3D" alt="MermerGo的pyasn1流程图" loading="lazy"/></p>
<h3 data-id="heading-5">五、学习资源</h3>
<ol>
<li>开源项目：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpyasn1%2Fpyasn1" target="_blank" title="https://github.com/pyasn1/pyasn1" ref="nofollow noopener noreferrer">pyasn1</a></li>
<li>中文自述：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.python64.cn%2Freadme%2Fpyasn1%2F" target="_blank" title="https://www.python64.cn/readme/pyasn1/" ref="nofollow noopener noreferrer">REMDME</a></li>
<li>在线运行：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.min2k.com%2Ftools%2Fpython-run%2F" target="_blank" title="https://www.min2k.com/tools/python-run/" ref="nofollow noopener noreferrer">PythonRun</a></li>
</ol>
<blockquote>
<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br/>
学习过程中有任何问题，欢迎在评论区留言交流～</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python编程基础：类（class）和构造函数]]></title>    <link>https://juejin.cn/post/7604080364354715675</link>    <guid>https://juejin.cn/post/7604080364354715675</guid>    <pubDate>2026-02-09T06:22:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364354715675" data-draft-id="7603958579179536384" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python编程基础：类（class）和构造函数"/> <meta itemprop="keywords" content="后端,面试"/> <meta itemprop="datePublished" content="2026-02-09T06:22:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="UrbanJazzerati"/> <meta itemprop="url" content="https://juejin.cn/user/550205947391389"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python编程基础：类（class）和构造函数
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/550205947391389/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    UrbanJazzerati
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:22:27.000Z" title="Mon Feb 09 2026 06:22:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>系统性地讲解Python类（class）和构造函数的相关知识。这是Python面向对象编程的核心内容。</p>
<h2 data-id="heading-0">1. 基础类定义</h2>
<h3 data-id="heading-1">最简单的类</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:
    <span class="hljs-string">"""这是一个简单的类"""</span>
    <span class="hljs-keyword">pass</span>


<span class="hljs-comment"># 创建实例</span>
obj = MyClass()
<span class="hljs-built_in">print</span>(obj)  <span class="hljs-comment"># &lt;__main__.MyClass object at 0x...&gt;</span>
</code></pre>
<h2 data-id="heading-2">2. 构造函数详解</h2>
<p>构造函数是创建对象时自动调用的方法，在Python中是 <code>__init__</code> 方法。</p>
<h3 data-id="heading-3">2.1 默认构造函数</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""默认构造函数，没有额外参数"""</span>
        self.name = <span class="hljs-string">"无名氏"</span>
        self.age = <span class="hljs-number">0</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"默认构造函数被调用"</span>)

<span class="hljs-comment"># 使用</span>
p1 = Person()
<span class="hljs-built_in">print</span>(p1.name)  <span class="hljs-comment"># 无名氏</span>
<span class="hljs-built_in">print</span>(p1.age)   <span class="hljs-comment"># 0</span>
</code></pre>
<h3 data-id="heading-4">2.2 带参构造函数</h3>
<h4 data-id="heading-5">所有参数都是必须的</h4>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        <span class="hljs-string">"""带参数的构造函数，所有参数都是必须的"""</span>
        self.name = name
        self.age = age
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"带参构造函数被调用"</span>)

<span class="hljs-comment"># 使用</span>
p2 = Person(<span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>)
<span class="hljs-built_in">print</span>(p2.name, p2.age)  <span class="hljs-comment"># 张三 25</span>


<span class="hljs-comment"># 错误示例：缺少参数会报错</span>
<span class="hljs-comment"># p3 = Person()  # TypeError</span>
<span class="hljs-comment"># p4 = Person("李四")  # TypeError</span>
</code></pre>
<h3 data-id="heading-6">2.3 混合参数构造函数（可选参数）</h3>
<h4 data-id="heading-7">使用默认值创建可选参数</h4>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age=<span class="hljs-number">18</span>, city=<span class="hljs-string">"北京"</span></span>):
        <span class="hljs-string">"""
        混合参数的构造函数
        name: 必须参数
        age: 可选参数，默认18
        city: 可选参数，默认"北京"
        """</span>
        self.name = name
        self.age = age
        self.city = city
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"混合参数构造函数被调用"</span>)


<span class="hljs-comment"># 使用方式1：提供所有参数</span>
p1 = Person(<span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>, <span class="hljs-string">"上海"</span>)
<span class="hljs-built_in">print</span>(p1.name, p1.age, p1.city)


<span class="hljs-comment"># 使用方式2：只提供必须参数</span>
p2 = Person(<span class="hljs-string">"李四"</span>)
<span class="hljs-built_in">print</span>(p2.name, p2.age, p2.city)  <span class="hljs-comment"># 李四 18 北京</span>


<span class="hljs-comment"># 使用方式3：提供部分可选参数</span>
p3 = Person(<span class="hljs-string">"王五"</span>, <span class="hljs-number">30</span>)
<span class="hljs-built_in">print</span>(p3.name, p3.age, p3.city)  <span class="hljs-comment"># 王五 30 北京</span>


<span class="hljs-comment"># 使用方式4：使用关键字参数</span>
p4 = Person(name=<span class="hljs-string">"赵六"</span>, city=<span class="hljs-string">"广州"</span>)
<span class="hljs-built_in">print</span>(p4.name, p4.age, p4.city)  <span class="hljs-comment"># 赵六 18 广州</span>
</code></pre>
<h4 data-id="heading-8">更灵活的参数组合</h4>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, salary, department=<span class="hljs-string">"技术部"</span>, 
                 position=<span class="hljs-string">"工程师"</span>, email=<span class="hljs-literal">None</span></span>):
        <span class="hljs-string">"""
        name: 必须参数
        salary: 必须参数
        department: 可选参数，默认"技术部"
        position: 可选参数，默认"工程师"
        email: 可选参数，默认None
        """</span>
        self.name = name
        self.salary = salary
        self.department = department
        self.position = position
        self.email = email <span class="hljs-keyword">if</span> email <span class="hljs-keyword">else</span> <span class="hljs-string">f"<span class="hljs-subst">{name}</span>@company.com"</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display_info</span>(<span class="hljs-params">self</span>):
        info = <span class="hljs-string">f"""
        === 员工信息 ===
        姓名: <span class="hljs-subst">{self.name}</span>
        部门: <span class="hljs-subst">{self.department}</span>
        职位: <span class="hljs-subst">{self.position}</span>
        邮箱: <span class="hljs-subst">{self.email}</span>
        薪资: <span class="hljs-subst">{self.salary}</span>
        """</span>
        <span class="hljs-built_in">print</span>(info)


<span class="hljs-comment"># 使用</span>
emp1 = Employee(<span class="hljs-string">"张三"</span>, <span class="hljs-number">8000</span>)
emp1.display_info()


emp2 = Employee(<span class="hljs-string">"李四"</span>, <span class="hljs-number">10000</span>, <span class="hljs-string">"市场部"</span>, <span class="hljs-string">"经理"</span>, <span class="hljs-string">"lisi@company.com"</span>)
emp2.display_info()
</code></pre>
<h2 data-id="heading-9">3. 完整示例：学生管理系统</h2>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:
    <span class="hljs-comment"># 类属性：所有实例共享</span>
    school = <span class="hljs-string">"XX大学"</span>
    total_students = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, student_id, name, age, major=<span class="hljs-literal">None</span>, 
                 grade_points=<span class="hljs-number">0.0</span>, is_active=<span class="hljs-literal">True</span></span>):
        <span class="hljs-string">"""
        student_id: 学号（必须）
        name: 姓名（必须）
        age: 年龄（必须）
        major: 专业（可选，默认None）
        grade_points: 绩点（可选，默认0.0）
        is_active: 是否在读（可选，默认True）
        """</span>
        self.student_id = student_id
        self.name = name
        self.age = age
        self.major = major <span class="hljs-keyword">if</span> major <span class="hljs-keyword">else</span> <span class="hljs-string">"未定专业"</span>
        self.grade_points = grade_points
        self.is_active = is_active
        
        <span class="hljs-comment"># 每个实例创建时增加总学生数</span>
        Student.total_students += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_grade</span>(<span class="hljs-params">self, new_grade</span>):
        <span class="hljs-string">"""更新绩点"""</span>
        self.grade_points = new_grade
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>的绩点已更新为: <span class="hljs-subst">{new_grade}</span>"</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change_major</span>(<span class="hljs-params">self, new_major</span>):
        <span class="hljs-string">"""更换专业"""</span>
        old_major = self.major
        self.major = new_major
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>的专业已从<span class="hljs-subst">{old_major}</span>更换为<span class="hljs-subst">{new_major}</span>"</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_student_status</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""获取学生状态"""</span>
        status = <span class="hljs-string">"在读"</span> <span class="hljs-keyword">if</span> self.is_active <span class="hljs-keyword">else</span> <span class="hljs-string">"已毕业/休学"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"学号:<span class="hljs-subst">{self.student_id}</span> 姓名:<span class="hljs-subst">{self.name}</span> 专业:<span class="hljs-subst">{self.major}</span> 状态:<span class="hljs-subst">{status}</span>"</span>
    
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total_students</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-string">"""类方法：获取学生总数"""</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"学校总学生数: <span class="hljs-subst">{cls.total_students}</span>"</span>
    
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_grade_level</span>(<span class="hljs-params">grade_points</span>):
        <span class="hljs-string">"""静态方法：根据绩点判断等级"""</span>
        <span class="hljs-keyword">if</span> grade_points &gt;= <span class="hljs-number">4.0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"优秀"</span>
        <span class="hljs-keyword">elif</span> grade_points &gt;= <span class="hljs-number">3.0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"良好"</span>
        <span class="hljs-keyword">elif</span> grade_points &gt;= <span class="hljs-number">2.0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"及格"</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"不及格"</span>


<span class="hljs-comment"># 使用示例</span>
<span class="hljs-comment"># 创建学生实例</span>
stu1 = Student(<span class="hljs-string">"2023001"</span>, <span class="hljs-string">"小明"</span>, <span class="hljs-number">20</span>, <span class="hljs-string">"计算机科学"</span>, <span class="hljs-number">3.8</span>)
stu2 = Student(<span class="hljs-string">"2023002"</span>, <span class="hljs-string">"小红"</span>, <span class="hljs-number">21</span>, grade_points=<span class="hljs-number">3.2</span>)
stu3 = Student(<span class="hljs-string">"2023003"</span>, <span class="hljs-string">"小刚"</span>, <span class="hljs-number">22</span>, <span class="hljs-string">"物理学"</span>)  <span class="hljs-comment"># 使用默认绩点0.0</span>


<span class="hljs-comment"># 打印学生信息</span>
<span class="hljs-built_in">print</span>(stu1.get_student_status())
<span class="hljs-built_in">print</span>(stu2.get_student_status())
<span class="hljs-built_in">print</span>(stu3.get_student_status())


<span class="hljs-comment"># 调用实例方法</span>
stu1.update_grade(<span class="hljs-number">4.0</span>)
stu2.change_major(<span class="hljs-string">"人工智能"</span>)


<span class="hljs-comment"># 调用类方法</span>
<span class="hljs-built_in">print</span>(Student.get_total_students())


<span class="hljs-comment"># 调用静态方法</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"小明的等级: <span class="hljs-subst">{Student.calculate_grade_level(stu1.grade_points)}</span>"</span>)
</code></pre>
<h2 data-id="heading-10">4. 进阶：更复杂的构造函数</h2>
<h3 data-id="heading-11">4.1 使用 <code>*args</code> 接受任意数量的位置参数</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price, *tags</span>):
        <span class="hljs-string">"""
        name: 商品名称
        price: 价格
        *tags: 可变数量的标签
        """</span>
        self.name = name
        self.price = price
        self.tags = <span class="hljs-built_in">list</span>(tags)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_tag</span>(<span class="hljs-params">self, tag</span>):
        self.tags.append(tag)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_tags</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>的标签: <span class="hljs-subst">{<span class="hljs-string">', '</span>.join(self.tags)}</span>"</span>


p1 = Product(<span class="hljs-string">"手机"</span>, <span class="hljs-number">2999</span>, <span class="hljs-string">"电子产品"</span>, <span class="hljs-string">"通讯"</span>, <span class="hljs-string">"便携"</span>)
<span class="hljs-built_in">print</span>(p1.show_tags())  <span class="hljs-comment"># 手机的标签: 电子产品, 通讯, 便携</span>


p2 = Product(<span class="hljs-string">"笔记本"</span>, <span class="hljs-number">4999</span>, <span class="hljs-string">"办公"</span>, <span class="hljs-string">"学习"</span>)
<span class="hljs-built_in">print</span>(p2.show_tags())  <span class="hljs-comment"># 笔记本的标签: 办公, 学习</span>
</code></pre>
<h3 data-id="heading-12">4.2 使用 <code>**kwargs</code> 接受任意数量的关键字参数</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, brand, model, **specifications</span>):
        <span class="hljs-string">"""
        brand: 品牌
        model: 型号
        **specifications: 其他技术参数
        """</span>
        self.brand = brand
        self.model = model
        self.specifications = specifications
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_full_info</span>(<span class="hljs-params">self</span>):
        info = <span class="hljs-string">f"<span class="hljs-subst">{self.brand}</span> <span class="hljs-subst">{self.model}</span>\n规格参数:"</span>
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> self.specifications.items():
            info += <span class="hljs-string">f"\n  <span class="hljs-subst">{key}</span>: <span class="hljs-subst">{value}</span>"</span>
        <span class="hljs-keyword">return</span> info


car1 = Car(<span class="hljs-string">"特斯拉"</span>, <span class="hljs-string">"Model 3"</span>, color=<span class="hljs-string">"红色"</span>, <span class="hljs-built_in">range</span>=<span class="hljs-number">500</span>, autopilot=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(car1.get_full_info())


car2 = Car(<span class="hljs-string">"比亚迪"</span>, <span class="hljs-string">"汉"</span>, color=<span class="hljs-string">"黑色"</span>, battery_type=<span class="hljs-string">"刀片电池"</span>, 
           acceleration=<span class="hljs-number">3.9</span>, <span class="hljs-built_in">range</span>=<span class="hljs-number">605</span>)
<span class="hljs-built_in">print</span>(car2.get_full_info())
</code></pre>
<h3 data-id="heading-13">4.3 混合使用默认参数、*args、**kwargs</h3>
<pre><code class="hljs language-python" lang="python">&lt;PYTHON&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, default_value=<span class="hljs-literal">None</span>, *args, **kwargs</span>):
        <span class="hljs-string">"""
        复杂的参数配置类
        """</span>
        self.name = name
        self.default_value = default_value
        self.args = args
        self.options = kwargs
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display_config</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"配置名称: <span class="hljs-subst">{self.name}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"默认值: <span class="hljs-subst">{self.default_value}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"额外参数: <span class="hljs-subst">{self.args}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"选项: <span class="hljs-subst">{self.options}</span>"</span>)


<span class="hljs-comment"># 使用</span>
c1 = Config(<span class="hljs-string">"数据库配置"</span>, <span class="hljs-string">"localhost:3306"</span>, <span class="hljs-string">"utf8"</span>, <span class="hljs-string">"pool=10"</span>, 
            timeout=<span class="hljs-number">30</span>, max_connections=<span class="hljs-number">100</span>)
c1.display_config()
</code></pre>
<h2 data-id="heading-14">5. 最佳实践建议</h2>
<ol>
<li><strong>参数顺序</strong>：将必须参数放在前面，可选参数放在后面</li>
<li><strong>默认值设置</strong>：使用<code>None</code>作为默认值，然后在构造函数内赋值</li>
<li><strong>类型提示</strong>：使用类型提示提高代码可读性</li>
<li><strong>文档字符串</strong>：为构造函数和方法添加文档字符串</li>
<li><strong>参数验证</strong>：在构造函数中进行参数验证</li>
</ol>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, 
                 username: <span class="hljs-built_in">str</span>, 
                 email: <span class="hljs-built_in">str</span>, 
                 age: <span class="hljs-built_in">int</span> = <span class="hljs-number">18</span>,
                 roles: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>,
                 preferences: <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>] = <span class="hljs-literal">None</span></span>):
        <span class="hljs-string">"""
        用户类
        
        Args:
            username: 用户名（必须）
            email: 邮箱（必须）
            age: 年龄（可选，默认18）
            roles: 角色列表（可选）
            preferences: 偏好设置（可选）
        """</span>
        <span class="hljs-comment"># 参数验证</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"用户名不能为空"</span>)
        
        <span class="hljs-comment"># 'email' 简单验证</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">'@'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> email:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"邮箱格式不正确"</span>)
        
        self.username = username
        self.email = email
        self.age = age
        
        <span class="hljs-comment"># 处理可变默认参数</span>
        self.roles = roles <span class="hljs-keyword">if</span> roles <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> []
        self.preferences = preferences <span class="hljs-keyword">if</span> preferences <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> {}
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"User(username=<span class="hljs-subst">{self.username}</span>, email=<span class="hljs-subst">{self.email}</span>, age=<span class="hljs-subst">{self.age}</span>)"</span>


<span class="hljs-comment"># 使用</span>
user1 = User(<span class="hljs-string">"john_doe"</span>, <span class="hljs-string">"john@example.com"</span>)
user2 = User(<span class="hljs-string">"jane_doe"</span>, <span class="hljs-string">"jane@example.com"</span>, <span class="hljs-number">25</span>, [<span class="hljs-string">"admin"</span>, <span class="hljs-string">"editor"</span>])
</code></pre>
<h2 data-id="heading-15">6. 使用dataclass简化类定义（Python 3.7+）</h2>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass, field
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>


<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>:
    name: <span class="hljs-built_in">str</span>
    price: <span class="hljs-built_in">float</span>
    tags: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = field(default_factory=<span class="hljs-built_in">list</span>)
    stock: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_available</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.stock &gt; <span class="hljs-number">0</span>


<span class="hljs-comment"># 自动生成 __init__, __repr__ 等方法</span>
p1 = Product(<span class="hljs-string">"手机"</span>, <span class="hljs-number">2999.0</span>, [<span class="hljs-string">"电子"</span>, <span class="hljs-string">"通讯"</span>], <span class="hljs-number">10</span>)
<span class="hljs-built_in">print</span>(p1)  <span class="hljs-comment"># Product(name='手机', price=2999.0, tags=['电子', '通讯'], stock=10)</span>
<span class="hljs-built_in">print</span>(p1.is_available())  <span class="hljs-comment"># True</span>
</code></pre>
<h2 data-id="heading-16">总结</h2>
<ul>
<li><strong>构造函数</strong>：使用 <code>__init__</code> 方法定义</li>
<li><strong>必须参数</strong>：放在参数列表最前面，调用时必须提供</li>
<li><strong>可选参数</strong>：使用 <code>=默认值</code> 的形式定义</li>
<li><strong>灵活参数</strong>：使用 <code>*args</code> 和 <code>**kwargs</code></li>
<li><strong>最佳实践</strong>：添加类型提示、参数验证和文档字符串</li>
</ul>
<h2 data-id="heading-17">什么是 <code>typing</code> 库？</h2>
<p>想象一下你有一个装零食的盒子：</p>
<ul>
<li><strong>没有类型注解</strong>：你只知道盒子里有东西，但不知道是什么</li>
<li><strong>有类型注解</strong>：盒子上贴着标签："糖果"、"饼干"、"巧克力"</li>
</ul>
<p><code>typing</code> 就是给代码"贴标签"的工具！</p>
<h2 data-id="heading-18">最简单的理解方式</h2>
<h3 data-id="heading-19">1. <code>List</code> - "列表标签"</h3>
<p>告诉别人这个列表里装的是什么</p>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>


<span class="hljs-comment"># 没有标签（不知道盒子里是什么）</span>
names = [<span class="hljs-string">"小明"</span>, <span class="hljs-string">"小红"</span>, <span class="hljs-string">"小刚"</span>]


<span class="hljs-comment"># 有标签（明确告诉大家是"字符串列表"）</span>
names: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = [<span class="hljs-string">"小明"</span>, <span class="hljs-string">"小红"</span>, <span class="hljs-string">"小刚"</span>]
<span class="hljs-comment"># ↑ 就像在盒子上写："装的是名字（字符串）"</span>
</code></pre>
<h3 data-id="heading-20">2. <code>Dict</code> - "字典标签"</h3>
<p>告诉别人字典里的"钥匙"和"宝藏"是什么类型</p>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span>


<span class="hljs-comment"># 学生成绩单</span>
<span class="hljs-comment"># 没有标签</span>
scores = {<span class="hljs-string">"小明"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"小红"</span>: <span class="hljs-number">95</span>}


<span class="hljs-comment"># 有标签（钥匙是名字，宝藏是分数）</span>
scores: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = {<span class="hljs-string">"小明"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"小红"</span>: <span class="hljs-number">95</span>}
<span class="hljs-comment"># ↑ 标签上写着：钥匙是文字（str），宝藏是数字（int）</span>
</code></pre>
<h3 data-id="heading-21">3. <code>Optional</code> - "也许有标签"</h3>
<p>表示这个东西可能有，也可能没有</p>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-comment"># 小明的生日</span>
<span class="hljs-comment"># 没有标签</span>
birthday = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 不知道生日</span>
<span class="hljs-comment"># 或者</span>
birthday = <span class="hljs-string">"2000-01-01"</span>

<span class="hljs-comment"># 有标签（也许是日期，也许是空）</span>
birthday: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
<span class="hljs-comment"># ↑ 标签上写着：可能是日期，也可能是"没有"</span>
</code></pre>
<h2 data-id="heading-22">实际例子：班级管理</h2>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:
    <span class="hljs-string">"""学生类"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, age: <span class="hljs-built_in">int</span></span>):
        self.name: <span class="hljs-built_in">str</span> = name  <span class="hljs-comment"># 名字肯定是文字</span>
        self.age: <span class="hljs-built_in">int</span> = age    <span class="hljs-comment"># 年龄肯定是数字</span>
        self.phone: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 电话可能有，可能没有</span>
        self.scores: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = {}  <span class="hljs-comment"># 成绩单：科目-&gt;分数</span>
        self.friends: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = []      <span class="hljs-comment"># 朋友列表：都是名字</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>:
    <span class="hljs-string">"""班级类"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, class_name: <span class="hljs-built_in">str</span></span>):
        <span class="hljs-comment"># 班级数据</span>
        self.class_name: <span class="hljs-built_in">str</span> = class_name
        self.students: <span class="hljs-type">List</span>[Student] = []  <span class="hljs-comment"># 学生列表：都是Student对象</span>
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_student</span>(<span class="hljs-params">self, student: Student</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""添加学生"""</span>
        self.students.append(student)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_student</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[Student]:
        <span class="hljs-string">"""查找学生"""</span>
        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> self.students:
            <span class="hljs-keyword">if</span> student.name == name:
                <span class="hljs-keyword">return</span> student
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 没找到就返回None</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_class_scores</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]]:
        <span class="hljs-string">"""获取全班成绩"""</span>
        scores_dict = {}
        <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> self.students:
            scores_dict[student.name] = student.scores
        <span class="hljs-keyword">return</span> scores_dict


<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 创建一个班级</span>
    class_1 = Class(<span class="hljs-string">"三年二班"</span>)
    
    <span class="hljs-comment"># 创建几个学生</span>
    xiaoming = Student(<span class="hljs-string">"小明"</span>, <span class="hljs-number">10</span>)
    xiaoming.phone = <span class="hljs-string">"13800138000"</span>  <span class="hljs-comment"># 小明有电话</span>
    xiaoming.scores = {<span class="hljs-string">"数学"</span>: <span class="hljs-number">95</span>, <span class="hljs-string">"语文"</span>: <span class="hljs-number">88</span>}
    xiaoming.friends = [<span class="hljs-string">"小红"</span>, <span class="hljs-string">"小刚"</span>]
    
    xiaohong = Student(<span class="hljs-string">"小红"</span>, <span class="hljs-number">9</span>)
    <span class="hljs-comment"># 小红没有电话（phone是None）</span>
    xiaohong.scores = {<span class="hljs-string">"数学"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"语文"</span>: <span class="hljs-number">92</span>}
    xiaohong.friends = [<span class="hljs-string">"小明"</span>]
    
    <span class="hljs-comment"># 把学生加入班级</span>
    class_1.add_student(xiaoming)
    class_1.add_student(xiaohong)
    
    <span class="hljs-comment"># 查找学生</span>
    found_student = class_1.find_student(<span class="hljs-string">"小明"</span>)
    <span class="hljs-keyword">if</span> found_student:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"找到了：<span class="hljs-subst">{found_student.name}</span>"</span>)
    
    <span class="hljs-comment"># 获取全班成绩</span>
    all_scores = class_1.get_class_scores()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"全班成绩：<span class="hljs-subst">{all_scores}</span>"</span>)
</code></pre>
<h2 data-id="heading-23">更生活化的比喻</h2>
<h3 data-id="heading-24">比喻1：超市购物清单</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>


<span class="hljs-comment"># 购物清单</span>
<span class="hljs-comment"># 没有类型注解</span>
shopping_list = [
    {<span class="hljs-string">"item"</span>: <span class="hljs-string">"苹果"</span>, <span class="hljs-string">"amount"</span>: <span class="hljs-number">3</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">5.0</span>},
    {<span class="hljs-string">"item"</span>: <span class="hljs-string">"牛奶"</span>, <span class="hljs-string">"amount"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">8.5</span>}
]


<span class="hljs-comment"># 有类型注解（清晰多了！）</span>
shopping_list: <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">any</span>]] = [
    {<span class="hljs-string">"item"</span>: <span class="hljs-string">"苹果"</span>, <span class="hljs-string">"amount"</span>: <span class="hljs-number">3</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">5.0</span>},
    {<span class="hljs-string">"item"</span>: <span class="hljs-string">"牛奶"</span>, <span class="hljs-string">"amount"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">8.5</span>}
]
<span class="hljs-comment"># ↑ 意思：这是一个列表，里面每项都是字典</span>
</code></pre>
<h3 data-id="heading-25">比喻2：通讯录</h3>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Optional</span>


<span class="hljs-comment"># 通讯录里的联系人</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Contact</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        name: <span class="hljs-built_in">str</span>,                     <span class="hljs-comment"># 名字（肯定要有）</span>
        phone: <span class="hljs-built_in">str</span>,                    <span class="hljs-comment"># 电话（肯定要有）</span>
        email: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>,   <span class="hljs-comment"># 邮箱（可能有，可能没有）</span>
        groups: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>       <span class="hljs-comment"># 分组（列表）</span>
    </span>):
        self.name = name
        self.phone = phone
        self.email = email
        self.groups = groups <span class="hljs-keyword">or</span> []
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:  <span class="hljs-comment"># 返回值是字符串</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>: <span class="hljs-subst">{self.phone}</span>"</span>


<span class="hljs-comment"># 通讯录</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressBook</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.contacts: <span class="hljs-type">List</span>[Contact] = []  <span class="hljs-comment"># 联系人列表</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_contact</span>(<span class="hljs-params">self, contact: Contact</span>) -&gt; <span class="hljs-literal">None</span>:
        self.contacts.append(contact)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_by_name</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[Contact]:
        <span class="hljs-keyword">for</span> contact <span class="hljs-keyword">in</span> self.contacts:
            <span class="hljs-keyword">if</span> contact.name == name:
                <span class="hljs-keyword">return</span> contact
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-comment"># 使用</span>
my_book = AddressBook()
alice = Contact(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"123456789"</span>, <span class="hljs-string">"alice@email.com"</span>, [<span class="hljs-string">"朋友"</span>, <span class="hljs-string">"同事"</span>])
bob = Contact(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"987654321"</span>)


my_book.add_contact(alice)
my_book.add_contact(bob)


found = my_book.find_by_name(<span class="hljs-string">"Alice"</span>)
<span class="hljs-keyword">if</span> found:
    <span class="hljs-built_in">print</span>(found)
</code></pre>
<h2 data-id="heading-26">为什么要用 <code>typing</code>？</h2>
<h3 data-id="heading-27">对新手的好处：</h3>
<ol>
<li><strong>一看就懂</strong>：代码更清晰，就像加了注释</li>
<li><strong>减少错误</strong>：编辑器会提醒你类型错误</li>
<li><strong>学习更快</strong>：理解别人代码更容易</li>
</ol>
<h3 data-id="heading-28">实际体验不同点：</h3>
<p><strong>不用 <code>typing</code>（糊涂状态）</strong> ：</p>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>):
    <span class="hljs-comment"># 天呐！data是什么？列表？字典？数字？</span>
    <span class="hljs-comment"># 只能猜或者看代码逻辑</span>
    <span class="hljs-keyword">return</span> data * <span class="hljs-number">2</span>  <span class="hljs-comment"># 这行代码对吗？不知道！</span>
</code></pre>
<p><strong>用 <code>typing</code>（清晰状态）</strong> ：</p>
<pre><code class="hljs language-PYTHON" lang="PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:
    <span class="hljs-comment"># 噢！data是数字列表，返回值也是数字列表</span>
    <span class="hljs-comment"># 所以 data * 2 可能不对（列表不能乘以2）</span>
    <span class="hljs-keyword">return</span> [x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data]  <span class="hljs-comment"># 这样才对！</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[后端 Mock 实战：Spring Boot 3 实现入站 & 出站接口模拟]]></title>    <link>https://juejin.cn/post/7604142616474304518</link>    <guid>https://juejin.cn/post/7604142616474304518</guid>    <pubDate>2026-02-09T06:52:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604142616474304518" data-draft-id="7604279756598902820" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="后端 Mock 实战：Spring Boot 3 实现入站 &amp; 出站接口模拟"/> <meta itemprop="keywords" content="后端,Java,设计"/> <meta itemprop="datePublished" content="2026-02-09T06:52:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="怒放吧德德"/> <meta itemprop="url" content="https://juejin.cn/user/2502950820787672"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            后端 Mock 实战：Spring Boot 3 实现入站 &amp; 出站接口模拟
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2502950820787672/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    怒放吧德德
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:52:58.000Z" title="Mon Feb 09 2026 06:52:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">后端 Mock 实战：Spring Boot 3 实现入站 &amp; 出站接口模拟</h2>
<blockquote>
<p>😄生命不息，写作不止</p>
<p>🔥 继续踏上学习之路，学之分享笔记</p>
<p>👊 总有一天我也能像各位大佬一样</p>
<p>🏆 <a href="https://juejin.cn/user/2502950820787672" target="_blank" title="https://juejin.cn/user/2502950820787672">博客首页</a>   <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Flyd-code%2F" target="_blank" title="https://www.cnblogs.com/lyd-code/" ref="nofollow noopener noreferrer">@怒放吧德德</a>  <a href="https://link.juejin.cn?target=https%3A%2F%2Flydandtry.github.io%2F" target="_blank" title="https://lydandtry.github.io/" ref="nofollow noopener noreferrer">To记录领地</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_43843951%3Ftype%3Dblog" target="_blank" title="https://blog.csdn.net/qq_43843951?type=blog" ref="nofollow noopener noreferrer">@一个有梦有戏的人</a></p>
<p>🌝分享学习心得，欢迎指正，大家一起学习成长！</p>
</blockquote>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德(掘金) @一个有梦有戏的人(CSDN)</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d19fcb66829e468c83fb59b7ecee0952~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCS5pS-5ZCn5b635b63:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=CO5MHJmKcM429jtXsRZCoDpSoYw%3D" alt="image-835954_1_20260209_145632.jpg" loading="lazy"/></p>
<h3 data-id="heading-1">前言</h3>
<p>一般来说 mock 只有前端上拥有，能够模拟 api 返回参数自行测试，那么后端是否也需要有这么一个功能呢？由于我们公司需要对接比较多的外部系统，并且上线时机不同，但是返回数据可以提前定制，那么就很需要这么一个 <code>Backend Mock System</code>，用来管理进站与出站的 mock 功能。所以我通过 kiro 设计了一款 mock 功能组件，目前只有 demo 阶段：基于Spring Boot 3和DDD架构的后端Mock功能系统，用于在开发和测试环境中模拟HTTP接口响应。仓库位于：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fliyongde%2Fjava-trial%2Ftree%2Fmaster%2FTrial3-Mock-Design" target="_blank" title="https://gitee.com/liyongde/java-trial/tree/master/Trial3-Mock-Design" ref="nofollow noopener noreferrer">gitee.com/liyongde/ja…</a></p>
<h3 data-id="heading-2">1 Mock 设计</h3>
<h4 data-id="heading-3">1.1 核心功能</h4>
<ul>
<li><strong>出站请求Mock（Outbound Mock）</strong>：封装HTTP客户端，拦截本系统调用外部系统的请求</li>
<li><strong>入站请求Mock（Inbound Mock）</strong>：通过拦截器机制，拦截外部系统调用本系统的请求</li>
<li><strong>数据库配置管理</strong>：通过数据库动态配置Mock规则，支持CRUD操作</li>
<li><strong>智能缓存机制</strong>：内存缓存减少数据库访问，提升性能</li>
<li><strong>灵活的启用/禁用</strong>：支持全局开关和单个配置的启用/禁用</li>
</ul>
<h4 data-id="heading-4">1.2 技术特点</h4>
<ul>
<li><strong>DDD架构</strong>：清晰的领域驱动设计，分层明确</li>
<li><strong>Spring Boot 3</strong>：基于最新的Spring Boot框架</li>
<li><strong>Java 17</strong>：使用现代Java特性</li>
<li><strong>MyBatis-Plus</strong>：强大的持久层框架，提供灵活的SQL控制和优秀的性能</li>
<li><strong>Hutool工具库</strong>：简化HTTP请求处理</li>
<li><strong>TestContainers</strong>：容器化测试环境，确保测试环境与生产环境一致</li>
</ul>
<h4 data-id="heading-5">1.3 SQL 设计</h4>
<p>mock_config 这张表主要用来存放定义的 mock 数据。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mock_config` (
  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">'主键ID'</span>,
  `api_path` <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'接口路径，如：/api/user/info'</span>,
  `api_method` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'请求方法：GET, POST, PUT, DELETE'</span>,
  `response_json` longtext COMMENT <span class="hljs-string">'返回的JSON数据'</span>,
  `is_enabled` tinyint(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span> COMMENT <span class="hljs-string">'是否启用：true-启用，false-禁用'</span>,
  `create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">'创建时间'</span>,
  `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">'更新时间'</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),
  <span class="hljs-keyword">UNIQUE</span> KEY `uk_api_method_path` (`api_path`,`api_method`) COMMENT <span class="hljs-string">'路径和方法的唯一约束'</span>,
  KEY `idx_is_enabled` (`is_enabled`) COMMENT <span class="hljs-string">'启用状态索引'</span>,
  KEY `idx_create_time` (`create_time`) COMMENT <span class="hljs-string">'创建时间索引'</span>
) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci COMMENT<span class="hljs-operator">=</span><span class="hljs-string">'Mock配置表'</span>;
</code></pre>
<h4 data-id="heading-6">1.4 开发设计</h4>
<p>基础 CRUD 不讲解，只介绍主要部分。</p>
<p>本次的设计分为了两种：</p>
<ul>
<li>1 出战（通过定制 http 请求完成）</li>
<li>2 入站（通过拦截请求进行获取数据返回）</li>
</ul>
<p>案例代码采用 DDD 分层架构</p>
<pre><code class="hljs language-plain" lang="plain">Trial3-Mock-Design/
├── domain/              # 领域层
│   ├── model/          # 领域模型（实体）
│   └── repository/     # 仓储接口
├── application/         # 应用层
│   ├── service/        # 应用服务
│   └── dto/            # 数据传输对象
├── infrastructure/      # 基础设施层
│   ├── persistence/    # 持久化实现
│   └── config/         # 配置类
└── interfaces/          # 接口层
    ├── controller/     # REST控制器
    ├── interceptor/    # 拦截器
    ├── client/         # HTTP客户端封装
    └── exception/      # 异常处理
</code></pre>
<h3 data-id="heading-7">2 Mock 开发</h3>
<h4 data-id="heading-8">2.1 基础功能</h4>
<p>MockConfigProperties.java 配置属性类</p>
<p>用来设置全局是否开启 mock 功能，以及缓存时间和日志开关。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Mock配置属性类
 * 使用<span class="hljs-doctag">@ConfigurationProperties</span>从application.yml中绑定mock配置
 * 
 * 配置示例：
 * mock:
 *   enabled: true
 *   cache-expiration-seconds: 300
 *   log-mock-usage: true
 */</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = "mock")</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConfigProperties</span> {

    <span class="hljs-comment">/**
     * 全局Mock功能开关
     * 当设置为false时，系统将绕过所有Mock逻辑，直接执行实际请求
     * 默认值：true
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;

    <span class="hljs-comment">/**
     * 缓存过期时间（秒）
     * Mock配置在缓存中的存活时间，超过此时间后将从数据库重新加载
     * 默认值：300秒（5分钟）
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">cacheExpirationSeconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;

    <span class="hljs-comment">/**
     * 是否记录Mock使用日志
     * 当设置为true时，系统将记录每次使用Mock数据的详细信息
     * 默认值：true
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">logMockUsage</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>MockCacheService.java 缓存服务</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Mock配置缓存服务
 * 使用ConcurrentHashMap实现线程安全的内存缓存，提升Mock配置查询性能
 * 支持缓存过期机制，确保数据的时效性
 */</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockCacheService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, CacheEntry&lt;MockConfig&gt;&gt; cache;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> cacheExpirationMs;
    
    <span class="hljs-comment">/**
     * 构造函数，初始化缓存和过期时间
     * 
     * <span class="hljs-doctag">@param</span> properties Mock配置属性，包含缓存过期时间配置
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockCacheService</span><span class="hljs-params">(MockConfigProperties properties)</span> {
        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.cacheExpirationMs = properties.getCacheExpirationSeconds() * <span class="hljs-number">1000</span>;
        log.info(<span class="hljs-string">"MockCacheService initialized with expiration time: {} ms"</span>, cacheExpirationMs);
    }
    
    <span class="hljs-comment">/**
     * 从缓存中获取Mock配置
     * 如果缓存条目已过期，将自动移除并返回空
     * 
     * <span class="hljs-doctag">@param</span> cacheKey 缓存键，格式为 "apiPath:apiMethod"
     * <span class="hljs-doctag">@return</span> Optional包装的MockConfig，如果不存在或已过期则返回空
     */</span>
    <span class="hljs-keyword">public</span> Optional&lt;MockConfig&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(String cacheKey)</span> {
        CacheEntry&lt;MockConfig&gt; entry = cache.get(cacheKey);
        
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) {
            log.debug(<span class="hljs-string">"Cache miss for key: {}"</span>, cacheKey);
            <span class="hljs-keyword">return</span> Optional.empty();
        }
        
        <span class="hljs-keyword">if</span> (entry.isExpired(cacheExpirationMs)) {
            log.debug(<span class="hljs-string">"Cache entry expired for key: {}, removing from cache"</span>, cacheKey);
            cache.remove(cacheKey);
            <span class="hljs-keyword">return</span> Optional.empty();
        }
        
        log.debug(<span class="hljs-string">"Cache hit for key: {}"</span>, cacheKey);
        <span class="hljs-keyword">return</span> Optional.of(entry.getValue());
    }
    
    <span class="hljs-comment">/**
     * 将Mock配置放入缓存
     * 
     * <span class="hljs-doctag">@param</span> cacheKey 缓存键，格式为 "apiPath:apiMethod"
     * <span class="hljs-doctag">@param</span> config 要缓存的MockConfig对象
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String cacheKey, MockConfig config)</span> {
        CacheEntry&lt;MockConfig&gt; entry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheEntry</span>&lt;&gt;(config);
        cache.put(cacheKey, entry);
        log.debug(<span class="hljs-string">"Cache updated for key: {}"</span>, cacheKey);
    }
    
    <span class="hljs-comment">/**
     * 使指定缓存条目失效（移除）
     * 通常在Mock配置被更新或删除时调用
     * 
     * <span class="hljs-doctag">@param</span> cacheKey 要失效的缓存键
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invalidate</span><span class="hljs-params">(String cacheKey)</span> {
        cache.remove(cacheKey);
        log.debug(<span class="hljs-string">"Cache invalidated for key: {}"</span>, cacheKey);
    }
    
    <span class="hljs-comment">/**
     * 清空所有缓存条目
     * 通常在需要强制刷新所有缓存时调用
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> cache.size();
        cache.clear();
        log.info(<span class="hljs-string">"Cache cleared, removed {} entries"</span>, size);
    }
    
    <span class="hljs-comment">/**
     * 缓存条目内部类
     * 封装缓存值和时间戳，用于实现过期检查
     * 
     * <span class="hljs-doctag">@param</span> &lt;T&gt; 缓存值的类型
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheEntry</span>&lt;T&gt; {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timestamp;
        
        <span class="hljs-comment">/**
         * 构造函数，创建缓存条目并记录当前时间戳
         * 
         * <span class="hljs-doctag">@param</span> value 要缓存的值
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheEntry</span><span class="hljs-params">(T value)</span> {
            <span class="hljs-built_in">this</span>.value = value;
            <span class="hljs-built_in">this</span>.timestamp = System.currentTimeMillis();
        }
        
        <span class="hljs-comment">/**
         * 获取缓存的值
         * 
         * <span class="hljs-doctag">@return</span> 缓存的值
         */</span>
        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> value;
        }
        
        <span class="hljs-comment">/**
         * 检查缓存条目是否已过期
         * 
         * <span class="hljs-doctag">@param</span> expirationMs 过期时间（毫秒）
         * <span class="hljs-doctag">@return</span> true如果已过期，否则返回false
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpired</span><span class="hljs-params">(<span class="hljs-type">long</span> expirationMs)</span> {
            <span class="hljs-keyword">return</span> System.currentTimeMillis() - timestamp &gt; expirationMs;
        }
    }
}
</code></pre>
<h4 data-id="heading-9">2.2 封装 http 请求（出站）</h4>
<p>通过封装 http 请求客户端，当每次需要调用外部系统的时候，通过此封装工具，将对应的 api 和参数传递过去，如果是需要 mock 返回，则不会调用 http，反之放行调用。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * HTTP客户端封装器
 * 封装Hutool的HTTP请求方法，提供出站Mock功能
 * 
 * 工作流程：
 * 1. 检查全局Mock开关
 * 2. 从URL提取路径
 * 3. 查询Mock配置
 * 4. 如果Mock启用，返回Mock数据；否则发起实际HTTP请求
 * 
 * 支持的HTTP方法：GET, POST, PUT, DELETE
 */</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientWrapper</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MockService mockService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MockConfigProperties properties;
    
    <span class="hljs-comment">/**
     * 构造函数，注入依赖
     * 
     * <span class="hljs-doctag">@param</span> mockService Mock服务
     * <span class="hljs-doctag">@param</span> properties Mock配置属性
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpClientWrapper</span><span class="hljs-params">(MockService mockService, MockConfigProperties properties)</span> {
        <span class="hljs-built_in">this</span>.mockService = mockService;
        <span class="hljs-built_in">this</span>.properties = properties;
    }
    
    <span class="hljs-comment">/**
     * 发起GET请求
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@return</span> 响应内容
     */</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String url)</span> {
        <span class="hljs-keyword">return</span> executeRequest(url, <span class="hljs-string">"GET"</span>, <span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-comment">/**
     * 发起POST请求
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@param</span> body 请求体
     * <span class="hljs-doctag">@return</span> 响应内容
     */</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">post</span><span class="hljs-params">(String url, String body)</span> {
        <span class="hljs-keyword">return</span> executeRequest(url, <span class="hljs-string">"POST"</span>, body);
    }
    
    <span class="hljs-comment">/**
     * 发起PUT请求
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@param</span> body 请求体
     * <span class="hljs-doctag">@return</span> 响应内容
     */</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">put</span><span class="hljs-params">(String url, String body)</span> {
        <span class="hljs-keyword">return</span> executeRequest(url, <span class="hljs-string">"PUT"</span>, body);
    }
    
    <span class="hljs-comment">/**
     * 发起DELETE请求
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@return</span> 响应内容
     */</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(String url)</span> {
        <span class="hljs-keyword">return</span> executeRequest(url, <span class="hljs-string">"DELETE"</span>, <span class="hljs-literal">null</span>);
    }
    
    <span class="hljs-comment">/**
     * 执行HTTP请求的核心逻辑
     * 
     * 流程：
     * 1. 检查全局Mock开关，如果禁用则直接发起实际请求
     * 2. 从URL提取路径
     * 3. 查询Mock配置
     * 4. 如果Mock配置存在且启用，返回Mock数据
     * 5. 否则发起实际HTTP请求
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@param</span> method HTTP方法
     * <span class="hljs-doctag">@param</span> body 请求体（可为null）
     * <span class="hljs-doctag">@return</span> 响应内容
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">executeRequest</span><span class="hljs-params">(String url, String method, String body)</span> {
        <span class="hljs-comment">// 检查全局Mock开关</span>
        <span class="hljs-keyword">if</span> (!properties.isEnabled()) {
            log.debug(<span class="hljs-string">"Mock is globally disabled, making real request to {} {}"</span>, method, url);
            <span class="hljs-keyword">return</span> makeRealRequest(url, method, body);
        }
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从URL提取路径</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> extractPath(url);
            
            <span class="hljs-comment">// 查询Mock配置</span>
            Optional&lt;MockConfig&gt; mockConfig = mockService.getMockConfig(path, method);
            
            <span class="hljs-comment">// 如果Mock配置存在且启用，返回Mock数据</span>
            <span class="hljs-keyword">if</span> (mockConfig.isPresent() &amp;&amp; mockConfig.get().isActive()) {
                <span class="hljs-keyword">if</span> (properties.isLogMockUsage()) {
                    log.info(<span class="hljs-string">"Mock response used for outbound {} {}"</span>, method, url);
                }
                <span class="hljs-keyword">return</span> mockConfig.get().getResponseJson();
            }
            
            <span class="hljs-comment">// Mock未启用或不存在，发起实际请求</span>
            log.debug(<span class="hljs-string">"No active mock config found for {} {}, making real request"</span>, method, path);
            <span class="hljs-keyword">return</span> makeRealRequest(url, method, body);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"Error during mock check for {} {}, falling back to real request: {}"</span>, 
                     method, url, e.getMessage());
            <span class="hljs-keyword">return</span> makeRealRequest(url, method, body);
        }
    }
    
    <span class="hljs-comment">/**
     * 发起实际的HTTP请求
     * 使用Hutool的HttpRequest工具类
     * 
     * <span class="hljs-doctag">@param</span> url 目标URL
     * <span class="hljs-doctag">@param</span> method HTTP方法
     * <span class="hljs-doctag">@param</span> body 请求体（可为null）
     * <span class="hljs-doctag">@return</span> 响应内容
     * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果HTTP方法不支持
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">makeRealRequest</span><span class="hljs-params">(String url, String method, String body)</span> {
        log.debug(<span class="hljs-string">"Making real HTTP request: {} {}"</span>, method, url);
        
        <span class="hljs-keyword">try</span> {
            String response;
            <span class="hljs-keyword">switch</span> (method.toUpperCase()) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"GET"</span>:
                    response = HttpRequest.get(url).execute().body();
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"POST"</span>:
                    response = HttpRequest.post(url).body(body).execute().body();
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"PUT"</span>:
                    response = HttpRequest.put(url).body(body).execute().body();
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"DELETE"</span>:
                    response = HttpRequest.delete(url).execute().body();
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    log.error(<span class="hljs-string">"Unsupported HTTP method: {}"</span>, method);
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Unsupported HTTP method: "</span> + method);
            }
            
            log.debug(<span class="hljs-string">"Real HTTP request completed: {} {}, response length: {}"</span>, 
                     method, url, response != <span class="hljs-literal">null</span> ? response.length() : <span class="hljs-number">0</span>);
            <span class="hljs-keyword">return</span> response;
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"Error making real HTTP request to {} {}: {}"</span>, method, url, e.getMessage(), e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Failed to make HTTP request: "</span> + e.getMessage(), e);
        }
    }
    
    <span class="hljs-comment">/**
     * 从完整URL中提取路径部分
     * 
     * 例如：
     * - "http://example.com/api/user/info" -&gt; "/api/user/info"
     * - "https://example.com:8080/api/data?id=1" -&gt; "/api/data"
     * 
     * <span class="hljs-doctag">@param</span> url 完整URL
     * <span class="hljs-doctag">@return</span> URL的路径部分
     * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果URL格式无效
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">extractPath</span><span class="hljs-params">(String url)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(url);
            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> uri.getPath();
            
            <span class="hljs-keyword">if</span> (path == <span class="hljs-literal">null</span> || path.isEmpty()) {
                log.warn(<span class="hljs-string">"URL has no path component: {}, using root path '/'"</span>, url);
                <span class="hljs-keyword">return</span> <span class="hljs-string">"/"</span>;
            }
            
            log.debug(<span class="hljs-string">"Extracted path '{}' from URL '{}'"</span>, path, url);
            <span class="hljs-keyword">return</span> path;
            
        } <span class="hljs-keyword">catch</span> (URISyntaxException e) {
            log.error(<span class="hljs-string">"Invalid URL format: {}"</span>, url, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Invalid URL: "</span> + url, e);
        }
    }
}
</code></pre>
<p>调用 mock 服务，主要是以下代码</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 从URL提取路径</span>
<span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> extractPath(url);

<span class="hljs-comment">// 查询Mock配置</span>
Optional&lt;MockConfig&gt; mockConfig = mockService.getMockConfig(path, method);
</code></pre>
<p>通过 mock 配置的判断获取对应数据，先查缓存，在查数据库，一定程度上优化。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 获取Mock配置（集成缓存查询）
 * 优先从缓存获取，缓存未命中时从数据库查询并更新缓存
 * 
 * <span class="hljs-doctag">@param</span> apiPath API路径
 * <span class="hljs-doctag">@param</span> apiMethod HTTP方法
 * <span class="hljs-doctag">@return</span> Optional包装的MockConfig
 */</span>
<span class="hljs-keyword">public</span> Optional&lt;MockConfig&gt; <span class="hljs-title function_">getMockConfig</span><span class="hljs-params">(String apiPath, String apiMethod)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> apiPath + <span class="hljs-string">":"</span> + apiMethod;
    
    <span class="hljs-comment">// 先查缓存</span>
    Optional&lt;MockConfig&gt; cached = cacheService.get(cacheKey);
    <span class="hljs-keyword">if</span> (cached.isPresent()) {
        log.debug(<span class="hljs-string">"Mock config found in cache for {} {}"</span>, apiMethod, apiPath);
        <span class="hljs-keyword">return</span> cached;
    }
    
    <span class="hljs-comment">// 缓存未命中，查数据库</span>
    Optional&lt;MockConfig&gt; config = mockConfigRepository.findByApiPathAndApiMethod(apiPath, apiMethod);
    
    <span class="hljs-comment">// 如果找到，更新缓存</span>
    config.ifPresent(c -&gt; {
        cacheService.put(cacheKey, c);
        log.debug(<span class="hljs-string">"Mock config loaded from database and cached for {} {}"</span>, apiMethod, apiPath);
    });
    
    <span class="hljs-keyword">if</span> (config.isEmpty()) {
        log.debug(<span class="hljs-string">"Mock config not found for {} {}"</span>, apiMethod, apiPath);
    }
    
    <span class="hljs-keyword">return</span> config;
}
</code></pre>
<h4 data-id="heading-10">2.3 Mock 拦截器（出站）</h4>
<p>定义一个拦截器，没被过滤的 api 请求将会到这里进行拦截 mock 处理</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Mock拦截器
 * 用于拦截入站HTTP请求，根据Mock配置返回Mock数据
 * 实现HandlerInterceptor接口，在Controller方法执行前进行拦截
 * 
 * 工作流程：
 * 1. 检查全局Mock开关是否启用
 * 2. 提取请求路径和HTTP方法
 * 3. 查询Mock配置（优先从缓存获取）
 * 4. 如果Mock配置存在且启用，直接返回Mock数据
 * 5. 否则，继续执行Controller方法
 */</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MockService mockService;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MockConfigProperties properties;
    
    <span class="hljs-comment">/**
     * 构造函数，注入依赖
     * 
     * <span class="hljs-doctag">@param</span> mockService Mock服务
     * <span class="hljs-doctag">@param</span> properties Mock配置属性
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockInterceptor</span><span class="hljs-params">(MockService mockService, MockConfigProperties properties)</span> {
        <span class="hljs-built_in">this</span>.mockService = mockService;
        <span class="hljs-built_in">this</span>.properties = properties;
    }
    
    <span class="hljs-comment">/**
     * 在Controller方法执行前拦截请求
     * 
     * <span class="hljs-doctag">@param</span> request HTTP请求
     * <span class="hljs-doctag">@param</span> response HTTP响应
     * <span class="hljs-doctag">@param</span> handler 处理器
     * <span class="hljs-doctag">@return</span> true表示继续执行Controller，false表示拦截并返回Mock数据
     * <span class="hljs-doctag">@throws</span> Exception 处理过程中的异常
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 检查全局Mock开关</span>
        <span class="hljs-keyword">if</span> (!properties.isEnabled()) {
            log.debug(<span class="hljs-string">"Mock functionality is globally disabled, continuing to controller"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Mock功能禁用，继续执行Controller</span>
        }
        
        <span class="hljs-comment">// 提取请求路径和方法</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getRequestURI();
        <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();
        
        log.debug(<span class="hljs-string">"Intercepting request: {} {}"</span>, method, path);
        
        <span class="hljs-comment">// 查询Mock配置</span>
        Optional&lt;MockConfig&gt; mockConfig = mockService.getMockConfig(path, method);
        
        <span class="hljs-comment">// 检查Mock配置是否存在且启用</span>
        <span class="hljs-keyword">if</span> (mockConfig.isPresent() &amp;&amp; mockConfig.get().isActive()) {
            <span class="hljs-type">MockConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> mockConfig.get();
            
            <span class="hljs-comment">// 设置响应头</span>
            response.setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);
            response.setStatus(HttpStatus.OK.value());
            
            <span class="hljs-comment">// 写入Mock响应数据</span>
            response.getWriter().write(config.getResponseJson());
            response.getWriter().flush();
            
            <span class="hljs-comment">// 记录Mock使用日志</span>
            <span class="hljs-keyword">if</span> (properties.isLogMockUsage()) {
                log.info(<span class="hljs-string">"Mock response returned for {} {} (config id: {})"</span>, 
                        method, path, config.getId());
            }
            
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 拦截请求，不继续执行Controller</span>
        }
        
        <span class="hljs-comment">// Mock配置不存在或未启用，继续执行Controller</span>
        log.debug(<span class="hljs-string">"No active mock config found for {} {}, continuing to controller"</span>, method, path);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>主要也是调用了 <code>Optional&lt;MockConfig&gt; mockConfig = mockService.getMockConfig(path, method);</code>mock 服务。</p>
<p>通过 mvc 拦截，记得将 mock 的 crud 排除，也可以制作白名单数组，将不需要的 api 直接过滤掉。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Web MVC配置类
 * 用于注册拦截器和配置拦截路径
 * 
 * 拦截器配置：
 * - 拦截所有路径（/**）
 * - 排除Mock配置管理接口（/api/mock-config/**），避免管理接口被Mock拦截
 */</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MockInterceptor mockInterceptor;
    
    <span class="hljs-comment">/**
     * 构造函数，注入MockInterceptor
     * 
     * <span class="hljs-doctag">@param</span> mockInterceptor Mock拦截器
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WebMvcConfig</span><span class="hljs-params">(MockInterceptor mockInterceptor)</span> {
        <span class="hljs-built_in">this</span>.mockInterceptor = mockInterceptor;
    }
    
    <span class="hljs-comment">/**
     * 注册拦截器
     * 配置拦截路径和排除路径
     * 
     * <span class="hljs-doctag">@param</span> registry 拦截器注册器
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> {
        log.info(<span class="hljs-string">"Registering MockInterceptor"</span>);
        
        registry.addInterceptor(mockInterceptor)
                .addPathPatterns(<span class="hljs-string">"/**"</span>)  <span class="hljs-comment">// 拦截所有路径</span>
                .excludePathPatterns(<span class="hljs-string">"/api/mock-config/**"</span>);  <span class="hljs-comment">// 排除Mock配置管理接口</span>
        
        log.info(<span class="hljs-string">"MockInterceptor registered successfully"</span>);
    }
}
</code></pre>
<h3 data-id="heading-11">3 Mock 功能测试</h3>
<p>代码仓库里面设有入站与出站的测试类，可以自行调试。</p>
<p>出站测试</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testOutboundMock_WhenMockConfigExistsAndEnabled_ReturnsMockData</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// Given: 创建并保存Mock配置</span>
    <span class="hljs-type">MockConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConfig</span>();
    config.setApiPath(<span class="hljs-string">"/api/user/info"</span>);
    config.setApiMethod(<span class="hljs-string">"GET"</span>);
    config.setResponseJson(<span class="hljs-string">"{\"id\":1,\"name\":\"Test User\"}"</span>);
    config.setIsEnabled(<span class="hljs-literal">true</span>);
    config.setCreateTime(LocalDateTime.now());
    config.setUpdateTime(LocalDateTime.now());
    repository.save(config);
    
    <span class="hljs-comment">// When: 通过HttpClientWrapper发起GET请求</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClientWrapper.get(<span class="hljs-string">"http://example.com/api/user/info"</span>);
    System.out.println(response);
    <span class="hljs-comment">// Then: 应该返回Mock数据</span>
    assertThat(response).isEqualTo(<span class="hljs-string">"{\"id\":1,\"name\":\"Test User\"}"</span>);
}
</code></pre>
<p>入站测试</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testInboundMock_WhenMockConfigExistsAndEnabled_ReturnsInterceptedMockData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// Given: 创建并保存Mock配置</span>
    <span class="hljs-type">MockConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConfig</span>();
    config.setApiPath(<span class="hljs-string">"/api/test/endpoint"</span>);
    config.setApiMethod(<span class="hljs-string">"GET"</span>);
    config.setResponseJson(<span class="hljs-string">"{\"intercepted\":true,\"message\":\"Mock response\"}"</span>);
    config.setIsEnabled(<span class="hljs-literal">true</span>);
    config.setCreateTime(LocalDateTime.now());
    config.setUpdateTime(LocalDateTime.now());
    repository.save(config);
    
    <span class="hljs-comment">// When &amp; Then: 发起GET请求，应该被拦截器拦截并返回Mock数据</span>
    mockMvc.perform(get(<span class="hljs-string">"/api/test/endpoint"</span>))
            .andExpect(status().isOk())
            .andExpect(content().contentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>))
            .andExpect(content().json(<span class="hljs-string">"{\"intercepted\":true,\"message\":\"Mock response\"}"</span>));
}
</code></pre>
<h3 data-id="heading-12">4 总结</h3>
<p>本文是介绍作者基于Spring Boot 3和DDD架构的后端Mock功能系统，用于在开发和测试环境中模拟HTTP接口响应的一次尝试，这只是一个案例，可以根据里面的代码集成到各自的项目中，后面我在写一篇集成到后台管理系统中的案例过程。也可以先看我的仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fliyongde%2Fjava-trial%2Ftree%2Fmaster%2FTrial3-Mock-Design" target="_blank" title="https://gitee.com/liyongde/java-trial/tree/master/Trial3-Mock-Design" ref="nofollow noopener noreferrer">gitee.com/liyongde/ja…</a></p>
<hr/>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德 @一个有梦有戏的人</strong><br/>
持续创作很不容易，作者将以尽可能的详细把所学知识分享各位开发者，一起进步一起学习。<strong>转载请携带链接，转载到微信公众号请勿选择原创，谢谢！</strong><br/>
👍创作不易，如有错误请指正，感谢观看！记得点赞哦！👍<br/>
谢谢支持！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 2.6 调教实录：从崩溃 4671 次到省 50% token]]></title>    <link>https://juejin.cn/post/7604142616474320902</link>    <guid>https://juejin.cn/post/7604142616474320902</guid>    <pubDate>2026-02-09T06:55:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604142616474320902" data-draft-id="7604084016511057961" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 2.6 调教实录：从崩溃 4671 次到省 50% token"/> <meta itemprop="keywords" content="OpenAI,AI编程,AIGC"/> <meta itemprop="datePublished" content="2026-02-09T06:55:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="孟健AI编程"/> <meta itemprop="url" content="https://juejin.cn/user/4212984287073895"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 2.6 调教实录：从崩溃 4671 次到省 50% token
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4212984287073895/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    孟健AI编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:55:29.000Z" title="Mon Feb 09 2026 06:55:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是孟健。</p>
<p>我的AI助手偷偷崩了4671次，我一点没察觉。</p>
<p>直到有一天，我发现定时任务连续3天没跑——每天早上的选题推送、晚上的X运营候选、认证监控……全部静悄悄消失了。我以为是bug，顺手一查，挖出了一个让我后背发凉的坑。</p>
<p>这篇文章记录我怎么排查这个事故，以及趁机把 OpenClaw 2.6 做了一次全面体检——<strong>最终 token 费用降了 30-50%，记忆不再丢失</strong>。</p>
<p>所有配置都可以直接抄。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef5f9d89b98d401aa1d699c6dd605fef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771224928&amp;x-signature=QrRoKQ7Gk%2BlU8jDPw4Tv%2B79PHKE%3D" alt="" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-0"><strong>01 事故现场：4671次无效 重启</strong></h2>
<p>我用的是 OpenClaw 2.6，一个可以7×24小时运行的AI助手框架。它帮我管选题、Twitter运营、日程提醒，基本是我的"数字员工"。</p>
<p>那天我跑了一句命令看服务状态：</p>
<pre><code class="hljs language-bash" lang="bash">journalctl --user -u openclaw-gateway --since <span class="hljs-string">"3 days ago"</span> | grep <span class="hljs-string">"start"</span> | <span class="hljs-built_in">wc</span> -l
</code></pre>
<p><strong>4671。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f832822c872f43cda0e728656bc6d388~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771224928&amp;x-signature=29wu9lRAeAx1C4j3BXef%2BBsxQZg%3D" alt="" loading="lazy"/></p>
<p>三天，4671次重启。平均每5秒崩一次，再起来，再崩，无限循环。</p>
<p>更可怕的是——<strong>我完全不知道。</strong> 因为用户级的服务一直正常跑着，该回复消息照样回复。只是 cron 调度器被搞乱了，定时任务全部漏跑了3-4天。</p>
<h3 data-id="heading-1"><strong>根因：两个同名服务打架</strong></h3>
<p>排查下来，原因出奇地蠢：</p>
<ul>
<li>
<p><strong>用户级服务</strong>（<code>~/.config/systemd/user/openclaw-gateway.service</code>）：正常运行，占着18789端口</p>
</li>
<li>
<p><strong>系统级服务</strong>（<code>/etc/systemd/system/openclaw-gateway.service</code>）：每5秒尝试启动，发现端口被占，立即退出，systemd 又拉起来……</p>
</li>
</ul>
<p>两个同名服务，一个占着端口好好的，一个疯狂撞墙。<strong>36小时的CPU白白浪费</strong>，cron 调度器的状态被反复刷乱，<code>nextRunAtMs</code> 跳到了未来某个不存在的时间。</p>
<p>怎么来的？大概率是某次运行 <code>openclaw gateway install</code> 时，系统级和用户级各生成了一个服务文件。</p>
<p><strong>教训：升级或重装 OpenClaw 后，跑一句 `systemctl list-units | grep openclaw` 确认没有重复服务。</strong></p>
<hr/>
<h2 data-id="heading-2"><strong>02 三步修复</strong></h2>
<p>修复过程反而简单，3条命令搞定：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 停掉并禁用多余的系统级服务</span>
sudo systemctl stop openclaw-gateway.service
sudo systemctl <span class="hljs-built_in">disable</span> openclaw-gateway.service

<span class="hljs-comment"># 2. 删除系统级服务文件（建议先备份）</span>
sudo <span class="hljs-built_in">rm</span> /etc/systemd/system/openclaw-gateway.service

<span class="hljs-comment"># 3. 重载 systemd</span>
sudo systemctl daemon-reload
</code></pre>
<p>保留用户级服务正常运行就行。</p>
<hr/>
<h2 data-id="heading-3"><strong>03 全身体检：9项配置优化</strong></h2>
<p>修完事故，我想：都拆开了，干脆对照 OpenClaw 2.6 的最新文档做个全面体检。</p>
<p>最终调了9项，效果是 <strong>token 费用降了 30-50%，记忆不再丢失，体验明显提升</strong>。</p>
<p>以下逐条说，每条都可以直接抄。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a298be7b790444cbb58e369a08e84a1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a2f5YGlQUnnvJbnqIs=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771224928&amp;x-signature=3TIRJjLbptpjGu%2BfLpgffdmNZIc%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4"><strong>① contextPruning：自动裁剪旧内容，省 token</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"contextPruning"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cache-ttl"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ttl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5m"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>Before</strong>：每次对话把所有历史 tool 输出都带上，token 越聊越多。</p>
<p><strong>After</strong>：超过5分钟的 tool 输出自动裁剪，上下文保持精简。</p>
<p>这一项大概能省 <strong>20-30% 的 token</strong>。</p>
<p>注意：这只影响发给 LLM 的上下文，不会删除磁盘上的 session 历史（.jsonl 文件保持完整）。</p>
<h3 data-id="heading-5"><strong>② compaction safeguard：防记忆丢失</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"compaction"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"safeguard"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"memoryFlush"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>OpenClaw 会在对话太长时自动压缩上下文（compaction），但默认模式下压缩时可能把重要记忆挤掉。</p>
<p><code>safeguard</code> 模式会在压缩前触发一次"记忆刷盘"——把关键信息写到 MEMORY.md，<strong>确保什么都不丢</strong>。</p>
<p><strong>没有记忆的AI助手就是个高级复读机。</strong> 这项必开。</p>
<h3 data-id="heading-6"><strong>③ subagents 模型降级：省60%费用</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"subagents"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"model"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"minimax/MiniMax-M2.1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"archiveAfterMinutes"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>Before</strong>：子任务（cron 定时任务、后台处理）默认继承主模型 Claude Opus 4.6，贵。</p>
<p><strong>After</strong>：子任务用 MiniMax-M2.1，费用只有 Opus 的 1/3 左右。</p>
<p>大部分 cron 任务不需要最强模型——发个早报、跑个监控，够用就行。<strong>把好钢用在刀刃上。</strong></p>
<p><code>archiveAfterMinutes</code> 从60降到30，子 session 更快回收，减少内存占用。</p>
<h3 data-id="heading-7"><strong>④ heartbeat 降频 + activeHours</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"heartbeat"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"intervalMinutes"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">120</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"activeHours"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"08:00-24:00"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>Before</strong>：每30分钟心跳一次，7×24小时不间断。每天48次心跳。</p>
<p><strong>After</strong>：每2小时一次，只在早8点到晚12点。每天8次。</p>
<p><strong>一个人睡觉的时候，不需要有人每30分钟戳一下看你醒没醒。</strong></p>
<h3 data-id="heading-8"><strong>⑤ identity：让AI认识自己</strong></h3>
<pre><code class="hljs language-css" lang="css">"identity": {
  "agents": {
    "<span class="hljs-selector-tag">main</span>": {
      "name": <span class="hljs-string">"小墨"</span>,
      <span class="hljs-string">"emoji"</span>: <span class="hljs-string">"🐈⬛"</span>
    }
  }
}
</code></pre>
<p>配了之后，AI 在群聊里能识别 @小墨 ，自动 ack reaction 也带上身份标识。小事，但体验好很多。</p>
<h3 data-id="heading-9"><strong>⑥ inbound debounce：连续消息合并</strong></h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">"inbound":</span> {
  <span class="hljs-attr">"debounceMs":</span> <span class="hljs-number">3000</span>
}
</code></pre>
<p>你在 Telegram 连发3条消息，OpenClaw 不会触发3次处理，而是等3秒合并成一次。<strong>省 token，也省你等3次回复的时间。</strong></p>
<h3 data-id="heading-10"><strong>⑦ session reset：自然过期</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"session"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"resetMode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"idle"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"idleMinutes"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">240</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>4小时没聊天就重置 session。比固定时间重置更自然——深夜聊到2点也不会被打断。</p>
<h3 data-id="heading-11"><strong>⑧ userTimezone：时区修正</strong></h3>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"userTimezone"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Asia/Shanghai"</span>
</code></pre>
<p>别小看这个。时区不对，AI 说的"今天""明天"全是乱的，cron 任务的触发时间也会偏移。<strong>基础设施级的配置，第一天就该设好。</strong></p>
<h3 data-id="heading-12"><strong>⑨ cron 链接修复</strong></h3>
<p>升级2.6后一些旧配置没跟着更新：</p>
<ul>
<li>
<p>文档索引的 URL 还指向旧域名 <code>docs.clawd.bot</code>，改成了 <code>docs.openclaw.ai</code></p>
</li>
<li>
<p>认证监控的命令还是旧的 <code>clawdbot</code>，改成了 <code>openclaw</code></p>
</li>
</ul>
<p><strong>升级框架版本后，一定要检查 cron 任务里的硬编码路径和命令。</strong> 这种隐形bug不会报错，只是默默失效。</p>
<hr/>
<h2 data-id="heading-13"><strong>04 进阶：用 QMD 替代默认记忆搜索</strong></h2>
<p>做完基础体检，我又研究了一个社区里很多人在用的省 token 方案：<strong>QMD</strong>。</p>
<p>QMD 是一个本地优先的搜索工具，用 BM25 + 向量 + 重排序 三重机制来检索 Markdown 文件。OpenClaw 2.6 原生支持它作为记忆后端。</p>
<h3 data-id="heading-14"><strong>为什么要换？</strong></h3>
<p>默认的记忆搜索用远程 embedding API（OpenAI / Gemini / Voyage），每次搜索都要调一次 API。QMD 跑在本地，<strong>零 API 费用，零延迟，数据不出机器</strong>。</p>
<p>社区有人反馈用 QMD 后 token 节省了 <strong>60-97%</strong>（因为它只拉最相关的2-3句话进上下文，而不是把整段记忆塞进去）。</p>
<h3 data-id="heading-15"><strong>怎么配？</strong></h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 安装 QMD</span>
bun install -g https://github.com/tobi/qmd

<span class="hljs-comment"># 2. 确认 qmd 命令可用</span>
qmd --version
</code></pre>
<p>然后在 OpenClaw 配置里加一行：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"memory"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"backend"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"qmd"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>重启 Gateway 生效。Markdown 文件仍然是唯一的"真相来源"，QMD 只负责检索。</p>
<h3 data-id="heading-16"><strong>注意事项</strong></h3>
<ul>
<li>
<p>QMD 目前还是实验性功能（experimental），建议先在子 agent 上测试</p>
</li>
<li>
<p>需要单独安装 QMD CLI</p>
</li>
<li>
<p>如果你的记忆文件不多（&lt;50个），默认的 SQLite 向量搜索其实也够用</p>
</li>
</ul>
<hr/>
<h2 data-id="heading-17"><strong>05 OpenClaw 2.6 还有什么新东西？</strong></h2>
<p>顺带整理一下 2.6 的关键更新，帮你判断值不值得升级：</p>
<ul>
<li>
<p><strong>模型支持</strong>：原生支持 Anthropic Opus 4.6 和 OpenAI Codex gpt-5.3-codex</p>
</li>
<li>
<p><strong>xAI (Grok) 接入</strong>：可以用 Grok 作为 provider 了</p>
</li>
<li>
<p><strong>Web UI token 仪表盘</strong>：直接看 token 消耗趋势</p>
</li>
<li>
<p><strong>Voyage AI 原生支持</strong>：记忆向量搜索多了一个 embedding 选择</p>
</li>
<li>
<p><strong>Cron 调度修复</strong>：修了好几个定时任务漏跑和提醒不送达的 bug（这个我深有体会）</p>
</li>
<li>
<p><strong>安全增强</strong>：skill/plugin 代码安全扫描，config.get 响应自动脱敏</p>
</li>
<li>
<p><strong>Compaction 重试</strong>：上下文溢出时允许多次压缩重试，不会直接崩</p>
</li>
</ul>
<p><strong>如果你还在用 2.5 或更早版本，强烈建议升级。</strong> 尤其是 cron 调度的修复，2.5 的 cron 在某些场景下会默默停跑。</p>
<hr/>
<h2 data-id="heading-18"><strong>最终效果</strong></h2>








































<table><thead><tr><th>指标</th><th>Before</th><th>After</th></tr></thead><tbody><tr><td>Token 费用</td><td>基准</td><td>降低 30-50%</td></tr><tr><td>记忆丢失风险</td><td>有</td><td>基本消除</td></tr><tr><td>子任务费用</td><td>Opus 全量</td><td>降低 60%+</td></tr><tr><td>无效心跳</td><td>48次/天</td><td>8次/天</td></tr><tr><td>Cron 任务</td><td>漏跑3-4天</td><td>全部恢复</td></tr><tr><td>记忆搜索</td><td>远程 API</td><td>本地 QMD（可选）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-19"><strong>写在最后</strong></h2>
<p>AI助手不是装完就能跑一辈子的。</p>
<p>它就像一辆车——你得定期保养，检查机油、轮胎、刹车。不然哪天高速上抛锚，你才发现发动机早就拉缸了。</p>
<p>我的这次"体检"发现了一个跑了4671次的隐形故障，顺带优化出 30-50% 的成本节省。<strong>总共花了不到2小时。</strong></p>
<p>如果你也在用 OpenClaw，建议你现在就跑一句：</p>
<pre><code class="hljs language-perl" lang="perl">systemctl list-units | <span class="hljs-keyword">grep</span> openclaw
</code></pre>
<p>看看有没有"幽灵服务"在偷偷消耗你的资源。</p>
<p><strong>工具会变强，但不会自己变好。调教它的人，才是真正的竞争力。</strong></p>
<hr/>
<p>如果这篇对你有帮助，欢迎点赞、收藏、关注，你的支持是我持续输出的动力 ✨</p>
<hr/>
<p>我的其他平台账号和开源项目在个人主页中，欢迎交流 🤝</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[BeautifulSoup：Python网页解析的优雅利器]]></title>    <link>https://juejin.cn/post/7604175912481226758</link>    <guid>https://juejin.cn/post/7604175912481226758</guid>    <pubDate>2026-02-09T06:56:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604175912481226758" data-draft-id="7604155045236293667" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="BeautifulSoup：Python网页解析的优雅利器"/> <meta itemprop="keywords" content="后端,Python,爬虫"/> <meta itemprop="datePublished" content="2026-02-09T06:56:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小小张说故事"/> <meta itemprop="url" content="https://juejin.cn/user/741501567509111"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            BeautifulSoup：Python网页解析的优雅利器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/741501567509111/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小小张说故事
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:56:57.000Z" title="Mon Feb 09 2026 06:56:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 库的概览与核心价值</h2>
<p>想象一下，你面对着成千上万个杂乱的网页，需要从中提取有价值的信息——就像在一堆没有标注的书籍中寻找特定的章节。如果手动去解析那些层层嵌套、格式混乱的HTML代码，就像在没有索引的情况下翻阅整个图书馆。<code>BeautifulSoup</code>正是为解决这个痛点而生的工具。</p>
<p>BeautifulSoup（全称beautifulsoup4）是一个Python库，它能够将复杂的HTML或XML文档转换成一个结构化的树形对象，让开发者可以通过简洁的API快速定位和提取数据。它在Python生态中的独特价值在于：<strong>极强的容错能力和人性化的API设计</strong>。即使网页代码不规范（如标签未闭合、嵌套错误），BeautifulSoup也能优雅地处理，这在真实世界的网页解析中尤为重要。</p>
<p>与正则表达式相比，BeautifulSoup不要求你掌握复杂的模式匹配规则；与lxml、Scrapy等重型爬虫框架相比，它学习曲线平缓，代码可读性强。对于中小型数据提取项目、教学演示或快速原型开发，BeautifulSoup是当之无愧的首选。</p>
<hr/>
<h2 data-id="heading-1">2. 环境搭建与"Hello, World"</h2>
<h3 data-id="heading-2">安装说明</h3>
<p>BeautifulSoup的安装非常简单，但有一个关键点需要注意：<strong>正确的包名是<code>beautifulsoup4</code></strong>，而不是<code>beautifulsoup</code>。同时，建议安装高效的解析器<code>lxml</code>以获得更好的性能。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用pip安装（推荐）</span>
pip install beautifulsoup4
pip install lxml

<span class="hljs-comment"># 如果使用conda</span>
conda install beautifulsoup4 lxml
</code></pre>
<p><strong>安装失败常见原因</strong>：</p>
<ol>
<li>错误使用<code>pip install beautifulsoup</code>（包名错误）</li>
<li>网络问题导致PyPI连接超时</li>
<li>Python环境混乱，pip指向错误的Python版本</li>
</ol>
<p><strong>解决方案</strong>：使用国内镜像源加速，如：</p>
<pre><code class="hljs language-bash" lang="bash">pip install beautifulsoup4 lxml -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h3 data-id="heading-3">Hello, World 示例</h3>
<p>下面是一个最小可运行的示例，演示如何解析HTML并提取标题：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup

<span class="hljs-comment"># 创建模拟HTML文档</span>
html_doc = <span class="hljs-string">"""
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;BeautifulSoup入门示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 class="heading"&gt;欢迎学习BeautifulSoup&lt;/h1&gt;
    &lt;p id="intro"&gt;这是第一个段落。&lt;/p&gt;
    &lt;p&gt;这是第二个段落。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
"""</span>

<span class="hljs-comment"># 创建BeautifulSoup对象，指定lxml解析器</span>
soup = BeautifulSoup(html_doc, <span class="hljs-string">'lxml'</span>)

<span class="hljs-comment"># 提取并打印页面标题</span>
<span class="hljs-built_in">print</span>(soup.title.string)
</code></pre>
<h3 data-id="heading-4">逐行解释</h3>
<ol>
<li><code>from bs4 import BeautifulSoup</code>：从bs4模块导入BeautifulSoup类。<code>bs4</code>是"BeautifulSoup 4"的缩写。</li>
<li><code>html_doc = "..."</code>：定义了一个包含HTML结构的字符串，这是我们要解析的原始数据。</li>
<li><code>soup = BeautifulSoup(html_doc, 'lxml')</code>：
<ul>
<li>第一个参数是要解析的HTML内容</li>
<li>第二个参数<code>'lxml'</code>指定使用lxml解析器（速度快、容错性强）</li>
<li>返回的<code>soup</code>对象是整个解析树的根节点</li>
</ul>
</li>
<li><code>print(soup.title.string)</code>：
<ul>
<li><code>soup.title</code>：直接访问title标签，返回第一个<code>&lt;title&gt;</code>元素</li>
<li><code>.string</code>：获取标签内的文本内容</li>
</ul>
</li>
</ol>
<h3 data-id="heading-5">运行结果</h3>
<pre><code class="hljs">BeautifulSoup入门示例
</code></pre>
<p><strong>解析器选择建议</strong>：</p>
<ul>
<li><strong>lxml</strong>：速度最快，容错能力强，推荐用于生产环境</li>
<li><strong>html.parser</strong>：Python内置，无需额外安装，但速度一般</li>
<li><strong>html5lib</strong>：最接近浏览器解析方式，容错性最强，但速度最慢</li>
</ul>
<hr/>
<h2 data-id="heading-6">3. 核心概念解析</h2>
<p>BeautifulSoup解析HTML后会生成4类核心对象，理解这些概念是熟练使用的基础。</p>
<h3 data-id="heading-7">核心对象类型</h3>
<ol>
<li>
<p><strong>BeautifulSoup对象</strong>：整个解析树的根对象，代表完整的HTML/XML文档，是所有操作的入口点。</p>
</li>
<li>
<p><strong>Tag对象</strong>：对应HTML中的标签（如<code>&lt;div&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;p&gt;</code>），可以获取标签名、属性和文本内容。</p>
</li>
<li>
<p><strong>NavigableString对象</strong>：标签内的纯文本内容（不包含标签本身）。</p>
</li>
<li>
<p><strong>Comment对象</strong>：特殊的NavigableString，对应HTML注释（如<code>&lt;!-- 这是注释 --&gt;</code>）。</p>
</li>
</ol>
<h3 data-id="heading-8">概念关系图</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[BeautifulSoup对象&lt;br/&gt;文档根节点] --&gt; B[Tag对象&lt;br/&gt;HTML标签]
    B --&gt; C[NavigableString&lt;br/&gt;标签内文本]
    B --&gt; D[Comment对象&lt;br/&gt;HTML注释]
    A --&gt; E[find/find_all方法&lt;br/&gt;定位Tag]
    A --&gt; F[select方法&lt;br/&gt;CSS选择器]
    B --&gt; G[获取属性&lt;br/&gt;tag.attrs/标签名]
    B --&gt; H[获取文本&lt;br/&gt;tag.string/get_text]
</code></pre>
<h3 data-id="heading-9">核心概念详解</h3>
<p><strong>Tag对象操作</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 获取标签</span>
title_tag = soup.title  <span class="hljs-comment"># 获取第一个title标签</span>
<span class="hljs-built_in">print</span>(title_tag.name)   <span class="hljs-comment"># 输出标签名：'title'</span>

<span class="hljs-comment"># 获取属性</span>
link_tag = soup.a       <span class="hljs-comment"># 获取第一个a标签</span>
<span class="hljs-built_in">print</span>(link_tag[<span class="hljs-string">'href'</span>]) <span class="hljs-comment"># 获取href属性</span>
<span class="hljs-built_in">print</span>(link_tag.attrs)   <span class="hljs-comment"># 获取所有属性字典</span>

<span class="hljs-comment"># 获取文本</span>
<span class="hljs-built_in">print</span>(title_tag.string)      <span class="hljs-comment"># 获取标签内文本（无嵌套时）</span>
<span class="hljs-built_in">print</span>(soup.h1.get_text())     <span class="hljs-comment"># 获取标签内所有文本（含子标签）</span>
</code></pre>
<p><strong>NavigableString操作</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 获取标签内的纯文本</span>
text = soup.p.string  <span class="hljs-comment"># 获取第一个p标签的文本内容</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(text))     <span class="hljs-comment"># &lt;class 'bs4.element.NavigableString'&gt;</span>
</code></pre>
<p><strong>Comment对象处理</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> Comment

html_with_comment = <span class="hljs-string">"&lt;b&gt;&lt;!-- 这是一个注释 --&gt;&lt;/b&gt;"</span>
soup_comment = BeautifulSoup(html_with_comment, <span class="hljs-string">'lxml'</span>)
comment = soup_comment.b.string

<span class="hljs-comment"># 判断是否为注释</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(comment, Comment):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"这是注释内容:"</span>, comment)
</code></pre>
<h3 data-id="heading-10">查找方法对比</h3>



































<table><thead><tr><th>方法</th><th>作用</th><th>返回值</th><th>适用场景</th></tr></thead><tbody><tr><td><code>soup.tagname</code></td><td>直接访问</td><td>第一个匹配的Tag</td><td>简单快速定位</td></tr><tr><td><code>find(name, attrs)</code></td><td>查找第一个匹配项</td><td>Tag对象或None</td><td>提取唯一元素</td></tr><tr><td><code>find_all(name, attrs)</code></td><td>查找所有匹配项</td><td>Tag对象列表</td><td>批量提取数据</td></tr><tr><td><code>select(css_selector)</code></td><td>CSS选择器</td><td>Tag对象列表</td><td>熟悉CSS语法时使用</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-11">4. 实战演练：爬取新闻网站标题</h2>
<p>让我们通过一个真实项目来巩固所学知识。我们将模拟爬取一个新闻网站的标题、链接和摘要。</p>
<h3 data-id="heading-12">需求分析</h3>
<p>我们需要从一个新闻网页中提取以下信息：</p>
<ul>
<li>新闻标题</li>
<li>新闻链接</li>
<li>新闻摘要</li>
<li>发布时间</li>
</ul>
<h3 data-id="heading-13">方案设计</h3>
<p>使用<code>requests</code>库获取网页内容（模拟），然后用BeautifulSoup解析数据。我们将使用以下功能：</p>
<ol>
<li><code>find_all()</code>批量查找新闻条目</li>
<li>CSS选择器定位嵌套元素</li>
<li><code>get()</code>方法提取属性</li>
<li><code>get_text()</code>提取文本</li>
</ol>
<h3 data-id="heading-14">完整代码实现</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup

<span class="hljs-comment"># 模拟新闻网页HTML结构</span>
news_html = <span class="hljs-string">"""
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;科技新闻网&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="news-container"&gt;
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/1"&gt;AI技术突破新里程碑&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;人工智能在图像识别领域取得重大进展，准确率提升至98%。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-15&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/2"&gt;量子计算商业化进程加速&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;多家科技巨头宣布量子计算云服务正式上线，标志着量子计算进入实用阶段。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-14&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/3"&gt;5G网络覆盖率达95%&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;最新数据显示，全国5G网络覆盖率已超过95%，为物联网发展奠定基础。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-13&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
"""</span>

<span class="hljs-comment"># 创建BeautifulSoup对象</span>
soup = BeautifulSoup(news_html, <span class="hljs-string">'lxml'</span>)

<span class="hljs-comment"># 查找所有新闻条目</span>
news_items = soup.find_all(<span class="hljs-string">'div'</span>, class_=<span class="hljs-string">'news-item'</span>)

<span class="hljs-comment"># 遍历提取每条新闻的信息</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"科技新闻网 - 最新资讯"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)

<span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(news_items, <span class="hljs-number">1</span>):
    <span class="hljs-comment"># 提取标题和链接</span>
    title_tag = item.find(<span class="hljs-string">'a'</span>)
    title = title_tag.get_text(strip=<span class="hljs-literal">True</span>)
    link = title_tag.get(<span class="hljs-string">'href'</span>)
    
    <span class="hljs-comment"># 提取摘要</span>
    summary_tag = item.find(<span class="hljs-string">'p'</span>, class_=<span class="hljs-string">'news-summary'</span>)
    summary = summary_tag.get_text(strip=<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> summary_tag <span class="hljs-keyword">else</span> <span class="hljs-string">"无摘要"</span>
    
    <span class="hljs-comment"># 提取发布时间</span>
    time_tag = item.find(<span class="hljs-string">'span'</span>, class_=<span class="hljs-string">'publish-time'</span>)
    publish_time = time_tag.get_text(strip=<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> time_tag <span class="hljs-keyword">else</span> <span class="hljs-string">"未知时间"</span>
    
    <span class="hljs-comment"># 输出结果</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n新闻 <span class="hljs-subst">{i}</span>:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"标题: <span class="hljs-subst">{title}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"链接: <span class="hljs-subst">{link}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"摘要: <span class="hljs-subst">{summary}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"发布时间: <span class="hljs-subst">{publish_time}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span> + <span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"共提取 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(news_items)}</span> 条新闻"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span>)
</code></pre>
<h3 data-id="heading-15">运行说明</h3>
<p>将上述代码保存为Python文件并运行，你会看到格式化的新闻列表输出。每个新闻条目都包含标题、链接、摘要和发布时间。</p>
<p><strong>代码亮点</strong>：</p>
<ol>
<li>使用<code>class_='news-item'</code>查找所有新闻容器（注意<code>class_</code>的下划线避免关键字冲突）</li>
<li>使用<code>.get_text(strip=True)</code>去除文本中的多余空格和换行</li>
<li>使用<code>.get('href')</code>安全获取属性，避免属性不存在时报错</li>
<li>使用条件判断处理可能缺失的元素，增强代码健壮性</li>
</ol>
<hr/>
<h2 data-id="heading-16">5. 最佳实践与常见陷阱</h2>
<h3 data-id="heading-17">常见错误及规避方法</h3>
<p><strong>错误1：直接使用<code>class</code>作为参数</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 错误做法</span>
soup.find_all(<span class="hljs-string">'div'</span>, <span class="hljs-keyword">class</span>=<span class="hljs-string">'content'</span>)  <span class="hljs-comment"># SyntaxError</span>

<span class="hljs-comment"># ✅ 正确做法</span>
soup.find_all(<span class="hljs-string">'div'</span>, class_=<span class="hljs-string">'content'</span>)  <span class="hljs-comment"># 加下划线避免关键字冲突</span>
</code></pre>
<p><strong>错误2：属性不存在时直接访问</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 错误做法</span>
link = soup.a[<span class="hljs-string">'href'</span>]  <span class="hljs-comment"># 如果a标签没有href属性会报错</span>

<span class="hljs-comment"># ✅ 正确做法</span>
link = soup.a.get(<span class="hljs-string">'href'</span>)  <span class="hljs-comment"># 属性不存在返回None，安全</span>
link = soup.a.get(<span class="hljs-string">'href'</span>, <span class="hljs-string">'#'</span>)  <span class="hljs-comment"># 可设置默认值</span>
</code></pre>
<p><strong>错误3：混淆string和get_text()</strong></p>
<pre><code class="hljs language-python" lang="python">html = <span class="hljs-string">"&lt;p&gt;Hello &lt;b&gt;World&lt;/b&gt;&lt;/p&gt;"</span>
soup = BeautifulSoup(html, <span class="hljs-string">'lxml'</span>)

<span class="hljs-comment"># ❌ 错误理解</span>
<span class="hljs-built_in">print</span>(soup.p.string)  <span class="hljs-comment"># 输出None，因为有嵌套标签</span>

<span class="hljs-comment"># ✅ 正确做法</span>
<span class="hljs-built_in">print</span>(soup.p.get_text())  <span class="hljs-comment"># 输出：Hello World</span>
</code></pre>
<p><strong>错误4：忘记指定解析器</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 不推荐：依赖默认解析器</span>
soup = BeautifulSoup(html_doc)

<span class="hljs-comment"># ✅ 推荐：明确指定解析器</span>
soup = BeautifulSoup(html_doc, <span class="hljs-string">'lxml'</span>)
</code></pre>
<h3 data-id="heading-18">最佳实践建议</h3>
<ol>
<li>
<p><strong>选择合适的解析器</strong></p>
<ul>
<li>生产环境使用<code>lxml</code>（速度+容错）</li>
<li>开发测试可用<code>html.parser</code>（无需安装）</li>
<li>特殊场景用<code>html5lib</code>（容错性最强）</li>
</ul>
</li>
<li>
<p><strong>使用CSS选择器提高效率</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 传统方法</span>
div.find(<span class="hljs-string">'div'</span>, class_=<span class="hljs-string">'container'</span>).find_all(<span class="hljs-string">'a'</span>)

<span class="hljs-comment"># CSS选择器（更简洁）</span>
soup.select(<span class="hljs-string">'.container a'</span>)
</code></pre>
</li>
<li>
<p><strong>处理中文编码</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 读取文件时指定编码</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'page.html'</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
    soup = BeautifulSoup(f, <span class="hljs-string">'lxml'</span>)
</code></pre>
</li>
<li>
<p><strong>异常处理</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">try</span>:
    title = soup.title.string
<span class="hljs-keyword">except</span> AttributeError:
    title = <span class="hljs-string">"无标题"</span>
</code></pre>
</li>
<li>
<p><strong>性能优化</strong></p>
<ul>
<li>使用<code>limit</code>参数限制返回数量：<code>find_all('a', limit=10)</code></li>
<li>只在必要时调用<code>prettify()</code>（格式化输出耗时）</li>
<li>大文档考虑分块解析</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">注意事项</h3>
<ol>
<li><strong>BeautifulSoup只能解析静态HTML</strong>，对于JavaScript动态渲染的内容，需配合Selenium或Playwright</li>
<li><strong>它不负责下载网页</strong>，需结合requests、urllib等网络库使用</li>
<li><strong>遵守网站的robots.txt协议</strong>，合理设置请求频率，避免给服务器造成压力</li>
<li><strong>注意反爬虫机制</strong>，适当添加User-Agent等请求头</li>
</ol>
<hr/>
<h2 data-id="heading-20">6. 进阶指引</h2>
<h3 data-id="heading-21">高级功能</h3>
<p>BeautifulSoup除了基础的数据提取，还提供了强大的修改功能：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 修改标签内容</span>
soup.title.string = <span class="hljs-string">"新标题"</span>

<span class="hljs-comment"># 添加新标签</span>
new_tag = soup.new_tag(<span class="hljs-string">'div'</span>)
new_tag[<span class="hljs-string">'class'</span>] = <span class="hljs-string">'new-item'</span>
soup.body.append(new_tag)

<span class="hljs-comment"># 删除标签</span>
soup.p.decompose()  <span class="hljs-comment"># 彻底删除标签及其内容</span>
soup.p.extract()    <span class="hljs-comment"># 从文档中移除并返回该标签</span>
</code></pre>
<h3 data-id="heading-22">生态扩展</h3>
<p>结合其他库构建完整的数据采集系统：</p>
<ul>
<li><strong>requests/httpx</strong>：发送HTTP请求获取网页</li>
<li><strong>Selenium/Playwright</strong>：处理动态JavaScript渲染</li>
<li><strong>pandas</strong>：将提取的数据保存为CSV/Excel</li>
<li><strong>sqlite3</strong>：将数据存储到数据库</li>
</ul>
<h3 data-id="heading-23">学习路径</h3>
<ol>
<li><strong>初级阶段</strong>：掌握基本的标签查找和属性提取</li>
<li><strong>中级阶段</strong>：熟练使用CSS选择器和文档树遍历</li>
<li><strong>高级阶段</strong>：学习修改文档树、处理复杂嵌套结构</li>
<li><strong>实战应用</strong>：结合requests完成完整爬虫项目</li>
</ol>
<h3 data-id="heading-24">推荐资源</h3>
<ul>
<li><strong>官方文档</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbeautiful-soup.readthedocs.io%2F%25EF%25BC%2588%25E6%259C%2580%25E6%259D%2583%25E5%25A8%2581%25E7%259A%2584%25E5%258F%2582%25E8%2580%2583%25EF%25BC%2589" target="_blank" title="https://beautiful-soup.readthedocs.io/%EF%BC%88%E6%9C%80%E6%9D%83%E5%A8%81%E7%9A%84%E5%8F%82%E8%80%83%EF%BC%89" ref="nofollow noopener noreferrer">beautiful-soup.readthedocs.io/（最权威的参考）</a></li>
<li><strong>GitHub仓库</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacelessuser%2FBeautifulSoup4" target="_blank" title="https://github.com/facelessuser/BeautifulSoup4" ref="nofollow noopener noreferrer">github.com/facelessuse…</a></li>
<li><strong>实战项目</strong>：尝试爬取豆瓣电影Top250、知乎热榜等网站</li>
</ul>
<p>BeautifulSoup是Python网页解析领域的"瑞士军刀"，掌握了它，你就拥有了从网页中提取数据的强大能力。无论是数据采集、内容分析，还是自动化测试，它都能成为你得力的助手。保持练习，不断探索，你将发现更多精彩的应用场景！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PostgreSQL 分区表的 ALTER TABLE 语句执行机制解析]]></title>    <link>https://juejin.cn/post/7604175912481193990</link>    <guid>https://juejin.cn/post/7604175912481193990</guid>    <pubDate>2026-02-09T06:54:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604175912481193990" data-draft-id="7604279756598870052" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PostgreSQL 分区表的 ALTER TABLE 语句执行机制解析"/> <meta itemprop="keywords" content="PostgreSQL,开源,数据库"/> <meta itemprop="datePublished" content="2026-02-09T06:54:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="IvorySQL"/> <meta itemprop="url" content="https://juejin.cn/user/761327331579511"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PostgreSQL 分区表的 ALTER TABLE 语句执行机制解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/761327331579511/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    IvorySQL
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:54:11.000Z" title="Mon Feb 09 2026 06:54:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>分区表是 PostgreSQL 的核心特性之一，但有一个问题即便资深用户也常会产生困惑：</p>
<blockquote>
<p>在涉及分区时，ALTER TABLE 语句的具体执行逻辑是怎样的？</p>
</blockquote>
<p>操作是否会同步至各分区？是否对新建分区生效？<code>ONLY</code> 关键字是否实现预期效果？为何部分命令可在主表执行却无法在分区执行，或反之？</p>
<p>当前 PostgreSQL 官方文档对单个 <code>ALTER TABLE</code> 子命令的说明较为完善，但很少系统性地解释它们在分区表场景下的整体行为。这导致真实行为往往只能通过反复试验才能被发现。</p>
<p>本文基于一次系统性验证，总结了 <code>ALTER TABLE</code> 在分区表上的行为规律，将零散规则归纳为一套统一的分类模型。</p>
<h2 data-id="heading-0">问题本质：“不一致”并不等同于“未定义”</h2>
<p>在 PostgreSQL 社区中，<code>ALTER TABLE</code> 在分区表上的行为常被描述为“不一致”。实际上，更深层的问题在于：</p>
<ul>
<li>行为规则是存在的；</li>
<li>但规则分散在不同的代码路径、报错信息以及历史设计决策中；</li>
<li>且未以可预测结果的方式进行文档化说明。</li>
</ul>
<p>在缺乏清晰认知模型的情况下，即便是简单问题也难以回答：</p>
<ul>
<li>在父分区表上执行操作后，现有分区会发生什么？</li>
<li>后续新建的分区是否会继承相关设置？</li>
<li><code>ONLY</code> 是否能够阻止传播，还是会被直接忽略？</li>
<li>能否为单个分区单独覆盖相关配置？</li>
</ul>
<h2 data-id="heading-1">ALTER TABLE 子命令的验证方法</h2>
<p>为厘清上述问题，本次研究针对所有 ALTER TABLE 子命令，在分区表场景下采用统一的问题框架开展测试验证。</p>
<h3 data-id="heading-2">四个评估维度</h3>
<p>针对每个子命令，均围绕以下四个核心问题展开验证：</p>
<ol>
<li>传播性（Propagation）
在父分区表上执行操作后，是否会传播到已有分区？</li>
<li>新分区继承性（Inheritance for new partitions）
后续新建的分区是否会继承父表的设置？</li>
<li>ONLY 的影响（Effect of <code>ONLY</code>）
<code>ONLY parent_table</code> 是否如文档所述，能够阻止操作传播？</li>
<li>独立性（Independence）
父表与各个分区是否可以拥有不同的配置值？</li>
</ol>
<p>通过这四个维度，可以将模糊的“不一致”转化为明确、可验证的行为特征。</p>
<h3 data-id="heading-3">范围与版本说明</h3>
<p>本分析基于 PostgreSQL 18 的开发版本行为（截至 2026 年初）。所有结论均在 PostgreSQL 18 上验证。部分细节在早期版本中可能存在差异，未来版本也可能随着分区机制的演进而发生变化。</p>
<h2 data-id="heading-4">分区表上 ALTER TABLE 的分类模型</h2>
<p>基于上述评估维度，<code>ALTER TABLE</code> 的子命令可自然划分为 15 类，每一类对应一种明确的行为模式。</p>
<p>该分类仅作为执行逻辑的参考依据，而非价值判断。</p>
<h3 data-id="heading-5">C1 – 仅作用于父表的结构性变更</h3>
<p>此类特征如下：</p>
<ul>
<li>仅可在分区表上使用；</li>
<li>在分区上执行会失败；</li>
<li>不支持 <code>ONLY</code> 关键字。</li>
</ul>
<p>包含的子命令：</p>
<ul>
<li><code>ADD COLUMN</code>（添加列）</li>
<li><code>DROP COLUMN</code>（删除列）</li>
<li><code>SET DATA TYPE</code>（修改数据类型）</li>
<li><code>DROP EXPRESSION</code>（删除表达式）</li>
<li><code>ADD GENERATED AS IDENTITY</code>（添加自增标识列）</li>
<li><code>ADD GENERATED</code>（添加生成列）</li>
<li><code>SET sequence_option</code>（设置序列参数）</li>
<li><code>RESTART</code>（重启序列）</li>
<li><code>ALTER CONSTRAINT</code>（修改约束）</li>
</ul>
<p>此类命令用于定义分区表的整体结构，必须保持全局一致性。</p>
<h3 data-id="heading-6">C2 – 可传播且可继承的变更</h3>
<p>此类特征如下：</p>
<ul>
<li>从父表传播至所有已有分区；</li>
<li>遵循 <code>ONLY</code> 关键字的作用规则；</li>
<li>新建分区会继承主表的相关配置；</li>
<li>支持为单个分区单独覆盖配置。</li>
</ul>
<p>包含的子命令：</p>
<ul>
<li><code>SET DEFAULT</code>（设置默认值）</li>
<li><code>DROP DEFAULT</code>（删除默认值）</li>
<li><code>SET EXPRESSION AS</code>（设置表达式）</li>
<li><code>SET STORAGE</code>（设置存储参数）</li>
<li><code>DROP CONSTRAINT</code>（删除约束）</li>
<li><code>ENABLE/DISABLE TRIGGER</code>（启用 / 禁用触发器）</li>
</ul>
<p>这是多数场景下对 ALTER TABLE 行为的直观预期。</p>
<h3 data-id="heading-7">C3 – 可传播但不支持新分区继承</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>SET STATISTICS</code>（设置统计信息参数）</li>
</ul>
<p>执行逻辑与 C2 类基本一致，区别在于操作仅同步至现有分区，对后续新建分区不生效。若默认认为配置可自动继承，该特性易引发使用偏差。</p>
<h3 data-id="heading-8">C4 – 父表与分区完全独立</h3>
<p>此类特征如下：</p>
<ul>
<li>不传播；</li>
<li>不继承；</li>
<li>允许父表与分区设置不同值；</li>
<li>支持 <code>ONLY</code> 关键字，但无实际执行效果。</li>
</ul>
<p>包含的子命令：</p>
<ul>
<li><code>SET/RESET (attribute_option = value)</code>（设置 / 重置属性参数）</li>
<li><code>ENABLE/DISABLE [REPLICA | ALWAYS] RULE</code>（启用 / 禁用复制 / 永久规则）</li>
<li><code>ENABLE/DISABLE ROW LEVEL SECURITY</code>（启用 / 禁用行级安全策略）</li>
<li><code>NO FORCE / FORCE ROW LEVEL SECURITY</code>（不强制 / 强制行级安全策略）</li>
<li><code>OWNER TO</code>（修改表属主）</li>
<li><code>REPLICA IDENTITY</code>（设置复制标识）</li>
<li><code>SET SCHEMA</code>（修改所属模式）</li>
</ul>
<p>在行为上，父表与分区几乎等同于彼此独立的普通表。</p>
<h3 data-id="heading-9">C5 – 独立设置，但新分区继承</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>SET COMPRESSION</code>（设置压缩参数）</li>
</ul>
<p>执行逻辑与 C4 基本一致，但新建分区会继承父表设置，已有分区不受影响。</p>
<h3 data-id="heading-10">C6 – 强制传播类命令</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>ADD table_constraint</code>（添加表级约束）</li>
</ul>
<p>执行逻辑与 C2 类基本一致，但不允许使用 <code>ONLY</code>，系统会强制保证所有分区一致。</p>
<h3 data-id="heading-11">C7 – 仅适用于叶子分区的命令</h3>
<p>此类特征如下：</p>
<ul>
<li>无法在分区表上使用；</li>
<li>只能在叶子分区上执行。</li>
</ul>
<p>包含的子命令：</p>
<ul>
<li><code>ADD table_constraint_with_index</code>（添加带索引的表级约束）</li>
<li><code>ALTER CONSTRAINT ... INHERIT / NO INHERIT</code>（修改约束的继承 / 取消继承属性）</li>
<li><code>CLUSTER ON</code>（按指定索引聚簇）</li>
<li><code>SET WITHOUT CLUSTER</code>（取消聚簇）</li>
<li><code>SET LOGGED / UNLOGGED</code>（设置日志记录 / 无日志记录）</li>
<li><code>SET (storage_parameter)</code>（设置存储参数）</li>
</ul>
<h3 data-id="heading-12">C8 – 父表作用域，但允许分区覆盖</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>VALIDATE CONSTRAINT</code>（验证约束）</li>
</ul>
<p>执行逻辑与 C1 类基本一致，区别在于验证动作定义在父表层级，但各分区的验证状态可以不同。</p>
<h3 data-id="heading-13">C9 – 条件继承型</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>SET ACCESS METHOD</code>（设置访问方法）</li>
</ul>
<p>执行逻辑与 C2 类基本一致，但新分区是否继承取决于父表是否显式设置；若未设置，则使用 GUC 默认值。</p>
<h3 data-id="heading-14">C10 – 不传播，但新分区继承</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>SET TABLESPACE</code>（设置表空间）</li>
</ul>
<p>已有分区保持不变，新建分区继承父表设置。接受 <code>ONLY</code>，但无实际效果。</p>
<h3 data-id="heading-15">C11 – 在父表上为空操作</h3>
<p>此类别仅包含一个子命令：</p>
<ul>
<li><code>RESET (storage_parameter)</code>（重置存储参数）</li>
</ul>
<p>此类命令在分区表上不会报错，但也不会产生任何实际变化。</p>
<h3 data-id="heading-16">C12 – 不支持分区表的命令</h3>
<p>包含的子命令：</p>
<ul>
<li><code>INHERIT</code>（继承表）</li>
<li><code>NO INHERIT</code>（取消继承表）</li>
</ul>
<p>在概念上与声明式分区机制不兼容。</p>
<h3 data-id="heading-17">C13 – 仅绑定父表元数据</h3>
<p>包含的子命令：</p>
<ul>
<li><code>OF type</code>（绑定复合类型）</li>
<li><code>NOT OF</code>（取消复合类型绑定）</li>
</ul>
<p>仅作用于分区表本身，在分区上执行会失败。接受 <code>ONLY</code>，但无实际效果。</p>
<h3 data-id="heading-18">C14 – 按普通表处理</h3>
<p>仅包含一个子命令：</p>
<ul>
<li><code>RENAME</code>（重命名）</li>
</ul>
<p>无传播、无继承，也不存在分区相关的特殊行为。</p>
<h3 data-id="heading-19">C15 – 分区管理类命令</h3>
<p>包含的子命令：</p>
<ul>
<li><code>ATTACH PARTITION</code>（挂载分区）</li>
<li><code>DETACH PARTITION</code>（卸载分区）</li>
</ul>
<p>用于操作分区结构本身，而非表属性。</p>
<h2 data-id="heading-20">结语</h2>
<p>在 PostgreSQL 官方文档未对分区表的 ALTER TABLE 语句执行逻辑进行明确、体系化说明前，本分类模型可作为重要的参考依据。</p>
<p>若日常工作中频繁使用分区表，建议将该认知模型作为常用参考，在生产环境执行相关命令前，先确认其所属的执行类别，再开展操作，以降低不可预期风险。</p>
<p>原文链接：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.highgo.ca%2F2026%2F01%2F21%2Funderstanding-alter-table-behavior-on-partitioned-tables-in-postgr" target="_blank" title="https://www.highgo.ca/2026/01/21/understanding-alter-table-behavior-on-partitioned-tables-in-postgr" ref="nofollow noopener noreferrer">www.highgo.ca/2026/01/21/…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端视角下认识 AI Agent 和 LangChain]]></title>    <link>https://juejin.cn/post/7604039449468895282</link>    <guid>https://juejin.cn/post/7604039449468895282</guid>    <pubDate>2026-02-09T06:58:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604039449468895282" data-draft-id="7604080364353585179" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端视角下认识 AI Agent 和 LangChain"/> <meta itemprop="keywords" content="前端,Agent,人工智能"/> <meta itemprop="datePublished" content="2026-02-09T06:58:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lsx_"/> <meta itemprop="url" content="https://juejin.cn/user/1442981392682829"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端视角下认识 AI Agent 和 LangChain
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1442981392682829/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lsx_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:58:36.000Z" title="Mon Feb 09 2026 06:58:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;color:#282d36}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px;color:#2f845e}.markdown-body h2{font-size:22px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 32px);border-bottom:3px solid #2f845e}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%;box-shadow:6px 6px 6px #888}.markdown-body hr{border:none;border-top:1px solid rgba(66,185,131,.15);margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:16px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;border:1px solid #2f845e;border-top:8px solid #2f845e;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important}.markdown-body pre&gt;code.hljs[lang]:before{top:8px!important;color:#2f845e!important}.markdown-body pre&gt;code.language-awesome_error{border:1px solid #ff4d4f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ff4d4f!important;background:#fff2f0!important}.markdown-body pre&gt;code.language-awesome_error:before{content:"!"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ff4d4f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_warn{border:1px solid #ffc46f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ffc46f!important;background:#fffbe6!important}.markdown-body pre&gt;code.language-awesome_warn:before{content:"☂"!important;position:absolute;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ffc46f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_success{border:1px solid #52c41a!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#52c41a!important;background:#f6ffed!important}.markdown-body pre&gt;code.language-awesome_success:before{content:"✓"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#52c41a!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_info{border:1px solid #1890ff!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#1890ff!important;background:#e6f7ff!important}.markdown-body pre&gt;code.language-awesome_info:before{content:"i"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#1890ff!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body strong{background-color:inherit;color:#2f845e}.markdown-body em{background-color:inherit;color:#949415}.markdown-body a{text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64}.markdown-body a:active,.markdown-body a:hover{color:#3f9e64}.markdown-body a[class^=footnote]{margin-left:4px}.markdown-body a:before{content:"➤ "}.markdown-body table{font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54}.markdown-body thead{background:#2f8e54;color:#fff;text-align:left;font-weight:700}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:22px}.markdown-body td{min-width:120px}.markdown-body blockquote{padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:2px}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#2f845e}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px;color:#282d36}.markdown-body del{color:#2f845e}.markdown-body input[type=checkbox]:checked:before{content:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA/klEQVQ4T72TMU7DQBBF318XdFR06egQEnAXRINEGlqgowoIR8AF4AZOZ4JEGq5AC5EixBU4A55BNrEVHAcSBTHlaubt37/zxZKlcn7n6mDPXJvz8IJ89HzWu8t7C8D2dfsY52ae4apHnLx0ktsCsHXZjiUuFgG40x2eJ/H/AhztB+zDUTpLwWj8jGkzxSHiHaMPrDQC8sMoilKzLAUqiKQjmb+ZuAdW80tmelCHODoNgSfP7AFprTTaRTzsJN1GEyuIZ7uW6TEEHwCtyV/6EVBKJHhfzgC0Xv/iXwEFBF4FG0378bd7sPQq5xK/hSnk6sdlX3mZrKkwLZKBeu8n9XuWEUE7X+YAAAAASUVORK5CYII=);position:relative;top:-1px;left:-1px}.markdown-body .math .katex{font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}@media (max-width:720px){.markdown-body h1{font-size:22px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">AI Agent 和 传统应用的区别</h2>
<p>我们假设要开发一个对话机器人的应用。</p>
<p>对于传统对话机器人开发：核心在于后端业务逻辑、数据库设计、API 接口等技术栈。</p>
<p>而对于 AI Agent 对话机器人开发：核心变成了如何与大模型对话、如何优化提示词、如何管理对话流程。</p>
<p>核心在于 AI Agent 中，大模型是驱动这个程序核心，这也是为什么说 AI 改变了传统应用的开发模式。</p>
<h2 data-id="heading-1">AI Agent 的构成</h2>
<p>现在大家常用一个经典公式来概括它的核心构成：</p>
<p><strong><code>AI Agent = LLM(大脑) + Memory(记忆) + Planning(规划) + Tools(工具)</code></strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30cb3f6f7f504170b34ba72ed15fb55f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=k1aNtLnRoXnOyyrX9gxezKcEQkw%3D" alt="image.png" loading="lazy"/></p>
<p>让我们来逐一拆解这四个核心组件：</p>
<ul>
<li><strong>LLM (大语言模型):</strong> Agent 的核心引擎，充当"<strong>大脑</strong>"的角色。它负责理解用户意图，进行推理、分析和决策。所有复杂的逻辑判断和语言理解，都由它来完成。</li>
<li><strong>Planning (规划):</strong> Agent 的"<strong>思考框架</strong>"。当面对复杂任务时（比如"规划旅行"），Agent 需要将其分解成一系列可执行的小步骤（1. 查天气 → 2. 查酒店 → 3. 查景点 → 4. 规划行程）。这种任务分解和规划能力是 Agent 自主性的关键。</li>
<li><strong>Memory (记忆):</strong> Agent 的"<strong>笔记本</strong>"。它能记住之前的交互历史、任务的中间结果，甚至过去的成功经验和失败教训。这使得 Agent 在多轮对话和长期任务中能保持上下文连贯，而不是只有"七秒钟记忆的金鱼脑袋"。</li>
<li><strong>Tools (工具):</strong> Agent 的"<strong>双手</strong>"，是它与现实世界交互的桥梁。无论是 API 调用（如查询天气）、数据库查询，还是近期热门的 <code>MCP Server</code> 概念，这些都属于工具的范畴。</li>
</ul>
<h2 data-id="heading-2">为什么你需要一个 AI 开发框架</h2>
<p>在传统开发中，不同的编程语言都有自己的“神器”：</p>
<ul>
<li>Java 开发者会用 Spring 框架</li>
<li>Go 程序员会选择 Gin 框架</li>
<li>Python 开发者青睐 Django/Flask</li>
</ul>
<p>那么在 AI 应用开发领域，什么是我们的“趁手兵器”呢？</p>
<p>目前 AI Agent 开发框架中最耀眼的一颗星，毫无疑问就是 <strong>LangChain</strong>。今天，就让我们一起来揭开它的神秘面纱！</p>
<h2 data-id="heading-3"> LangChain 是什么？一个生动比喻告诉你答案</h2>
<p>我们使用一个例子，来说明 LangChain 为什么是 AI Agent 开发中必不可少的内容。</p>
<p>没有 LangChain 时，调用不同的大模型可能需要这样：</p>
<p>以下是调用 OpenAI 的 Nodejs 代码</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'openai'</span>;

<span class="hljs-comment">// 初始化客户端</span>
<span class="hljs-keyword">const</span> openai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>({
  <span class="hljs-attr">apiKey</span>: <span class="hljs-string">'your-openai-api-key'</span>,
});

<span class="hljs-comment">// 调用 ChatGPT</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callOpenAI</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> completion = <span class="hljs-keyword">await</span> openai.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">model</span>: <span class="hljs-string">"gpt-3.5-turbo"</span>,
      <span class="hljs-attr">messages</span>: [
        { <span class="hljs-attr">role</span>: <span class="hljs-string">"system"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"You are a helpful assistant."</span> },
        { <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"Hello!"</span> }
      ],
      <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
    });

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(completion.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>);
    <span class="hljs-keyword">return</span> completion;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error calling OpenAI:'</span>, error);
  }
}


<span class="hljs-comment">// 调用 Claude</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Anthropic</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@anthropic-ai/sdk'</span>;

<span class="hljs-comment">// 初始化客户端</span>
<span class="hljs-keyword">const</span> anthropic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Anthropic</span>({
  <span class="hljs-attr">apiKey</span>: <span class="hljs-string">'your-anthropic-api-key'</span>,
});

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callClaude</span>(<span class="hljs-params"/>) {xxx}

<span class="hljs-comment">// 调用函数</span>
<span class="hljs-title function_">callClaude</span>();
</code></pre>
<p>而你使用 LangChain 后：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatAnthropic</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/anthropic"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-comment">// 注：import 'dotenv/config';作用是自动从项目根目录的 `.env` 文件中读取环境变量</span>
<span class="hljs-comment">// 例如 .env 文件中有配置 OPENAI_API_KEY = xxx, 那么我们就可以用 process.env.OPENAI_API_KEY 获取到值</span>

<span class="hljs-comment">// 统一的使用方式</span>
<span class="hljs-keyword">const</span> openai_llm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({
  <span class="hljs-attr">modelName</span>: <span class="hljs-string">"gpt-4"</span>,
  <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
  <span class="hljs-attr">apiKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">OPENAI_API_KEY</span>, <span class="hljs-comment">// 从环境变量读取</span>
});

<span class="hljs-keyword">const</span> claude_llm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatAnthropic</span>({
  <span class="hljs-attr">modelName</span>: <span class="hljs-string">"claude-3-opus-20240229"</span>, <span class="hljs-comment">// Claude 需要具体版本</span>
  <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
  <span class="hljs-attr">apiKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">ANTHROPIC_API_KEY</span>, <span class="hljs-comment">// 从环境变量读取</span>
});

<span class="hljs-comment">// 调用方式完全一致！</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callModels</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 单个调用</span>
    <span class="hljs-keyword">const</span> response1 = <span class="hljs-keyword">await</span> openai_llm.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">"你好"</span>);
    <span class="hljs-keyword">const</span> response2 = <span class="hljs-keyword">await</span> claude_llm.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">"Hello"</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"GPT-4 回复:"</span>, response1.<span class="hljs-property">content</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Claude 3 回复:"</span>, response2.<span class="hljs-property">content</span>);
    
    <span class="hljs-keyword">return</span> { response1, response2 };
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"调用模型时出错:"</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
}

<span class="hljs-comment">// 调用函数</span>
<span class="hljs-title function_">callModels</span>();
</code></pre>
<p>看到区别了吗？LangChain 就像是一个<strong>万能翻译器</strong>，无论底层用的是哪个大模型，都为你提供统一的 API 接口。</p>
<p>展示一下deepseek用langchain的调用方式：</p>
<p>js 版本, 注意下载 @langchain/core，@langchain/openai 包。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;

<span class="hljs-keyword">const</span> apiKey = <span class="hljs-string">"sk-xx"</span>;

<span class="hljs-keyword">const</span> llm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-string">"deepseek-chat"</span>,
  <span class="hljs-attr">temperature</span>: <span class="hljs-number">0</span>,
  apiKey,
  <span class="hljs-attr">configuration</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"https://api.deepseek.com"</span>,
  },
  <span class="hljs-comment">// other params...</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> llm.<span class="hljs-title function_">invoke</span>([
      {
        <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"I love programming."</span>,
      },
    ]);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"response:"</span>, response);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error:"</span>, error);
  }
};

<span class="hljs-title function_">run</span>();
</code></pre>
<h2 data-id="heading-4">拆解 LangChain：名字里藏着什么秘密？</h2>
<p>Lang + Chain = 语言模型 + 链式调用</p>
<p>这个名字精准地描述了它的核心思想：</p>
<ul>
<li>Lang：代表大语言模型（Large Language Model）</li>
<li>Chain：代表将不同组件像链条一样连接起来</li>
</ul>
<p>合起来就是：通过链式架构将大模型能力连接到实际应用中。</p>
<h3 data-id="heading-5">前端开发者的福音</h3>
<p>好消息是，LangChain 原生支持 TypeScript！这意味着前端开发者可以用自己熟悉的 JavaScript/TypeScript 来构建 AI 应用。</p>
<h2 data-id="heading-6">LangChain 还解决了哪些大模型的问题</h2>
<p>大模型虽然强大，但也有一些“与生俱来”的局限性：</p>
<h3 data-id="heading-7">1. 信息过时问题</h3>
<blockquote>
<p>“今天北京的天气怎么样？”</p>
</blockquote>
<p>大模型很可能会告诉你它不知道，因为它的训练数据截止到某个特定日期。这种时效性强的问题，单纯的大模型很难给出准确答案。</p>
<h3 data-id="heading-8">2. 无法联网</h3>
<blockquote>
<p>“帮我查一下特斯拉最新的股价”</p>
</blockquote>
<p>大模型不能实时访问互联网（虽然有些模型后期增加了联网功能，但这通常是基于 LangChain 等技术实现的扩展）。</p>
<h3 data-id="heading-9">3. 私有知识盲区</h3>
<blockquote>
<p>“我们公司的产品定价策略是什么？”</p>
</blockquote>
<p>大模型没有学习过你公司的内部文档，自然无法回答这类问题。</p>
<h3 data-id="heading-10">4. 无法调用外部服务</h3>
<blockquote>
<p>“帮我订一张明天去上海的机票”</p>
</blockquote>
<p>大模型本身没有订票能力，它需要调用第三方的机票预订 API。</p>
<h2 data-id="heading-11">LangChain 如何解决这些问题？</h2>
<p>针对上述问题，LangChain 提供了完整的解决方案：</p>
<h3 data-id="heading-12">解决方案矩阵</h3>






























<table><thead><tr><th>大模型的问题</th><th>LangChain 的解决方案</th><th>实际应用场景</th></tr></thead><tbody><tr><td>信息过时</td><td>实时数据检索</td><td>新闻查询、股票价格、天气信息</td></tr><tr><td>无法联网</td><td>网络搜索工具</td><td>最新资讯、实时数据获取</td></tr><tr><td>私有知识盲区</td><td>文档加载与向量检索</td><td>企业内部知识库、专业文档问答</td></tr><tr><td>不能调用 API</td><td>工具调用集成</td><td>订票、支付、查询等实际业务</td></tr></tbody></table>
<h3 data-id="heading-13">统一的多模型支持</h3>
<p>LangChain 支持几乎所有主流大模型：</p>
<ul>
<li>OpenAI GPT 系列</li>
<li>Anthropic Claude 系列</li>
<li>Google Gemini</li>
<li>开源模型（Llama、Qwen等）</li>
</ul>
<p>而且调用方式完全统一，让你可以轻松切换或同时使用多个模型。</p>
<h2 data-id="heading-14">关于可视化平台的思考</h2>
<p>有些同学可能会问：“现在不是有 Coze、Dify 这类可视化 AI 应用搭建平台吗？为什么还要学编程去做大模型应用？”</p>
<p>这个问题问得很好！作为前端开发者，你一定很清楚低代码/无代码平台的优缺点：</p>
<p>可视化平台的优势</p>
<ul>
<li>上手快，无需编码</li>
<li>快速原型验证</li>
<li>适合简单场景</li>
</ul>
<p>可视化平台的局限</p>
<ul>
<li>定制化能力有限</li>
<li>复杂逻辑实现困难</li>
<li>难以集成到现有系统</li>
<li>性能和扩展性受限</li>
</ul>
<p>就像你不会只用低代码平台来做复杂的前端项目一样，在需要深度定制和复杂集成的 AI 应用场景中，掌握 LangChain 这样的编程框架是必不可少的。</p>
<p>讲完 Langchain 是什么了，接下来我们了解下 AI Agent 开发我们常见遇到的 4 个场景，帮助我们了解到后续开发 AI Agent 可能遇到的架构是什么。</p>
<h2 data-id="heading-15">AI Agent 开发常见的 4 个场景</h2>
<h3 data-id="heading-16">场景一：纯Prompt场景</h3>
<p><strong>纯Prompt场景</strong>是最基础、最直接的AI应用方式，就像使用搜索引擎一样简单：你输入问题（Prompt），AI直接返回答案。示意图如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bafb463d01d84b2d96c37a618155fa21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=dhLnm9vt1PMKFzmkghllgyyxElE%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 纯Prompt场景的简单实现</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChatOpenAI</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@langchain/openai"</span>;

<span class="hljs-keyword">const</span> llm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatOpenAI</span>({
  <span class="hljs-attr">modelName</span>: <span class="hljs-string">"gpt-4"</span>,
  <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
});

<span class="hljs-comment">// 直接调用</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> llm.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">"帮我写一首关于春天的诗"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">content</span>);
</code></pre>
<h3 data-id="heading-17">场景二：Agent + Function Call</h3>
<p>什么是Agent + Function Call？</p>
<p><strong>Agent</strong>是能够自主规划、决策和执行的智能体，<strong>Function Call</strong>让AI能够调用外部工具和API，真正"动手做事"。</p>
<p>简单举例，我们查询天气时，ai 肯定不知道当天天气是什么，此时，ai 可以调用一个函数，这个函数是我们后端自己写的，当问及查询天气的时候，就让大模型调我们的查询天气 api，然后将结果给大模型，最后大模型返回给用户。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab75efb1f6804ce089729a25c0581eee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=Hl2U9UarOt3MP2Kh3yG1sFmBS9Y%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-18">场景三：RAG（检索增强生成）</h3>
<p>简单来说，比如你们要做一个公司内部文档的 AI Agent，当你问这个 AI Agent 问题的时候，很多问题都是跟公司内部信息有关，这个大模型肯定是不知道的，所以我们提前把公司各种资料转化为大模型认识的格式（向量），保存在数据库中，当大模型回答有关公司问题的时候，先去我们的数据库查相关内容，然后找到相关信息，再把之前用户提问的问题增强一下。</p>
<p>增强是指，把从向量数据库搜索的一些资料也附带在问题中，最终大模型基于这些资料和用户的问题回答。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1025c44946394910a73606ae827c7f68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=LnEOBXttgJfYnzbqx61qSYuVG8Q%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-19">场景四：Fine-tuning（微调训练）</h3>
<p>微调也很好理解，之前 RAG 是把我们公司数据库里的信息附带着给大模型，让大模型知道一些背景信息，而微调，是直接把数据库里的资料给大模型训练，让大模型学习到。</p>
<p>最后用户问问题的时候，就不需要 RAG 的模式，还去我们本地的数据库搜索了，直接就能回答跟公司相关的问题了。这就是微调！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca55df15cfa348889348d8bb80dd7f8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225115&amp;x-signature=pmr%2FlL%2Bd9xeUG6%2B%2FRiDfKniUovU%3D" alt="image.png" loading="lazy"/></p>
<p>其实目前实现 AI Agent 大部分就是上面四种类型 + 在可视化平台拖拉拽的方式。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Sass实现，蛇形流动布局]]></title>    <link>https://juejin.cn/post/7604175912481243142</link>    <guid>https://juejin.cn/post/7604175912481243142</guid>    <pubDate>2026-02-09T06:59:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604175912481243142" data-draft-id="7604175912481210374" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Sass实现，蛇形流动布局"/> <meta itemprop="keywords" content="前端,CSS"/> <meta itemprop="datePublished" content="2026-02-09T06:59:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="会一丢丢蝶泳的咻狗"/> <meta itemprop="url" content="https://juejin.cn/user/1803675742243277"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Sass实现，蛇形流动布局
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1803675742243277/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    会一丢丢蝶泳的咻狗
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T06:59:53.000Z" title="Mon Feb 09 2026 06:59:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">效果展示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ee1dce4e36f4b2bb2e2b5744451f74e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lya5LiA5Lii5Lii6J225rOz55qE5ZK754uX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225192&amp;x-signature=Aebf%2Bgy09NP%2FFWSGLPHhnf29AFc%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27ca98d4bfb34a40b4aaac543ffd6696~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lya5LiA5Lii5Lii6J225rOz55qE5ZK754uX:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771225192&amp;x-signature=2dSS1kSzFgsqBY0jMJ%2FNzAd8fw4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">使用Sass构建智能流程图式网格布局系统</h2>
<h3 data-id="heading-2">项目背景</h3>
<p>在民宿康养微实训管理平台的学生模块中，我们需要实现一个直观的流程图式界面，用于展示实训任务的执行步骤。传统的CSS布局难以满足这种复杂的连线需求，因此我们设计了一套基于Sass的智能网格布局系统。</p>
<h3 data-id="heading-3">核心设计思路</h3>
<h4 data-id="heading-4">1. 蛇形流动布局</h4>
<p>系统采用蛇形流动设计，奇数行从左到右，偶数行从右到左，形成自然的视觉引导路径。</p>
<h4 data-id="heading-5">2. 伪元素连线技术</h4>
<p>利用CSS伪元素(<code>::before</code>, <code>::after</code>)动态生成连接线和箭头，避免额外的DOM元素。</p>
<h4 data-id="heading-6">3. 数学计算驱动</h4>
<p>通过Sass的数学函数和循环，实现布局的自动化计算。</p>
<h3 data-id="heading-7">关键技术实现</h3>
<h4 data-id="heading-8">Sass变量定义</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-variable">$grid-columns</span>: <span class="hljs-number">4</span>;                    <span class="hljs-comment">// 网格列数</span>
<span class="hljs-variable">$max-grid-items</span>: <span class="hljs-number">30</span>;                 <span class="hljs-comment">// 最大网格项数</span>
<span class="hljs-variable">$gap-y</span>: <span class="hljs-number">34px</span>;                        <span class="hljs-comment">// 垂直间距</span>
<span class="hljs-variable">$line-ab-top</span>: <span class="hljs-number">20px</span>;                  <span class="hljs-comment">// 连线顶部偏移</span>
</code></pre>
<h4 data-id="heading-9">智能位置计算</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-variable">$max-grid-items</span> {
  <span class="hljs-variable">$row</span>: math.<span class="hljs-built_in">ceil</span>(math.<span class="hljs-built_in">div</span>(<span class="hljs-variable">$i</span>, <span class="hljs-variable">$grid-columns</span>));           <span class="hljs-comment">// 计算行号</span>
  <span class="hljs-variable">$col_in_row</span>: <span class="hljs-variable">$i</span> - (<span class="hljs-variable">$row</span> - <span class="hljs-number">1</span>) * <span class="hljs-variable">$grid-columns</span>;           <span class="hljs-comment">// 计算列号</span>
  <span class="hljs-variable">$direction</span>: <span class="hljs-built_in">if</span>(<span class="hljs-variable">$row</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>, <span class="hljs-variable">$col_in_row</span>, <span class="hljs-variable">$grid-columns</span> - <span class="hljs-variable">$col_in_row</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 蛇形方向</span>
}
</code></pre>
<h4 data-id="heading-10">四种连线模式处理</h4>
<h5 data-id="heading-11">1. 单行中间项（水平右向）</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 水平虚线 + 右箭头</span>
&amp;<span class="hljs-selector-pseudo">::after</span> { <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-number">#626c85</span>; }
&amp;<span class="hljs-selector-pseudo">::before</span> { <span class="hljs-attribute">content</span>: <span class="hljs-variable">$arrow-right-svg</span>; }
</code></pre>
<h5 data-id="heading-12">2. 双行中间项（水平左向）</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 水平虚线 + 左箭头（反向）</span>
&amp;<span class="hljs-selector-pseudo">::after</span> { <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>((<span class="hljs-number">100%</span> - <span class="hljs-variable">$item-inner-width</span> - <span class="hljs-variable">$line-gap</span>) * -<span class="hljs-number">1</span>); }
&amp;<span class="hljs-selector-pseudo">::before</span> { <span class="hljs-attribute">content</span>: <span class="hljs-variable">$arrow-left-svg</span>; }
</code></pre>
<h5 data-id="heading-13">3. 单行最右侧（垂直向下转弯）</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 垂直弯曲线 + 下箭头</span>
&amp;<span class="hljs-selector-pseudo">::after</span> { 
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> + <span class="hljs-variable">$gap-y</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">12px</span> <span class="hljs-number">12px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">border-left</span>: none;
}
</code></pre>
<h5 data-id="heading-14">4. 双行最左侧（垂直向上转弯）</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 垂直弯曲线 + 上箭头</span>
&amp;<span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> + <span class="hljs-variable">$gap-y</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12px</span>;
  <span class="hljs-attribute">border-right</span>: none;
}
</code></pre>
<h3 data-id="heading-15">技术亮点</h3>
<h4 data-id="heading-16">1. Data URI图标嵌入</h4>
<p>使用Data URI格式嵌入SVG箭头，减少HTTP请求：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-variable">$arrow-right-svg</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">"data:image/svg+xml;utf8,&lt;svg&gt;...&lt;/svg&gt;"</span>);
</code></pre>
<h4 data-id="heading-17">2. 响应式计算</h4>
<p>所有尺寸都基于变量计算，便于维护和调整：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-variable">$item-inner-width</span> - (<span class="hljs-variable">$line-gap</span> * <span class="hljs-number">2</span>));
</code></pre>
<h4 data-id="heading-18">3. 边界条件处理</h4>
<p>自动识别首尾项，避免多余的连线：</p>
<pre><code class="hljs language-scss" lang="scss">&amp;<span class="hljs-selector-pseudo">:last-of-type</span><span class="hljs-selector-pseudo">::after</span> { <span class="hljs-attribute">content</span>: none; }
&amp;<span class="hljs-selector-pseudo">:last-of-type</span><span class="hljs-selector-pseudo">::before</span> { <span class="hljs-attribute">content</span>: none; }
</code></pre>
<h3 data-id="heading-19">Vue组件集成</h3>
<h4 data-id="heading-20">模板结构</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="bg-[#016cff1a] p-20"&gt;
    &lt;div class="lk-grid pl-40!"&gt;
      &lt;div v-for="item in 15" :key="item" class="grid-item"&gt;
        &lt;div class="inner"&gt;展示{{ item }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-21">样式作用域</h4>
<p>使用<code>scoped</code>属性确保样式隔离，避免全局污染。</p>
<h3 data-id="heading-22">性能优化考虑</h3>
<ol>
<li><strong>伪元素性能</strong>：CSS伪元素比额外DOM元素性能更好</li>
<li><strong>计算缓存</strong>：Sass编译时完成所有计算，运行时无性能开销</li>
<li><strong>图标优化</strong>：内联SVG避免图标加载延迟</li>
</ol>
<h3 data-id="heading-23">扩展性设计</h3>
<p>系统支持通过修改变量轻松调整：</p>
<ul>
<li>修改<code>$grid-columns</code>改变列数</li>
<li>调整<code>$max-grid-items</code>支持更多步骤</li>
<li>更改颜色变量适配不同主题</li>
</ul>
<h3 data-id="heading-24">总结</h3>
<p>这套Sass网格布局系统成功解决了复杂流程图的可视化需求，通过数学计算和CSS伪元素的巧妙结合，实现了高度可定制且性能优良的布局方案。该技术方案可以广泛应用于工作流、进度跟踪、步骤引导等场景。</p>
<p><strong>技术栈</strong>：Vue 3 + Sass + CSS Grid + 伪元素技术
<strong>适用场景</strong>：流程图、工作流、步骤引导、进度展示</p>
<h2 data-id="heading-25">完整代码</h2>
<pre><code class="hljs language-vue" lang="vue">&lt;style lang="scss" scoped&gt;
@use 'sass:math';
$grid-columns: 7;
$max-grid-items: 30; //线条滚动的个数
$gap-y: 34px;
$line-ab-top: 20px;
// 右箭头：Data URI 格式（直接复制到 content 中使用）
$arrow-right-svg: url("data:image/svg+xml;utf8,&lt;svg viewBox='0 0 24 24' fill='%23626c85' xmlns='http://www.w3.org/2000/svg'&gt;&lt;path d='M8 5v14l11-7z'/&gt;&lt;/svg&gt;");
// 左箭头：Data URI 格式（直接复制到 content 中使用）
$arrow-left-svg: url("data:image/svg+xml;utf8,&lt;svg  viewBox='0 0 24 24' fill='%23626c85' xmlns='http://www.w3.org/2000/svg'&gt;&lt;path d='M16 19l-7-7 7-7v14z'/&gt;&lt;/svg&gt;");
$arrow-width: 24px;
$arrow-height: 24px;

$item-height: 116px;
$item-inner-width: 50px;

// 线段留下的缝隙
$line-gap: 10px;

@mixin grid-container() {
  display: grid;
  grid-template-columns: repeat($grid-columns, 1fr);
  row-gap: $gap-y;
}

@mixin grid-item() {
  height: $item-height;
  width: 100%;
  position: relative;
  // outline: 1px solid #ff0000;
}
@mixin grid-items-layout() {
  // 先线性布局，给每一个item确定位置
  @for $i from 1 through $max-grid-items {
    $row: math.ceil(math.div($i, $grid-columns)); //确定几行
    $col_in_row: $i - ($row - 1) * $grid-columns; //确定在第几行的第几列
    // 使用 % 操作符进行模运算判断奇偶性
    $direction: if($row % 2 == 1, $col_in_row, $grid-columns - $col_in_row + 1); //单数正x，双数反x
    &amp;:nth-child(#{$i}) {
      grid-column: #{$direction};
      grid-row: #{$row};

      // 伪元素，绘制线段箭头
      // 初始化
      &amp;:last-of-type::after {
        content: none;
      }
      &amp;:last-of-type::before {
        content: none;
      }

      // 单行，除了左右侧的
      @if $i % ($grid-columns * 2) &gt; 0 and $i % ($grid-columns * 2) &lt; $grid-columns {
        // 线段
        &amp;::after {
          content: '';
          position: absolute;
          top: $line-ab-top;
          left: calc($item-inner-width + $line-gap);
          display: block;
          width: calc(
            100% - $item-inner-width - ($line-gap * 2)
          ); //占满就是100% - $item-inner-width;但我们左右留个缝隙
          border-top: 1px dashed #626c85;
        }
        // 箭头
        &amp;::before {
          content: $arrow-right-svg;
          position: absolute;
          // top: calc($line-ab-top - ($arrow-height/2));
          // right: calc(10px - ($arrow-width/2));
          top: $line-ab-top;
          right: $line-gap; //留的缝隙
          width: $arrow-width;
          height: $arrow-height;
          transform: translate(50%, -50%);
        }
      }
      // 双行，除了最左侧的
      @if $i % ($grid-columns * 2) &gt; $grid-columns and $i % ($grid-columns * 2) &lt; $grid-columns * 2
      {
        &amp;:after {
          content: '';
          position: absolute;
          top: $line-ab-top;
          left: calc((100% - $item-inner-width - $line-gap) * -1);
          display: block;
          width: calc(
            100% - $item-inner-width - ($line-gap * 2)
          ); //占满就是100% - $item-inner-width;但我们左右留个缝隙
          border-top: 1px dashed #626c85;
        }
        &amp;::before {
          content: $arrow-left-svg;
          position: absolute;
          left: calc(-100% + $line-gap + $item-inner-width);
          top: $line-ab-top;
          width: $arrow-width;
          height: $arrow-height;
          transform: translate(-50%, -50%);
        }
      }
      // 单行最右侧的
      @if $i % ($grid-columns * 2) == $grid-columns {
        &amp;::after {
          content: '';
          position: absolute;
          top: $line-ab-top;
          left: calc($item-inner-width + $line-gap);
          display: block;
          width: 50%; //这个看着改
          height: calc(100% + $gap-y);
          border-radius: 0 12px 12px 0; //弧度看着改
          border: 1px dashed #626c85;
          border-left: none;
        }
        &amp;::before {
          content: $arrow-left-svg;
          position: absolute;
          left: calc($item-inner-width + $line-gap);
          bottom: calc(($gap-y + $line-ab-top) * -1);
          width: $arrow-width;
          height: $arrow-height;
          transform: translate(-50%, 50%);
        }
      }
      // 双行最左侧
      @if $i % ($grid-columns * 2) == 0 {
        $box-width: 30%; //看着改
        &amp;::after {
          content: '';
          position: absolute;
          top: $line-ab-top;
          left: calc(($box-width + $line-gap) * -1);
          display: block;
          width: $box-width; //这个看着改
          height: calc(100% + $gap-y);
          border-radius: 12px 0 0 12px; //弧度看着改
          border: 1px dashed #626c85;
          border-right: none;
        }
        &amp;::before {
          content: $arrow-right-svg;
          position: absolute;
          left: calc($line-gap * -1);
          bottom: calc(($gap-y + $line-ab-top) * -1);
          width: $arrow-width;
          height: $arrow-height;
          transform: translate(-50%, 50%);
        }
      }
    }
  }
}
.lk-grid {
  @include grid-container();
  .grid-item {
    @include grid-item();
    @include grid-items-layout();
    .inner {
      width: $item-inner-width;
      height: 50px;
      background-color: #016cff;
    }
  }
}
&lt;/style&gt;
&lt;template&gt;
  &lt;div class="bg-[#016cff1a] p-20"&gt;
    &lt;div class="lk-grid pl-40!"&gt;
      &lt;div v-for="item in 15" :key="item" class="grid-item"&gt;
        &lt;div class="inner"&gt;展示{{ item }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[中国多模态大模型历史性突破：智源Emu3自回归统一范式技术深度解读]]></title>    <link>https://juejin.cn/post/7604036853130510351</link>    <guid>https://juejin.cn/post/7604036853130510351</guid>    <pubDate>2026-02-09T07:00:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604036853130510351" data-draft-id="7604315965874716706" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="中国多模态大模型历史性突破：智源Emu3自回归统一范式技术深度解读"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-09T07:00:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="indieAI"/> <meta itemprop="url" content="https://juejin.cn/user/4488643649743614"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            中国多模态大模型历史性突破：智源Emu3自回归统一范式技术深度解读
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4488643649743614/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    indieAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T07:00:01.000Z" title="Mon Feb 09 2026 07:00:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>2026年1月28日，北京智源人工智能研究院（BAAI）在国际顶级学术期刊《自然》（Nature）正刊发表重磅研究成果——基于“预测下一个词元”（Next-Token Prediction, NTP）的多模态大模型Emu3。这是我国科研机构主导的大模型成果首次登上Nature封面，标志着中国在人工智能基础理论研究的原始创新能力已跻身世界最前沿。</p>
<p>Nature编辑评价道：“Emu3仅基于‘预测下一个token’实现了大规模文本、图像和视频的统一学习，其在生成与感知任务上的性能可与使用专门路线相当，这一成果对构建可扩展、统一的多模态智能系统具有重要意义，有望推动原生多模态助手、世界模型以及具身智能等方向的发展。”</p>
<p>本文将深度解析Emu3的技术突破、架构创新、性能表现及产业影响，为AI技术研究者、架构师和决策者提供全面认知框架。</p>
<h2 data-id="heading-0">一、突破价值：中国AI科研国际地位的历史性跃升</h2>
<h3 data-id="heading-1">1.1 从跟随到引领的技术范式转换</h3>
<p>自2018年GPT模型以自回归路线开启语言大模型时代以来，多模态领域长期陷入技术路线割裂：视觉生成由扩散模型主导，视觉语言理解依赖CLIP+LLM的组合架构，视频生成更是Sora等扩散模型的专属领地。这种“专模专用”的局面导致AI系统复杂度高、研发成本巨大、应用场景受限。</p>
<p>Emu3的突破意义在于终结了这种技术割裂，首次证明仅通过“预测下一个词元”这一单一目标，就能统一文本、图像、视频三种模态的学习。这不仅简化了多模态AI架构，更确立了中国在AI基础理论创新中的引领地位。</p>
<h3 data-id="heading-2">1.2 原始创新能力的国际认可</h3>
<p>作为继DeepSeek之后中国AI团队的又一里程碑式成果，Emu3登上Nature封面具有双重象征意义：</p>
<ul>
<li><strong>学术认可</strong>：Nature作为国际科学界最高殿堂之一，对Emu3的认可代表着国际科学共同体对中国AI基础研究质量的最高评价。</li>
<li><strong>技术自信</strong>：Emu3选择“硬核原创理论”而非“性价比”路线，证明中国AI已从应用创新转向底层架构创新。</li>
</ul>
<p>前OpenAI政策主管、现Anthropic联合创始人杰克·克拉克评价Emu3：“不依赖花哨的架构技巧，仅用最基础的预测下一个token的逻辑，这种‘简单’被视为具备强大的扩展潜力。”</p>
<h2 data-id="heading-3">二、技术原理：自回归路线如何统一多模态学习</h2>
<h3 data-id="heading-4">2.1 统一表示空间的构建机制</h3>
<p>Emu3的核心创新在于将不同模态数据映射到同一离散表示空间。传统多模态模型通常采用分离的编码器（如CLIP编码图像、BERT编码文本），然后在特征空间进行对齐，这种“拼接式”架构存在模态转换损耗和训练目标不一致问题。</p>
<p>Emu3通过设计统一的视觉分词器（Tokenizer），将512×512图像或540×960视频片段（4帧）高效压缩为4096个离散token。该分词器基于SBER-MoVQGAN架构，创新性加入3D卷积核以同时处理时空信息。</p>
<p>关键设计参数：</p>
<ul>
<li>码本大小（codebook_size）：32768</li>
<li>标记维度（embed_dim）：4</li>
<li>压缩比：固定（适配任意时空分辨率输入）</li>
<li>时序下采样因子（temporal_downsample_factor）：4</li>
</ul>
<h3 data-id="heading-5">2.2 纯自回归预测的数学表达</h3>
<p>给定一个多模态序列<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S = [t_1, t_2, ..., t_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>，其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span>可以是文本token、视觉token或动作token，Emu3的训练目标是最大化序列的联合概率：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(S) = \prod_{i=1}^{n} P(t_i | t_1, t_2, ..., t_{i-1}; \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"/><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"/><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span/></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span/></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></div>
<p>其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span>为模型参数。通过标准的交叉熵损失函数优化：</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">L</mi><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">;</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{L} = -\sum_{i=1}^{n} \log P(t_i | t_1, t_2, ..., t_{i-1}; \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathcal">L</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"/><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"/><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span/></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span/></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></div>
<p>为避免视觉token占比过高主导训练，研究团队将视觉token的损失权重设为0.5，确保模型平衡学习各模态特征。</p>
<h3 data-id="heading-6">2.3 多模态序列的数据格式设计</h3>
<p>为实现文本、图像、视频的统一输入，Emu3定义了结构化的多模态序列格式：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[BOS]</span> {<span class="hljs-selector-tag">caption</span> text} <span class="hljs-selector-attr">[SOV]</span> {meta text} <span class="hljs-selector-attr">[SOT]</span> {vision tokens} <span class="hljs-selector-attr">[EOV]</span> <span class="hljs-selector-attr">[EOS]</span>
</code></pre>
<p>特殊token功能说明：</p>
<ul>
<li><code>[BOS]/[EOS]</code>：文本分词器原生的开始/结束标记</li>
<li><code>[SOV]</code>（Start of Vision）：视觉输入开始标记</li>
<li><code>[SOT]</code>（Start of Vision Tokens）：视觉token开始标记</li>
<li><code>[EOV]</code>（End of Vision）：视觉输入结束标记</li>
<li><code>[EOL]/[EOF]</code>：插入视觉token中，分别表示换行和帧边界</li>
</ul>
<h2 data-id="heading-7">三、架构创新：极简统一的Transformer设计</h2>
<h3 data-id="heading-8">3.1 纯解码器架构的核心设计</h3>
<p>Emu3沿用LLM的解oder-only架构，参考Llama-2设计，仅针对多模态场景做少量适配：</p>
<p><strong>核心配置</strong>：</p>
<ul>
<li>参数量：130亿（基础版本）</li>
<li>层数：32层Transformer解码器</li>
<li>注意力头数：32头</li>
<li>隐藏维度：4096</li>
<li>词汇表大小：32768（共享码本）</li>
</ul>
<p><strong>架构优化</strong>：</p>
<ul>
<li>归一化：采用RMSNorm，提升训练稳定性</li>
<li>注意力机制：使用GQA（Grouped Query Attention），平衡性能与计算效率</li>
<li>激活函数：SwiGLU，增强模型表达能力</li>
<li>去偏置：移除QKV和线性投影层的偏置，减少参数冗余</li>
<li>文本分词器：采用QwenTokenizer，支持多语言处理</li>
</ul>
<h3 data-id="heading-9">3.2 视觉分词器的技术突破</h3>
<p>Emu3VisionVQVectorQuantizer是向量量化的关键模块，实现机制包括：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 简化后的向量量化器结构示意</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Emu3VisionVQVectorQuantizer</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.codebook_size = config.codebook_size  <span class="hljs-comment"># 32768</span>
        self.embed_dim = config.embed_dim          <span class="hljs-comment"># 4</span>
        self.commitment_cost = config.commitment_cost  <span class="hljs-comment"># 0.25</span>
        <span class="hljs-comment"># 3D卷积层处理时空信息</span>
        self.conv_3d = nn.Conv3d(in_channels, out_channels, 
                                 kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, z</span>):
        <span class="hljs-comment"># 将连续特征映射到最近码本向量</span>
        distances = torch.cdist(z, self.codebook)
        encoding_indices = torch.argmin(distances, dim=-<span class="hljs-number">1</span>)
        quantized = self.codebook[encoding_indices]
        <span class="hljs-comment"># 直通估计器梯度传递</span>
        quantized = z + (quantized - z).detach()
        <span class="hljs-keyword">return</span> quantized, encoding_indices
</code></pre>
<h3 data-id="heading-10">3.3 三阶段训练策略</h3>
<h4 data-id="heading-11">阶段一：大规模预训练</h4>
<ul>
<li>数据混合：文本+图像+视频混合序列</li>
<li>上下文长度：第一阶段5120，第二阶段扩展至131072</li>
<li>学习率：5×10⁻⁵，采用余弦退火策略</li>
<li>并行策略：张量并行（TP）+上下文并行（CP）+数据并行（DP）</li>
</ul>
<h4 data-id="heading-12">阶段二：质量微调（QFT）</h4>
<ul>
<li>数据筛选：图像数据采用HPSv2.1、MPS、LAION美学分数平均值筛选</li>
<li>分辨率提升：训练分辨率从512像素提升至720像素</li>
<li>损失设计：仅对视觉token施加监督，保持NTP目标不变</li>
</ul>
<h4 data-id="heading-13">阶段三：直接偏好优化（DPO）</h4>
<ul>
<li>数据构建：每个提示词生成8-10个样本，3名标注者从视觉吸引力和提示词对齐度评分</li>
<li>训练目标：最小化DPO损失与NTP交叉熵损失的组合</li>
<li>效果提升：人类偏好分数从52.3/57.3提升至61.6/60.6</li>
</ul>
<h2 data-id="heading-14">四、性能对比：全面超越传统多模态模型</h2>
<h3 data-id="heading-15">4.1 图像生成性能对比</h3>
<p>在MSCOCO-30K23、GenEval24、T2I-CompBench25等多个基准测试中，Emu3表现出色：</p>









































<table><thead><tr><th>模型</th><th>MSCOCO FID↓</th><th>GenEval得分↑</th><th>T2I-CompBench↑</th></tr></thead><tbody><tr><td>Stable Diffusion 1.5</td><td>18.3</td><td>72.5</td><td>81.2</td></tr><tr><td>SDXL</td><td>15.6</td><td>75.8</td><td>84.7</td></tr><tr><td>DALL-E 3</td><td>12.1</td><td>79.3</td><td>88.4</td></tr><tr><td>Emu3</td><td><strong>11.8</strong></td><td><strong>80.2</strong></td><td><strong>88.9</strong></td></tr><tr><td>FLUX.1 (Dev)</td><td>11.9</td><td>80.1</td><td>88.7</td></tr></tbody></table>
<p><strong>关键发现</strong>：Emu3作为纯自回归模型，在图像生成质量上与最先进的扩散模型相当甚至略有优势，打破了“扩散模型主导视觉生成”的传统认知。</p>
<h3 data-id="heading-16">4.2 视觉语言理解性能</h3>
<p>在视觉问答、图像描述、跨模态检索等任务中，Emu3的表现同样出色：</p>





























<table><thead><tr><th>模型</th><th>VQA v2↑</th><th>TextCaps↑</th><th>COCO Retrieval@5↑</th></tr></thead><tbody><tr><td>LLaVA-1.6 (13B)</td><td>78.3</td><td>82.7</td><td>76.4</td></tr><tr><td>Qwen-VL-Chat</td><td>79.1</td><td>83.5</td><td>77.2</td></tr><tr><td>Emu3</td><td><strong>79.8</strong></td><td><strong>84.1</strong></td><td><strong>78.0</strong></td></tr></tbody></table>
<p><strong>技术洞察</strong>：Emu3作为一种纯粹的无编码器方法，在多个基准测试中达到了与组合式方法（CLIP+LLM）相当的性能，证明统一的Transformer架构完全有能力自主学习跨模态对齐。</p>
<h3 data-id="heading-17">4.3 视频生成能力</h3>
<p>Emu3原生支持24帧/秒的5秒视频生成，并可通过自回归方法进行扩展：</p>
<ul>
<li><strong>VBench评分</strong>：81分，超过Open-Sora 1.2的78分</li>
<li><strong>生成方式</strong>：纯自回归逐token预测，而非扩散模型的迭代去噪</li>
<li><strong>扩展能力</strong>：通过预测未来帧实现视频延展，展现对物理世界环境、人类与动物行为的初步模拟能力</li>
</ul>
<h3 data-id="heading-18">4.4 多模态缩放定律</h3>
<p>研究团队发现Emu3的性能随着模型大小和训练数据量的增加，呈现出清晰的幂律缩放行为：</p>
<ul>
<li><strong>图像生成</strong>：性能随参数规模增加呈<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∝</mo><msup><mi>N</mi><mn>0.085</mn></msup></mrow><annotation encoding="application/x-tex">P \propto N^{0.085}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8141em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.085</span></span></span></span></span></span></span></span></span></span></span></span></span>提升</li>
<li><strong>视觉理解</strong>：性能随参数规模增加呈<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∝</mo><msup><mi>N</mi><mn>0.072</mn></msup></mrow><annotation encoding="application/x-tex">P \propto N^{0.072}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8141em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.072</span></span></span></span></span></span></span></span></span></span></span></span></span>提升</li>
<li><strong>视频生成</strong>：性能随参数规模增加呈<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∝</mo><msup><mi>N</mi><mn>0.091</mn></msup></mrow><annotation encoding="application/x-tex">P \propto N^{0.091}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8141em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.091</span></span></span></span></span></span></span></span></span></span></span></span></span>提升</li>
</ul>
<p>这种可预测的缩放定律为大规模AI模型研发提供了明确的技术路径。</p>
<h2 data-id="heading-19">五、实战代码：基于Emu3原理的简化多模态理解/生成示例</h2>
<h3 data-id="heading-20">5.1 环境配置与依赖安装</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># requirements.txt</span>
torch&gt;=<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>
transformers&gt;=<span class="hljs-number">4.36</span><span class="hljs-number">.0</span>
accelerate&gt;=<span class="hljs-number">0.25</span><span class="hljs-number">.0</span>
einops&gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span>
pillow&gt;=<span class="hljs-number">10.0</span><span class="hljs-number">.0</span>
opencv-python&gt;=<span class="hljs-number">4.8</span><span class="hljs-number">.0</span>

<span class="hljs-comment"># 安装命令</span>
<span class="hljs-comment"># pip install -r requirements.txt</span>
</code></pre>
<h3 data-id="heading-21">5.2 统一多模态Tokenizer实现</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModel

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnifiedMultimodalTokenizer</span>:
    <span class="hljs-string">"""基于Emu3原理的统一多模态分词器简化实现"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size=<span class="hljs-number">32768</span>, embed_dim=<span class="hljs-number">4</span></span>):
        self.vocab_size = vocab_size
        self.embed_dim = embed_dim
        self.text_tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">"Qwen/Qwen2.5-7B-Instruct"</span>)
        
        <span class="hljs-comment"># 视觉编码器简化实现</span>
        self.visual_encoder = self._build_visual_encoder()
        self.codebook = nn.Embedding(vocab_size, embed_dim)
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_visual_encoder</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""简化视觉编码器，实际应为3D卷积网络"""</span>
        <span class="hljs-keyword">return</span> nn.Sequential(
            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>),
            nn.ReLU(),
            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>),
            nn.ReLU(),
            nn.Conv2d(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>),
            nn.AdaptiveAvgPool2d((<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))
        )
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_text</span>(<span class="hljs-params">self, text</span>):
        <span class="hljs-string">"""文本分词"""</span>
        tokens = self.text_tokenizer.encode(text, add_special_tokens=<span class="hljs-literal">False</span>)
        <span class="hljs-keyword">return</span> tokens
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_image</span>(<span class="hljs-params">self, image_tensor</span>):
        <span class="hljs-string">"""图像分词：实际应为VQ-VAE压缩过程"""</span>
        <span class="hljs-comment"># 提取视觉特征</span>
        features = self.visual_encoder(image_tensor)
        b, c, h, w = features.shape
        features = features.view(b, c, h*w).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        
        <span class="hljs-comment"># 向量量化简化实现</span>
        flattened = features.reshape(-<span class="hljs-number">1</span>, c)
        distances = torch.cdist(flattened, self.codebook.weight)
        indices = torch.argmin(distances, dim=-<span class="hljs-number">1</span>)
        indices = indices.view(b, h*w)
        
        <span class="hljs-keyword">return</span> indices.tolist()
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_multimodal_sequence</span>(<span class="hljs-params">self, text, image_tokens=<span class="hljs-literal">None</span></span>):
        <span class="hljs-string">"""构建统一的多模态序列"""</span>
        sequence = []
        
        <span class="hljs-comment"># 添加文本开始标记</span>
        sequence.append(self.text_tokenizer.bos_token_id)
        
        <span class="hljs-comment"># 添加文本token</span>
        text_tokens = self.tokenize_text(text)
        sequence.extend(text_tokens)
        
        <span class="hljs-keyword">if</span> image_tokens:
            <span class="hljs-comment"># 添加视觉开始标记（简化实现）</span>
            sequence.append(self.vocab_size + <span class="hljs-number">1</span>)  <span class="hljs-comment"># [SOV]</span>
            <span class="hljs-comment"># 添加视觉token</span>
            sequence.extend(image_tokens)
            sequence.append(self.vocab_size + <span class="hljs-number">2</span>)  <span class="hljs-comment"># [EOV]</span>
        
        <span class="hljs-comment"># 添加序列结束标记</span>
        sequence.append(self.text_tokenizer.eos_token_id)
        
        <span class="hljs-keyword">return</span> sequence
</code></pre>
<h3 data-id="heading-22">5.3 简化Transformer模型架构</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplifiedEmu3Decoder</span>(nn.Module):
    <span class="hljs-string">"""简化的Emu3解码器实现，展示统一多模态学习原理"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, vocab_size=<span class="hljs-number">32768</span>, hidden_dim=<span class="hljs-number">512</span>, num_layers=<span class="hljs-number">6</span>, num_heads=<span class="hljs-number">8</span></span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.embedding = nn.Embedding(vocab_size + <span class="hljs-number">10</span>, hidden_dim)  <span class="hljs-comment"># 预留特殊token</span>
        self.layers = nn.ModuleList([
            self._build_decoder_layer(hidden_dim, num_heads) 
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_layers)
        ])
        self.fc_out = nn.Linear(hidden_dim, vocab_size)
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_decoder_layer</span>(<span class="hljs-params">self, hidden_dim, num_heads</span>):
        <span class="hljs-string">"""构建单层解码器"""</span>
        <span class="hljs-keyword">return</span> nn.ModuleDict({
            <span class="hljs-string">'attn'</span>: nn.MultiheadAttention(hidden_dim, num_heads, batch_first=<span class="hljs-literal">True</span>),
            <span class="hljs-string">'ffn'</span>: nn.Sequential(
                nn.Linear(hidden_dim, hidden_dim * <span class="hljs-number">4</span>),
                nn.SiLU(),
                nn.Linear(hidden_dim * <span class="hljs-number">4</span>, hidden_dim)
            ),
            <span class="hljs-string">'norm1'</span>: nn.RMSNorm(hidden_dim),
            <span class="hljs-string">'norm2'</span>: nn.RMSNorm(hidden_dim)
        })
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids, attention_mask=<span class="hljs-literal">None</span></span>):
        <span class="hljs-string">"""前向传播"""</span>
        x = self.embedding(input_ids)
        
        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers:
            <span class="hljs-comment"># 自注意力</span>
            residual = x
            x = layer[<span class="hljs-string">'norm1'</span>](x)
            attn_output, _ = layer[<span class="hljs-string">'attn'</span>](
                x, x, x, 
                key_padding_mask=attention_mask <span class="hljs-keyword">if</span> attention_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
            )
            x = residual + attn_output
            
            <span class="hljs-comment"># 前馈网络</span>
            residual = x
            x = layer[<span class="hljs-string">'norm2'</span>](x)
            x = residual + layer[<span class="hljs-string">'ffn'</span>](x)
        
        logits = self.fc_out(x)
        <span class="hljs-keyword">return</span> logits
</code></pre>
<h3 data-id="heading-23">5.4 多模态推理示例</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">multimodal_generation_demo</span>():
    <span class="hljs-string">"""展示统一多模态生成流程"""</span>
    
    <span class="hljs-comment"># 初始化模型和分词器</span>
    tokenizer = UnifiedMultimodalTokenizer()
    model = SimplifiedEmu3Decoder()
    
    <span class="hljs-comment"># 示例1：纯文本生成</span>
    text_prompt = <span class="hljs-string">"一只可爱的橘猫坐在窗台上晒太阳"</span>
    text_tokens = tokenizer.tokenize_text(text_prompt)
    text_sequence = tokenizer.create_multimodal_sequence(text_prompt)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"文本提示词: <span class="hljs-subst">{text_prompt}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"文本token数: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(text_tokens)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"完整序列长度: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(text_sequence)}</span>"</span>)
    
    <span class="hljs-comment"># 示例2：图文交错生成（简化）</span>
    multimodal_prompt = <span class="hljs-string">"先展示一张日出时分的海滩照片，然后描述照片中的细节"</span>
    sequence = tokenizer.create_multimodal_sequence(multimodal_prompt)
    
    <span class="hljs-comment"># 模拟推理过程</span>
    <span class="hljs-keyword">with</span> torch.no_grad():
        input_tensor = torch.tensor([sequence])
        logits = model(input_tensor)
        predicted_tokens = torch.argmax(logits, dim=-<span class="hljs-number">1</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n多模态生成完成！"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"输入序列长度: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(sequence)}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"预测token数: <span class="hljs-subst">{predicted_tokens.shape[-<span class="hljs-number">1</span>]}</span>"</span>)
    
    <span class="hljs-keyword">return</span> predicted_tokens

<span class="hljs-comment"># 运行演示</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    predictions = multimodal_generation_demo()
</code></pre>
<h3 data-id="heading-24">5.5 多模态Prompt工程优化实践</h3>
<p>随着Emu3等统一多模态大模型的普及，跨模态Prompt设计面临新的技术挑战：如何高效评估文本-图像-视频联合生成的质量一致性？</p>
<p><strong>传统方法的局限性</strong>：</p>
<ol>
<li><strong>单模态评估割裂</strong>：分别评估文本质量、图像质量、视频质量，缺乏跨模态一致性度量</li>
<li><strong>人工标注成本高</strong>：需要专家标注者同时具备文本理解、视觉感知、时序分析能力</li>
<li><strong>评估标准不统一</strong>：不同团队使用不同的评估指标和基准数据集</li>
</ol>
<p><strong>优化方案：基于prompt-minder.com的多模态评估API</strong></p>
<p>Emu3的统一多模态学习为跨模态Prompt工程提出了新范式。通过prompt-minder.com的多模态评估API，开发者可以建立标准化的质量基准，实现从单模态到多模态Prompt工程的平滑过渡：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 使用prompt-minder.com API进行多模态评估</span>
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultimodalPromptEvaluator</span>:
    <span class="hljs-string">"""基于prompt-minder.com的多模态Prompt评估器"""</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, api_key</span>):
        self.api_key = api_key
        self.base_url = <span class="hljs-string">"https://api.prompt-minder.com/v1"</span>
        
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_multimodal_generation</span>(<span class="hljs-params">self, prompt, generated_content, content_type=<span class="hljs-string">"mixed"</span></span>):
        <span class="hljs-string">"""
        评估多模态生成质量
        content_type: "text" | "image" | "video" | "mixed"
        """</span>
        headers = {
            <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">f"Bearer <span class="hljs-subst">{self.api_key}</span>"</span>,
            <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
        }
        
        payload = {
            <span class="hljs-string">"prompt"</span>: prompt,
            <span class="hljs-string">"generated_content"</span>: generated_content,
            <span class="hljs-string">"content_type"</span>: content_type,
            <span class="hljs-string">"metrics"</span>: [
                <span class="hljs-string">"cross_modal_alignment"</span>,  <span class="hljs-comment"># 跨模态对齐度</span>
                <span class="hljs-string">"semantic_consistency"</span>,    <span class="hljs-comment"># 语义一致性</span>
                <span class="hljs-string">"visual_fidelity"</span>,         <span class="hljs-comment"># 视觉保真度</span>
                <span class="hljs-string">"temporal_coherence"</span>       <span class="hljs-comment"># 时序连贯性</span>
            ]
        }
        
        response = requests.post(
            <span class="hljs-string">f"<span class="hljs-subst">{self.base_url}</span>/evaluate/multimodal"</span>,
            headers=headers,
            data=json.dumps(payload)
        )
        
        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> response.json()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f"评估失败: <span class="hljs-subst">{response.text}</span>"</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">optimize_prompt_iteratively</span>(<span class="hljs-params">self, initial_prompt, target_modality=<span class="hljs-string">"mixed"</span>, iterations=<span class="hljs-number">3</span></span>):
        <span class="hljs-string">"""迭代优化多模态Prompt"""</span>
        optimized_prompt = initial_prompt
        evaluation_history = []
        
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iterations):
            <span class="hljs-comment"># 模拟生成内容（实际应为模型生成）</span>
            simulated_content = self._simulate_generation(optimized_prompt, target_modality)
            
            <span class="hljs-comment"># 评估生成质量</span>
            evaluation = self.evaluate_multimodal_generation(
                optimized_prompt, 
                simulated_content, 
                target_modality
            )
            
            evaluation_history.append({
                <span class="hljs-string">"iteration"</span>: i + <span class="hljs-number">1</span>,
                <span class="hljs-string">"prompt"</span>: optimized_prompt,
                <span class="hljs-string">"scores"</span>: evaluation[<span class="hljs-string">"scores"</span>]
            })
            
            <span class="hljs-comment"># 基于评估结果优化Prompt</span>
            <span class="hljs-keyword">if</span> i &lt; iterations - <span class="hljs-number">1</span>:
                optimized_prompt = self._refine_prompt(
                    optimized_prompt, 
                    evaluation[<span class="hljs-string">"scores"</span>]
                )
        
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"final_prompt"</span>: optimized_prompt,
            <span class="hljs-string">"evaluation_history"</span>: evaluation_history
        }
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_simulate_generation</span>(<span class="hljs-params">self, prompt, modality</span>):
        <span class="hljs-string">"""简化生成过程模拟"""</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"text"</span>: <span class="hljs-string">f"基于提示词'<span class="hljs-subst">{prompt}</span>'生成的文本描述"</span>,
            <span class="hljs-string">"image"</span>: <span class="hljs-string">"模拟图像数据"</span>,
            <span class="hljs-string">"video"</span>: <span class="hljs-string">"模拟视频数据"</span>
        }
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_refine_prompt</span>(<span class="hljs-params">self, prompt, scores</span>):
        <span class="hljs-string">"""基于评估分数优化Prompt"""</span>
        <span class="hljs-comment"># 简化优化逻辑</span>
        <span class="hljs-keyword">if</span> scores[<span class="hljs-string">"cross_modal_alignment"</span>] &lt; <span class="hljs-number">0.7</span>:
            <span class="hljs-keyword">return</span> prompt + <span class="hljs-string">"。请确保文本描述与视觉内容高度一致。"</span>
        <span class="hljs-keyword">elif</span> scores[<span class="hljs-string">"temporal_coherence"</span>] &lt; <span class="hljs-number">0.6</span>:
            <span class="hljs-keyword">return</span> prompt + <span class="hljs-string">"。注意视频帧间的连贯性和物理规律。"</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> prompt

<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">prompt_optimization_workflow</span>():
    <span class="hljs-string">"""展示多模态Prompt优化工作流"""</span>
    
    api_key = <span class="hljs-string">"your-api-key-here"</span>
    evaluator = MultimodalPromptEvaluator(api_key)
    
    <span class="hljs-comment"># 初始Prompt</span>
    initial_prompt = <span class="hljs-string">"生成一段关于未来城市的宣传视频，包含高楼大厦、飞行汽车和全息广告"</span>
    
    <span class="hljs-comment"># 迭代优化</span>
    result = evaluator.optimize_prompt_iteratively(
        initial_prompt=initial_prompt,
        target_modality=<span class="hljs-string">"mixed"</span>,  <span class="hljs-comment"># 混合模态</span>
        iterations=<span class="hljs-number">3</span>
    )
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"多模态Prompt优化完成！"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"初始Prompt: <span class="hljs-subst">{initial_prompt}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"优化后Prompt: <span class="hljs-subst">{result[<span class="hljs-string">'final_prompt'</span>]}</span>"</span>)
    
    <span class="hljs-comment"># 展示评估历史</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n评估历史:"</span>)
    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> result[<span class="hljs-string">"evaluation_history"</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"迭代<span class="hljs-subst">{record[<span class="hljs-string">'iteration'</span>]}</span>: <span class="hljs-subst">{record[<span class="hljs-string">'scores'</span>]}</span>"</span>)
    
    <span class="hljs-keyword">return</span> result

</code></pre>
<h2 data-id="heading-25">六、产业影响：统一范式对AI应用开发的变革性影响</h2>
<h3 data-id="heading-26">6.1 降低多模态AI开发门槛</h3>
<p>Emu3的统一架构将带来AI开发范式的根本变革：</p>
<p><strong>传统模式的问题</strong>：</p>
<ul>
<li>开发团队需要精通多种技术栈：NLP、CV、视频处理</li>
<li>模型集成复杂度高，维护成本巨大</li>
<li>跨模态数据对齐困难，性能优化挑战多</li>
</ul>
<p><strong>Emu3带来的变革</strong>：</p>
<ul>
<li><strong>单一技术栈</strong>：只需掌握Transformer和自回归预测</li>
<li><strong>统一训练流程</strong>：文本、图像、视频统一训练，无需多阶段拼接</li>
<li><strong>标准化评估</strong>：跨模态质量评估基准建立</li>
</ul>
<h3 data-id="heading-27">6.2 推动原生多模态应用爆发</h3>
<p>Emu3的统一范式将催生新一代AI应用：</p>
<ol>
<li>
<p><strong>智能内容创作平台</strong>：</p>
<ul>
<li>用户可用自然语言描述需求，系统自动生成图文并茂的内容</li>
<li>视频制作从专业工具转向自然语言交互</li>
</ul>
</li>
<li>
<p><strong>跨模态人机交互系统</strong>：</p>
<ul>
<li>AI能同时理解语音指令、手势动作、环境视觉</li>
<li>智能助理从“聊天机器人”升级为“全能助手”</li>
</ul>
</li>
<li>
<p><strong>产业数字化转型加速</strong>：</p>
<ul>
<li>制造业：产品设计从CAD建模转向自然语言描述</li>
<li>教育：个性化学习材料自动生成</li>
<li>医疗：病历文本与医学影像的联合分析</li>
</ul>
</li>
</ol>
<h3 data-id="heading-28">6.3 对Prompt工程的技术要求升级</h3>
<p>Emu3的成功实施对Prompt工程提出新要求：</p>
<p><strong>技术挑战</strong>：</p>
<ol>
<li><strong>跨模态一致性</strong>：如何设计Prompt确保文本、图像、视频在语义上一致</li>
<li><strong>时序逻辑建模</strong>：视频生成的Prompt需包含时间维度的逻辑约束</li>
<li><strong>质量评估体系</strong>：建立统一的多模态生成质量评估标准</li>
</ol>
<p><strong>解决方案</strong>：
通过prompt-minder.com的多模态评估API，开发者可以：</p>
<ul>
<li>建立标准化的跨模态Prompt设计规范</li>
<li>实现多模态生成质量的自动化评估</li>
<li>迭代优化Prompt以提高生成效果</li>
</ul>
<p>这正是大规模多模态应用落地的关键技术支撑。</p>
<h3 data-id="heading-29">6.4 对AI芯片与算力基础设施的影响</h3>
<p>Emu3的统一架构对硬件提出新要求：</p>
<p><strong>计算特征变化</strong>：</p>
<ul>
<li><strong>注意力模式</strong>：长序列混合模态的自注意力计算</li>
<li><strong>内存需求</strong>：多模态token序列的KV缓存管理</li>
<li><strong>推理效率</strong>：自回归生成的串行特性与加速优化</li>
</ul>
<p><strong>产业机遇</strong>：</p>
<ul>
<li>专用AI芯片针对统一多模态架构优化</li>
<li>云计算平台提供多模态模型训练推理服务</li>
<li>边缘设备支持轻量化多模态应用部署</li>
</ul>
<h2 data-id="heading-30">七、技术局限与未来展望</h2>
<h3 data-id="heading-31">7.1 当前技术局限</h3>
<ol>
<li>
<p><strong>推理效率挑战</strong>：</p>
<ul>
<li>纯自回归解码的串行特性限制生成速度</li>
<li>大规模多模态序列的KV缓存内存占用高</li>
<li>实时交互应用面临延迟挑战</li>
</ul>
</li>
<li>
<p><strong>Tokenizer质量瓶颈</strong>：</p>
<ul>
<li>压缩率与重建保真度的权衡</li>
<li>复杂场景细节保留不足</li>
<li>长视频序列的时序信息损失</li>
</ul>
</li>
<li>
<p><strong>训练数据需求</strong>：</p>
<ul>
<li>高质量多模态对齐数据稀缺</li>
<li>长视频训练样本获取成本高</li>
<li>领域特定数据标注困难</li>
</ul>
</li>
</ol>
<h3 data-id="heading-32">7.2 未来发展方向</h3>
<ol>
<li>
<p><strong>架构持续优化</strong>：</p>
<ul>
<li>探索并行解码技术加速推理</li>
<li>研究更高效的视觉分词器</li>
<li>优化长序列注意力计算</li>
</ul>
</li>
<li>
<p><strong>应用场景拓展</strong>：</p>
<ul>
<li>具身智能：机器人与物理世界交互</li>
<li>科学发现：跨模态科学数据分析</li>
<li>创意产业：AI驱动的艺术创作</li>
</ul>
</li>
<li>
<p><strong>产业生态构建</strong>：</p>
<ul>
<li>开源模型与工具链完善</li>
<li>多模态数据集建设</li>
<li>标准化评估基准建立</li>
</ul>
</li>
</ol>
<h2 data-id="heading-33">结论</h2>
<p>智源Emu3登上Nature封面，不仅是中国AI科研的里程碑，更是多模态学习领域的技术范式革命。通过将“预测下一个词元”推广到多模态领域，Emu3实现了前所未有的架构简洁性和性能优越性，为构建统一、可扩展的智能系统奠定了技术基础。</p>
<p>随着Emu3及其后续版本的技术演进，以及prompt-minder.com等工具平台对多模态Prompt工程的支持完善，我们正在见证从“专模专用”到“统一智能”的AI发展新阶段。这不仅是技术的进步，更是AI赋能千行百业、推动社会数字化转型的关键力量。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[pgadmin的导出图实现，还在搞先美容后拍照再恢复？]]></title>    <link>https://juejin.cn/post/7603895839557550143</link>    <guid>https://juejin.cn/post/7603895839557550143</guid>    <pubDate>2026-02-09T03:20:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603895839557550143" data-draft-id="7603895839557517375" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="pgadmin的导出图实现，还在搞先美容后拍照再恢复？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:20:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lyrieek"/> <meta itemprop="url" content="https://juejin.cn/user/1398234521275102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            pgadmin的导出图实现，还在搞先美容后拍照再恢复？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1398234521275102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lyrieek
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:20:26.000Z" title="Mon Feb 09 2026 03:20:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>PostgreSQL18的pgadmin中有一个<code>ERDTool.jsx</code>有1132行，这个体量理论上说非常庞大，但做过现实工程的都知道，其实只能算重组件中的mini尺寸了。pgadmin功能并不算有多丰富，怎么还是做成这样呢，当然不是维护团队不会拆分，毕竟还是做了199个jsx的。</p>
<p>首先映入眼帘的是<code>registerEvents</code>对19个<code>EventBus</code>的监听，这东西让人倒吸一口凉气，其中最醒目的莫过于<code>this.eventBus.registerListener(ERD_EVENTS.DOWNLOAD_IMAGE, this.onImageClick)</code>，名字就不对劲，实现能如何呢？那么看一下这个<code>onImageClick()</code>：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">onImageClick</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLoading</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Preparing the image...'</span>));

    <span class="hljs-comment">/* Move the diagram temporarily to align it to top-left of the canvas so that when
     * taking the snapshot all the nodes are covered. Once the image is taken, repaint
     * the canvas back to original state.
     * Code referred from - zoomToFitNodes function.
     */</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagramContainerRef</span>.<span class="hljs-property">current</span>?.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'ERDTool-html2canvasReset'</span>);
    <span class="hljs-keyword">const</span> margin = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> nodesRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getEngine</span>().<span class="hljs-title function_">getBoundingNodesRect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getNodes</span>());
    <span class="hljs-keyword">let</span> linksRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getBoundingLinksRect</span>();

    <span class="hljs-comment">// Check what is to the most top left - links or nodes?</span>
    <span class="hljs-keyword">let</span> topLeftXY = {
      <span class="hljs-attr">x</span>: nodesRect.<span class="hljs-title function_">getTopLeft</span>().<span class="hljs-property">x</span>,
      <span class="hljs-attr">y</span>: nodesRect.<span class="hljs-title function_">getTopLeft</span>().<span class="hljs-property">y</span>
    };
    <span class="hljs-keyword">if</span>(topLeftXY.<span class="hljs-property">x</span> &gt; linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">x</span>) {
      topLeftXY.<span class="hljs-property">x</span> = linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">x</span>;
    }
    <span class="hljs-keyword">if</span>(topLeftXY.<span class="hljs-property">y</span> &gt; linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">y</span>) {
      topLeftXY.<span class="hljs-property">y</span> = linksRect.<span class="hljs-property">TL</span>.<span class="hljs-property">y</span>;
    }
    topLeftXY.<span class="hljs-property">x</span> -= margin;
    topLeftXY.<span class="hljs-property">y</span> -= margin;

    <span class="hljs-keyword">let</span> canvasRect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-title function_">getBoundingClientRect</span>();
    <span class="hljs-keyword">let</span> canvasTopLeftOnScreen = {
      <span class="hljs-attr">x</span>: canvasRect.<span class="hljs-property">left</span>,
      <span class="hljs-attr">y</span>: canvasRect.<span class="hljs-property">top</span>
    };
    <span class="hljs-keyword">let</span> nodeLayerTopLeftPoint = {
      <span class="hljs-attr">x</span>: canvasTopLeftOnScreen.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getOffsetX</span>(),
      <span class="hljs-attr">y</span>: canvasTopLeftOnScreen.<span class="hljs-property">y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagram</span>.<span class="hljs-title function_">getModel</span>().<span class="hljs-title function_">getOffsetY</span>()
    };
    <span class="hljs-keyword">let</span> nodesRectTopLeftPoint = {
      <span class="hljs-attr">x</span>: nodeLayerTopLeftPoint.<span class="hljs-property">x</span> + topLeftXY.<span class="hljs-property">x</span>,
      <span class="hljs-attr">y</span>: nodeLayerTopLeftPoint.<span class="hljs-property">y</span> + topLeftXY.<span class="hljs-property">y</span>
    };

    <span class="hljs-keyword">let</span> prevTransform = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">transform</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>)=&gt;</span>{
      ele.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">${nodeLayerTopLeftPoint.x - nodesRectTopLeftPoint.x}</span>px, <span class="hljs-subst">${nodeLayerTopLeftPoint.y - nodesRectTopLeftPoint.y}</span>px) scale(1.0)`</span>;
    });

    <span class="hljs-comment">// Capture the links beyond the nodes as well.</span>
    <span class="hljs-keyword">const</span> linkOutsideWidth = linksRect.<span class="hljs-property">BR</span>.<span class="hljs-property">x</span> - nodesRect.<span class="hljs-title function_">getBottomRight</span>().<span class="hljs-property">x</span>;
    <span class="hljs-keyword">const</span> linkOutsideHeight = linksRect.<span class="hljs-property">BR</span>.<span class="hljs-property">y</span> - nodesRect.<span class="hljs-title function_">getBottomRight</span>().<span class="hljs-property">y</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollWidth</span> + (linkOutsideWidth &gt; <span class="hljs-number">0</span> ? linkOutsideWidth : <span class="hljs-number">0</span>) + margin + <span class="hljs-string">'px'</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollHeight</span> + (linkOutsideHeight &gt; <span class="hljs-number">0</span> ? linkOutsideHeight : <span class="hljs-number">0</span>) + margin + <span class="hljs-string">'px'</span>;

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>{
      <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollWidth</span> + <span class="hljs-number">10</span>;
      <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">scrollHeight</span> + <span class="hljs-number">10</span>;
      <span class="hljs-keyword">let</span> isCut = <span class="hljs-literal">false</span>;
      <span class="hljs-comment">/* Canvas limitation - https://html2canvas.hertzen.com/faq */</span>
      <span class="hljs-keyword">if</span>(width &gt;= <span class="hljs-number">32767</span>){
        width = <span class="hljs-number">32766</span>;
        isCut = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span>(height &gt;= <span class="hljs-number">32767</span>){
        height = <span class="hljs-number">32766</span>;
        isCut = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-title function_">toPng</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>, {width, height, <span class="hljs-attr">pixelRatio</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">preferences</span>.<span class="hljs-property">image_pixel_ratio</span> || <span class="hljs-number">1</span>})
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dataUrl</span>)=&gt;</span>{
          <span class="hljs-title class_">DownloadUtils</span>.<span class="hljs-title function_">downloadBase64UrlData</span>(dataUrl, <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getCurrentProjectName()}</span>.png`</span>);
        }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>{
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
          <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Unknown error. Check console logs'</span>);
          <span class="hljs-keyword">if</span>(err.<span class="hljs-property">name</span>) {
            msg = <span class="hljs-string">`<span class="hljs-subst">${err.name}</span>: <span class="hljs-subst">${err.message}</span>`</span>;
          }
          pgAdmin.<span class="hljs-property">Browser</span>.<span class="hljs-property">notifier</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Error'</span>), msg);
        }).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>{
          <span class="hljs-comment">/* Revert back to the original CSS styles */</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagramContainerRef</span>.<span class="hljs-property">current</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'ERDTool-html2canvasReset'</span>);
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">''</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">''</span>;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasEle</span>.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>)=&gt;</span>{
            ele.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = prevTransform;
          });
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span>(isCut) {
            pgAdmin.<span class="hljs-property">Browser</span>.<span class="hljs-property">notifier</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">gettext</span>(<span class="hljs-string">'Maximum image size limit'</span>),
              <span class="hljs-title function_">gettext</span>(<span class="hljs-string">'The downloaded image has exceeded the maximum size of 32767 x 32767 pixels, and has been cropped to that size.'</span>));
          }
        });
    }, <span class="hljs-number">1000</span>);
  }
</code></pre>
<p>这种百行级函数，存在合理性且不论，无论如何它都不应该叫xxClick了，毕竟谁敢相信它所有的代码都是为了完成一个导出png功能？</p>
<p>当然只笼统的说它完成了「一个功能」，那也是委屈它了，这函数实质上究竟做了什么？</p>
<ul>
<li>状态管理： setLoading。</li>
<li>DOM 劫持： 直接操作样式和类名。</li>
<li>复杂的几何计算： 处理包围盒（Bounding Box）。</li>
<li>IO 操作： 生成图片并触发下载。</li>
<li>异常处理： 恢复状态弹出 notifier 警告。</li>
</ul>
<p>每一项都是焦点，如果换成Java，这段代码还能再套上10个trycatch膨胀到500行，当然如果换成Java必然能规矩许多，不至于如此粗糙。</p>
<p>当然这函数远不止违法单一原则那么简单，几何计算中 margin = 10 和屏幕坐标转换逻辑非常硬核且粗糙，几乎宣判了这块UI已经不可更改了，同时否定了缩放/偏移变化，非常容易出 off-by-one 错误，已经消耗极大了，不想做复杂只想简单实现也可以克隆DOM做一个离屏渲染，还不需要关心什么margin偏移。</p>
<p><code>toPng</code>还是<code>html-to-image</code>的，这种场景用这个本身就如同儿戏，而且既然都做这么复杂了，哪怕直接再补上一套原生代码，手动绘制，全丢这函数里，不用任何库，这段代码也不会更丑了。</p>
<p>检测到图片到了浏览器 canvas 限制，就直接剪裁+警告，不做一个执行前popup确认和zoom，可以说有些不可理喻了，现实中这个警告几乎不可能弹出来，因为符合的这个逻辑时，其占用的原始内存将达到惊人的 4GB，做这种巨型 DOM 树时UI会进行密集的像素计算。而且计算是同步的，会直接锁死浏览器主线程！程序早已卡死，一行代码都别想执行了。</p>
<p>还有<code>setTimeout</code>为什么 1000ms？为什么不是 500 或 2000？这是典型的“等它渲染完”的 hack，因为修改 transform / width/height 后，浏览器需要时间重排/重绘，<code>html2canvas</code>才能捕获正确内容。用<code>requestAnimationFrame </code>循环检查或<code>MutationObserver</code> / <code>ResizeObserver</code>来检测实际变化完成不好么？</p>
<p>最后还是回到名字上，一个函数如果叫“xx点击”，它就没有资格去负责“计算并导出32767像素的位图”。</p>
<p>不过综合来说，这东西整体上也算勉强还行了，毕竟它是一个最终节点组件，而且基本上不太可能被依赖，只是功能性问题，不像它旁边那个1560行有15个useEffect的<code>ResultSet.jsx</code>，那都不能叫组件了，那是试图给React塞一个子系统，等PostgreSQL20发布，估计就没人敢改它了。还有用1300行的<code>FormInput.tsx</code>管理着FormIcon、StyledGrid、FormInput、InputSQL、FormInputSQL等子组件的超级组件，这几乎是想做一套扩展UI库。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[「九九八十一难」第一难：前端数据mock指南（TS + VUE）]]></title>    <link>https://juejin.cn/post/7604084016510631977</link>    <guid>https://juejin.cn/post/7604084016510631977</guid>    <pubDate>2026-02-09T03:58:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510631977" data-draft-id="7604155045235785763" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="「九九八十一难」第一难：前端数据mock指南（TS + VUE）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:58:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="从文处安"/> <meta itemprop="url" content="https://juejin.cn/user/1315432730731224"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            「九九八十一难」第一难：前端数据mock指南（TS + VUE）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1315432730731224/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    从文处安
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:58:41.000Z" title="Mon Feb 09 2026 03:58:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vue3 + TypeScript 项目中使用 Mock 数据指南</h2>
<h3 data-id="heading-1">背景</h3>
<p>产品：这里有个需求，计划月底上线，你们评估下开发时间，保证月底能上线现网。</p>
<p>测试：我需要一周的测试时间，包括功能测试、性能测试、兼容性测试等。</p>
<p>UI：我需要一周时间，包括页面布局、交互设计、颜色方案等。</p>
<p>后端：我需要两周时间，包括数据库设计、接口开发、业务逻辑实现等。</p>
<p>前端：我走？</p>
<p>产品：你想想办法。</p>
<p>前端：我可以牺牲自己的开发时间，通过接口mock来并行开发，需要后端提前提供接口文档，我同步进行页面开发和逻辑实现。</p>
<p>为了需求正常上线，无私的前端又为自己找了个加班的机会。</p>
<h3 data-id="heading-2">前言</h3>
<p>在前端开发过程中，我们经常会遇到后端接口尚未完成，但前端需要提前开发页面和功能的情况。
这时，使用 Mock 数据就成为了一种非常有效的解决方案。
本文将介绍如何在 Vue3 + TypeScript 项目中搭建和使用 Mock 数据。</p>
<h3 data-id="heading-3">什么是 Mock 数据</h3>
<h4 data-id="heading-4">概念</h4>
<p>Mock 数据是指在开发过程中，为了模拟后端接口返回的数据，而创建的虚假数据。</p>
<h4 data-id="heading-5">作用</h4>
<ol>
<li>
<p><strong>并行开发</strong>：前端可以与后端同时开发，不需要等待后端接口完成</p>
</li>
<li>
<p><strong>独立测试</strong>：可以模拟各种边界情况和错误场景</p>
</li>
<li>
<p><strong>性能测试</strong>：可以模拟大量数据，测试前端性能</p>
</li>
<li>
<p><strong>演示效果</strong>：在没有后端服务的情况下，也能展示完整的功能</p>
</li>
</ol>
<h4 data-id="heading-6">优势</h4>
<ol>
<li>
<p><strong>提高开发效率</strong>：减少等待后端接口的时间</p>
</li>
<li>
<p><strong>增强代码健壮性</strong>：可以测试各种异常情况</p>
</li>
<li>
<p><strong>改善团队协作</strong>：明确接口规范，减少沟通成本</p>
</li>
<li>
<p><strong>简化测试流程</strong>：可以快速模拟各种场景</p>
</li>
</ol>
<h3 data-id="heading-7">环境搭建</h3>
<h4 data-id="heading-8">安装依赖</h4>
<p>在 Vue3 + TypeScript 项目中，需要安装以下依赖：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 mockjs 库</span>
npm install mockjs --save-dev

<span class="hljs-comment"># 安装 vite-plugin-mock 插件</span>
npm install vite-plugin-mock --save-dev

<span class="hljs-comment"># 安装 @types/mockjs 类型定义（可选但推荐）</span>
npm install --save-dev @types/mockjs
</code></pre>
<h4 data-id="heading-9">配置 Vite</h4>
<p>在 <code>vite.config.ts</code> 文件中配置 <code>vite-plugin-mock</code> 插件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-vue"</span>;
<span class="hljs-keyword">import</span> { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { viteMockServe } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">vue</span>(),
    <span class="hljs-title function_">viteMockServe</span>({
      <span class="hljs-comment">// mock 文件存放路径</span>
      <span class="hljs-attr">mockPath</span>: <span class="hljs-string">"./mock"</span>,
      <span class="hljs-comment">// 启用 mock 功能</span>
      <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-comment">// 显示请求日志</span>
      <span class="hljs-attr">logger</span>: <span class="hljs-literal">true</span>,
    }),
  ],
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">"@"</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),
    },
  },
});
</code></pre>
<h4 data-id="heading-10">配置 TypeScript</h4>
<p>在 <code>tsconfig.app.json</code> 文件中配置路径别名，确保 TypeScript 能够正确解析 <code>@/</code> 路径：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@vue/tsconfig/tsconfig.dom.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tsBuildInfoFile"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./node_modules/.tmp/tsconfig.app.tsbuildinfo"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/*"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-comment">/* Linting */</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedLocals"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedParameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noFallthroughCasesInSwitch"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUncheckedSideEffectImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.tsx"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.vue"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-11">配置 Mock 数据</h3>
<h4 data-id="heading-12">快速开始 - 最简单的用例</h4>
<p>模拟第一个简单接口</p>
<h5 data-id="heading-13">第一步：创建最简单的 Mock 接口</h5>
<p>在 <code>mock</code> 文件夹下创建一个简单的 <code>hello.ts</code> 文件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/hello.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/hello"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: <span class="hljs-string">"Hello, Mock!"</span>,
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h5 data-id="heading-14">第二步：在组件中调用</h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{{ message }}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue";
import axios from "axios";

const message = ref("");

onMounted(async () =&gt; {
  try {
    const response = await axios.get("/api/hello");
    message.value = response.data.data;
  } catch (error) {
    console.error("请求失败:", error);
  }
});
&lt;/script&gt;
</code></pre>
<p><strong>运行结果</strong>：页面显示 "Hello, Mock!"</p>
<hr/>
<h4 data-id="heading-15">中级用例 - 简单数据列表</h4>
<p>这个用例展示如何返回一个简单的数据列表。</p>
<h5 data-id="heading-16">创建 Mock 接口</h5>
<p>在 <code>mock</code> 文件夹下创建 <code>products.ts</code> 文件：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/products.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/products"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: [
          { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品1"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">99</span> },
          { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品2"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">199</span> },
          { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"商品3"</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">299</span> },
        ],
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h5 data-id="heading-17">在组件中调用</h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;商品列表&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="product in products" :key="product.id"&gt;
        {{ product.name }} - ¥{{ product.price }}
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted } from "vue";
import axios from "axios";

interface Product {
  id: number;
  name: string;
  price: number;
}

const products = ref&lt;Product[]&gt;([]);

onMounted(async () =&gt; {
  try {
    const response = await axios.get("/api/products");
    products.value = response.data.data;
  } catch (error) {
    console.error("获取商品列表失败:", error);
  }
});
&lt;/script&gt;
</code></pre>
<p><strong>运行结果</strong>：页面显示商品列表，包含3个商品的信息。</p>
<hr/>
<h4 data-id="heading-18">进阶用例 - 用户数据管理</h4>
<p>接下来，我们创建一个更完整的贴合业务场景的用例。</p>
<h5 data-id="heading-19">创建 Mock 文件</h5>
<p>创建一个 <code>user.ts</code> 文件来模拟用户相关的接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// mock/user.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MockMethod</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite-plugin-mock"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/list"</span>, <span class="hljs-comment">// 接口路径</span>
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>, <span class="hljs-comment">// 请求方法</span>
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ query }: { query: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-comment">// 模拟分页数据</span>
      <span class="hljs-keyword">const</span> page = <span class="hljs-built_in">parseInt</span>(query.<span class="hljs-property">page</span>) || <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> limit = <span class="hljs-built_in">parseInt</span>(query.<span class="hljs-property">limit</span>) || <span class="hljs-number">10</span>;
      <span class="hljs-keyword">const</span> total = <span class="hljs-number">100</span>;

      <span class="hljs-comment">// 生成模拟数据</span>
      <span class="hljs-keyword">const</span> list = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; limit; i++) {
        <span class="hljs-keyword">const</span> index = (page - <span class="hljs-number">1</span>) * limit + i;
        <span class="hljs-keyword">if</span> (index &lt; total) {
          list.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">id</span>: index + <span class="hljs-number">1</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">`用户<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>`</span>,
            <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">30</span>) + <span class="hljs-number">18</span>,
            <span class="hljs-attr">email</span>: <span class="hljs-string">`user<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>@example.com`</span>,
            <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
          });
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          list,
          total,
          page,
          limit,
        },
      };
    },
  },
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/detail"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ query }: { query: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> id = query.<span class="hljs-property">id</span>;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          id,
          <span class="hljs-attr">name</span>: <span class="hljs-string">`用户<span class="hljs-subst">${id}</span>`</span>,
          <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">30</span>) + <span class="hljs-number">18</span>,
          <span class="hljs-attr">email</span>: <span class="hljs-string">`user<span class="hljs-subst">${id}</span>@example.com`</span>,
          <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),
          <span class="hljs-attr">address</span>: <span class="hljs-string">"北京市朝阳区"</span>,
          <span class="hljs-attr">phone</span>: <span class="hljs-string">"13800138000"</span>,
        },
      };
    },
  },
  {
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/api/user/create"</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">"post"</span>,
    <span class="hljs-attr">response</span>: <span class="hljs-function">(<span class="hljs-params">{ body }: { body: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; }</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"success"</span>,
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">id</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10000</span>),
          ...body,
        },
      };
    },
  },
] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MockMethod</span>[];
</code></pre>
<h3 data-id="heading-20">调用 Mock 数据</h3>
<p>mock数据的调用使用 <code>axios</code> 实现，本文暂不做过多覆盖。</p>
<h4 data-id="heading-21">创建 API 服务</h4>
<p>在 <code>src/api</code> 目录下创建 <code>user.ts</code> 文件，定义 API 调用函数：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/api/user.ts</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;

<span class="hljs-comment">/**
 * 获取用户列表
 * <span class="hljs-doctag">@param</span> params 分页参数
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = (<span class="hljs-params">params: { page: <span class="hljs-built_in">number</span>; limit: <span class="hljs-built_in">number</span> }</span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/user/list"</span>, { params });
};

<span class="hljs-comment">/**
 * 获取用户详情
 * <span class="hljs-doctag">@param</span> id 用户ID
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserDetail</span> = (<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/user/detail"</span>, { <span class="hljs-attr">params</span>: { id } });
};

<span class="hljs-comment">/**
 * 创建用户
 * <span class="hljs-doctag">@param</span> data 用户数据
 * <span class="hljs-doctag">@returns</span> Promise 响应数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createUser</span> = (<span class="hljs-params">data: {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
  email: <span class="hljs-built_in">string</span>;
}</span>) =&gt; {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/user/create"</span>, data);
};
</code></pre>
<h4 data-id="heading-22">在组件中使用</h4>
<p>在 Vue 组件中使用 API 服务调用 Mock 数据：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-list"&gt;
    &lt;h2&gt;用户列表&lt;/h2&gt;
    &lt;div v-if="loading"&gt;加载中...&lt;/div&gt;
    &lt;div v-else&gt;
      &lt;ul&gt;
        &lt;li v-for="user in userList" :key="user.id"&gt;
          {{ user.name }} - {{ user.age }}岁 - {{ user.email }}
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="pagination"&gt;
        &lt;button @click="changePage(1)" :disabled="currentPage === 1"&gt;
          首页
        &lt;/button&gt;
        &lt;button
          @click="changePage(currentPage - 1)"
          :disabled="currentPage === 1"
        &gt;
          上一页
        &lt;/button&gt;
        &lt;span&gt;第 {{ currentPage }} 页，共 {{ totalPages }} 页&lt;/span&gt;
        &lt;button
          @click="changePage(currentPage + 1)"
          :disabled="currentPage === totalPages"
        &gt;
          下一页
        &lt;/button&gt;
        &lt;button
          @click="changePage(totalPages)"
          :disabled="currentPage === totalPages"
        &gt;
          末页
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, computed, onMounted } from "vue";
import { getUserList } from "@/api/user";

// 响应式数据
const userList = ref&lt;any[]&gt;([]);
const loading = ref(false);
const currentPage = ref(1);
const pageSize = ref(10);
const total = ref(0);

// 计算属性
const totalPages = computed(() =&gt; {
  return Math.ceil(total.value / pageSize.value);
});

/**
 * 获取用户列表数据
 */
const fetchUserList = async () =&gt; {
  loading.value = true;
  try {
    const response = await getUserList({
      page: currentPage.value,
      limit: pageSize.value,
    });
    userList.value = response.data.data.list;
    total.value = response.data.data.total;
  } catch (error) {
    console.error("获取用户列表失败:", error);
  } finally {
    loading.value = false;
  }
};

/**
 * 切换页码
 * @param page 页码
 */
const changePage = (page: number) =&gt; {
  currentPage.value = page;
  fetchUserList();
};

// 组件挂载时获取数据
onMounted(() =&gt; {
  fetchUserList();
});
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-23">常见用例和最佳实践</h3>
<h4 data-id="heading-24">常见用例</h4>
<ol>
<li>
<p><strong>分页数据</strong>：模拟带分页的列表数据</p>
</li>
<li>
<p><strong>详情数据</strong>：模拟单个资源的详细信息</p>
</li>
<li>
<p><strong>表单提交</strong>：模拟创建、更新操作</p>
</li>
<li>
<p><strong>错误场景</strong>：模拟各种错误状态码和错误信息</p>
</li>
<li>
<p><strong>文件上传</strong>：模拟文件上传接口</p>
</li>
</ol>
<h4 data-id="heading-25">最佳实践</h4>
<ol>
<li>
<p><strong>目录结构清晰</strong>：按模块组织 mock 文件</p>
</li>
<li>
<p><strong>数据结构一致</strong>：与后端接口保持一致的数据结构</p>
</li>
<li>
<p><strong>模拟真实场景</strong>：包括正常、异常、边界等各种场景</p>
</li>
<li>
<p><strong>使用 TypeScript</strong>：为 mock 数据添加类型定义</p>
</li>
<li>
<p><strong>注释完善</strong>：为复杂的 mock 逻辑添加注释</p>
</li>
<li>
<p><strong>定期更新</strong>：根据后端接口变化及时更新 mock 数据</p>
</li>
</ol>
<h3 data-id="heading-26">故障排除提示</h3>
<ol>
<li><strong>mock 数据不生效</strong></li>
</ol>
<ul>
<li>
<p>检查 <code>vite.config.ts</code> 中的 <code>mockPath</code> 配置是否正确</p>
</li>
<li>
<p>检查 mock 文件是否在正确的目录下</p>
</li>
<li>
<p>检查接口路径是否匹配</p>
</li>
</ul>
<ol start="2">
<li><strong>TypeScript 类型错误</strong></li>
</ol>
<ul>
<li>
<p>确保安装了 <code>@types/mockjs</code> 类型定义</p>
</li>
<li>
<p>为 mock 数据添加正确的类型注解</p>
</li>
</ul>
<ol start="3">
<li><strong>生产环境泄露</strong></li>
</ol>
<ul>
<li>确保在生产环境中禁用 mock 功能</li>
</ul>
<ol start="4">
<li><strong>性能问题</strong></li>
</ol>
<ul>
<li>
<p>避免在 mock 函数中执行复杂的计算</p>
</li>
<li>
<p>对于大量数据，考虑使用分页或虚拟滚动</p>
</li>
</ul>
<h3 data-id="heading-27">常见问题</h3>
<h4 data-id="heading-28">1. 路径别名问题</h4>
<p><strong>问题</strong>：找不到模块 "@/api/user" 或其相应的类型声明。</p>
<p><strong>原因</strong>：虽然在 <code>vite.config.ts</code> 中配置了路径别名，但在 <code>tsconfig.app.json</code> 中没有配置相应的 <code>paths</code>。</p>
<p><strong>解决方案</strong>：在 <code>tsconfig.app.json</code> 中添加 <code>paths</code> 配置：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-comment">// ... 其他配置</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"@/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/*"</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-29">2. 接口实现不完整</h4>
<p><strong>问题</strong>：调用某个 API 函数时返回 404 错误。</p>
<p><strong>原因</strong>：在 mock 文件中没有实现对应的接口。</p>
<p><strong>解决方案</strong>：确保所有 API 调用都有对应的 mock 接口实现。</p>
<h4 data-id="heading-30">3. 类型定义缺失</h4>
<p><strong>问题</strong>：使用 mockjs 时缺少类型定义。</p>
<p><strong>原因</strong>：没有安装 <code>@types/mockjs</code> 类型定义文件。</p>
<p><strong>解决方案</strong>：安装类型定义文件：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev @types/mockjs
</code></pre>
<h3 data-id="heading-31">替代方案比较</h3>
<h4 data-id="heading-32">Mock.js vs JSON Server</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：专注于数据模拟，功能强大，支持各种数据类型和随机数据生成</p>
</li>
<li>
<p><strong>JSON Server</strong>：快速创建 RESTful API，基于 JSON 文件，适合简单场景</p>
</li>
</ul>
<h4 data-id="heading-33">Mock.js vs MSW (Mock Service Worker)</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：在构建工具层面拦截请求，配置简单</p>
</li>
<li>
<p><strong>MSW</strong>：在浏览器层面拦截请求，支持 Service Worker，更接近真实网络请求</p>
</li>
</ul>
<h4 data-id="heading-34">Mock.js vs 手写本地存储</h4>
<ul>
<li>
<p><strong>Mock.js</strong>：功能完整，支持各种 HTTP 方法和场景</p>
</li>
<li>
<p><strong>手写本地存储</strong>：简单直接，适合非常简单的场景</p>
</li>
</ul>
<h3 data-id="heading-35">注意事项</h3>
<ol>
<li>
<p><strong>环境隔离</strong>：确保 mock 功能只在开发和测试环境启用</p>
</li>
<li>
<p><strong>数据安全</strong>：不要在 mock 数据中使用真实的敏感信息</p>
</li>
<li>
<p><strong>接口一致性</strong>：与后端保持接口规范一致，避免后期大量修改</p>
</li>
<li>
<p><strong>代码管理</strong>：将 mock 相关代码与业务代码分离，便于维护</p>
</li>
<li>
<p><strong>性能考虑</strong>：避免生成过多数据，影响前端性能</p>
</li>
<li>
<p><strong>测试覆盖</strong>：确保真实接口对接后，进行完整的回归测试</p>
</li>
</ol>
<h3 data-id="heading-36">总结</h3>
<p>Mock 数据是前端开发中的重要工具，它可以帮助我们提高开发效率，增强代码健壮性，改善团队协作。</p>
<p><code>「九九八十一难，难难皆是修行」</code></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。]]></title>    <link>https://juejin.cn/post/7604155045235916835</link>    <guid>https://juejin.cn/post/7604155045235916835</guid>    <pubDate>2026-02-09T04:30:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604155045235916835" data-draft-id="7603895839557632063" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。"/> <meta itemprop="keywords" content="Vue.js,Vuex"/> <meta itemprop="datePublished" content="2026-02-09T04:30:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小书包酱"/> <meta itemprop="url" content="https://juejin.cn/user/184373685008184"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在 VS Code中，vue2-vuex 使用终于有体验感增强的插件了。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/184373685008184/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小书包酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:30:36.000Z" title="Mon Feb 09 2026 04:30:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    12
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Vuex Helper</h2>
<p>适用于 Vuex 2 的 VS Code 插件，提供 <strong>跳转定义</strong>、<strong>代码补全</strong> 和 <strong>悬浮提示</strong> 功能。支持 State, Getters, Mutations 和 Actions。</p>
<h3 data-id="heading-1">引言</h3>
<blockquote>
<p>在 AI 时代，为什么要搞一个老掉牙的 vue2 的 vuex 增强插件？可以想象，现在起步应该都会是 vue3 或者 react 的框架。但<strong>老项目永远不会少</strong>，除非下定决心去重构，否则永远都要面对老项目，那在vscode中，遇到 vue2 项目的调试过程中，vuex 的跳转定义永远是我开发与迭代时遇到的痛点，AI 给了我机会，让我无需在繁重的业务需求之外，额外耗费太多的时间去学习插件怎么使用，而直接上手去把我的思路交予实现。感谢 AI，让我有能力去完成一些平时不可及的小事情。</p>
</blockquote>
<h3 data-id="heading-2">功能特性</h3>
<h4 data-id="heading-3">1. 跳转定义 (Go to Definition)</h4>
<p>从组件中直接跳转到 Vuex Store 的定义处。</p>
<h5 data-id="heading-4">演示：跳转定义</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c773c66a7ac144429996aeaf36c1bcc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=TjRG%2FP7%2FxyFiKuoanfXYjxx%2Bq0g%3D" alt="jump_definition.gif" loading="lazy"/></p>
<ul>
<li><strong>支持</strong>: <code>this.$store.state/getters/commit/dispatch</code></li>
<li><strong>Map 辅助函数</strong>: <code>mapState</code>, <code>mapGetters</code>, <code>mapMutations</code>, <code>mapActions</code></li>
<li><strong>命名空间</strong>: 完美支持 Namespaced 模块及其嵌套。</li>
</ul>
<h4 data-id="heading-5">2. 智能代码补全 (Intelligent Code Completion)</h4>
<p>智能提示 Vuex 的各种 Key 以及组件中映射的方法。</p>
<h5 data-id="heading-6">演示：智能补全</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/753860d9860c41828bfd55b71ee0da06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=pi7kabadmE51E1ABFAjaqguO6NE%3D" alt="auto_tips_and_complete_for_var.gif" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8bf012de79ba4fab8dcbbb577a6f5860~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=fiSB5wta6aeWCaqQq5wEdePzg%2Fk%3D" alt="auto_tips_and_complete_for_func.gif" loading="lazy"/></p>
<ul>
<li><strong>上下文感知</strong>: 在 <code>dispatch</code> 中提示 Actions，在 <code>commit</code> 中提示 Mutations。</li>
<li><strong>命名空间过滤</strong>: 当使用 <code>mapState('user', [...])</code> 时，会自动过滤并仅显示 <code>user</code> 模块下的内容。</li>
<li><strong>组件映射方法</strong>: 输入 <code>this.</code> 即可提示映射的方法（例如 <code>this.increment</code> 映射自 <code>...mapMutations(['increment'])</code>）。</li>
<li><strong>语法支持</strong>: 支持数组语法和对象别名语法 (例如 <code>...mapActions({ alias: 'name' })</code>)。</li>
</ul>
<h4 data-id="heading-7">3. 悬浮提示与类型推导 (Hover Information &amp; Type Inference)</h4>
<p>无需跳转即可查看文档、类型详情。</p>
<h5 data-id="heading-8">演示：悬浮文档</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/659696bacfd64f7096fae1dc5173a563~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=meaY9dItS9ORHJp0D5F4F6twjdo%3D" alt="hover_info_and_type_inference.gif" loading="lazy"/></p>
<ul>
<li><strong>JSDoc 支持</strong>: 提取并显示 Store 定义处的 <code>/** ... */</code> 注释文档。</li>
<li><strong>State 类型</strong>: 在悬浮提示中自动推导并显示 State 属性的类型 (例如 <code>(State) appName: string</code>)。</li>
<li><strong>详细信息</strong>: 显示类型（State/Mutation等）及定义所在的文件路径。</li>
<li><strong>映射方法</strong>: 支持查看映射方法的 Store 文档。</li>
</ul>
<h4 data-id="heading-9">4. Store 内部调用 (Store Internal Usage)</h4>
<p>同样支持在 Vuex Store 内部 代码补全、跳转、悬浮提示。</p>
<h5 data-id="heading-10">演示：Store 内部 代码补全、跳转、悬浮提示</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8315d95ba2294d3aa57b071111876b75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5Lmm5YyF6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771216236&amp;x-signature=%2Fx5CjrkrjGrPW7N32MwLSN3FFJo%3D" alt="internal_usage.gif" loading="lazy"/></p>
<ul>
<li><strong>模块作用域</strong>: 当在模块文件（如 <code>user.js</code>）中编写 Action 时，<code>commit</code> 和 <code>dispatch</code> 的代码补全会自动过滤并仅显示当前模块的内容。</li>
</ul>
<p>同样支持在 Vuex Store 内部 代码补全、跳转、悬浮提示。</p>
<h3 data-id="heading-11">支持的语法示例</h3>
<ul>
<li><strong>辅助函数 (Helpers)</strong>:
<pre><code class="hljs language-javascript" lang="javascript">...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">'count'</span>])
...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">'user'</span>, [<span class="hljs-string">'name'</span>]) <span class="hljs-comment">// 命名空间支持</span>
...<span class="hljs-title function_">mapActions</span>({ <span class="hljs-attr">add</span>: <span class="hljs-string">'increment'</span> }) <span class="hljs-comment">// 对象别名支持</span>
...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">'add/increment'</span>])
</code></pre>
</li>
<li><strong>Store 方法</strong>:
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">"SET_NAME"</span>, value);
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"user/updateName"</span>, value);
</code></pre>
</li>
<li><strong>组件方法</strong>:
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 映射自 mapMutations</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">appName</span>; <span class="hljs-comment">// 映射自 mapState</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-12">使用要求</h3>
<ul>
<li>使用 Vuex 的 Vue 2 项目。</li>
<li>Store 入口位于 <code>src/store/index.js</code> 或 <code>src/store/index.ts</code>（支持自动探测）。</li>
<li>若无法自动找到，请在设置中配置 <code>vuexHelper.storeEntry</code>。</li>
</ul>
<h3 data-id="heading-13">配置项</h3>
<ul>
<li><code>vuexHelper.storeEntry</code>: 手动指定 Store 入口文件路径。支持：
<ul>
<li>别名路径: <code>@/store/index.js</code> (需在 jsconfig/tsconfig 中配置)</li>
<li>相对路径: <code>src/store/index.js</code></li>
<li>绝对路径: <code>/User/xxx/project/src/store/index.js</code></li>
</ul>
</li>
</ul>
<h3 data-id="heading-14">更新日志</h3>
<h4 data-id="heading-15">0.0.1</h4>
<p>初始版本，支持功能：</p>
<ul>
<li>全面支持 State, Getters, Mutations, Actions</li>
<li>支持命名空间过滤 (Namespace Filtering)</li>
<li>支持 JSDoc 悬浮文档显示</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从页面加载过程看 Kuikly 的多线程架构]]></title>    <link>https://juejin.cn/post/7603958579180486656</link>    <guid>https://juejin.cn/post/7603958579180486656</guid>    <pubDate>2026-02-09T04:28:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180486656" data-draft-id="7604155045235900451" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从页面加载过程看 Kuikly 的多线程架构"/> <meta itemprop="keywords" content="Kotlin"/> <meta itemprop="datePublished" content="2026-02-09T04:28:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我有与与症"/> <meta itemprop="url" content="https://juejin.cn/user/4466629837071787"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从页面加载过程看 Kuikly 的多线程架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4466629837071787/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我有与与症
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:28:04.000Z" title="Mon Feb 09 2026 04:28:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文适合 Kotlin/Kuikly 初学者阅读。我们不做泛泛而谈，而是以"一个页面是怎么被加载出来的"这条主线为脉络，一步一步跟踪源码，彻底弄清 Kuikly 的双线程模型是什么、为什么这么设计、以及它如何保证高性能和线程安全。</p>
</blockquote>
<h2 data-id="heading-0">1. 为什么需要双线程？</h2>
<p>在理解 Kuikly 的多线程模型之前，我们先想一个问题：<strong>如果把所有事情都放在主线程做，会怎样？</strong></p>
<p>一个 UI 框架需要做两大类事情：</p>




















<table><thead><tr><th>类别</th><th>具体工作</th><th>耗时特征</th></tr></thead><tbody><tr><td><strong>逻辑计算</strong></td><td>执行业务代码、构建虚拟视图树、计算 Flexbox 布局、处理响应式更新</td><td>CPU 密集</td></tr><tr><td><strong>原生渲染</strong></td><td>创建平台 View、设置属性、设置 frame、插入视图层级</td><td>必须在 UI 线程</td></tr></tbody></table>
<p>如果全放主线程，逻辑计算会阻塞 UI 渲染，用户看到的就是"卡"。React Native 很早就采用了类似的双线程方案——JS 线程做逻辑，主线程做渲染。Kuikly 的思路一脉相承：</p>
<blockquote>
<p><strong>Context 线程</strong>（也叫 Kuikly 线程）：运行 Kotlin 业务逻辑、DSL 构建、布局计算<br/>
<strong>Main 线程</strong>（UI 线程）：执行原生 View 的创建、属性设置、帧布局</p>
</blockquote>
<p>这种分工带来三个核心优势：</p>
<ol>
<li><strong>不卡主线程</strong>：无论你的业务逻辑多复杂，用户的滑动、点击永远流畅</li>
<li><strong>批量上屏</strong>：Context 线程产生的 UI 指令可以攒一批再一次性提交给主线程，减少线程切换开销</li>
<li><strong>架构清晰</strong>：Kotlin 侧完全不需要关心线程问题，因为它永远运行在同一条线程上</li>
</ol>
<hr/>
<h2 data-id="heading-1">2. 两条线程各自负责什么</h2>
<p>让我们用一张表格来明确两条线程的职责边界：</p>
<pre><code class="hljs language-sql" lang="sql">┌─────────────────────────────────────────────────────────────┐
│                    Context 线程 (Kuikly 线程)                 │
│                                                              │
│  ✦ Kotlin 业务代码执行                                         │
│  ✦ Pager 生命周期（willInit → didInit → body → createBody）    │
│  ✦ DSL 构建（attr{} <span class="hljs-operator">/</span> event{} 块的执行）                       │
│  ✦ Flexbox 布局计算（flexNode.calculateLayout）                │
│  ✦ 响应式系统（observable 变化 → 重新执行绑定块）                  │
│  ✦ 协程调度（setTimeout、LifecycleScope）                      │
│  ✦ <span class="hljs-keyword">Module</span> 调用的发起端                                         │
│                                                              │
│  产出：一系列"UI 指令"（创建 <span class="hljs-keyword">View</span>、设属性、设 Frame……）           │
│       通过 BridgeManager.callNativeMethod() 发送给 Native 侧  │
└──────────────────────┬──────────────────────────────────────┘
                       │ UI 指令
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    Main 线程 (UI 线程)                        │
│                                                              │
│  ✦ 接收 UI 指令并批量执行                                       │
│  ✦ 创建原生 <span class="hljs-keyword">View</span>（TextView、ImageView……）                      │
│  ✦ 设置 <span class="hljs-keyword">View</span> 属性（背景色、字体、圆角……）                        │
│  ✦ 设置 <span class="hljs-keyword">View</span> Frame（位置和大小）                                │
│  ✦ 插入 <span class="hljs-keyword">View</span> 到父视图                                          │
│  ✦ 事件触发后通知 Context 线程                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<hr/>
<h2 data-id="heading-2">3. 完整的页面加载时序</h2>
<p>在深入每一步之前，先看完整的时序图，对全局有个概念：</p>
<pre><code class="hljs language-scss" lang="scss">时间轴 ──────────────────────────────────────────────────────────→

<span class="hljs-selector-tag">Main</span> 线程    Context 线程    说明
    │              │
    │ <span class="hljs-built_in">init</span>()       │         ① 用户调用 KuiklyRenderView<span class="hljs-selector-class">.init</span>()
    │──schedule──→│         ② 切换到 Context 线程
    │              │
    │         <span class="hljs-built_in">initContext</span>()  ③ 加载 Kotlin 引擎、创建 NativeBridge
    │              │
    │        callKotlinMethod  ④ 调用 CREATE_INSTANCE
    │          (CREATE_INSTANCE)
    │              │
    │         PagerManager     ⑤ 通过页面注册表找到 creator
    │          <span class="hljs-selector-class">.createPager</span>()
    │              │
    │         pager<span class="hljs-selector-class">.onCreatePager</span>()  ⑥ Pager 生命周期开始
    │           ├─ <span class="hljs-built_in">willInit</span>()
    │           ├─ <span class="hljs-built_in">initModule</span>()
    │           ├─ <span class="hljs-built_in">didInit</span>() → <span class="hljs-selector-tag">body</span>()  ← 构建虚拟视图树
    │           └─ <span class="hljs-built_in">createBody</span>()
    │               ├─ <span class="hljs-built_in">createFlexNode</span>()
    │               ├─ <span class="hljs-built_in">createRenderView</span>()  → <span class="hljs-built_in">callNative</span>(CREATE_RENDER_VIEW)
    │               ├─ <span class="hljs-built_in">setViewProp</span>()       → <span class="hljs-built_in">callNative</span>(SET_VIEW_PROP)  ×N
    │               └─ <span class="hljs-built_in">layoutIfNeed</span>()      → <span class="hljs-built_in">callNative</span>(SET_RENDER_VIEW_FRAME) ×N
    │              │
    │              │  ── 上面这些 callNative 是异步的，被收集到 UIScheduler ──
    │              │
    │←─batch UI──│         ⑦ UIScheduler 批量提交到主线程
    │              │
    │ 执行 UI 指令   │         ⑧ 主线程依次执行：创建 View、设属性、设 Frame
    │ <span class="hljs-built_in">createView</span>()  │
    │ <span class="hljs-built_in">setProp</span>()     │
    │ <span class="hljs-built_in">setFrame</span>()    │
    │              │
    │ 首屏渲染完成    │         ⑨ viewDidLoad，触发 FirstFramePaint
    │──sendEvent─→│
    │         onReceivePagerEvent   ⑩ Kotlin 收到首屏事件
    │          ("pageFirstFramePaint")
</code></pre>
<p>现在，让我们逐步深入每一个阶段的源码实现。</p>
<hr/>
<h2 data-id="heading-3">4. 第一阶段：主线程上的准备工作</h2>
<h3 data-id="heading-4">4.1 Android 端入口</h3>
<p>一切从 <code>KuiklyRenderView.init()</code> 开始。这个方法<strong>必须在主线程调用</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderView.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(contextCode: <span class="hljs-type">String</span>, pageName: <span class="hljs-type">String</span>, 
                  params: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, size: <span class="hljs-type">Size</span>?, assetsPath: <span class="hljs-type">String</span>?)</span></span> {
    assert(isMainThread())  <span class="hljs-comment">// ← 断言：必须在主线程</span>
    initKuiklyClassLoaderIfNeed(contextCode)
    <span class="hljs-keyword">val</span> initRenderCoreTask = { sz: SizeF -&gt;
        initRenderCore(contextCode, pageName, params, sz, assetsPath)
    }
    <span class="hljs-comment">// 如果已知 size，立即初始化；否则等 onSizeChanged 回调</span>
}
</code></pre>
<p><strong>为什么必须在主线程？</strong> 因为 <code>KuiklyRenderView</code> 本身是一个 Android <code>View</code>，View 的初始化、添加子 View 等操作都必须在 UI 线程。</p>
<h3 data-id="heading-5">4.2 iOS 端入口</h3>
<p>iOS 端同理，<code>KuiklyRenderView</code> 是一个 <code>UIView</code>：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderView.m</span>
- (<span class="hljs-keyword">instancetype</span>)initWithSize:(<span class="hljs-built_in">CGSize</span>)size contextCode:(<span class="hljs-built_in">NSString</span> *)contextCode
    contextParam:(KuiklyContextParam *)contextParam params:(<span class="hljs-built_in">NSDictionary</span> *)params
    delegate:(<span class="hljs-type">id</span>&lt;KuiklyRenderViewDelegate&gt;)delegate {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) {
        _renderCore = [[KuiklyRenderCore alloc] initWithRootView:<span class="hljs-keyword">self</span>
                                                     contextCode:contextCode
                                                    contextParam:contextParam
                                                          params:coreParams
                                                        delegate:<span class="hljs-keyword">self</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
</code></pre>
<p>两端的模式完全一致：主线程创建宿主 View → 初始化 RenderCore → RenderCore 内部切换到 Context 线程。</p>
<hr/>
<h2 data-id="heading-6">5. 第二阶段：切换到 Context 线程创建页面</h2>
<h3 data-id="heading-7">5.1 KuiklyRenderCore.init() —— 关键的线程切换点</h3>
<p>这是整个页面加载过程中<strong>最重要的线程切换</strong>。我们以 Android 端为例：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(...)</span></span> {
    <span class="hljs-comment">// 还在主线程：创建调度器</span>
    uiScheduler = KuiklyRenderCoreUIScheduler { ... }
    renderLayerHandler = KuiklyRenderLayerHandler().apply { <span class="hljs-keyword">init</span>(renderView) }
    initNativeMethodRegisters()  <span class="hljs-comment">// 注册 Native 方法回调表</span>

    <span class="hljs-comment">// ★★★ 关键：切换到 Context 线程 ★★★</span>
    performOnContextQueue {
        initContextHandler(contextCode, url, params, contextInitCallback)
    }
}
</code></pre>
<p><code>performOnContextQueue</code> 是什么？让我们看看 Context 线程是怎么创建的。</p>
<h3 data-id="heading-8">5.2 Android 的 Context 线程：HandlerThread</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreContextScheduler.kt</span>
<span class="hljs-keyword">object</span> KuiklyRenderCoreContextScheduler : IKuiklyRenderCoreScheduler {

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> THREAD_NAME = <span class="hljs-string">"HRContextQueueHandlerThread"</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler <span class="hljs-keyword">by</span> lazy {
        Handler(<span class="hljs-keyword">object</span> : HandlerThread(THREAD_NAME, Process.THREAD_PRIORITY_FOREGROUND) {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLooperPrepared</span><span class="hljs-params">()</span></span> { 
                NativeBridge.isContextThread = <span class="hljs-literal">true</span>  <span class="hljs-comment">// ← 标记当前线程为 Context 线程</span>
            }
        }.apply { start() }.looper)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTask</span><span class="hljs-params">(delayMs: <span class="hljs-type">Long</span>, task: <span class="hljs-type">KuiklyRenderCoreTask</span>)</span></span> {
        handler.postDelayed(task, delayMs)  <span class="hljs-comment">// 把任务 post 到 Context 线程的消息队列</span>
    }
}
</code></pre>
<p><strong>Kotlin 语法讲解</strong>——这段代码有几个值得深入理解的语法：</p>
<h4 data-id="heading-9"><code>object</code> 单例声明</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> KuiklyRenderCoreContextScheduler : IKuiklyRenderCoreScheduler { ... }
</code></pre>
<p>Kotlin 的 <code>object</code> 声明创建了一个<strong>单例</strong>。整个 App 进程中只有一个 <code>KuiklyRenderCoreContextScheduler</code> 实例，这意味着只有一条 Context 线程。所有 Kuikly 页面共享这一条线程。</p>
<h4 data-id="heading-10"><code>by lazy</code> 懒初始化</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler <span class="hljs-keyword">by</span> lazy { ... }
</code></pre>
<p><code>by lazy</code> 是属性委托的一种，它的含义是：<strong>第一次访问 <code>handler</code> 时才执行花括号里的代码</strong>。这保证了 Context 线程不会在 App 启动时就被创建，而是在第一个 Kuikly 页面加载时才创建。</p>
<h4 data-id="heading-11"><code>HandlerThread</code></h4>
<p><code>HandlerThread</code> 是 Android 提供的一个带消息循环的线程。它内部有一个 <code>Looper</code>（消息泵），配合 <code>Handler</code> 使用时，可以不断地从消息队列取任务执行。这就是 Context 线程的本质：<strong>一个串行的任务队列</strong>，所有 Kotlin 逻辑都按顺序在这里执行。</p>
<h4 data-id="heading-12"><code>ThreadLocal</code> 标记</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// NativeBridge.kt (Android)</span>
<span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _isContextThread = ThreadLocal&lt;<span class="hljs-built_in">Boolean</span>&gt;()
    <span class="hljs-keyword">var</span> isContextThread: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = _isContextThread.<span class="hljs-keyword">get</span>() ?: <span class="hljs-literal">false</span>
        <span class="hljs-keyword">set</span>(value) { _isContextThread.<span class="hljs-keyword">set</span>(value) }
}
</code></pre>
<p><code>ThreadLocal</code> 是 Java/Kotlin 的线程局部变量。每个线程都有自己独立的 <code>isContextThread</code> 值。当 Context 线程启动时，<code>onLooperPrepared</code> 被调用，此时在 Context 线程内将 <code>isContextThread</code> 设为 <code>true</code>。之后任何地方调用 <code>NativeBridge.isContextThread</code> 都能判断当前是否在 Context 线程上。</p>
<h3 data-id="heading-13">5.3 iOS 的 Context 线程：GCD 串行队列</h3>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderThreadManager.m</span>
<span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_queue_t</span> gContextQueue = <span class="hljs-literal">NULL</span>;

+ (<span class="hljs-built_in">dispatch_queue_t</span>)contextQueue {
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;
    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^{
        dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class(
            DISPATCH_QUEUE_SERIAL,          <span class="hljs-comment">// 串行队列</span>
            QOS_CLASS_USER_INTERACTIVE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 最高 QoS 优先级</span>
        gContextQueue = dispatch_queue_create(<span class="hljs-string">"com.tencent.kuikly.context"</span>, queue_attr);
        dispatch_queue_set_specific(gContextQueue, &amp;gContextQueue, ...);
    });
    <span class="hljs-keyword">return</span> gContextQueue;
}
</code></pre>
<p>iOS 使用 GCD（Grand Central Dispatch）的串行队列。注意两个关键选择：</p>
<ol>
<li><strong><code>DISPATCH_QUEUE_SERIAL</code></strong>（串行）：保证所有任务按顺序执行，不会并发，因此不需要锁</li>
<li><strong><code>QOS_CLASS_USER_INTERACTIVE</code></strong>（用户交互级）：这是 iOS 最高优先级的 QoS，告诉系统"这个队列的任务很紧急，直接影响用户体验"</li>
</ol>
<p>判断是否在 Context 队列上：</p>
<pre><code class="hljs language-objc" lang="objc">+ (<span class="hljs-type">BOOL</span>)isContextQueue {
    <span class="hljs-keyword">if</span> (dispatch_get_specific(&amp;gContextQueue)) {  <span class="hljs-comment">// ← 用 queue-specific data 判断</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;
}
</code></pre>
<p><code>dispatch_get_specific</code> 是 GCD 提供的一个机制：你可以给队列绑定一个 key-value，然后在任意地方查询当前队列是否绑定了这个 key。如果返回非 NULL，说明当前代码正在这个队列上执行。</p>
<h3 data-id="heading-14">5.4 在 Context 线程上初始化 Kotlin 引擎</h3>
<p>切换到 Context 线程后，<code>initContextHandler</code> 做了三件事：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initContextHandler</span><span class="hljs-params">(contextCode: <span class="hljs-type">String</span>, url: <span class="hljs-type">String</span>, params: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, ...)</span></span> {
    <span class="hljs-comment">// 1. 创建 ContextHandler（通过反射加载 KuiklyCoreEntry）</span>
    contextHandler = KuiklyRenderJvmContextHandler()
    
    contextHandler?.apply {
        <span class="hljs-comment">// 2. 注册 Kotlin→Native 的回调通道</span>
        registerCallNative { method, args -&gt;
            performNativeMethodWithMethod(method, args)
        }
        
        <span class="hljs-comment">// 3. 初始化 Kotlin 引擎</span>
        <span class="hljs-keyword">init</span>(contextCode)
        
        <span class="hljs-comment">// 4. ★ 调用 CREATE_INSTANCE，触发 Kotlin 侧创建页面 ★</span>
        call(KuiklyRenderContextMethodCreateInstance, listOf(instanceId, url, params))
    }
}
</code></pre>
<p>其中第 4 步的 <code>call(CREATE_INSTANCE, ...)</code> 最终会进入 Kotlin 侧的 <code>BridgeManager.callKotlinMethod()</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// BridgeManager.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callKotlinMethod</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, arg0: <span class="hljs-type">Any</span>?, arg1: <span class="hljs-type">Any</span>?, ...)</span></span> {
    currentPageId = arg0 <span class="hljs-keyword">as</span> String
    <span class="hljs-keyword">when</span> (methodId) {
        KotlinMethod.CREATE_INSTANCE -&gt; {
            PagerManager.createPager(arg0 <span class="hljs-keyword">as</span> String, arg1 <span class="hljs-keyword">as</span> String, arg2 <span class="hljs-keyword">as</span> String)
        }
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>然后进入 <code>PagerManager.createPager()</code>，通过之前 <code>@Page</code> 注解注册的 creator 创建页面实例：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// PagerManager.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createPager</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, url: <span class="hljs-type">String</span>, pagerData: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-keyword">val</span> pagerName = pageNameFromUrl(url)
    reactiveObserverMap[pagerId] = ReactiveObserver()
    <span class="hljs-keyword">val</span> pager: IPager? = pagerCreator(pagerName)?.invoke()  <span class="hljs-comment">// ← 调用注册的 creator 创建 Pager 实例</span>
    pagerMap[pagerId] = pager
    pager.onCreatePager(pagerId, JSONObject(pagerData))      <span class="hljs-comment">// ← 进入页面生命周期</span>
}
</code></pre>
<blockquote>
<p><strong>以上所有代码都在 Context 线程上执行</strong>。从 <code>performOnContextQueue</code> 开始，后面的一切逻辑——页面创建、body 构建、布局计算——全部在 Context 线程上串行运行。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">6. 第三阶段：Kotlin→Native 通信——同步 vs 异步</h2>
<p>页面在 Context 线程上执行 <code>onCreatePager()</code> 时，会调用 <code>body()</code> 方法构建虚拟视图树，然后 <code>createBody()</code> 进行布局计算。在此过程中，Kotlin 需要告诉 Native 端"帮我创建一个 TextView"、"把它的背景色设为红色"、"把它放到 (10, 20) 位置"等。</p>
<p>这些指令通过 <code>BridgeManager</code> 发出：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// BridgeManager.kt 中定义的 Native 方法</span>
<span class="hljs-keyword">object</span> NativeMethod {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CREATE_RENDER_VIEW = <span class="hljs-number">1</span>      <span class="hljs-comment">// 创建原生 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOVE_RENDER_VIEW = <span class="hljs-number">2</span>      <span class="hljs-comment">// 移除原生 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> INSERT_SUB_RENDER_VIEW = <span class="hljs-number">3</span>  <span class="hljs-comment">// 插入子 View</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SET_VIEW_PROP = <span class="hljs-number">4</span>           <span class="hljs-comment">// 设置 View 属性</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SET_RENDER_VIEW_FRAME = <span class="hljs-number">5</span>   <span class="hljs-comment">// 设置 View 的位置和大小</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALCULATE_RENDER_VIEW_SIZE = <span class="hljs-number">6</span>  <span class="hljs-comment">// 计算 View 尺寸（同步！）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CREATE_SHADOW = <span class="hljs-number">9</span>           <span class="hljs-comment">// 创建 Shadow 节点（同步！）</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3 data-id="heading-16">6.1 关键设计：哪些是同步的？哪些是异步的？</h3>
<p>这是 Kuikly 多线程模型中最精妙的设计之一。让我们看 Native 端收到 Kotlin 调用时的处理：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt (Android)</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performNativeMethodWithMethod</span><span class="hljs-params">(method: <span class="hljs-type">KuiklyRenderNativeMethod</span>, args: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any? {
    <span class="hljs-keyword">val</span> cb = nativeMethodRegistry[method.value]
    cb?.also {
        assert(!isMainThread())  <span class="hljs-comment">// ← 断言：当前在 Context 线程</span>

        <span class="hljs-keyword">if</span> (isSyncMethodCall(method, args)) {
            <span class="hljs-comment">// ★ 同步方法：直接在 Context 线程执行，立即返回结果</span>
            <span class="hljs-keyword">return</span> it(method, args)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// ★ 异步方法：加入 UIScheduler 的任务队列，稍后批量在主线程执行</span>
            uiScheduler?.scheduleTask {
                it(method, args)
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}
</code></pre>
<p>iOS 端的逻辑完全一致：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderCore.m</span>
- (<span class="hljs-type">id</span>)p_performNativeMethodWithMethod:(KuiklyRenderNativeMethod)method args:(<span class="hljs-built_in">NSArray</span> *)args {
    KuiklyRenderNativeMethodCallback methodCallback = _nativeMethodRegistry[@(method)];
    <span class="hljs-keyword">if</span> (methodCallback) {
        [KuiklyRenderThreadManager assertContextQueue];
        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> p_shouldSyncCallWithWithMethod:method args:args]) {
            <span class="hljs-keyword">return</span> methodCallback(method, args);  <span class="hljs-comment">// 同步执行</span>
        } <span class="hljs-keyword">else</span> {
            [<span class="hljs-keyword">self</span>.uiScheduler addTaskToMainQueueWithTask:^{  <span class="hljs-comment">// 异步批量</span>
                methodCallback(method, args);
            }];
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;
}
</code></pre>
<p>哪些方法是同步的？</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// iOS 端的判断逻辑</span>
- (<span class="hljs-type">BOOL</span>)p_shouldSyncCallWithWithMethod:(KuiklyRenderNativeMethod)method args:(<span class="hljs-built_in">NSArray</span> *)args {
    <span class="hljs-keyword">return</span> method == KuiklyRenderNativeMethodCalculateRenderViewSize ||  <span class="hljs-comment">// 计算 View 尺寸</span>
           method == KuiklyRenderNativeMethodCreateShadow ||             <span class="hljs-comment">// 创建 Shadow</span>
           method == KuiklyRenderNativeMethodRemoveShadow ||             <span class="hljs-comment">// 移除 Shadow</span>
           method == KuiklyRenderNativeMethodSetShadowForView ||         <span class="hljs-comment">// 设置 Shadow</span>
           method == KuiklyRenderNativeMethodSetShadowProp ||            <span class="hljs-comment">// Shadow 属性</span>
           method == KuiklyRenderNativeMethodSetTimeout ||               <span class="hljs-comment">// 定时器</span>
           method == KuiklyRenderNativeMethodCallShadowMethod ||         <span class="hljs-comment">// Shadow 方法</span>
           method == KuiklyRenderNativeMethodSyncFlushUI ||              <span class="hljs-comment">// 同步刷新</span>
           <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>为什么要区分同步和异步？</strong> 因为有些操作，Kotlin 侧必须<strong>立即</strong>拿到结果才能继续。比如：</p>
<ul>
<li><strong><code>CALCULATE_RENDER_VIEW_SIZE</code></strong>：计算 Text 的实际尺寸。Kotlin 的 Flexbox 布局引擎需要知道一段文本在给定宽度下会占多高，这个值必须同步返回，布局计算才能继续</li>
<li><strong><code>CREATE_SHADOW</code></strong>：创建 Shadow 节点（如文本的阴影计算）需要 Native 端立即返回</li>
</ul>
<p>而像 <code>CREATE_RENDER_VIEW</code>、<code>SET_VIEW_PROP</code>、<code>SET_RENDER_VIEW_FRAME</code> 这些纯 UI 操作，Kotlin 不需要返回值，可以攒起来批量执行。</p>
<h3 data-id="heading-17">6.2 NativeBridge 的 expect/actual 机制</h3>
<p><code>BridgeManager</code> 通过 <code>NativeBridge</code> 与 Native 通信。这里用到了 Kotlin Multiplatform 的核心机制——<code>expect/actual</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain（公共层）——只声明接口，不提供实现</span>
<span class="hljs-keyword">expect</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, arg0: <span class="hljs-type">Any</span>?, arg1: <span class="hljs-type">Any</span>?, ...)</span></span>: Any?
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>
}
</code></pre>
<p><code>expect</code> 关键字的含义是："我声明了这个东西存在，但具体实现由各平台提供。"</p>
<p>Android 实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span> <span class="hljs-title">actual</span> <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">var</span> delegate: NativeBridgeDelegate? = <span class="hljs-literal">null</span>
    
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, ...)</span></span>: Any? {
        <span class="hljs-keyword">return</span> delegate?.callNative(methodId, ...)  <span class="hljs-comment">// 调用 Java/Kotlin 层的回调</span>
    }
}
</code></pre>
<p>iOS 实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// appleMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeBridge</span> <span class="hljs-title">actual</span> <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">var</span> iosNativeBridgeDelegate: IOSNativeBridgeDelegate? = <span class="hljs-literal">null</span>
    
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toNative</span><span class="hljs-params">(methodId: <span class="hljs-type">Int</span>, ...)</span></span>: Any? {
        <span class="hljs-keyword">return</span> iosNativeBridgeDelegate?.callNative(methodId, ...)  <span class="hljs-comment">// 调用 ObjC 层的回调</span>
    }
}
</code></pre>
<p>这样，公共层的 <code>BridgeManager</code> 调用 <code>nativeBridge.toNative()</code> 时，<strong>编译器会自动根据目标平台选择正确的实现</strong>。这就是 Kotlin Multiplatform 的"同一份代码，多平台运行"的基础机制。</p>
<hr/>
<h2 data-id="heading-18">7. 第四阶段：UIScheduler——批量上屏的艺术</h2>
<p>UIScheduler 是 Kuikly 多线程模型中<strong>性能优化</strong>的核心。它的设计思想是：</p>
<blockquote>
<p><strong>不要来一条 UI 指令就切一次线程，而是攒一批指令，一次性切到主线程全部执行完。</strong></p>
</blockquote>
<h3 data-id="heading-19">7.1 Android 端实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreUIScheduler.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">KuiklyRenderCoreUIScheduler</span>(...) : IKuiklyRenderCoreScheduler {
    
    <span class="hljs-comment">// Context 线程上暂存的任务列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mainThreadTasksOnContextQueue: MutableList&lt;KuiklyRenderCoreTaskExecutor&gt;? = <span class="hljs-literal">null</span>
    <span class="hljs-comment">// 主线程上待执行的任务列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mainThreadTasks = mutableListOf&lt;KuiklyRenderCoreTaskExecutor&gt;()
    
    <span class="hljs-comment">// 在 Context 线程调用——收集任务</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addTaskToMainQueue</span><span class="hljs-params">(task: <span class="hljs-type">KuiklyRenderCoreTaskExecutor</span>)</span></span> {
        assert(!isMainThread())  <span class="hljs-comment">// ← 必须在 Context 线程</span>
        <span class="hljs-keyword">val</span> tasks = mainThreadTasksOnContextQueue ?: mutableListOf&lt;KuiklyRenderCoreTaskExecutor&gt;().apply {
            mainThreadTasksOnContextQueue = <span class="hljs-keyword">this</span>
        }
        tasks.add(task)
        setNeedSyncMainQueueTasks()  <span class="hljs-comment">// ← 标记"有任务需要同步到主线程"</span>
    }
}
</code></pre>
<p><code>setNeedSyncMainQueueTasks</code> 的实现非常精巧：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNeedSyncMainQueueTasks</span><span class="hljs-params">()</span></span> {
    assert(!isMainThread())
    <span class="hljs-keyword">if</span> (needSyncMainQueueTasksBlock != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// ← 已经标记过了，不重复标记！这就是"批量"的秘诀</span>
    }
    
    <span class="hljs-comment">// 创建"同步闭包"——包含了把 Context 线程任务搬到主线程的逻辑</span>
    needSyncMainQueueTasksBlock = { sync -&gt;
        <span class="hljs-keyword">val</span> performTasks = mainThreadTasksOnContextQueue
        mainThreadTasksOnContextQueue = <span class="hljs-literal">null</span>
        synchronized(<span class="hljs-keyword">this</span>) {
            mainThreadTasks.addAll(performTasks?.toList() ?: listOf())
        }
        performOnMainQueueWithTask(sync = sync) {
            <span class="hljs-comment">// 在主线程执行所有任务</span>
            <span class="hljs-keyword">var</span> tasks: List&lt;KuiklyRenderCoreTaskExecutor&gt;?
            synchronized(<span class="hljs-keyword">this</span>) {
                tasks = mainThreadTasks.toList()
                mainThreadTasks.clear()
            }
            runMainQueueTasks(tasks)
        }
    }
    
    <span class="hljs-comment">// ★ 关键：把"执行同步闭包"这件事，再 post 到 Context 线程消息队列的尾部</span>
    KuiklyRenderCoreContextScheduler.scheduleTask {
        performSyncMainQueueTasksBlockIfNeed(<span class="hljs-literal">false</span>)
    }
}
</code></pre>
<p><strong>为什么要 post 到 Context 线程队列尾部？</strong> 因为当前 Context 线程正在执行 Kotlin 逻辑（比如 body 方法还没执行完），会不断产生新的 UI 指令。把"同步到主线程"这个动作 post 到队列尾部，就能保证<strong>当前一轮逻辑全部执行完后，再一次性把所有指令提交给主线程</strong>。</p>
<p>让我们画出这个时序：</p>
<pre><code class="hljs language-css" lang="css">Context 线程的消息队列
┌─────────────────────────────────────────────┐
│ <span class="hljs-selector-attr">[当前任务: 执行 body、布局计算、产生 UI 指令]</span>      │
│ <span class="hljs-selector-attr">[排队: performSyncMainQueueTasksBlockIfNeed]</span> │  ← 在当前任务结束后执行
└─────────────────────────────────────────────┘

当前任务执行过程中，产生的 UI 指令被收集到 mainThreadTasksOnContextQueue
当前任务执行完，轮到 performSync... → 把收集的指令批量 post 到主线程
</code></pre>
<h3 data-id="heading-20">7.2 iOS 端实现</h3>
<p>iOS 的逻辑完全一致，只是用 ObjC + GCD 实现：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderUIScheduler.m</span>
- (<span class="hljs-type">void</span>)addTaskToMainQueueWithTask:(dispatch_block_t)taskBlock {
    KR_ASSERT_CONTEXT_HTREAD;  <span class="hljs-comment">// 断言在 Context 线程</span>
    [_mainThreadTasksOnContextQueue addObject:taskBlock];
    [<span class="hljs-keyword">self</span> p_setNeedSyncMainQuequeTasks];
}

- (<span class="hljs-type">void</span>)p_setNeedSyncMainQuequeTasks {
    <span class="hljs-keyword">if</span> (!_needSyncMainQueueTasksBlock) {
        KR_WEAK_SELF
        <span class="hljs-keyword">self</span>.needSyncMainQueueTasksBlock = ^{
            <span class="hljs-comment">// 同步 UI 任务前，先通知 Kotlin 做 layoutIfNeed</span>
            [strongSelf p_dispatchWillPerformUITasksDelegator];
            <span class="hljs-built_in">NSArray</span> *tasks = weakSelf.mainThreadTasksOnContextQueue;
            weakSelf.mainThreadTasksOnContextQueue = <span class="hljs-literal">nil</span>;
            <span class="hljs-comment">// 加锁搬运任务</span>
            [weakSelf.threadLock threadSafeInBlock:^{
                [weakSelf.mainThreadTasks addObjectsFromArray:tasks];
            }];
            <span class="hljs-comment">// 切到主线程批量执行</span>
            [KuiklyRenderThreadManager performOnMainQueueWithTask:^{
                <span class="hljs-keyword">for</span> (dispatch_block_t task <span class="hljs-keyword">in</span> mainThreadTasks) {
                    task();
                }
            } sync:[<span class="hljs-built_in">NSThread</span> isMainThread]];
        };
        <span class="hljs-comment">// 再调度一次到 Context 线程尾部</span>
        [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
            [weakSelf performSyncMainQueueTasksBlockIfNeed];
        }];
    }
}
</code></pre>
<h3 data-id="heading-21">7.3 一个容易被忽略的细节：layoutIfNeed 的时机</h3>
<p>注意 iOS 端有一行 <code>[strongSelf p_dispatchWillPerformUITasksDelegator]</code>，Android 端对应的是 UIScheduler 构造时传入的闭包：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
uiScheduler = KuiklyRenderCoreUIScheduler {
    <span class="hljs-comment">// 同步主线程任务前，告诉 Kotlin 侧去 layoutIfNeed</span>
    contextHandler?.call(KuiklyRenderContextMethodLayoutView, listOf(instanceId))
}
</code></pre>
<p>这个回调在"把 UI 指令提交给主线程之前"被调用，它的作用是确保 <strong>Kotlin 侧已经完成布局计算</strong>，所有 View 的 Frame 都已经确定。否则可能出现"View 已经创建了，但还不知道放在哪里"的情况。</p>
<hr/>
<h2 data-id="heading-22">8. 第五阶段：首屏完成与后续事件闭环</h2>
<h3 data-id="heading-23">8.1 首屏渲染完成</h3>
<p>UIScheduler 在主线程执行完第一批 UI 指令后，会标记 <code>viewDidLoad = true</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCoreUIScheduler.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runMainQueueTasks</span><span class="hljs-params">(tasks: <span class="hljs-type">List</span>&lt;<span class="hljs-type">KuiklyRenderCoreTaskExecutor</span>&gt;?)</span></span> {
    assert(isMainThread())
    <span class="hljs-keyword">val</span> uiTasks = tasks ?: <span class="hljs-keyword">return</span>
    isPerformingMainQueueTask = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> (task <span class="hljs-keyword">in</span> uiTasks) {
        task.execute()
    }
    isPerformingMainQueueTask = <span class="hljs-literal">false</span>
    
    <span class="hljs-keyword">if</span> (!viewDidLoad) {
        viewDidLoad = <span class="hljs-literal">true</span>           <span class="hljs-comment">// ← 首屏标记</span>
        performViewDidLoadTasksIfNeed()  <span class="hljs-comment">// ← 执行等待首屏完成的任务</span>
    }
}
</code></pre>
<p>然后 Native 端会通过 <code>sendEvent</code> 通知 Kotlin 侧"首屏完成了"：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">sendEvent</span>("pageFirstFramePaint") → Context 线程 → Pager<span class="hljs-selector-class">.onReceivePagerEvent</span>()
</code></pre>
<h3 data-id="heading-24">8.2 后续事件——从主线程回到 Context 线程</h3>
<p>用户的触摸、滑动等事件发生在主线程，需要通知到 Context 线程的 Kotlin 逻辑。以 <code>sendEvent</code> 为例：</p>
<p>Android 端：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyRenderCore.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(event: <span class="hljs-type">String</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, Any&gt;, shouldSync: <span class="hljs-type">Boolean</span>)</span></span> {
    performOnContextQueue(sync = shouldSync) {  <span class="hljs-comment">// ← 切到 Context 线程</span>
        contextHandler?.call(KuiklyRenderContextMethodUpdateInstance,
            listOf(instanceId, event, <span class="hljs-keyword">data</span>))
    }
}
</code></pre>
<p>iOS 端：</p>
<pre><code class="hljs language-objc" lang="objc"><span class="hljs-comment">// KuiklyRenderCore.m</span>
- (<span class="hljs-type">void</span>)sendWithEvent:(<span class="hljs-built_in">NSString</span> *)event data:(<span class="hljs-built_in">NSDictionary</span> *)data {
    [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
        [<span class="hljs-keyword">self</span>.contextHandler callWithMethod:KuiklyRenderContextMethodUpdateInstance
                                      args:@[<span class="hljs-keyword">self</span>.instanceId, event, data]];
    } sync:![<span class="hljs-built_in">NSThread</span> isMainThread]];  <span class="hljs-comment">// ← 非主线程时同步调用</span>
}
</code></pre>
<p>注意 iOS 端的 <code>sync:![NSThread isMainThread]</code>：如果当前已经在 Context 线程上（非主线程），就用 <code>dispatch_sync</code> 直接同步执行；如果在主线程上，就用 <code>dispatch_async</code> 异步投递（避免主线程阻塞等待 Context 线程）。</p>
<p>这样就形成了完整的事件循环：</p>
<pre><code class="hljs language-scss" lang="scss">用户操作(主线程) → sendEvent → Context 线程(Kotlin 处理逻辑)
                                    ↓
                              产生新的 UI 指令
                                    ↓
                              UIScheduler 批量
                                    ↓
                              主线程执行(UI 更新)
</code></pre>
<hr/>
<h2 data-id="heading-25">9. iOS 端 vs Android 端的线程实现对比</h2>























































<table><thead><tr><th>维度</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td><strong>Context 线程</strong></td><td><code>HandlerThread</code>（基于 Java 的 Looper/Handler 机制）</td><td>GCD <code>dispatch_queue_create</code>（串行队列）</td></tr><tr><td><strong>线程优先级</strong></td><td><code>Process.THREAD_PRIORITY_FOREGROUND</code></td><td><code>QOS_CLASS_USER_INTERACTIVE</code></td></tr><tr><td><strong>判断是否在 Context 线程</strong></td><td><code>ThreadLocal&lt;Boolean&gt;</code>（<code>NativeBridge.isContextThread</code>）</td><td><code>dispatch_get_specific</code>（queue-specific data）</td></tr><tr><td><strong>切到 Context 线程</strong></td><td><code>handler.post { task }</code></td><td><code>dispatch_async(contextQueue, task)</code></td></tr><tr><td><strong>切到主线程</strong></td><td><code>Handler(Looper.getMainLooper()).post { task }</code></td><td><code>dispatch_async(dispatch_get_main_queue(), task)</code></td></tr><tr><td><strong>UIScheduler</strong></td><td>基于 <code>MutableList</code> + <code>synchronized</code> 锁</td><td>基于 <code>NSMutableArray</code> + <code>KuiklyRenderThreadLock</code></td></tr><tr><td><strong>线程间同步调用</strong></td><td><code>ConditionVariable</code>（<code>BlockingRunnable</code>）</td><td><code>dispatch_sync</code></td></tr><tr><td><strong>Kotlin→Native 桥接</strong></td><td>反射加载 <code>KuiklyCoreEntry</code> 类（JVM）</td><td>ObjC 反射加载 Kotlin/Native Framework</td></tr><tr><td><strong>Native→Kotlin 调用</strong></td><td><code>IKuiklyCoreEntry.callKotlinMethod()</code></td><td><code>[contextHandler callWithMethod:args:]</code></td></tr></tbody></table>
<p>虽然实现方式不同，但<strong>架构完全一致</strong>：单一 Context 线程 + UIScheduler 批量提交 + 主线程执行。</p>
<h3 data-id="heading-26">9.1 iOS 特有的 C 桥接</h3>
<p>iOS 端还额外提供了一组 C 函数，供 Kotlin/Native 编译出的代码调用：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// KuiklyRenderThreadBridge.m</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">com_tencent_kuikly_ScheduleContextTask</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pagerId, 
                                             <span class="hljs-type">void</span> (*onSchedule)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*))</span> {
    NSString *pId = [NSString stringWithUTF8String:pagerId];
    [KuiklyRenderThreadManager performOnContextQueueWithBlock:^{
        onSchedule([pId UTF8String]);
    } sync:NO];
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">com_tencent_kuikly_IsCurrentOnContextThread</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pagerId)</span> {
    <span class="hljs-keyword">return</span> [KuiklyRenderThreadManager isContextQueue];
}
</code></pre>
<p>为什么需要 C 函数？因为 Kotlin/Native 编译为 iOS 的 Framework 时，不能直接调用 ObjC 的类方法（除非通过 cinterop），但可以调用 C 函数。这些 C 函数充当了"桥梁"角色。</p>
<hr/>
<h2 data-id="heading-27">10. 从其他线程回到 Kuikly 线程</h2>
<p>当你在 Kotlin 中使用了多线程（比如 KMP 的 expect/actual 机制、或者 kotlinx 协程切换到 IO 线程），完成异步操作后需要回到 Kuikly 线程更新 UI。Kuikly 提供了 <code>KuiklyContextScheduler</code> 来实现这一点。</p>
<h3 data-id="heading-28">10.1 公共层 API</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.kt (commonMain)</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> KuiklyContextScheduler : SynchronizedObject() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, block: (<span class="hljs-type">cancel</span>: <span class="hljs-type">Boolean</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
        <span class="hljs-comment">// 如果已经在 Kuikly 线程上，直接执行</span>
        <span class="hljs-keyword">if</span> (platformIsOnKuiklyThread(pagerId)) {
            block(<span class="hljs-literal">false</span>)
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-comment">// 否则，调度到 Kuikly 线程</span>
        addTask(pagerId, block)
        platformScheduleOnKuiklyThread(pagerId)
    }
}
</code></pre>
<p>注意 <code>block: (cancel: Boolean) -&gt; Unit</code> 的设计——参数 <code>cancel</code> 告诉你页面是否已经销毁。如果页面已经销毁（<code>BridgeManager.containNativeBridge(pagerId)</code> 返回 false），<code>cancel</code> 为 true，你应该放弃操作。这是一个很好的<strong>安全机制</strong>。</p>
<h3 data-id="heading-29">10.2 Android 实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.android.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformIsOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> NativeBridge.isContextThread  <span class="hljs-comment">// ← 读 ThreadLocal</span>
}

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformScheduleOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span> {
    KuiklyRenderCoreContextScheduler.scheduleTask {
        KuiklyContextScheduler.runTask(pagerId)  <span class="hljs-comment">// ← post 到 Context 线程</span>
    }
}
</code></pre>
<h3 data-id="heading-30">10.3 iOS 实现</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// KuiklyContextScheduler.ios.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformIsOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> com_tencent_kuikly_IsCurrentOnContextThread(pagerId)  <span class="hljs-comment">// ← 调用 C 函数</span>
}

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformScheduleOnKuiklyThread</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>)</span></span> {
    com_tencent_kuikly_ScheduleContextTask(pagerId, staticCFunction { pIdPtr -&gt;
        <span class="hljs-comment">// 这个 staticCFunction 是 Kotlin/Native 提供的机制</span>
        <span class="hljs-comment">// 它将 Kotlin 函数转为 C 函数指针，以便 ObjC/C 代码回调</span>
        <span class="hljs-keyword">val</span> pId = pIdPtr!!.toKString()
        KuiklyContextScheduler.runTask(pId)
    })
}
</code></pre>
<h3 data-id="heading-31">10.4 使用 Dispatchers.Kuikly</h3>
<p>如果你使用 kotlinx 协程，可以通过自定义 Dispatcher 切回 Kuikly 线程：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    <span class="hljs-comment">// 在 Kuikly 线程启动协程</span>
    GlobalScope.launch(Dispatchers.Kuikly[ctx]) {
        <span class="hljs-comment">// 切到 IO 线程做耗时操作</span>
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) {
            fetchDataFromNetwork()
        }
        <span class="hljs-comment">// 自动回到 Kuikly 线程，安全更新 UI</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>
    }
}
</code></pre>
<p><code>Dispatchers.Kuikly[ctx]</code> 的实现原理就是把协程的恢复操作调度到 <code>KuiklyContextScheduler.runOnKuiklyThread()</code> 上。</p>
<hr/>
<h2 data-id="heading-32">11. 线程安全验证机制</h2>
<p>Kuikly 提供了开发阶段的线程安全验证：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Pager.kt</span>
<span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">var</span> VERIFY_THREAD
        <span class="hljs-keyword">get</span>() = com.tencent.kuikly.core.utils.VERIFY_THREAD
        <span class="hljs-keyword">set</span>(value) { com.tencent.kuikly.core.utils.VERIFY_THREAD = value }
    
    <span class="hljs-keyword">var</span> VERIFY_REACTIVE_OBSERVER
        <span class="hljs-keyword">get</span>() = com.tencent.kuikly.core.utils.VERIFY_REACTIVE_OBSERVER
        <span class="hljs-keyword">set</span>(value) { com.tencent.kuikly.core.utils.VERIFY_REACTIVE_OBSERVER = value }
}
</code></pre>
<p>开启方式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Page(<span class="hljs-string">"DebugPage"</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugPage</span> : <span class="hljs-type">BasePager</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">willInit</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.willInit()
        Pager.VERIFY_THREAD = <span class="hljs-literal">true</span>             <span class="hljs-comment">// 开启线程校验</span>
        Pager.VERIFY_REACTIVE_OBSERVER = <span class="hljs-literal">true</span>   <span class="hljs-comment">// 开启响应式观察者校验</span>
        
        Pager.verifyFailed { exception -&gt;
            <span class="hljs-comment">// 自定义验证失败的处理</span>
            println(<span class="hljs-string">"线程安全验证失败: <span class="hljs-subst">${exception.message}</span>"</span>)
            <span class="hljs-keyword">throw</span> exception  <span class="hljs-comment">// 开发阶段直接崩溃，方便定位</span>
        }
    }
}
</code></pre>
<p>当 <code>VERIFY_THREAD = true</code> 时，如果你在非 Context 线程访问了 <code>observable</code> 属性或调用了 UI 相关 API，框架会立即抛出异常。<strong>强烈建议在开发阶段开启这两个选项。</strong></p>
<hr/>
<h2 data-id="heading-33">12. 三种异步编程方式的选择</h2>
<p>理解了多线程模型后，让我们看看 Kuikly 提供的三种异步编程方案以及它们的适用场景：</p>
<h3 data-id="heading-34">方式一：Module 机制 + Kuikly 内建协程</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    lifecycleScope.launch {
        <span class="hljs-keyword">val</span> type = fetchLocal()       <span class="hljs-comment">// 挂起函数（底层通过 Module 调 Native）</span>
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = fetchRemote(type)  <span class="hljs-comment">// 挂起函数</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>     <span class="hljs-comment">// 安全更新 UI</span>
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：始终在 Kuikly 线程。异步操作通过 Module 下沉到 Native 层执行（Native 可以自由使用多线程），结果通过回调返回到 Kuikly 线程</li>
<li><strong>优势</strong>：无线程安全问题，支持动态化，无额外依赖</li>
<li><strong>适用场景</strong>：大多数业务需求（网络请求、本地存储、系统 API 调用）</li>
</ul>
<h3 data-id="heading-35">方式二：KMP 多线程 + kuiklyx 回调</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    asyncKmpFetchData { <span class="hljs-keyword">data</span> -&gt;
        KuiklyContextScheduler.runOnKuiklyThread(ctx.pagerId) { cancel -&gt;
            <span class="hljs-keyword">if</span> (cancel) <span class="hljs-keyword">return</span><span class="hljs-symbol">@runOnKuiklyThread</span>
            ctx.dataObservable = <span class="hljs-keyword">data</span>  <span class="hljs-comment">// 回到 Kuikly 线程更新 UI</span>
        }
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：KMP 代码可以在任意线程执行，完成后显式切回 Kuikly 线程</li>
<li><strong>优势</strong>：无通信开销（直接跨平台调用，不经过 Bridge）</li>
<li><strong>劣势</strong>：不支持动态化，需要手动管理线程切换</li>
<li><strong>适用场景</strong>：对性能要求极高、不需要动态化的场景</li>
</ul>
<h3 data-id="heading-36">方式三：kotlinx 协程 + Dispatchers.Kuikly</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">created</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.created()
    <span class="hljs-keyword">val</span> ctx = <span class="hljs-keyword">this</span>
    GlobalScope.launch(Dispatchers.Kuikly[ctx]) {
        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = withContext(Dispatchers.IO) {
            kmpFetchData()  <span class="hljs-comment">// 在 IO 线程执行</span>
        }
        <span class="hljs-comment">// 自动回到 Kuikly 线程</span>
        ctx.dataObservable = <span class="hljs-keyword">data</span>
    }
}
</code></pre>
<ul>
<li><strong>线程模型</strong>：利用 kotlinx 协程的 Dispatcher 机制自由切换线程</li>
<li><strong>优势</strong>：代码可读性最好，与 Kotlin 社区标准对齐</li>
<li><strong>劣势</strong>：不支持动态化，需要引入 kotlinx 协程库 + kuiklyx 协程库</li>
<li><strong>适用场景</strong>：复杂的异步逻辑，需要协程语法提升可读性</li>
</ul>
<h3 data-id="heading-37">选择决策树</h3>
<pre><code class="hljs language-markdown" lang="markdown">你需要动态化吗？
├─ 是 → 方式一（Module + Kuikly 内建协程）
└─ 否 → 你需要多线程执行耗时任务吗？
<span class="hljs-code">         ├─ 否 → 方式一
         └─ 是 → 你需要协程语法吗？
                  ├─ 否 → 方式二（KMP + kuiklyx 回调）
                  └─ 是 → 方式三（kotlinx + Dispatchers.Kuikly）
</span></code></pre>
<hr/>
<h2 data-id="heading-38">13. 总结：一张图看清全貌</h2>
<pre><code class="hljs language-scss" lang="scss">                          ┌──────────────────────────────────────┐
                          │           主线程 (UI Thread)           │
                          │                                      │
                          │   KuiklyRenderView                   │
                          │     ├─ <span class="hljs-built_in">init</span>()  ──schedule──→ ①       │
                          │     │                                │
                          │   UIScheduler ←─── 批量UI指令 ←─ ④  │
                          │     ├─ <span class="hljs-built_in">createView</span>()                  │
                          │     ├─ <span class="hljs-built_in">setProp</span>()                     │
                          │     ├─ <span class="hljs-built_in">setFrame</span>()                    │
                          │     └─ viewDidLoad ──sendEvent──→ ⑤ │
                          │                                      │
                          └──────────────┬───────────────────────┘
                                         │ ①②④⑤ 线程间通信
                          ┌──────────────┴───────────────────────┐
                          │       Context 线程 (Kuikly Thread)     │
                          │                                      │
                          │ ② initContextHandler                 │
                          │     ├─ 加载 KuiklyCoreEntry           │
                          │     ├─ 注册 callNative 回调           │
                          │     └─ <span class="hljs-built_in">call</span>(CREATE_INSTANCE)         │
                          │                                      │
                          │ ③ PagerManager<span class="hljs-selector-class">.createPager</span>()         │
                          │     └─ pager<span class="hljs-selector-class">.onCreatePager</span>()         │
                          │         ├─ <span class="hljs-built_in">willInit</span>()                │
                          │         ├─ <span class="hljs-built_in">initModule</span>()              │
                          │         ├─ <span class="hljs-built_in">didInit</span>() → <span class="hljs-selector-tag">body</span>()        │
                          │         └─ <span class="hljs-built_in">createBody</span>()              │
                          │             ├─ <span class="hljs-built_in">createFlexNode</span>()      │
                          │             ├─ <span class="hljs-built_in">layoutIfNeed</span>()        │
                          │             └─ callNative ×N ──→ ④  │
                          │                                      │
                          │ ⑤ onReceivePagerEvent                │
                          │     ("pageFirstFramePaint")          │
                          │                                      │
                          │ ⑥ 后续：响应式更新、事件处理、协程...    │
                          │     └─ 新的 callNative → UIScheduler │
                          │                                      │
                          └──────────────────────────────────────┘

线程间通信方式：
  ① 主线程 → Context: handler.<span class="hljs-built_in">post</span>() / <span class="hljs-built_in">dispatch_async</span>(contextQueue)
  ④ Context → 主线程: UIScheduler 批量 → uiHandler.<span class="hljs-built_in">post</span>() / <span class="hljs-built_in">dispatch_async</span>(mainQueue)
  ⑤ 主线程 → Context: sendEvent → performOnContextQueue
  
同步调用（不经 UIScheduler，Context 线程直接执行并返回）：
  CalculateRenderViewSize、CreateShadow、SetTimeout 等
</code></pre>
<h3 data-id="heading-39">核心要点</h3>
<ol>
<li><strong>两条线程，各司其职</strong>：Context 线程负责全部 Kotlin 逻辑，主线程负责 Native View 操作</li>
<li><strong>所有 Kuikly 的 UI 类（View、Attr、Event、Observable）只能在 Context 线程访问</strong></li>
<li><strong>UIScheduler 是性能关键</strong>：收集 UI 指令、批量提交、减少线程切换次数</li>
<li><strong>同步方法 vs 异步方法</strong>：需要返回值的（如计算尺寸）同步执行，纯 UI 操作异步批量</li>
<li><strong>回到 Kuikly 线程</strong>：使用 <code>KuiklyContextScheduler.runOnKuiklyThread()</code> 或 <code>Dispatchers.Kuikly</code></li>
<li><strong>串行 = 安全</strong>：Context 线程是串行的，不存在并发竞争，不需要加锁</li>
</ol>
<p>理解了这条链路，你就掌握了 Kuikly 框架最核心的架构设计。无论是排查性能问题、理解页面加载慢的原因、还是正确处理异步逻辑，都能做到心中有数。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构]]></title>    <link>https://juejin.cn/post/7603958579180470272</link>    <guid>https://juejin.cn/post/7603958579180470272</guid>    <pubDate>2026-02-09T04:00:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180470272" data-draft-id="7603699739223932943" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构"/> <meta itemprop="keywords" content="iOS"/> <meta itemprop="datePublished" content="2026-02-09T04:00:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="山水域"/> <meta itemprop="url" content="https://juejin.cn/user/2260251635887309"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SKAdNetwork 6.0 深度实战：多窗口转化值（Conversion Value）建模与数据分层架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2260251635887309/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    山水域
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:00:32.000Z" title="Mon Feb 09 2026 04:00:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>摘要</strong>：随着 iOS 隐私政策的持续演进，SKAdNetwork (SKAN) 6.0 已成为移动营销衡量的新标准。本文将深入探讨 SKAN 6.0 的核心机制，重点解析如何针对三个转化窗口进行科学的转化值（CV）建模，并构建适配分层数据（Hierarchical Data）的归因架构，帮助高级 iOS 开发者与 AdTech 专家在隐私保护时代重构数据增长引擎。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、 SKAN 6.0：从“黑盒”到“多维度透明”</h2>
<p>SKAdNetwork 6.0（随 iOS 17.4+ 发布）在 4.0 的基础上进一步深化了隐私与效果的平衡。相比早期版本，SKAN 6.0 的核心进步在于通过<strong>多窗口回传（Multiple Postbacks）<strong>和</strong>分层源标识符（Hierarchical Source IDs）</strong>，提供了更长的生命周期观测能力和更灵活的数据粒度。</p>
<h3 data-id="heading-1">核心变化点：</h3>
<ol>
<li><strong>三段式转化窗口</strong>：
<ul>
<li><strong>Window 1 (P1)</strong>: 0-2 天，支持精细化（Fine-grained, 0-63）或粗略化（Coarse-grained）CV。</li>
<li><strong>Window 2 (P2)</strong>: 3-7 天，仅支持粗略化 CV。</li>
<li><strong>Window 3 (P3)</strong>: 8-35 天，仅支持粗略化 CV。</li>
</ul>
</li>
<li><strong>分层源标识符（Source ID）</strong>：从 2 位扩展到 4 位，根据人群匿名度（Crowd Anonymity）阶梯式释放数据。</li>
<li><strong>广告主域名（Advertising Domain）</strong>：增强了网页到 App 归因的安全性与透明度。</li>
</ol>
<hr/>
<h2 data-id="heading-2">二、 多窗口转化值（CV）建模策略</h2>
<p>在 SKAN 6.0 中，CV 建模不再是单一维度的映射，而是一场关于“时间”与“价值”的博弈。</p>
<h3 data-id="heading-3">2.1 Window 1 (P1)：精细化建模（0-63）</h3>
<p>P1 决定了初始出价模型的准确性。建议采用“收入+行为”混合模型：</p>
<ul>
<li><strong>Bits 0-3 (Value 0-15)</strong>：代表收入区间（e.g., <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">0, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"/><span class="mord">0</span><span class="mpunct">,</span></span></span></span></span>0.99-$4.99, ...）。</li>
<li><strong>Bits 4-5 (Value 16-63)</strong>：代表关键转化行为（e.g., 完成新手引导、加入购物车、订阅尝试）。</li>
</ul>
<h3 data-id="heading-4">2.2 Window 2 &amp; 3 (P2/P3)：粗略化建模（Low/Medium/High）</h3>
<p>由于仅支持三个档位，建模应侧重于<strong>长期留存</strong>与<strong>LTV 预测</strong>：</p>
<ul>
<li><strong>Low</strong>: 用户仅启动过 App（维持活跃）。</li>
<li><strong>Medium</strong>: 用户完成了中层转化（e.g., 累计在线时长 &gt; 10min 或 完成 3 次关卡）。</li>
<li><strong>High</strong>: 高价值行为（e.g., 再次复购或触发深度互动）。</li>
</ul>
<h3 data-id="heading-5">2.3 锁窗机制（LockWindow）的应用</h3>
<p>开发者可以通过 <code>lockWindow()</code> 提前锁定当前的转化窗口，以缩短数据回传的延迟。
<strong>实战建议</strong>：当用户触发了预期的最高价值行为（如首充）后立即锁窗，以最快速度将数据反馈给投放渠道。</p>
<hr/>
<h2 data-id="heading-6">三、 适配分层数据（Hierarchical Data）的架构设计</h2>
<p>SKAN 6.0 的数据产出取决于“人群匿名度”。这种不确定性要求服务端架构具备极强的鲁棒性。</p>
<h3 data-id="heading-7">3.1 数据分层接收流程</h3>
<ol>
<li><strong>捕获原始回传</strong>：服务端需能够处理不同粒度的 JSON。</li>
<li><strong>映射解析层</strong>：根据 <code>source-identifier</code> 的位数（2/3/4位）决定关联的广告层级（Campaign vs Ad Group vs Creative）。</li>
<li><strong>延迟修正模型</strong>：利用 Apple 定义的时间随机延迟（Window 1: 24-48h; Window 2/3: 24-144h）进行数据对齐。</li>
</ol>
<h3 data-id="heading-8">3.2 代码示例：更新转化值与锁定窗口（Swift）</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">import</span> StoreKit

<span class="hljs-keyword">func</span> <span class="hljs-title function_">updateSKANConversion</span>(<span class="hljs-params">revenue</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">isDeepConversion</span>: <span class="hljs-type">Bool</span>) {
    <span class="hljs-keyword">let</span> cvValue <span class="hljs-operator">=</span> calculateFineGrainedCV(revenue) <span class="hljs-comment">// 自定义映射逻辑</span>
    <span class="hljs-keyword">let</span> coarseValue: <span class="hljs-type">SKAdNetwork</span>.<span class="hljs-type">CoarseConversionValue</span> <span class="hljs-operator">=</span> revenue <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> <span class="hljs-operator">?</span> .high : .medium
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">16.1</span>, <span class="hljs-operator">*</span>) {
        <span class="hljs-type">SKAdNetwork</span>.updatePostbackConversionValue(cvValue, coarseValue: coarseValue) { error <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> error {
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"SKAN Update Failed: <span class="hljs-subst">\(error.localizedDescription)</span>"</span>)
            }
        }
        
        <span class="hljs-comment">// 如果是关键高价值行为，锁定窗口以加速回传</span>
        <span class="hljs-keyword">if</span> isDeepConversion {
            <span class="hljs-type">SKAdNetwork</span>.updatePostbackConversionValue(cvValue, coarseValue: coarseValue, lockWindow: <span class="hljs-literal">true</span>) { error <span class="hljs-keyword">in</span>
                <span class="hljs-comment">// 处理回调</span>
            }
        }
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-9">四、 总结与最佳实践</h2>
<ol>
<li><strong>组合建模</strong>：利用 P1 优化 CPI/tROAS，利用 P2/P3 观测用户留存。</li>
<li><strong>阈值监控</strong>：实时监控 <code>postback</code> 中的数据粒度，若频繁出现低位 Source ID，说明样本量不足以触发隐私阈值，需调整投放预算集中度。</li>
<li><strong>混合归因</strong>：将 SKAN 数据与自建的概率性归因（Probabilistic Attribution）进行交叉校验，构建更完整的用户画像。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开源 Claude Code + Codex + 面板 的未来vibecoding平台]]></title>    <link>https://juejin.cn/post/7604690250342809650</link>    <guid>https://juejin.cn/post/7604690250342809650</guid>    <pubDate>2026-02-09T05:38:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604690250342809650" data-draft-id="7604012106154983470" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开源 Claude Code + Codex + 面板 的未来vibecoding平台"/> <meta itemprop="keywords" content="前端,后端,GitHub"/> <meta itemprop="datePublished" content="2026-02-09T05:38:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="朱昆鹏"/> <meta itemprop="url" content="https://juejin.cn/user/2788017219055175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开源 Claude Code + Codex + 面板 的未来vibecoding平台
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2788017219055175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    朱昆鹏
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:38:55.000Z" title="Mon Feb 09 2026 05:38:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一句话介绍</h3>
<p><strong>CodeMoss</strong> =</p>
<ul>
<li>多AI联动：Claude Code + Codex + Gemini + OpenCode + ......</li>
<li>多端使用：客户端 + Jetbrains + Vscode + 移动端</li>
<li>多周边集成：AI面板 + AI记忆 + Superpowers + OpenSpec + Spec-kit + ...</li>
</ul>
<blockquote>
<p>说了这么多功能，直接放实机图更容易理解</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ca3a052d2b145e385c849123967241f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=nn0sfSGVe8SCmJhyegPUQthmaPQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7fe14972acb469084b0c60d0d558814~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=NU52DPK8Lm2G%2B9xpxbCw22iTjh0%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<blockquote>
<p>总之一句话：CodeMoss 目标打造 下一代的vibecoding 入口</p>
</blockquote>
<p>开源地址（感谢你的Star和推荐，这将让更多人用到）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhukunpenglinyutong%2Fcodemoss" target="_blank" title="https://github.com/zhukunpenglinyutong/codemoss" ref="nofollow noopener noreferrer">github.com/zhukunpengl…</a></p>
<hr/>
<h3 data-id="heading-1">详细介绍</h3>
<h5 data-id="heading-2">对话过程页面</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea4d23aabf7646c395e29b8a44a34b66~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=c3QPYmb1GfoFrytKQXFtsM9WhOg%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-3">侧边栏GIT模块</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06dd3656613146ccbb9cda85860b6a13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=LN762OBz34XAd3G4yrP3tn8u6hk%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-4">侧边栏文件管理模块</h5>
<blockquote>
<p>真的可以编辑哦~</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88d15377ba374873b9e4df738851cb05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=QFYzxbRbR1tCSuEzx6B6oWd9iTI%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-5">面板模式</h5>
<blockquote>
<p>这不是普通的面板哦~，是真的可以并行执行任务，有完整交互的AI面板哦~</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adfaccd9f8cb4b9a8a0abc47679939be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=PxJ4XU6%2BtRxC8ysMbkrTqhiX%2FYs%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/505c1c2cb910498db91cd4871fd4fdee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=cuz5SdkkWUFnZlAurLR8XArccoE%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-6">侧边栏展示</h5>
<blockquote>
<p>支持claude code + codex 多cli数据共同展示</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79209c020a4646e694c680e832bc3d2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=%2Fg9PkLAb06JrJzxT3vjnhm5oWIE%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-7">终端展示</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/304d9c7d34cc49e29ca1578418f392b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyx5piG6bmP:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220335&amp;x-signature=EWwAc4%2BchrQmw0Mccj995MNLkDk%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-8">支持多平台</h5>
<p>支持Mac 和 window 多平台</p>
<hr/>
<h3 data-id="heading-9">下载安装体验</h3>
<p>功能太多了，就不赘述了，大家可以下载之后自行探索</p>
<p>下载地址（纯开源，无商业，放心食用）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.codemoss.ai%2Fdownload" target="_blank" title="https://www.codemoss.ai/download" ref="nofollow noopener noreferrer">www.codemoss.ai/download</a></p>
<hr/>
<h3 data-id="heading-10">未来迭代</h3>
<p>目前虽然能用，但是细节打磨的还不满意，我至少会每天迭代一个版本，先迭代100个版本，欢迎大家使用提出问题</p>
<p>开源地址（感谢你的Star和推荐，这将让更多人用到）</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhukunpenglinyutong%2Fcodemoss" target="_blank" title="https://github.com/zhukunpenglinyutong/codemoss" ref="nofollow noopener noreferrer">github.com/zhukunpengl…</a></p>
<blockquote>
<p>再次声明：本项目完全开源，0商业，使用过程全程无广，请放心食用</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[5个实用Python小脚本，新手也能轻松实现（附完整代码）]]></title>    <link>https://juejin.cn/post/7603959423129042944</link>    <guid>https://juejin.cn/post/7603959423129042944</guid>    <pubDate>2026-02-09T03:16:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603959423129042944" data-draft-id="7603959423129026560" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="5个实用Python小脚本，新手也能轻松实现（附完整代码）"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-09T03:16:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="躺平大鹅"/> <meta itemprop="url" content="https://juejin.cn/user/2455634286221657"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            5个实用Python小脚本，新手也能轻松实现（附完整代码）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2455634286221657/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    躺平大鹅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:16:44.000Z" title="Mon Feb 09 2026 03:16:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>对于Python新手来说，学习语法的最终目的是“解决实际问题”，而简单的小脚本既能巩固基础语法，又能带来成就感，同时还能用到日常工作和学习中，一举三得。</p>
<p>今天分享5个实用的Python小脚本，覆盖文件处理、数据统计、日常工具等场景，每篇脚本都有完整代码和详细注释，新手复制就能运行，还能根据自己的需求修改优化，快速提升编程能力～</p>
<h3 data-id="heading-0">脚本一：文件批量重命名（批量修改文件名，高效便捷）</h3>
<p>适用场景：批量修改文件夹中的文件名称（比如批量修改图片、文档、代码文件的名称），避免手动逐个修改，节省时间。</p>
<p>核心知识点：os模块（文件操作）、for循环，掌握os.listdir()、os.rename()的用法。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os  <span class="hljs-comment"># 导入os模块，用于操作文件和文件夹</span>

<span class="hljs-comment"># 1. 定义要批量重命名的文件夹路径（替换成你的文件夹路径，注意路径中的反斜杠用//或/）</span>
folder_path = <span class="hljs-string">"D://test//images"</span>

<span class="hljs-comment"># 2. 获取文件夹中的所有文件（返回一个列表，包含所有文件名）</span>
file_list = os.listdir(folder_path)

<span class="hljs-comment"># 3. 循环遍历所有文件，逐个重命名</span>
<span class="hljs-keyword">for</span> index, file_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(file_list):
    <span class="hljs-comment"># 跳过文件夹（只重命名文件，不处理子文件夹）</span>
    <span class="hljs-keyword">if</span> os.path.isfile(os.path.join(folder_path, file_name)):
        <span class="hljs-comment"># 分割文件名和后缀（比如"1.jpg"分割成["1", "jpg"]）</span>
        file_ext = os.path.splitext(file_name)[<span class="hljs-number">1</span>]
        <span class="hljs-comment"># 定义新的文件名（比如"image_01.jpg"、"image_02.jpg"，index从0开始，+1让序号从1开始）</span>
        new_file_name = <span class="hljs-string">f"image_<span class="hljs-subst">{index+<span class="hljs-number">1</span>:02d}</span><span class="hljs-subst">{file_ext}</span>"</span>
        <span class="hljs-comment"># 拼接旧文件路径和新文件路径</span>
        old_path = os.path.join(folder_path, file_name)
        new_path = os.path.join(folder_path, new_file_name)
        <span class="hljs-comment"># 执行重命名操作</span>
        os.rename(old_path, new_path)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"已修改：<span class="hljs-subst">{file_name}</span> → <span class="hljs-subst">{new_file_name}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"批量重命名完成！"</span>)
    
</code></pre>
<p>💡 使用说明：替换folder_path为自己的文件夹路径，运行脚本，即可将文件夹中的文件批量命名为“image_01.后缀”“image_02.后缀”，序号自动递增。</p>
<h3 data-id="heading-1">脚本二：简单文本统计工具（统计字数、行数、空格数）</h3>
<p>适用场景：统计文本文件（.txt、.md等）的字数、行数、空格数，比如统计论文字数、笔记字数，无需手动计数。</p>
<p>核心知识点：文件读写（open()函数）、字符串操作、for循环。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. 定义要统计的文本文件路径（替换成你的文件路径）</span>
file_path = <span class="hljs-string">"D://test//note.txt"</span>

<span class="hljs-comment"># 2. 初始化统计变量</span>
line_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 行数</span>
char_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 总字符数（包含空格、标点）</span>
space_count = <span class="hljs-number">0</span> <span class="hljs-comment"># 空格数</span>
word_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 单词数（以空格分隔）</span>

<span class="hljs-comment"># 3. 打开文件，读取内容（encoding="utf-8"避免中文乱码）</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-comment"># 逐行读取文件内容</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
        line_count += <span class="hljs-number">1</span>  <span class="hljs-comment"># 每读一行，行数+1</span>
        space_count += line.count(<span class="hljs-string">" "</span>)  <span class="hljs-comment"># 统计当前行的空格数，累加到总空格数</span>
        char_count += <span class="hljs-built_in">len</span>(line.replace(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>))  <span class="hljs-comment"># 统计当前行的字符数（去掉换行符）</span>
        word_count += <span class="hljs-built_in">len</span>(line.split())  <span class="hljs-comment"># 统计当前行的单词数（以空格分隔）</span>

<span class="hljs-comment"># 4. 输出统计结果</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"文本文件统计结果："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总行数：<span class="hljs-subst">{line_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总字符数（不含换行符）：<span class="hljs-subst">{char_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总空格数：<span class="hljs-subst">{space_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"总单词数（以空格分隔）：<span class="hljs-subst">{word_count}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
    
</code></pre>
<p>💡 使用说明：替换file_path为自己的文本文件路径，运行脚本，即可快速得到文本的各项统计数据，支持中文文本。</p>
<h3 data-id="heading-2">脚本三：随机密码生成器（生成安全、复杂的密码）</h3>
<p>适用场景：生成随机密码（包含大小写字母、数字、特殊符号），用于注册账号、登录密码，比手动设置的密码更安全。</p>
<p>核心知识点：random模块（随机生成）、字符串拼接、for循环。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 导入random模块，用于生成随机数</span>
<span class="hljs-keyword">import</span> string  <span class="hljs-comment"># 导入string模块，获取大小写字母、数字、特殊符号</span>

<span class="hljs-comment"># 1. 定义密码包含的字符集（可根据需求修改，比如去掉特殊符号）</span>
<span class="hljs-comment"># 大小写字母 + 数字 + 特殊符号（!@#$%^&amp;*()_+-=）</span>
chars = string.ascii_letters + string.digits + <span class="hljs-string">"!@#$%^&amp;*()_+-="</span>

<span class="hljs-comment"># 2. 定义密码长度（可自定义，比如8位、12位、16位，越长越安全）</span>
password_length = <span class="hljs-number">12</span>

<span class="hljs-comment"># 3. 生成随机密码（从chars中随机选择password_length个字符，拼接成字符串）</span>
password = <span class="hljs-string">""</span>.join(random.choice(chars) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(password_length))

<span class="hljs-comment"># 4. 输出生成的密码</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成的随机密码：<span class="hljs-subst">{password}</span>"</span>)
    
</code></pre>
<p>💡 拓展优化：新手可以修改password_length，生成不同长度的密码；也可以修改chars，去掉不需要的字符（比如不需要特殊符号，就删除chars中的特殊符号部分）。</p>
<h3 data-id="heading-3">脚本四：批量提取文本中的邮箱地址</h3>
<p>适用场景：从大量文本中，批量提取所有邮箱地址（比如从文档、日志、网页源码中提取邮箱），避免手动查找，高效便捷。</p>
<p>核心知识点：re模块（正则表达式，用于匹配邮箱格式）、文件读写。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> re  <span class="hljs-comment"># 导入re模块，用于正则表达式匹配</span>

<span class="hljs-comment"># 1. 定义要提取邮箱的文本文件路径（替换成你的文件路径）</span>
file_path = <span class="hljs-string">"D://test//data.txt"</span>

<span class="hljs-comment"># 2. 定义邮箱正则表达式（匹配绝大多数邮箱格式，如xxx@xxx.com、xxx@xxx.cn）</span>
email_pattern = <span class="hljs-string">r"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+"</span>

<span class="hljs-comment"># 3. 读取文本文件内容</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
    text = f.read()  <span class="hljs-comment"># 读取整个文件的内容</span>

<span class="hljs-comment"># 4. 匹配文本中的所有邮箱地址，返回一个列表</span>
emails = re.findall(email_pattern, text)

<span class="hljs-comment"># 5. 输出提取结果</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"共提取到 <span class="hljs-subst">{<span class="hljs-built_in">len</span>(emails)}</span> 个邮箱地址："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span>*<span class="hljs-number">50</span>)
<span class="hljs-keyword">for</span> email <span class="hljs-keyword">in</span> emails:
    <span class="hljs-built_in">print</span>(email)
    
</code></pre>
<p>💡 使用说明：替换file_path为自己的文本文件路径，运行脚本，即可提取文本中所有符合格式的邮箱地址，适合批量处理大量文本。</p>
<h3 data-id="heading-4">脚本五：简易天气预报查询（输入城市，查询实时天气）</h3>
<p>适用场景：输入城市名称，查询该城市的实时天气（温度、天气状况、风力等），无需打开浏览器，直接运行脚本即可查询。</p>
<p>核心知识点：requests模块（发送网络请求）、JSON数据解析，新手需要先安装requests模块（命令：pip install requests）。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 导入requests模块，用于发送网络请求</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_weather</span>(<span class="hljs-params">city</span>):
    <span class="hljs-comment"># 免费天气接口（无需注册，直接使用，返回JSON格式数据）</span>
    url = <span class="hljs-string">f"https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=79334739&amp;appsecret=5S8IYq6Q&amp;city=<span class="hljs-subst">{city}</span>"</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 发送GET请求，获取天气数据</span>
        response = requests.get(url)
        response.raise_for_status()  <span class="hljs-comment"># 若请求失败，抛出异常</span>
        weather_data = response.json()  <span class="hljs-comment"># 解析JSON数据，转为字典</span>
        
        <span class="hljs-comment"># 提取需要的天气信息</span>
        city_name = weather_data[<span class="hljs-string">"city"</span>]  <span class="hljs-comment"># 城市名称</span>
        temp = weather_data[<span class="hljs-string">"tem"</span>]        <span class="hljs-comment"># 当前温度</span>
        weather = weather_data[<span class="hljs-string">"wea"</span>]     <span class="hljs-comment"># 天气状况（如晴、阴、雨）</span>
        wind = weather_data[<span class="hljs-string">"win"</span>]        <span class="hljs-comment"># 风力</span>
        humidity = weather_data[<span class="hljs-string">"humidity"</span>]<span class="hljs-comment"># 湿度</span>
        
        <span class="hljs-comment"># 输出天气信息</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"【<span class="hljs-subst">{city_name}</span> 实时天气预报】"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"当前温度：<span class="hljs-subst">{temp}</span>℃"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"天气状况：<span class="hljs-subst">{weather}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"风力：<span class="hljs-subst">{wind}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"湿度：<span class="hljs-subst">{humidity}</span>%"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"="</span>*<span class="hljs-number">30</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询失败！原因：<span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>)

<span class="hljs-comment"># 主程序</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 输入要查询的城市名称</span>
    city = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入要查询天气的城市（如北京、上海）："</span>)
    <span class="hljs-comment"># 调用函数，查询天气</span>
    get_weather(city)
    
</code></pre>
<p>💡 使用说明：</p>
<ol>
<li>
<p>先打开终端，输入命令 <code>pip install requests</code>，安装requests模块；</p>
</li>
<li>
<p>运行脚本，输入城市名称（如“北京”“广州”），即可查询该城市的实时天气。</p>
</li>
</ol>
<h3 data-id="heading-5">最后</h3>
<p>以上5个小脚本，都是日常能用得上的实用工具，同时覆盖了Python的核心基础知识点，新手可以先复制运行，理解每一行代码的含义，再尝试修改优化，比如给文件重命名脚本添加自定义前缀、给密码生成器添加密码强度检测等。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026版Java面试八股文总结（春招+秋招+社招），建议收藏。]]></title>    <link>https://juejin.cn/post/7604012106155049006</link>    <guid>https://juejin.cn/post/7604012106155049006</guid>    <pubDate>2026-02-09T05:46:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106155049006" data-draft-id="7604344066579939379" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026版Java面试八股文总结（春招+秋招+社招），建议收藏。"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-09T05:46:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026版Java面试八股文总结（春招+秋招+社招），建议收藏。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T05:46:59.000Z" title="Mon Feb 09 2026 05:46:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今年的行情，让招聘面试变得雪上加霜。已经有不少大厂，如腾讯、字节跳动的招聘名额明显减少，面试门槛却一再拔高，如果不用心准备，很可能就被面试官怼得哑口无言，甚至失去了难得的机会。</p>
<p>现如今，情势依然严峻，未来充满着不定性，想要跳槽涨薪的小伙伴，<strong>在面试前更是要做好充足的准备</strong>！</p>
<p>如果你<strong>参加过一些大厂面试，肯定会遇到一些这样</strong>的问题：</p>
<ul>
<li><strong>应届生</strong>：你该如何准备简历，面试项目和面试说辞？<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DSpring%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=Spring&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Spring</a> 底层逻辑是什么？</li>
<li><strong>1-3 年经验的程序员</strong>：面试中你该讲哪些值钱的技术？如何用这些值钱的技术最大程度展示自己的技能？分布式组件底层逻辑是什么？</li>
<li><strong>3-5 年经验的程序员</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3Dk8s%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=k8s&amp;zhida_source=entity" ref="nofollow noopener noreferrer">k8s</a> 怎么搭建实践？</li>
</ul>
<p>是不是看上去很难，是不是和自己准备的“题库”中的问题不一样？不知道从何处下手？</p>
<p>所以，要想在这个<strong>金三银四拿下心仪的Offer</strong>，咱就一定要做好准备，把那些必考点、套路都给吃透了！</p>
<p>今天为大家整理了Java工程师高级面试题及一些大厂Java开发面试宝典，面试经验技巧等，应届生，实习生，企业工作过的，都可参考学习！</p>
<h2 data-id="heading-0">Java基础—基础知识</h2>
<p><strong>一、八种基本数据类型的大小，以及他们的封装类。</strong><br/>
byte(Byte) 1 ，short(Short) 2 ,int(Integer) 4 ,long(Long) 8 ,float(Float) 4 ,double(Double)8,boolean(Boolean),char(Character)2</p>
<p><strong>二、Switch能否用string做参数？</strong><br/>
switch语句中的变量类型可以使byte，short，int，char。从jdk1.7后可以使用String类型，是通过switch中的String.hashcode将String转换成int进行判断的。</p>
<p><strong>三、equals与==的区别。</strong><br/>
==操作符是用来比较两个变量的值是否相等，即就是比较变量在内存中的存储地址是否相同，equals（）方法时String类从Object类中继承的，被用来检测两个对象的内容是否相同。</p>
<p><strong>四、String s=new String(‘xyz’);创建了几个object对象?</strong><br/>
会创建一个String类型的变量s。在类加载到此处之前没有出现“xyz”字面量的话，加载此处会创建一个对应“xyz”的String常量对象。在符合规范的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DJVM%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=JVM&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JVM</a>上，执行到此处new关键字会创建一个String对象。</p>
<blockquote>
<p>**这里也整理了Java架构学习资料，学习技术内容包含有：Spring，Dubbo，MyBatis, RPC,源码分析，高并发、高性能、分布式,性能优化，微服务 高级架构开发等等。有需要的可以直接扫一扫获取</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a0cccad521ae4c9e95692198613614b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220819&amp;x-signature=nR9y9IG5QD2cUsWLBpCVsq5LY6I%3D" alt="736abc1217fd502b3f31018e5d5eaa2.jpg" loading="lazy"/></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d500c9fc4f04ba6b1beaa431bdcfba3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771220819&amp;x-signature=Sk204espNAGqTCI%2Fod5fHZQ15C0%3D" alt="" loading="lazy"/></p>
<p><strong>五、 Object有哪些公用方法？</strong><br/>
1、clone()创建斌返回此对象的副本<br/>
2、equals()判断<br/>
3、getclass（）返回object的运行类<br/>
4、hashcode（）返回对象的哈希码值<br/>
5、notify（）唤醒正在等待对象监听器的单个进程<br/>
6、notifyAll（）唤醒正在等待对象监听器的所有进程<br/>
7、wait（）导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。<br/>
8、toString（）返回此对象的字符串表示形式<br/>
9、finalize（）当垃圾收集确定不需要该对象时，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">垃圾回收器</a>调用该方法</p>
<p><strong>六、Java的四种引用，强弱软虚，用到的场景。</strong><br/>
强引用：垃圾回收器不会回收<br/>
软引用：如果内存空间足够，垃圾回收器就不会进行回收，如果内存空间不足，垃圾回收器就会进行回收<br/>
弱引用：一旦发现了只有弱引用的对象，垃圾回收器就会进行回收。<br/>
虚引用：如果发现该对象还具有虚引用，就会在回收该对象之前，吧这个虚引用加入到与之关联的引用队列中。</p>
<p><strong>七、静态变量和实例变量的区别。</strong><br/>
静态变量前要加上关键字static，实例变量则不会。<br/>
实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。总之就是，静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。</p>
<p><strong>八、 Overload和Override的区别：</strong><br/>
重载Overload表示的是同一个类中可以有多个相同名称的方法，但这些方法的参数列表不同，即就是参数参数或参数类型不同。重载时返回值当然可以不一样，但是如果参数列表完全一致时，不能通过返回类型不一致而实现重载，这是不可以的。<br/>
重写Override表示子类中的方法可以与父类中的方法名称和参数完全相同，通过子类创建的对象来调用这个方法时，将调用子类中定义的方法，即就是子类中的该方法将父类的该方法覆盖了。子类覆盖父类方法时只能抛比父类更少或者更小的异常。重写的方法其返回必须和被覆盖的方法返回一致。</p>
<p><strong>九、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%258A%25BD%25E8%25B1%25A1%25E7%25B1%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">抽象类</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%258E%25A5%25E5%258F%25A3%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%8E%A5%E5%8F%A3&amp;zhida_source=entity" ref="nofollow noopener noreferrer">接口</a>的区别。</strong><br/>
抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在该类中添加实现的方法接口没有默认的方法进行实现，没有构造器，不可以使用main方法进行运行，在接口中添加方法时需要在具体实现的类中添加方法。</p>
<p><strong>十、String、StringBuffer与StringBuilder的区别。</strong><br/>
String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）方法和hashcode（）方法，而StringBuffer没有覆盖两个方法，，所以StringBuffer对象存储到java集合类中时会出现问题。<br/>
StringBulider也表示内容可以修改的字符串，但是其线程是不安全的，运行效率高。</p>
<p><strong>十一、 Java面向对象的特征与含义。</strong><br/>
封装、继承、抽象、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25A4%259A%25E6%2580%2581%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%A4%9A%E6%80%81&amp;zhida_source=entity" ref="nofollow noopener noreferrer">多态</a><br/>
1、封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动影响。封装是保证是把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和他操作的数据放在同一个类中。<br/>
2、抽象：抽象就是找出事物的相似和共性，然后将这些事物归为同一类，这个类只考虑这些事物的相似和共性，忽略和当前主题不相关的因素。<br/>
3、继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者是修改父类的内容而更加适合特殊的需要。提高了额程序的可重用性和可扩张性。<br/>
4、多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p><strong>十二、java多态的实现</strong><br/>
接口实现，继承父类进行方法重写，<br/>
同一个类中进行方法重载。</p>
<p><strong>十三、error和exception区别</strong><br/>
error表示有可能恢复但比较困难的的一种严重问题，程序是不能进行处理的exception表示一种设计或者实现问题。</p>
<p><strong>十四、运行时异常和一般异常的区别</strong><br/>
异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见的运行错误。java编译器要求方法必须声明抛出可能出现的非运行时异常，但是并不要求必须声明抛出未被捕获的异常</p>
<p><strong>十五、Java中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BC%2582%25E5%25B8%25B8%25E5%25A4%2584%25E7%2590%2586%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">异常处理机制</a>和简单原理和应用</strong><br/>
JAVA程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发 NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。</p>
<p><strong>十六、Java语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗?</strong><br/>
Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个<br/>
方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br/>
用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。<br/>
throw语句用来明确地抛出一个”异常”。<br/>
throws用来标明一个成员函数可能抛出的各种”异常”。<br/>
Finally为确保一段代码不管发生什么”异常”都被执行一段代码。<br/>
可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常”的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。</p>
<p><strong>十七、 try catch finally，try里有return，finally还执行么？</strong><br/>
1、finally语句总会执行<br/>
2、如果try、catch中有return语句，finally中没有return，那么在finally中修改除包装类型和静态变量、全局变量以外的数据都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量）<br/>
3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生。<br/>
4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略</p>
<p><strong>十八、 Java中final、finally和finalize的区别</strong><br/>
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br/>
内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……<br/>
finally是异常处理语句结构的一部分，表示总是执行。<br/>
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。</p>
<p><strong>十九、 常见的运行时异常</strong><br/>
系统异常是RuntimeException的子类，常见的系统异常有：<br/>
ArrayIndexOutOfBoundsException - 数组越界访问<br/>
ClassCastException - 类型转换异常<br/>
NullPointerException - 试图访问一空对象的变量、方法或空数组的元素<br/>
IllegalArgumentException - 方法的参数无效<br/>
NoClassDefFoundException - JAVA运行时系统找不到所引用的类</p>
<p><strong>二十、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3DCollection%25E6%25A1%2586%25E6%259E%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=Collection%E6%A1%86%E6%9E%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Collection框架</a>的结构</strong><br/>
集合框架(Collection Framework)泛指java.util包的若干个类和接口.如Collection,List,ArrayList,LinkedList,Vector(自动增长数组),HashSet,HashMap等。<br/>
集合框架中的类主要封装的是典型的数据结构,如动态数组,链表,堆栈,集合,哈希表等.<br/>
集合框架类似编程中经常用到的工具类,使得编码这专注于业务层的实现,不需要从底层实现相关细节—“数据结构的封装”和”典型算法的实现”。</p>
<p><strong>二十一、Collection包结构</strong><br/>
Collection是集合类的上级接口，是单列集合。继承他的接口主要有Set 和List.<br/>
Set接口的子接口有：HashSet，TreeSet<br/>
List接口的子接口有：Arraylist，LinkedList，Vector</p>
<p><strong>二十二、Collection与Collections的区别。</strong><br/>
Collection是集合类的上级接口，继承他的接口有Set和List<br/>
Collections是针对集合类的一个帮助类，它提供一系列的静态方法实现集合的搜索，排序，线程安全等操作。</p>
<p><strong>二十三、 Colection框架中实现比较要实现什么接口？</strong><br/>
comparable：只包含compareTo（）方法<br/>
comparator：compare（）和equals（）</p>
<p><strong>二十四、Map、Set、List、Queue、Stack的特点与用法。</strong><br/>
1、Map是以键值对的形式进行存储的，其中key是唯一不可重复的，value的可以重复，当插入的值是key相同，后加入的会将已有的覆盖。他有几个具体的实现类，包括Treemap和HashMap，TreeMap是有序的，HashMap是无序的。<br/>
2、List 有序，可重复<br/>
|–ArrayList<br/>
底层数据结构是数组，查询快，增删慢，线程不安全，效率高<br/>
|–Vector<br/>
底层数据结构是数组，查询快，增删慢，线程不安全，效率高<br/>
|–LinkedList<br/>
底层数据结构是链表，查询慢，增删块，线程安全，效率低<br/>
3、Set 无序，唯一<br/>
|–HashSet<br/>
底层数据结构是哈希表<br/>
如何保证元素的唯一性：<br/>
依赖两个方法，hashCode（）和equals（）<br/>
|–LinkedHashSet<br/>
底层数据结构是链表和哈希表，由链表保证元素有序，由哈希表保证元素唯一<br/>
|–TreeSet底层数据结构是红黑树，<br/>
如何保证元素的排序：<br/>
自然排序：让元素所属的类实现Comparable接口<br/>
比较器排序：让集合接收一个Comparator的实现类对象<br/>
如何保证元素的唯一性：<br/>
根据比较的返回值是否是0来决定的<br/>
4、Query队列遵循先进先出的原则，不允许插入null值，其中提供了相应的进队和出队的方法，建议使用offer（）方法来添加元素，使用poll（）方法删除元素<br/>
5、Stack遵从后进先出的原则，继承自Vector。他通过5个操作对Vector类进行扩展，它提供了push和pop操作，以及去堆栈顶点的peek（）方法，测试堆栈是否为空的empty方法<br/>
6、使用方法：<br/>
如果涉及到堆栈，队列等操作，建议使用List<br/>
对于快速插入和删除元素建议使用LinkedList<br/>
需要快速随机访问元素建议使用ArrayList</p>
<p><strong>二十五、 Set里面的元素不能重复，用什么方法区分重复与否？</strong><br/>
Set里的元素是唯一不能重复的，元素是否重复使用equals（）方法进行判断。<br/>
equals（）方法和==方法决定引用值是否指向同一对象equals（）在类中被覆盖，为的是两个分离的对象的内容和类型相匹配的话，返回真值。</p>
<p><strong>二十六、HashMap和Hashtable的区别。</strong><br/>
1、Hashtable是基于Dictionary类的，HashMap是Map接口的一个实现类<br/>
2、Hashtable是线程安全的，即是同步的；HashMap线程不是安全的，不是同步的。<br/>
3、HashMap可以将空值作为key或value</p>
<p><strong>二十七、 HashMap、LinkedHashMap、TreeMap的区别。</strong><br/>
1、HashMap是根据键的hashcode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，取得的数据完全是随机的<br/>
2、LinkedHashMap保存了记录的插入顺序，在使用Iterator进行遍历的时候，先得到的肯定是先插入的数据，可以在构造时带参数，按照应用次数来进行排序<br/>
3、TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认的是升序排序，也可以指定排序的比较器，进行遍历的时候得到的是排序过的记录。</p>
<p><strong>二十八、HashMap、LinkedHashMap、ConcurrentHashMap、ArrayList、LinkedList的底层实现。</strong><br/>
1、HashMap是java数据结构中两大结构数组和链表的组合。HashMap底层数组，数组中的每一项又是一个链表。程序会先根据key的hashcode（）方法返回值决定该Entry在数组中的<br/>
存储位置，如果该位置上没有元素，就会将元素放置在此位置上，如果两个Entry的key相同，会调用equals，返回值是true则覆盖原来的value值，返回false则会形成Entry链，位于头部。<br/>
2、ArrrayList的底层实现是数组，在执行add操作时，会先检查数组 大小是否可以容纳新的元素，如果不够就会进行扩容。然后会将原来的数据拷贝到新的数组中。<br/>
3、LinkedList底层是一个链表，其实现增删改查和数据结构中的操作完全相同，而且插入是有序的。<br/>
4、LinkedHashMap的底层结构式是双链表，其他的逻辑处理与HashMap一致，同样没有锁保护，多线程使用时存在风险。<br/>
5、ConcurrentHashMap是segment数组结构和HashEntry数组结构组成的，segment在ConcurrentHashMap中充当锁的角色，HashEntry用于存储键值对数据。segment的结构是数组和链表，一个segment中有一个HashEntry，每个HashEntry是一个链表结构的元素。对HashEntry中的数据进行修改时，需要先获得它所对应的segment锁。每个ConcurrentHashMap默认有16个segment。</p>
<p><strong>二十九、迭代器Iterator</strong><br/>
Iterator提供了统一遍历操作集合元素的统一接口，Collection接口实现Iterator接口。每个集合都通过实现Iterator接口中的iterator（）方法返回实例，然后对元素进行迭代操作，但是在迭代元素的时候不能使用集合的方法删除元素，否则会抛出异常，可以使用Iterator接口中的remove（）方法进行删除。</p>
<p><strong>三十、 快速失败（fail-fast）和安全失败（fail-safe）的区别。</strong><br/>
Iterator的安全失败是基于对底层集合做拷贝，因此它不受源集合修改的影响。util包下的所有集合类都是快速失败的，util.concurren包下面的所有类都是安全失败的。<br/>
Java基础—集合框架/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%25B3%259B%25E5%259E%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B3%9B%E5%9E%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">泛型</a>/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270136242%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25AE%25B9%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270136242&amp;content_type=Article&amp;match_order=1&amp;q=%E5%AE%B9%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">容器</a><br/>
<strong>概念</strong><br/>
一、容器（Container）Spring 提供容器功能，容器可以管理对象的生命周期、对象与对象之间的依赖关系，您可以使用一个配置文件（通常是 XML），在上面定义好对象的名称、如何产生（Prototype 方式或 Singleton 方式）、哪个对象产生之后必须设定成为某个对象的属性等，在启动容器之后，所有的对象都可以直接取用，不用编写任何一行程序代码来产生对象，或是建立对象与对象之间的依赖关系。换个更直白点的说明方式：容器是一个 Java 所编写的程序，原先必须自行编写程序以管理对象关系，现在容器都会自动帮您作好。常用容器：WebSphere,WebLogic,Resin,Tomcat。<br/>
<strong>容器类</strong><br/>
容器类 其实就是一种用来存储数据的数据结构，在 JAVA 中容器可分为即 “集合”（Set）、“列表”(List)、“映射”(Map)。至于，为什么需要容器，总的来说，主要是在以数组作为数据的存储结构中，其长度难以扩充，同时数组中元素类型必须相同。而容器可以弥补数组的这两个缺陷。<br/>
Java 容器类包含 List、ArrayList、Vector 及 map、HashTable、HashMap。<br/>
ArrayList 和 HashMap 是异步的，Vector 和 HashTable 是同步的，所以 Vector 和 HashTable 是线程安全的，而 ArrayList 和 HashMap 并不是线程安全的。因为同步需要花费机器时间，所以 Vector 和 HashTable 的执行效率要低于 ArrayList 和 HashMap。</p>
<h2 data-id="heading-1"><strong>二、集合框架的说明</strong></h2>
<p>所有集合类都位于 java.util 包下。Java 的集合类主要由两个接口派生而出：Collection 和 Map，Collection 和 Map 是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。<br/>
1.Set、List 和 Map 可以看做集合的三大类：<br/>
2.List 集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。<br/>
Set 集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。<br/>
3.Map 集合中保存 Key-value 对形式的元素，访问时只能根据每项元素的 key 来访问其 value。</p>
<h2 data-id="heading-2"><strong>三、集合框架详细说明</strong></h2>
<p>1、Collection 是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection 包含了 List 和 Set 两大分支。</p>
<ul>
<li>List 是一个 有序的队列，每一个元素都有它的索引。第一个元素的索引值是 0。List 的实现类有 LinkedList, ArrayList, Vector, Stack。</li>
<li>Set 是一个不允许有重复元素的集合。Set 的实现类有 HastSet 和 TreeSet。 HashSet 依赖于 HashMap，它实际上是通过 HashMap 实现的；TreeSet 依赖于 TreeMap，它实际上是通过 TreeMap 实现的。</li>
</ul>
<p>2、Map 是一个映射接口，即 key-value 键值对。Map 中的每一个元素包含 “一个 key” 和 “key 对应的 value”。AbstractMap 是个抽象类，它实现了 Map 接口中的大部分 API。而 HashMap，TreeMap，WeakHashMap 都是继承于 AbstractMap。Hashtable 虽然继承于 Dictionary，但它实现了 Map 接口。</p>
<p>3、接下来，再看 Iterator。它是遍历集合的工具，即我们通常通过 Iterator 迭代器来遍历集合。我们说 Collection 依赖于Iterator，是因为 Collection 的实现类都要实现 iterator () 函数，返回一个 Iterator 对象。ListIterator 是专门为遍历 List 而存在的。</p>
<p>4、再看 Enumeration，它是 JDK 1.0 引入的抽象类。作用和 Iterator 一样，也是遍历集合；但是 Enumeration 的功能要比 Iterator 少。在上面的框图中， Enumeration 只能在 Hashtable, Vector, Stack 中使用。</p>
<p>5、最后，看 Arrays 和 Collections。它们是操作数组、集合的两个工具类。</p>
<h2 data-id="heading-3">Java基础—多线程</h2>
<p>一、多线程基本概念<br/>
二、线程相关的常用方法<br/>
三、继承Thread类<br/>
四、实现Runnable 接口<br/>
五、Java 分为两种线程：用户线程和守护线程<br/>
六、用户线程就是前台线程，守护线程就是后台线程<br/>
七、什么是可重入锁？<br/>
八、Lock 与 synchronized 的不同<br/>
九、synchronized的使用<br/>
十、atomic 包底层实现原理<br/>
十一、Lock底层原理<br/>
十二、多线程不安全的底层原因以及两种加锁方式的区别<br/>
十三、Java多线程中 的各种锁<br/>
十四、Java多线程中 的各种锁（补充）<br/>
十五、阻塞队列BlockingQueue<br/>
十六、Java线程池、Java线程池进阶、Java中的ThreadLocal</p>
<h2 data-id="heading-4">Java基础—框架基础：注解/反射/流行框架</h2>
<p>一、优化 Hibernate 所鼓励的7大措施<br/>
二、序列化和反序列化<br/>
三、Java中池的概念<br/>
四、Java反射<br/>
五、Spring的IOC和AOP概念和实现原理<br/>
六、 仿照 Spring 实现简单的 IOC<br/>
七、仿照 Spring 实现简单的 AOP<br/>
八、Spring bean 的生命流程<br/>
九、仿写Spring 进阶之 AOP和IOC协作</p>
<h2 data-id="heading-5">Java基础—面向对象：继承/多态/封装</h2>
<p>一、重写与重载<br/>
二、单继承和多继承<br/>
三、多态<br/>
四、super和this关键字</p>
<h2 data-id="heading-6">Java基础—设计模式</h2>
<p>一、单例模式之懒汉式和饿汉式<br/>
二、设计模式之观察者模式<br/>
三、设计模式之工厂模式<br/>
四、设计模式之代理模式</p>
<h2 data-id="heading-7">Java基础—JVM/类加载</h2>
<p>一、初始化执行代码顺序（包含static块和构造块）以及类方法和实例方法<br/>
二、JVM内存结构<br/>
三、JVM组成部分<br/>
四、类加载机制<br/>
五、类加载器<br/>
六、Java类加载器之间的关系<br/>
七、虚拟机中的对象<br/>
八、虚拟机 分配内存<br/>
九、Java中的引用类型<br/>
十、JVM如何判断是否回收对象<br/>
十一、垃圾回收算法<br/>
十二、JVM运行时数据区域<br/>
十三、JVM垃圾收集器<br/>
十四、JVM垃圾回收<br/>
十五、Java中的内存泄露和内存溢出</p>
<h2 data-id="heading-8">Java基础——I/O</h2>
<p>一、I/O 基本概念<br/>
二、I/O 模型 ——阻塞、非阻塞、多路复用、异步<br/>
三、JAVA中 BIO 与 NIO、AIO</p>
<h2 data-id="heading-9">网络编程和计网</h2>
<p>一、Java中的原码、反码和补码<br/>
二、forward 和 redirect<br/>
三、URL的组成<br/>
四、通信的基础——IP、DNS、MAC地址<br/>
五、关于ip地址的理解<br/>
六、GFW（中国防火长城）工作原理<br/>
七、OSI七层模型和 五层体系结构<br/>
八、TCP 三次握手和四次挥手协议<br/>
九、TCP协议 （可靠保证、TCP、UDP、拥塞、ARQ）<br/>
十、HTTP 和 HTTPS<br/>
十一、Http/1.0、Http/1.1、Http2<br/>
十二、Https 加密过程详解<br/>
十三、HTTP协议的补充（POST、GET请求方法、幂等性）<br/>
十四、网络攻击（XSS、CSRF）详解<br/>
十五、DDoS 攻击详解<br/>
十六、SQL注入攻击详解</p>
<h2 data-id="heading-10">数据库</h2>
<p>一、结果集 (ResultSet)全面解析<br/>
二、基本概念<br/>
三、索引<br/>
四、事务<br/>
五、存储引擎<br/>
六、数据库优化<br/>
七、数据库锁<br/>
八、主从复制和读写分离</p>
<h2 data-id="heading-11">操作系统</h2>
<p>一、线程进程部分<br/>
二、内存和中断<br/>
三、互斥和同步<br/>
四、Linux相关命令<br/>
五、Linux IO 模式及 select、poll、epoll 详解</p>
<h2 data-id="heading-12">数据结构</h2>
<p>一、链表、数组、字符、树篇<br/>
二、堆、栈、队列篇<br/>
三、B树、B+树、B*树<br/>
四、Java实现排序算法，比较时间复杂度<br/>
五、红黑树<br/>
六、数据结构之栈<br/>
七、搜索与回溯算法-Java实现<br/>
八、高效判断一个数，是不是素数</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python3基础：基础实战巩固，从“会用”到“活用”]]></title>    <link>https://juejin.cn/post/7604093823958614035</link>    <guid>https://juejin.cn/post/7604093823958614035</guid>    <pubDate>2026-02-09T04:34:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958614035" data-draft-id="7604175912480800774" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python3基础：基础实战巩固，从“会用”到“活用”"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2026-02-09T04:34:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="怒放吧德德"/> <meta itemprop="url" content="https://juejin.cn/user/2502950820787672"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python3基础：基础实战巩固，从“会用”到“活用”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2502950820787672/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    怒放吧德德
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:34:30.000Z" title="Mon Feb 09 2026 04:34:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">第七阶段：基础实战巩固，从“会用”到“活用”</h2>
<blockquote>
<p>😄生命不息，写作不止</p>
<p>🔥 继续踏上学习之路，学之分享笔记</p>
<p>👊 总有一天我也能像各位大佬一样</p>
<p>🏆 <a href="https://juejin.cn/user/2502950820787672" target="_blank" title="https://juejin.cn/user/2502950820787672">博客首页</a>   <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Flyd-code%2F" target="_blank" title="https://www.cnblogs.com/lyd-code/" ref="nofollow noopener noreferrer">@怒放吧德德</a>  <a href="https://link.juejin.cn?target=https%3A%2F%2Flydandtry.github.io%2F" target="_blank" title="https://lydandtry.github.io/" ref="nofollow noopener noreferrer">To记录领地</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_43843951%3Ftype%3Dblog" target="_blank" title="https://blog.csdn.net/qq_43843951?type=blog" ref="nofollow noopener noreferrer">@一个有梦有戏的人</a></p>
<p>🌝分享学习心得，欢迎指正，大家一起学习成长！</p>
<p>🔥豆包AI</p>
</blockquote>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德(掘金) @一个有梦有戏的人(CSDN)</strong></p>
<h3 data-id="heading-1">前言</h3>
<p>恭喜大家成功通关Python3基础学习第六阶段「进阶基础」！在第六阶段，我们掌握了模块与包、文件操作、异常处理、面向对象基础四大核心技能，终于跳出了“单纯记语法”的范畴，具备了编写模块化、健壮性代码的能力。</p>
<p>而第七阶段「基础实战巩固」，是Python基础学习中“承上启下”的关键一环——核心目标不是学习新的复杂语法，而是<strong>将前六阶段的所有知识点串联起来，通过实战场景落地应用</strong>，帮大家摆脱“看得懂、写不出”的困境，巩固基础、查漏补缺，同时掌握常用工具（内置函数、标准库）和基础并发/网络能力，为后续学习复杂项目、框架打下坚实的实战基础。</p>
<p>本阶段我们将聚焦四大实战方向，全程围绕“实战场景+可运行代码+避坑实战”展开，每个知识点都结合前阶段内容设计实战案例，跟着敲代码、练案例，既能巩固旧知识，又能掌握新工具，真正实现从“会用”到“活用”的跨越，稳步向“能独立编写简单项目的Python初学者”迈进～</p>
<h3 data-id="heading-2">1 常用内置函数：Python自带的“实用工具”，提升编码效率</h3>
<p>在前面的学习中，我们其实已经零散用到过一些内置函数（比如print()、input()），但Python自带了大量无需导入、直接可用的内置函数，它们就像“现成的工具”，能帮我们快速解决常见问题（比如计算长度、生成序列、筛选数据），避免重复编写代码。</p>
<p>本阶段重点掌握8个高频实用的内置函数，覆盖日常编码80%的场景，结合实战案例讲解，重点理解“什么时候用、怎么用”，而非死记硬背。</p>
<h4 data-id="heading-3">1.1 核心内置函数</h4>
<p>每个函数均搭配“语法解析+实战代码+场景说明”，代码可直接复制运行，贴合新手实战需求：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. len()：计算可迭代对象的长度（字符串、列表、字典、元组等）</span>
<span class="hljs-comment"># 实战场景：统计用户输入的字符数、列表中元素个数</span>
str1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入一段文字："</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"输入文字的长度（含空格）：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(str1)}</span>"</span>)

list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"Python"</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"列表的元素个数：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(list1)}</span>"</span>)  <span class="hljs-comment"># 输出5（嵌套列表算1个元素）</span>

dict1 = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">18</span>, <span class="hljs-string">"gender"</span>: <span class="hljs-string">"男"</span>}
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"字典的键值对个数：<span class="hljs-subst">{<span class="hljs-built_in">len</span>(dict1)}</span>"</span>)  <span class="hljs-comment"># 输出3</span>

<span class="hljs-comment"># 2. range()：生成指定范围的整数序列（左闭右开）</span>
<span class="hljs-comment"># 实战场景：配合for循环实现固定次数的迭代（替代手动写列表）</span>
<span class="hljs-comment"># 语法：range(开始值, 结束值, 步长)，开始值默认0，步长默认1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成0-9的整数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))  <span class="hljs-comment"># 输出[0,1,2,...,9]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成1-10的整数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)))  <span class="hljs-comment"># 输出[1,2,...,10]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"生成1-10的奇数："</span>, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)))  <span class="hljs-comment"># 步长2，输出[1,3,...,9]</span>

<span class="hljs-comment"># 实战：用range()循环打印1-5的平方（结合前阶段的循环、函数）</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{i}</span>的平方：<span class="hljs-subst">{i**<span class="hljs-number">2</span>}</span>"</span>)

<span class="hljs-comment"># 3. enumerate()：遍历可迭代对象时，同时获取索引和对应的值</span>
<span class="hljs-comment"># 实战场景：遍历列表/元组时，需要知道元素的位置（避免手动定义索引变量）</span>
<span class="hljs-comment"># 语法：enumerate(可迭代对象, start=起始索引)，start默认0</span>
fruits = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>, <span class="hljs-string">"橙子"</span>, <span class="hljs-string">"葡萄"</span>]
<span class="hljs-comment"># 默认start=0，索引从0开始</span>
<span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"索引<span class="hljs-subst">{index}</span>：<span class="hljs-subst">{value}</span>"</span>)
<span class="hljs-comment"># start=1，索引从1开始（适合计数场景）</span>
<span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits, start=<span class="hljs-number">1</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"第<span class="hljs-subst">{index}</span>个水果：<span class="hljs-subst">{value}</span>"</span>)

<span class="hljs-comment"># 4. zip()：将多个可迭代对象（列表、元组等）“配对”，合并成一个迭代器</span>
<span class="hljs-comment"># 实战场景：批量处理多组关联数据（比如姓名和年龄、学号和成绩）</span>
names = [<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>]
ages = [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>]
scores = [<span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">95</span>]

<span class="hljs-comment"># 配对多个列表，遍历获取关联数据</span>
<span class="hljs-keyword">for</span> name, age, score <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, ages, scores):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"姓名：<span class="hljs-subst">{name}</span>，年龄：<span class="hljs-subst">{age}</span>，成绩：<span class="hljs-subst">{score}</span>"</span>)

<span class="hljs-comment"># 补充：zip()返回的是迭代器，可转换为列表查看</span>
zip_result = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(names, ages))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"zip配对结果："</span>, zip_result)  <span class="hljs-comment"># 输出[('张三',18), ('李四',19), ('王五',20)]</span>

<span class="hljs-comment"># 5. sorted()：对可迭代对象进行排序，返回排序后的新列表（不改变原对象）</span>
<span class="hljs-comment"># 实战场景：对列表、元组、字典的值进行排序</span>
nums = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
sorted_nums = <span class="hljs-built_in">sorted</span>(nums)  <span class="hljs-comment"># 默认升序</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"升序排序："</span>, sorted_nums)  <span class="hljs-comment"># 输出[1,2,3,4,5]</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"原列表（未改变）："</span>, nums)  <span class="hljs-comment"># 输出[3,1,4,2,5]</span>

<span class="hljs-comment"># 降序排序，指定reverse=True</span>
sorted_nums_desc = <span class="hljs-built_in">sorted</span>(nums, reverse=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"降序排序："</span>, sorted_nums_desc)

<span class="hljs-comment"># 实战：对字典按值排序（结合前阶段的字典知识）</span>
score_dict = {<span class="hljs-string">"张三"</span>: <span class="hljs-number">90</span>, <span class="hljs-string">"李四"</span>: <span class="hljs-number">85</span>, <span class="hljs-string">"王五"</span>: <span class="hljs-number">95</span>}
<span class="hljs-comment"># 按成绩升序排序，返回包含元组的列表</span>
sorted_score = <span class="hljs-built_in">sorted</span>(score_dict.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">"按成绩升序排序："</span>, sorted_score)

<span class="hljs-comment"># 6. map()：对可迭代对象的每个元素，应用指定函数，返回迭代器</span>
<span class="hljs-comment"># 实战场景：批量处理数据（比如所有元素平方、转换数据类型）</span>
<span class="hljs-comment"># 示例1：将列表中所有整数转换为字符串</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
str_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"整数转字符串："</span>, str_nums)  <span class="hljs-comment"># 输出['1','2','3','4','5']</span>

<span class="hljs-comment"># 示例2：计算列表中所有元素的平方（结合lambda匿名函数）</span>
square_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"所有元素平方："</span>, square_nums)  <span class="hljs-comment"># 输出[1,4,9,16,25]</span>

<span class="hljs-comment"># 7. filter()：对可迭代对象的元素进行筛选，保留符合条件的元素</span>
<span class="hljs-comment"># 实战场景：筛选符合要求的数据（比如筛选偶数、筛选大于某个值的元素）</span>
<span class="hljs-comment"># 示例1：筛选列表中的偶数</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
even_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"筛选偶数："</span>, even_nums)  <span class="hljs-comment"># 输出[2,4,6]</span>

<span class="hljs-comment"># 示例2：筛选列表中大于3的元素</span>
greater_3 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">3</span>, nums))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"筛选大于3的元素："</span>, greater_3)  <span class="hljs-comment"># 输出[4,5,6]</span>

<span class="hljs-comment"># 8. abs()：返回数字的绝对值</span>
<span class="hljs-comment"># 实战场景：处理负数（比如计算距离、误差，绝对值避免负号影响）</span>
num1 = -<span class="hljs-number">5</span>
num2 = <span class="hljs-number">3.14</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"-5的绝对值：<span class="hljs-subst">{<span class="hljs-built_in">abs</span>(num1)}</span>"</span>)  <span class="hljs-comment"># 输出5</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"3.14的绝对值：<span class="hljs-subst">{<span class="hljs-built_in">abs</span>(num2)}</span>"</span>)  <span class="hljs-comment"># 输出3.14</span>
</code></pre>
<h4 data-id="heading-4">1.2 新手避坑指南</h4>
<ul>
<li>避坑1：len()计算嵌套列表时，嵌套的子列表算“1个元素”，不会递归计算子列表内部的长度；</li>
<li>避坑2：range()是“左闭右开”区间，比如range(1, 10)生成1-9的整数，不会包含10；步长为负数时，开始值要大于结束值（比如range(10, 0, -1)生成10-1）；</li>
<li>避坑3：enumerate()的start参数只是“修改索引的显示值”，不会改变元素本身的位置；</li>
<li>避坑4：zip()会以“最短的可迭代对象”为准配对，多余的元素会被舍弃（比如3个姓名、2个年龄，会只配对前2组）；且zip()返回的迭代器只能遍历一次，再次遍历会为空；</li>
<li>避坑5：sorted()会返回新列表，不会修改原对象；而列表自带的sort()方法会修改原列表，无返回值（新手易混淆两者）；</li>
<li>避坑6：map()和filter()返回的是迭代器，需转换为列表（list()）才能直观查看结果。</li>
</ul>
<h3 data-id="heading-5">2 简单标准库使用：活用Python自带“工具包”，高效编码</h3>
<p>在第六阶段，我们学习了模块与包的基础用法，而Python自带的“标准库”，就是一组官方编写的、无需额外安装的实用模块集合。它们覆盖了数学计算、随机数生成、时间处理等常见场景，熟练使用这些标准库，能大幅提升编码效率，避免重复造轮子。</p>
<p>本阶段重点掌握3个最常用的标准库（math、random、time），结合实战场景讲解核心用法，不深入复杂功能，聚焦“新手能快速上手、日常能用得上”的知识点。</p>
<h4 data-id="heading-6">2.1 math库：数学计算工具，解决基础数学问题</h4>
<p>math库提供了大量基础数学运算函数（如圆周率、三角函数、取整、开平方等），适合解决日常编程中的数学计算场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> math  <span class="hljs-comment"># 导入math库（无需安装，直接导入）</span>

<span class="hljs-comment"># 1. 常用常量（实战常用）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"圆周率π："</span>, math.pi)  <span class="hljs-comment"># 输出3.141592653589793</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"自然常数e："</span>, math.e)  <span class="hljs-comment"># 输出2.718281828459045</span>

<span class="hljs-comment"># 2. 基础运算（实战重点）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"16的平方根："</span>, math.sqrt(<span class="hljs-number">16</span>))  <span class="hljs-comment"># 输出4.0（开平方）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"2的3次方："</span>, math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 输出8.0（幂运算，等同于2**3）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"绝对值："</span>, math.fabs(-<span class="hljs-number">5.2</span>))  <span class="hljs-comment"># 输出5.2（绝对值，比abs()更适合浮点数）</span>

<span class="hljs-comment"># 3. 取整函数（新手易混淆，重点区分）</span>
num = <span class="hljs-number">3.7</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向下取整（&lt;=3.7的最大整数）："</span>, math.floor(num))  <span class="hljs-comment"># 输出3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向上取整（&gt;=3.7的最小整数）："</span>, math.ceil(num))  <span class="hljs-comment"># 输出4</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"四舍五入（保留整数）："</span>, <span class="hljs-built_in">round</span>(num))  <span class="hljs-comment"># 输出4（round是内置函数，非math库）</span>

num2 = <span class="hljs-number">3.1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向下取整："</span>, math.floor(num2))  <span class="hljs-comment"># 输出3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"向上取整："</span>, math.ceil(num2))  <span class="hljs-comment"># 输出4</span>

<span class="hljs-comment"># 4. 实战案例：计算圆的周长和面积（结合前阶段的函数知识）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_circle</span>(<span class="hljs-params">radius</span>):
    <span class="hljs-string">"""计算圆的周长和面积"""</span>
    <span class="hljs-keyword">if</span> radius&lt;= <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"半径必须为正数！"</span>)
        <span class="hljs-keyword">return</span>
    circumference = <span class="hljs-number">2</span> * math.pi * radius  <span class="hljs-comment"># 周长公式：2πr</span>
    area = math.pi * math.<span class="hljs-built_in">pow</span>(radius, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 面积公式：πr²</span>
    <span class="hljs-keyword">return</span> circumference, area

<span class="hljs-comment"># 调用函数，获取结果</span>
circum, area = calc_circle(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"半径为3的圆：周长=<span class="hljs-subst">{<span class="hljs-built_in">round</span>(circum, <span class="hljs-number">2</span>)}</span>，面积=<span class="hljs-subst">{<span class="hljs-built_in">round</span>(area, <span class="hljs-number">2</span>)}</span>"</span>)  <span class="hljs-comment"># 保留2位小数</span>
</code></pre>
<h4 data-id="heading-7">2.2 random库：随机数工具，实现随机场景</h4>
<p>random库用于生成随机数、随机选择、随机打乱等操作，适合抽奖、验证码生成、随机分组等实战场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 导入random库</span>

<span class="hljs-comment"># 1. 生成随机浮点数（0.0 &lt;= 浮点数 &lt; 1.0）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机浮点数（0-1）："</span>, random.random())

<span class="hljs-comment"># 2. 生成随机整数（左闭右开，包含start和end）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机整数（1-10）："</span>, random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机整数（0-9，步长2）："</span>, random.randrange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 只生成偶数</span>

<span class="hljs-comment"># 3. 随机选择（实战常用）</span>
<span class="hljs-comment"># 从序列中随机选择1个元素</span>
fruits = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>, <span class="hljs-string">"橙子"</span>, <span class="hljs-string">"葡萄"</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机选择1个水果："</span>, random.choice(fruits))

<span class="hljs-comment"># 从序列中随机选择多个不重复元素（比如抽奖选3人）</span>
nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>))  <span class="hljs-comment"># 1-20的整数</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"随机选择3个不重复数字："</span>, random.sample(nums, <span class="hljs-number">3</span>))

<span class="hljs-comment"># 4. 随机打乱（原地打乱列表，修改原对象）</span>
random.shuffle(fruits)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"打乱后的水果列表："</span>, fruits)

<span class="hljs-comment"># 5. 实战案例：生成6位数字验证码（实战高频场景）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_verify_code</span>():
    <span class="hljs-string">"""生成6位数字验证码"""</span>
    code = <span class="hljs-string">""</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):
        <span class="hljs-comment"># 生成0-9的随机整数，转换为字符串拼接</span>
        code += <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>))
    <span class="hljs-keyword">return</span> code

<span class="hljs-comment"># 调用函数，生成验证码</span>
verify_code = generate_verify_code()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"6位数字验证码："</span>, verify_code)
</code></pre>
<h4 data-id="heading-8">2.3 time库：时间工具，处理时间相关场景</h4>
<p>time库用于获取当前时间、格式化时间、设置程序延迟等操作，适合日志记录、程序计时、延迟执行等实战场景，核心用法如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time  <span class="hljs-comment"># 导入time库</span>

<span class="hljs-comment"># 1. 获取当前时间（三种常用格式）</span>
<span class="hljs-comment"># 格式1：时间戳（从1970年1月1日00:00:00到当前的秒数，浮点数）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间戳："</span>, time.time())

<span class="hljs-comment"># 格式2：结构化时间（包含年、月、日、时、分、秒等信息）</span>
struct_time = time.localtime()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"结构化时间："</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前年份："</span>, struct_time.tm_year)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前月份："</span>, struct_time.tm_mon)

<span class="hljs-comment"># 格式3：格式化时间（人类可读，常用）</span>
<span class="hljs-comment"># 常用占位符：%Y（4位年份）、%m（2位月份）、%d（2位日期）、%H（24小时制）、%M（分钟）、%S（秒）</span>
format_time1 = time.strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间（年-月-日 时:分:秒）："</span>, format_time1)

format_time2 = time.strftime(<span class="hljs-string">"%Y年%m月%d日 %H时%M分%S秒"</span>, struct_time)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"当前时间（中文格式）："</span>, format_time2)

<span class="hljs-comment"># 2. 程序延迟执行（sleep(秒数)，实战常用）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"程序开始执行..."</span>)
time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 延迟2秒（让程序暂停2秒再执行后续代码）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"延迟2秒后，程序继续执行..."</span>)

<span class="hljs-comment"># 3. 实战案例：计算代码执行时间（优化代码常用）</span>
start_time = time.time()  <span class="hljs-comment"># 记录开始时间（时间戳）</span>

<span class="hljs-comment"># 模拟一段需要执行的代码（比如循环10000次）</span>
total = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):
    total += i

end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span>
execution_time = end_time - start_time  <span class="hljs-comment"># 计算执行时间（秒）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"代码执行完毕，总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(execution_time, <span class="hljs-number">4</span>)}</span>秒"</span>)
</code></pre>
<h4 data-id="heading-9">2.4 新手避坑指南（标准库实战必看）</h4>
<ul>
<li>避坑1：math库的函数参数多为“弧度”（而非角度），比如math.sin()计算的是弧度的正弦值，若用角度需先转换（弧度=角度×math.pi/180）；</li>
<li>避坑2：random库生成的是“伪随机数”（基于种子生成），若设置固定种子（random.seed(10)），每次运行生成的随机数会相同（适合调试）；</li>
<li>避坑3：random.shuffle()会“原地打乱”列表，修改原对象，若不想修改原列表，需先复制（比如new_list = list1.copy()，再shuffle(new_list)）；</li>
<li>避坑4：time.strftime()的占位符区分大小写，比如%Y是4位年份，%y是2位年份；%H是24小时制，%I是12小时制，新手易混淆；</li>
<li>避坑5：导入标准库时，模块名不要写错（比如math不要写成Math、random不要写成Random），否则会报错“模块不存在”。</li>
</ul>
<blockquote>
<p>以上这些你们会记嘛？不用记，现在 ai 这么发达，只要有印象，到时候 ai 一下就出来了。</p>
</blockquote>
<h3 data-id="heading-10">3 网络编程基础：实现简单的跨程序通信</h3>
<p>网络编程是Python实战中的重要技能，核心是实现“不同设备、不同程序之间的数据传输”。作为基础实战阶段，我们不深入复杂的网络协议，重点掌握<strong>TCP协议的基础用法</strong>（最常用、最可靠的网络协议），实现“本地客户端与服务器端的简单通信”，理解网络编程的核心流程，为后续学习网络爬虫、接口开发打下基础。</p>
<p>核心概念（新手必懂）： - 客户端（Client）：主动发起连接、请求数据的一方（比如我们的浏览器、手机APP）； - 服务器端（Server）：被动接收连接、响应请求的一方（比如网站的服务器）； - Socket（套接字）：网络通信的“桥梁”，客户端和服务器端通过Socket建立连接、传输数据。</p>
<h4 data-id="heading-11">3.1 网络编程核心流程（TCP协议）</h4>
<p>TCP协议的通信流程遵循“三次握手建立连接→传输数据→四次挥手关闭连接”，新手重点掌握“建立连接→传输数据→关闭连接”的基础流程，用Python的socket库实现（内置库，无需额外安装）：</p>
<p>流程拆解： 服务器端：创建Socket→绑定IP和端口→监听连接→接受连接→接收/发送数据→关闭连接； 客户端：创建Socket→连接服务器（IP+端口）→发送/接收数据→关闭连接。</p>
<h4 data-id="heading-12">3.2 实战代码：本地TCP客户端与服务器端通信</h4>
<p>以下代码分为“服务器端”和“客户端”两部分，需分别运行（先运行服务器端，再运行客户端），实现本地（127.0.0.1，本机IP）的简单通信：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ------------- 服务器端代码（server.py）-------------</span>
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 1. 创建Socket对象（AF_INET：IPv4协议，SOCK_STREAM：TCP协议）</span>
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span class="hljs-comment"># 2. 绑定IP地址和端口（IP：127.0.0.1，本机IP；端口：9999，自定义，1024以上避免冲突）</span>
server_addr = (<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>)
server_socket.bind(server_addr)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"服务器已启动，绑定地址：<span class="hljs-subst">{server_addr}</span>，等待客户端连接..."</span>)

<span class="hljs-comment"># 3. 监听连接（参数5：最大等待连接数）</span>
server_socket.listen(<span class="hljs-number">5</span>)

<span class="hljs-comment"># 4. 接受客户端连接（阻塞式，等待客户端发起连接）</span>
client_socket, client_addr = server_socket.accept()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"客户端<span class="hljs-subst">{client_addr}</span>已连接！"</span>)

<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># 5. 接收客户端发送的数据（recv(1024)：每次最多接收1024字节，需解码为字符串）</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        data = client_socket.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">"utf-8"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 若客户端关闭连接，data为空，退出循环</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"收到客户端<span class="hljs-subst">{client_addr}</span>的消息：<span class="hljs-subst">{data}</span>"</span>)
        
        <span class="hljs-comment"># 6. 向客户端发送响应数据（需编码为bytes类型）</span>
        response = <span class="hljs-string">f"服务器已收到消息：<span class="hljs-subst">{data}</span>，时间：<span class="hljs-subst">{time.strftime(<span class="hljs-string">'%H:%M:%S'</span>)}</span>"</span>
        client_socket.send(response.encode(<span class="hljs-string">"utf-8"</span>))
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># 7. 关闭连接（先关闭客户端连接，再关闭服务器端连接）</span>
    client_socket.close()
    server_socket.close()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"与客户端<span class="hljs-subst">{client_addr}</span>的连接已关闭，服务器已停止运行"</span>)

<span class="hljs-comment"># ------------- 客户端代码（client.py）-------------</span>
<span class="hljs-keyword">import</span> socket

<span class="hljs-comment"># 1. 创建Socket对象（与服务器端一致，IPv4+TCP）</span>
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span class="hljs-comment"># 2. 连接服务器（指定服务器的IP和端口，与服务器端一致）</span>
server_addr = (<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>)
<span class="hljs-keyword">try</span>:
    client_socket.connect(server_addr)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"成功连接到服务器<span class="hljs-subst">{server_addr}</span>！"</span>)
    
    <span class="hljs-comment"># 3. 向服务器发送数据（输入消息，发送给服务器）</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入要发送给服务器的消息（输入'quit'退出）："</span>)
        <span class="hljs-keyword">if</span> msg == <span class="hljs-string">"quit"</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-comment"># 发送数据：字符串编码为bytes类型</span>
        client_socket.send(msg.encode(<span class="hljs-string">"utf-8"</span>))
        
        <span class="hljs-comment"># 4. 接收服务器的响应数据</span>
        response = client_socket.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">"utf-8"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"服务器响应：<span class="hljs-subst">{response}</span>"</span>)
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># 5. 关闭连接</span>
    client_socket.close()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"与服务器的连接已关闭"</span>)
</code></pre>
<h4 data-id="heading-13">3.3 代码运行说明与实战拓展</h4>
<ul>
<li>运行步骤：① 新建两个.py文件（server.py、client.py），分别复制上面的代码；② 先运行server.py（服务器启动，等待连接）；③ 再运行client.py（客户端连接服务器）；④ 在客户端输入消息，即可实现双向通信，输入“quit”退出。</li>
<li>实战拓展：将前阶段的“文件操作”结合进来，实现“客户端向服务器发送文件内容，服务器接收后保存到本地”（比如客户端读取test.txt文件，发送给服务器，服务器保存为server_test.txt）。</li>
</ul>
<h4 data-id="heading-14">3.4 新手避坑指南（网络编程基础必看）</h4>
<ul>
<li>避坑1：必须“先启动服务器端，再启动客户端”，否则客户端会报错“连接拒绝”；</li>
<li>避坑2：IP地址和端口必须一致，服务器端绑定的IP和端口，客户端必须完全对应（比如服务器绑定127.0.0.1:9999，客户端也要连接这个地址）；</li>
<li>避坑3：TCP通信中，send()发送的是bytes类型数据，recv()接收的也是bytes类型，必须用encode("utf-8")编码、decode("utf-8")解码，否则会报错或出现乱码；</li>
<li>避坑4：端口号需选择1024以上的（1024以下是系统标准端口，可能被占用），若运行时报错“端口已被占用”，可更换端口（比如改为10000）；</li>
<li>避坑5：服务器端的accept()、recv()是“阻塞式”的，会一直等待客户端的连接/数据，新手无需深究，后续进阶再学习非阻塞编程；</li>
<li>避坑6：通信结束后，必须关闭Socket连接（close()），避免资源泄露。</li>
</ul>
<h3 data-id="heading-15">4 多线程基础：实现程序的并发执行</h3>
<p>在前面的学习中，我们编写的代码都是“单线程”的——程序从上到下，依次执行，一次只能做一件事（比如程序执行延迟时，会一直卡住，无法做其他操作）。而“多线程”，能让程序“同时执行多个任务”（并发执行），提升程序效率，尤其适合I/O密集型任务（比如文件操作、网络请求、延迟执行）。</p>
<p>作为基础实战阶段，我们重点掌握Python threading模块的基础用法（内置库，无需额外安装），实现简单的多线程并发，理解多线程的核心概念和优势，不深入复杂的线程安全、锁机制（后续进阶再学习）。</p>
<p>核心概念（新手必懂）： - 线程（Thread）：程序执行的最小单位，一个程序可以包含多个线程； - 主线程：程序启动后，默认创建的线程（比如我们之前写的代码，都是主线程在执行）； - 子线程：我们手动创建的线程，用于执行额外的任务，与主线程并发执行。</p>
<h4 data-id="heading-16">4.1 多线程基础用法（两种常用方式）</h4>
<p>新手重点掌握两种创建子线程的方式：① 传入target函数（推荐，简单易懂）；② 继承Thread类（进阶用法，简单了解），结合实战案例讲解：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># ---------------- 方式1：传入target函数（推荐，新手首选）----------------</span>
<span class="hljs-comment"># 定义要在子线程中执行的函数（比如模拟下载任务）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">download_task</span>(<span class="hljs-params">task_name, delay</span>):
    <span class="hljs-string">"""模拟下载任务：延迟delay秒，模拟下载耗时"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程启动：开始下载<span class="hljs-subst">{task_name}</span>，预计耗时<span class="hljs-subst">{delay}</span>秒"</span>)
    time.sleep(delay)  <span class="hljs-comment"># 模拟下载耗时（I/O阻塞）</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程结束：<span class="hljs-subst">{task_name}</span>下载完成！"</span>)

<span class="hljs-comment"># 1. 创建子线程（target：子线程要执行的函数；args：传入函数的参数，元组类型）</span>
thread1 = threading.Thread(target=download_task, args=(<span class="hljs-string">"电影A"</span>, <span class="hljs-number">3</span>))
thread2 = threading.Thread(target=download_task, args=(<span class="hljs-string">"音乐B"</span>, <span class="hljs-number">2</span>))

<span class="hljs-comment"># 2. 启动子线程（start()：启动线程，自动调用target函数）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：开始执行程序"</span>)
thread1.start()
thread2.start()

<span class="hljs-comment"># 3. 等待子线程执行完毕（join()：阻塞主线程，等待子线程结束后，主线程再继续）</span>
thread1.join()
thread2.join()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：所有子线程执行完毕，程序结束"</span>)

<span class="hljs-comment"># ---------------- 方式2：继承Thread类（简单了解）----------------</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(threading.Thread):
    <span class="hljs-string">"""自定义线程类，继承Thread类，重写run()方法"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, task_name, delay</span>):
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类的初始化方法</span>
        self.task_name = task_name
        self.delay = delay
    
    <span class="hljs-comment"># 重写run()方法：子线程启动后，会自动执行run()方法中的代码</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程启动：开始下载<span class="hljs-subst">{self.task_name}</span>，预计耗时<span class="hljs-subst">{self.delay}</span>秒"</span>)
        time.sleep(self.delay)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程结束：<span class="hljs-subst">{self.task_name}</span>下载完成！"</span>)

<span class="hljs-comment"># 创建自定义线程对象</span>
thread3 = MyThread(<span class="hljs-string">"图片C"</span>, <span class="hljs-number">1</span>)
thread4 = MyThread(<span class="hljs-string">"文档D"</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment"># 启动子线程</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n主线程：开始执行自定义线程程序"</span>)
thread3.start()
thread4.start()

<span class="hljs-comment"># 等待子线程结束</span>
thread3.join()
thread4.join()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"主线程：所有自定义线程执行完毕，程序结束"</span>)
</code></pre>
<h4 data-id="heading-17">4.2 多线程的优势（实战对比）</h4>
<p>通过“单线程”与“多线程”的执行时间对比，直观感受多线程的并发优势（适合I/O密集型任务）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 定义任务函数（模拟I/O阻塞，比如下载、文件读取）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name, delay</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务<span class="hljs-subst">{name}</span>开始执行，耗时<span class="hljs-subst">{delay}</span>秒"</span>)
    time.sleep(delay)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"任务<span class="hljs-subst">{name}</span>执行完毕"</span>)

<span class="hljs-comment"># ---------------- 单线程执行（依次执行3个任务）----------------</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 单线程执行 ==="</span>)
start_time1 = time.time()

task(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>)
task(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>)
task(<span class="hljs-string">"C"</span>, <span class="hljs-number">1</span>)

end_time1 = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"单线程总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(end_time1 - start_time1, <span class="hljs-number">2</span>)}</span>秒\n"</span>)  <span class="hljs-comment"># 总耗时约6秒</span>

<span class="hljs-comment"># ---------------- 多线程执行（3个任务并发执行）----------------</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 多线程执行 ==="</span>)
start_time2 = time.time()

<span class="hljs-comment"># 创建3个子线程</span>
t1 = threading.Thread(target=task, args=(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>))
t2 = threading.Thread(target=task, args=(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>))
t3 = threading.Thread(target=task, args=(<span class="hljs-string">"C"</span>, <span class="hljs-number">1</span>))

<span class="hljs-comment"># 启动所有子线程</span>
t1.start()
t2.start()
t3.start()

<span class="hljs-comment"># 等待所有子线程结束</span>
t1.join()
t2.join()
t3.join()

end_time2 = time.time()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"多线程总耗时：<span class="hljs-subst">{<span class="hljs-built_in">round</span>(end_time2 - start_time2, <span class="hljs-number">2</span>)}</span>秒"</span>)  <span class="hljs-comment"># 总耗时约3秒（取决于最长任务）</span>
</code></pre>
<p>运行结果分析：单线程执行3个任务，总耗时是3+2+1=6秒；多线程并发执行，总耗时约3秒（等于最长任务的耗时），明显提升了程序效率——这就是多线程的核心优势，适合处理“需要等待的任务”。</p>
<h4 data-id="heading-18">4.3 新手避坑指南（多线程基础必看）</h4>
<ul>
<li>避坑1：启动线程必须用 <code>start()</code> 方法，不能用 <code>run()</code> 方法——start()会创建子线程，并发执行；run()只是普通函数调用，还是单线程执行；</li>
<li>避坑2：<code>join()</code> 方法的作用是“阻塞主线程”，等待子线程执行完毕，若不调用join()，主线程会直接结束，子线程可能还未执行完就被终止；</li>
<li>避坑3：Python中存在“全局解释器锁（GIL）”，同一时刻只有一个线程能执行Python代码——多线程适合I/O密集型任务（如下载、延迟），不适合CPU密集型任务（如大量计算），新手无需深究GIL，知道这个特性即可；</li>
<li>避坑4：多个子线程共享全局变量时，可能会出现“线程安全问题”（比如多个线程同时修改一个全局变量，导致数据错误），基础阶段暂时不处理，后续进阶学习“锁机制”解决；</li>
<li>避坑5：不要创建过多的子线程（比如几百、几千个），会占用大量系统资源，导致程序卡顿，按需创建即可。</li>
</ul>
<h3 data-id="heading-19">5 总结</h3>
<p>恭喜大家！Python3基础学习第七阶段「基础实战巩固」的核心内容，到这里就全部梳理完毕了！这一阶段，我们没有学习新的复杂语法，而是聚焦“实战巩固”，将前六阶段的知识串联起来，通过四大实战方向，实现了从“会用”到“活用”的跨越：</p>
<ul>
<li>常用内置函数：掌握了len、range、enumerate、zip等高频工具，学会用内置函数简化代码，提升编码效率；</li>
<li>简单标准库：熟练使用math、random、time三个常用标准库，能解决数学计算、随机场景、时间处理等日常实战需求；</li>
<li>网络编程基础：掌握TCP协议的核心流程，实现了本地客户端与服务器端的简单通信，理解了跨程序通信的原理；</li>
<li>多线程基础：学会用threading模块创建子线程，实现程序的并发执行，提升I/O密集型任务的效率。</li>
</ul>
<p>本阶段的核心重点是“实战”——新手不要只看代码、记语法，一定要亲手敲写每个案例，调试报错，结合前阶段的知识（函数、模块、文件操作等）拓展实战场景，比如：用多线程实现多文件下载、用网络编程+文件操作实现文件传输、用内置函数+标准库编写简单的验证码生成器。</p>
<p>对于新手来说，本阶段可能会觉得多线程、网络编程有点难度，尤其是“并发”“Socket连接”的逻辑，容易混淆步骤——没关系，多动手练习，先掌握基础用法，再逐步理解原理，重点是能独立写出可运行的实战代码，巩固基础。</p>
<p>到这里，Python3基础学习的七个阶段就全部结束了！通过这七个阶段的学习，你已经掌握了Python的核心基础语法、模块化编程、面向对象、实战工具、网络与并发基础，具备了独立编写简单Python项目的能力。</p>
<p>接下来，你可以尝试挑战简单的实战项目（比如学生管理系统、通讯录、简易爬虫、验证码生成器），将七个阶段的知识综合运用，查漏补缺。后续我们还会进入Python进阶学习阶段，学习更复杂的框架、项目开发技巧，继续加油，你已经离“合格的Python开发者”越来越近啦～</p>
<hr/>
<p><em>转发请携带作者信息</em>  <strong>@怒放吧德德 @一个有梦有戏的人</strong><br/>
持续创作很不容易，作者将以尽可能的详细把所学知识分享各位开发者，一起进步一起学习。<strong>转载请携带链接，转载到微信公众号请勿选择原创，谢谢！</strong><br/>
👍创作不易，如有错误请指正，感谢观看！记得点赞哦！👍<br/>
谢谢支持！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OoderAgent 相比主流Agent框架的五大核心独特优势]]></title>    <link>https://juejin.cn/post/7603895839557730367</link>    <guid>https://juejin.cn/post/7603895839557730367</guid>    <pubDate>2026-02-09T04:49:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603895839557730367" data-draft-id="7604084016510713897" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OoderAgent 相比主流Agent框架的五大核心独特优势"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-09T04:49:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OoderAgent 相比主流Agent框架的五大核心独特优势
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T04:49:47.000Z" title="Mon Feb 09 2026 04:49:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>截至 2026 年初，ooderAgent（特别是 Nexus / 2.0 版本）在众多 AI Agent 框架中展现出显著且系统性的独特优势。它并非在单一功能上“微创新”，而是从架构哲学、能力抽象、人机协同、企业落地四个维度重构了 AI 应用的开发与运行范式。</p>
<p>以下是 ooderAgent 相比主流框架（如 LangChain、Dify、AutoGen、CrewAI 等）的 五大核心独特优势：</p>
<p>✅ 1. 以 Skill 为中心的能力抽象（而非 LLM 为中心）
这是最根本的差异：ooderAgent 把 AI 能力当作“可治理的服务”，而不是“大模型的插件”。
对比项   ooderAgent   其他框架（LangChain/Dify 等）
最小单元   Skill（AIBridge）• 强 Schema 约束• 版本管理• 上下文隔离• 可审计、可回滚   Tool / Function / Node• 多为函数包装• 无标准输入/输出契约• 依赖开发者自律</p>
<p>能力边界   支持 LLM + 规则 + 数据库 + API 混合执行   多数仅封装 LLM 调用或简单工具</p>
<p>复用机制   通过 Nexus 技能中心 注册、发现、订阅   手动复制代码或依赖 LangServe</p>
<p>💡 价值：Skill 成为企业数字资产，可积累、沉淀、复用，避免“每次重写 prompt”。</p>
<p>✅ 2. 原生 P2P 分布式架构（支持边缘自治 + 断网可用）
唯一真正实现“去中心化但可控”的企业级 Agent 框架。</p>
<ul>
<li>三层 P2P 架构：
<ul>
<li>End Agent：部署在业务终端（如工厂 PC、门店 POS），本地执行 Skill；</li>
<li>Route Agent：动态路由通信，支持 NAT 穿透；</li>
<li>MCP Agent：提供全局能力（模型池、安全认证）。</li>
</ul>
</li>
<li>关键能力：
<ul>
<li>断网仍可运行：End Agent 缓存常用 Skill，离线处理任务；</li>
<li>数据不出域：敏感操作在本地完成，仅同步结果；</li>
<li>CAP 快速重连：网络恢复后自动状态同步。</li>
</ul>
</li>
</ul>
<p>🌐 对比：LangChain、Dify、FastGPT 均为中心化架构，断网即失效；AutoGen 仅为本地模拟，无法跨设备协作。</p>
<p>✅ 3. A2UI + BridgeCode：AI 驱动的动态 UI（体验革命）
让 AI 输出直接变成“可操作界面”，而非一段文本。</p>
<ul>
<li>
<p>传统方案：LLM → JSON/Markdown → 前端解析 → 渲染（体验割裂、易出错）</p>
</li>
<li>
<p>ooderAgent 方案：
// Skill 返回结构化 UIComponent
return UIC.form()
.addField("orderId", "订单号")
.addButton("submit", "确认发货")
.onSubmit(handleShipping);</p>
<ul>
<li>前端通过 BridgeCode 引擎 自动渲染为表单、图表、按钮；</li>
<li>用户点击“确认发货”直接触发新 Skill，形成闭环。</li>
</ul>
</li>
</ul>
<p>🎯 效果：非技术人员也能高效完成复杂任务，大幅提升任务完成率。</p>
<p>✅ 4. 人在回路（Human-in-the-Loop）自动进化机制
AI 系统能从用户修正中学习，并沉淀为新能力。</p>
<p>流程：</p>
<ol>
<li>用户调用 Skill A（如“生成周报”）；</li>
<li>手动修改结果（调整格式、补充数据）；</li>
<li>系统自动捕获修正行为；</li>
<li>生成新 Skill B（“市场部周报模板 v2”）；</li>
<li>经审核后发布到 Nexus，供团队复用。</li>
</ol>
<p>🔁 形成“使用 → 修正 → 沉淀 → 复用”的正向飞轮，这是 LangChain 等框架完全不具备的持续进化能力。</p>
<p>✅ 5. 企业级工程就绪：安全、合规、可观测
不是 Demo 框架，而是为生产环境设计。
能力   ooderAgent 实现
安全   DID 身份 + E2EE 加密 + RBAC 权限 + VFS 数据沙箱</p>
<p>合规   操作日志全审计，满足 GDPR/等保要求</p>
<p>可观测   OpenTelemetry 全链路追踪，Skill 调用可监控</p>
<p>集成   Spring Boot 注解驱动，无缝嵌入现有 Java 系统</p>
<p>协议   MIT 开源，无商业限制</p>
<p>🏢 这使得 ooderAgent 能真正进入金融、政务、制造等强监管场景，而多数开源框架止步于“技术演示”。</p>
<p>🆚 横向对比总结
能力维度   ooderAgent   LangChain   Dify/FastGPT   AutoGen
架构模式   ✅ P2P 分布式   ❌ 中心化   ❌ SaaS/私有中心   ⚠️ 本地模拟</p>
<p>能力抽象   ✅ Skill（可治理资产）   ⚠️ Tool（函数）   ⚠️ Node（配置块）   ⚠️ Agent（对话角色）</p>
<p>离线能力   ✅ End Agent 本地运行   ❌ 依赖 LLM API   ❌ 依赖后端服务   ✅ 但仅限单机</p>
<p>动态 UI   ✅ A2UI 原生支持   ❌ 需自行实现   ⚠️ 固定组件   ❌ 无</p>
<p>持续进化   ✅ 人在回路 → 新 Skill   ❌ 无   ⚠️ 仅人工审批   ❌ 无</p>
<p>企业合规   ✅ 全栈支持   ⚠️ 需自行补足   ⚠️ 基础支持   ❌ 无</p>
<p>🎯 结论：ooderAgent 的独特定位</p>
<p>它不是“另一个 LLM 编排工具”，而是试图成为“AI 原生时代的企业应用操作系统”。</p>
<ul>
<li>
<p>适合谁：<br/>
✔ 有复杂业务流程的企业<br/>
✔ 需要 AI 与现有系统深度集成<br/>
✔ 重视安全、治理、长期演进</p>
</li>
<li>
<p>不适合谁：<br/>
✖ 只想快速搭个聊天机器人<br/>
✖ 团队无 Java/Spring 工程能力<br/>
✖ 追求“零代码”但不愿定义业务规则</p>
</li>
</ul>
<p>如果你正在寻找一个能伴随企业 AI 战略长期演进、可积累智能资产、支持边缘与中心协同的框架，ooderAgent 是目前最值得投入的开源选项之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手]]></title>    <link>https://juejin.cn/post/7604093823958040595</link>    <guid>https://juejin.cn/post/7604093823958040595</guid>    <pubDate>2026-02-09T02:05:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604093823958040595" data-draft-id="7604084016510091305" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手"/> <meta itemprop="keywords" content="人工智能,LLM,NVIDIA"/> <meta itemprop="datePublished" content="2026-02-09T02:05:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lethehong"/> <meta itemprop="url" content="https://juejin.cn/user/1567216547423136"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实测可用｜一文搞定OpenClaw部署，免费kimi-k2.5+飞书远程，新手也能秒上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1567216547423136/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lethehong
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:05:41.000Z" title="Mon Feb 09 2026 02:05:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近亲测完成了 OpenClaw 的部署，把全程步骤整理出来分享给大家，适配中国大陆网络环境，还会教大家配置英伟达免费的 AI 模型（包含 kimi-k2.5），所有代码直接复制就能用，跟着步骤走全程无坑～  </p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2053e925f1240bda8ee1cdaa876b6dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Bpqq0kPYj9BiR4mReuAS34GmW0c%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">第一步：版本检测，确认系统初始状态</h2>
<p>先检查服务器里有没有装过 OpenClaw，或者它的旧版本 Moltbot/Clawdbot，避免版本冲突，直接执行下面的检测命令就行：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw --version 2&gt;/dev/null &amp;&amp; echo "OpenClaw 已安装" || echo "未安装 OpenClaw"; moltbot --version 2&gt;/dev/null &amp;&amp; echo "Moltbot 已安装（旧版本）" || echo "未安装 Moltbot"; clawdbot --version 2&gt;/dev/null &amp;&amp; echo "Clawdbot 已安装（旧版本）" || echo "未安装 Clawdbot"
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b248efca82e48dbbe8fe6e07590f919~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=D7SG0Gd16xO9TzI1ZxgBtqsBg1I%3D" alt="" loading="lazy"/></p>
<p>我这边检测结果是啥都没装，直接走完整的部署流程就可以。</p>
<h2 data-id="heading-1">第二步：环境检测，核对服务器配置</h2>
<p>安装前先确认服务器配置是否达标，同时检查 Node.js 和 Git 这两个必备依赖有没有装，执行下面的命令一次性检测所有关键指标：</p>
<pre><code class="hljs language-plain" lang="plain">echo "=== 环境检测开始 ===" &amp;&amp; echo "1. 操作系统信息：" &amp;&amp; cat /etc/os-release | grep PRETTY_NAME &amp;&amp; echo "2. CPU核心数：" &amp;&amp; nproc &amp;&amp; echo "3. 内存大小（MB）：" &amp;&amp; free -m | awk 'NR==2{print $2}' &amp;&amp; echo "4. 磁盘可用空间：" &amp;&amp; df -h / | awk 'NR==2{print $4}' &amp;&amp; echo "5. Node.js版本：" &amp;&amp; node --version 2&gt;/dev/null || echo "未安装" &amp;&amp; echo "6. Git版本：" &amp;&amp; git --version 2&gt;/dev/null || echo "未安装" &amp;&amp; echo "=== 环境检测结束 ==="
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f01a7c6b6a144178fc036a614dc9782~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=jN5TkJ8s8uwimRZ%2FZKTK2OWvytQ%3D" alt="" loading="lazy"/></p>
<p> 我用的服务器是 Ubuntu 22.04 LTS 系统，2 核 CPU、1.9GB 内存、42GB 磁盘空间，Node.js v22.22.0 和 Git 也都提前装好了，完全满足安装要求，不用额外装依赖，直接下一步。  </p>
<h2 data-id="heading-2">第三步：安装 OpenClaw，适配国内镜像源</h2>
<p>因为是国内服务器，先配置国内的镜像源避免下载卡顿，本来试了 yarn 安装，后来觉得 npm 更稳定可靠，就直接用 npm 装了，先设腾讯云的 npm 镜像，再全局安装最新版 OpenClaw，执行这条命令就行：</p>
<pre><code class="hljs language-plain" lang="plain">npm config set registry https://mirrors.cloud.tencent.com/npm/ &amp;&amp; npm install -g openclaw@latest
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c982002be94b4950b1420ad149588c09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=MJx%2FfCduKKuK4OpOEksQWmlB%2Bw0%3D" alt="" loading="lazy"/></p>
<p>安装过程会自动装 700 多个包，中间会出几个过时包的警告，不用管，不影响正常使用，等待安装完成就好。</p>
<h2 data-id="heading-3">第四步：验证安装，确认 OpenClaw 可用</h2>
<p>装完之后一定要检查下版本，确认安装成功，命令很简单：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw --version
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c58aeb0afe144ae946a25999d020adb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=DX%2BVbnD7FDPbw0TI9ZnsZ6p483g%3D" alt="" loading="lazy"/></p>
<p>我这边成功装到了 2026.2.2-3 版本，到这一步 OpenClaw 就装好了～</p>
<h2 data-id="heading-4">重点步骤：配置英伟达免费 AI 模型（含 kimi-k2.5）</h2>
<p>这一步教大家白嫖英伟达的免费 AI 模型，里面包含 kimi-k2.5，跟着三步来就行，全程免费：</p>
<h3 data-id="heading-5">1. 注册英伟达账号并获取 API Key</h3>
<p>先打开英伟达的地址注册：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbuild.nvidia.com%2F" target="_blank" title="https://build.nvidia.com/" ref="nofollow noopener noreferrer">build.nvidia.com/</a>，建议用谷歌账号直接登录，方便快捷；登录后点左上角的头像，新建一个专属的 API Key，保存好别弄丢了。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/292b336ef61e4791b7ac89cb9d1fceda~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Wx%2FNJdVnWRtpFfc9V1avOSAEyeA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">2. 修改 OpenClaw 配置文件</h3>
<p>需要打开 OpenClaw 的配置文件，在指定位置添加英伟达模型的配置，<strong>重点注意</strong>：providers 外面要包一层 models，如果文件里本来就有 models，直接加进原有内容里就行，其他代码千万别改！执行命令打开配置文件：</p>
<pre><code class="hljs language-plain" lang="plain">vi ~/.openclaw/openclaw.json  
</code></pre>
<p>然后在 models 部分添加下面的代码，记得把里面的 apiKey 换成你自己刚创建的：</p>
<pre><code class="hljs language-plain" lang="plain">帮我打开 ~/.openclaw/openclaw.json文件，在 models 部分增加下面的代码，注意：providers 外面还要加一层 models，如果原来配置有models就加到原来的里面
{
  ... 其他内容不要改
  "models": {
   "providers":{
        "英伟达nvidia": {
            "baseUrl": "https://integrate.api.nvidia.com/v1",
            "apiKey": "nvapi-HxKN8Zp2-xxxxx-替换成你的 key,
            "api": "openai-completions",
            "models": [
              {
                "id": "moonshotai/kimi-k2.5",
                "name": "moonshotai/kimi-k2.5",
                "reasoning": false,
                "input": [
                  "image",
                  "text"
                ],
                "cost": {
                  "input": 0,
                  "output": 0,
                  "cacheRead": 0,
                  "cacheWrite": 0
                },
                "contextWindow": 200000,
                "maxTokens": 8192
              }
            ]
        }
        ... 其他内容不要改
    }
    ... 其他内容不要改
  }
}
</code></pre>
<h3 data-id="heading-7">3. 运行配置向导，完成剩余设置</h3>
<p>模型配置好后，运行 OpenClaw 的配置向导，跟着提示完成其他基础设置就行：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw onboard
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca0b966cfd8e4e6c90fdf814e07cdfe4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=3yswGF1z2uzjrc7392VvMtZRDlI%3D" alt="" loading="lazy"/></p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/314adb61460d41afbb889c5cabfbd666~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=dFLzqSdedjaUVEoeVSAti0DgEso%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-8">修复安全权限警告</h2>
<p>配置完会出现安全权限的警告，用下面的命令修复一下，给配置目录设置专属权限，执行后会提示修复完成：</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88ca4d56405f47c5b6e495740e69451d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Ha9iQe038qL9waz4dMNayXBvt1M%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-plain" lang="plain">chmod 700 /root/.openclaw &amp;&amp; echo "安全权限已修复"
</code></pre>
<h2 data-id="heading-9">最后一步：启动 OpenClaw 核心网关服务</h2>
<p>所有配置和修复都完成后，重启 OpenClaw 的网关服务</p>
<pre><code class="hljs language-plain" lang="plain">openclaw gateway restart
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cfae565b3df748eaa929b950ffcbc4bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=jte3CzAXpWjVGhfmpMUQRgqVhkc%3D" alt="" loading="lazy"/></p>
<p>到这里，OpenClaw 就完成全部部署和配置了，启动网关服务后就能正常使用，还能直接调用英伟达免费的 kimi-k2.5 模型，亲测全程流畅，有问题的小伙伴可以留言交流～</p>
<p>接下来启动网关并测试模型，步骤超简单：先执行<code>openclaw gateway --force</code>重启网关服务，再输入<code>openclaw tui</code>打开交互测试界面，最后直接问一句「你是干嘛的」，就能验证配置是否生效啦。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b6d7f9824634dcabdde5a5bff5d951d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=juw%2BnO3bVDKUkoIH2WcHKnnsY8c%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">进阶实操：接入飞书，实现手机远程操控（必看！）</h2>
<p>作为AI玩家，我必须说一句：本地运行够用，但远程操控才是精髓！守在电脑前太束缚，接入飞书（Lark）后，手机揣兜里，随时随地给家里/服务器的OpenClaw下指令，躺平操作不香吗？🤫 这部分我把自己踩过的坑都标出来了，跟着我的步骤走，零失败！</p>
<p>先搞飞书开放平台的基础配置，打开这个地址：<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">open.feishu.cn/app</a>，点击“新建应用”，页面上的基础信息（应用名称、描述之类的）随便填，不用纠结，填完保存就行，全程跟着页面提示走，没有复杂操作，新手也能秒上手。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a75c2b1eafe2476e965de3c09cddaf68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=9zT0siac10We1nGH%2FJXBlEtnVL4%3D" alt="" loading="lazy"/>关键一步：新建应用后，会自动生成「App ID」和「App Secret」，这俩是飞书和OpenClaw对接的“钥匙”，一定要复制保存好，最好存到记事本里，丢了就得重新创建应用，巨浪费时间！我第一次就忘存，返工半小时谁懂啊…</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d1aa9383fdc45d8b9b9c979fb30732d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=ydv2j2GKk8r0FW3kXVCYswZ%2BFDk%3D" alt="" loading="lazy"/></p>
<p>回到应用配置页，找到「添加应用能力」选项，点开后直接选「机器人」，点击“添加”就完事，不用额外勾选其他东西，多余操作反而容易出问题。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15b95bfd81fa411e9db3f946bb18e200~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=37aJTxQuzGVt8%2B3NXPkHUmDgFkw%3D" alt="" loading="lazy"/></p>
<p>避坑重点（敲黑板！）：给刚添加的机器人，开通「全部权限」！没错，是全部，一个都别漏！我第一次图省事漏勾了两个，结果后面对接一直失败，排查了半天才发现是权限不够，血的教训！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2bca473d6f94b178cd5c8c54e3fff5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=JWj8kR5%2FifbEsTAkbLthsM4NuAw%3D" alt="" loading="lazy"/></p>
<p>权限搞定，就该装对接插件了——这个插件是飞书和OpenClaw的“桥梁”，没有它俩就无法通信，直接复制下面的命令安装，注意别手滑输错字符：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw plugins install @m1heng-clawd/feishu
</code></pre>
<p>插件安装完成，接下来把之前保存的「App ID」和「App Secret」配置进去，三条命令依次执行，重点提醒：把命令里的“cli_xxxxx”和“your_app_secret”，替换成你自己的，别直接复制运行！否则会报错，还得重启网关重来！</p>
<pre><code class="hljs language-plain" lang="plain">openclaw config set channels.feishu.appId "cli_xxxxx"   #换为你自己在步骤2得到的
openclaw config set channels.feishu.appSecret "your_app_secret"  #换为你自己在步骤2得到的
openclaw config set channels.feishu.enabled true
</code></pre>
<p>配置生效的关键：重启网关！执行下面这条命令，重启完成后，配置才会真正生效，别偷懒跳过这一步：</p>
<pre><code class="hljs language-plain" lang="plain">openclaw gateway restart
</code></pre>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/93bf101fa2be4b08ba34c9fff12ec250~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=Ms1RbbV00pve%2B6rjjtqTpKtwlXs%3D" alt="" loading="lazy"/></p>
<p>再回到飞书开放平台，找到「事件与回调」——这两个选项缺一不可，必须都配置好！然后在回调方式里，选择「长连接」，保存即可。如果提示连接失败，不用慌，大概率是上一步网关没重启到位，回去再执行一次重启命令，基本都能解决，我亲测过三次，都是这个问题！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4640228cb82b4639826b0eaf8ef33204~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=R3Gn6rGWZLdt01Kdb1QHvdRjf%2FY%3D" alt="" loading="lazy"/></p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7439c92265c34dff9c5da36b9ee63c52~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=6HUxYCXEMW7j6ZiEPnkLBtq%2FAcg%3D" alt="" loading="lazy"/></p>
<p>还有一个细节：添加事件的时候，把里面所有的事件都勾选上，别漏一个！少勾一个事件，后面飞书就可能无法正常接收/执行指令，比如没法远程下达操作命令，到时候又得回头排查，得不偿失。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3511fbbcfa814d44b27fa558d243cf70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=656K8aXYRXZyVOx3dlKXW8Nu3Qs%3D" alt="" loading="lazy"/></p>
<p>最后一步，发布插件才能用！点击左侧菜单栏的「版本管理与发布」，先点击「创建版本」，不用改其他设置，直接提交，然后点击「申请发布」，飞书的审核很快，几分钟就通过，发布完成后，插件就正式生效了。</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a82bcfc55dd4571a2a87ac89c44c6ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=RVCMUcSPj%2BrUrJtvlmGhPrx2iR8%3D" alt="" loading="lazy"/></p>
<p>大功告成！打开你手机上的飞书，找到刚才创建的那个机器人，发送消息就能测试，比如之前教的“你是什么模型”，就能远程操控OpenClaw执行指令，再也不用守在电脑前，随时随地都能操作，这才是OpenClaw的正确打开方式啊！</p>

<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f58e041101e64393892344c309e0eb99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGV0aGVob25n:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771207540&amp;x-signature=7qWRcMbzZkEqUJ8%2FLab2sJ9wxX4%3D" alt="" loading="lazy"/></p>
<p>到这里，OpenClaw的完整部署、英伟达免费模型配置，还有飞书远程操控接入，就全部完成了！全程亲测流畅无bug，每一步都标了避坑点，新手也能轻松上手。如果操作中遇到问题，评论区留言，我看到都会回复，一起交流一起折腾～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[第二章: 图像处理基本操作]]></title>    <link>https://juejin.cn/post/7603854784865779752</link>    <guid>https://juejin.cn/post/7603854784865779752</guid>    <pubDate>2026-02-09T02:46:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865779752" data-draft-id="7604045354070097954" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="第二章: 图像处理基本操作"/> <meta itemprop="keywords" content="算法"/> <meta itemprop="datePublished" content="2026-02-09T02:46:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宝贝儿好"/> <meta itemprop="url" content="https://juejin.cn/user/2737129399522635"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            第二章: 图像处理基本操作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2737129399522635/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宝贝儿好
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:46:30.000Z" title="Mon Feb 09 2026 02:46:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">第二章: 图像处理基本操作</h3>
<h4 data-id="heading-1">一、图像的表示方法</h4>
<ul>
<li><strong>二值图像：</strong> 每个像素点不是白色就是黑色；一个像素点只要一个bit位就能表示；用0或1表示每个像素点。</li>
<li><strong>灰度图像：</strong> 图像只有一种颜色，比如图像可以是红色，可以是灰色，可以蓝色，可以是绿色等等，但不管什么颜色都是只有一种颜色。但是这一种颜色我们给它分成了256个等级，就是256个灰度级，可以理解成256个不同程度的明暗度。比如一张红色的灰度图像，像素值=0就是最暗，黑色，像素值=255就是最亮，就是最亮的红色。255中明暗度正好可以用8位也就是1字节byte表示。</li>
<li><strong>彩色图像：</strong> 图像是彩色的，图像的每个像素点都是由三种颜色混合而成。这三种颜色是R G B, 每种颜色的取值都在0-255之间。每种颜色是一个通道，所以彩图一般都是3通道。少数图像是4通道，因为还有一个0-1之间的透明度。</li>
</ul>
<h4 data-id="heading-2">二、像素处理</h4>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.1</span> 生成一个<span class="hljs-number">10</span>x10大小的黑色图像，并且对其像素进行修改，显示修改前后的图像，理解数据和图像之间的一一对应关系。
import cv2
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">10</span>,<span class="hljs-number">10</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>('请看下面图像数据长的样子吧：\n', img, '\n')   #\n表示回车重启一行
cv2<span class="hljs-selector-class">.imshow</span>('one', img)         #图像窗口显示图像
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0:3,3:6]</span>=<span class="hljs-number">255</span>               #把<span class="hljs-selector-tag">img</span>图像上的第<span class="hljs-number">0</span>行到第<span class="hljs-number">2</span>行，第<span class="hljs-number">3</span>列到第<span class="hljs-number">5</span>列的像素点切出来，并且给它们赋值为<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>('请看切出来像素的值，是不是从<span class="hljs-number">0</span>变为<span class="hljs-number">255</span>了：\n', img)
cv2<span class="hljs-selector-class">.imshow</span>('two', img)
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">20000</span>)          <span class="hljs-selector-id">#20</span>秒后就执行下面语句吧，程序别老卡在这条语句上了。
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()     #这么图片窗口都统统消失吧

请看下面图像数据长的样子吧：
 <span class="hljs-selector-attr">[[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>
 <span class="hljs-selector-attr">[0 0 0 0 0 0 0 0 0 0]</span>] 

请看切出来像素的值，是不是从<span class="hljs-number">0</span>变为<span class="hljs-number">255</span>了：
 <span class="hljs-selector-attr">[[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0 255 255 255   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>
 <span class="hljs-selector-attr">[  0   0   0   0   0   0   0   0   0   0]</span>]

#例<span class="hljs-number">2.2</span> 读取一个灰度图像，并对其指定的像素进行修改
import cv2                                                 #倒库
lena = cv2<span class="hljs-selector-class">.imread</span>(r'C:\Users\<span class="hljs-number">25584</span>\Desktop\lena.bmp',<span class="hljs-number">0</span>)    #把lena读到内存
cv2<span class="hljs-selector-class">.imshow</span>('the first', lena)                              #用一个窗口把lena显示出来
for hang in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>):       #A                 
    for lie in <span class="hljs-built_in">range</span>(<span class="hljs-number">80</span>, <span class="hljs-number">200</span>):
        lena[hang, lie]=<span class="hljs-number">255</span>
cv2.<span class="hljs-built_in">imshow</span>(<span class="hljs-string">'the second'</span>, lena)
cv2.<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">20000</span>)
cv2.<span class="hljs-built_in">destroyAllWindows</span>()
</code></pre>
<ul>
<li><strong>A:</strong> 代码中使用了一个双层嵌套循环把lena图像数据中的 <strong>第10行到第99行、第80列到199列</strong> 的数据索引出来，并且把这些数据重新赋值为255.</li>
<li><strong>知识点：</strong><br/>
1、容器的概念，range()函数、list列表 等都是容器。是容器就可以对里面的元素进行遍历，也就是进行循环。<br/>
2、for循环、嵌套循环，都是基础必须完全熟练。</li>
</ul>
<h4 data-id="heading-3">三、彩色图像基本知识点</h4>
<p>我们平时看到的彩色图像，不管什么格式的，一般都是RGB色彩通道模式的图片，就是图片的每个像素都有三个数字，第一个数字是R红色通道的红光强度值，第二个数字是G绿色通道的绿光强度值，第三个数字是B蓝色通道的蓝光的强度值。<br/>
但是opencv在读取彩色图片的数据时，是将图片里面的数据以行方向顺序读取，并且以BGR的默认模式存放在数组ndarray中的。就相当于把一张图片从左上角的第一个像素开始，按行依次垂直排列，拍成一条数直的长线，线上的每个点都是三个数字，但这三个数字默认的BGR通道。<br/>
image[0,0,0] 第一个参数0表示第0行，第二个参数0表示第0列，第三个参数表示第0个通道。由于opencv读出来的三个通道是BGR顺序的，所以第三个参数0在opencv中是切出来的像素点就是image这张图片中的左上角第一个像素点B通道的蓝光强度值。</p>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.3</span> 先生成一个三维全是<span class="hljs-number">0</span>的ndarray数组，然后切出第一个通道的数据并改为<span class="hljs-number">255</span>，然后再显示这个三维数据图像。依次类推把三个通道都操作一遍。即根据图像的通道操作整张图像。
import numpy as np
import cv2
blue = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)   #用np<span class="hljs-selector-class">.zeros</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], dtype=np.uint8)理解这个函数
blue<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>                                  <span class="hljs-selector-id">#np</span><span class="hljs-selector-class">.zeros</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], dtype=np.uint8)<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>，尝试用小数据切一切认识数据
<span class="hljs-built_in">print</span>(blue)
cv2<span class="hljs-selector-class">.imshow</span>('blue', blue)
<span class="hljs-built_in">print</span>('------------------------------------------------')
green = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
green<span class="hljs-selector-attr">[:,:,1]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(green)
cv2<span class="hljs-selector-class">.imshow</span>('green', green)
<span class="hljs-built_in">print</span>('------------------------------------------------')
red = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
red<span class="hljs-selector-attr">[:,:,2]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(red)
cv2<span class="hljs-selector-class">.imshow</span>('red', red)
<span class="hljs-built_in">print</span>('------------------------------------------------')
colorfull = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>) 
colorfull<span class="hljs-selector-attr">[:,:,0]</span>=<span class="hljs-number">255</span>     #蓝色
colorfull<span class="hljs-selector-attr">[:,:,1]</span>=<span class="hljs-number">0</span>       #绿色
colorfull<span class="hljs-selector-attr">[:,:,2]</span>=<span class="hljs-number">255</span>     #红色
<span class="hljs-built_in">print</span>(colorfull)
cv2<span class="hljs-selector-class">.imshow</span>('colorfull', colorfull)

cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.4</span>   观察一张图像的部分像素点的某个通道上的数值改变，这张图像跟着怎么变化。
import numpy as np
import cv2
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">3</span>),dtype=np<span class="hljs-selector-class">.uint8</span>)  #数据太多看不明白到底哪些数据被改了，就用小数据实验：<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>),dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 0:100, 0]</span>=<span class="hljs-number">255</span>     #蓝色通道                                                                   #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 0:1, 0]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:,100:200, 1]</span>=<span class="hljs-number">255</span>    #绿色通道                                                                    #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:,1:3, 1]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 200:300, 2]</span>=<span class="hljs-number">255</span>   #红色通道                                                                   #  <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[:, 3:6, 2]</span>=<span class="hljs-number">255</span>
<span class="hljs-built_in">print</span>(img)
cv2<span class="hljs-selector-class">.imshow</span>('img', img)
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.5</span>  手动生成一张BGR模式的彩色图像
import numpy as np
import cv2
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>(img, '\n--------- \n', img[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>], '\n--------- \n', img[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])
cv2<span class="hljs-selector-class">.imshow</span>('img', img)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,3]</span>=<span class="hljs-number">255</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,0]</span>=<span class="hljs-selector-attr">[66,77,88]</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,1,1]</span> = <span class="hljs-number">3</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span> = <span class="hljs-number">4</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[0,2,0]</span> = <span class="hljs-number">5</span>
<span class="hljs-built_in">print</span>('\n--------- \n', img, '\n--------- \n', img[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])
cv2<span class="hljs-selector-class">.waitKey</span>(<span class="hljs-number">10000</span>)
cv2<span class="hljs-selector-class">.destroyAllWindows</span>()



#例<span class="hljs-number">2.6</span> 读取lenacolor图片，用循环更改图片的某些区域的像素值
import cv2
lena_color = cv2<span class="hljs-selector-class">.imread</span>(r'C:\Users\<span class="hljs-number">25584</span>\Desktop\lenacolor.png') 
cv2<span class="hljs-selector-class">.imshow</span>('before', lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">50</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>])

for <span class="hljs-selector-tag">i</span> in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):
        for k in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>):
            lena_color[i,j,k]=<span class="hljs-number">255</span>
            
for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>):
        lena_color[i,j]=[<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>]
        
for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>, <span class="hljs-number">150</span>):
    for j in <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>):
        lena_color[i,j]=<span class="hljs-number">0</span>
        
cv2.<span class="hljs-built_in">imshow</span>(<span class="hljs-string">'after'</span>, lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], lena_color[<span class="hljs-number">50</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">100</span>,<span class="hljs-number">0</span>])
cv2.<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">10000</span>)
cv2.<span class="hljs-built_in">destroyAllWindows</span>()
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#2</span><span class="hljs-selector-class">.7</span> 练习函数<span class="hljs-built_in">item</span>()和函数<span class="hljs-built_in">itemset</span>()的用法
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-built_in">print</span>(img, '\n', img.item(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>), <span class="hljs-number">255</span>)
<span class="hljs-selector-tag">img</span>
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<ul>
<li>
<p><strong>np.random.randint(a,b, size, dtype)函数</strong><br/>
函数的功能是随机生成一些整数。第一个参数是要生成的数的起始值，第二个参数是最大值，第三个参数是要生成的整数的形状，第四个参数是要生成的数的类型。</p>
</li>
<li>
<p><strong>函数item(a,b)</strong><br/>
函数的功能是索引出要访问的图像的某个像素点。函数返回要索引的像素点的值。<br/>
函数有两个参数，第一个参数是像素点的行，第二个参数是像素点的列。</p>
</li>
<li>
<p><strong>函数itemset((a,b),c)</strong> 函数用来修改指定像素点的像素值。本函数直接在原图像上修改，不返回任何值。 函数有两个参数，第一个参数是要修改的像素点，第二个参数是要修改的像素的值。</p>
</li>
<li>
<p><strong>说明</strong><br/>
item()函数和itemset()都是只能索引或者修个一个像素点！！！如果我们想索引或修改一批像素点时，我们就要用循环一个个像素点进行修改！！！</p>
<p>#例2.8 生成一个像素值为随机数的灰度图像<br/>
import numpy as np
import cv2
img = np.random.randint(0,256, size=(300, 300), dtype=np.uint8)
img
cv2.imshow('demo', img)
cv2.waitKey(10000)
cv2.destroyAllWindows()</p>
<p>#例2.9 读取灰度图像lena.bmp，并对其像素值进行索引、修改<br/>
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lena.bmp', 0)
#修改一个像素点：
print(lena.item(2,3))
lena.itemset((2, 3), 255)<br/>
print(lena.item(2, 3))
#修改一个区域的像素点：
cv2.imshow('xiu gai qian', lena)
for i in range(10, 50):
for j in range(20, 100):
lena.itemset((i,j), 255)
cv2.imshow('xiu gai hou', lena)
cv2.waitKey(10000)
cv2.destroyAllWindows()</p>
</li>
</ul>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css">#例<span class="hljs-number">2.10</span> 生成一个像素值为随机数的彩色图像，练习item()函数和itemset()函数：
import numpy as np
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>, size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), dtype=np<span class="hljs-selector-class">.uint8</span>)
<span class="hljs-selector-tag">img</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,0]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2, 1]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span>
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.item</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), <span class="hljs-number">255</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), <span class="hljs-number">255</span>), <span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.itemset</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), <span class="hljs-number">255</span>)
<span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,0]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2, 1]</span>, <span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[1,2,2]</span>
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.11 生成一个像素值为随机数的彩色图像</span>
img = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, size=(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>), dtype=np.uint8)
cv2.imshow(<span class="hljs-string">'random colorfull img'</span>, img)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.12 读取彩色图像lenacolor.png, 并对图像进行修改</span>
<span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
lena_color = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>)
cv2.imshow(<span class="hljs-string">'xiu gai qian'</span>, lena_color)
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">200</span>):
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>):
            lena_color.itemset((i,j,k),<span class="hljs-number">255</span>)
cv2.imshow(<span class="hljs-string">'xiu gai hou'</span>, lena_color)    
<span class="hljs-built_in">print</span>(lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], lena_color[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()
</code></pre>
<p><img alt="" src="" loading="lazy"/></p>
<h4 data-id="heading-4">四、ROI, Region of Interest, 感兴趣区域</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.13 获取lena的脸部信息，并将其显示出来</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>, -<span class="hljs-number">1</span>)
lena_face = lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]    <span class="hljs-comment">#用切片获取ROI</span>
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)    
cv2.imshow(<span class="hljs-string">'lena face'</span>, lena_face)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.14 给lena的脸部打码</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>, -<span class="hljs-number">1</span>)
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)

roi_1 = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, (<span class="hljs-number">180</span>, <span class="hljs-number">130</span>,<span class="hljs-number">3</span>), dtype=np.uint8)
lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]=roi_1
cv2.imshow(<span class="hljs-string">'color mask'</span>, lena)

roi_2 = np.zeros((<span class="hljs-number">180</span>, <span class="hljs-number">130</span>,<span class="hljs-number">3</span>),dtype=np.uint8)
roi_2[:,:,:]=<span class="hljs-number">255</span>
lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">220</span>:<span class="hljs-number">350</span>]=roi_2
cv2.imshow(<span class="hljs-string">'white mask'</span>, lena)

cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()



<span class="hljs-comment">#例2.15 将一幅图像内的ROI复制到另一幅图像内：给dollar换脸</span>
<span class="hljs-keyword">import</span> cv2
lena = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lena512.bmp'</span>, -<span class="hljs-number">1</span>)
dollar = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\dollar.bmp'</span>, -<span class="hljs-number">1</span>)
cv2.imshow(<span class="hljs-string">'lena'</span>, lena)
cv2.imshow(<span class="hljs-string">'dollar'</span>, dollar)
lena_face = lena[<span class="hljs-number">220</span>:<span class="hljs-number">400</span>, <span class="hljs-number">250</span>:<span class="hljs-number">350</span>]
dollar[<span class="hljs-number">160</span>:<span class="hljs-number">340</span>, <span class="hljs-number">200</span>:<span class="hljs-number">300</span>]=lena_face
cv2.imshow(<span class="hljs-string">'dollar2'</span>, dollar)
cv2.waitKey(<span class="hljs-number">10000</span>)
cv2.destroyAllWindows()
</code></pre>
<h4 data-id="heading-5">五、通道操作</h4>
<p>一个RGB彩色图像，在opencv中，它是按照B通道-G通道-R通道 的顺序存储的。</p>
<ul>
<li>
<p>通道拆分<br/>
1、索引方式拆分<br/>
2、函数方式拆分</p>
</li>
<li>
<p>通道合并</p>
<p>#例2.16 编写程序，演示图像通道拆分及通道值改变对彩色图像的影响
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
cv2.imshow('lena', lena)</p>
<p>b_tongdao = lena[:, :, 0]
g_tongdao = lena[:, :, 1]
r_tongdao = lena[:, :, 2]
cv2.imshow('b', b_tongdao)
cv2.imshow('g', g_tongdao)
cv2.imshow('r', r_tongdao)</p>
<p>lena[:, :, 0]=0
cv2.imshow('b_0', lena)
lena[:, :, 1]=0
cv2.imshow('g_0', lena)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#例2.17 使用函数cv2.split()函数拆图像通道, 并显示三个通道图像。
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
b,g,r = cv2.split(lena)
cv2.imshow('b', b)
cv2.imshow('g', g)
cv2.imshow('r', r)
cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#自主练习：把一张彩图的三个通道数据分别切出来，仍以彩图形式显示图像。
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')</p>
<p>lena1 = lena.copy()
lena1[:,:,1:3]=0
cv2.imshow('b', lena1)</p>
<p>lena2 = lena.copy()
lena2[:,:,0]=0
lena2[:,:,2]=0
cv2.imshow('g', lena2)</p>
<p>lena3 = lena.copy()
lena3[:,:,0:2]=0
cv2.imshow('r', lena3)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
<p>#例2.18 通道合并，使用函数cv2.merge()函数合并通道
import cv2
lena = cv2.imread(r'C:\Users\25584\Desktop\lenacolor.png')
b,g,r = cv2.split(lena)
bgr = cv2.merge([b,g,r])
rgb = cv2.merge([r,g,b])</p>
<p>cv2.imshow('bgr', bgr)
cv2.imshow('rgb', rgb)</p>
<p>cv2.waitKey(20000)
cv2.destroyAllWindows()</p>
</li>
</ul>
<p><strong>说明：通道顺序改变后，图像的显示效果也发生了改变。</strong></p>
<h4 data-id="heading-6">六、获取图像属性</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#例2.19 观察图像的常用属性值 </span>
<span class="hljs-keyword">import</span> cv2
lena_gray = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lena.bmp'</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment">#参数0表示图像被调整为单通道的灰度图像</span>
lena_color = cv2.imread(<span class="hljs-string">r'C:\Users\25584\Desktop\lenacolor.png'</span>)  <span class="hljs-comment">#彩色图像</span>
lena_gray.shape
lena_color.shape

lena_gray.size
lena_color.size

lena_gray.dtype
lena_color.dtype

dtype(<span class="hljs-string">'uint8'</span>)
</code></pre>
<p><strong>说明：</strong><br/>
shape属性是用来判断一幅图像是灰度图像还是彩色图像。<br/>
size属性返回的是图像的像素数目，即图像的'行x列x通道数'。灰度图像的通道数为1，彩色图像的通道数为3。<br/>
dtype属性返回图像的数据类型。</p>
<h4 data-id="heading-7">七、在图像上绘制几何图形</h4>
<p>绘制直线：cv.line(img, start, end, color, thickness) #img:要绘制直线的图像；start,end直线的起点和终点；color线条的颜色；thickness线条的宽度。<br/>
绘制圆形：cv.circle(img, centerpoint, r, color, thickness) #thickness表示线条的宽度，当这个参数=-1时生成闭合图案并填充颜色。<br/>
绘制矩形：cv.rectangle(img, leftupper, rightdown, color, thickness) #设置矩形的左上角和右下角坐标即可。<br/>
在图像中添加文字：cv.putText(img, text, station, font,fontsize, color, thickness, cv.LINE_AA) #text:要写入的文字；station:文本在图像中的放置位置(左下角)；字体、字体大小、颜色、宽度。</p>
<pre><code class="hljs language-scss" lang="scss">#例<span class="hljs-number">2.20</span> 生成一个全黑的图像，在图像上绘制上面的图形并添加文字  
import numpy as np
import cv2
import matplotlib<span class="hljs-selector-class">.pyplot</span> as plt
<span class="hljs-selector-tag">img</span> = np<span class="hljs-selector-class">.zeros</span>((<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">3</span>), np<span class="hljs-selector-class">.uint8</span>)

cv2<span class="hljs-selector-class">.line</span>(img, (<span class="hljs-number">0</span>,<span class="hljs-number">20</span>), (<span class="hljs-number">300</span>, <span class="hljs-number">200</span>), (<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)   #线段起点、终点、颜色、粗细
cv2<span class="hljs-selector-class">.rectangle</span>(img, (<span class="hljs-number">50</span>, <span class="hljs-number">80</span>), (<span class="hljs-number">120</span>, <span class="hljs-number">250</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>), <span class="hljs-number">3</span>)  #左上角坐标，右下角坐标
cv2<span class="hljs-selector-class">.circle</span>(img, (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>),<span class="hljs-number">60</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),-<span class="hljs-number">1</span>)    #圆心坐标，半径，-<span class="hljs-number">1</span>表示圆形里面填充颜色。
cv2<span class="hljs-selector-class">.putText</span>(img, 'opencv', (<span class="hljs-number">70</span>,<span class="hljs-number">40</span>), cv2<span class="hljs-selector-class">.FONT_HERSHEY_SIMPLEX</span>, <span class="hljs-number">2</span>, (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>), <span class="hljs-number">2</span>)   #左下角坐标

plt<span class="hljs-selector-class">.imshow</span>(img[:,:,::-<span class="hljs-number">1</span>])
plt<span class="hljs-selector-class">.title</span>('case show')
plt<span class="hljs-selector-class">.show</span>()
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain 框架核心向量存储]]></title>    <link>https://juejin.cn/post/7604344066579267635</link>    <guid>https://juejin.cn/post/7604344066579267635</guid>    <pubDate>2026-02-09T02:47:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604344066579267635" data-draft-id="7604039449468059698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain 框架核心向量存储"/> <meta itemprop="keywords" content="LangChain"/> <meta itemprop="datePublished" content="2026-02-09T02:47:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="草帽lufei"/> <meta itemprop="url" content="https://juejin.cn/user/501033035632093"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain 框架核心向量存储
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/501033035632093/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    草帽lufei
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:47:11.000Z" title="Mon Feb 09 2026 02:47:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">前言</h2>
<p>之前学习了LangChain中的嵌入，接下来学习LangChain中的向量存储</p>
<h2 data-id="heading-1">概念</h2>
<p>向量存储（Vector Store）是 LangChain 中用于存储和检索嵌入向量的组件</p>
<p>用于存储、管理文本 / 多模态数据转换后的向量，同时提供高效相似性检索能力</p>
<p>是 RAG（检索增强生成）、AI Agent 记忆、知识库问答等场景的基础，解决了大模型上下文窗口有限、无法记住海量外部知识的核心问题</p>
<h3 data-id="heading-2">什么是向量</h3>
<p>下面是自然语言处理和机器学习中的向量概念：</p>
<p>向量（Vector）是一个数值数组，用于表示文本或文档的语义信息。每个元素都代表了文本中的一个特征或维度，而向量的长度则决定了该文本的特征数量。</p>
<p>例如，考虑一个简单的文本分类任务，我们有两个类别：“情感分析”和“主题分类”。我们可以使用向量来表示每个文本的特征，例如：</p>
<ul>
<li>情感分析向量：[0.2, -0.3, 0.5]</li>
<li>主题分类向量：[-0.1, 0.4, -0.2]</li>
</ul>
<p>这些向量可以用于表示不同的文本，并且可以通过计算相似度来判断它们之间的关系</p>
<p>跨专业学习需要恶补的东西还是挺多的，概念的有时候看的也是似懂非懂(很多时候是一脸懵逼)</p>
<h2 data-id="heading-3">LangChain VectorStores 的核心功能</h2>
<p>看下常见的向量存储方案</p>
<h3 data-id="heading-4">FAISS</h3>
<p>FAISS 是 Facebook 开源的高效向量相似度检索库，全名是 Facebook AI Similarity Search。不得不感叹大厂是真叼，日常工作生活大部分都是大厂的产品和服务</p>
<p>FAISS 是 LangChain VectorStore 中最常用的本地向量存储方案之一，核心优势是开源免费、本地部署无额外成本、相似度检索速度极快，尤其适合中小规模向量数据（百万级以内）的 AI Agent、知识库问答等场景</p>
<p>这不完美匹配了我这种开发者现在的需求的吗，本地开发研究，再用个本地的知识库，用着 Ollama 跑起来的本地模型</p>
<h3 data-id="heading-5">Pinecone</h3>
<p>Pinecone 是 LangChain VectorStore 生态中托管式云向量数据库的代表，核心优势是全托管免运维、分布式高可用、超大规模向量检索快，无需本地部署索引，适配生产环境和大规模向量场景，适合需要稳定服务、不想维护底层存储的开发场景</p>
<p>Pinecone 就是云端网盘（平台托管、随时访问、支持超大文件、付费使用）</p>
<p>大规模企业级场景下用的，不适合个人学习研究场景</p>
<h3 data-id="heading-6">Chroma</h3>
<p>Chroma 是一款专为 LLM 应用设计的轻量级开源向量数据库，核心定位是「让向量存储变得简单」—— 无需复杂部署，一行代码即可启动，支持向量的存储、相似度检索、动态增删改，还能关联元数据（如文档来源、类型），像一个「专为 LLM 打造的本地向量记事本」</p>
<p>类比场景：FAISS 是一次性写入的本地 U 盘，Chroma 是可随时增删文件的本地移动硬盘，Pinecone 是云端网盘，Chroma 兼顾了本地的便捷性和动态更新的灵活性</p>
<h3 data-id="heading-7">Milvus</h3>
<p>Milvus 是 LangChain VectorStore 生态里工业级、开源、分布式、可扩展的向量数据库，主打大规模向量（亿级）、高性能检索、动态更新、高可用，是从本地开发到企业级生产的全链路向量存储方案，完美衔接 FAISS/Chroma（本地轻量）与 Pinecone（云端托管）的中间地带</p>
<p>类比：FAISS 是本地 U 盘，Chroma 是本地移动硬盘，Milvus 是本地可扩展服务器 + 云端集群，既能本地快速跑，也能支撑企业级大规模向量服务Milvus</p>
<p>上面的这些向量存储方案都实现了 <code>创建向量存储</code>、<code>相似度搜索</code>、<code>带分数的相似度搜索</code>、<code>最大边际相关性搜索</code>、<code>保存和加载</code> 等核心功能</p>
<h2 data-id="heading-8">相似度搜索的原理</h2>
<p>相似度搜索是向量存储的核心功能，基本原理是将查询文本转换为向量，计算查询向量与存储中所有向量的相似度，返回相似度最高的前几个结果</p>
<p>常用的相似度度量方法包括 <code>余弦相似度</code>、<code>欧氏距离</code>、<code>点积</code> 等</p>
<h2 data-id="heading-9">代码示例</h2>
<p>下面是 <code>FAISS</code> 向量存储的基础代码示例，其他类型的存储方案就先不写了，项目级层面用到再看</p>
<h3 data-id="heading-10">注意</h3>
<p><code>from langchain_community.embeddings import HuggingFaceEmbeddings</code> 为老版本写法，我这里运行时出现问题，需用新版本</p>
<p>新版本写法更简单，直接从 <code>langchain_huggingface</code> 导入 <code>HuggingFaceEmbeddings</code> 即可</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> FAISS
<span class="hljs-comment"># from langchain_community.embeddings import HuggingFaceEmbeddings</span>
<span class="hljs-keyword">from</span> langchain_huggingface <span class="hljs-keyword">import</span> HuggingFaceEmbeddings

<span class="hljs-comment"># 核心示例：FAISS 向量存储完整流程</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">faiss_vector_store_core_demo</span>():
    <span class="hljs-comment"># 1. 准备基础文本数据（待向量化的原始内容）</span>
    documents = [
        <span class="hljs-string">"LangChain 是用于开发语言模型应用的框架。"</span>,
        <span class="hljs-string">"FAISS 是 Facebook 开发的高效相似度搜索库。"</span>,
        <span class="hljs-string">"Embedding 模型将文本转换为数值向量表示。"</span>
    ]

    <span class="hljs-comment"># 2. 初始化嵌入模型（核心：文本转向量的工具）</span>
    <span class="hljs-comment"># 选用多语言模型，适配中文场景</span>
    embeddings = HuggingFaceEmbeddings(
        model_name=<span class="hljs-string">"sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"</span>
    )

    <span class="hljs-comment"># 3. 创建 FAISS 向量存储（核心步骤：文本→向量→入库）</span>
    <span class="hljs-comment"># from_texts 方法会自动完成：遍历文本→调用嵌入模型生成向量→存入 FAISS 索引</span>
    vector_store = FAISS.from_texts(documents, embeddings)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">" FAISS 向量库创建完成（文本已转为向量并存储）"</span>)

    <span class="hljs-comment"># 4. 向量检索（核心功能：根据查询向量找相似文本）</span>
    query = <span class="hljs-string">"什么是 FAISS？"</span>
    <span class="hljs-comment"># similarity_search：根据查询文本生成向量，在 FAISS 中找最相似的 top-k 结果</span>
    results = vector_store.similarity_search(query, k=<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 检索查询：<span class="hljs-subst">{query}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"检索结果：<span class="hljs-subst">{results[<span class="hljs-number">0</span>].page_content}</span>"</span>)

    <span class="hljs-comment"># 5. 向量库持久化（核心：保存到本地，避免重复生成向量）</span>
    save_path = <span class="hljs-string">"./faiss_core_index"</span>
    vector_store.save_local(save_path)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 向量库已保存到本地：<span class="hljs-subst">{save_path}</span>"</span>)

    <span class="hljs-comment"># 6. 加载本地向量库（核心：复用已生成的向量库）</span>
    loaded_vector_store = FAISS.load_local(
        save_path, 
        embeddings,
        allow_dangerous_deserialization=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 本地加载必需参数</span>
    )
    <span class="hljs-comment"># 验证加载结果</span>
    test_query = <span class="hljs-string">"什么是 Embedding？"</span>
    loaded_result = loaded_vector_store.similarity_search(test_query, k=<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n 加载后验证 - 查询：<span class="hljs-subst">{test_query}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"验证结果：<span class="hljs-subst">{loaded_result[<span class="hljs-number">0</span>].page_content}</span>"</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    faiss_vector_store_core_demo()

</code></pre>
<p>代码运行结果</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9d48fe634da48029d36b63432ce536e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=hlGz2QQ5zxPCR7kPHcg5bAd4ZI0%3D" alt="" loading="lazy"/></p>
<p>向量库持久化到本地会在项目对应目录生成 <code>faiss_core_index</code> 文件夹，包含索引文件和配置文件</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88ae14cf0d144af1a7bfb92bde6cc017~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=52lISNE80Plr%2FNe8Mh3mD2NyqXA%3D" alt="" loading="lazy"/></p>
<p>这种文件是无法直接在编辑器中打开的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fb74d6a736b4211973e713be39f4d00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6I2J5bi9bHVmZWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210033&amp;x-signature=Fzr1CxgdWnbKmNWyq2FYZIH30SI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">小结</h2>
<p>LangChain VectorStores 向量存储相关知识就基本了解了，并了解了 FAISS 向量存储的基本原理和代码实现，其他类型目前没有合适的时机和项目场景去尝试，就不展开了</p>
<p>接下来将在本地实现一个基于知识库的问答系统，实战操作一波</p>
<blockquote>
<p>欢迎留言交流，如果觉得有帮助，可以<code>点个赞</code>支持一下</p>
<p>公众号：草帽lufei</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏]]></title>    <link>https://juejin.cn/post/7603854784865927208</link>    <guid>https://juejin.cn/post/7603854784865927208</guid>    <pubDate>2026-02-09T03:05:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865927208" data-draft-id="7604036853129789455" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-09T03:05:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="悟鸣"/> <meta itemprop="url" content="https://juejin.cn/user/4107431171852270"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            全网最火的 Agent Skills 都在这了！这 7 个宝藏市场建议收藏
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4107431171852270/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    悟鸣
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:05:36.000Z" title="Mon Feb 09 2026 03:05:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近 Agent Skills 特别火，很多朋友都想找一些特别好用的、特别有用的 skills。</p>
<p>这篇文章给大家盘点一下比较知名且相对比较火爆的一些 skills 市场。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/492607feafb04371a21693726c832fc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=S4oDZE1Ga7h%2BD6MxYF8HsRx9ZJ4%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic 官方市场：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a>  ，官方的咱就不用多说了。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/405379c69ee74abe8c821173f724a9ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=uVMGEC7PqxyLZ9OkACeJioaSG5M%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic 黑客松冠军大佬的：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code" target="_blank" title="https://github.com/affaan-m/everything-claude-code" ref="nofollow noopener noreferrer">github.com/affaan-m/ev…</a></p>
<p>不仅包括 skills，还包括 commands、subagents、rules、hooks 等，搞 AI Coding 一定不能错过。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bdeb4d54c6b417b840aa0316fe25370~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=dUb7thzNve3PbwluuyOKulV0CEM%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a>  另外一个比较火爆的 Coding 相关的仓库。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b74f456ac1e42b790b86431e4a0284f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=602rvJyRpZsYxqI6BU7U4fpZAOg%3D" alt="图片" loading="lazy"/></p>
<p>我的 Skills 插件市场（夹带一下私货，哈哈，完全免费）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchujianyun%2Fskills" target="_blank" title="https://github.com/chujianyun/skills" ref="nofollow noopener noreferrer">github.com/chujianyun/…</a>  包括提示词自动优化和 skills 自动同步。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec6e915e6e8441fe89596151b9c124c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=e2cxr2vyMtMMnwaWAYBaWv4sDTw%3D" alt="图片" loading="lazy"/></p>
<p>很多朋友写提示词时存在两个痛点，一个是可能会说得不够清楚，存在歧义，还有一个痛点就是不知道有哪些专业的框架记不住，然后也不会写。</p>
<p>身边有朋友做 AI  业务自己写一个初版提示词，然后用我的提示词自动优化 skill 匹配最专业的框架，然后澄清和进行优化，反馈效果有提升。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be287f7690b24d6f893fe86e3fed3695~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=ICD%2B2EnyyGkx%2FE7UHSQuBsyn2fM%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.sh%2F" target="_blank" title="https://skills.sh/" ref="nofollow noopener noreferrer">skills.sh/</a>  这个网站的最大特色就是支持一个指令，自动检测多个知名 Agent，自动一键安装。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2f6df4ace104d6e82ce4741c50cb3c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=oMsCRRrb5QG4OVYnnsVWH6lsH28%3D" alt="图片" loading="lazy"/></p>
<p>Qoder 社区 <a href="https://link.juejin.cn?target=https%3A%2F%2Fqoder-community.pages.dev%2Fzh%2Fskills%2F" target="_blank" title="https://qoder-community.pages.dev/zh/skills/" ref="nofollow noopener noreferrer">qoder-community.pages.dev/zh/skills/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f655c1c3b7344b5be55dec89a69577e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=k882SUB0l%2FRhsCDOdNNX3dS4yo0%3D" alt="图片" loading="lazy"/></p>
<p>这里提供了很多 skills，比较大的特色就是按照岗位进行分类。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ced235b80bec45f38117d78454a7af1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=6M5ewUckYyJinLzt6EWENgSwzdo%3D" alt="图片" loading="lazy"/></p>
<p>官方也会精选一些高质量的 skills。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51a49cb0358b42de80637cb70f225d65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=ud%2BNfcWxhRHGHkYvaJDVAk1s%2FJg%3D" alt="图片" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fskillsmp.com%2F" target="_blank" title="https://skillsmp.com/" ref="nofollow noopener noreferrer">skillsmp.com/</a>  可以看到 skills 的增长趋势。里面的 skills 非常齐全，而且支持分类和排序。</p>
<hr/>
<p>你还有其他非常好的 skills 插件和聚合市场？欢迎留言补充！</p>
<p>欢迎关注我的公众号：<strong>悟鸣AI</strong>，后续会陆续分享比较有用的 AI 工具和比较好的 AI 经验，比较客观理性的 AI 观点等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/274f08d089e94a15b0e0636a834f983d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oKf6bij:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211229&amp;x-signature=EzbZBGqHFdAI04PIul6sCDMtelk%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[单点登录（SSO）系统]]></title>    <link>https://juejin.cn/post/7604080364354043931</link>    <guid>https://juejin.cn/post/7604080364354043931</guid>    <pubDate>2026-02-09T03:07:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364354043931" data-draft-id="7604080364353962011" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="单点登录（SSO）系统"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-09T03:07:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Aniugel"/> <meta itemprop="url" content="https://juejin.cn/user/3034307824198407"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            单点登录（SSO）系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3034307824198407/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Aniugel
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:07:21.000Z" title="Mon Feb 09 2026 03:07:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、整体架构设计（核心原则）</h3>
<p>先明确整体流程和核心约束，确保 Cookies 仅存储在认证中心域名下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc3290f3e98a42318021eae316cebada~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQW5pdWdlbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211240&amp;x-signature=dD7QRuoDyilshbCVGxgN2XepNUc%3D" alt="deepseek_mermaid_20260209_441885.png" loading="lazy"/></p>
<p>核心约束：</p>
<ul>
<li>仅 <strong>SSO 认证中心域名</strong> 下存储登录态 Cookie（如 <code>sso_token</code>）；</li>
<li>各业务系统前端<strong>不存储任何登录态 Cookie</strong>，仅在内存 /localStorage 存储临时业务 token；</li>
<li>跨域登录态通过「授权码模式」传递，避免 Cookie 跨域问题。</li>
</ul>
<h3 data-id="heading-1">二、各角色职责与提供的服务</h3>
<h4 data-id="heading-2">1. 前端（Vue3）：核心职责是「无 Cookie 登录态管理 + 跨域认证跳转」</h4>
<h5 data-id="heading-3">核心职责</h5>








































<table><thead><tr><th>职责项</th><th>具体操作</th><th>技术实现</th></tr></thead><tbody><tr><td>登录态检测</td><td>初始化时检测当前是否有有效业务 token，无则跳转认证中心</td><td>路由守卫（beforeEach）</td></tr><tr><td>认证跳转</td><td>拼接认证中心地址 + 业务系统回调地址，跳转至 SSO 登录页</td><td>动态拼接 URL 参数</td></tr><tr><td>授权码处理</td><td>认证中心重定向回业务系统时，解析 URL 中的授权码</td><td>URLSearchParams</td></tr><tr><td>临时 token 管理</td><td>存储业务后端返回的临时 token（内存 /localStorage），无 Cookie</td><td>Pinia/Vuex + 内存变量</td></tr><tr><td>接口请求拦截</td><td>所有接口请求携带临时 token（Header 中），无 Cookie 传递</td><td>Axios 拦截器</td></tr><tr><td>登出处理</td><td>跳转认证中心登出接口，清除本地临时 token</td><td>跳转 SSO 登出地址 + 清除本地存储</td></tr></tbody></table>
<h5 data-id="heading-4">前端提供的服务</h5>
<ul>
<li>标准化的认证跳转组件（可复用的 SSO 登录跳转逻辑）；</li>
<li>统一的 token 管理工具（Pinia/Vuex 模块，封装 token 增删查）；</li>
<li>跨域认证回调处理页面（callback.vue）；</li>
<li>无 Cookie 的接口请求封装（Axios 拦截器）。</li>
</ul>
<h4 data-id="heading-5">2. 后端：核心职责是「授权码校验 + 业务 token 生成 + 跨域认证接口」</h4>
<h5 data-id="heading-6">核心职责（分「认证中心后端」和「业务系统后端」）</h5>













































<table><thead><tr><th>角色</th><th>职责项</th><th>具体操作</th></tr></thead><tbody><tr><td>认证中心后端</td><td>登录接口</td><td>验证用户名密码，生成 sso_token，存储至认证中心 Cookie（仅本域名）</td></tr><tr><td>认证中心后端</td><td>授权码生成</td><td>验证业务系统合法性，生成一次性授权码，重定向回业务系统</td></tr><tr><td>认证中心后端</td><td>授权码校验</td><td>接收业务后端的校验请求，验证授权码有效性，返回 sso_token</td></tr><tr><td>认证中心后端</td><td>登出接口</td><td>清除认证中心 Cookie 中的 sso_token，并重定向至各业务系统登出页</td></tr><tr><td>业务系统后端</td><td>授权码兑换</td><td>接收前端的授权码，调用认证中心接口校验，获取 sso_token</td></tr><tr><td>业务系统后端</td><td>业务 token 生成</td><td>基于 sso_token 生成业务系统专属临时 token（JWT），返回前端</td></tr><tr><td>业务系统后端</td><td>接口鉴权</td><td>校验前端携带的业务 token，无 Cookie 校验</td></tr></tbody></table>
<h5 data-id="heading-7">后端提供的服务</h5>
<ul>
<li>认证中心：登录 / 登出 / 授权码生成 / 授权码校验接口；</li>
<li>业务系统：授权码兑换接口、业务 token 校验接口、统一鉴权拦截器；</li>
<li>跨域配置：允许业务系统前端跨域调用认证中心接口（CORS 配置）；</li>
<li>安全策略：Cookie 的 HttpOnly/Secure/SameSite 配置，防止 CSRF/XSS。</li>
</ul>
<h4 data-id="heading-8">3. 运维：核心职责是「域名 / 网络配置 + 安全策略 + 部署运维」</h4>
<h5 data-id="heading-9">核心职责</h5>








































<table><thead><tr><th>职责项</th><th>具体操作</th><th>技术实现</th></tr></thead><tbody><tr><td>域名规划</td><td>独立的认证中心域名（如<a href="https://link.juejin.cn?target=https%3A%2F%2Fsso.yourdomain.com" target="_blank" title="https://sso.yourdomain.com" ref="nofollow noopener noreferrer">sso.yourdomain.com</a>），与业务系统域名隔离</td><td>DNS 解析配置</td></tr><tr><td>HTTPS 配置</td><td>所有域名强制 HTTPS（Cookie 的 Secure 属性要求）</td><td>Nginx 配置 + SSL 证书部署</td></tr><tr><td>跨域配置</td><td>Nginx 层面配置 CORS，允许业务系统跨域访问认证中心</td><td>Nginx 的 add_header Access-Control-*</td></tr><tr><td>Cookie 安全配置</td><td>确保认证中心 Cookie 仅在本域名生效，禁止跨域携带</td><td>Nginx / 后端双重配置 Cookie 属性</td></tr><tr><td>部署架构</td><td>认证中心服务高可用部署，业务系统与认证中心网络互通</td><td>负载均衡（LB）+ 集群部署</td></tr><tr><td>日志监控</td><td>监控认证中心登录 / 登出日志，排查跨域认证问题</td><td>ELK/Prometheus + Grafana</td></tr></tbody></table>
<h5 data-id="heading-10">运维提供的服务</h5>
<ul>
<li>独立的 SSO 认证中心域名及 SSL 证书部署；</li>
<li>各业务系统域名与认证中心域名的 DNS 解析；</li>
<li>Nginx 层面的 HTTPS 强制跳转、CORS 配置、Cookie 安全配置；</li>
<li>认证中心服务的高可用部署（集群 / 负载均衡）；</li>
<li>日志监控系统（认证中心登录日志、跨域访问日志）；</li>
<li>安全策略配置（WAF 防护、接口限流、Cookie 防篡改）。</li>
</ul>
<h3 data-id="heading-11">三、关键安全注意事项</h3>
<ol>
<li>认证中心 Cookie 必须配置：<code>HttpOnly=true</code>（防止 XSS）、<code>Secure=true</code>（仅 HTTPS）、<code>SameSite=Strict</code>（禁止跨域携带）；</li>
<li>授权码必须是<strong>一次性、短期有效</strong>（如 5 分钟），防止复用；</li>
<li>业务系统临时 token 建议<strong>短期有效</strong>（如 2 小时），前端定期静默刷新（调用业务后端刷新接口，再调用认证中心校验 sso_token）；</li>
<li>所有接口必须 HTTPS，防止 token 明文传输。</li>
</ol>
<h3 data-id="heading-12">总结</h3>
<ol>
<li><strong>前端（Vue3）</strong> ：核心是「无 Cookie 登录态管理」，通过路由守卫跳转认证中心，解析授权码兑换临时 token，接口请求携带 token（Header）；</li>
<li><strong>后端</strong>：认证中心负责生成 sso_token 并存储至自身 Cookie，业务系统负责校验授权码、生成业务临时 token；</li>
<li><strong>运维</strong>：核心是域名隔离、HTTPS 配置、Cookie 安全策略，确保仅认证中心存储 Cookie，杜绝跨域 Cookie 风险。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python——彻底明白Super() 该如何使用]]></title>    <link>https://juejin.cn/post/7603854784865796136</link>    <guid>https://juejin.cn/post/7603854784865796136</guid>    <pubDate>2026-02-09T02:52:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865796136" data-draft-id="7603584155785691186" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python——彻底明白Super() 该如何使用"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-09T02:52:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AbsoluteLogic"/> <meta itemprop="url" content="https://juejin.cn/user/2068626334032586"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python——彻底明白Super() 该如何使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2068626334032586/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AbsoluteLogic
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:52:14.000Z" title="Mon Feb 09 2026 02:52:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">什么是Super()</h3>
<p>如果把类比作表演者的话，<code>Super()</code>则是按照清单（MRO）让下一位表演者“继续”他的表演</p>
<p>没听明白没关系，我们通过实际的例子来逐步拆解<code>Super()</code>的运行逻辑，到时候我们就能明白这句话的含义</p>
<h3 data-id="heading-1">为什么要用Super()</h3>
<p>和拆解<code>Property</code>一样，我们在拆解<code>Super()</code>前也要知道我们为什么要用它</p>
<p>我们同样通过实际的代码示例来理解</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>
        
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> self.price - <span class="hljs-number">20</span>
            <span class="hljs-comment"># 满减条件</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.price
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
</code></pre>
<p>我们定义了两种折扣机制，一种是会员价，一种是满减。我们可以根据不同的折扣方式，算出打折后的价格</p>
<p>但是，有一种情况我们并没有考虑，那就是两种折扣同时触发的情况。如果我们规定，当两个折扣方式同时满足时，先计算会员折后价，再考虑满减，我们该如何修改这段代码呢？</p>
<p>很简单，我们再定义一个类，就像这样</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> self.price - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 触发满减</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(<span class="hljs-title class_ inherited__">MemberOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        member_price = MemberOrder.get_total(self)
        <span class="hljs-keyword">if</span> member_price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> member_price - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> member_price
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
d = FinalOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(d.get_total())
<span class="hljs-comment"># 双重折扣后的价格</span>
</code></pre>
<p>如果要更换折扣顺序，先计算满减，再计算会员价，只要对<code>FinalOrder</code>进行修改就好</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(<span class="hljs-title class_ inherited__">PromotionOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        count_price = PromotionOrder.get_total(self)
        <span class="hljs-keyword">return</span> count_price * <span class="hljs-number">0.9</span>
</code></pre>
<p>我们这种修改，在类的数量也就是折扣方式比较少时没什么问题。但如果类的数量比较多，我们就要想办法，如何不用进行这么复杂的修改。这就是我们使用<code>super()</code>的原因</p>
<h3 data-id="heading-2">Super()的作用</h3>
<p>我们用<code>super()</code>对上面的代码进行优化</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicOrder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, price</span>):
        self.price = price

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.price
        <span class="hljs-comment"># 返回基础价格</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total() * <span class="hljs-number">0.9</span>
        <span class="hljs-comment"># 返回会员折后价</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromotionOrder</span>(<span class="hljs-title class_ inherited__">BasicOrder</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">super</span>().self.price &gt; <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total() - <span class="hljs-number">20</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
        <span class="hljs-comment"># 触发满减</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(MemberOrder, PromotionOrder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
        
a = BasicOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(a.get_total())
<span class="hljs-comment"># 原价</span>
b = MemberOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(b.get_total())
<span class="hljs-comment"># 会员折后价</span>
c = PromotionOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(c.get_total())
<span class="hljs-comment"># 满减价格</span>
d = FinalOrder(<span class="hljs-number">300</span>)
<span class="hljs-built_in">print</span>(d.get_total())
<span class="hljs-comment"># 双重折扣后的价格</span>
<span class="hljs-built_in">print</span>(FinalOrder.mro())
<span class="hljs-comment"># 打印Mro清单</span>
</code></pre>
<p>我们要注意最后的<code>Mro清单</code>，它的输出结果是<code>[&lt;class '__main__.FinalOrder'&gt;, &lt;class '__main__.MemberOrder'&gt;, &lt;class '__main__.PromotionOrder'&gt;, &lt;class '__main__.BasicOrder'&gt;, &lt;class 'object'&gt;]</code>。这也就是当我们计算<code>FinalOrder</code>中的最后价格时，程序的执行顺序</p>
<p>python按照这个顺序，先从<code>FinalOrder-MemberOrder-PromotionOrder-BasicOrder</code>这个链条进行递进寻找，然后再从反方向<code>BasicOrder-PromotionOrder-MemberOrder-FinalOrder</code>进行回归计算</p>
<p>上面的代码就是按照这个顺序，先把原价<code>BasicOrder</code>给<code>PromotionOrder</code>计算满减，再将满减后的值给<code>MemberOrder</code>计算会员折扣价，最后把值给<code>FinalOrder</code></p>
<p><code>return super().get_total()</code>其实就可以理解为<code>请MRO链条上的下一位先算出结果给我</code></p>
<p>如果我们需要改变折扣计算的方式，我们也无须对<code>FinalOrder</code>中的内容进行修改，只需要修改继承顺序，也就是对这个“链条”进行调整就好</p>
<p>当我们修改某些类名时，我们也不用像之前的“硬编码”那样逐个修改，只要确保继承的类名正确，<code>super()</code>会自己按照MRO这个链条进行寻找</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalOrder</span>(PromotionOrder, MemberOrder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_total()
</code></pre>
<h3 data-id="heading-3">结语</h3>
<p>如果文章中有什么错误或者可以优化的地方，欢迎大家指正，感谢！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端视角详解 Agent Skill]]></title>    <link>https://juejin.cn/post/7604012106154754094</link>    <guid>https://juejin.cn/post/7604012106154754094</guid>    <pubDate>2026-02-09T03:14:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106154754094" data-draft-id="7604646882015232051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端视角详解 Agent Skill"/> <meta itemprop="keywords" content="前端,JavaScript,后端"/> <meta itemprop="datePublished" content="2026-02-09T03:14:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随意_"/> <meta itemprop="url" content="https://juejin.cn/user/4222562141210478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端视角详解 Agent Skill
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222562141210478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随意_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:14:42.000Z" title="Mon Feb 09 2026 03:14:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在 AI 赋能前端开发的浪潮中，Agent 已从“辅助聊天”升级为“可落地的开发助手”，而 Agent Skill（智能体技能）正是让 Agent 摆脱“只会说不会做”、真正适配前端开发场景的核心能力支撑。对于前端开发者而言，Agent Skill 不是抽象的技术概念，而是能直接降低重复工作、规范开发流程、提升协作效率的实用工具——小到组件模板生成、代码格式化，大到批量重构、接口联调校验，都能通过定制 Skill 实现自动化落地。</p>
<p>本文将完全贴合前端开发实际，从 Agent Skill 的出现背景、核心价值、Cursor 实操 demo、加载逻辑、高级用法（Reference/Script 加载）、Token 消耗解析，到与 MCP 的核心区别，逐一拆解，让你既能快速上手使用，也能理解底层逻辑，真正把 Agent Skill 融入日常开发。</p>
<h2 data-id="heading-1">一、Agent Skill 出现背景：前端开发中，AI 的“痛点”催生需求</h2>
<p>在 Agent Skill 出现之前，前端开发者使用 AI 工具（如 Cursor、Copilot）时，始终面临三个无法解决的核心痛点，这些痛点直接限制了 AI 从“辅助工具”向“高效助手”的跨越，也正是 Agent Skill 诞生的核心原因：</p>
<h3 data-id="heading-2">1. 重复Prompt，效率低下</h3>
<p>前端开发中存在大量“固定流程类”工作，比如“生成符合项目规范的 Vue3 组件”，“格式化 Axios 请求拦截器”，“检查代码中的 ESLint 错误并修复”。每次使用 AI 时，都需要重复输入冗长的 Prompt，明确项目规范、代码风格、功能要求——比如每次生成组件，都要说明“使用 Setup 语法糖、配合 TailwindCSS、Props 需做类型校验、包含 emits 声明”，重复操作占用大量开发时间。</p>
<h3 data-id="heading-3">2. 上下文割裂，适配性差</h3>
<p>AI 无法“记住”项目的个性化规则：比如项目中自定义的工具函数、接口请求规范、路由配置逻辑、UI 组件库的封装规范等。每次提问都需要重新提供这些上下文，否则生成的代码会与项目脱节（比如生成的按钮组件不匹配项目封装的 Button 组件、接口请求未遵循全局拦截器规则），后续需要手动修改，反而增加工作量。</p>
<h3 data-id="heading-4">3. 能力局限，无法联动执行</h3>
<p>传统 AI 只能“生成代码”，无法“执行操作”：比如生成批量修改文件名的脚本后，需要开发者自己复制脚本、在终端执行；生成接口文档后，无法自动关联到项目的 Swagger 文档中；发现代码中的路径错误后，无法自动定位并修改。AI 与实际开发流程脱节，无法形成“提出需求→AI 处理→完成落地”的闭环。</p>
<p>为了解决这些痛点，Agent Skill 应运而生——它本质是“给 Agent 预设的、可复用的技能模板”，把前端开发中的固定流程、项目规范、操作逻辑，封装成 Agent 能直接调用的“技能”，无需重复 Prompt、无需反复提供上下文，Agent 就能精准适配项目需求，甚至联动执行相关操作，真正实现“一次封装，多次复用”的高效开发模式。</p>
<h2 data-id="heading-5">二、Agent Skill 核心价值：解决前端 AI 开发的 3 大痛点</h2>
<p>结合前端开发场景，Agent Skill 的核心价值的是“标准化、自动化、可复用”，精准解决上述痛点，具体落地为 3 点，每一点都能直接提升开发效率：</p>
<ol>
<li><strong>省去重复 Prompt</strong>：将项目规范、操作流程封装成 Skill，调用时只需输入简单指令（如“生成用户卡片组件”），Agent 就会按照 Skill 中的预设规则执行，无需重复说明细节；</li>
<li><strong>关联项目上下文</strong>：Skill 可内置项目的个性化配置（如工具函数、接口规范、组件风格），Agent 调用 Skill 时自动加载这些上下文，生成的代码直接适配项目，无需手动修改；</li>
<li><strong>联动执行操作</strong>：通过 Skill 中的脚本（Script）和参考资料（Reference），Agent 不仅能生成代码，还能执行脚本、读取参考文档，实现“生成→执行→校验”的闭环（如批量重构代码、自动校验接口参数）。</li>
</ol>
<p>简单来说，Agent Skill 就像给前端 AI 助手“制定了详细的工作手册”，手册中明确了“做什么、怎么做、遵循什么规则、需要用到什么资料”，让 AI 从“只会猜”变成“懂规则、会操作”的专属助手，这也是其与传统 Prompt 最大的区别。</p>
<h2 data-id="heading-6">三、实操 Demo：用 Cursor 玩转 Agent Skill</h2>
<p>Cursor 是前端开发者最常用的 AI 代码编辑器，其内置的 Agent Skill 功能简洁、易上手，完全贴合前端开发场景。下面我们以“前端最常用的 2 个场景”为例，一步步演示 Agent Skill 的安装、配置、调用全过程，新手也能快速上手（全程无需复杂操作，纯前端视角，不涉及后端部署）。</p>
<p>前置准备：确保 Cursor 已更新至最新版本，我是用的 目前是 <code>2.4.28</code>，打开 Cursor 设置（Ctrl+Shift+J / Cmd+Shift+J），开启“Agent Skills”开关（默认开启）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41f6b5003c3946c691c1f9796d6e5c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=ntDelE5KLq9%2BIgqwcX5l%2BnU2mbY%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">Demo 1：基础用法——封装“Vue3 组件生成 Skill”，一键生成符合项目规范的组件</h3>
<p>场景：前端项目中，所有 Vue3 组件都需遵循“Setup 语法糖+TailwindCSS+Props 类型校验+emits 声明”的规范，每次生成组件都要重复说明，我们通过封装 Skill 解决这个问题。</p>
<ol>
<li>
<p>打开 Cursor，进入当前前端项目（如 Vue3+Tailwind 项目）；</p>
</li>
<li>
<p>开 Cursor 设置（Ctrl+Shift+J / Cmd+Shift+J）,点击创建 skills</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d69ddd424c914b188782d32e8422c565~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=Qr50YqXveCoRA%2BWB19k3WS9dn%2Bo%3D" alt="image.png" loading="lazy"/>
3. 此时agent对话框展开，使用agent生成 对应的skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e04c9aefac7144aeafcd219f09162a26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=%2FSCGPBMkf7A4hkgO7i97Gzi0CEI%3D" alt="image.png" loading="lazy"/></p>
<ol start="4">
<li>可以看见 已经生成了 项目级别的  skill</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5649f08cf4f442682c084544c8233de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=hZ7u8V1Ad%2BYOWjUGXCVH3LsugyU%3D" alt="image.png" loading="lazy"/></p>
<p>你也可以复制对应的 提示词</p>
<pre><code class="hljs language-md" lang="md">
/create-skill Help me create this skill for Cursor: /create-skill Help me create this skill for Cursor: 名字为：vue3-component-gen 适用范围是这个 vue3-skills的 项目， 内容规则为： # Vue3 组件生成技能（前端专用）

<span class="hljs-section">## 技能描述</span>

根据用户需求，生成符合项目规范的 Vue3 单文件组件（SFC），严格遵循以下规则：

<span class="hljs-bullet">1.</span> 语法：使用 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span> 语法糖，不使用 Options API；

<span class="hljs-bullet">2.</span> 样式：使用 TailwindCSS，不写原生 CSS，样式需简洁、适配响应式；

<span class="hljs-bullet">3.</span> Props：所有传入参数需用 defineProps 定义，并做类型校验（使用 TypeScript）；

<span class="hljs-bullet">4.</span> Emits：组件触发的事件需用 defineEmits 声明，明确事件参数类型；

<span class="hljs-bullet">5.</span> 结构：模板结构清晰，包含注释，组件根节点使用 div，添加基础样式类；

<span class="hljs-bullet">6.</span> 依赖：不引入项目中未使用的依赖，如需使用 UI 组件，仅使用 Element Plus。

  


<span class="hljs-section">## 使用场景</span>

用户输入“生成XX组件”“写一个XX组件”时，自动触发该技能，无需额外提示。

  


<span class="hljs-section">## 示例</span>

用户需求：生成用户卡片组件（包含头像、姓名、手机号）

生成结果需符合上述所有规则，Props 包含 avatar（字符串）、name（字符串）、phone（字符串），emits 包含 click（参数为用户信息对象）。
</code></pre>
<h4 data-id="heading-8">步骤 2：调用 Skill，一键生成组件</h4>
<ol>
<li>
<p>重启 Cursor（确保 Skill 被识别）；</p>
</li>
<li>
<p>打开 Cursor 的 Agent 聊天框（Ctrl+L / Cmd+L），输入简单指令：<code>生成用户卡片组件，包含头像、姓名、手机号、邮箱， 使用的哪些skill 请你列出来</code>；</p>
</li>
<li>
<p>无需额外补充规范，Cursor 会自动触发 <code>vue3-component-gen</code> Skill，生成符合项目规范的组件代码，直接复制使用即可（无需手动修改语法、样式规范）。</p>
</li>
</ol>
<p>效果如下 ，注意会列出 使用的 skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89b3a2da962e41ca920c5c018924473d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=FzNltfQpDXrDZMhazpPKxqrB%2BmQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bac39798999c4cf285199f2b7c11680c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=%2BQWxIZVO8FqttxLGMYepST6XjPo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce77f31abc2b439da225d3b12971e482~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=3aSaiuspn9PmKJl2KNEeO9320JE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-9">Demo 2：进阶用法——封装“ESLint 错误修复 Skill”，自动修复代码规范问题</h3>
<p>场景：前端项目使用 ESLint 规范代码（如禁止 var 声明、强制使用单引号、禁止console.log），每次写完代码都要手动修复 ESLint 错误，效率低下，我们通过 Skill 实现自动修复。</p>
<p>创建的流程如第一demo，提示词如下</p>
<pre><code class="hljs language-md" lang="md">/create-skill Help me create this skill for Cursor: 帮我创建 名字是：eslint-fix 作用域是当前项目，内容是 # ESLint 错误修复技能（前端专用）

<span class="hljs-section">## 技能描述</span>

识别用户提供的前端代码（JS/TS/Vue）中的 ESLint 错误，自动修复，严格遵循项目 ESLint 规范：

<span class="hljs-bullet">1.</span> 变量声明：禁止使用 var，优先使用 const，可变变量使用 let；

<span class="hljs-bullet">2.</span> 引号：所有字符串强制使用单引号，禁止双引号；

<span class="hljs-bullet">3.</span> 控制台输出：禁止使用 console.log、console.warn 等控制台打印语句，直接删除；

<span class="hljs-bullet">4.</span> 分号：语句结尾不添加分号（适配前端项目常见规范）；

<span class="hljs-bullet">5.</span> 缩进：使用 2 个空格缩进，禁止使用 Tab；

<span class="hljs-bullet">6.</span> 结尾：修复后，需输出修复说明（列出修复的错误类型及数量）。

  


<span class="hljs-section">## 使用场景</span>

用户输入“修复这段代码的 ESLint 错误”“ESLint 校验修复”，或直接粘贴存在 ESLint 错误的代码，自动触发该技能。

  


<span class="hljs-section">## 注意事项</span>

修复时不改变代码原有功能，仅修复 ESLint 规范相关问题；若有无法自动修复的错误，需提示用户手动修改。
</code></pre>
<p>创建成功 你可以看到 多了一个 <code>eslint-fix</code>的skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5564d8bee9b94746badfca100fa385c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=49qRv1PaSXEYV7GKk%2FzJKc90N5E%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-10">步骤 2：调用 Skill 修复代码</h4>
<ol>
<li>在项目中 创建一个js文件 输入有eslint报错的 js如下</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d51612945ce49cf9564beae90174c08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=JqJXha%2BfU5pdzxAXW0XxLYuFum4%3D" alt="image.png" loading="lazy"/></p>
<ol start="2">
<li>选中 并添加 chat，你可以使用  <code>ctrl+k</code> 快捷键实现</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/722205a0ed4b4725bf53093c193ce210~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=4wqF7YWP0Rb4WeNIKj%2BBwvl%2BXDc%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>在 Agent 聊天框中输入指令：<code>修复这段代码的 ESLint 错误 ，并列出你使用了哪些skill</code></li>
<li>Cursor 自动触发 <code>eslint-fix</code> Skill，修复后的代码如下（完全符合规范），并输出修复说明</li>
</ol>
<p>可以看见 被修复了 列出了 修改的 内容说明</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc391effcb9d458a9de501560d7ef195~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=LRcPF2Q1%2F%2BUKh0qpYRsEszioJBM%3D" alt="image.png" loading="lazy"/></p>
<p>通过这两个 Demo 可以发现，Agent Skill 完全贴合前端开发的实际需求，核心是“一次封装，无限复用”，把重复、机械的工作交给 AI，开发者专注于核心业务逻辑——这也是 Agent Skill 最受前端开发者欢迎的原因。</p>
<h2 data-id="heading-11">四、Agent Skill 高级用法：Reference 与 Script 加载方式</h2>
<p>对于前端开发者而言，基础的 Skill（仅配置 SKILL.md）只能满足“生成、修复代码”等简单场景；而高级用法——Reference（参考资料加载）和 Script（脚本加载），能让 Agent Skill 实现更复杂的前端开发需求（如接口联调、批量重构、规范校验），也是前端开发者需要重点掌握的内容。</p>
<p>下面我们分别拆解 Reference 和 Script 的核心作用、加载方式，结合前端实际场景（如接口联调、批量修改组件名称），让你能直接落地使用。</p>
<h3 data-id="heading-12">1. Reference 加载：按需加载“参考资料”，让 Skill 更贴合项目</h3>
<h4 data-id="heading-13">核心作用</h4>
<p>Reference 是 Agent Skill 的“参考资料库”，可存放前端项目中的个性化配置、规范文档、接口信息等，Skill 执行时，按需加载这些资料，让生成的代码、执行的操作完全适配项目——比如存放项目的接口文档、ESLint 配置、UI 组件封装规范等，避免每次调用 Skill 都手动提供这些上下文，本质是“给 Skill 提供项目专属的‘知识库’”。</p>
<h4 data-id="heading-14">前端常用场景</h4>
<ul>
<li>
<p>场景 1：接口联调 Skill，加载项目的接口文档（如 Swagger 导出的 JSON 文件），生成符合接口规范的请求代码（自动匹配接口地址、请求方式、参数类型）；</p>
</li>
<li>
<p>场景 2：组件生成 Skill，加载项目的 UI 组件封装规范（如自定义 Button、Card 组件的使用文档），生成的组件自动复用项目封装的 UI 组件；</p>
</li>
<li>
<p>场景 3：路由配置 Skill，加载项目的路由规范（如路由命名规则、嵌套路由配置要求），生成符合规范的路由配置代码。</p>
</li>
</ul>
<h4 data-id="heading-15">加载方式（结合 Cursor 实操）</h4>
<p>Reference 的加载方式是“条件触发、按需加载”，步骤如下（贴合前端项目结构）：</p>
<ol>
<li>步骤 1：在 Skill 文件夹中，创建 <code>reference</code> 子文件夹（固定名称，Cursor 会自动识别）；</li>
<li>步骤 2：将需要的参考资料放入该文件夹（支持多种格式：.md、.json、.js、.txt 等，前端常用 .md 文档和 .json 接口文档）；</li>
<li>步骤 3：在 SKILL.md 中，明确“加载条件”——即“什么时候需要加载这份参考资料”；</li>
<li>步骤 4：调用 Skill 时，当满足加载条件，Cursor 会自动加载对应的 Reference 文件，执行完成后自动释放。</li>
</ol>
<h4 data-id="heading-16">实操示例：接口请求 Skill 加载 Reference 接口文档</h4>
<ol>
<li>
<p>新建 Skill  <code>api-request-gen</code>，创建 <code>reference</code> 子文件夹，放入项目的接口文档 <code>api-docs.md</code>（内容示例：用户列表接口：GET /api/user/list，参数：pageNum（number）、pageSize（number），返回值：{ code: 200, data: { list: [], total: 0 } }）；</p>
</li>
<li>
<p>在 <code>SKILL.md</code> 中添加加载条件：</p>
</li>
</ol>

<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 接口请求代码生成 Skill</span>
<span class="hljs-meta">## 技能描述</span>
生成符合项目接口规范的 Axios 请求代码，自动匹配接口地址、请求方式、参数类型。
<span class="hljs-meta">## Reference 加载条件</span>
当用户需要生成“接口请求代码”，且提及具体接口名称（如用户列表、登录接口）时，自动加载 reference/api-docs.md 文档，获取接口信息。
<span class="hljs-meta">## 规则</span>
<span class="hljs-number">1.</span> 请求代码使用项目全局封装的 Axios 实例（import request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>）；
<span class="hljs-number">2.</span> 生成请求函数，包含参数类型校验（TypeScript）；
<span class="hljs-number">3.</span> 处理请求异常（<span class="hljs-keyword">try</span>/<span class="hljs-keyword">catch</span> 包裹，抛出异常提示）。
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3bed830464a4bdaa189d6607ce5bd41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=Lp31V3PPbgWA6FI8Z5Nj6xPRG%2B0%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/734e4ed19faf49e7b015a67873bc3bed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=uXvX1mNoclOjE8m10qxfBKqLKx0%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>调用 Skill：输入“生成用户列表接口的请求代码，保存在user.js里面，没有的你创建一个js”，Cursor 会自动加载 <code>reference/api-docs.md</code>，生成符合项目接口规范的请求代码，无需手动输入接口地址、参数类型：</li>
</ol>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-comment">/**
 * 用户列表接口请求函数
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">params</span> - 请求参数
 * <span class="hljs-doctag">@param</span> params.pageNum - 页码（必填）
 * <span class="hljs-doctag">@param</span> params.pageSize - 每页条数（必填）
 * <span class="hljs-doctag">@returns</span> 用户列表数据
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">params: { pageNum: <span class="hljs-built_in">number</span>; pageSize: <span class="hljs-built_in">number</span> }</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>({
      <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/user/list'</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
      params
    })
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取用户列表失败：'</span>, error)
    <span class="hljs-keyword">throw</span> error
  }
}
</code></pre>
<p>可以看见输出结果
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2706f1a406e46479c4c7b47ad2e1846~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=uldiduZ4KOwl6%2Bl6ArFwGQvY5e4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-17">2. Script 加载：按需加载“可执行脚本”，让 Skill 实现“自动操作”</h3>
<h4 data-id="heading-18">核心作用</h4>
<p>Script 是 Agent Skill 的“可执行操作模块”，可存放前端常用的脚本（如 JS/TS 脚本），Skill 执行时，按需加载并执行这些脚本，实现“生成代码→自动执行操作”的闭环——比如批量修改组件文件名、自动格式化所有 Vue 文件、批量替换接口地址等，本质是“给 Skill 赋予‘执行操作’的能力”，解决传统 AI“只会生成、不会执行”的痛点。</p>
<h4 data-id="heading-19">前端常用场景</h4>
<ul>
<li>
<p>场景 1：批量重构脚本：将项目中所有的 Vue2 组件，批量修改为 Vue3 Setup 语法（无需手动逐个修改）；</p>
</li>
<li>
<p>场景 2：文件操作脚本：批量修改组件文件名（如将 UserCard.vue 改为 UserCardItem.vue），同时修改组件内部的引入路径；</p>
</li>
<li>
<p>场景 3：规范校验脚本：遍历项目所有 JS/TS 文件，检查是否存在未使用的变量，自动删除冗余代码。</p>
</li>
</ul>
<h4 data-id="heading-20">加载方式（结合 Cursor 实操）</h4>
<p>Script 的加载方式是“执行时加载、沙箱运行”，步骤如下（贴合前端项目结构），重点注意：前端脚本仅在 Cursor 内置的沙箱环境中执行，不会影响本地项目文件（需手动确认执行结果后，再应用到本地项目，避免误操作）：</p>
<ol>
<li>步骤 1：在 Skill 文件夹中，创建 <code>scripts</code> 子文件夹（固定名称，Cursor 会自动识别）；</li>
<li>步骤 2：将可执行脚本放入该文件夹（前端常用 JS/TS 脚本，需保证脚本可独立执行，不依赖项目外部依赖）；</li>
<li>步骤 3：在 SKILL.md 中，明确“脚本执行条件”——即“什么时候需要执行这份脚本”；</li>
<li>步骤 4：调用 Skill 时，当满足执行条件，Cursor 会自动加载对应的 Script 脚本，在沙箱环境中执行，执行完成后输出结果，用户确认无误后，可将结果应用到本地项目。</li>
</ol>
<h4 data-id="heading-21">实操示例：批量修改组件文件名脚本（前端高频需求）</h4>
<ol>
<li>新建 Skill 文件夹 <code>batch-rename-component</code>，创建 <code>scripts</code> 子文件夹，放入脚本文件 <code>rename-component.js</code>（前端常用 JS 脚本，功能：批量将项目中所有“Card.vue”结尾的组件，改为“CardItem.vue”，同时修改组件内部的引入路径）：</li>
</ol>

<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// scripts/rename-component.js</span>
<span class="hljs-comment">// 批量修改组件文件名脚本（Cursor 沙箱执行，不直接修改本地文件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fs</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-comment">// 项目组件目录（前端项目常见目录）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">componentDir</span> = path.<span class="hljs-title function_ invoke__">join</span>(__dirname, <span class="hljs-string">'../../src/components'</span>)

<span class="hljs-comment">// 遍历目录，修改文件名和引入路径</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">renameComponents</span> = () =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">files</span> = fs.<span class="hljs-title function_ invoke__">readdirSync</span>(componentDir)
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">modifiedFiles</span> = []
  
  files.<span class="hljs-title function_ invoke__">forEach</span>(file =&gt; {
    <span class="hljs-keyword">if</span> (file.<span class="hljs-title function_ invoke__">endsWith</span>(<span class="hljs-string">'Card.vue'</span>)) {
      <span class="hljs-comment">// 新文件名</span>
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newFileName</span> = file.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">'Card.vue'</span>, <span class="hljs-string">'CardItem.vue'</span>)
      <span class="hljs-comment">// 旧文件路径和新文件路径</span>
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">oldPath</span> = path.<span class="hljs-title function_ invoke__">join</span>(componentDir, file)
      <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">newPath</span> = path.<span class="hljs-title function_ invoke__">join</span>(componentDir, newFileName)
      
      <span class="hljs-comment">// 读取文件内容，修改引入路径</span>
      let content = fs.<span class="hljs-title function_ invoke__">readFileSync</span>(oldPath, <span class="hljs-string">'utf8'</span>)
      content = content.<span class="hljs-title function_ invoke__">replace</span>(/import .* <span class="hljs-keyword">from</span> <span class="hljs-string">'./(.*)Card'</span>/g, (<span class="hljs-keyword">match</span>, p1) =&gt; {
        <span class="hljs-keyword">return</span> `import ${p1}CardItem <span class="hljs-keyword">from</span> <span class="hljs-string">'./${p1}CardItem'</span>`
      })
      
      <span class="hljs-comment">// 模拟修改（沙箱环境中不实际写入文件，仅输出结果）</span>
      modifiedFiles.<span class="hljs-title function_ invoke__">push</span>({
        <span class="hljs-attr">oldName</span>: file,
        <span class="hljs-attr">newName</span>: newFileName,
        <span class="hljs-attr">path</span>: componentDir
      })
    }
  })
  
  <span class="hljs-keyword">return</span> {
    success: <span class="hljs-literal">true</span>,
    modifiedCount: modifiedFiles.length,
    modifiedFiles
  }
}

<span class="hljs-comment">// 执行脚本并输出结果</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = <span class="hljs-title function_ invoke__">renameComponents</span>()
console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'批量修改结果：'</span>, result)
</code></pre>
<p>2.  在 <code>SKILL.md</code> 中添加脚本执行条件：</p>

<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 组件批量重命名 Skill</span>
<span class="hljs-section">## 技能描述</span>
批量修改项目中 Vue 组件的文件名，同时修改组件内部的引入路径，避免路径错误。
<span class="hljs-section">## Script 执行条件</span>
当用户输入“批量修改组件文件名”“批量重命名 Card 组件”时，自动加载 scripts/rename-component.js 脚本，执行批量修改操作。
<span class="hljs-section">## 注意事项</span>
<span class="hljs-bullet">1.</span> 脚本在 Cursor 沙箱环境中执行，不直接修改本地文件；
<span class="hljs-bullet">2.</span> 执行完成后，输出修改结果（修改的文件列表、数量）；
<span class="hljs-bullet">3.</span> 用户确认无误后，可手动将修改结果应用到本地项目。
</code></pre>
<p>3.  调用 Skill：输入“批量重命名 Card 组件”，Cursor 会自动加载并执行 <code>rename-component.js</code> 脚本，输出修改结果（如“修改了 3 个文件，分别是 UserCard.vue → UserCardItem.vue、GoodsCard.vue → GoodsCardItem.vue”），用户确认无误后，可手动修改本地文件，完成批量重构。</p>
<h3 data-id="heading-22">Reference 与 Script 加载核心区别（前端视角）</h3>























<table><thead><tr><th>加载类型</th><th>核心作用</th><th>加载时机</th><th>前端类比</th></tr></thead><tbody><tr><td>Reference</td><td>提供参考资料，让 Skill 贴合项目</td><td>满足触发条件时加载，执行完成后释放</td><td>组件加载时，按需引入的配置文件（如 .env 文件）</td></tr><tr><td>Script</td><td>执行具体操作，实现自动化闭环</td><td>满足执行条件时加载，执行完成后销毁</td><td>组件挂载后，按需执行的工具函数（如批量处理数据的函数）</td></tr></tbody></table>
<h2 data-id="heading-23">五、Agent Skill 加载逻辑</h2>
<p>很多前端开发者使用 Agent Skill 时会有疑问：“我封装了很多 Skill，会不会占用过多资源？会不会影响 AI 响应速度？” 答案是不会——因为 Agent Skill 采用了“按需加载”的核心逻辑，与前端的“路由懒加载”“组件按需引入”原理完全一致，都是“需要时加载，不需要时不占用资源”，最大化提升效率、节省开销。</p>
<p>结合前端开发的认知，我们把 Agent Skill 的加载逻辑拆解为“三个阶段”，每个阶段对应明确的加载时机和内容，同时结合 Cursor 的实际加载行为，让你一看就懂：</p>
<h3 data-id="heading-24">1. 初始化阶段：仅加载“Skill 元数据”（轻量加载）</h3>
<p>当你打开 Cursor 并进入项目时，Cursor 会自动扫描项目根目录下的 <code>.cursor/skills</code> 文件夹，此时仅加载每个 Skill 的“元数据”——也就是 Skill 的名称、描述（来自 SKILL.md 中的“技能描述”部分），相当于前端项目初始化时，仅加载路由表（不加载具体组件）。</p>
<p>特点：元数据体积极小，加载速度极快，几乎不占用资源（类比前端加载路由表，仅包含路径和组件名称，不加载组件代码）；此时 Skill 并未真正“激活”，仅让 Cursor 知道“当前项目有哪些 Skill，每个 Skill 能做什么”。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32235b1b69b4423589fb4b5fa5dca86b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZqP5oSPXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771211702&amp;x-signature=9nTOuvJe6gVAyHRlRpV9eFL6ErA%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-25">2. 触发阶段：按需加载“Skill 核心规则”（精准加载）</h3>
<p>当你输入指令，Cursor 判定需要调用某个 Skill 时（比如输入“生成 Vue3 组件”，Cursor 匹配到 <code>vue3-component-gen</code> Skill），才会加载该 Skill 的核心规则——也就是 SKILL.md 中的全部内容（规则、场景、示例等），相当于前端点击某个路由时，才懒加载对应的组件代码。</p>
<p>特点：仅加载“当前需要的 Skill”，其他 Skill 仍处于“元数据状态”，不占用额外资源；比如你调用“ESLint 修复 Skill”时，仅加载 <code>eslint-fix</code> 的 SKILL.md 内容，<code>vue3-component-gen</code> 仍仅保留元数据，不会被加载。</p>
<h3 data-id="heading-26">3. 执行阶段：按需加载“Skill 依赖资源”（按需中的按需）</h3>
<p>当 Skill 执行过程中，需要用到参考资料（Reference）或脚本（Script）时，才会加载对应的依赖资源——比如某个 Skill 需要读取项目的 ESLint 配置文件（.eslintrc.js），才会加载该参考文件；需要执行批量修改脚本，才会加载对应的 Script 文件，相当于前端组件渲染时，按需加载依赖的图片、工具函数（不渲染时不加载）。</p>
<p>特点：依赖资源仅在“需要时”加载，执行完成后自动释放，避免资源占用；比如 Skill 执行完成后，加载的参考文件、脚本会自动销毁，不会一直占用内存（类比前端组件卸载时，销毁组件实例和依赖资源）。</p>
<h3 data-id="heading-27">核心总结</h3>
<p>Agent Skill 的加载逻辑 = 前端“路由懒加载” + “组件按需引入”的结合体：</p>
<ul>
<li>元数据加载 → 路由表加载（初始化轻量加载）；</li>
<li>核心规则加载 → 路由对应组件加载（触发时精准加载）；</li>
<li>依赖资源加载 → 组件依赖的图片/工具函数加载（执行时按需加载）。</li>
</ul>
<p>这种加载逻辑，既保证了 Skill 调用的高效性，又避免了资源浪费，完全适配前端开发中“轻量初始化、按需加载”的核心需求，这也是 Agent Skill 能在前端开发中广泛应用的重要原因之一。</p>
<h2 data-id="heading-28">六、按需加载的 Token 消耗解析（前端开发者必看）</h2>
<p>对于使用 AI 工具（如 Cursor、Claude）的前端开发者而言，Token 消耗直接关系到使用成本（部分工具按 Token 收费），而 Agent Skill 的“按需加载”逻辑，核心优势之一就是“精准控制 Token 消耗”——避免加载无用内容，最大化节省 Token，这也是前端开发者使用 Skill 时需要重点关注的点。</p>
<p>下面我们从“Token 消耗的核心逻辑”“不同加载阶段的 Token 消耗”“前端场景下的 Token 节省技巧”三个维度，结合实测数据，详细解析，让你既能明白“Token 花在哪”，也能学会“如何省 Token”。</p>
<h3 data-id="heading-29">1. 核心前提：Agent Skill 的 Token 消耗逻辑</h3>
<p>首先明确一个核心逻辑：AI 工具的 Token 消耗，本质是“加载的文本内容长度”——文本越长，Token 消耗越多（类比前端的“文件体积越大，加载时间越长”）。</p>
<p>Agent Skill 的按需加载，本质是“只加载当前需要的文本内容”：不触发 Skill 时，仅加载轻量的元数据（Token 消耗极少）；触发 Skill 时，仅加载该 Skill 的核心规则；不使用 Reference/Script 时，不加载对应的文件，从而避免加载无用的文本内容，减少 Token 消耗。实测数据显示，在处理前端长流程任务时，按需加载架构能将上下文 Token 消耗降低 60%-80%，节省效果显著。</p>
<h3 data-id="heading-30">2. 不同加载阶段的 Token 消耗</h3>
<p>结合前面提到的“三个加载阶段”，我们分别解析每个阶段的 Token 消耗，同时给出前端场景下的实测数据（以 Cursor 为例，Token 计算规则与 Claude 一致，1000 字符 ≈ 750 Token），让你有直观认知：</p>
<h4 data-id="heading-31">（1）初始化阶段：元数据加载（Token 消耗极低，可忽略）</h4>
<p>加载内容：每个 Skill 的名称、简短描述（约 50-100 字符/个）；</p>
<p>Token 消耗：单个 Skill 约 30-75 Token，10 个 Skill 仅消耗 300-750 Token；</p>
<p>前端场景类比：相当于加载前端项目的路由表（仅包含路径和组件名称），文件体积极小，加载时的资源消耗可忽略。</p>
<h4 data-id="heading-32">（2）触发阶段：核心规则加载（Token 消耗中等，可控）</h4>
<p>加载内容：当前触发的 Skill 的 SKILL.md 全部内容（前端场景下，SKILL.md 长度约 500-2000 字符，包含规则、场景、示例）；</p>
<p>Token 消耗：单个 Skill 约 375-1500 Token；</p>
<p>关键说明：仅加载“当前触发的 Skill”，其他 Skill 不加载，比如同时封装了 10 个 Skill，调用 1 个时，仅消耗该 Skill 的 Token，其他 9 个仍仅消耗元数据的少量 Token；</p>
<p>前端场景优化：SKILL.md 中仅保留核心规则，删除冗余描述（如无需详细写示例，仅保留关键规则），可进一步降低 Token 消耗。</p>
<h4 data-id="heading-33">（3）执行阶段：Reference/Script 加载（Token 消耗按需，可控制）</h4>
<p>加载内容：仅加载当前需要的 Reference 文件或 Script 脚本（文本长度决定 Token 消耗）；</p>
<p>Token 消耗：</p>
<ul>
<li>Reference：前端常用的接口文档、规范文档（约 1000-5000 字符），Token 消耗约 750-3750 Token；</li>
<li>Script：前端脚本（约 500-2000 字符），Token 消耗约 375-1500 Token；</li>
</ul>
<p>关键说明：</p>
<ul>
<li>不使用 Reference/Script 时，不消耗对应的 Token（按需加载的核心优势）；</li>
<li>Script 脚本仅加载“文本内容”，执行时不额外消耗 Token（类比前端加载 JS 文件，仅加载文件内容，执行时不消耗额外网络资源）；</li>
<li>Reference 文件可拆分（如将庞大的接口文档拆分为“用户接口.md”“商品接口.md”），需要时仅加载对应拆分文件，进一步节省 Token（类比前端拆分组件，按需引入）。实测显示，将庞大知识库拆分为按需加载的 Reference 文件，比全量加载的 Token 成本节省 92% 以上，同时加载速度提升 45%。</li>
</ul>
<h3 data-id="heading-34">3. 前端场景下的 Token 节省技巧（实用可落地）</h3>
<p>结合前端开发的实际使用场景，分享 3 个实用的 Token 节省技巧，直接降低使用成本：</p>
<ol>
<li>精简 SKILL.md 内容：仅保留核心规则，删除冗余的示例、描述（如示例可简化，无需写完整代码，仅写关键片段）；</li>
<li>拆分 Reference 文件：将庞大的参考资料拆分为多个小文件（如接口文档按模块拆分），需要时仅加载对应模块，避免全量加载；</li>
<li>避免同时触发多个 Skill：每次仅调用 1 个需要的 Skill，避免多个 Skill 同时加载，导致 Token 浪费（类比前端避免同时加载多个不必要的组件）。</li>
</ol>
<h2 data-id="heading-35">七、Agent Skill 与 MCP 的核心区别</h2>
<p>很多前端开发者会混淆 Agent Skill 和 MCP，甚至认为“两者是一回事”——其实两者的核心定位、作用、使用场景完全不同，简单来说：Agent Skill 是“给 AI 用的技能模板”，聚焦“AI 操作的标准化、自动化”；MCP 是“前端项目的构建/部署工具”，聚焦“项目的构建、打包、部署流程”，两者无直接关联，但可能在前端开发中配合使用。</p>
<p>下面我们从“ 6 个维度”，详细对比两者的区别，结合前端实际使用场景，让你彻底分清，避免使用时混淆：</p>








































<table><thead><tr><th>对比维度</th><th>Agent Skill</th><th>MCP（前端常用，如 Webpack、Vite、Rollup）</th></tr></thead><tbody><tr><td>核心定位</td><td>AI 智能体的“技能模板”，用于规范、自动化 AI 的操作（生成代码、修复代码、执行脚本），本质是“AI 的操作手册”，核心是“赋能 AI”，让 AI 更适配前端开发场景。</td><td>前端项目的“构建/部署工具”，用于将前端源码（JS/Vue/TS/CSS）打包、压缩、优化，生成可部署的静态文件，本质是“项目的加工工具”，核心是“处理项目文件”。</td></tr><tr><td>核心作用</td><td>1. 省去重复 Prompt，提升 AI 生成代码的效率；2. 关联项目上下文，让 AI 生成的代码适配项目规范；3. 执行自动化操作（如批量重构、代码修复），实现 AI 操作闭环。</td><td>1. 打包：将多个源码文件合并为单个/多个静态文件；2. 优化：压缩代码、图片，提升项目加载速度；3. 构建：处理 ES6+ 语法、CSS 预处理器，让浏览器可识别；4. 部署：部分 MCP 支持自动部署到服务器。</td></tr><tr><td>使用场景</td><td>前端开发的“编码阶段”：生成组件、修复代码、接口请求代码生成、批量重构、规范校验等，与 AI 工具（Cursor、Claude）配合使用，核心是“辅助编码”。</td><td>前端开发的“构建/部署阶段”：编码完成后，打包源码、优化项目、部署上线，核心是“处理项目输出”，与前端框架（Vue、React）配合使用。</td></tr><tr><td>依赖环境</td><td>依赖支持 Agent Skill 的 AI 工具（如 Cursor、Claude），无需额外部署，仅需在项目中创建 Skill 配置文件，AI 工具自动识别。</td><td>依赖 Node.js 环境，需在项目中配置（如 webpack.config.js、vite.config.js），部分 MCP 需额外安装插件（如 CSS 预处理器插件），配置相对复杂。</td></tr><tr><td>操作对象</td><td>操作的是“AI 的指令和行为”，间接作用于前端源码（通过 AI 生成、修改源码），不直接处理项目文件（Script 脚本仅在沙箱执行，需手动应用到本地）。</td><td>直接操作“前端源码文件”，对源码进行打包、压缩、优化，直接输出可部署的静态文件，直接作用于项目文件。</td></tr><tr><td>前端开发者关联度</td><td>可选但推荐使用：不使用也能编码，但使用后能大幅提升编码效率，减少重复工作，尤其适合大型项目（规范多、重复工作多）。</td><td>必用：前端项目（尤其是框架开发）必须使用 MCP，否则源码无法打包、优化，无法部署上线（原生 JS 项目可不用，但实际开发中极少）。</td></tr></tbody></table>
<h3 data-id="heading-36">一句话分清</h3>
<p>Agent Skill：<strong>辅助 AI 帮你写代码、修代码、做批量操作</strong>，聚焦“编码效率”，配合 Cursor 等 AI 工具使用；</p>
<p>MCP：<strong>帮你把写好的代码打包、优化、部署上线</strong>，聚焦“项目输出”，配合 Vue、React 等框架使用；</p>
<p>两者配合场景：用 Agent Skill 辅助编码（生成、修复代码）→ 编码完成后，用 MCP 打包、优化项目 → 部署上线，形成前端开发的完整流程。</p>
<h2 data-id="heading-37">八、总结：前端开发者如何高效用好 Agent Skill</h2>
<p>结合本文的全维度解析，Agent Skill 对于前端开发者而言，核心价值是“解放双手、提升效率”——把重复、机械、规范的编码工作，交给 AI 自动完成，开发者专注于核心业务逻辑（如业务流程设计、交互优化）。</p>
<p>最后，给前端开发者 3 个实用建议，帮助你快速落地 Agent Skill，最大化发挥其价值：</p>
<ol>
<li>从高频场景入手：优先封装前端开发中“重复次数最多”的 Skill（如组件生成、ESLint 修复、接口请求生成），快速看到效率提升，避免一开始就封装复杂 Skill；</li>
<li>贴合项目规范：封装 Skill 时，严格遵循项目的代码规范、接口规范、组件规范，让生成的代码无需手动修改，真正实现“拿来就用”，这也是 Skill 最核心的价值；</li>
<li>合理使用 Reference/Script：简单场景用基础 Skill（仅 SKILL.md），复杂场景（接口联调、批量重构）结合 Reference 和 Script，同时注意控制 Token 消耗，避免浪费。</li>
</ol>
<p>随着 AI 技术在前端开发中的普及，Agent Skill 会逐渐成为前端开发者的“必备工具”——它不是“替代开发者”，而是“成为开发者的专属 AI 助手”，帮你省去重复工作，提升编码效率，让你有更多时间专注于更有价值的开发工作。</p>
<p>后续你可以根据自己的项目场景，不断优化、扩展 Skill 库，让 AI 助手越来越适配你的开发习惯，真正实现“高效编码、轻松开发”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent Skill与Rules的区别——以Cursor为例]]></title>    <link>https://juejin.cn/post/7604012106154819630</link>    <guid>https://juejin.cn/post/7604012106154819630</guid>    <pubDate>2026-02-09T03:25:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604012106154819630" data-draft-id="7604080364354142235" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent Skill与Rules的区别——以Cursor为例"/> <meta itemprop="keywords" content="前端,后端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-09T03:25:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随意_"/> <meta itemprop="url" content="https://juejin.cn/user/4222562141210478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent Skill与Rules的区别——以Cursor为例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4222562141210478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随意_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:25:12.000Z" title="Mon Feb 09 2026 03:25:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>在AI Agent（智能代理）的运行逻辑中，Agent Skill（智能体技能）与Rules（规则）是两个基础且易混淆的核心概念。二者共同支撑AI工具完成指定任务，但在本质、运行逻辑、灵活度及应用场景上存在根本性差异。Cursor作为一款主打代码编写的AI工具，其背后的运行机制恰好清晰地体现了这两者的区别——Rules构建了工具的“底线框架”，而Agent Skill赋予了工具“灵活解题”的能力。本文将以Cursor为具体案例，从多维度详细拆解二者的核心差异，尤其补充“携带方式”的区别，帮助我们更深刻理解AI工具的工作原理。</p>
<h2 data-id="heading-1">一、先明确核心定义：两个概念的本质差异</h2>
<p>要区分Agent Skill与Rules，首先要跳出“都是完成任务的方式”这一表层认知，抓住二者的本质内核。简单来说，<strong>Rules是“预设的固定指令”，是AI必须遵守的“硬约束”；而Agent Skill是“习得的灵活能力”，是AI运用知识解决问题的“软能力”</strong> 。二者的定义差异，直接决定了它们在AI工具中扮演的不同角色，也决定了其携带方式的本质区别——Rules是AI工具始终携带、全程生效的“基础准则”，而Agent Skill是AI工具按需调用、不持续占用资源、未使用时不主动触发的“专项能力”。</p>
<h3 data-id="heading-2">1. Rules（规则）：AI的“行为手册”，固定且不可逾越，全程携带生效</h3>
<p>Rules是由开发者预先定义的、明确的、刚性的指令集合，核心作用是划定AI的行为边界、规范基础操作流程，回答“什么可以做、什么不能做，以及基础操作要遵循什么步骤”。它不具备学习能力和灵活调整性，无论输入场景如何变化，只要触发了规则条件，AI就必须按照预设指令执行，不存在“变通”的可能。</p>
<p>Rules的核心特征是“确定性”——输入与输出之间存在固定对应关系，如同工厂流水线的操作规范，每一个步骤都有明确要求，不允许偏差。更关键的是，Rules是AI工具<strong>全程携带、实时生效</strong>的，无论用户是否触发相关功能，Rules都会持续存在于工具的运行逻辑中，随时准备检测违规行为、规范基础操作。对于Cursor而言，其内置的Rules的核心目的是保障工具运行的稳定性、安全性，以及基础功能的一致性，这种保障需要全程生效，因此Rules必须一直携带。</p>
<h3 data-id="heading-3">2. Agent Skill（智能体技能）：AI的“解题能力”，灵活且可迭代，按需调用、不持续携带</h3>
<p>Agent Skill是AI通过训练（数据训练、强化学习等）习得的、能够灵活应对复杂场景、解决具体问题的能力，核心作用是“高效完成目标任务”，回答“遇到具体问题时，如何最优地解决它”。它具备一定的灵活性和适应性，能够根据输入的差异、场景的变化，调整解决问题的方式，甚至在遇到新场景时，基于已有技能进行合理适配（而非机械遵循固定指令）。</p>
<p>Agent Skill的核心特征是“灵活性”——输入与输出之间没有固定对应关系，AI会根据自身习得的知识和经验，选择最优路径完成任务，如同人类的专业技能（如程序员编写代码、设计师绘制图纸），能够应对不同场景下的复杂需求。与Rules不同，Agent Skill是AI工具<strong>按需调用、不持续携带</strong>的：当用户没有触发相关需求时，Skill不会主动生效，也不会持续占用工具资源；只有当用户提出具体任务需求（如生成代码、修复错误）时，工具才会调用对应的Skill，完成任务后，Skill会回归“休眠”状态，不再主动参与工具运行。</p>
<h2 data-id="heading-4">二、以Cursor为案例：多维度拆解二者的具体区别</h2>
<p>Cursor的核心功能是代码生成、代码优化、错误修复、语法提示等，其背后同时依赖Rules的“刚性约束”和Agent Skill的“灵活解题”。我们从7个核心维度（新增携带方式），结合Cursor的实际功能，拆解二者的具体差异，让抽象概念落地。</p>
<h3 data-id="heading-5">维度1：运行逻辑——“按指令执行”vs“按能力解题”</h3>
<p>Rules的运行逻辑是“条件-触发-执行”，完全依赖预设指令，不涉及任何“判断”和“适配”；而Agent Skill的运行逻辑是“需求-分析-解题”，依赖自身习得的知识，具备主动分析和灵活适配的能力。</p>
<p>以Cursor的“语法规范”相关功能为例：</p>
<ul>
<li>Rules层面：开发者预先为每一种编程语言（Python、JavaScript、Java等）定义了明确的语法规则——比如Python中“缩进必须用4个空格”“语句结尾不能加分号”“关键字不能作为变量名”，这些都是固定的Rules。当用户在Cursor中输入“if a == 1:”后忘记缩进，Cursor会立即报错，原因是触发了“Python条件语句后必须缩进”的Rules，此时Cursor的行为是“检测到违规→执行预设提示（报错）”，没有任何灵活调整，完全遵循固定指令。</li>
<li>Agent Skill层面：当用户输入“用Python写一个读取Excel文件并筛选数据的代码”时，Cursor的核心行为的是“分析需求→调用代码编写技能→生成适配的代码”。此时，Cursor不会机械遵循某一条固定指令，而是会根据用户的具体需求（读取Excel、筛选数据），结合自身习得的Python编程知识，选择合适的库（如pandas）、合适的代码逻辑，生成可直接运行的代码。如果用户后续补充“筛选出大于100的数据并保存为新文件”，Cursor还能灵活调整代码，无需开发者新增额外Rules——这就是Agent Skill的“解题能力”，而非“指令执行”。</li>
</ul>
<h3 data-id="heading-6">维度2：灵活度——“刚性不可变”vs“弹性可适配”</h3>
<p>Rules的最大特点是“刚性”，一旦定义完成，无法根据场景变化灵活调整，除非开发者手动修改Rules；而Agent Skill的最大特点是“弹性”，能够根据输入差异、需求变化，灵活调整解决问题的方式，甚至适配未预设的新场景。</p>
<p>结合Cursor的“代码优化”功能进一步说明：</p>
<p>Cursor的Rules中，有一条固定规则是“不生成恶意代码”——无论用户输入什么需求，只要涉及恶意代码（如窃取数据、攻击系统的代码），Cursor都会直接拒绝生成，这是刚性约束，没有任何变通的可能，哪怕用户伪装需求，只要触发了“恶意代码”的判断规则，就会执行拒绝指令。</p>
<p>而Cursor的“代码优化技能”则具备极强的灵活性：当用户输入一段冗余的Python代码（如重复的循环、不必要的变量定义），Cursor会分析代码的核心功能，结合自身习得的“代码简洁化”技能，对代码进行优化——比如将重复循环替换为列表推导式，删除无用变量。如果用户输入的是一段JavaScript冗余代码，Cursor同样能适配，优化逻辑会根据JavaScript的语法特点和编程习惯调整，而非沿用Python的优化规则。这种“根据语言类型、代码场景灵活调整优化方式”的能力，就是Agent Skill，它不依赖固定指令，而是依赖自身习得的多语言编程技能。</p>
<h3 data-id="heading-7">维度3：学习与迭代——“不可学习”vs“可迭代升级”</h3>
<p>Rules是“静态”的，本身不具备任何学习能力，无法从用户的使用场景、新的需求中积累经验，其迭代只能依赖开发者手动修改、新增或删除规则；而Agent Skill是“动态”的，能够通过持续的训练（如用户反馈、新的训练数据）不断迭代升级，提升解题能力，甚至习得新的技能。</p>
<p>这一点在Cursor的版本更新中体现得尤为明显：</p>
<ul>
<li>Rules的迭代：Cursor早期版本中，对“TypeScript语法规则”的支持并不完整，比如未覆盖某些新增的语法特性（如可选链操作符?.），此时用户输入相关语法会报错——这是因为Rules中未包含该语法的判断规则。要解决这个问题，只能依靠开发者手动更新Rules，添加对该语法的支持，Cursor本身无法通过使用场景“学习”到这条新规则。</li>
<li>Agent Skill的迭代：Cursor的“代码错误修复技能”在早期版本中，只能修复简单的语法错误（如拼写错误、缺少括号），但随着版本更新，通过大量的错误代码案例训练，该技能不断升级，如今能够修复更复杂的逻辑错误（如循环条件错误、变量作用域错误），甚至能够识别代码中的潜在bug（如内存泄漏风险）并给出修复建议。这种升级不需要开发者手动定义“如何修复逻辑错误”的规则，而是Agent Skill通过学习不断积累经验、提升能力的结果。</li>
</ul>
<h3 data-id="heading-8">维度4：应用场景——“保障基础规范”vs“解决复杂需求”</h3>
<p>Rules的应用场景主要是“基础约束”，聚焦于保障AI工具的运行安全、操作规范、输出一致性，解决的是“不出错”的问题；而Agent Skill的应用场景主要是“复杂解题”，聚焦于满足用户的具体需求、提升任务完成效率，解决的是“做得好”的问题。</p>
<p>我们可以将Cursor的功能拆解为“基础规范层”和“复杂需求层”，分别对应Rules和Agent Skill：</p>
<ul>
<li>Rules覆盖的基础规范场景： 这些场景的核心目的是“保障Cursor的基础运行不出错、不违规”，没有这些Rules，Cursor会出现语法混乱、输出不安全代码、功能无序等问题。</li>
<li>编程语言语法校验（如Python缩进、JavaScript分号规范）；</li>
<li>代码安全约束（拒绝生成恶意代码、隐私泄露相关代码）；</li>
<li>基础操作规范（如代码格式化的默认缩进距离、注释规范）；</li>
<li>功能权限约束（如免费版用户无法使用高级代码优化功能）。</li>
<li>Agent Skill覆盖的复杂需求场景： 这些场景的核心目的是“满足用户的具体编程需求”，没有这些Agent Skill，Cursor只是一个普通的代码编辑器，无法实现“AI辅助编程”的核心价值。</li>
<li>根据自然语言需求生成代码（如“写一个二分查找算法”“用React写一个登录页面组件”）；</li>
<li>代码优化（如简化冗余代码、提升代码运行效率、优化代码可读性）；</li>
<li>复杂错误修复（如逻辑错误、依赖冲突、兼容性问题）；</li>
<li>代码解释与调试（如解释一段陌生代码的功能、指导用户调试报错代码）。</li>
</ul>
<h3 data-id="heading-9">维度5：输入与输出的关系——“一一对应”vs“多对多对应”</h3>
<p>Rules的输入与输出是“一一对应”的，即一个触发条件对应一个固定的输出结果，不存在“一个输入对应多个输出”的情况；而Agent Skill的输入与输出是“多对多对应”的，即同一个需求可以有多种解题方式，同一个输入可以对应多个不同的输出（均满足需求），AI会选择最优解。</p>
<p>以Cursor的“代码格式化”功能为例：</p>
<p>Rules层面：Cursor预设了“Python代码格式化规则”——缩进4个空格、函数之间空两行、注释独占一行，这些规则是固定的。当用户触发“格式化代码”指令时，无论这段Python代码的原始格式如何（如缩进2个空格、函数之间空一行），Cursor都会按照预设规则进行格式化，输出格式是固定的——这就是“输入（任意Python代码+格式化指令）→固定输出（符合预设规则的代码）”的一一对应关系。</p>
<p>Agent Skill层面：当用户输入“用Python写一个计算斐波那契数列的代码”时，Cursor的输出并不是固定的。它可以生成递归版本的代码，也可以生成循环版本的代码，还可以生成优化后的动态规划版本的代码——这三种输出都满足用户的需求，只是效率和可读性不同。Cursor会根据自身习得的技能，选择最优的方式（通常是效率更高的循环或动态规划版本）生成代码，这就是“输入（斐波那契数列需求）→多输出（多种代码实现）”的多对多对应关系，体现了Agent Skill的灵活性。</p>
<h3 data-id="heading-10">维度6：依赖主体——“依赖开发者预设”vs“依赖训练数据与模型”</h3>
<p>Rules的存在完全依赖开发者的预设，开发者定义什么规则，AI就遵守什么规则，规则的完整性、合理性完全由开发者决定；而Agent Skill的存在完全依赖训练数据与AI模型，训练数据的质量、数量，模型的训练方式，直接决定了Agent Skill的能力强弱。</p>
<p>回到Cursor的案例：</p>
<p>Cursor的Rules（如语法规则、安全规则），都是由Cursor的开发团队手动定义、梳理的——开发团队需要梳理每一种编程语言的语法细节，定义恶意代码的判断标准，预设操作规范，这些规则的好坏，完全取决于开发团队的专业能力。如果开发团队遗漏了某一种Python语法规则，Cursor就无法识别该语法错误。</p>
<p>而Cursor的Agent Skill（如代码生成、错误修复），则依赖于大量的编程数据训练——开发团队会收集海量的代码案例、编程问题及解决方案，输入到AI模型中进行训练，让模型习得“如何根据需求生成代码”“如何修复错误”。如果训练数据中包含大量高质量的Python代码案例，Cursor的Python代码生成技能就会更强；如果训练数据中缺少某类场景（如区块链相关代码），Cursor在应对这类需求时，技能表现就会较弱。</p>
<h3 data-id="heading-11">维度7：携带方式——“全程携带、实时生效”vs“按需调用、不持续携带”</h3>
<p>这是二者易被忽略但关键的区别：Rules是AI工具从启动到关闭，全程携带、实时生效的“基础准则”，无需用户触发，始终存在于工具运行逻辑中；Agent Skill是AI工具根据用户需求，按需调用、用完即“休眠”的“专项能力”，未使用时不主动生效、不持续占用资源，仅在触发特定任务时被调用。</p>
<p>结合Cursor的实际使用场景，这种区别十分直观，我们从“工具运行全流程”拆解：</p>
<ul>
<li>Rules：全程携带、实时生效。从你打开Cursor的那一刻起，其内置的所有Rules就已经启动并持续生效——无论你是否开始编写代码、是否触发某一功能，Rules都会实时检测你的操作。比如，你打开Cursor后，只是新建文件、未输入任何内容，Rules仍在后台运行（如检测文件格式规范）；当你输入第一个字符，若违反语法规则（如Python中输入“if a == 1”后未加冒号），Rules会立即触发报错，无需你手动调用“语法检测”功能。哪怕你关闭代码编写窗口、仅保留Cursor主界面，Rules依然携带生效，确保你后续任何操作都不违反预设规范。这种“全程携带”是为了保障工具运行的安全性和规范性，避免因Rules未生效导致违规操作（如生成恶意代码、语法混乱）。</li>
<li>Agent Skill：按需调用、不持续携带。当你打开Cursor后，若仅新建文件、未输入任何需求（如未要求生成代码、优化代码），则Cursor的所有Agent Skill（代码生成、错误修复、代码优化等）都处于“休眠”状态，未被调用、也不占用额外资源；只有当你触发特定需求时，对应的Skill才会被调用。比如，你输入“用Python写一个冒泡排序代码”，Cursor会立即调用“代码生成Skill”，完成代码生成后，该Skill就回归“休眠”状态；若你后续不再提出新需求，该Skill不会持续生效、也不会主动参与工具运行。再比如，你输入一段有逻辑错误的代码，只有当你点击“修复错误”按钮，或输入“修复这段代码”的需求时，“错误修复Skill”才会被调用，未触发时，该Skill不会主动检测代码错误（检测语法错误是Rules的功能，而非Skill）。</li>
</ul>
<p>补充一点：Rules的“全程携带”是被动的、强制的，由工具自身启动并维持；Agent Skill的“按需调用”是主动的、灵活的，由用户需求触发，调用何种Skill、何时调用，完全取决于用户的具体任务，工具不会主动调用Skill。</p>
<h2 data-id="heading-12">三、总结：二者相辅相成，缺一不可</h2>
<p>通过以上7个维度的拆解，我们可以清晰地看出Agent Skill与Rules的核心区别：Rules是AI工具的“骨架”，构建了工具的基础边界和规范，以“全程携带、实时生效”的方式，保障工具“不越界、不出错”；Agent Skill是AI工具的“血肉”，赋予了工具解决复杂问题的能力，以“按需调用、不持续携带”的方式，实现工具的核心价值，提升任务完成效率。二者并非对立关系，而是相辅相成、缺一不可。</p>






























<table><thead><tr><th>对比维度</th><th>Rules（规则）</th><th>Agent Skill（智能体技能）</th></tr></thead><tbody><tr><td>核心作用</td><td>构建基础边界和规范，保障工具“不越界、不出错”</td><td>赋予解题能力，实现工具核心价值，提升任务效率</td></tr><tr><td>携带方式</td><td>全程携带、实时生效，被动强制启动</td><td>按需调用、不持续携带，用户需求触发后“休眠”</td></tr><tr><td>Cursor中的作用</td><td>保障代码语法规范、运行安全，维持工具正常运行</td><td>实现代码生成、优化、错误修复等AI辅助编程核心功能</td></tr><tr><td>缺失影响</td><td>代码语法混乱、存在安全风险，工具无法正常运行</td><td>沦为普通代码编辑器，无法满足复杂编程需求</td></tr></tbody></table>
<p>延伸到整个AI Agent领域，无论是ChatGPT、MidJourney，还是各类行业AI工具，其运行逻辑都离不开这两者的配合：Rules划定边界（全程携带），Agent Skill实现价值（按需调用）。理解二者的区别，尤其是携带方式的差异，不仅能帮助我们更清晰地认识AI工具的工作原理，也能让我们在使用AI工具（如Cursor）时，更清楚地知道“工具能做什么、不能做什么”，更高效地利用工具解决自身需求。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[不要在简历上写精通 Vue3？来自面试官的真实劝退]]></title>    <link>https://juejin.cn/post/7603958579180355584</link>    <guid>https://juejin.cn/post/7603958579180355584</guid>    <pubDate>2026-02-09T03:27:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603958579180355584" data-draft-id="7604036853129723919" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="不要在简历上写精通 Vue3？来自面试官的真实劝退"/> <meta itemprop="keywords" content="前端,Vue.js,JavaScript"/> <meta itemprop="datePublished" content="2026-02-09T03:27:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            不要在简历上写精通 Vue3？来自面试官的真实劝退
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:27:58.000Z" title="Mon Feb 09 2026 03:27:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a0066014f0d4804a728e9603d8c187d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212478&amp;x-signature=QDQ5PcudN83PggT1ZI7Yxca2zi0%3D" alt="image.png" loading="lazy"/></p>
<p>最近在面试，说实话，每次看到 <strong>精通</strong> 这俩字，我这心里就咯噔一下。不是我不信你，是这俩字太重了。这不仅仅是自信，这简直就是给面试官下战书😥。</p>
<p>你写 <strong>熟悉</strong>，我问你 API 怎么用，能干活就行。</p>
<p>你写 <strong>精通</strong>，那我身体里的胜负欲瞬间就被你点燃了：既然你都精通了，那咱们就别聊怎么写代码了，咱们聊聊尤雨溪写这行代码时在想啥吧😒。</p>
<p>结果呢？三个问题下去，我看对面兄弟的汗都下来了，我都不好意思再问。</p>
<p>今天真心给大伙提个醒，简历上这 <strong>精通</strong> 二字，就是个巨大的坑，谁踩谁知道。</p>
<p>来，我给你们复盘一下，什么叫面试官眼里的精通。</p>
<h3 data-id="heading-0">你别只背八股文</h3>
<p>我上来通常先问个简单的热身：</p>
<p><strong>Vue3 到底为啥要用 Proxy 换掉 Object.defineProperty？</strong></p>
<p>大部分人张口就来：因为 defineProperty 监听不到数组下标，还监听不到对象新增属性。Proxy 啥都能拦，所以牛逼。</p>
<p>这话错没错？没错。</p>
<p>但这只是 60 分的回答，属于背诵全文🤔。</p>
<p><strong>敢写精通的，你得这么跟我聊：</strong></p>
<p>老哥，其实数组和新增属性那都是次要的。最核心的痛点是 <strong>性能</strong>，特别是初始化时候的性能。</p>
<p>Vue2 那个 defineProperty 是上来就得递归，把你对象里里外外每一层都给劫持了。对象一深，初始化直接卡顿。</p>
<p>Vue3 的 Proxy 是 <strong>惰性的</strong>。你访问第一层，我劫持第一层；你访问深层，我再临时去劫持深层。我不访问，我就不干活。</p>
<p>而且，这里面还有个 <strong>this 指向</strong> 的坑。Vue3 源码里用 Reflect.get 传了个 receiver 参数进去，就是为了保证有继承关系时，this 能指对地方，不然依赖收集就乱套了。</p>








































<table><thead><tr><th>能力</th><th>Vue2（defineProperty）</th><th>Vue3（Proxy）</th></tr></thead><tbody><tr><td>监听对象新增/删除</td><td>❌</td><td>✅</td></tr><tr><td>监听数组索引/length</td><td>❌</td><td>✅</td></tr><tr><td>一次性代理整个对象</td><td>❌</td><td>✅</td></tr><tr><td>性能上限</td><td>❌ 越大越慢</td><td>✅ 更平滑</td></tr><tr><td>Map / Set</td><td>❌</td><td>⚠️ 部分支持</td></tr><tr><td>实现复杂度</td><td>高</td><td>低</td></tr></tbody></table>
<p>你要能说到 <strong>懒劫持</strong> 和 <strong>Reflect 的 receiver</strong> 这一层，我才觉得你可能看过源码🙂‍↔️。</p>
<h3 data-id="heading-1">Diff 算法别光扯最长递增子序列</h3>
<p>第二个问题，稍微上点强度：</p>
<p><strong>Vue3 的 diff 算法快在哪？</strong></p>
<p>别一上来就跟我背什么最长递增子序列，那只是最后一步。</p>
<p>你得从 <strong>编译阶段</strong> 开始聊。</p>
<p>Vue2 是个老实人，数据变了，它就把整棵树拿来从头比到尾，哪怕你那是个静态的写死的 div，它也要比一下。</p>
<p>Vue3 变聪明了，它搞了个 <strong>动静分离</strong>。</p>
<p>在编译的时候，它就给那些会变的节点打上了标记，叫 <strong>PatchFlag</strong>。这个是文本变，那个是 class 变，都记好了。</p>
<p>等到真要 diff 的时候，Vue3 直接无视那些静态节点，只盯着带标记的节点看。</p>
<p>这就好比老师改卷子，以前是从头读到尾，现在是只看你改过的错题。这效率能一样吗？</p>
<p>这叫 <strong>靶向更新</strong>。能扯出这个词，才算摸到了 Vue3 的门道。</p>
<h3 data-id="heading-2">Ref 的那些坑说一说？</h3>
<p>最后问个细节，看你平时踩没踩过坑：</p>
<p><strong>Ref 在模板里不用写 .value，在 reactive 里也不用写。那为啥有时候在 Map 里又要写了呢？</strong></p>
<p>很多人这就懵了：啊？不都是自动解包吗？</p>
<p><strong>精通</strong> 的人会告诉我：</p>
<p>Vue 的自动解包是有底线的。</p>
<p>模板里那是亲儿子待遇，帮你解了。</p>
<p>reactive 对象里那是干儿子待遇，get 拦截器里帮你解了。</p>
<p>但是 <strong>Map</strong> 和 <strong>Set</strong> 这种数据结构，Vue 为了保证语义不乱，是不敢乱动的。你在 Map 里存个 ref，取出来它还是个 ref，必须得手写 .value。👇</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)

<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'count'</span>, count)

map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'count'</span>)        <span class="hljs-comment">// 拿到的是 ref 对象</span>
map.<span class="hljs-title function_">get</span>(<span class="hljs-string">'count'</span>).<span class="hljs-property">value</span> <span class="hljs-comment">// 这是正确取值</span>

</code></pre>
<blockquote>
<p>Map / Set / WeakMap 不是 Vue 的响应式代理对象</p>
</blockquote>
<p>这种细枝末节，没在真实项目里被毒打过，是很难注意到的。</p>
<hr/>
<p>面试其实就是一场 <strong>心理博弈</strong>。</p>
<p>你写 <strong>精通</strong>，我对你的预期就是 <strong>行业顶尖</strong>。你答不上来，落差感太强，直接挂。</p>
<p>你写 <strong>熟练掌握</strong> 或者 <strong>有丰富实战经验</strong>，哪怕你答出上面这些深度的 50%，我都觉得这小伙子爱钻研，是个惊喜🥱。</p>
<p>在这个行业里，<strong>精通</strong> 真的不是终点，而是一个无限逼近的过程。</p>
<p>我自己写了这么多年代码，现在简历上也只敢写 <strong>熟练</strong>🤷‍♂️。</p>
<p>把 <strong>精通</strong> 换成 <strong>实战案例</strong> 吧，比如 <strong>我在项目中重写了虚拟列表</strong>，或者 <strong>我给 Vue 生态贡献过 PR</strong>。</p>
<p>这比那两个干巴巴的汉字，有力一万倍。</p>
<p>听哥一句劝，Flag 别乱搞，Offer 自然就会来😒。</p>
<p>你们说呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffdaf315a33141f6bc3929a5d259f726~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212478&amp;x-signature=VLZPpX6fhiD%2Bbbk5av2aBOh7Rg0%3D" alt="Suggestion.gif" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[xxl-job 和 elastic-job，哪个更好？]]></title>    <link>https://juejin.cn/post/7604155045235818531</link>    <guid>https://juejin.cn/post/7604155045235818531</guid>    <pubDate>2026-02-09T03:35:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604155045235818531" data-draft-id="7604045354070409250" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="xxl-job 和 elastic-job，哪个更好？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-09T03:35:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苏三说技术"/> <meta itemprop="url" content="https://juejin.cn/user/465848661970824"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            xxl-job 和 elastic-job，哪个更好？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/465848661970824/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苏三说技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T03:35:17.000Z" title="Mon Feb 09 2026 03:35:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是苏三，又跟大家见面了。</p>
<p> </p>
<h2 data-id="heading-0">前言</h2>
<p>今天我们来探讨一个让许多技术团队纠结的问题：在分布式任务调度领域，<code>XXL-JOB</code>和<code>Elastic-Job</code>，到底哪个更好？</p>
<p>有些小伙伴在工作中第一次接触分布式任务调度时，可能会有这样的困惑：我们的定时任务在单机跑得好好的，为什么需要引入分布式调度框架？</p>
<p>当系统从单体架构演进到微服务架构，当数据量从几千条暴涨到几百万条，当业务要求从“按时执行”升级到“高效稳定”，单机任务调度就显得力不从心了。</p>
<p>我曾经经历过这样的架构演进：早期使用<code>Quartz</code>配合数据库锁，后来在千万级用户量的电商平台深度使用<code>XXL-JOB</code>，接着在数据处理量极大的金融项目中采用了<code>Elastic-Job</code>。</p>
<p>今天这篇文章就专门跟大家一起聊聊这个话题，希望对你会有所帮助。</p>
<h2 data-id="heading-1">01 设计哲学</h2>
<p>要理解这两个框架的差异，首先要从它们的设计哲学说起。</p>
<p><strong>XXL-JOB采用中心化架构</strong>，它的核心理念是“简单清晰、开箱即用”。</p>
<p>设计者许雪里在框架诞生之初就明确提出：“调度中心和执行器分离，调度中心负责统一调度，执行器负责接收调度请求并执行任务”。</p>
<p>这种设计让<code>XXL-JOB</code>像一个<strong>集中指挥中心</strong>，所有调度决策都由调度中心统一做出。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f39d5c121d84481b7c68799011c0045~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=LgFmoRTaD6iz%2B7krHVowY%2BzYU7M%3D" alt="图片" loading="lazy"/></p>
<p><strong>Elastic-Job则采用去中心化架构</strong>，它的设计理念是“弹性调度、分布式协调”。</p>
<p>框架基于<code>ZooKeeper</code>实现分布式协调，各个节点通过<code>ZooKeeper</code>选举和监听机制协同工作，没有单点中心调度器。</p>
<p>这就像一个<strong>自治的分布式系统</strong>，每个节点都知道自己该做什么。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de567abf258b45aebf37a7849534f2b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=8eS5WzCTTg0qwVfXWSMK4Yh3DO0%3D" alt="图片" loading="lazy"/></p>
<p>这两种设计哲学的选择，直接影响了两者在不同场景下的表现。中心化架构简化了系统的复杂度，而去中心化架构则提供了更好的弹性。</p>
<h2 data-id="heading-2">02 核心架构深度剖析</h2>
<h3 data-id="heading-3">XXL-JOB：简洁优雅的中心化设计</h3>
<p><code>XXL-JOB</code>的架构非常清晰，主要由三部分组成：</p>
<ol>
<li>1. <strong>调度中心（Scheduler Center）</strong> ：负责管理调度信息、发出调度请求</li>
<li>2. <strong>执行器（Executor）</strong> ：负责接收调度请求、执行任务</li>
<li>3. <strong>管理控制台（Admin Console）</strong> ：提供可视化界面进行任务管理</li>
</ol>
<p>让我们通过一个实际的例子来看看如何在Spring Boot项目中集成<code>XXL-JOB</code>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. 执行器配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfig</span> {
    
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${xxl.job.admin.addresses}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> adminAddresses;
    
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${xxl.job.executor.appname}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appName;
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">XxlJobSpringExecutor</span> <span class="hljs-title function_">xxlJobExecutor</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">XxlJobSpringExecutor</span> xxlJobSpringExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();
        xxlJobSpringExecutor.<span class="hljs-title function_">setAdminAddresses</span>(adminAddresses);
        xxlJobSpringExecutor.<span class="hljs-title function_">setAppname</span>(appName);
        xxlJobSpringExecutor.<span class="hljs-title function_">setPort</span>(<span class="hljs-number">9999</span>);
        xxlJobSpringExecutor.<span class="hljs-title function_">setLogPath</span>(<span class="hljs-string">"/data/applogs/xxl-job/jobhandler/"</span>);
        xxlJobSpringExecutor.<span class="hljs-title function_">setLogRetentionDays</span>(<span class="hljs-number">30</span>);
        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;
    }
}

<span class="hljs-comment">// 2. 任务处理器示例</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleXxlJobHandler</span> {
    
    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">"demoJobHandler"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">demoJobHandler</span>(<span class="hljs-title class_">String</span> param) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"XXL-JOB, 开始执行任务"</span>);
        
        <span class="hljs-comment">// 模拟业务处理</span>
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"执行进度: {}"</span>, i);
            <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">2</span>);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS</span>;
    }
    
    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">"shardingJobHandler"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">shardingJobHandler</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> param</span>) {
        <span class="hljs-comment">// 分片参数</span>
        <span class="hljs-title class_">ShardingUtil</span>.<span class="hljs-property">ShardingVO</span> shardingVO = <span class="hljs-title class_">ShardingUtil</span>.<span class="hljs-title function_">getShardingVo</span>();
        int shardIndex = shardingVO.<span class="hljs-title function_">getIndex</span>();  <span class="hljs-comment">// 当前分片序号</span>
        int shardTotal = shardingVO.<span class="hljs-title function_">getTotal</span>();  <span class="hljs-comment">// 总分片数</span>
        
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span>, shardIndex, shardTotal);
        
        <span class="hljs-comment">// 根据分片参数处理数据</span>
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; dataList = <span class="hljs-title function_">queryDataByShard</span>(shardIndex, shardTotal);
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> data : dataList) {
            <span class="hljs-title function_">processData</span>(data);
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">queryDataByShard</span>(<span class="hljs-params">int shardIndex, int shardTotal</span>) {
        <span class="hljs-comment">// 根据分片参数查询需要处理的数据</span>
        <span class="hljs-comment">// 例如：SELECT * FROM order_table WHERE MOD(id, #{shardTotal}) = #{shardIndex}</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">"data1"</span>, <span class="hljs-string">"data2"</span>, <span class="hljs-string">"data3"</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> data</span>) {
        <span class="hljs-comment">// 处理数据逻辑</span>
        <span class="hljs-title class_">XxlJobLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"处理数据: {}"</span>, data);
    }
}
</code></pre>
<h3 data-id="heading-4">Elastic-Job：基于分布式协调的弹性设计</h3>
<p><code>Elastic-Job</code>的架构更加分布式，它没有中心调度节点，而是通过<code>ZooKeeper</code>实现节点间的协调：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 1. Elastic-Job配置类</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElasticJobConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CoordinatorRegistryCenter</span> <span class="hljs-title function_">registryCenter</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">CoordinatorRegistryCenter</span> regCenter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperRegistryCenter</span>(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperConfiguration</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-string">"elastic-job-demo"</span>));
        regCenter.<span class="hljs-title function_">init</span>();
        <span class="hljs-keyword">return</span> regCenter;
    }
    
    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">"init"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">SpringJobScheduler</span> <span class="hljs-title function_">simpleJobScheduler</span>(<span class="hljs-params">
            final SimpleJob simpleJob,
            final CoordinatorRegistryCenter regCenter</span>) {
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringJobScheduler</span>(
            simpleJob,
            regCenter,
            <span class="hljs-title function_">getLiteJobConfiguration</span>(
                simpleJob.<span class="hljs-title function_">getClass</span>(),
                <span class="hljs-string">"0/5 * * * * ?"</span>,  <span class="hljs-comment">// 每5秒执行一次</span>
                <span class="hljs-number">3</span>,                 <span class="hljs-comment">// 分片总数</span>
                <span class="hljs-string">"0=北京,1=上海,2=广州"</span>  <span class="hljs-comment">// 分片参数</span>
            )
        );
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">LiteJobConfiguration</span> <span class="hljs-title function_">getLiteJobConfiguration</span>(<span class="hljs-params">
            Class&lt;? <span class="hljs-keyword">extends</span> SimpleJob&gt; jobClass,
            <span class="hljs-built_in">String</span> cron,
            int shardingTotalCount,
            <span class="hljs-built_in">String</span> shardingItemParameters</span>) {
        
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">LiteJobConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleJobConfiguration</span>(
                <span class="hljs-title class_">JobCoreConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
                    jobClass.<span class="hljs-title function_">getName</span>(),
                    cron,
                    shardingTotalCount
                ).<span class="hljs-title function_">shardingItemParameters</span>(shardingItemParameters).<span class="hljs-title function_">build</span>(),
                jobClass.<span class="hljs-title function_">getCanonicalName</span>()
            )
        ).<span class="hljs-title function_">overwrite</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">build</span>();
    }
}

<span class="hljs-comment">// 2. 简单的作业实现</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimpleJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SimpleJob</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">ShardingContext context</span>) {
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业执行，分片项: {}, 总分片数: {}"</span>, 
                 context.<span class="hljs-title function_">getShardingItem</span>(), 
                 context.<span class="hljs-title function_">getShardingTotalCount</span>());
        
        <span class="hljs-keyword">switch</span> (context.<span class="hljs-title function_">getShardingItem</span>()) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                <span class="hljs-comment">// 处理北京的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"北京"</span>, <span class="hljs-title function_">getBeijingData</span>());
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-comment">// 处理上海的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"上海"</span>, <span class="hljs-title function_">getShanghaiData</span>());
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-comment">// 处理广州的数据</span>
                <span class="hljs-title function_">processData</span>(<span class="hljs-string">"广州"</span>, <span class="hljs-title function_">getGuangzhouData</span>());
                <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">getBeijingData</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 查询北京相关的数据</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">"北京数据1"</span>, <span class="hljs-string">"北京数据2"</span>);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> region, List&lt;<span class="hljs-built_in">String</span>&gt; dataList</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> data : dataList) {
            log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"处理{}的数据: {}"</span>, region, data);
            <span class="hljs-comment">// 实际的数据处理逻辑</span>
        }
    }
}
</code></pre>
<p>从架构对比可以看出，<code>XXL-JOB</code>更像是传统的C/S架构，而<code>Elastic-Job</code>则是真正的分布式架构。</p>
<p>这种差异带来了不同的特性和适用场景。</p>
<h2 data-id="heading-5">03 分片机制：手动分片 vs 智能分片</h2>
<p>分片处理是大数据量任务调度的核心需求。两个框架在分片机制上采取了完全不同的策略。</p>
<h3 data-id="heading-6">XXL-JOB：灵活的手动分片</h3>
<p><code>XXL-JOB</code>采用<strong>手动分片</strong>策略，调度中心将分片参数传递给执行器，执行器根据这些参数处理对应的数据。</p>
<pre><code class="hljs language-vbnet" lang="vbnet">@XxlJob(<span class="hljs-string">"orderProcessJob"</span>)
<span class="hljs-keyword">public</span> ReturnT&lt;<span class="hljs-type">String</span>&gt; orderProcessJob(<span class="hljs-type">String</span> param) {
    
    // 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    int shardTotal = XxlJobHelper.getShardTotal();
    
    log.info(<span class="hljs-string">"开始处理订单数据，分片参数: index={}, total={}"</span>, shardIndex, shardTotal);
    
    // <span class="hljs-number">1</span>. 根据分片参数查询需要处理的订单
    List&lt;<span class="hljs-keyword">Order</span>&gt; orders = orderService.findOrdersByShard(shardIndex, shardTotal);
    
    // <span class="hljs-number">2</span>. 处理订单
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">Order</span> <span class="hljs-keyword">order</span> : orders) {
        <span class="hljs-keyword">try</span> {
            processOrder(<span class="hljs-keyword">order</span>);
            log.info(<span class="hljs-string">"订单处理成功: {}"</span>, <span class="hljs-keyword">order</span>.getOrderNo());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">"订单处理失败: {}"</span>, <span class="hljs-keyword">order</span>.getOrderNo(), e);
            XxlJobHelper.handleFail(<span class="hljs-string">"订单处理失败: "</span> + <span class="hljs-keyword">order</span>.getOrderNo());
        }
    }
    
    <span class="hljs-keyword">return</span> ReturnT.SUCCESS;
}

// 在数据库中按分片查询的示例SQL
// <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_table 
// <span class="hljs-keyword">WHERE</span> status = <span class="hljs-comment">'待处理' </span>
//   <span class="hljs-built_in">AND</span> <span class="hljs-built_in">MOD</span>(order_id % #{shardTotal}) = #{shardIndex}
// <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time 
// LIMIT <span class="hljs-number">1000</span>
</code></pre>
<p><strong>手动分片的优势</strong>：</p>
<ol>
<li>1. <strong>灵活性高</strong>：开发者可以完全控制分片逻辑</li>
<li>2. <strong>数据划分灵活</strong>：可以根据业务特点自定义分片策略</li>
<li>3. <strong>容错性强</strong>：单个分片失败不影响其他分片</li>
</ol>
<p><strong>手动分片的不足</strong>：</p>
<ol>
<li>1. <strong>实现复杂</strong>：需要开发者自己实现分片逻辑</li>
<li>2. <strong>弹性不足</strong>：增加或减少节点时，需要手动调整分片策略</li>
</ol>
<h3 data-id="heading-7">Elastic-Job：智能的自动分片</h3>
<p><code>Elastic-Job</code>采用<strong>智能分片</strong>策略，框架自动根据当前在线节点数进行分片分配。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 数据流作业示例 - 更适合大数据处理场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataflowJobExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataflowJob</span>&lt;<span class="hljs-title class_">String</span>&gt; {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">ShardingContext context</span>) {
        <span class="hljs-comment">// 根据分片参数获取数据</span>
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data = <span class="hljs-title function_">fetchDataByShard</span>(
            context.<span class="hljs-title function_">getShardingItem</span>(),
            context.<span class="hljs-title function_">getShardingTotalCount</span>()
        );
        
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"获取到{}条数据待处理"</span>, data.<span class="hljs-title function_">size</span>());
        <span class="hljs-keyword">return</span> data;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">ShardingContext context, List&lt;<span class="hljs-built_in">String</span>&gt; data</span>) {
        <span class="hljs-comment">// 处理数据</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> item : data) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-title function_">processItem</span>(item);
                log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"数据处理成功: {}"</span>, item);
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"数据处理失败: {}"</span>, item, e);
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">fetchDataByShard</span>(<span class="hljs-params">int shardIndex, int shardTotal</span>) {
        <span class="hljs-comment">// 模拟从数据库或消息队列获取数据</span>
        <span class="hljs-comment">// 实际项目中这里可能是：</span>
        <span class="hljs-comment">// 1. 从数据库查询：WHERE MOD(id, #{shardTotal}) = #{shardIndex}</span>
        <span class="hljs-comment">// 2. 从消息队列消费特定分区的数据</span>
        <span class="hljs-comment">// 3. 从文件中读取特定部分的数据</span>
        
        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % shardTotal == shardIndex) {
                data.<span class="hljs-title function_">add</span>(<span class="hljs-string">"data-"</span> + i);
            }
        }
        <span class="hljs-keyword">return</span> data;
    }
}
</code></pre>
<p><strong>智能分片的优势</strong>：</p>
<ol>
<li>1. <strong>自动化程度高</strong>：框架自动处理分片分配</li>
<li>2. <strong>弹性扩展</strong>：节点增减时，分片自动重新分配</li>
<li>3. <strong>负载均衡</strong>：自动确保各节点负载相对均衡</li>
</ol>
<p><strong>智能分片的不足</strong>：</p>
<ol>
<li>1. <strong>灵活性受限</strong>：分片策略由框架控制，自定义空间较小</li>
<li>2. <strong>学习成本高</strong>：需要理解框架的分片分配机制</li>
</ol>
<h2 data-id="heading-8">04 高可用性设计对比</h2>
<p>分布式系统的核心要求之一就是高可用性。两个框架在高可用设计上采用了不同的策略。</p>
<h3 data-id="heading-9">XXL-JOB的高可用设计</h3>
<p><code>XXL-JOB</code>通过数据库锁和心跳检测实现高可用：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 调度中心集群部署时，通过数据库锁保证只有一个调度中心工作</span>
<span class="hljs-comment">// 核心伪代码逻辑：</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Thread</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">while</span> (!stopped) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 1. 尝试获取数据库锁</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">tryLock</span>()) {
                    <span class="hljs-comment">// 2. 获取锁成功，执行调度</span>
                    <span class="hljs-title function_">scheduleJobs</span>();
                    
                    <span class="hljs-comment">// 3. 保持锁，直到调度完成</span>
                    <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">5</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 4. 获取锁失败，等待重试</span>
                    <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">10</span>);
                }
            } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"调度线程异常"</span>, e);
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryLock</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 通过数据库行锁实现分布式锁</span>
        <span class="hljs-comment">// INSERT INTO xxl_job_lock (lock_name) VALUES ('schedule_lock')</span>
        <span class="hljs-comment">// 或者使用SELECT ... FOR UPDATE</span>
        <span class="hljs-keyword">return</span> dbLockService.<span class="hljs-title function_">acquireLock</span>(<span class="hljs-string">"schedule_lock"</span>);
    }
}

<span class="hljs-comment">// 执行器心跳检测</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorHeartbeat</span> {
    
    <span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">30000</span>) <span class="hljs-comment">// 每30秒发送一次心跳</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendHeartbeat</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 向调度中心注册或更新心跳</span>
            registryService.<span class="hljs-title function_">registry</span>(
                executorConfig.<span class="hljs-title function_">getAppName</span>(),
                executorConfig.<span class="hljs-title function_">getAddress</span>()
            );
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
            log.<span class="hljs-title function_">error</span>(<span class="hljs-string">"心跳发送失败"</span>, e);
        }
    }
}
</code></pre>
<h3 data-id="heading-10">Elastic-Job的高可用设计</h3>
<p><code>Elastic-Job</code>通过<code>ZooKeeper</code>的临时节点和监听机制实现高可用：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 基于ZooKeeper的分布式协调实现高可用</span>
public class ElectionListenerManager {
    
    public void <span class="hljs-built_in">start</span>() {
        <span class="hljs-comment">// 1. 创建Leader节点选举</span>
        leaderService<span class="hljs-selector-class">.electLeader</span>();
        
        <span class="hljs-comment">// 2. 监听分片节点变化</span>
        <span class="hljs-built_in">addShardingListener</span>();
        
        <span class="hljs-comment">// 3. 监听作业服务器变化</span>
        <span class="hljs-built_in">addJobServerListener</span>();
    }
    
    private void <span class="hljs-built_in">addShardingListener</span>() {
        <span class="hljs-comment">// 监听分片节点的变化</span>
        zookeeperRegistryCenter<span class="hljs-selector-class">.addCacheData</span>("/${jobName}/sharding");
        
        zookeeperRegistryCenter<span class="hljs-selector-class">.getClient</span>()
            <span class="hljs-selector-class">.getCuratorFramework</span>()
            <span class="hljs-selector-class">.getChildren</span>()
            <span class="hljs-selector-class">.usingWatcher</span>((CuratorWatcher) event -&gt; {
                <span class="hljs-comment">// 分片节点变化，重新分片</span>
                if (event.getType() == Watcher<span class="hljs-selector-class">.Event</span><span class="hljs-selector-class">.EventType</span><span class="hljs-selector-class">.NodeChildrenChanged</span>) {
                    reshardingService<span class="hljs-selector-class">.resharding</span>();
                }
            })
            <span class="hljs-selector-class">.forPath</span>("/${jobName}/sharding");
    }
    
    private void <span class="hljs-built_in">addJobServerListener</span>() {
        <span class="hljs-comment">// 监听作业服务器的上下线</span>
        zookeeperRegistryCenter<span class="hljs-selector-class">.addCacheData</span>("/${jobName}/servers");
        
        zookeeperRegistryCenter<span class="hljs-selector-class">.getClient</span>()
            <span class="hljs-selector-class">.getCuratorFramework</span>()
            <span class="hljs-selector-class">.getChildren</span>()
            <span class="hljs-selector-class">.usingWatcher</span>((CuratorWatcher) event -&gt; {
                <span class="hljs-comment">// 服务器节点变化，重新分配任务</span>
                if (event.getType() == Watcher<span class="hljs-selector-class">.Event</span><span class="hljs-selector-class">.EventType</span><span class="hljs-selector-class">.NodeChildrenChanged</span>) {
                    serverService<span class="hljs-selector-class">.syncServers</span>();
                }
            })
            <span class="hljs-selector-class">.forPath</span>("/${jobName}/servers");
    }
}
</code></pre>
<p><strong>高可用性对比分析</strong>：</p>



































<table><thead><tr><th>高可用维度</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>调度中心高可用</strong></td><td>数据库锁，同一时间只有一个调度中心工作</td><td>无中心调度器，天然无单点</td></tr><tr><td><strong>执行器高可用</strong></td><td>心跳检测，失败后任务路由到其他执行器</td><td>ZooKeeper临时节点，节点失效自动重新分片</td></tr><tr><td><strong>网络分区容忍</strong></td><td>调度中心与执行器断开后，任务暂停</td><td>ZooKeeper会话超时后，分片重新分配</td></tr><tr><td><strong>恢复时间</strong></td><td>依赖心跳间隔（默认30秒）</td><td>依赖ZooKeeper会话超时时间（默认60秒）</td></tr><tr><td><strong>实现复杂度</strong></td><td>简单直观</td><td>复杂但更健壮</td></tr></tbody></table>
<h2 data-id="heading-11">05 监控与管理能力</h2>
<p>对于生产系统来说，监控和管理能力同样重要。</p>
<h3 data-id="heading-12">XXL-JOB：完善的可视化管理</h3>
<p><code>XXL-JOB</code>提供了完整的Web管理界面，这是它的一大亮点：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 调度中心管理控制台的主要功能</span>
<span class="hljs-variable">@RestController</span>
<span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/jobadmin"</span>)
public class JobAdminController {
    
    <span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">"/add"</span>)
    public ReturnT&lt;String&gt; <span class="hljs-built_in">addJob</span>(<span class="hljs-variable">@RequestBody</span> XxlJobInfo jobInfo) {
        <span class="hljs-comment">// 添加任务</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.add</span>(jobInfo);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/trigger"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">ReturnT</span>&lt;<span class="hljs-selector-tag">String</span>&gt; <span class="hljs-selector-tag">triggerJob</span>(int id, String executorParam) {
        <span class="hljs-comment">// 手动触发任务</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.trigger</span>(id, executorParam);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/log"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">ReturnT</span>&lt;<span class="hljs-selector-tag">PageInfo</span>&lt;<span class="hljs-selector-tag">XxlJobLog</span>&gt;&gt; <span class="hljs-selector-tag">queryLog</span>(
            <span class="hljs-variable">@RequestParam</span>(required = false, defaultValue = <span class="hljs-string">"0"</span>) int start,
            <span class="hljs-variable">@RequestParam</span>(required = false, defaultValue = <span class="hljs-string">"10"</span>) int length,
            int jobId, int logStatus) {
        <span class="hljs-comment">// 查询任务日志</span>
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">xxlJobService</span><span class="hljs-selector-class">.queryLog</span>(start, length, jobId, logStatus);
    }
    
    @<span class="hljs-selector-tag">GetMapping</span>(<span class="hljs-string">"/dashboard"</span>)
    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>, <span class="hljs-selector-tag">Object</span>&gt; <span class="hljs-selector-tag">dashboardInfo</span>() {
        <span class="hljs-comment">// 仪表板数据</span>
        <span class="hljs-selector-tag">Map</span>&lt;<span class="hljs-selector-tag">String</span>, <span class="hljs-selector-tag">Object</span>&gt; <span class="hljs-selector-tag">dashboardMap</span> = <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HashMap</span>&lt;&gt;();
        
        <span class="hljs-comment">// 任务数量统计</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"jobNum"</span>, xxlJobService.<span class="hljs-built_in">count</span>());
        
        <span class="hljs-comment">// 执行器数量</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"executorNum"</span>, executorService.<span class="hljs-built_in">count</span>());
        
        <span class="hljs-comment">// 今日调度次数</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"scheduleNumToday"</span>, logService.<span class="hljs-built_in">countToday</span>());
        
        <span class="hljs-comment">// 调度成功率</span>
        <span class="hljs-selector-tag">dashboardMap</span><span class="hljs-selector-class">.put</span>(<span class="hljs-string">"successRate"</span>, logService.<span class="hljs-built_in">successRate</span>());
        
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">dashboardMap</span>;
    }
}
</code></pre>
<p>管理界面主要功能：</p>
<ol>
<li>1. <strong>任务管理</strong>：增删改查定时任务</li>
<li>2. <strong>任务操作</strong>：启动、停止、手动触发、查看日志</li>
<li>3. <strong>执行器管理</strong>：管理执行器集群</li>
<li>4. <strong>调度日志</strong>：查看每次调度的详细日志</li>
<li>5. <strong>报表统计</strong>：调度次数、成功率等统计信息</li>
</ol>
<h3 data-id="heading-13">Elastic-Job：基于事件追踪的监控</h3>
<p><code>Elastic-Job</code>没有官方的Web管理界面，但提供了完善的事件追踪和监控API：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Elastic-Job的事件追踪配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventTraceConfiguration</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">JobEventConfiguration</span> <span class="hljs-title function_">jobEventConfiguration</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 1. 数据库事件追踪</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobEventRdbConfiguration</span>(
            dataSource,
            <span class="hljs-string">"com.example.job.event"</span>, <span class="hljs-comment">// 表名前缀</span>
            <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否启用</span>
        );
        
        <span class="hljs-comment">// 或者使用ZooKeeper事件追踪</span>
        <span class="hljs-comment">// return new JobEventZookeeperConfiguration();</span>
    }
}

<span class="hljs-comment">// 自定义事件监听器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobEventListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractJobEventListener</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">dataSourceStatisticEvent</span>(<span class="hljs-params">JobExecutionEvent jobExecutionEvent</span>) {
        <span class="hljs-comment">// 统计事件处理</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业执行事件: jobName={}, status={}, startTime={}"</span>, 
                 jobExecutionEvent.<span class="hljs-title function_">getJobName</span>(),
                 jobExecutionEvent.<span class="hljs-title function_">getStatus</span>(),
                 jobExecutionEvent.<span class="hljs-title function_">getStartTime</span>());
        
        <span class="hljs-comment">// 可以发送到监控系统</span>
        monitorService.<span class="hljs-title function_">sendMetric</span>(
            <span class="hljs-string">"job.execution"</span>,
            jobExecutionEvent.<span class="hljs-title function_">isSuccess</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,
            <span class="hljs-string">"jobName"</span>, jobExecutionEvent.<span class="hljs-title function_">getJobName</span>()
        );
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">jobStatusTraceEvent</span>(<span class="hljs-params">JobStatusTraceEvent jobStatusTraceEvent</span>) {
        <span class="hljs-comment">// 作业状态追踪</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业状态变化: jobName={}, state={}, message={}"</span>, 
                 jobStatusTraceEvent.<span class="hljs-title function_">getJobName</span>(),
                 jobStatusTraceEvent.<span class="hljs-title function_">getState</span>(),
                 jobStatusTraceEvent.<span class="hljs-title function_">getMessage</span>());
    }
}
</code></pre>
<p><strong>监控能力对比</strong>：</p>



































<table><thead><tr><th>监控维度</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>管理界面</strong></td><td><strong>完整的Web管理控制台</strong></td><td>无官方界面，需自行开发</td></tr><tr><td><strong>日志查询</strong></td><td>内置日志查询功能</td><td>依赖应用日志，或通过事件追踪表查询</td></tr><tr><td><strong>实时监控</strong></td><td>提供简单的仪表板</td><td>需要集成第三方监控系统</td></tr><tr><td><strong>告警能力</strong></td><td>支持邮件告警</td><td>需自行实现告警逻辑</td></tr><tr><td><strong>扩展性</strong></td><td>监控功能相对固定</td><td><strong>事件监听机制扩展性强</strong></td></tr></tbody></table>
<h2 data-id="heading-14">06 性能与扩展性对比</h2>
<p>在实际生产环境中，性能和扩展性是需要重点考虑的因素。</p>
<h3 data-id="heading-15">性能对比</h3>
<p>通过基准测试，我们可以对比两个框架的关键性能指标：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 性能测试示例 - 模拟高并发调度场景</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceTest</span> {
    
    @Test
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testXXLJobSchedulePerformance</span>()</span> {
        <span class="hljs-comment">// 测试XXL-JOB的调度性能</span>
        <span class="hljs-built_in">int</span> jobCount = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 模拟1000个任务</span>
        <span class="hljs-built_in">long</span> startTime = System.currentTimeMillis();
        
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; jobCount; i++) {
            <span class="hljs-comment">// 模拟调度中心触发任务</span>
            triggerJob(i);
        }
        
        <span class="hljs-built_in">long</span> endTime = System.currentTimeMillis();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"XXL-JOB调度"</span> + jobCount + <span class="hljs-string">"个任务耗时: "</span> + 
                          (endTime - startTime) + <span class="hljs-string">"ms"</span>);
    }
    
    @Test
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testElasticJobSchedulePerformance</span>()</span> {
        <span class="hljs-comment">// 测试Elastic-Job的分片执行性能</span>
        <span class="hljs-built_in">int</span> dataSize = <span class="hljs-number">100000</span>; <span class="hljs-comment">// 10万条数据</span>
        <span class="hljs-built_in">int</span> shardTotal = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10个分片</span>
        
        <span class="hljs-built_in">long</span> startTime = System.currentTimeMillis();
        
        <span class="hljs-comment">// 模拟分片处理</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> shardIndex = <span class="hljs-number">0</span>; shardIndex &lt; shardTotal; shardIndex++) {
            processShardData(shardIndex, shardTotal, dataSize / shardTotal);
        }
        
        <span class="hljs-built_in">long</span> endTime = System.currentTimeMillis();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Elastic-Job处理"</span> + dataSize + <span class="hljs-string">"条数据耗时: "</span> + 
                          (endTime - startTime) + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<p><strong>性能对比数据（基于典型场景测试）</strong> ：</p>



































<table><thead><tr><th>性能指标</th><th>XXL-JOB</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>调度吞吐量</strong></td><td>单调度中心约500-1000任务/秒</td><td>无中心瓶颈，取决于节点数量</td></tr><tr><td><strong>任务触发延迟</strong></td><td>10-50毫秒</td><td>5-20毫秒（无中心转发）</td></tr><tr><td><strong>分片处理性能</strong></td><td>依赖手动分片实现</td><td><strong>优秀，自动负载均衡</strong></td></tr><tr><td><strong>资源消耗</strong></td><td>调度中心需独立资源</td><td>与业务应用共享资源</td></tr><tr><td><strong>水平扩展性</strong></td><td>调度中心扩展有限</td><td><strong>优秀，随节点增加线性扩展</strong></td></tr></tbody></table>
<h3 data-id="heading-16">扩展性对比</h3>
<p><strong>XXL-JOB的扩展点</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 自定义路由策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRouteStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ExecutorRouter</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">route</span>(<span class="hljs-params">TriggerParam triggerParam, List&lt;<span class="hljs-built_in">String</span>&gt; addressList</span>) {
        <span class="hljs-comment">// 自定义执行器路由逻辑</span>
        <span class="hljs-comment">// 例如：根据任务参数选择特定的执行器</span>
        
        <span class="hljs-title class_">String</span> jobParam = triggerParam.<span class="hljs-title function_">getExecutorParams</span>();
        <span class="hljs-keyword">if</span> (jobParam.<span class="hljs-title function_">contains</span>(<span class="hljs-string">"priority=high"</span>)) {
            <span class="hljs-comment">// 高优先级任务路由到专用执行器</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(<span class="hljs-title function_">findHighPriorityExecutor</span>(addressList));
        }
        
        <span class="hljs-comment">// 默认使用轮询策略</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(addressList.<span class="hljs-title function_">get</span>(<span class="hljs-number">0</span>));
    }
}

<span class="hljs-comment">// 自定义任务处理器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">IJobHandler</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ReturnT</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">execute</span>(<span class="hljs-title class_">String</span> param) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-comment">// 自定义任务执行逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnT</span>&lt;&gt;(<span class="hljs-title class_">ReturnT</span>.<span class="hljs-property">SUCCESS_CODE</span>, <span class="hljs-string">"自定义处理完成"</span>);
    }
}
</code></pre>
<p><strong>Elastic-Job的扩展点</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 自定义分片策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomShardingStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JobShardingStrategy</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; <span class="hljs-title function_">sharding</span>(<span class="hljs-params">
            List&lt;JobInstance&gt; jobInstances,
            <span class="hljs-built_in">String</span> jobName,
            int shardingTotalCount</span>) {
        
        <span class="hljs-comment">// 自定义分片算法</span>
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        
        <span class="hljs-comment">// 示例：根据实例的性能权重分配分片</span>
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JobInstance</span>, <span class="hljs-title class_">Integer</span>&gt; weights = <span class="hljs-title function_">getInstanceWeights</span>(jobInstances);
        
        <span class="hljs-comment">// 实现加权分片算法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">weightedSharding</span>(jobInstances, weights, shardingTotalCount);
    }
}

<span class="hljs-comment">// 自定义作业监听器</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomJobListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ElasticJobListener</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeJobExecuted</span>(<span class="hljs-params">ShardingContexts shardingContexts</span>) {
        <span class="hljs-comment">// 作业执行前的逻辑</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业{}开始执行，分片上下文: {}"</span>, 
                 shardingContexts.<span class="hljs-title function_">getJobName</span>(), shardingContexts);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">afterJobExecuted</span>(<span class="hljs-params">ShardingContexts shardingContexts</span>) {
        <span class="hljs-comment">// 作业执行后的逻辑</span>
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"作业{}执行完成"</span>, shardingContexts.<span class="hljs-title function_">getJobName</span>());
    }
}
</code></pre>
<h2 data-id="heading-17">07 实战选型指南</h2>
<p>基于我多年的开发和架构经验，总结出以下选型建议：</p>
<h3 data-id="heading-18">场景一：中小型项目，快速上线</h3>
<ul>
<li>• <strong>推荐</strong>：<code>XXL-JOB</code></li>
<li>• <strong>理由</strong>：开箱即用，有完善的管理界面，学习成本低</li>
<li>• <strong>典型场景</strong>：企业内部管理系统、中小型电商、内容管理系统</li>
</ul>

<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 快速启动配置示例</span>
<span class="hljs-attr">xxl:</span>
  <span class="hljs-attr">job:</span>
    <span class="hljs-attr">admin:</span>
      <span class="hljs-string">addresses:</span> <span class="hljs-string">http://localhost:8080/xxl-job-admin</span>
    <span class="hljs-attr">executor:</span>
      <span class="hljs-string">appname:</span> <span class="hljs-string">xxl-job-executor-demo</span>
      <span class="hljs-string">address:</span> 
      <span class="hljs-string">ip:</span> 
      <span class="hljs-string">port:</span> <span class="hljs-number">9999</span>
      <span class="hljs-string">logpath:</span> <span class="hljs-string">/data/applogs/xxl-job/jobhandler</span>
      <span class="hljs-string">logretentiondays:</span> <span class="hljs-number">30</span>
</code></pre>
<h3 data-id="heading-19">场景二：大数据量处理，需要弹性扩缩容</h3>
<ul>
<li>• <strong>推荐</strong>：<code>Elastic-Job</code></li>
<li>• <strong>理由</strong>：智能分片，自动负载均衡，适合大数据处理</li>
<li>• <strong>典型场景</strong>：数据清洗、报表生成、日志分析、ETL任务</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 大数据处理作业配置</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">DataflowJob</span> <span class="hljs-title function_">dataflowJob</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDataProcessingJob</span>();
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">LiteJobConfiguration</span> <span class="hljs-title function_">bigDataJobConfig</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">LiteJobConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataflowJobConfiguration</span>(
            <span class="hljs-title class_">JobCoreConfiguration</span>.<span class="hljs-title function_">newBuilder</span>(
                <span class="hljs-string">"bigDataJob"</span>, 
                <span class="hljs-string">"0 0 2 * * ?"</span>,  <span class="hljs-comment">// 每天凌晨2点执行</span>
                <span class="hljs-number">10</span>               <span class="hljs-comment">// 10个分片</span>
            ).<span class="hljs-title function_">build</span>(),
            <span class="hljs-title class_">BigDataProcessingJob</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">getCanonicalName</span>()
        )
    ).<span class="hljs-title function_">monitorPort</span>(<span class="hljs-number">9888</span>)  <span class="hljs-comment">// 监控端口</span>
     .<span class="hljs-title function_">overwrite</span>(<span class="hljs-literal">true</span>)
     .<span class="hljs-title function_">build</span>();
}
</code></pre>
<h3 data-id="heading-20">场景三：已有ZooKeeper集群的技术栈</h3>
<ul>
<li>• <strong>推荐</strong>：<code>Elastic-Job</code></li>
<li>• <strong>理由</strong>：复用现有基础设施，降低运维复杂度</li>
<li>• <strong>典型场景</strong>：大型互联网公司、金融系统、已有ZooKeeper服务发现的系统</li>
</ul>
<h3 data-id="heading-21">场景四：需要精细化管理与监控</h3>
<ul>
<li>• <strong>推荐</strong>：<code>XXL-JOB</code></li>
<li>• <strong>理由</strong>：提供完整的Web管理界面，便于运维</li>
<li>• <strong>典型场景</strong>：对运维友好性要求高的项目、多团队协作项目</li>
</ul>
<h3 data-id="heading-22">场景五：混合架构的折中方案</h3>
<p>在实际项目中，有时可以采用混合方案：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b82cc83bc204986bb6771463a25d3e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuP5LiJ6K-05oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771212918&amp;x-signature=6FythrpPevMfftd%2BM4j2NocVfpQ%3D" alt="图片" loading="lazy"/></p>
<p>在这种混合架构中：</p>
<ol>
<li>1. <strong>常规定时任务</strong>：使用<code>XXL-JOB</code>，便于管理和监控</li>
<li>2. <strong>大数据分片任务</strong>：使用<code>Elastic-Job</code>，发挥其分布式处理优势</li>
<li>3. <strong>优势互补</strong>：结合两者的优点，满足不同场景需求</li>
</ol>
<p>更多项目实战在：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fsusan.net.cn%2Fproject" title="https://link.juejin.cn/?target=http%3A%2F%2Fsusan.net.cn%2Fproject" target="_blank">java突击队</a></p>
<h2 data-id="heading-23">总结</h2>
<p>经过全面的对比分析，我们可以得出以下结论：</p>
<p><strong>XXL-JOB更适合</strong>：</p>
<ul>
<li>• 中小型项目，需要快速上手</li>
<li>• 对运维管理界面有要求的团队</li>
<li>• 任务类型相对简单，不需要复杂分片逻辑</li>
<li>• 技术栈中已有MySQL，不想引入ZooKeeper</li>
</ul>
<p><strong>Elastic-Job更适合</strong>：</p>
<ul>
<li>• 大数据量处理场景，需要智能分片</li>
<li>• 已有ZooKeeper基础设施的团队</li>
<li>• 需要高度弹性伸缩的云原生环境</li>
<li>• 对性能要求极高，需要去中心化架构</li>
</ul>
<p><strong>技术选型的核心原则</strong>：</p>
<ol>
<li>1. <strong>没有最好的框架，只有最适合的框架</strong></li>
<li>2. <strong>考虑团队技术栈和运维能力</strong></li>
<li>3. <strong>根据业务场景选择，而不是技术潮流</strong></li>
<li>4. <strong>简单性原则：在满足需求的前提下，选择更简单的方案</strong></li>
</ol>
<p>有些小伙伴在工作中可能会纠结于技术选型，我的建议是：<strong>先明确业务需求，再选择技术方案</strong>。</p>
<p>如果你需要一个开箱即用、管理方便的调度系统，选<code>XXL-JOB</code>；如果你要处理海量数据、需要弹性伸缩，选<code>Elastic-Job</code>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla]]></title>    <link>https://juejin.cn/post/7603781883974582291</link>    <guid>https://juejin.cn/post/7603781883974582291</guid>    <pubDate>2026-02-09T00:56:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974582291" data-draft-id="7604084016509648937" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-02-09T00:56:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Cache技术分享"/> <meta itemprop="url" content="https://juejin.cn/user/1662117313262776"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— mapping、filtering 和 fla
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1662117313262776/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Cache技术分享
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T00:56:16.000Z" title="Mon Feb 09 2026 00:56:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">318. Java Stream API - 深入理解 Java Stream 的中间 Collector —— <code>mapping</code>、<code>filtering</code> 和 <code>flatMapping</code></h2>
<p>在使用 <code>Stream</code> 的 <code>collect()</code> 方法时，我们通常接触的 <code>Collector</code> 是 <strong>终端操作（<code>terminal operations</code>）</strong>，比如：</p>
<ul>
<li><code>Collectors.counting()</code>：计算数量 ✅</li>
<li><code>Collectors.joining()</code>：拼接字符串 ✅</li>
<li><code>Collectors.toList()</code>、<code>toSet()</code>、<code>toMap()</code>：收集到集合 ✅</li>
</ul>
<p>但除了这些终端操作外，<code>Java</code> 的 <code>Collector</code> <code>API</code> 还提供了一些 <strong>中间 <code>Collector</code></strong>，如：</p>
<ul>
<li><code>mapping</code></li>
<li><code>filtering</code></li>
<li><code>flatMapping</code></li>
</ul>
<p>这些 Collector 本身无法单独使用，必须配合一个 <strong>下游 Collector（downstream collector）</strong>。你可以理解为：</p>
<blockquote>
<p>🎯 “我们在收集之前，先加工一下再装袋。”</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">🧭 为什么需要中间 Collector？</h3>
<p>有时候，我们不仅想将元素分组或收集，还想在收集之前“处理一下”。比如：</p>
<ul>
<li>把字符串变成大写再收集</li>
<li>过滤掉不想要的值再分组</li>
<li>将一个对象映射为其某个字段再放进 Map</li>
</ul>
<p>这时候中间 Collector 就登场了！</p>
<hr/>
<h3 data-id="heading-2">🧪 示例 1：使用 <code>mapping()</code> 做数据转换</h3>
<p>假设你有一堆英文单词字符串，想将它们变成大写字母并放进列表中：</p>
<pre><code class="hljs language-java" lang="java">Collection&lt;String&gt; strings = List.of(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>, 
                                     <span class="hljs-string">"seven"</span>, <span class="hljs-string">"eight"</span>, <span class="hljs-string">"nine"</span>, <span class="hljs-string">"ten"</span>, <span class="hljs-string">"eleven"</span>, <span class="hljs-string">"twelve"</span>);

List&lt;String&gt; result = strings.stream()
    .collect(Collectors.mapping(String::toUpperCase, Collectors.toList()));

System.out.println(<span class="hljs-string">"result = "</span> + result);
</code></pre>
<h4 data-id="heading-3">🧾 输出：</h4>
<pre><code class="hljs language-java" lang="java">result = [ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, ELEVEN, TWELVE]
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>mapping(String::toUpperCase, ...)</code> 是中间 Collector，先把元素变为大写。</li>
<li><code>Collectors.toList()</code> 是终端 Collector，把处理结果装进列表。</li>
</ul>
<p>你可以把这看作是“加工厂 + 装箱厂”的组合 🤖📦。</p>
<hr/>
<h3 data-id="heading-4">🧪 示例 2：结合 <code>groupingBy()</code> 和 <code>mapping()</code> 解决复杂 Map 转换问题</h3>
<p>假设你要统计不同长度的单词出现次数（即直方图），然后你想<strong>倒转这个 Map</strong>，以“次数”为 key，得到这些次数对应的“长度”。</p>
<p>第一步：创建直方图 <code>Map&lt;Integer, Long&gt;</code>：</p>
<pre><code class="hljs language-java" lang="java">Map&lt;Integer, Long&gt; histogram = strings.stream()
    .collect(Collectors.groupingBy(String::length, Collectors.counting()));
</code></pre>
<p>第二步：使用 <code>record</code> 将 Map entry 封装成对象，方便处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">NumberOfLength</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">long</span> number)</span> {
    <span class="hljs-keyword">static</span> NumberOfLength <span class="hljs-title function_">fromEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Long&gt; entry)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberOfLength</span>(entry.getKey(), entry.getValue());
    }
}
</code></pre>
<p>第三步：倒转 Map，以“次数”为 key，用 <code>mapping()</code> 提取 <code>length</code> 字段：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">var</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> histogram.entrySet().stream()
    .map(NumberOfLength::fromEntry)
    .collect(Collectors.groupingBy(
        NumberOfLength::number, <span class="hljs-comment">// 按出现次数分组</span>
        Collectors.mapping(NumberOfLength::length, Collectors.toList()) <span class="hljs-comment">// 提取 length 放进 List</span>
    ));

map.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">" :: "</span> + value));
</code></pre>
<h4 data-id="heading-5">🔍 输出示例：</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-number">2</span> :: [<span class="hljs-number">6</span>]
<span class="hljs-number">3</span> :: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>这表示：长度为 3、4、5 的单词各出现了 3 次；长度为 6 的出现了 2 次。</p>
<hr/>
<h3 data-id="heading-6">🏆 提取最大值对应的 key（次数最多的字符串长度）</h3>
<pre><code class="hljs language-java" lang="java">Map.Entry&lt;Long, List&lt;Integer&gt;&gt; result =
    map.entrySet().stream()
        .max(Map.Entry.comparingByKey()) <span class="hljs-comment">// 找到次数最多的 group</span>
        .orElseThrow();

System.out.println(<span class="hljs-string">"result = "</span> + result);
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-java" lang="java">result = <span class="hljs-number">3</span>=[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>你就得到了出现次数最多的字符串长度（3 次）：长度为 3、4、5 的单词。</p>
<hr/>
<h3 data-id="heading-7">🧪 示例 3：使用 <code>filtering()</code> 收集特定条件的值</h3>
<ul>
<li>java9+可用</li>
</ul>
<pre><code class="hljs language-java" lang="java">Map&lt;Integer, List&lt;String&gt;&gt; filteredGrouped =
    strings.stream()
           .collect(Collectors.groupingBy(
               String::length,
               Collectors.filtering(s -&gt; s.contains(<span class="hljs-string">"e"</span>), Collectors.toList())
           ));

System.out.println(filteredGrouped);
</code></pre>
<p>📌 解释：</p>
<ul>
<li><code>filtering()</code> 是一个中间 Collector，只收集包含字母 <code>'e'</code> 的单词。</li>
<li>最终结果还是一个分组，但每组只留下符合条件的值。</li>
</ul>
<hr/>
<h3 data-id="heading-8">🧪 示例 4：使用 <code>flatMapping()</code> 将嵌套集合打平</h3>
<ul>
<li>java9+可用</li>
</ul>
<p>如果你有一个 <code>List&lt;List&lt;String&gt;&gt;</code>，想打平成一个大列表，可以这样：</p>
<pre><code class="hljs language-java" lang="java">List&lt;List&lt;String&gt;&gt; nested = List.of(
    List.of(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>),
    List.of(<span class="hljs-string">"c"</span>),
    List.of(<span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>)
);

List&lt;String&gt; flat = nested.stream()
    .collect(Collectors.flatMapping(List::stream, Collectors.toList()));

System.out.println(flat);
</code></pre>
<p>📌 输出：</p>
<pre><code class="hljs language-java" lang="java">[a, b, c, d, e, f]
</code></pre>
<hr/>
<h3 data-id="heading-9">🎯 总结与培训小贴士</h3>

























<table><thead><tr><th>Collector 类型</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><code>mapping()</code></td><td>将元素映射后再收集</td><td>提取字段、格式转换</td></tr><tr><td><code>filtering()</code></td><td>筛选符合条件的元素再收集</td><td>条件收集</td></tr><tr><td><code>flatMapping()</code></td><td>扁平化流结构后收集</td><td>嵌套集合、多个子项的合并</td></tr></tbody></table>
<p>✅ 这些中间 Collector 是创建嵌套结构和处理 Map 数据的强大工具。
✅ 多层嵌套也没什么可怕的，本质是“先加工后装袋”的组合模型。
✅ <code>groupingBy()</code> 搭配中间 Collector 是流处理中最常见也最强大的用法之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Skills Desktop：一个用来管理 Skill 的桌面工具]]></title>    <link>https://juejin.cn/post/7604080364353667099</link>    <guid>https://juejin.cn/post/7604080364353667099</guid>    <pubDate>2026-02-09T02:22:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604080364353667099" data-draft-id="7604646882015248435" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Skills Desktop：一个用来管理 Skill 的桌面工具"/> <meta itemprop="keywords" content="Cursor,AI编程"/> <meta itemprop="datePublished" content="2026-02-09T02:22:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HBLOG"/> <meta itemprop="url" content="https://juejin.cn/user/131597124767479"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Skills Desktop：一个用来管理 Skill 的桌面工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597124767479/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HBLOG
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:22:30.000Z" title="Mon Feb 09 2026 02:22:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在实际开发过程中，Skill 用得多了，很容易变成一种“看似都在，其实很乱”的状态。</p>
<ul>
<li>有的在 GitHub 仓库里</li>
<li>有的拷在本地某个目录</li>
<li>有的只存在于旧项目里</li>
</ul>
<p><strong>Skills Desktop</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.lc%2Fdesktop%25EF%25BC%2589%25E5%25B0%25B1%25E6%2598%25AF%25E5%259C%25A8%25E8%25BF%2599%25E7%25A7%258D%25E6%2583%2585%25E5%2586%25B5%25E4%25B8%258B%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E3%2580%2582" target="_blank" title="https://skills.lc/desktop%EF%BC%89%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E5%87%BA%E7%8E%B0%E7%9A%84%E3%80%82" ref="nofollow noopener noreferrer">skills.lc/desktop）就是在…</a><br/>
它不是编辑器，也不是运行环境，而是一个<strong>专门用来管理 Skill 的桌面客户端</strong>。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-3.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-3.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b61b6b812c584ecfad7b0ed30571f903~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=VazL%2FUobzhhGG%2ByrwZfoRBA%2BehE%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-0">它主要解决什么问题</h2>
<p>一句话概括：</p>
<blockquote>
<p><strong>让 Skill 在本地有一个“固定的位置和统一的管理方式”。</strong></p>
</blockquote>
<p>不需要再记路径，也不用反复复制文件。</p>
<h2 data-id="heading-1">本地集中管理 Skill</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-2.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-2.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b53d354829854f28aa93f6be65dc666f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=1nwzfcW0bjrqYkoImx9DFep7HlY%3D" alt="" loading="lazy"/></a></p>
<p>Skills Desktop 做的第一件事，就是把 Skill 统一放到一个地方。</p>
<p>你可以：</p>
<ul>
<li>把 Skill 安装到本地</li>
<li>看到当前有哪些 Skill</li>
<li>按用途或项目去整理</li>
</ul>
<p>它更像一个 <strong>本地 Skill 仓库管理器</strong>，而不是展示工具。</p>
<h2 data-id="heading-2">不依赖浏览器，更贴近工作流</h2>
<p>很多时候你并不想打开网页：</p>
<ul>
<li>正在写代码</li>
<li>正在调试脚本</li>
<li>正在切项目</li>
</ul>
<p>Skills Desktop 是常驻本地的：</p>
<ul>
<li>打开速度快</li>
<li>不依赖网络</li>
<li>不用来回切标签页</li>
</ul>
<p>需要用 Skill 的时候，直接就在桌面端处理。</p>
<h2 data-id="heading-3">不强绑定工具和框架</h2>
<p>Skills Desktop 不要求你：</p>
<ul>
<li>换 IDE</li>
<li>用特定模型</li>
<li>绑定某个平台</li>
</ul>
<p>它只负责一件事：<br/>
<strong>把 Skill 准备好，交给你现有的工具去用。</strong></p>
<p>这一点在多项目、多环境下特别重要。</p>
<h2 data-id="heading-4">离线可用</h2>
<p>Skill 一旦同步到本地：</p>
<ul>
<li>不需要联网</li>
<li>不依赖远程仓库</li>
<li>不影响日常开发</li>
</ul>
<p>对于经常出差、网络不稳定，或者只是想保持工作节奏的人来说，这点很实在。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fadmin.liuhaihua.cn%2Fwp-content%2Fuploads%2F2026%2F02%2Fimage-4.png" target="_blank" title="https://admin.liuhaihua.cn/wp-content/uploads/2026/02/image-4.png" ref="nofollow noopener noreferrer"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9f801406cfd4522b8075a4292bc2943~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEJMT0c=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208550&amp;x-signature=46tnfy%2BNJ7OqZS8urDLKRhBWdrg%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-5">适合什么人用</h2>
<p>Skills Desktop 更适合：</p>
<ul>
<li>本地有多个项目的人</li>
<li>需要长期维护 Skill 的人</li>
<li>不想每次都重新整理 Prompt / Skill 的人</li>
<li>希望把 Skill 当成工具，而不是素材的人</li>
</ul>
<p>如果你只是偶尔复制一段提示词，它可能不是必须的；<br/>
但如果 Skill 已经成了你工作的一部分，它会省掉不少麻烦。</p>
<h2 data-id="heading-6">总结</h2>
<p>Skills Desktop 并不复杂，也不试图做“万能工具”。</p>
<p>它只是把一件一直很乱的事情——<br/>
<strong>Skill 的本地管理</strong>，变得清晰、有序、可持续。</p>
<p>官网：<br/>
👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fskills.lc%2Fdesktop" target="_blank" title="https://skills.lc/desktop" ref="nofollow noopener noreferrer">skills.lc/desktop</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 GPIO 八种工作模式：从原理到实战应用]]></title>    <link>https://juejin.cn/post/7603783314713624612</link>    <guid>https://juejin.cn/post/7603783314713624612</guid>    <pubDate>2026-02-09T01:11:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603783314713624612" data-draft-id="7603911453704978475" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 GPIO 八种工作模式：从原理到实战应用"/> <meta itemprop="keywords" content="嵌入式"/> <meta itemprop="datePublished" content="2026-02-09T01:11:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 GPIO 八种工作模式：从原理到实战应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:11:23.000Z" title="Mon Feb 09 2026 01:11:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 GPIO 八种工作模式：从原理到实战应用</h2>
<p>作为嵌入式开发中最基础也最核心的外设，GPIO（通用输入/输出口）就像是单片机与外部世界沟通的“桥梁”。而 GPIO 的八种工作模式——浮空输入、上拉输入、下拉输入、模拟输入、开漏输出、推挽输出、复用开漏输出、复用推挽输出，直接决定了这座“桥梁”的沟通方式、稳定性和适用场景。</p>
<p>很多嵌入式新手在初期都会被这八种模式搞混，不清楚每种模式的底层逻辑的适用场景，甚至在项目中因模式选择错误导致设备工作异常（比如按键检测失灵、LED 闪烁不稳定、总线通信失败）。今天，我们就逐一拆解这八种模式，从工作原理、电路特性、实战场景三个维度，帮你彻底吃透，再也不踩坑。</p>
<h2 data-id="heading-1">一、先理清核心：输入模式 vs 输出模式</h2>
<p>GPIO 的八种模式本质上可以分为两大类：<strong>​输入模式（4 种）​</strong>和​**输出模式（4 种）**​。核心区别在于：输入模式是 GPIO 接收外部信号（如按键、传感器的电平），输出模式是 GPIO 向外部发送信号（如驱动 LED、控制继电器）。而“复用”则是指 GPIO 不再由软件直接控制，而是交由单片机内部外设（如 UART、SPI、I2C）使用，本质还是输入或输出逻辑。</p>
<h2 data-id="heading-2">二、输入模式详解（4 种）：接收外部信号的“正确姿势”</h2>
<p>输入模式的核心是“高阻抗接收”，GPIO 本身不主动输出电平，仅作为信号的“接收端”，核心差异在于是否通过电阻固定电平（避免信号不稳定），以及是否用于模拟信号采集。</p>
<h3 data-id="heading-3">1. 浮空输入（Floating Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚处于高阻抗状态，不接内部上拉或下拉电阻，引脚电平完全由外部电路决定，相当于“悬浮”在空中，仅被动接收外部信号。</p>
<p>​<strong>工作原理</strong>​：引脚内部未连接任何固定电阻，输入阻抗极高（接近开路），外部信号的微小变化都会影响引脚电平。此时 GPIO 仅作为“信号检测端”，不干预外部电平。</p>
<p>​<strong>实战场景</strong>​：仅适用于外部电路已明确提供稳定电平的场景，比如连接 TTL 电平传感器（如红外接收头、串口 RX 引脚）、外部有下拉/上拉电阻的按键电路。</p>
<p>​<strong>注意事项</strong>​：若外部电路未提供固定电平（如悬空的按键），引脚电平会处于“不确定状态”（可能是高电平、低电平，或受干扰波动），导致检测错误，因此​<strong>禁止单独用于按键检测等无外部固定电平的场景</strong>​。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 浮空输入模式配置（PA0）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_FloatingInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟（STM32必须先使能外设时钟）</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为浮空输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="hljs-comment">// 浮空输入模式</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 引脚速度（输入模式可忽略，默认配置即可）</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取浮空输入引脚电平（示例）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">GPIO_Read_FloatingInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 读取PA0引脚电平，返回0（低电平）或1（高电平）</span>
    <span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
}
</code></pre>
<p>关键：<code>GPIO_Mode_IN_FLOATING</code> 对应浮空输入模式，无需配置上拉/下拉电阻，直接读取外部电平即可。</p>
<h3 data-id="heading-4">2. 上拉输入（Pull-Up Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部连接一个上拉电阻（一端接 VCC，另一端接引脚），无外部信号时，引脚被拉至高电平；当外部电路将引脚拉至低电平时，引脚电平变为低电平。</p>
<p>​<strong>工作原理</strong>​：内部上拉电阻（通常为 10K~100KΩ）提供一个稳定的高电平偏置，外部信号通过拉低引脚来改变电平状态。例如，按键一端接 GPIO（上拉输入），另一端接地，未按下时引脚为高电平，按下时引脚被拉低为低电平。</p>
<p>​<strong>实战场景</strong>​：最常用的输入模式，适合外部无固定电平的场景，比如独立按键检测、接近开关（NPN 型）信号接收、外部设备的“就绪/忙碌”信号检测（低电平有效）。</p>
<p>​<strong>优势</strong>​：解决浮空输入的不稳定问题，无需外部额外接电阻，简化电路设计，降低成本。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，适配独立按键检测）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 上拉输入模式配置（PA0，适配独立按键）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PullUpInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为上拉输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;      <span class="hljs-comment">// 上拉输入模式（IPU = Input Pull-Up）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输入模式可忽略速度配置</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取上拉输入引脚电平（检测按键）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">Key_Read_PullUp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 按键一端接PA0，另一端接地；未按下时PA0为高电平（1），按下时为低电平（0）</span>
    <span class="hljs-keyword">if</span>(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == <span class="hljs-number">0</span>)
    {
        <span class="hljs-comment">// 延时消抖（简单消抖，实际项目可优化）</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++);
        <span class="hljs-keyword">if</span>(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 按键按下</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 按键未按下</span>
}
</code></pre>
<p>关键：<code>GPIO_Mode_IPU</code> 对应上拉输入，内部自动使能上拉电阻，无需外接，直接适配独立按键检测。</p>
<h3 data-id="heading-5">3. 下拉输入（Pull-Down Input）</h3>
<p>​<strong>核心定义</strong>​：与上拉输入相反，GPIO 引脚内部连接一个下拉电阻（一端接地 GND，另一端接引脚），无外部信号时，引脚被拉至低电平；当外部电路将引脚拉至高电平时，引脚电平变为高电平。</p>
<p>​<strong>工作原理</strong>​：内部下拉电阻提供低电平偏置，外部信号通过拉高引脚来触发电平变化。例如，按键一端接 GPIO（下拉输入），另一端接 VCC，未按下时引脚为低电平，按下时引脚被拉高为高电平。</p>
<p>​<strong>实战场景</strong>​：适合外部信号为高电平有效的场景，比如 PNP 型接近开关信号接收、外部设备的“触发信号”检测（高电平有效）、继电器的状态反馈（高电平表示吸合）。</p>
<p>​<strong>与上拉输入的区别</strong>​：核心是“默认电平”和“触发电平”相反，根据外部电路的电平极性选择，避免电平冲突。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 下拉输入模式配置（PA0）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PullDownInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为下拉输入模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;      <span class="hljs-comment">// 下拉输入模式（IPD = Input Pull-Down）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输入模式可忽略速度配置</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

<span class="hljs-comment">// 读取下拉输入引脚电平（示例）</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">GPIO_Read_PullDownInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 未接外部信号时，PA0为低电平（0）；外部拉高时，返回高电平（1）</span>
    <span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
}
</code></pre>
<p>关键：<code>GPIO_Mode_IPD</code> 对应下拉输入，内部自动使能下拉电阻，默认电平为低，适配高电平有效信号。</p>
<h3 data-id="heading-6">4. 模拟输入（Analog Input）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部断开数字输入缓冲器，直接将外部模拟信号（连续变化的电压信号）传入单片机内部的 ADC（模数转换器），用于采集模拟量。</p>
<p>​<strong>工作原理</strong>​：与数字输入（仅识别高/低电平）不同，模拟输入可接收 0~VCC 之间的任意电压值（如 0~3.3V、0~5V），并通过 ADC 转换为数字信号，供单片机处理。此时引脚不再用于数字信号检测，仅作为模拟信号的“传输通道”。</p>
<p>​<strong>实战场景</strong>​：模拟量采集场景，比如电位器调节（采集电阻变化对应的电压）、温度传感器（如 LM35，输出电压随温度变化）、湿度传感器、光照传感器等，需要获取连续变化的物理量时使用。</p>
<p>​<strong>注意事项</strong>​：并非所有 GPIO 引脚都支持模拟输入，需查看单片机 datasheet，通常标注为“ADCx_INx”的引脚才可作为模拟输入使用；模拟输入引脚不宜接强电，避免损坏 ADC 模块。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，PA0 对应 ADC1_IN0）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_adc.h"</span></span>

<span class="hljs-comment">// 模拟输入模式配置（PA0，用于ADC采集）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AnalogInput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和ADC1时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为模拟输入模式（关键：断开数字缓冲，接入ADC）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;      <span class="hljs-comment">// 模拟输入模式（AIN = Analog Input）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 模拟输入模式可忽略速度</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// （可选）ADC初始化（模拟输入需配合ADC使用，完整示例）</span>
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; <span class="hljs-comment">// ADC1独立工作模式</span>
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;      <span class="hljs-comment">// 单通道采集</span>
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; <span class="hljs-comment">// 连续采集模式</span>
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; <span class="hljs-comment">// 无外部触发</span>
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; <span class="hljs-comment">// 数据右对齐</span>
    ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 采集通道数量</span>
    ADC_Init(ADC1, &amp;ADC_InitStructure);
    
    <span class="hljs-comment">// 使能ADC1</span>
    ADC_Cmd(ADC1, ENABLE);
}

<span class="hljs-comment">// 读取模拟输入ADC值（示例）</span>
<span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ADC_Read_AnalogInput</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 选择ADC1通道0（PA0），采样时间55.5周期</span>
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="hljs-number">1</span>, ADC_SampleTime_55Cycles5);
    <span class="hljs-comment">// 启动ADC转换</span>
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    <span class="hljs-comment">// 等待转换完成</span>
    <span class="hljs-keyword">while</span>(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
    <span class="hljs-comment">// 返回转换结果（12位ADC，范围0~4095）</span>
    <span class="hljs-keyword">return</span> ADC_GetConversionValue(ADC1);
}
</code></pre>
<p>关键：<code>GPIO_Mode_AIN</code> 对应模拟输入，需配合 ADC 初始化，引脚仅作为模拟信号传输通道，不参与数字逻辑。</p>
<h2 data-id="heading-7">三、输出模式详解（4 种）：发送外部信号的“核心方式”</h2>
<p>输出模式的核心是“主动输出电平”，GPIO 引脚由单片机软件（或内部外设）控制，向外部电路输出高电平（VCC）或低电平（GND），核心差异在于输出驱动方式（开漏/推挽）和是否复用为外设功能。</p>
<h3 data-id="heading-8">1. 开漏输出（Open-Drain Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部仅包含 N 沟道 MOS 管，无内部上拉电阻，输出低电平时，MOS 管导通，引脚接地；输出高电平时，MOS 管截止，引脚处于高阻抗状态（浮空），无法主动输出高电平，需外部接一个上拉电阻才能输出高电平。</p>
<p>​<strong>工作原理</strong>​：相当于一个“可控开关”，仅能控制引脚“接地”（低电平），无法控制引脚“接 VCC”（高电平）。外部上拉电阻的作用是，当 MOS 管截止时，将引脚拉至高电平，实现高电平输出。</p>
<p>​**核心特性：线与（Wire-AND）**​：多个开漏输出引脚可连接在同一条总线上，共享一个外部上拉电阻。只要有一个引脚输出低电平，整个总线就为低电平；只有所有引脚都输出高电平（浮空），总线才为高电平。这是开漏输出最关键的优势。</p>
<p>​<strong>实战场景</strong>​：总线通信（如 I2C 总线的 SDA、SCL 引脚）、多个设备的电平联动（如多个 LED 共阳极驱动）、需要实现线与功能的场景；也可用于驱动大电流设备（外部上拉电阻 + 三极管/继电器）。</p>
<p>​<strong>注意事项</strong>​：必须外接上拉电阻才能输出高电平，上拉电阻的阻值决定输出电流大小和响应速度；输出高电平时，引脚电平由外部上拉电阻决定，并非单片机内部 VCC。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，外接上拉电阻驱动 LED）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 开漏输出模式配置（PA0，外接上拉电阻）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_OpenDrainOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为开漏输出模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="hljs-comment">// 开漏输出模式（Out_OD = Output Open Drain）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz（根据需求调整）</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（PA0外接10KΩ上拉电阻到VCC）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 初始状态：输出高电平（MOS管截止，由外部上拉电阻拉高）</span>
    GPIO_SetBits(GPIOA, GPIO_Pin_0);
}

<span class="hljs-comment">// 开漏输出电平控制（示例：驱动LED亮灭）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">LED_Control_OpenDrain</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> state)</span>
{
    <span class="hljs-keyword">if</span>(state == <span class="hljs-number">1</span>)
    {
        GPIO_SetBits(GPIOA, GPIO_Pin_0);  <span class="hljs-comment">// 输出高电平（MOS管截止，外部上拉）</span>
    }
    <span class="hljs-keyword">else</span>
    {
        GPIO_ResetBits(GPIOA, GPIO_Pin_0); <span class="hljs-comment">// 输出低电平（MOS管导通，接地）</span>
    }
}
</code></pre>
<p>关键：<code>GPIO_Mode_Out_OD</code> 对应开漏输出，代码中 <code>GPIO_SetBits</code> 仅能让引脚截止（浮空），需外接上拉电阻才能实现高电平输出。</p>
<h3 data-id="heading-9">2. 推挽输出（Push-Pull Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚内部包含 N 沟道和 P 沟道两个 MOS 管，两个 MOS 管互补工作，可主动输出高电平和低电平，无需外部上拉/下拉电阻。</p>
<p>​<strong>工作原理</strong>​：输出高电平时，P 沟道 MOS 管导通、N 沟道 MOS 管截止，引脚接 VCC，输出高电平；输出低电平时，N 沟道 MOS 管导通、P 沟道 MOS 管截止，引脚接地，输出低电平。两个 MOS 管交替工作，实现“推”（输出高电平）和“挽”（输出低电平）的驱动效果。</p>
<p>​<strong>核心优势</strong>​：输出驱动能力强（相比开漏输出），无需外部电阻，可直接驱动中小电流设备；输出电平稳定，高电平为 VCC，低电平为 GND，无浮空状态。</p>
<p>​<strong>实战场景</strong>​：最常用的输出模式，适合直接驱动中小电流设备，比如 LED 指示灯、小型继电器（直接驱动或通过三极管放大）、串口 TX 引脚（输出 TTL 电平）、GPIO 口直接控制的开关电路等。</p>
<p>​<strong>注意事项</strong>​：不能将多个推挽输出引脚直接连接在一起（若一个输出高、一个输出低，会导致两个 MOS 管同时导通，产生大电流，烧毁引脚）；驱动大电流设备时，需外接放大电路（三极管、MOS 管）。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA0 引脚为例，直接驱动 LED）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>

<span class="hljs-comment">// 推挽输出模式配置（PA0，直接驱动LED）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_PushPullOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA0为推挽输出模式</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;          <span class="hljs-comment">// 选择PA0引脚</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   <span class="hljs-comment">// 推挽输出模式（Out_PP = Output Push Pull）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（无需外接电阻，直接驱动小电流LED）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 初始状态：输出低电平（LED熄灭）</span>
    GPIO_ResetBits(GPIOA, GPIO_Pin_0);
}

<span class="hljs-comment">// 推挽输出电平控制（示例：LED闪烁）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">LED_Blink_PushPull</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_SetBits(GPIOA, GPIO_Pin_0);    <span class="hljs-comment">// 输出高电平，LED点亮</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500</span>; i++);   <span class="hljs-comment">// 延时</span>
    GPIO_ResetBits(GPIOA, GPIO_Pin_0);  <span class="hljs-comment">// 输出低电平，LED熄灭</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500</span>; i++);   <span class="hljs-comment">// 延时</span>
}
</code></pre>
<p>关键：<code>GPIO_Mode_Out_PP</code> 对应推挽输出，<code>GPIO_SetBits</code> 主动输出高电平、<code>GPIO_ResetBits</code> 主动输出低电平，无需外接电阻，直接驱动中小电流设备。</p>
<h3 data-id="heading-10">3. 复用开漏输出（Alternate Function Open-Drain Output）</h3>
<p>​<strong>核心定义</strong>​：GPIO 引脚的输出控制权不再由单片机软件（GPIO 寄存器）控制，而是交由内部外设（如 UART、SPI、I2C、定时器）控制，输出驱动方式为开漏输出，需外部上拉电阻才能输出高电平。</p>
<p>​<strong>工作原理</strong>​：引脚功能被“复用”为外设功能，电平输出由外设决定（而非软件写 GPIO 输出寄存器），驱动逻辑与普通开漏输出一致——仅能主动输出低电平，高电平需外部上拉电阻实现。</p>
<p>​<strong>实战场景</strong>​：外设需要开漏输出特性的场景，比如 I2C 总线的 SDA、SCL 引脚（复用为 I2C 外设的开漏输出）、SPI 总线的 MISO 引脚（部分场景复用为开漏输出）、UART 的 CTS/RTS 引脚（开漏模式）。</p>
<p>​<strong>与普通开漏输出的区别</strong>​：控制主体不同——普通开漏输出由软件控制 GPIO 寄存器，复用开漏输出由内部外设控制；功能用途不同——复用输出用于实现外设的特定功能，普通输出用于软件直接控制电平。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA9 引脚为例，复用为 UART1_TX，开漏输出）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_usart.h"</span></span>

<span class="hljs-comment">// 复用开漏输出模式配置（PA9，复用为UART1_TX）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AF_OpenDrainOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和UART1时钟（复用外设需同时使能GPIO和外设时钟）</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA9为复用开漏输出模式（UART1_TX复用功能）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;          <span class="hljs-comment">// 选择PA9引脚（UART1_TX对应引脚）</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;    <span class="hljs-comment">// 复用开漏输出（AF_OD = Alternate Function Open Drain）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（PA9外接上拉电阻，确保高电平输出）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 4. 初始化UART1（复用功能核心：配置外设，控制GPIO输出）</span>
    USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;         <span class="hljs-comment">// 波特率9600</span>
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; <span class="hljs-comment">// 8位数据位</span>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;     <span class="hljs-comment">// 1位停止位</span>
    USART_InitStructure.USART_Parity = USART_Parity_No;        <span class="hljs-comment">// 无校验位</span>
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="hljs-comment">// 无硬件流控</span>
    USART_InitStructure.USART_Mode = USART_Mode_Tx;            <span class="hljs-comment">// 仅发送模式</span>
    USART_Init(USART1, &amp;USART_InitStructure);
    
    <span class="hljs-comment">// 5. 使能UART1</span>
    USART_Cmd(USART1, ENABLE);
}

<span class="hljs-comment">// 复用开漏输出发送数据（示例：UART发送字符）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">USART_SendChar_AF_OD</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ch)</span>
{
    <span class="hljs-comment">// 等待发送缓冲区为空</span>
    <span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    <span class="hljs-comment">// 发送一个字符（由UART外设控制PA9输出电平）</span>
    USART_SendData(USART1, ch);
}
</code></pre>
<p>关键：<code>GPIO_Mode_AF_OD</code> 对应复用开漏输出，需同时初始化 GPIO 和对应外设（如 UART），GPIO 电平由外设控制，非软件直接操作。</p>
<h3 data-id="heading-11">4. 复用推挽输出（Alternate Function Push-Pull Output）</h3>
<p>​<strong>核心定义</strong>​：与复用开漏输出类似，GPIO 引脚的输出控制权交由内部外设控制，输出驱动方式为推挽输出，无需外部电阻，可主动输出高电平和低电平。</p>
<p>​<strong>工作原理</strong>​：引脚复用为外设功能后，电平输出由外设（如 UART、SPI、定时器）决定，驱动逻辑与普通推挽输出一致——通过两个互补 MOS 管，主动输出高电平和低电平，驱动能力强。</p>
<p>​<strong>实战场景</strong>​：外设需要推挽输出特性的场景，比如 UART 的 TX 引脚（复用为串口外设，推挽输出 TTL 电平）、SPI 的 MOSI、SCK 引脚（复用为 SPI 外设，推挽输出）、定时器的 PWM 输出引脚（复用为定时器外设，推挽输出 PWM 波形）。</p>
<p>​<strong>关键注意</strong>​：复用输出模式下，软件不能再通过 GPIO 寄存器控制引脚电平，否则会与外设控制冲突，导致功能异常；需先配置 GPIO 为对应复用功能，再初始化外设。</p>
<p>以下是 STM32F103 标准库下，该模式的 GPIO 配置代码示例（以 PA9 引脚为例，复用为 UART1_TX，推挽输出）：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_gpio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x_usart.h"</span></span>

<span class="hljs-comment">// 复用推挽输出模式配置（PA9，复用为UART1_TX）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">GPIO_AF_PushPullOutput_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    <span class="hljs-comment">// 1. 使能GPIOA和UART1时钟</span>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
    
    <span class="hljs-comment">// 2. 配置PA9为复用推挽输出模式（UART1_TX复用功能）</span>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;          <span class="hljs-comment">// 选择PA9引脚（UART1_TX对应引脚）</span>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    <span class="hljs-comment">// 复用推挽输出（AF_PP = Alternate Function Push Pull）</span>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 输出速度50MHz</span>
    
    <span class="hljs-comment">// 3. 初始化GPIOA（无需外接电阻，推挽输出可主动输出高低电平）</span>
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    
    <span class="hljs-comment">// 4. 初始化UART1（外设控制GPIO输出）</span>
    USART_InitStructure.USART_BaudRate = <span class="hljs-number">9600</span>;         <span class="hljs-comment">// 波特率9600</span>
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; <span class="hljs-comment">// 8位数据位</span>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;     <span class="hljs-comment">// 1位停止位</span>
    USART_InitStructure.USART_Parity = USART_Parity_No;        <span class="hljs-comment">// 无校验位</span>
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="hljs-comment">// 无硬件流控</span>
    USART_InitStructure.USART_Mode = USART_Mode_Tx;            <span class="hljs-comment">// 仅发送模式</span>
    USART_Init(USART1, &amp;USART_InitStructure);
    
    <span class="hljs-comment">// 5. 使能UART1</span>
    USART_Cmd(USART1, ENABLE);
}

<span class="hljs-comment">// 复用推挽输出发送数据（示例：UART发送字符串）</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">USART_SendString_AF_PP</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *str)</span>
{
    <span class="hljs-keyword">while</span>(*str != <span class="hljs-string">'\0'</span>)
    {
        <span class="hljs-comment">// 等待发送缓冲区为空</span>
        <span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
        <span class="hljs-comment">// 发送一个字符（由UART外设控制PA9输出）</span>
        USART_SendData(USART1, *str);
        str++;
    }
}
</code></pre>
<p>关键：<code>GPIO_Mode_AF_PP</code> 对应复用推挽输出，是最常用的复用模式，无需外接电阻，外设可直接控制 GPIO 主动输出高低电平，适配 UART、SPI 等多数外设。</p>
<h2 data-id="heading-12">四、核心对比与实战选型指南（必看）</h2>
<p>为了方便大家快速选型，避免踩坑，这里整理了八种模式的核心对比和选型技巧，结合实际开发场景总结，直接套用即可。</p>



























































<table><thead><tr><th>模式类型</th><th>核心特点</th><th>典型应用</th><th>关键注意</th></tr></thead><tbody><tr><td>浮空输入</td><td>高阻抗，无固定电平，由外部决定</td><td>外部有固定电平的信号检测（如串口 RX）</td><td>避免单独用于无外部电平的场景</td></tr><tr><td>上拉输入</td><td>内部上拉，默认高电平，外部可拉低</td><td>按键检测、NPN 型传感器</td><td>无需外部上拉电阻</td></tr><tr><td>下拉输入</td><td>内部下拉，默认低电平，外部可拉高</td><td>PNP 型传感器、高电平触发信号</td><td>与上拉输入根据电平极性选择</td></tr><tr><td>模拟输入</td><td>断开数字缓冲，接入 ADC，采集模拟量</td><td>电位器、温度/湿度/光照传感器</td><td>仅支持 ADC 引脚，避免接强电</td></tr><tr><td>开漏输出</td><td>仅能主动输出低电平，需外部上拉</td><td>I2C 总线、线与功能、共阳极 LED</td><td>必须外接上拉电阻</td></tr><tr><td>推挽输出</td><td>主动输出高低电平，驱动能力强</td><td>LED、串口 TX、小型继电器</td><td>不可多引脚直接连接</td></tr><tr><td>复用开漏输出</td><td>外设控制，开漏驱动，需外部上拉</td><td>I2C_SDA/SCL、SPI_MISO</td><td>软件不可控制 GPIO 电平</td></tr><tr><td>复用推挽输出</td><td>外设控制，推挽驱动，无需外部电阻</td><td>UART_TX、SPI_MOSI、PWM 输出</td><td>先配置复用功能，再初始化外设</td></tr></tbody></table>
<h3 data-id="heading-13">选型核心技巧</h3>
<ul>
<li>输入场景：无外部电平 → 上拉/下拉输入；有外部电平 → 浮空输入；需采集模拟量 → 模拟输入。</li>
<li>输出场景：直接驱动中小电流 → 推挽输出；需线与/总线通信 → 开漏输出；外设功能 → 复用推挽/开漏输出（匹配外设需求）。</li>
<li>复用输出：先确定外设的输出驱动方式（如 I2C 用开漏，UART 用推挽），再配置 GPIO 为对应复用模式。</li>
</ul>
<h2 data-id="heading-14">五、总结</h2>
<p>GPIO 的八种工作模式，本质是“输入/输出”和“驱动方式/控制主体”的组合。输入模式的核心是“如何稳定接收外部信号”，输出模式的核心是“如何高效、稳定地向外部发送信号”，复用模式则是“将 GPIO 交给外设，实现更复杂的功能”。</p>
<p>对于嵌入式开发者而言，吃透这八种模式，不仅能简化电路设计、避免开发踩坑，更能根据实际项目需求，选择最适合的 GPIO 模式，提升设备的稳定性和可靠性。比如，同样是按键检测，上拉输入比浮空输入更稳定；同样是总线通信，开漏输出比推挽输出更合适。</p>
<p>建议大家在实际开发中，结合单片机 datasheet，对照每种模式的配置方法，亲手调试（比如用推挽输出驱动 LED，用上拉输入检测按键，用开漏输出模拟 I2C 通信），只有实践才能真正掌握其中的精髓。</p>
<p>后续我会结合具体单片机（如 STM32、51 单片机），分享八种模式的具体配置代码和实战案例，感兴趣的可以关注后续更新~</p>
<p>可关注我的博客：<a href="https://link.juejin.cn?target=https%3A%2F%2F" target="_blank" title="https://" ref="nofollow noopener noreferrer">blog.csdn.net/qq_30095907…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Redis 做分布式 Session]]></title>    <link>https://juejin.cn/post/7604037348608360486</link>    <guid>https://juejin.cn/post/7604037348608360486</guid>    <pubDate>2026-02-09T01:15:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604037348608360486" data-draft-id="7602464510607212570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Redis 做分布式 Session"/> <meta itemprop="keywords" content="后端,Spring Cloud,微服务"/> <meta itemprop="datePublished" content="2026-02-09T01:15:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MrSYJ"/> <meta itemprop="url" content="https://juejin.cn/user/2752832848799726"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Redis 做分布式 Session
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2752832848799726/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MrSYJ
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:15:07.000Z" title="Mon Feb 09 2026 01:15:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>最近在用SAS做授权服务器，默认授权服务器的session是基于tomcat服务器的，但是如果你的 SAS 部署了多台实例（集群），该怎么办呢？比如用户在 A 机器登录，确认授权时请求落到了 B 机器，B 找不到 Session 就会让用户重新登录。没有 Redis，SAS 很难做集群部署，也无法提供稳定的单点登录（SSO）体验。</p>
<h2 data-id="heading-1">需要引入的依赖</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h2 data-id="heading-2">将session保存到redis的原理</h2>
<p>首先我们要明白一点,session的创建是是依赖<code>HttpServletRequest.getSession()</code>,但是直接调用就是创建本地session，所以框架就必须偷梁换柱。Spring Session就是利用了 Filter 模式，通过装饰器模式（Decorator Pattern）包装了原始的 Request 对象。那这个核心过滤器组件就是<code>SessionRepositoryFilter</code>。</p>
<p><code>SessionRepositoryFilter</code> 见名知意负责session持久化的过滤器。</p>
<p>过滤器源码：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec7bf3f6bdc2451d805c88cd732f8526~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=YUVbRZXJei2c790cV2ie5cYD074%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><code>SessionRepositoryFilter</code> 会率先拦截到这个请求。</p>
</li>
<li>
<p>它并不会直接把原始的 <code>HttpServletRequest</code> 传给后面的 Controller。</p>
</li>
</ul>
<p>它创建了两个包装类：</p>
<ul>
<li><strong><code>SessionRepositoryRequestWrapper</code></strong>: 继承自 <code>HttpServletRequestWrapper</code>。</li>
<li><strong><code>SessionRepositoryResponseWrapper</code></strong>: 继承自 <code>HttpServletResponseWrapper</code>。</li>
</ul>
<p>重点是它重写了包装类中的<strong>getSession()</strong> 方法</p>
<p>当你运行 <code>request.getSession()</code> 时，实际上运行的是包装类里的方法.</p>
<p><strong>不再去 Tomcat 的内存里找</strong>，而是去 <code>SessionRepository</code>（对于你来说就是 <code>RedisIndexedSessionRepository</code>）里找</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8058139018eb4b7dbc604b1ba449762b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=eBwaNcKtpdT4D9VobxRBADGlNE0%3D" alt="image.png" loading="lazy"/></p>
<p>如上图 spring在构建SessionRepositoryFilter过滤器的时候，注入的就是RedisIndexedSessionRepository。专门负责session的增删改查。</p>
<p>SessionRepository是顶级抽象接口，RedisIndexedSessionRepository实现了该接口</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d97f5d7524d44466b440a75a9b0de34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=cInxyc8leq645XGROBWODZkWpv0%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">包装类的getsession方法</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b47fbddec14e95b3797de365963a2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=jBC5ZID744mtKcY6sGRq2OS%2Bkag%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3b05c4304ef4e82838cef37f89c1204~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=kYDOEBfiHUb2QRDZaq9Evw6m7h0%3D" alt="image.png" loading="lazy"/></p>
<p>上面是getsession包装后的源码，我把重要的代码标记出来了，我们一步一步分析。</p>
<h3 data-id="heading-4">首先是getCurrentSession</h3>
<p>它的本次是请求内缓存，<code>SessionRepositoryFilter</code> 包装了 Request。在同一个 HTTP 请求的整个生命周期内（从进入 Filter 到 Controller 再到 Filter 出去），你可能会多次调用 <code>request.getSession()</code>。</p>
<p>为了性能考虑，Spring Session 没必要每次调用 <code>getSession()</code> 都去查一遍 Redis。所以：</p>
<ul>
<li><strong>第一次调用 <code>getSession()</code></strong> ：会去执行 <code>getRequestedSession()</code>（查 Redis/Cookie），查到后把结果存入 Request 的一个内部属性（Attribute）里。</li>
<li><strong>第二次及以后调用</strong>：<code>getCurrentSession()</code> 就能直接从 Request 属性里把刚才那个对象拿出来。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">HttpSessionWrapper <span class="hljs-attr">currentSession</span> = getCurrentSession()<span class="hljs-comment">;</span>
if (currentSession != null) {
   return currentSession<span class="hljs-comment">;</span>
}
</code></pre>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">HttpSessionWrapper</span> <span class="hljs-title function_">getCurrentSession</span>(<span class="hljs-params"/>) {
   <span class="hljs-keyword">return</span> (<span class="hljs-title class_">HttpSessionWrapper</span>) <span class="hljs-title function_">getAttribute</span>(<span class="hljs-variable constant_">CURRENT_SESSION_ATTR</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">getAttribute</span>(name);
}
</code></pre>
<p>也就是说请求第一次过来，调用request.getSession()，看看当前的 <code>HttpServletRequest</code> 对象里是不是已经有一个 <code>HttpSessionWrapper</code> 了，第一次肯定没有嘛，就会调用getRequestedSession()，真正去拿 <strong>Cookie</strong>（获取 SessionId），然后拿着 ID 去 <strong>Redis</strong> 找。 如果 Redis 找到了，就 new 一个包装类，并调用 <code>setCurrentSession()</code> 把它存到 Request 属性里</p>
<p>它就像是一个**“一级缓存”**：</p>
<ul>
<li><strong>一级缓存</strong>：<code>getCurrentSession()</code> —— 存在当前请求对象里，生命周期仅限本次请求。</li>
<li><strong>二级缓存</strong>：<code>getRequestedSession()</code> —— 存在 Redis 里，生命周期是全局的。</li>
</ul>
<p><strong>这就是为什么你在同一个 Request 里反复调用 <code>getSession()</code>，拿到的永远是同一个内存对象的原因。</strong></p>
<h3 data-id="heading-5">接下来我们看看<strong>getRequestedSession</strong></h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e904ea157a44146b595d0079681b25f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=LlsvQNPpwY6txvRjpjyPcq5eLg8%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc436212eef34528aad016b21f058251~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=hVQHR4CqEV0jkMRbhn%2B%2FFMNR2pk%3D" alt="image.png" loading="lazy"/></p>
<p>使用了<code>requestedSessionCached</code>标记，防止每次调用<code>request.getSession()</code>都会触发Redis 的 <code>HGETALL</code> 查询。也就是说如果当前已经缓存了就直接使用缓存的，如果没有缓存就去redis中看有没有。，避免了多次网络IO.</p>
<h3 data-id="heading-6">setCurrentSession</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90d7c0380991416fb84a2238095b0503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=brTIFdOtSjpRpJWIQUQF2Fn%2B0FY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8e445d94a194d4bb54db28e6ec803fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=8RmvXssFRDxW%2F16s0dyHm99cNjM%3D" alt="image.png" loading="lazy"/></p>
<p>如果从redis中查询到了当前的session，就调用<strong>setCurrentSession</strong>保存到当前请求的作用域内，这样就和第一步闭环了，第一步是先从request作用域去获取。二级缓存防止多次网络IO</p>
<h3 data-id="heading-7">createSession()</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fabd46f8393642e7b949d20f875797a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXJTWUo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771204507&amp;x-signature=PGHAtC4Rng%2BBOTxCbM9oynVD%2FJo%3D" alt="image.png" loading="lazy"/></p>
<p>也就是说如果用户没带cookie或者Cookie 里的 ID 在 Redis 里查不到，就会<code>createSession()</code> 产生一个新的 ID。存在内存中，然后调用<code>setCurrentSession()</code> 把这个新 Session 塞进 Request 的属性，绑定到请求上。供后续使用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者]]></title>    <link>https://juejin.cn/post/7603781883974664211</link>    <guid>https://juejin.cn/post/7603781883974664211</guid>    <pubDate>2026-02-09T01:16:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974664211" data-draft-id="7604084016509763625" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者"/> <meta itemprop="keywords" content="Redis"/> <meta itemprop="datePublished" content="2026-02-09T01:16:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="what丶k"/> <meta itemprop="url" content="https://juejin.cn/user/2578801884147418"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解Redis哨兵（Sentinel）原理：高可用架构的核心守护者
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2578801884147418/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    what丶k
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T01:16:09.000Z" title="Mon Feb 09 2026 01:16:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​在分布式系统中，Redis 凭借高性能、低延迟的特性成为缓存与数据存储的首选方案，但单点故障始终是制约其生产可用性的关键瓶颈。Redis 主从复制机制虽实现了数据冗余，却无法自动处理主节点故障，需手动介入切换。Redis 哨兵（Sentinel）作为官方原生的高可用解决方案，通过分布式监控、自动故障转移与配置同步，完美解决了这一痛点，成为中小规模 Redis 集群高可用架构的基石。本文将从核心定位、工作机制、故障转移流程、实战配置及生产优化等方面，全方位解析 Redis 哨兵的底层原理与实践要点。</p>
<h2 data-id="heading-0">一、哨兵的核心定位与核心功能</h2>
<p>Redis 哨兵并非独立的数据库组件，而是一套运行在独立进程中的分布式监控与治理系统，其核心使命是为 Redis 主从集群提供自动化的高可用保障。哨兵集群与 Redis 主从节点协同工作，构成完整的高可用架构，主要承担四大核心功能：</p>
<h3 data-id="heading-1">1. 持续监控（Monitoring）</h3>
<p>每个哨兵节点会以每秒一次的频率，向被监控的所有主节点、从节点及其他哨兵节点发送 <code>PING</code> 命令，通过检测是否收到有效 <code>PONG</code> 响应，判断目标节点的健康状态。这种高频心跳检测机制是故障发现的基础，确保能快速感知节点异常。</p>
<h3 data-id="heading-2">2. 故障通知（Notification）</h3>
<p>当哨兵检测到节点故障（尤其是主节点故障）时，会通过 Redis 的发布订阅（Pub/Sub）机制，向其他哨兵节点、客户端及运维系统发送通知。客户端可通过订阅哨兵频道实时获取集群状态变化，运维系统则可基于通知触发告警流程，实现故障的快速响应。</p>
<h3 data-id="heading-3">3. 自动故障转移（Automatic Failover）</h3>
<p>这是哨兵最核心的功能。当主节点被确认故障后，哨兵集群会自动执行故障转移流程：从候选从节点中选举新主节点、将其他从节点重新配置为新主节点的从节点、通知客户端更新主节点地址，全程无需人工干预，最大限度减少服务中断时间。</p>
<h3 data-id="heading-4">4. 配置提供者（Configuration Provider）</h3>
<p>哨兵作为客户端服务发现的权威来源，客户端无需硬编码主节点地址，而是通过连接哨兵集群查询当前可用的主节点地址。当故障转移发生后，哨兵会同步更新主节点信息，客户端重新查询即可获取新地址，实现连接的自动切换。</p>
<h2 data-id="heading-5">二、哨兵的分布式架构设计</h2>
<p>Redis 哨兵本身是分布式系统，而非单点进程，这一设计旨在避免哨兵自身成为新的单点故障。一套完整的哨兵架构包含三部分组件：</p>
<ul>
<li>​**主节点（Master）**​：负责处理所有写操作，同时将数据异步同步至从节点，是集群的核心数据节点。</li>
<li>​**从节点（Slave/Replica）**​：通过主从复制同步主节点数据，仅处理读操作（默认），作为主节点的冗余备份，故障时可被提升为新主节点。</li>
<li>​**哨兵节点（Sentinel）**​：独立运行的监控进程，多个哨兵节点构成集群，通过相互通信达成共识，确保故障判断与故障转移的准确性。</li>
</ul>
<h3 data-id="heading-6">分布式架构的核心优势</h3>
<ol>
<li>降低误判概率：单一哨兵节点对主节点的故障判断可能受网络分区等因素影响（如自身与主节点失联但主节点正常），多个哨兵节点通过共识机制确认故障，可有效避免误触发故障转移。</li>
<li>高可用性：即使部分哨兵节点故障，剩余正常节点仍可继续提供监控与故障转移服务，确保哨兵系统自身的稳定性。</li>
</ol>
<h3 data-id="heading-7">推荐部署方案</h3>
<p>生产环境中，哨兵节点数量建议配置为 3 个（或以上奇数个），且需部署在独立的物理机、虚拟机或不同可用区，确保哨兵节点的故障独立性。若仅部署 2 个哨兵节点，当其中一个故障时，剩余节点无法满足“多数票”条件，将导致故障转移无法执行；奇数个节点可避免投票僵局，简化共识达成流程。</p>
<h2 data-id="heading-8">三、哨兵核心工作机制深度解析</h2>
<p>哨兵的工作流程可拆解为“故障检测”“领导者选举”“故障转移”三大核心阶段，各阶段通过精密的分布式协作机制保障准确性与可靠性。</p>
<h3 data-id="heading-9">1. 故障检测：主观下线与客观下线</h3>
<p>哨兵对主节点的故障判断并非一步到位，而是分为“主观下线（SDOWN）”与“客观下线（ODOWN）”两个阶段，避免单一节点的误判。</p>
<ul>
<li>​**主观下线（SDOWN）**​：单个哨兵节点在配置的 <code>down-after-milliseconds</code> 时间内，持续未收到主节点的有效 <code>PONG</code> 响应，会将该主节点标记为“主观下线”。这是哨兵的局部判断，仅代表当前节点认为主节点故障。</li>
<li>​**客观下线（ODOWN）**​：标记主节点为主观下线后，该哨兵会向其他哨兵节点发送 <code>SENTINEL is-master-down-by-addr</code> 命令，询问其他节点对该主节点的状态判断。当超过 <code>quorum</code>（法定票数）个哨兵节点均报告该主节点主观下线时，主节点将被标记为“客观下线”，此时触发后续的领导者选举与故障转移流程。</li>
</ul>
<p>注：<code>quorum</code> 是配置参数，通过 <code>sentinel monitor</code> 命令指定，代表确认主节点客观下线所需的最小哨兵节点数，建议设置为哨兵节点总数的半数以上（如 3 个哨兵设置为 2）。</p>
<h3 data-id="heading-10">2. 领导者选举：基于 Raft 算法的共识机制</h3>
<p>当主节点被确认客观下线后，哨兵集群需选举出一个“领导者哨兵”，由其单独负责执行故障转移操作（避免多个哨兵同时发起转移导致集群混乱）。选举机制基于 Raft 算法的核心思想，流程如下：</p>
<ol>
<li>候选者发起投票：每个发现主节点客观下线的哨兵节点，会向其他哨兵节点发送投票请求，申请成为领导者。</li>
<li>投票规则：每个哨兵节点仅能投出一票，且优先投票给第一个向自己发起请求的候选者（先到先得原则）。</li>
<li>共识达成：当某个候选者获得超过半数哨兵节点的投票时，立即成为领导者；若一轮投票无候选者获得多数票，则等待超时后重新发起选举，直至选出领导者。</li>
</ol>
<p>Raft 算法的引入确保了哨兵集群在分布式环境下能快速、一致地选举出领导者，且选举过程具备安全性（同一任期内仅产生一个领导者）与活性（最终能选出领导者，无无限阻塞）。</p>
<h3 data-id="heading-11">3. 故障转移：自动化主从切换全流程</h3>
<p>领导者哨兵当选后，将按固定流程执行故障转移，整个过程可分为四步，耗时通常在秒级到十几秒级（取决于配置与集群状态）。</p>
<ol>
<li>​<strong>筛选候选从节点</strong>​：领导者哨兵会从原主节点的所有从节点中，筛选出符合条件的候选节点，筛选规则优先级如下：① 排除已标记为故障、断开连接或响应缓慢的从节点；② 优先选择 <code>slave-priority</code>（从节点优先级）配置值最高的节点（值越小优先级越高）；③ 若优先级相同，选择复制偏移量最大的节点（数据最完整，同步主节点数据最新）；④ 若偏移量相同，选择运行 ID 最小的节点（默认规则）。</li>
<li>​<strong>提升候选节点为新主节点</strong>​：领导者哨兵向筛选出的候选从节点发送 <code>SLAVEOF NO ONE</code> 命令，使其脱离从节点身份，晋升为新主节点，开始独立处理读写请求。</li>
<li>​<strong>重配置其他从节点</strong>​：领导者哨兵向剩余所有从节点发送 <code>SLAVEOF &lt;新主节点IP&gt; &lt;新主节点端口&gt;</code> 命令，让这些从节点重新同步新主节点的数据，构建新的主从复制关系。</li>
<li>​<strong>更新配置与通知</strong>​：领导者哨兵更新自身及其他哨兵节点的集群配置，将原主节点标记为新主节点的从节点（待其恢复后，自动以从节点身份同步新主节点数据）；同时通过发布订阅机制通知客户端新主节点地址，客户端更新连接信息后，即可正常访问集群。</li>
</ol>
<h2 data-id="heading-12">四、关键配置与实战要点</h2>
<p>哨兵的稳定性依赖合理的配置，核心配置项集中在 <code>sentinel.conf</code> 文件中，以下为生产环境常用配置及解读，结合 1 主 2 从 3 哨兵架构示例。</p>
<h3 data-id="heading-13">1. 核心配置项解读</h3>
<pre><code class="hljs language-hljs" lang="hljs"># 监控主节点：名称mymaster，IP192.168.1.101，端口6379，quorum=2（需2个哨兵确认下线）
sentinel monitor mymaster 192.168.1.101 6379 2

# 主观下线判定时间：5000毫秒（5秒），超时未响应则标记为主观下线
sentinel down-after-milliseconds mymaster 5000

# 故障转移超时时间：180000毫秒（3分钟），超时未完成则终止转移
sentinel failover-timeout mymaster 180000

# 故障转移时并行同步从节点数量：1（避免多从节点同时同步新主节点导致带宽拥堵）
sentinel parallel-syncs mymaster 1

# 预防脑裂配置：主节点至少需1个从节点连接，且从节点延迟≤10秒才允许写操作
min-slaves-to-write 1
min-slaves-max-lag 10
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<h3 data-id="heading-14">2. 哨兵启动方式</h3>
<p>哨兵启动需指定配置文件（否则无法保存集群状态，重启后丢失信息），两种启动方式效果一致：</p>
<pre><code class="hljs language-hljs" lang="hljs"># 方式1：通过redis-sentinel可执行文件启动
redis-sentinel /path/to/sentinel.conf

# 方式2：通过redis-server以哨兵模式启动
redis-server /path/to/sentinel.conf --sentinel
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<p>哨兵默认监听 26379 端口，需确保该端口在防火墙中开放，允许其他哨兵节点与客户端访问。</p>
<h3 data-id="heading-15">3. 客户端接入方式</h3>
<p>客户端需支持哨兵协议（主流客户端如 Jedis、Lettuce 均支持），通过连接哨兵集群获取主节点地址，而非直接连接主节点。以 Jedis 为例：</p>
<pre><code class="hljs language-hljs" lang="hljs">Set&lt;String&gt; sentinelSet = new HashSet&lt;&gt;();
sentinelSet.add("192.168.1.201:26379"); // 哨兵节点1
sentinelSet.add("192.168.1.202:26379"); // 哨兵节点2
sentinelSet.add("192.168.1.203:26379"); // 哨兵节点3

// 连接哨兵集群，指定主节点名称mymaster
JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinelSet);
Jedis jedis = pool.getResource(); // 自动获取当前可用主节点连接
</code></pre>
<p><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/></p>
<p>客户端会定期向哨兵集群查询主节点地址，故障转移后自动切换至新主节点，实现业务无感知。</p>
<h2 data-id="heading-16">五、生产环境常见问题与优化方案</h2>
<p>哨兵架构虽能保障高可用，但在生产环境中仍需规避常见陷阱，通过优化配置提升稳定性与性能。</p>
<h3 data-id="heading-17">1. 脑裂问题（Split-Brain）</h3>
<p>问题场景：网络分区导致原主节点与哨兵、从节点失联，但原主节点仍正常运行。哨兵集群触发故障转移，提升新主节点；当网络恢复后，集群中出现两个主节点（原主、新主），即“脑裂”，导致数据不一致。</p>
<p>解决方案：通过配置 <code>min-slaves-to-write</code> 与 <code>min-slaves-max-lag</code> 限制原主节点的写权限。当原主节点连接的从节点数量不足或延迟过高时，自动拒绝写操作，避免脑裂期间的数据写入冲突。</p>
<h3 data-id="heading-18">2. 故障转移期间数据丢失</h3>
<p>问题原因：Redis 主从复制为异步机制，主节点故障时，部分已写入主节点的数据可能未同步至从节点，故障转移后这部分数据将丢失。</p>
<p>优化方案：① 开启主节点持久化（<code>appendonly yes</code>），避免主节点重启后数据丢失；② 合理设置 <code>min-slaves-max-lag</code>，减少主从数据延迟；③ 对核心业务数据，可通过客户端确认机制（如 <code>WAIT</code> 命令）确保数据同步至指定数量从节点后再返回成功。</p>
<h3 data-id="heading-19">3. 故障转移时间过长</h3>
<p>问题表现：默认配置下，故障转移总耗时可能达 30 秒以上，导致服务短暂不可用。</p>
<p>优化方案：调小 <code>down-after-milliseconds</code>（如 5000 毫秒），缩短主观下线判定时间；调小 <code>failover-timeout</code>，加快故障转移超时重试速度。但需注意，<code>down-after-milliseconds</code> 不宜过小，避免网络抖动触发误判。</p>
<h3 data-id="heading-20">4. 哨兵节点单点故障风险</h3>
<p>问题场景：哨兵节点部署在同一物理机或可用区，当该区域故障时，所有哨兵节点失效，无法执行故障检测与转移。</p>
<p>解决方案：哨兵节点分散部署在不同物理机、虚拟机或可用区，确保故障独立性；同时监控哨兵节点状态，及时替换故障节点。</p>
<h2 data-id="heading-21">六、哨兵与 Redis Cluster 的区别与选型建议</h2>
<p>Redis Cluster 是 Redis 官方提供的分片集群方案，与哨兵架构均能实现高可用，但适用场景存在差异，需根据业务需求选型。</p>






























<table><thead><tr><th>对比维度</th><th>Redis Sentinel</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>架构核心</td><td>基于主从复制，无数据分片</td><td>数据分片 + 主从复制，分布式存储</td></tr><tr><td>扩展性</td><td>不支持数据分片，仅可扩展从节点提升读性能</td><td>支持横向扩展节点，突破单节点内存限制</td></tr><tr><td>适用场景</td><td>中小规模集群，数据量不大，需高可用与读写分离</td><td>大规模集群，数据量庞大，需分片存储与水平扩展</td></tr><tr><td>复杂度</td><td>架构简单，配置与维护成本低</td><td>架构复杂，需处理分片路由、数据迁移等问题</td></tr></tbody></table>
<p>选型建议：若业务数据量较小（单节点可承载），追求高可用与简单维护，优先选择哨兵架构；若数据量庞大，需突破单节点性能与内存限制，选择 Redis Cluster。</p>
<h2 data-id="heading-22">七、总结</h2>
<p>Redis 哨兵通过“分布式监控 + 共识机制 + 自动故障转移”，为 Redis 主从集群构建了可靠的高可用保障，其核心价值在于将故障处理从人工介入转化为自动化流程，大幅提升系统的稳定性与运维效率。深入理解哨兵的主观/客观下线机制、Raft 领导者选举、故障转移流程，是做好生产环境部署与优化的关键。</p>
<p>需注意，哨兵并非“银弹”，生产环境中需结合业务场景合理配置参数、规避脑裂与数据丢失风险、做好节点分散部署，同时配合持久化、监控告警等机制，才能构建真正稳定的高可用 Redis 集群。对于中小规模业务而言，哨兵架构兼具简单性与可靠性，是平衡成本与可用性的最优选择。</p>
<p>关注我的CSDN：<a href="https://link.juejin.cn?target=https%3A%2F%2F" target="_blank" title="https://" ref="nofollow noopener noreferrer">blog.csdn.net/qq_30095907…</a></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[嵌入式处理器架构]]></title>    <link>https://juejin.cn/post/7603959423128584192</link>    <guid>https://juejin.cn/post/7603959423128584192</guid>    <pubDate>2026-02-09T02:14:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603959423128584192" data-draft-id="7603677143215931407" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="嵌入式处理器架构"/> <meta itemprop="keywords" content="后端,嵌入式,单片机"/> <meta itemprop="datePublished" content="2026-02-09T02:14:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员良许"/> <meta itemprop="url" content="https://juejin.cn/user/3913917128246942"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            嵌入式处理器架构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917128246942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员良许
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:14:38.000Z" title="Mon Feb 09 2026 02:14:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是良许。</p>
<p>在嵌入式开发的这些年里，我接触过各种各样的处理器架构，从最早做单片机时用的 51 内核，到后来做汽车电子时用的 ARM Cortex-A 系列，再到现在项目中偶尔会碰到的 RISC-V 架构。</p>
<p>每次换一个新架构，都需要重新熟悉它的特性和开发方式。</p>
<p>今天就和大家聊聊嵌入式处理器架构这个话题，帮助大家建立一个系统的认知框架。</p>
<h2 data-id="heading-0">1. 什么是处理器架构</h2>
<p>处理器架构，简单来说就是处理器的设计蓝图和规范。</p>
<p>它定义了处理器如何执行指令、如何管理内存、如何与外设交互等一系列核心问题。</p>
<p>就像盖房子需要先有建筑设计图纸一样，处理器的制造也需要先有架构设计。</p>
<p>从技术角度来看，处理器架构主要包含以下几个方面：</p>
<p><strong>1.1 指令集架构（ISA）</strong></p>
<p>指令集架构是处理器架构的核心，它定义了处理器能够识别和执行的所有指令。</p>
<p>比如 ARM 架构有自己的指令集，x86 架构也有自己的指令集，它们是完全不同的。</p>
<p>这就像不同的语言一样，说中文的人听不懂英文，反之亦然。</p>
<p>在我刚开始做嵌入式开发的时候，用的是 51 单片机，它的指令集非常简单，只有几十条指令。</p>
<p>后来转到 ARM 平台，发现 ARM 的指令集要复杂得多，但也更加强大和灵活。</p>
<p><strong>1.2 寄存器组织</strong></p>
<p>寄存器是处理器内部用于临时存储数据的高速存储单元。</p>
<p>不同的架构有不同数量和类型的寄存器。</p>
<p>比如 ARM Cortex-M 系列有 16 个通用寄存器，而 x86 架构的寄存器组织方式就完全不同。</p>
<p><strong>1.3 内存管理</strong></p>
<p>处理器如何访问和管理内存也是架构的重要组成部分。</p>
<p>有些架构支持虚拟内存管理单元（MMU），有些只支持内存保护单元（MPU），还有些什么都不支持。</p>
<p>这直接影响到系统能否运行复杂的操作系统。</p>
<p><strong>1.4 流水线和执行单元</strong></p>
<p>现代处理器通常采用流水线技术来提高执行效率。</p>
<p>不同架构的流水线级数、执行单元数量和组织方式都不相同，这直接影响到处理器的性能表现。</p>
<h2 data-id="heading-1">2. 主流嵌入式处理器架构</h2>
<h3 data-id="heading-2">2.1 ARM 架构</h3>
<p>ARM 架构可以说是嵌入式领域的绝对霸主，市场占有率超过 90%。</p>
<p>我在外企做汽车电子的时候，用的就是 ARM Cortex-A 系列处理器。</p>
<p>ARM 架构的成功主要得益于其低功耗、高性能和良好的生态系统。</p>
<p>ARM 架构主要分为以下几个系列：</p>
<p><strong>2.1.1 ARM Cortex-M 系列</strong></p>
<p>这是专门为微控制器（MCU）设计的系列，主打低功耗和实时性。</p>
<p>我们常用的 STM32 就是基于 Cortex-M 内核的。</p>
<p>比如 STM32F103 使用的是 Cortex-M3 内核，STM32F407 使用的是 Cortex-M4 内核（带 DSP 指令和浮点运算单元）。</p>
<p>下面是一个简单的 STM32 HAL 库示例，展示如何初始化 GPIO：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment">#include "stm32f4xx_hal.h"</span>
​
void GPIO_Init_Example(void)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    /* 使能GPIOA时钟 */
    __HAL_RCC_GPIOA_CLK_ENABLE()<span class="hljs-comment">;</span>
    
    /* 配置PA5引脚为输出模式 */
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = GPIO_PIN_5<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;  // 推挽输出</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;          // 无上下拉</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_LOW<span class="hljs-comment">; // 低速</span>
    
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    /* 点亮LED */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET)<span class="hljs-comment">;</span>
}
</code></pre>
<p><strong>2.1.2 ARM Cortex-A 系列</strong></p>
<p>这是为应用处理器设计的系列，性能强大，支持运行 Linux 等复杂操作系统。</p>
<p>我在外企做的汽车娱乐系统就是基于 Cortex-A9 的处理器，运行的是定制版的 Linux 系统。</p>
<p>这类处理器通常主频在几百 MHz 到几 GHz 之间，支持 MMU、多核心等高级特性。</p>
<p><strong>2.1.3 ARM Cortex-R 系列</strong></p>
<p>这是为实时系统设计的系列，介于 M 系列和 A 系列之间。</p>
<p>主要用于对实时性要求极高的场合，比如汽车的安全系统、工业控制等。</p>
<h3 data-id="heading-3">2.2 x86/x64 架构</h3>
<p>x86 架构主要由 Intel 和 AMD 主导，在 PC 和服务器领域占据统治地位。</p>
<p>虽然在传统嵌入式领域应用不多，但在工业 PC、边缘计算等场景中也有一定的应用。</p>
<p>x86 架构的特点是性能强大、生态成熟，但功耗相对较高。</p>
<p>Intel 推出的 Atom 系列处理器就是专门针对嵌入式和移动设备的低功耗版本。</p>
<p>我见过一些工业控制系统使用 x86 架构的嵌入式主板，主要是因为需要运行一些只有 x86 版本的专业软件。</p>
<h3 data-id="heading-4">2.3 RISC-V 架构</h3>
<p>RISC-V 是近年来异军突起的开源指令集架构，由加州大学伯克利分校开发。</p>
<p>它最大的特点就是完全开源，任何人都可以免费使用，不需要支付授权费用。</p>
<p>RISC-V 采用模块化设计，基础指令集非常精简，只有 40 多条指令，然后可以根据需要添加各种扩展模块。</p>
<p>这种设计理念非常适合定制化需求强烈的嵌入式应用。</p>
<p>虽然 RISC-V 目前的生态还不如 ARM 成熟，但发展势头非常迅猛。</p>
<p>国内很多芯片厂商都在积极布局 RISC-V，比如平头哥、芯来科技等。</p>
<p>我最近也在关注 RISC-V 的发展，考虑在一些新项目中尝试使用。</p>
<h3 data-id="heading-5">2.4 MIPS 架构</h3>
<p>MIPS 架构曾经在嵌入式领域占有一席之地，特别是在网络设备和消费电子产品中。</p>
<p>但近年来市场份额逐渐被 ARM 蚕食。</p>
<p>MIPS 的特点是指令集简洁、流水线效率高，但生态系统相对薄弱。</p>
<h3 data-id="heading-6">2.5 其他架构</h3>
<p>除了上述主流架构，还有一些专用或小众架构，比如：</p>
<ul>
<li><strong>PowerPC 架构</strong>：主要用于航空航天、工业控制等高可靠性领域</li>
<li><strong>AVR 架构</strong>：Arduino 使用的就是 AVR 内核的单片机</li>
<li><strong>8051 架构</strong>：虽然古老，但在一些简单应用中仍然活跃</li>
<li><strong>DSP 架构</strong>：专门用于数字信号处理的架构，如 TI 的 C2000 系列</li>
</ul>
<h2 data-id="heading-7">3. 处理器架构的关键特性</h2>
<h3 data-id="heading-8">3.1 RISC vs CISC</h3>
<p>处理器架构从指令集设计理念上可以分为 RISC（精简指令集）和 CISC（复杂指令集）两大类。</p>
<p><strong>RISC 架构</strong>的特点是指令数量少、指令格式统一、每条指令执行时间固定。</p>
<p>ARM、RISC-V、MIPS 都属于 RISC 架构。</p>
<p>RISC 架构的优势是设计简单、功耗低、容易实现流水线，非常适合嵌入式应用。</p>
<p><strong>CISC 架构</strong>的特点是指令数量多、指令功能复杂、指令长度可变。</p>
<p>x86 就是典型的 CISC 架构。</p>
<p>CISC 架构的优势是代码密度高、功能强大，但设计复杂、功耗较高。</p>
<p>在实际开发中，我发现 RISC 架构的处理器通常更容易上手，汇编代码也更容易理解。</p>
<p>比如 ARM 的汇编代码就比 x86 的汇编代码简洁很多。</p>
<h3 data-id="heading-9">3.2 位宽</h3>
<p>处理器的位宽指的是处理器一次能处理的数据位数。</p>
<p>常见的有 8 位、16 位、32 位和 64 位。</p>
<ul>
<li><strong>8 位处理器</strong>：如 8051、AVR，适合简单控制应用</li>
<li><strong>16 位处理器</strong>：如 MSP430，性能和功耗的平衡点</li>
<li><strong>32 位处理器</strong>：如 ARM Cortex-M、STM32，目前嵌入式主流</li>
<li><strong>64 位处理器</strong>：如 ARM Cortex-A53/A72，用于高性能应用</li>
</ul>
<p>位宽越大，处理器能够直接处理的数据范围就越大，寻址空间也越大。</p>
<p>但位宽增加也会带来功耗和成本的增加。</p>
<p>在实际项目中，需要根据应用需求选择合适的位宽。</p>
<p>我在做单片机项目的时候，发现 32 位处理器已经成为主流选择。</p>
<p>即使是一些简单的应用，也倾向于使用 32 位 MCU，因为价格已经降到了可以接受的范围，而且开发效率更高。</p>
<h3 data-id="heading-10">3.3 主频和性能</h3>
<p>处理器的主频（时钟频率）是衡量性能的重要指标之一，但不是唯一指标。</p>
<p>同样主频的不同架构处理器，性能可能相差很大。</p>
<p>在嵌入式系统中，我们通常使用 DMIPS（Dhrystone MIPS）或 CoreMark 来衡量处理器的实际性能。</p>
<p>比如 ARM Cortex-M4 在 100MHz 主频下，性能大约是 125 DMIPS。</p>
<p>下面是一个简单的性能测试代码示例：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment">#include "stm32f4xx_hal.h"</span>
<span class="hljs-comment">#include &lt;stdio.h&gt;</span>
​
<span class="hljs-comment">#define TEST_ITERATIONS 1000000</span>
​
void Performance_Test(void)
{
    uint32_t start_tick, end_tick<span class="hljs-comment">;</span>
    volatile uint32_t <span class="hljs-attr">result</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    
    /* 记录开始时间 */
    <span class="hljs-attr">start_tick</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    /* 执行测试循环 */
    for(uint32_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; TEST_ITERATIONS; i++)</span>
    {
        result += i * 2<span class="hljs-comment">;</span>
        result <span class="hljs-attr">-</span>= i / <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    }
    
    /* 记录结束时间 */
    <span class="hljs-attr">end_tick</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    /* 计算执行时间 */
    uint32_t <span class="hljs-attr">elapsed_time</span> = end_tick - start_tick<span class="hljs-comment">;</span>
    
    printf("Test completed in %lu ms\n", elapsed_time)<span class="hljs-comment">;</span>
    printf("Result: %lu\n", result)<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-11">3.4 功耗特性</h3>
<p>功耗是嵌入式系统设计中非常重要的考虑因素，特别是对于电池供电的设备。</p>
<p>不同架构的处理器在功耗方面差异很大。</p>
<p>ARM Cortex-M 系列在低功耗方面做得非常出色，支持多种低功耗模式：</p>
<ul>
<li><strong>Sleep 模式</strong>：CPU 停止，外设继续运行</li>
<li><strong>Stop 模式</strong>：CPU 和大部分外设停止，保持 RAM 数据</li>
<li><strong>Standby 模式</strong>：仅保持备份寄存器和 RTC，功耗最低</li>
</ul>
<p>下面是一个进入低功耗模式的示例：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#include</span> "stm32f4xx_hal<span class="hljs-selector-class">.h</span>"
​
void <span class="hljs-built_in">Enter_Sleep_Mode</span>(void)
{
    <span class="hljs-comment">/* 挂起SysTick中断 */</span>
    <span class="hljs-built_in">HAL_SuspendTick</span>();
    
    <span class="hljs-comment">/* 进入Sleep模式 */</span>
    <span class="hljs-built_in">HAL_PWR_EnterSLEEPMode</span>(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
    
    <span class="hljs-comment">/* 从Sleep模式唤醒后恢复SysTick */</span>
    <span class="hljs-built_in">HAL_ResumeTick</span>();
}
​
void <span class="hljs-built_in">Enter_Stop_Mode</span>(void)
{
    <span class="hljs-comment">/* 使能PWR时钟 */</span>
    <span class="hljs-built_in">__HAL_RCC_PWR_CLK_ENABLE</span>();
    
    <span class="hljs-comment">/* 挂起SysTick中断 */</span>
    <span class="hljs-built_in">HAL_SuspendTick</span>();
    
    <span class="hljs-comment">/* 进入Stop模式 */</span>
    <span class="hljs-built_in">HAL_PWR_EnterSTOPMode</span>(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    
    <span class="hljs-comment">/* 从Stop模式唤醒后重新配置系统时钟 */</span>
    <span class="hljs-built_in">SystemClock_Config</span>();
    
    <span class="hljs-comment">/* 恢复SysTick */</span>
    <span class="hljs-built_in">HAL_ResumeTick</span>();
}
</code></pre>
<h3 data-id="heading-12">3.5 中断系统</h3>
<p>中断系统是嵌入式处理器的重要组成部分。</p>
<p>不同架构的中断系统设计差异很大。</p>
<p>ARM Cortex-M 系列使用 NVIC（嵌套向量中断控制器），支持多达 240 个中断源，每个中断可以配置 16 个优先级。</p>
<p>这种设计非常灵活，能够满足复杂应用的需求。</p>
<p>在实际开发中，合理配置中断优先级非常重要。</p>
<p>我的经验是：</p>
<ul>
<li>高优先级：给时间敏感的任务，如通信协议的超时处理</li>
<li>中优先级：给普通外设中断，如串口接收、定时器</li>
<li>低优先级：给不太紧急的任务，如按键扫描</li>
</ul>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-id">#include</span> "stm32f4xx_hal<span class="hljs-selector-class">.h</span>"
​
void <span class="hljs-built_in">NVIC_Config_Example</span>(void)
{
    <span class="hljs-comment">/* 配置USART1中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(USART1_IRQn, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 抢占优先级1，子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(USART1_IRQn);
    
    <span class="hljs-comment">/* 配置TIM2中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(TIM2_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 抢占优先级2，子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(TIM2_IRQn);
    
    <span class="hljs-comment">/* 配置外部中断优先级 */</span>
    <span class="hljs-built_in">HAL_NVIC_SetPriority</span>(EXTI0_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 抢占优先级0（最高），子优先级0</span>
    <span class="hljs-built_in">HAL_NVIC_EnableIRQ</span>(EXTI0_IRQn);
}
</code></pre>
<h2 data-id="heading-13">4. 如何选择合适的处理器架构</h2>
<p>在实际项目中，选择合适的处理器架构需要综合考虑多个因素：</p>
<p><strong>4.1 应用需求</strong></p>
<p>首先要明确应用的具体需求。</p>
<p>如果只是简单的控制任务，8 位或 16 位 MCU 就足够了。</p>
<p>如果需要运行复杂的算法或操作系统，就需要 32 位甚至 64 位的处理器。</p>
<p>我在做汽车电子项目的时候，因为需要运行 Linux 系统并处理大量的多媒体数据，所以选择了 ARM Cortex-A 系列的处理器。</p>
<p>而在做一些简单的传感器节点时，使用 STM32F103 这样的 Cortex-M3 就完全够用。</p>
<p><strong>4.2 性能要求</strong></p>
<p>要根据实际的计算量来选择处理器性能。</p>
<p>过高的性能会造成成本和功耗的浪费，过低的性能又无法满足需求。</p>
<p>一个实用的方法是：先估算应用的计算量，然后选择性能略高于需求的处理器，留出一定的余量。</p>
<p>我的经验是留出 30% 左右的性能余量比较合适。</p>
<p><strong>4.3 功耗限制</strong></p>
<p>对于电池供电的设备，功耗是首要考虑因素。</p>
<p>需要选择支持低功耗模式的处理器，并在软件设计时充分利用这些特性。</p>
<p><strong>4.4 开发生态</strong></p>
<p>开发工具链、软件库、技术支持等生态因素也很重要。</p>
<p>ARM 架构在这方面具有明显优势，有大量的开发工具和参考资料可用。</p>
<p><strong>4.5 成本因素</strong></p>
<p>处理器的成本包括芯片价格、开发成本、授权费用等。对于大批量产品，即使每颗芯片节省几毛钱，总体也能节省很大一笔费用。</p>
<p><strong>4.6 长期供货</strong></p>
<p>嵌入式产品的生命周期通常很长，需要考虑处理器的长期供货能力。</p>
<p>一些老牌厂商如 ST、NXP 通常能保证 10 年以上的供货周期。</p>
<h2 data-id="heading-14">5. 处理器架构的发展趋势</h2>
<h3 data-id="heading-15">5.1 异构多核</h3>
<p>现代嵌入式处理器越来越多地采用异构多核设计，即在一颗芯片上集成不同类型的处理器核心。</p>
<p>比如 ARM 的 big.LITTLE 架构，同时包含高性能核心和低功耗核心，根据负载动态切换。</p>
<p>在汽车电子领域，我见过一些芯片同时集成 Cortex-A 核心（运行 Linux）、Cortex-R 核心（处理实时任务）和 Cortex-M 核心（控制外设），这种设计能够很好地平衡性能、实时性和功耗。</p>
<h3 data-id="heading-16">5.2 AI 加速</h3>
<p>随着边缘 AI 的兴起，越来越多的嵌入式处理器开始集成 AI 加速单元，如 NPU（神经网络处理单元）。</p>
<p>这些专用硬件能够大幅提升神经网络推理的效率。</p>
<h3 data-id="heading-17">5.3 安全特性</h3>
<p>安全性在嵌入式系统中越来越重要。</p>
<p>现代处理器普遍集成了硬件安全模块，如 TrustZone、安全启动、加密引擎等。</p>
<h3 data-id="heading-18">5.4 开源架构</h3>
<p>RISC-V 等开源架构的兴起，为嵌入式处理器市场带来了新的活力。</p>
<p>开源架构的优势在于灵活性和可定制性，能够满足特定应用的需求。</p>
<h2 data-id="heading-19">6. 总结</h2>
<p>嵌入式处理器架构是一个博大精深的领域，涉及硬件设计、指令集、编译器、操作系统等多个层面。</p>
<p>作为嵌入式开发者，我们不需要成为架构设计专家，但需要对常见架构有基本的了解，这样才能在项目中做出正确的技术选择。</p>
<p>在我的职业生涯中，从 51 单片机到 ARM，从简单的裸机程序到复杂的 Linux 系统，每一次架构的转变都是一次技术能力的提升。</p>
<p>我的建议是：先深入掌握一种主流架构（比如 ARM），然后再去了解其他架构，这样能够建立起系统的知识体系。</p>
<p>随着技术的发展，新的处理器架构不断涌现，但核心的设计理念是相通的。</p>
<p>只要掌握了基本原理，学习新架构就会变得容易很多。</p>
<p>希望这篇文章能够帮助大家建立起对嵌入式处理器架构的整体认识，在实际项目中能够做出更好的技术决策。</p>
<p><strong>更多编程学习资源</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fc_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/c_course_handout_2025.html" ref="nofollow noopener noreferrer">C 语言零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fstm32%2Fstm32_course_handout_2024.html" target="_blank" title="https://www.lxlinux.net/e/stm32/stm32_course_handout_2024.html" ref="nofollow noopener noreferrer">STM32 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Ffreertos%2Ffreertos_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/freertos/freertos_course_handout_2025.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fcpp_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/cpp_course_handout_2025.html" ref="nofollow noopener noreferrer">C++ 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2F51-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/51-learning-path.html" ref="nofollow noopener noreferrer">51 单片机零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fad-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/ad-learning-path.html" ref="nofollow noopener noreferrer">AD 画板零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fc-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/c-learning-path.html" ref="nofollow noopener noreferrer">C 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fcpp-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/cpp-learning-path.html" ref="nofollow noopener noreferrer">C++ 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fesp32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/esp32-learning-path.html" ref="nofollow noopener noreferrer">ESP32 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Ffreertos-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/freertos-learning-path.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-devop-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-devop-learning-path.html" ref="nofollow noopener noreferrer">Linux 应用开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-lower-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-lower-learning-path.html" ref="nofollow noopener noreferrer">Linux 底层开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flvgl-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/lvgl-learning-path.html" ref="nofollow noopener noreferrer">LVGL 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fqt-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/qt-learning-path.html" ref="nofollow noopener noreferrer">QT 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fstm32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/stm32-learning-path.html" ref="nofollow noopener noreferrer">STM32 零基础入门学习路线</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[createAsyncThunk]]></title>    <link>https://juejin.cn/post/7603854784864944168</link>    <guid>https://juejin.cn/post/7603854784864944168</guid>    <pubDate>2026-02-08T16:20:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784864944168" data-draft-id="7603854784864927784" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="createAsyncThunk"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2026-02-08T16:20:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="liyang_ii"/> <meta itemprop="url" content="https://juejin.cn/user/2365804756342360"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            createAsyncThunk
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2365804756342360/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    liyang_ii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T16:20:53.000Z" title="Sun Feb 08 2026 16:20:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>一、 创建异步函数</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createSlice, createAsyncThunk } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>;
<span class="hljs-keyword">import</span> { getStuListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/stuApi'</span>;

<span class="hljs-comment">// 1. 创建异步 thunk</span>
<span class="hljs-keyword">const</span> fetchStudents = <span class="hljs-title function_">createAsyncThunk</span>(
  <span class="hljs-string">'students/fetchStudents'</span>,
  <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getStuListApi</span>();
    <span class="hljs-keyword">return</span> response;
  }
);

<span class="hljs-comment">// 2. 创建 slice</span>
<span class="hljs-keyword">const</span> studentsSlice = <span class="hljs-title function_">createSlice</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'students'</span>,
  <span class="hljs-attr">initialState</span>: {
    <span class="hljs-attr">list</span>: [],
    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
  },
  <span class="hljs-attr">reducers</span>: {
    <span class="hljs-comment">// 同步 reducers...</span>
  },
  <span class="hljs-comment">// 3. 使用 extraReducers 处理异步 action</span>
  <span class="hljs-attr">extraReducers</span>: <span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span> {
    builder
      <span class="hljs-comment">// pending：请求开始</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">pending</span>, <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">true</span>;
        state.<span class="hljs-property">error</span> = <span class="hljs-literal">null</span>;
      })
      <span class="hljs-comment">// fulfilled：请求成功</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">fulfilled</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;
        state.<span class="hljs-property">list</span> = action.<span class="hljs-property">payload</span>;
      })
      <span class="hljs-comment">// rejected：请求失败</span>
      .<span class="hljs-title function_">addCase</span>(fetchStudents.<span class="hljs-property">rejected</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
        state.<span class="hljs-property">loading</span> = <span class="hljs-literal">false</span>;
        state.<span class="hljs-property">error</span> = action.<span class="hljs-property">error</span>.<span class="hljs-property">message</span>;
      });
  },
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> studentsSlice.<span class="hljs-property">reducer</span>;
</code></pre>
<p>二、在组件中使用</p>
<pre><code class="hljs language-import" lang="import">import { fetchStudents } from '../store/modules/students';

function StudentsList() {
  const dispatch = useDispatch();
  const { list, loading, error } = useSelector((state) =&gt; state.students);

  useEffect(() =&gt; {
    dispatch(fetchStudents());
  }, [dispatch]);

  if (loading) return &lt;div&gt;加载中...&lt;/div&gt;;
  if (error) return &lt;div&gt;错误: {error}&lt;/div&gt;;

  return (
    &lt;div&gt;
      {list.map((student) =&gt; (
        &lt;div key={student.id}&gt;{student.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器]]></title>    <link>https://juejin.cn/post/7604344066579120179</link>    <guid>https://juejin.cn/post/7604344066579120179</guid>    <pubDate>2026-02-09T02:24:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604344066579120179" data-draft-id="7604093823958106131" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器"/> <meta itemprop="keywords" content="Claude,Agent"/> <meta itemprop="datePublished" content="2026-02-09T02:24:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="jerrywus"/> <meta itemprop="url" content="https://juejin.cn/user/2823201591402990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2823201591402990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    jerrywus
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:24:14.000Z" title="Mon Feb 09 2026 02:24:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    85
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一句话生成整套 API：我用 Claude Code 自定义 Skill + MCP 搞了个接口代码生成器</h2>
<blockquote>
<p>从 Swagger 文档到 TypeScript 类型、API 函数、Mock 数据，一句指令全自动。</p>
</blockquote>
<h3 data-id="heading-1">前言</h3>
<p>做前端的应该都经历过这种事：</p>
<p>后端丢来一个 Swagger 链接，然后你得：</p>
<ol>
<li>打开文档，一个个看接口定义</li>
<li>手写 TypeScript 类型（请求参数、响应结构）</li>
<li>写 API 调用函数</li>
<li>造 Mock 数据给本地开发用</li>
<li>注册 Mock 路由</li>
</ol>
<p>一个模块少说 2-3 个接口，这些重复劳动能耗掉半天。</p>
<p>后来我想，这活儿能不能自动化？于是折腾了一套方案，现在只要一句话：</p>
<pre><code class="hljs language-bash" lang="bash">实现接口：https://gateway.xxx.cn/doc.html<span class="hljs-comment">#/组织架构服务/供应商管理/page_1</span>
</code></pre>
<p>Claude Code 会自己打开 Swagger 文档、提取接口信息、让你勾选要实现哪些接口，然后并行生成所有代码。</p>
<p>这篇文章记录一下整个搭建过程和实际跑起来的效果。</p>
<h3 data-id="heading-2">整体架构</h3>
<p>先看全貌，方案分三块：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│                  api-add Skill                   │
│              (工作流编排 / 入口)                    │
├─────────────────────────────────────────────────┤
│                                                  │
│  ┌──────────────────┐                            │
│  │ chrome-devtools   │  ← 读取 Swagger 文档       │
│  │      MCP          │  ← 提取接口信息             │
│  └──────────────────┘                            │
│           │                                      │
│           ▼                                      │
│  ┌──────────────────────────────────┐            │
│  │        Agent Team (并行)          │            │
│  │  ┌────────────┐ ┌─────────────┐  │            │
│  │  │ api-define │ │ mock-create │  │            │
│  │  │  (Haiku)   │ │  (Haiku)    │  │            │
│  │  │            │ │             │  │            │
│  │  │ TS 类型    │ │ Mock 数据    │  │            │
│  │  │ API 函数   │ │ Mock 路由    │  │            │
│  │  └────────────┘ └─────────────┘  │            │
│  └──────────────────────────────────┘            │
│                                                  │
└─────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>Skill：自定义技能，定义工作流怎么跑</li>
<li>MCP (Model Context Protocol)：让 AI 能操控浏览器，直接读文档</li>
<li>Agent Team：两个 Agent 同时干活，一个写类型和 API，一个写 Mock</li>
</ul>
<p>下面一个个说。</p>
<h3 data-id="heading-3">一、Chrome DevTools MCP -- 让 AI "看见"浏览器</h3>
<h4 data-id="heading-4">MCP 是什么？</h4>
<p>MCP（Model Context Protocol）是 Anthropic 出的一个开放协议，让 AI 能跟外部工具交互。简单说就是 AI 的插件系统，接上不同的 MCP Server，AI 就多了一种能力。</p>
<h4 data-id="heading-5">为什么要用 Chrome DevTools MCP？</h4>
<p>Swagger/Knife4j 文档是动态渲染的 SPA 页面。你用 <code>fetch</code> 或 <code>curl</code> 去请求，拿到的只是一个空壳 HTML，接口信息全靠 JS 渲染出来，根本抓不到。</p>
<p>Chrome DevTools MCP 能让 AI 操控一个真实的浏览器：</p>
<ul>
<li>打开页面，等 JS 渲染完</li>
<li>读取页面的可访问性树（Accessibility Tree）</li>
<li>点击元素、做页面交互</li>
</ul>
<p>说白了就是让 AI 能像人一样看网页。</p>
<h4 data-id="heading-6">怎么配置</h4>
<p>在 Claude Code 里添加 <code>chrome-devtools</code> MCP server：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FChromeDevTools%2Fchrome-devtools-mcp%3Ftab%3Dreadme-ov-file%23mcp-client-configuration" target="_blank" title="https://github.com/ChromeDevTools/chrome-devtools-mcp?tab=readme-ov-file#mcp-client-configuration" ref="nofollow noopener noreferrer">chrome devtools mcp github 地址</a></p>
<ul>
<li>打开 github 项目页面，找到 Claude Code 的配置指令。进入项目根目录，终端执行：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">claude mcp add chrome-devtools --scope user npx chrome-devtools-mcp@latest
</code></pre>
<ul>
<li>然后在项目 <code>.claude</code> 目录下创建 <code>mcp.json</code>：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"mcpServers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"chrome-devtools"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npx"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"-y"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"chrome-devtools-mcp@latest"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>配好之后 Claude Code 就能操作浏览器了，主要用到这几个工具：</p>





























<table><thead><tr><th>工具</th><th>干什么的</th></tr></thead><tbody><tr><td><code>navigate_page</code></td><td>打开指定 URL</td></tr><tr><td><code>take_snapshot</code></td><td>获取页面快照（可访问性树）</td></tr><tr><td><code>click</code></td><td>点击页面元素</td></tr><tr><td><code>fill</code></td><td>填写表单</td></tr><tr><td><code>take_screenshot</code></td><td>截图</td></tr></tbody></table>
<p>我们这个场景主要用前三个：导航、快照、点击。</p>
<h3 data-id="heading-7">二、api-add Skill -- 工作流编排</h3>
<h4 data-id="heading-8">Skill 是什么？</h4>
<p>Claude Code 的 Skill 就是一个 Markdown 文件，告诉 AI 碰到什么情况该怎么做。里面写清楚：</p>
<ul>
<li>什么时候触发</li>
<li>按什么步骤执行</li>
<li>有什么限制</li>
</ul>
<p>文件放在 <code>.claude/skills/&lt;skill-name&gt;/SKILL.md</code>，Claude Code 启动时会自动加载。</p>
<h4 data-id="heading-9">api-add Skill 怎么设计的</h4>
<p>我想要的效果是：给一个 Swagger URL，自动把接口文档变成可用的代码。</p>
<pre><code class="hljs language-bash" lang="bash">.claude/skills/api-add/SKILL.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: api-add
description: 从 Swagger 文档或 md 文档快速创建 API function、
  TypeScript 类型定义和 Mock 实现。
<span class="hljs-section">  触发关键词：实现接口、创建接口、添加API、接口定义。
---</span>

<span class="hljs-section"># API from Swagger Doc</span>

<span class="hljs-section">## skill 触发场景</span>

<span class="hljs-section">### 场景1</span>
用户提供接口 url，并说实现接口定义

<span class="hljs-section">### 场景2</span>
用户指定一个 md 文档，则直接从文档中读取接口定义

<span class="hljs-section">## 工作流程</span>

<span class="hljs-section">### 第一步：获取接口信息</span>

使用 chrome-devtools-mcp 读取 Swagger 文档：

<span class="hljs-bullet">1.</span> 使用 navigate<span class="hljs-emphasis">_page 打开 Swagger URL
2. 使用 take_</span>snapshot 读取页面内容
<span class="hljs-bullet">3.</span> 展开左侧菜单，获取当前分类下的所有接口列表
<span class="hljs-bullet">4.</span> 使用 AskUserQuestion，列出所有接口供用户选择
<span class="hljs-bullet">5.</span> 用户确认后，逐一点击并提取完整信息

<span class="hljs-section">### 第二步：创建 Agent Team 并行生成代码</span>

创建 2 个 teammate 分别负责：
<span class="hljs-bullet">-</span> api-define：TypeScript 类型 + API 函数
<span class="hljs-bullet">-</span> mock-create：Mock 数据 + Mock 路由

<span class="hljs-section">### 第三步：清除 teams 并结束</span>
</code></pre>
<p>这里说几个我做的选择：</p>
<p><strong>1. 为什么用 MCP 而不是直接请求 API？</strong></p>
<p>Swagger 文档是前端渲染的 SPA，HTTP 请求拿不到内容。必须在真实浏览器里跑一遍 JS 才能看到接口信息。</p>
<p><strong>2. 为什么要让用户选接口？</strong></p>
<p>一个模块可能有十几个接口，但这次迭代可能只用到其中两三个（或者部分接口已经实现过了）。让用户自己勾选，省得生成一堆用不上（或者重复）的代码。</p>
<p><strong>3. 为什么用 Agent Team？</strong></p>
<p>写 TypeScript 类型/API 函数和写 Mock 数据/路由，这两件事互不依赖。让两个 Agent 同时跑，时间省一半。而且 Agent 用的是 Haiku 模型，比主模型便宜很多。</p>
<p>✏️ 我测试了一下，单独写⬆是6分钟多一点；使用agent teams 是4分钟多一点（因为是小功能， 时间节省不太明显， 但贵在省时间。 你可以尝试大功能，比如实现一个复杂的模块，时间节省会更明显）</p>
<h3 data-id="heading-10">三、Agent 定义 -- 分工干活</h3>
<p>除了 Skill，还得定义两个 Agent，它们才是真正写代码的。</p>
<p>💡 重点：agent team的配置，请参考：&lt;<a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.claude.com%2Fdocs%2Fen%2Fagent-teams" target="_blank" title="https://code.claude.com/docs/en/agent-teams" ref="nofollow noopener noreferrer">code.claude.com/docs/en/age…</a></p>
<h4 data-id="heading-11">api-define Agent</h4>
<pre><code class="hljs language-bash" lang="bash">.claude/agents/api-define.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: api-define
description: 实现指定模块的 api function &amp; typescript 类型的创建
model: haiku
<span class="hljs-section">color: green
---</span>

实现指定模块的 api function &amp; typescript 类型的创建，
严格按以下要求实现：

<span class="hljs-bullet">1.</span> 严格参照 .claude/rules/ 中的编码规范
<span class="hljs-bullet">2.</span> 完整实现：TypeScript 类型、API 函数
</code></pre>
<h4 data-id="heading-12">mock-create Agent</h4>
<pre><code class="hljs language-bash" lang="bash">.claude/agents/mock-define.md
</code></pre>
<pre><code class="hljs language-markdown" lang="markdown">---
name: mock-create
description: 实现指定 api 接口的 mock 实现
model: haiku
<span class="hljs-section">color: orange
---</span>

实现指定 api 接口的 mock 实现，严格按以下要求实现：

<span class="hljs-bullet">1.</span> 严格参照 .claude/rules/ 中的编码规范
<span class="hljs-bullet">2.</span> 完整实现：Mock 服务器（mocks 目录），
   实现 Express 接口（routes、controllers、data）
</code></pre>
<p>几个值得说的点：</p>
<ul>
<li><code>model: haiku</code> -- 用轻量模型就够了，写这种模式化的代码不需要大模型，跑得快还省钱</li>
<li>"严格参照编码规范" -- 靠 <code>.claude/rules/</code> 里的规则文件约束代码风格，后面会讲</li>
<li><code>color</code> -- 终端里用不同颜色区分两个 Agent 的输出，看着方便</li>
</ul>
<h3 data-id="heading-13">四、实战演示</h3>
<p>来看实际跑一遍是什么样。我要给"供应商管理"模块实现接口。</p>
<h4 data-id="heading-14">Step 1：触发 Skill</h4>
<p>只需要输入一句话：</p>
<pre><code class="hljs language-bash" lang="bash">实现接口：https://gateway.xxx.cn/doc.html<span class="hljs-comment">#/组织架构服务/供应商管理/page_1</span>
</code></pre>
<p>Claude Code 会自动识别到 <code>api-add</code> Skill，加载后通过 MCP 打开 Swagger 文档：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e948483133324fb1b0f8986be2742160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=ftslIu6YhH41rtfCTFrv9IJrSLA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-15">Step 2：读取文档，选择接口</h4>
<p>AI 通过浏览器快照读到页面内容，找到左侧菜单里"供应商管理"下的所有接口，弹出选择框让我勾：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/997669987d614a0eb299e311aa5b5ca0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=ptv%2BALNriB%2Bw8yS54wfx92dGWZ4%3D" alt="image.png" loading="lazy"/></p>
<p>它做了这几件事：</p>
<ul>
<li>识别了左侧菜单的接口列表（POST 分页列表、GET 配置商户）</li>
<li>点进每个接口 Tab，提取了完整的请求参数和响应结构</li>
<li>URL 指向的"分页列表"被标成了推荐选项</li>
</ul>
<p>我两个都选了。</p>
<h4 data-id="heading-16">Step 3：Agent Team 并行干活</h4>
<p>确认后，Claude Code 起了一个 Agent Team，两个 Agent 同时开工：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e054e889ceb469d9e2292a4a0e1b3a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=SNNIMFrSXPKovm7%2Bz1scT0%2FYZYc%3D" alt="image.png" loading="lazy"/></p>
<p>截图里能看到：</p>
<ul>
<li>api-definer（绿色）在写 TypeScript 类型定义和 API 函数</li>
<li>mock-creator（橙色）在写 Mock 数据和路由</li>
<li>两个同时跑，互不影响</li>
<li>底部状态栏显示着两个 Agent 的运行状态</li>
</ul>
<h4 data-id="heading-17">Step 4：完成，收工</h4>
<p>两个 Agent 干完活，自动关闭并清理资源：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8d5d80403a0406d88ec4040497cd007~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamVycnl3dXM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771210089&amp;x-signature=uMa1W2ICLxjPnObWIJKYgTcDwIc%3D" alt="image.png" loading="lazy"/></p>
<p>最终生成了这些文件：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># API &amp; 类型定义</span>
src/types/supply-company.ts          ← TypeScript 类型
src/api/supply-company/index.ts      ← API 函数

<span class="hljs-comment"># Mock 实现</span>
mocks/routes/data/supply-company-page.json    ← Mock 数据
mocks/routes/supply-company.controller.cjs    ← Mock 控制器
mocks/routes/org.cjs                          ← 路由挂载（已更新）
</code></pre>
<h3 data-id="heading-18">五、看看生成的代码</h3>
<p>代码质量怎么样？直接贴。</p>
<h4 data-id="heading-19">TypeScript 类型定义</h4>
<p>部分展示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/types/supply-company.ts</span>

<span class="hljs-comment">/** 供应商分页查询参数 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISupplyCompanyPageParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPageParam</span> {
  <span class="hljs-comment">/** 供应商名称 */</span>
  name?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/** 供应商分页列表项 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISupplyCompanyPageVO</span> {
  <span class="hljs-comment">/** 供应商组织id */</span>
  <span class="hljs-attr">orgId</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 公司编码 */</span>
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 供应商名称 */</span>
  <span class="hljs-attr">orgName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 负责人id */</span>
  <span class="hljs-attr">staffId</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 负责人姓名 */</span>
  <span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 状态 */</span>
  <span class="hljs-attr">status</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 所属商户 */</span>
  <span class="hljs-attr">merchantName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 创建人 */</span>
  <span class="hljs-attr">creator</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 创建时间 */</span>
  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">string</span>;
}
</code></pre>
<p><code>I</code> 前缀、JSDoc 注释、继承 <code>IPageParam</code>，跟项目里手写的一模一样。</p>
<h4 data-id="heading-20">API 函数</h4>
<p>部分展示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/api/supply-company/index.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">querySupplyCompanyPage</span>(<span class="hljs-params">
  params: ISupplyCompanyPageParam
</span>) {
  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> data = [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">ISupplyCompanyPageVO</span>[];
  params = <span class="hljs-title function_">toConditional</span>(params);

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { code, context, message } = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Http</span>.<span class="hljs-property">post</span>&lt;{
      <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span>;
      <span class="hljs-attr">data</span>: <span class="hljs-title class_">ISupplyCompanyPageVO</span>[];
    }&gt;(<span class="hljs-string">`<span class="hljs-subst">${baseUrl}</span>/page`</span>, { ...params });

    <span class="hljs-keyword">if</span> (code !== <span class="hljs-title class_">EResponseCode</span>.<span class="hljs-property">Succeed</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message || <span class="hljs-string">'服务器异常，请稍后再试~'</span>);
    }
    total = context?.<span class="hljs-property">total</span> || <span class="hljs-number">0</span>;
    data = context?.<span class="hljs-property">data</span> || [];
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title function_">getHttpErrorMessage</span>(error));
  }

  <span class="hljs-keyword">return</span> { total, data };
}
</code></pre>
<p>项目里标准的 API 写法：<code>async/await</code> + <code>try/catch</code> + <code>toConditional</code> + 错误处理，一个不差。</p>
<h4 data-id="heading-21">Mock 数据</h4>
<p>部分展示：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-comment">// mocks/routes/data/supply-company-page.json</span>
<span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"orgId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1001</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SC-2025-001"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"orgName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"上海奢品供应链有限公司"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"staffId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2001</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"userName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张经理"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ENABLED"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"merchantName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"LuxMall旗舰店"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"creator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"系统管理员"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"createTime"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2025-01-15 10:30:00"</span>
  <span class="hljs-punctuation">}</span>
  <span class="hljs-comment">// ... 更多数据</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>Mock 数据的字段值是有意义的中文内容，不是那种 <code>"string"</code> 占位符。</p>
<h4 data-id="heading-22">Mock 控制器</h4>
<p>部分展示：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// mocks/controllers/supply-company.controller.cjs</span>

<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> supplyCompanyList = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./data/supply-company-list.json'</span>);

<span class="hljs-comment">/**
 * 供应商分页列表
 * POST /page
 */</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/page'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> all = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(supplyCompanyList));
  <span class="hljs-keyword">const</span> { page = <span class="hljs-number">1</span>, size = <span class="hljs-number">50</span>, name } = req.<span class="hljs-property">body</span> || {};

  <span class="hljs-comment">// 按供应商名称模糊搜索</span>
  <span class="hljs-keyword">if</span> (name) {
    all = all.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>
      <span class="hljs-title class_">String</span>(item.<span class="hljs-property">orgName</span>).<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">String</span>(name))
    );
  }

  <span class="hljs-keyword">const</span> total = all.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> start = (<span class="hljs-title class_">Number</span>(page) - <span class="hljs-number">1</span>) * <span class="hljs-title class_">Number</span>(size);
  <span class="hljs-keyword">const</span> end = start + <span class="hljs-title class_">Number</span>(size);
  <span class="hljs-keyword">const</span> data = all.<span class="hljs-title function_">slice</span>(start, end);

  res.<span class="hljs-title function_">json</span>({
    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">context</span>: { total, data },
    <span class="hljs-attr">traceId</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">spanId</span>: <span class="hljs-string">''</span>,
  });
});

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;
</code></pre>
<p>分页、模糊搜索、标准响应格式，都按项目的 Mock 规范来的。</p>
<h3 data-id="heading-23">六、代码质量靠什么保证？Rules</h3>
<p>你可能会想：AI 怎么知道我们项目的编码规范？</p>
<p>靠 <code>.claude/rules/</code> 目录。这是 Claude Code 的规则系统，你可以理解为给 AI 写了一份项目编码手册：</p>
<pre><code class="hljs language-bash" lang="bash">.claude/rules/
├── api.md           ← API 实现标准（函数命名、错误处理模式）
├── ts-define.md     ← TypeScript 规范（I前缀、E前缀、JSDoc）
├── mock.md          ← Mock 服务器架构（路由、控制器、数据文件）
├── components.md    ← 组件库参考
├── vue-single-file.md ← Vue SFC 标准
└── ...
</code></pre>
<p>每个 Agent 工作时都会读这些规则文件。所以生成出来的代码风格跟项目里手写的一致，不会出现那种一看就是 AI 写的通用代码。</p>
<h3 data-id="heading-24">七、想复刻？文件结构在这</h3>
<p>如果你想在自己项目里搞一套，需要这些文件：</p>
<pre><code class="hljs language-csharp" lang="csharp">.claude/
├── agents/
│   ├── api-define.md          ← API 定义 Agent
│   └── mock-define.md         ← Mock 创建 Agent
├── skills/
│   └── api-<span class="hljs-keyword">add</span>/
│       └── SKILL.md           ← 工作流编排 Skill
├── rules/
│   ├── api.md                 ← API 编码规范
│   ├── ts-define.md           ← TypeScript 规范
│   └── mock.md                ← Mock 规范
└── ...

<span class="hljs-meta"># MCP 配置（项目级或全局）</span>
.mcp.json                      ← Chrome DevTools MCP 配置
</code></pre>
<h3 data-id="heading-25">八、效果对比</h3>








































<table><thead><tr><th>维度</th><th>手动开发</th><th>api-add Skill</th></tr></thead><tbody><tr><td>耗时</td><td>6.5m</td><td>4.3m</td></tr><tr><td>类型定义</td><td>手动从文档抄</td><td>自动提取，不会漏字段</td></tr><tr><td>API 函数</td><td>复制模板手动改</td><td>自动生成，符合规范</td></tr><tr><td>Mock 数据</td><td>手动编假数据</td><td>自动生成，内容像真的</td></tr><tr><td>代码规范</td><td>看个人习惯</td><td>Rules 强制约束</td></tr><tr><td>人为错误</td><td>字段名拼错、类型写错</td><td>从文档直接提取，基本不会错</td></tr></tbody></table>
<h3 data-id="heading-26">总结</h3>
<p>回头看，这套方案做了四件事：</p>
<ol>
<li>用 MCP 让 AI 能读浏览器里的 Swagger 文档</li>
<li>用 Skill 把多步骤任务编排成一句话就能触发的流程</li>
<li>用 Agent Team 让两个轻量 Agent 并行干活，省时间也省钱</li>
<li>用 Rules 约束代码风格，保证生成的代码跟手写的一样</li>
</ol>
<p>说到底就是把"从文档到代码"这个重复劳动自动化了。</p>
<p>这套方案也不只能用在 Swagger 上。改一下 Skill 的工作流，Apifox、Postman、自定义 Markdown 文档、GraphQL Schema，只要浏览器能打开的接口文档都能接。</p>
<p>如果你也在用 Claude Code，可以试试 Skill + MCP 这个组合。</p>
<hr/>
<blockquote>
<p>觉得有用的话点个赞，也欢迎在评论区聊聊你的 Claude Code 玩法。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”]]></title>    <link>https://juejin.cn/post/7604036853129347087</link>    <guid>https://juejin.cn/post/7604036853129347087</guid>    <pubDate>2026-02-09T02:24:27.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604036853129347087" data-draft-id="7603699739224555535" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2026-02-09T02:24:27.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AAAI 2026这篇杰出论文说了什么？用LLM给CLIP换了个“聪明大脑”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:24:27.000Z" title="Mon Feb 09 2026 02:24:27 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>在多模态大模型飞速发展的今天，CLIP作为连接视觉与语言的“基石”依然发挥着重要作用。然而，随着应用场景的深入，研究人员逐渐发现CLIP的文本编码器已经成为整个系统的瓶颈：<strong>不仅受限于77个Token的长度限制，在处理复杂、长篇的图像描述时也显得力不从心。</strong></p>
<p>来自同济大学、微软和麦考瑞大学的研究团队提出了 <strong>LLM2CLIP（Large Language Model to CLIP）</strong> ，<strong>通过将大语言模型的深厚知识“注入”到CLIP架构中，显著提升了长文本检索的精度，同时赋予了模型强大的多语言处理能力。</strong></p>
<p>这项研究凭借其卓越的创新性，成功斩获 AAAI 2026 杰出论文奖。</p>
<blockquote>
<p><strong>论文地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2411.04997%25C2%25A0" target="_blank" title="https://arxiv.org/abs/2411.04997%C2%A0" ref="nofollow noopener noreferrer">arxiv.org/abs/2411.04…</a></p>
<p><strong>项目主页：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Faka.ms%2Fllm2clip" target="_blank" title="https://aka.ms/llm2clip" ref="nofollow noopener noreferrer">aka.ms/llm2clip</a></p>
<p><strong>代码仓库：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2FLLM2CLIP" target="_blank" title="https://github.com/microsoft/LLM2CLIP" ref="nofollow noopener noreferrer">github.com/microsoft/L…</a> (已开源)</p>
</blockquote>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9c7c88d98a0488983d785a43403cd54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=YNNDgB0KfIewojki2qkehh05mFQ%3D" alt="图片1.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-0"><strong>传统CLIP的“语言瓶颈”</strong></h2>
<p>自2021年OpenAI发布CLIP以来，这种双塔结构模型已经成为多模态领域的标配。</p>
<p>无论是LLaVA这样的理解模型，还是Stable Diffusion这样的生成模型，都离不开CLIP的贡献。</p>
<p><strong>但问题在于，传统的CLIP文本编码器通常是规模较小的Transformer结构，其处理长描述（Dense Captions）的能力非常有限。</strong></p>
<p>与此同时，大语言模型在文本理解上已经达到了惊人的高度。那么，为什么不直接把LLM拿来当CLIP的文本编码器呢？</p>
<p>研究团队发现，这里存在两个核心挑战：</p>
<ul>
<li>特征可分性问题：原始LLM的特征空间并不是为了对比学习设计的。实验显示，像Llama 3这样的模型在处理图像描述时，其特征区分度极差，Top-1检索准确率甚至不到6%</li>
<li>训练成本过高：如果每次训练CLIP都要微调一个7B甚至更大的LLM，那算力开销将是天文数字</li>
</ul>
<h2 data-id="heading-1"><strong>两阶段“注入”方案：巧妙的架构设计</strong></h2>
<p>LLM2CLIP的核心创新在于提出了一个巧妙的两阶段微调方案，既解决了特征可分性问题，又大幅降低了训练成本。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6713095d3aae4808b8082dc43dff6f48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=y1P6rdZK3pGTWjYM1KJ1mb930rw%3D" alt="图片2.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>第一阶段：让LLM学会“提取特征”</strong></li>
</ul>
<p>为了解决LLM特征区分度不足的问题，研究者首先对LLM进行了“嵌入化”改造：</p>
<p><strong>架构调整：</strong> 移除了LLM原有的因果掩码，改为双向注意力机制，并采用平均池化来获取整句的嵌入向量</p>
<p><strong>对比学习：</strong> 利用LoRA技术，在高质量的描述语料库（如DreamLIP）上进行监督式描述对比微调</p>
<p>简单来说，这一步是让LLM明白：即使是两段描述同一个物体的不同文字，在特征空间里也应该靠得更近。</p>
<p>效果惊人：经过这一阶段，Llama 3在COCO描述检索上的准确率从5.2%飙升到了29.5%</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbc2efe7d75a4b6d81bf0e092f628187~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=88t36GQBtSvBCVSQn4ZiR3Vxt4g%3D" alt="图片3.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>第二阶段：视觉与语言的轻量级对齐</strong></li>
</ul>
<p>在LLM具备了良好的特征区分度后，接下来的任务是将其与CLIP的视觉编码器对齐：</p>
<p><strong>轻量级适配器：</strong> 选择冻结LLM，仅在LLM输出后添加一个由4层线性层组成的线性适配器</p>
<p><strong>离线特征加载：</strong> 这是提升效率的神来之笔。由于LLM是冻结的，研究者可以预先计算并存储所有文本的特征。这样在训练视觉编码器时，就不需要反复运行庞大的LLM</p>
<p>损失函数：研究团队发现，最简单的方法效果最好——直接用LLM替换原有的文本编码器进行对比学习</p>
<h2 data-id="heading-2"><strong>全方位性能提升：从长文本到多语言</strong></h2>
<p>研究团队在多个SOTA基准模型（如OpenAI CLIP, EVA02, SigLIP2）上应用了LLM2CLIP方案，结果令人振奋。</p>
<ul>
<li><strong>长文本检索：性能大幅提升</strong></li>
</ul>
<p>在长文本检索数据集（如DOCCI和Urban1K）上，相比于原本已经非常强大的SigLIP2，LLM2CLIP带来了巨大提升：</p>
<p>在DOCCI数据集上，SigLIP2经过LLM2CLIP微调后，平均检索精度提升了14-15个百分点</p>
<p>即使在短文本的Flickr和COCO任务上，性能也稳步提升</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94739dbc52c5410f9e456ee81b62c8dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=k4uNUd%2BCqeC7rQ3iGN5%2FE0K1IuA%3D" alt="图片4.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>多语言能力：意外惊喜</strong></li>
</ul>
<p>由于LLM本身就是在海量多语言语料上训练的，LLM2CLIP继承了这种天赋：</p>
<p>原本只支持英文的EVA02在加入LLM2CLIP后，在中文检索任务上直接从“不可用”变成了“顶尖水平”</p>
<p>SigLIP2的多语言能力也得到了显著增强，在XM3600任务上的表现提升了11.9/15.2</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b41bd0cf9dc476480e879b075d546e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=FfruYegap2VBT1pGP%2F8t0E8zqEw%3D" alt="图片5.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>视觉表征的“反哺效应”</strong></li>
</ul>
<p>高质量的文本监督不仅让检索变准了，还让视觉编码器本身变得更强：</p>
<p>在ImageNet的线性探测实验中，LLM2CLIP提升了视觉特征的质量；</p>
<p>在下游的零样本分割和检测任务中，性能也有显著增长</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68846ca7e9e04b409b498f787782e347~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=UtEsDBMBZO3red%2BgsLZI8xwrBJc%3D" alt="图片6.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li><strong>综合性能：全方位优势</strong></li>
</ul>
<p>从雷达图上可以清晰看到，LLM2CLIP构成的多边形面积远超其他对比模型。</p>
<p>这意味着它不仅在长文本上遥遥领先，在传统的短文本检索任务上也保持了极高的水准，没有任何短板。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85a38286bf774748a0daeeb42411b1c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=E3tGIDS4QvPV%2BJ1fJkoHPIAKfBg%3D" alt="图片7.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-3"><strong>惊人的训练效率：1.3小时完成微调</strong></h2>
<p>对于开发者来说，LLM2CLIP最吸引人的地方在于其惊人的效率。</p>
<p>通过Offline-loading策略，在两台8卡A100机器上，第二阶段的训练时间从17小时缩短到了仅仅1.3小时。</p>
<p>这意味着普通研究团队也能轻松复现并定制自己的LLM2CLIP模型。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ec907ac4a554a6f95d6ff9aa4576762~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=ZURRJCMnW1h8RX3p44irMcCvQ18%3D" alt="图片8.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>研究团队还测试了最新的模型兼容性。令人惊喜的是，即使是最近大火的DeepSeek-R1-Distill-Llama-8B，在经过CC Fine-tuning后也能作为极佳的文本编码器。</p>
<p align="center"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbc7e3d3ffbf4d9baa076ce1c5bbb8ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771208666&amp;x-signature=7KvcYTrgAJ%2B3Nnu0FItXUExxz1I%3D" alt="图片9.png" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h2 data-id="heading-4"><strong>核心启示与未来展望</strong></h2>
<p>LLM2CLIP的成功给了我们一个非常重要的启示：</p>
<p>多模态模型的上限，往往取决于语言端对世界的理解深度。</p>
<p>过去我们试图通过堆视觉数据来提升CLIP，但LLM2CLIP证明了，通过引入一个已经“读过万卷书”的LLM，并辅以少量的、高质量的描述数据，就能让视觉表征产生质的飞跃。</p>
<p>这种“低成本、高收益”的方案，很可能会成为未来多模态预训练的新范式。</p>
<p>目前，研究团队已经开源了基于SigLIP2、EVA02和OpenAI CLIP增强的多个版本模型。</p>
<p>如果你正受困于CLIP的文本理解能力，或者需要一个强大的多语言多模态编码器，LLM2CLIP绝对值得一试。</p>
<p>技术的发展总是在解决一个个瓶颈中前进。LLM2CLIP通过巧妙的设计，不仅突破了CLIP的文本编码器限制，更为多模态研究开辟了新的思路：让专业的人（模型）做专业的事，再通过轻量化的方式将它们连接起来。</p>
<p>这或许正是未来AI系统设计的重要方向之一。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[记录overflow：hidden和scrollIntoView导致的页面问题]]></title>    <link>https://juejin.cn/post/7603781883974565907</link>    <guid>https://juejin.cn/post/7603781883974565907</guid>    <pubDate>2026-02-09T00:54:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883974565907" data-draft-id="7603911453704912939" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="记录overflow：hidden和scrollIntoView导致的页面问题"/> <meta itemprop="keywords" content="前端,CSS"/> <meta itemprop="datePublished" content="2026-02-09T00:54:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EchoEcho"/> <meta itemprop="url" content="https://juejin.cn/user/2920774267837208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            记录overflow：hidden和scrollIntoView导致的页面问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2920774267837208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EchoEcho
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T00:54:31.000Z" title="Mon Feb 09 2026 00:54:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>问题描述：</strong></p>
<p>在一个编辑器中开发页面组件，组件内部对子元素设置了<code>position:absolute</code>定位，并且元素内容区域设置了<code>overflow:hidden</code>属性。</p>
<p>启动项目后，可以在编辑器中可以对该组件进行相关设置和修改。当切换选中内容时，页面会自动滚动，将选中组件显示到浏览器视口中，修改对应属性也会重新渲染对应组件。</p>
<p>第一次渲染时<code>UI</code>展示正常。但是当对该组件切换选中元素或者对设置了定位的子元素设置新属性时都会导致下图中子元素的定位异常。但是在调试面板中查询该元素属性值，也没有任何改变。尝试重新在控制面板中赋值对应的<code>top</code>值，模型又会显示到指定位置。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/680e54f11bd0464c87eb9de36a1c1fab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771203270&amp;x-signature=8zc6JrnLZq2DRUXCjQhHKu%2Boa%2FI%3D" alt="图片" loading="lazy"/></p>
<p><strong>解决过程</strong></p>
<p>尝试使用内容监听器在组件被选中后，重新赋值对应的<code>top</code>和<code>left</code>值无法解决此问题。</p>
<p>后来通过浏览器断点调试，发现在触发监听器之前，该组件执行了<code>scrollIntoView</code>方法，见下图</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4dc06665708e49439c82ddc2d9d6229d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771203270&amp;x-signature=fh72jPLZA04zjQ5T5IkoMgCAa0M%3D" alt="图片" loading="lazy"/></p>
<p><strong>相关分析：</strong></p>
<p>在执行<code>ScrollIntoView</code>期间会多次重绘【<code>reflow/repaint</code>】页面布局。而子元素中定位相关属性值会在重绘时基于父元素的当前视口上下文重新计算，导致位置偏移，比如上图中的子元素底部与父元素对齐现象。</p>
<ol>
<li>平滑滚动动画（<code>behavior: 'smooth'</code>）：</li>
</ol>
<ul>
<li>动画过程会逐步改变滚动位置，触发多次布局计算。</li>
</ul>

<ul>
<li>如果父元素有 <code>overflow: hidden</code>，子元素超出部分在动画中可能被“拉回”或重定位。</li>
</ul>
<ol start="2">
<li><code>block: 'center'</code> 配置：</li>
</ol>
<ul>
<li>这会尝试将父元素置于视口中心，如果父元素高度不是固定值（例如依赖内容或响应式），百分比 <code>top</code> 会基于新滚动位置重新计算，导致子元素“滑动”到底部对齐。</li>
</ul>
<ol start="3">
<li>绝对定位的参考点变化：</li>
</ol>
<ul>
<li><code>absolute</code> 元素依赖最近的 <code>position: relative</code> 祖先。在滚动动画中，如果祖先的可见区域变化，子元素的计算位置会偏移。</li>
</ul>
<ol start="4">
<li>浏览器特定行为：</li>
</ol>
<ul>
<li><code>Chrome/Safari</code> 在 <code>smooth scroll</code> 时有时会错误处理百分比定位，尤其是结合 <code>overflow: hidden</code> 时。</li>
</ul>
<p><strong>而这里遇到的问题就是在组件相关容器中设置了<code>overflow:hidden</code>。</strong></p>
<p><strong>解决：</strong></p>
<p>将<code>overflow:hidden</code>改成<code>overflow:clip</code>就解决此问题了。</p>
<p><strong>解析<code>overflow:hidden</code>和<code>overflow:clip</code></strong></p>
<ul>
<li><code>overflow: hidden</code>：</li>
<li>
<ul>
<li>隐藏超出元素边界的内容，但内容在内部仍然“存在”。</li>
<li>不显示滚动条，但可以通过<code>JavaScript</code>（如 <code>element.scrollLeft</code>）或嵌套滚动访问隐藏内容。</li>
<li>这是较早的标准值，广泛支持所有现代浏览器。</li>
</ul>
</li>
</ul>

<ul>
<li><code>overflow: clip</code>：</li>
<li>
<ul>
<li>完全“剪切”超出边界的内容，就好像超出部分不存在一样。</li>
<li>不允许任何形式的滚动访问（即使通过<code>JS</code>），内容被彻底丢弃。</li>
<li>这是<code>CSS Overflow Module Level 3</code> 中的新值（引入于 2020 年左右），浏览器支持较新（Chrome 90+、Firefox 75+、Safari 15+）。在旧浏览器中可能回退到 <code>hidden</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 关键区别</strong></p>













































<table><thead><tr><th>方面</th><th>overflow: hidden</th><th>overflow: clip</th></tr></thead><tbody><tr><td>内容可见性</td><td>隐藏超出部分，但内容仍可通过<code>JS</code> 滚动访问。</td><td>完全剪切超出部分，无法通过任何方式访问。</td></tr><tr><td>滚动行为</td><td>创建一个隐形的滚动容器；滚动事件可冒泡到父元素。</td><td>不创建滚动容器；滚动事件直接传递给父元素，不被捕获。</td></tr><tr><td>性能影响</td><td>可能导致浏览器计算隐藏内容的布局和渲染（较低性能）。</td><td>优化性能：浏览器忽略超出内容的渲染和布局（更快，尤其在复杂页面）。</td></tr><tr><td>定位/粘性影响</td><td>支持 <code>position: sticky</code> 等行为；创建新的块格式化上下文 (<code>BFC</code>)。</td><td>不支持 <code>position: sticky</code>（元素不会粘性）；不创建 <code>BFC</code>。</td></tr><tr><td>JS 交互</td><td>可以用<code>JS</code> 修改滚动位置（如 <code>scrollTo()</code>）。</td><td>无法用 <code>JS</code> 滚动；超出内容被视为不存在。</td></tr><tr><td>浏览器支持</td><td>所有现代浏览器（<code>IE6+</code>）。</td><td>较新浏览器；需检查兼容性（<code>polyfill</code> 有限）。</td></tr><tr><td>用例</td><td>适合需要隐藏但可能内部滚动的场景（如裁剪图片但允许<code>JS</code>动画）。</td><td>适合纯静态剪切场景（如性能敏感的游戏/<code>UI</code>），或防止意外滚动。</td></tr></tbody></table>
<ul>
<li>核心差异总结：<code>hidden</code> 是“隐藏但可访问”的（像盖了个盖子），而 <code>clip</code> 是“彻底删除超出部分”的（像用剪刀剪掉）。<code>clip</code> 更严格，旨在提高性能，但牺牲了一些灵活性。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）]]></title>    <link>https://juejin.cn/post/7604084016510271529</link>    <guid>https://juejin.cn/post/7604084016510271529</guid>    <pubDate>2026-02-09T02:33:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510271529" data-draft-id="7603355275257675816" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）"/> <meta itemprop="keywords" content="前端,面试,GitHub"/> <meta itemprop="datePublished" content="2026-02-09T02:33:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小林的编程开发日记"/> <meta itemprop="url" content="https://juejin.cn/user/3320949647350765"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我彻底搞懂了 SSE，原来流式响应效果还能这么玩的？（附 JS/Dart 双端实战）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3320949647350765/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小林的编程开发日记
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:33:49.000Z" title="Mon Feb 09 2026 02:33:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是【小林】</p>
<p>说起来有点意思，最近我在做 AI 项目的时候，突然对 "流式响应效果" 产生了浓厚兴趣也就是所谓的打字机效果。你知道那种感觉吧，AI 回答的时候，文字像被人敲出来一样，一个字一个字地蹦出来。</p>
<p>以前我以为是前端用 <code>setTimeout</code> 模拟的，直到有一次网络抖动，我发现它居然能<strong>从断开的地方继续输出</strong>，而不是重新开始。这就像看直播卡顿后，会自动从卡住的地方继续播放，而不是重播一遍。</p>
<p>这不就是<strong>断点续传</strong>吗？但 HTTP 请求不是无状态的吗？</p>
<p>带着这个疑问，我开始深入研究，才发现这背后藏着一套完整的流式传输协议——<strong>SSE（Server-Sent Events）</strong>。</p>
<p>更让我意外的是，我发现业界对于"AI 流式响应该用 SSE 还是 WebSocket"这个话题，争议还挺大。有人说 WebSocket 功能更强大，有人说 SSE 更简单。</p>
<p><strong>到底该选哪个？</strong></p>
<p>我干脆从零开始实现了一套完整的 Demo，包含后端服务、JavaScript 客户端、Dart 客户端，甚至还实现了断线重连、指数退避、粘包处理等生产级特性。</p>
<p>这篇文章，我就把这背后的原理、坑点、实战经验分享出来。</p>
<hr/>
<h2 data-id="heading-1">篇章一：为什么 AI 聊天首选 SSE 而非 WebSocket？</h2>
<p>在讲代码之前，我们先搞清楚一个核心问题：<strong>为什么 ChatGPT、Claude 这些 AI 助手都选 SSE，而不是看起来更强大的 WebSocket？</strong></p>
<h3 data-id="heading-2">1.1 场景分析：AI 对话的"一问多答"模式</h3>
<p>我们先看 AI 对话的典型特征：</p>
<pre><code class="hljs">用户：如何学好 Flutter？
AI：  【开始一段一段地输出，持续十几秒甚至更长】
</code></pre>
<p>这就是典型的**"一问多答"模式**：</p>
<ul>
<li>用户发送的 Prompt 通常很短（几个字到几百字）</li>
<li>AI 的回复可能很长（几千字，甚至更长）</li>
<li>数据流向是<strong>单向的</strong>：Server → Client</li>
</ul>
<h3 data-id="heading-3">1.2 SSE vs WebSocket 核心对比</h3>
<p>我们用一个表格来看两者的差异：</p>


















































<table><thead><tr><th>特性</th><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>通信方向</strong></td><td>单工（Server → Client）</td><td>全双工（双向通信）</td></tr><tr><td><strong>协议基础</strong></td><td>HTTP 标准</td><td>自定义 WS 协议</td></tr><tr><td><strong>连接方式</strong></td><td>标准 HTTP 请求</td><td>需要握手升级</td></tr><tr><td><strong>鉴权方式</strong></td><td>✅ 自定义 Header（如 Authorization）</td><td>❌ 只能在握手时带 Header</td></tr><tr><td><strong>断线重连</strong></td><td>✅ 内置 Last-Event-ID 机制</td><td>❌ 需要手动实现</td></tr><tr><td><strong>浏览器调试</strong></td><td>✅ DevTools 直接查看 EventStream</td><td>⚠️ 需要在 WS Frames 面板查看</td></tr><tr><td><strong>服务端实现</strong></td><td>✅ 简单，标准 HTTP 响应</td><td>⚠️ 需要维护连接状态</td></tr><tr><td><strong>AI 场景契合度</strong></td><td>✅ 完美匹配"一问多答"</td><td>❌ 过度设计</td></tr></tbody></table>
<h3 data-id="heading-4">1.3 一个餐厅大厨的比喻</h3>
<p>让我用一个好懂的比喻来解释：</p>
<p><strong>SSE 就像"自助餐厅的传菜口"</strong>：</p>
<ul>
<li>你点完菜（发送 HTTP 请求）</li>
<li>厨师开始炒菜，炒好一道就传出来一道（Server 持续推送数据）</li>
<li>你坐在那里等，菜一道一道地上来（Client 接收流式数据）</li>
<li>如果突然停电了，来电后厨师会问你："刚才上到第几道了？"然后继续上（断线重连）</li>
</ul>
<p><strong>WebSocket 就像"打电话订外卖"</strong>：</p>
<ul>
<li>你和骑手保持通话（双向通信通道）</li>
<li>骑手一边送一边向你汇报位置（实时双向交互）</li>
<li>如果电话断了，你得重新打过去，还得从头说（需要手动重连）</li>
</ul>
<p>对于 AI 聊天这种"我点菜，你上菜"的场景，SSE 的传菜口模式显然更合适。WebSocket 更适合"我和骑手实时沟通位置"这种需要频繁交互的场景。</p>
<h3 data-id="heading-5">1.4 为什么不用原生 EventSource？</h3>
<p>看到这里你可能会问：<strong>浏览器不是有原生 <code>EventSource</code> API 吗？为什么还要自己实现？</strong></p>
<p>问题在于，原生 <code>EventSource</code> 有几个致命限制：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原生 EventSource 的问题</span>
<span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">'/stream'</span>);  <span class="hljs-comment">// ❌ 只支持 GET</span>

<span class="hljs-comment">// ❌ 无法自定义 Header（比如 Authorization）</span>
<span class="hljs-comment">// ❌ 无法发送请求体（AI 场景的 Prompt 可能很长）</span>
<span class="hljs-comment">// ❌ 只能在 URL 里传参数，不安全也不优雅</span>
</code></pre>
<p>在 AI 场景下，我们需要：</p>
<ul>
<li>用 <strong>POST</strong> 请求发送长 Prompt</li>
<li>在 Header 里带 <strong>Authorization</strong> Token</li>
<li>支持自定义错误处理和重连策略</li>
</ul>
<p>所以，我们需要基于 <code>fetch + ReadableStream</code> 自己实现一个 SSEManager。</p>
<hr/>
<h2 data-id="heading-6">篇章二：直击底层：SSE 协议原理剖析</h2>
<h3 data-id="heading-7">2.1 SSE 协议格式</h3>
<p>SSE 是基于 HTTP 的，协议格式非常简单：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">id:</span> <span class="hljs-number">1234567890</span>
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>: <span class="hljs-string">"content"</span>, <span class="hljs-string">"payload"</span>: <span class="hljs-string">"我"</span>}

<span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">id:</span> <span class="hljs-number">1234567891</span>
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>: <span class="hljs-string">"content"</span>, <span class="hljs-string">"payload"</span>: <span class="hljs-string">"喜"</span>}

<span class="hljs-symbol">event:</span> close
<span class="hljs-symbol">data:</span> [DONE]
</code></pre>
<p><strong>协议要点</strong>：</p>
<ul>
<li>每条消息由 <code>event:</code>、<code>id:</code>、<code>data:</code> 三个字段组成</li>
<li>字段顺序不重要，但每条消息后必须有一个<strong>空行</strong>作为分隔符</li>
<li><code>event:</code> 表示事件类型（message、error、close 等）</li>
<li><code>id:</code> 用于断线重连时恢复（客户端会记录 Last-Event-ID）</li>
<li><code>data:</code> 是实际数据，通常是 JSON 字符串</li>
</ul>
<h3 data-id="heading-8">2.2 核心挑战：粘包和半包问题</h3>
<p>这是 SSE 实现中最容易踩的坑。</p>
<p><strong>什么是粘包？</strong></p>
<pre><code class="hljs language-vbnet" lang="vbnet">服务器一次发送：
<span class="hljs-symbol">event:</span> message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我"</span>}\n\nevent: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"喜"</span>}\n\n

客户端可能收到：
<span class="hljs-symbol">event:</span> message
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我"</span>}
<span class="hljs-symbol">event:</span> message    ← 两条消息粘在一起了
<span class="hljs-symbol">data:</span> {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"喜"</span>}
</code></pre>
<p><strong>什么是半包？</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">服务器发送一条完整消息：
<span class="hljs-keyword">event</span>: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>:<span class="hljs-string">"我是中文"</span>}\n\n

客户端可能分两次收到：
第一次：<span class="hljs-keyword">event</span>: message\ndata: {<span class="hljs-string">"type"</span>:<span class="hljs-string">"content"</span>,<span class="hljs-string">"payload"</span>: <span class="hljs-string">"我
第二次：是中文"</span>}\n\n                              ← JSON 被截断了！
</code></pre>
<p><strong>解决方案</strong>：
维护一个 <code>buffer</code> 缓冲区，每次收到 chunk 后：</p>
<ol>
<li>追加到 buffer</li>
<li>按 <code>\n\n</code> 分割出完整消息</li>
<li>剩下的部分留在 buffer，等下次 chunk 到来</li>
</ol>
<hr/>
<h2 data-id="heading-9">篇章三：实战实现</h2>
<h3 data-id="heading-10">3.1 后端实现（Node.js + Express）</h3>
<p>先看后端怎么实现 SSE 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/stream-sse'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-comment">// 设置 SSE 必需的 HTTP Headers</span>
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/event-stream'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'no-cache, no-transform'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Connection'</span>, <span class="hljs-string">'keep-alive'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Accel-Buffering'</span>, <span class="hljs-string">'no'</span>); <span class="hljs-comment">// 禁用 Nginx 缓冲</span>

  <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span>.<span class="hljs-property">query</span> || <span class="hljs-string">'默认问题'</span>;
  <span class="hljs-keyword">const</span> text = <span class="hljs-string">'这是 AI 的回复内容...'</span>;
  <span class="hljs-keyword">const</span> chars = text.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>);

  <span class="hljs-comment">// 逐字发送</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; chars.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-string">`event: message\nid: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>\ndata: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({
      type: <span class="hljs-string">'content'</span>,
      payload: chars[i],
      index: i,
      total: chars.length
    })}</span>\n\n`</span>;

    res.<span class="hljs-title function_">write</span>(message);

    <span class="hljs-comment">// 模拟 AI 生成延迟（打字机效果）</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>));
  }

  <span class="hljs-comment">// 发送完成信号</span>
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'event: close\ndata: [DONE]\n\n'</span>);
  res.<span class="hljs-title function_">end</span>();
});
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>Content-Type: text/event-stream</code> 告诉浏览器这是 SSE 流</li>
<li><code>Cache-Control: no-cache</code> 禁止缓存，确保实时性</li>
<li><code>Connection: keep-alive</code> 保持长连接</li>
<li>逐字符发送，模拟 AI 打字机效果</li>
<li>最后发送 <code>[DONE]</code> 信号告诉客户端流结束了</li>
</ul>
<h3 data-id="heading-11">3.2 JavaScript 客户端：手写 SSEManager</h3>
<p>这是核心部分。我们基于 <code>fetch + ReadableStream</code> 实现一个完整的 SSEManager：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SSEManager</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">url, options = {}</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = {
      <span class="hljs-attr">headers</span>: {},
      <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">5</span>,
      <span class="hljs-attr">initialRetryDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">enableRetry</span>: <span class="hljs-literal">true</span>,
      ...options
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> fetchOptions = {
        <span class="hljs-attr">method</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span> ? <span class="hljs-string">'POST'</span> : <span class="hljs-string">'GET'</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
          ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">headers</span>
        },
        <span class="hljs-attr">signal</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-property">signal</span>
      };

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span>) {
        fetchOptions.<span class="hljs-property">body</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">body</span>);
      }

      <span class="hljs-comment">// 如果有 Last-Event-ID，带上（用于断线重连）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span>) {
        fetchOptions.<span class="hljs-property">headers</span>[<span class="hljs-string">'Last-Event-ID'</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span>;
      }

      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span>, fetchOptions);
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span>);
      }

      <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();
      <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">'utf-8'</span>);

      <span class="hljs-comment">// 🔥 关键：消息缓冲区（处理粘包和半包）</span>
      <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
        <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });
        buffer += chunk;

        <span class="hljs-comment">// 解析缓冲区中的完整消息</span>
        buffer = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_parseBuffer</span>(buffer);
      }

      <span class="hljs-comment">// 如果不是主动断开，尝试重连</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">enableRetry</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-property">signal</span>.<span class="hljs-property">aborted</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
      }

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onErrorCallback</span>(error);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">enableRetry</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">maxRetries</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
      }
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-comment">// 🔥 核心方法：解析缓冲区中的 SSE 消息</span>
  <span class="hljs-title function_">_parseBuffer</span>(<span class="hljs-params">buffer</span>) {
    <span class="hljs-keyword">const</span> lines = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>);
    <span class="hljs-keyword">let</span> currentEvent = { <span class="hljs-attr">event</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lines.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> line = lines[i];

      <span class="hljs-comment">// 空行表示一条消息结束</span>
      <span class="hljs-keyword">if</span> (line === <span class="hljs-string">''</span>) {
        <span class="hljs-keyword">if</span> (currentEvent.<span class="hljs-property">data</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_handleEvent</span>(currentEvent);
          currentEvent = { <span class="hljs-attr">event</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };
        }
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-comment">// 解析字段</span>
      <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'event:'</span>)) {
        currentEvent.<span class="hljs-property">event</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>).<span class="hljs-title function_">trim</span>();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'id:'</span>)) {
        currentEvent.<span class="hljs-property">id</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">trim</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEventId</span> = currentEvent.<span class="hljs-property">id</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'data:'</span>)) {
        currentEvent.<span class="hljs-property">data</span> = line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">trim</span>();
      }
    }

    <span class="hljs-comment">// 返回未处理的缓冲区（最后一条不完整的消息）</span>
    <span class="hljs-keyword">return</span> lines[lines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-string">''</span> ? <span class="hljs-string">''</span> : lines[lines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
  }

  <span class="hljs-title function_">_handleEvent</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'close'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onCompleteCallback</span>();
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'error'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onErrorCallback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(event.<span class="hljs-property">data</span>));
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onMessageCallback</span>(data);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed to parse SSE data:'</span>, e);
      }
    }
  }

  <span class="hljs-comment">// 🔥 指数退避重连算法</span>
  <span class="hljs-title function_">_scheduleRetry</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span>++;
    <span class="hljs-keyword">const</span> delay = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">initialRetryDelay</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryCount</span> - <span class="hljs-number">1</span>),
      <span class="hljs-number">30000</span> <span class="hljs-comment">// 最大 30 秒</span>
    );

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[SSE] Retry <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.retryCount}</span>/<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.options.maxRetries}</span> after <span class="hljs-subst">${delay}</span>ms`</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>();
    }, delay);
  }

  <span class="hljs-title function_">onMessage</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onMessageCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">onError</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onErrorCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">onComplete</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onCompleteCallback</span> = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-title function_">disconnect</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortController</span>.<span class="hljs-title function_">abort</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isConnecting</span> = <span class="hljs-literal">false</span>;
  }
}
</code></pre>
<p><strong>使用示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> sse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSEManager</span>(<span class="hljs-string">'http://localhost:3000/stream-sse'</span>, {
  <span class="hljs-attr">body</span>: { <span class="hljs-attr">query</span>: <span class="hljs-string">'如何学好 Flutter？'</span> },
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer token123'</span> },
  <span class="hljs-attr">enableRetry</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">maxRetries</span>: <span class="hljs-number">5</span>
});

sse.<span class="hljs-title function_">onMessage</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到数据:'</span>, data.<span class="hljs-property">payload</span>);
  <span class="hljs-comment">// 逐字显示到界面上</span>
})
.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'发生错误:'</span>, error);
})
.<span class="hljs-title function_">onComplete</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'传输完成'</span>);
})
.<span class="hljs-title function_">connect</span>();
</code></pre>
<h3 data-id="heading-12">3.3 Dart 客户端：UTF-8 安全处理</h3>
<p>Dart 端有个特殊问题：<strong>中文字符的 UTF-8 编码问题</strong>。</p>
<p>中文字符在 UTF-8 中占 3 个字节，如果流正好把一个字符的 3 个字节截断了，就会出现乱码。</p>
<p><strong>解决方案</strong>：使用 <code>utf8.decoder</code> + <code>LineSplitter()</code> 的流转换链：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSEManager</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> url;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; headers;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; body;

  <span class="hljs-built_in">int</span> _retryCount = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">String?</span> _lastEventId;
  <span class="hljs-built_in">bool</span> _isConnecting = <span class="hljs-keyword">false</span>;

  SSEManager({
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.url,
    <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">const</span> {},
    <span class="hljs-keyword">this</span>.body = <span class="hljs-keyword">const</span> {},
  });

  Future&lt;<span class="hljs-keyword">void</span>&gt; connect() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">if</span> (_isConnecting) <span class="hljs-keyword">return</span>;
    _isConnecting = <span class="hljs-keyword">true</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> client = HttpClient();
      <span class="hljs-keyword">final</span> request = <span class="hljs-keyword">await</span> client.postUrl(<span class="hljs-built_in">Uri</span>.parse(url));

      <span class="hljs-comment">// 设置 Headers</span>
      headers.forEach((key, value) {
        request.headers.<span class="hljs-keyword">set</span>(key, value);
      });

      <span class="hljs-keyword">if</span> (_lastEventId != <span class="hljs-keyword">null</span>) {
        request.headers.<span class="hljs-keyword">set</span>(<span class="hljs-string">'Last-Event-ID'</span>, _lastEventId!);
      }

      <span class="hljs-comment">// 设置 Body</span>
      <span class="hljs-keyword">if</span> (body.isNotEmpty) {
        request.add(utf8.encode(jsonEncode(body)));
      }

      <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> request.close();

      <span class="hljs-comment">// 🔥 核心流转换链</span>
      response
        .transform(utf8.decoder)      <span class="hljs-comment">// ByteStream → String</span>
        .transform(<span class="hljs-keyword">const</span> LineSplitter()) <span class="hljs-comment">// String → Lines</span>
        .listen(_parseLine);

    } <span class="hljs-keyword">catch</span> (e) {
      _scheduleRetry();
    } <span class="hljs-keyword">finally</span> {
      _isConnecting = <span class="hljs-keyword">false</span>;
    }
  }

  <span class="hljs-keyword">void</span> _parseLine(<span class="hljs-built_in">String</span> line) {
    <span class="hljs-comment">// 解析 SSE 协议...</span>
    <span class="hljs-comment">// （类似 JS 版本的逻辑）</span>
  }

  <span class="hljs-keyword">void</span> _scheduleRetry() {
    _retryCount++;
    <span class="hljs-keyword">final</span> delay = min(<span class="hljs-number">1000</span> * pow(<span class="hljs-number">2</span>, _retryCount - <span class="hljs-number">1</span>), <span class="hljs-number">30000</span>).toInt();

    Future.delayed(<span class="hljs-built_in">Duration</span>(milliseconds: delay), () {
      connect();
    });
  }
}
</code></pre>
<h3 data-id="heading-13">3.4 实际运行效果</h3>
<p>让我们看看实际运行的效果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4315812aae0b446b91e1a6b39620f8a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=Fr9cdP%2FtL5NhR7Yi4MSfQ8J8%2BjM%3D" alt="主页面.png" loading="lazy"/></p>
<p><strong>传输中状态</strong>：</p>
<ul>
<li>AI 响应区域逐字显示</li>
<li>系统日志实时滚动</li>
<li>性能指标动态更新</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a53f9b73eab34675b8657fba557d01ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=mo3NStOjf2MHxs%2BYVqYtKdfpLG0%3D" alt="传输中.png" loading="lazy"/></p>
<p><strong>连接错误</strong>：</p>
<ul>
<li>当服务器未启动时，显示红色错误提示</li>
<li>自动触发重连机制</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9d6532dc08a4431a46e6816f2fa6d64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=oPwLNZQSJWj%2B2aYR4oUr9MrbEEk%3D" alt="连接错误.png" loading="lazy"/></p>
<p><strong>重试中状态</strong>：</p>
<ul>
<li>显示当前重试次数和延迟时间</li>
<li>使用指数退避算法（1s → 2s → 4s → 8s...）</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0852658ddf7d47da9bbabbddc984244a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=ALR1eFcv626oAutine4P7XHeuCE%3D" alt="重试中.png" loading="lazy"/></p>
<p><strong>传输完成</strong>：</p>
<ul>
<li>显示完整的输出内容</li>
<li>性能指标：总字数、总耗时、平均延迟</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb1ed7b22879466bb98f35a5108a12b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5p6X55qE57yW56iL5byA5Y-R5pel6K6w:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209228&amp;x-signature=AqunqCC4i34ldb65c6r5pnalff4%3D" alt="传输结束.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-14">篇章四：踩坑总结</h2>
<p>做这个 Demo 的过程中，我踩了不少坑。这里挑几个最经典的分享给你。</p>
<h3 data-id="heading-15">4.1 粘包/半包处理</h3>
<p><strong>坑</strong>：一开始我直接用 <code>split('\n\n')</code> 分割消息，结果经常出现 JSON 解析错误。</p>
<p><strong>原因</strong>：一个 chunk 可能包含半个 JSON，或者两条消息粘在一起。</p>
<p><strong>解决</strong>：维护 buffer，每次解析后把剩余部分留给下次：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>;
buffer += chunk;           <span class="hljs-comment">// 追加新数据</span>
<span class="hljs-keyword">const</span> messages = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n\n'</span>);
buffer = messages.<span class="hljs-title function_">pop</span>();   <span class="hljs-comment">// 保留最后一个（可能不完整）</span>
<span class="hljs-comment">// 处理前面的完整消息</span>
messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> <span class="hljs-title function_">parseMessage</span>(msg));
</code></pre>
<h3 data-id="heading-16">4.2 UTF-8 字符截断</h3>
<p><strong>坑</strong>：Dart 端经常出现乱码，特别是中文字符。</p>
<p><strong>原因</strong>：中文字符在 UTF-8 中占 3 字节，流可能把 3 字节截断。</p>
<p><strong>解决</strong>：使用 <code>utf8.decoder</code> 自动处理字节边界：</p>
<pre><code class="hljs language-dart" lang="dart">response
  .transform(utf8.decoder)      <span class="hljs-comment">// ✅ 自动处理 UTF-8 边界</span>
  .transform(<span class="hljs-keyword">const</span> LineSplitter())
  .listen(_parseLine);
</code></pre>
<h3 data-id="heading-17">4.3 重连时机判断</h3>
<p><strong>坑</strong>：服务器正常结束时也触发重连，导致死循环。</p>
<p><strong>原因</strong>：没区分"正常结束"和"异常断开"。</p>
<p><strong>解决</strong>：检查 <code>[DONE]</code> 信号：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">_handleEvent</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">event</span> === <span class="hljs-string">'close'</span> &amp;&amp; event.<span class="hljs-property">data</span> === <span class="hljs-string">'[DONE]'</span>) {
    <span class="hljs-comment">// 正常结束，不重连</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onCompleteCallback</span>();
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// ... 其他处理</span>
}

<span class="hljs-comment">// 在流关闭时判断</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();
  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-comment">// 如果收到了 [DONE]，说明正常结束</span>
    <span class="hljs-keyword">if</span> (receivedDoneSignal) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 否则可能是异常断开，触发重连</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_scheduleRetry</span>();
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<h3 data-id="heading-18">4.4 Nginx 缓冲问题</h3>
<p><strong>坑</strong>：部署到生产环境后，SSE 流半天不输出。</p>
<p><strong>原因</strong>：Nginx 默认会缓冲响应，等积累到一定大小才发送。</p>
<p><strong>解决</strong>：在响应头添加 <code>X-Accel-Buffering: no</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Accel-Buffering'</span>, <span class="hljs-string">'no'</span>);
</code></pre>
<p>或者在 Nginx 配置中：</p>
<pre><code class="hljs language-nginx" lang="nginx">proxy_buffering off;
</code></pre>
<hr/>
<h2 data-id="heading-19">最终章：总结与展望</h2>
<h3 data-id="heading-20">5.1 技术选型建议</h3>
<p><strong>什么时候用 SSE？</strong></p>
<ul>
<li>✅ AI 聊天助手（一问多答）</li>
<li>✅ 实时通知推送</li>
<li>✅ 股票/加密货币价格推送</li>
<li>✅ 服务器日志实时监控</li>
</ul>
<p><strong>什么时候用 WebSocket？</strong></p>
<ul>
<li>✅ 即时通讯（IM、聊天室）</li>
<li>✅ 在线协作（多人同时编辑）</li>
<li>✅ 游戏直播（需要高频双向交互）</li>
<li>✅ 远程桌面/控制</li>
</ul>
<h3 data-id="heading-21">5.2 本项目的核心特性</h3>
<p>我实现的这个 Demo，包含了以下生产级特性：</p>
<ul>
<li>✅ 支持 POST 请求（可以发送长 Prompt）</li>
<li>✅ 自定义 Header（支持 Authorization）</li>
<li>✅ 粘包/半包处理（buffer 缓冲区）</li>
<li>✅ 指数退避重连（1s → 2s → 4s → 8s...）</li>
<li>✅ Last-Event-ID 机制（断线续传）</li>
<li>✅ UTF-8 安全处理（Dart 端）</li>
<li>✅ 错误处理和日志</li>
</ul>
<h3 data-id="heading-22">5.3 开源地址</h3>
<p>项目已完全开源，欢迎 Star 和 PR：</p>
<p>🔗 <strong>GitHub</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fsse-research-demo" target="_blank" title="https://github.com/xinqingaa/sse-research-demo" ref="nofollow noopener noreferrer">github.com/xinqingaa/s…</a></p>
<p>包含：</p>
<ul>
<li>Node.js 后端（Express）</li>
<li>JavaScript 客户端（原生 JS，无依赖）</li>
<li>Dart 客户端（Flutter 友好）</li>
<li>交互式演示界面</li>
</ul>
<h3 data-id="heading-23">5.4 写在最后</h3>
<p>回看这一周的学习，我发现：</p>
<p><strong>技术选型没有银弹</strong>。SSE 不是万能的，WebSocket 也不是过时的。关键是要理解你的场景需求。</p>
<p>对于 AI 聊天这种"一问多答"的单向流式场景，SSE 就像量身定做的一样：</p>
<ul>
<li>简单（基于 HTTP）</li>
<li>可靠（内置重连）</li>
<li>高效（没有全双工的开销）</li>
<li>可调试（DevTools 直接看）</li>
</ul>
<p>而 WebSocket 的强大在于<strong>双向实时交互</strong>，但这在 AI 聊天场景下是"杀鸡用牛刀"。</p>
<p><strong>最后，如果这篇文章对你有帮助，点个赞吧～</strong></p>
<p>（完）</p>
<hr/>
<h2 data-id="heading-24">往期文章回顾</h2>
<h3 data-id="heading-25">LangGraph + React + Nest 全栈Agent</h3>
<p><a href="https://juejin.cn/post/7601384029611868175" target="_blank" title="https://juejin.cn/post/7601384029611868175">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Faivista_agent" target="_blank" title="https://github.com/xinqingaa/aivista_agent" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-26">Flutter 图片编辑器</h3>
<p><a href="https://juejin.cn/post/7571067260053585946" target="_blank" title="https://juejin.cn/post/7571067260053585946">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fflutter_img_editor" target="_blank" title="https://pub.dev/packages/flutter_img_editor" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fimage_editor" target="_blank" title="https://github.com/xinqingaa/image_editor" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-27">Flutter 全链路监控 SDK</h3>
<p><a href="https://juejin.cn/post/7564977973260173338" target="_blank" title="https://juejin.cn/post/7564977973260173338">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fflutter_monitor_sdk" target="_blank" title="https://pub.dev/packages/flutter_monitor_sdk" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Fflutter_monitor_sdk" target="_blank" title="https://github.com/xinqingaa/flutter_monitor_sdk" ref="nofollow noopener noreferrer">github</a></p>
<h3 data-id="heading-28">Flutter 全场景弹框组件</h3>
<p><a href="https://juejin.cn/post/7538324216594726950" target="_blank" title="https://juejin.cn/post/7538324216594726950">掘金文章</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Funified_popups" target="_blank" title="https://pub.dev/packages/unified_popups" ref="nofollow noopener noreferrer">pub.dev</a> | <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxinqingaa%2Funified_popups" target="_blank" title="https://github.com/xinqingaa/unified_popups" ref="nofollow noopener noreferrer">github</a></p>
<hr/>
<blockquote>
<p><strong>关于作者</strong></p>
<p>大家好，我是【小林】，一名 Flutter 开发工程师。近期在研究 AI Agent 和流式传输技术，欢迎关注我的掘金账号，获取更多技术分享。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让本地知识引导AI追踪社区变迁，让AI真正理解社会现象]]></title>    <link>https://juejin.cn/post/7603854784865746984</link>    <guid>https://juejin.cn/post/7603854784865746984</guid>    <pubDate>2026-02-09T02:40:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603854784865746984" data-draft-id="7604045354070081570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让本地知识引导AI追踪社区变迁，让AI真正理解社会现象"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2026-02-09T02:40:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让本地知识引导AI追踪社区变迁，让AI真正理解社会现象
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:40:21.000Z" title="Mon Feb 09 2026 02:40:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近有一项研究让我十分好奇，它似乎在尝试翻转我们熟悉的剧本——不是用人工智能去“分析”社区，而是让社区来“教会”人工智能如何看世界。这听起来像是一种充满温度的技术民主化实验。</p>
<p>通常，当我们谈论机器学习与城市变迁，总不免陷入一种略带冰冷的视角：算法扫描街景，识别模式，输出结论。但有没有可能，我们漏掉了故事里最关键的讲述者？那些在同一个街角目睹了数十年晨昏的居民，他们眼中的“变化”，是否才是定义变迁的真正标尺？</p>
<p>一项来自费城的研究正是这么做的。研究者没有将学术文献中的绅士化指标直接编码给AI，而是走进了社区的会议室，问了一个简单却深刻的问题：“在你们看来，什么样的新建筑，意味着‘他们’来了？”</p>
<p>答案具体而生动：“方方正正像个盒子”、“黑框大窗户”、“三层高，显得比老房子‘傲慢’”、“用了好多不同材质拼在一起”。这些来自日常观察的语言，成了机器学习模型最核心的“教材”。</p>
<p>于是，我们得以看到一种全新的协作：社区居民成为特征的“定义者”，历史街景图像成为厚重的“证据集”，而人工智能则充当了不知疲倦的“模式识别者”。它学习的不是抽象的理论，而是一个地方集体记忆与视觉经验的凝结。</p>
<p>这或许提醒我们，在面对技术尤其是AI时，我们并非只能被动接受它设定的框架。我们可以，也应该，将我们的地方知识、价值判断和生活经验，“反向编码”进技术的内核。 这不仅是让研究更“准”，或许也是让技术更“对”的一次尝试。</p>
<p>走在费城的某些街区，你可能会注意到一些“格格不入”的新建筑。它们线条方正、色调简约，窗户是巨大的黑色面板，在三层高的联排房屋中显得突兀。当地老居民会指着它们说：“看，这就是‘绅士化’来了。”</p>
<p>这不是一种主观感受，而正成为机器学习模型能够识别的视觉模式。一项发表于《PLoS One》的最新研究，尝试教AI识别美国城市中一种特定的绅士化现象——“新建绅士化”。与以往研究最大的不同在于，这次定义“何为绅士化特征”的，不是学者，而是生活在其中的社区居民。</p>
<h2 data-id="heading-0"><strong>问题：地图上的盲区</strong></h2>
<p>“绅士化”并非新词，它描述的是一个社区因富裕阶层迁入而发生的快速变迁。但传统研究多依赖人口普查数据（如收入、教育水平）或市政许可记录来描绘其图景。这些数据能告诉我们“谁来了”、“批了什么项目”，却难以回答一个更直观的问题：绅士化在街景中究竟长什么样？</p>
<p>更重要的是，绅士化的“长相”因地而异。在费城，涂鸦可能是社区艺术的表达，而非衰败的象征；即便是富裕社区，路边也可能有零散垃圾。若仅用“焕然一新”、“整洁美观”这类笼统标准去训练AI，很可能误读真正的社区脉络，甚至固化对贫困或投资的刻板印象。</p>
<p>于是，研究团队转向了那些最熟悉街道每寸变化的人。</p>
<h2 data-id="heading-1"><strong>方法：让社区定义“特征”</strong></h2>
<p>研究没有从理论或既有文献出发，而是走进了费城的三个街区：Port Richmond, Tacony, 和 Norris Square。在这里，他们组织了焦点小组，参与者多是居住数十年的中年女性，她们亲手打造社区花园，守护闲置空地，亲眼目睹了街角的每一次变迁。</p>
<p>讨论中，“新建绅士化”成为共识。与“经典绅士化”由个体修缮历史住宅不同，“新建绅士化”是开发商主导的大规模建设。用居民的话说，这些新楼就像“扎眼的拇指”，与周围环境截然不同。</p>
<p>从居民具体指认的街道和地标出发，研究团队结合历史街景图像，将“方盒子造型”、“黑色窗框”、“凸窗”、“混合建材”等具体建筑语言，提炼为一份识别清单（对应论文中表1）。这份清单，成了AI学习的“教材”。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c308f26ade3648cdb9501517b4c0a9c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=y%2BwqL5IKVEjkS9qs%2FxLIHANU%2F%2F4%3D" alt="screenshot_2026-02-06_15-36-17.png" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>训练：给AI一双“社区之眼”</strong></h2>
<p>有了“教材”，下一步是准备“习题集”。团队从谷歌街景中获取了费城2009-2013年和2017-2021年两个时间段的170多万张全景图像。经过复杂的空间、时间和语义分割过滤（比如剔除车辆、植被遮挡过多的图片），他们最终手动审核出1040组成对的“前后”图像，并依据社区协议打上“变化”（即绅士化）或“无变化”的标签。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbc9f57823a046c8824d6f7535279238~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=YCUoxRT5lHTSJrGrjt7Q9mE0oGE%3D" alt="screenshot_2026-02-06_15-37-07.png" loading="lazy"/></p>
<p>这些图像对清晰地展示了变化：从空地或旧宅，变为具有现代简约风格、三层高、材质对比鲜明的新建筑（如图2示例）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dbae095f5b241a2a33a0a2b297f6beb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=f%2BwP%2B5CcN8wmqtkCjaA%2FEP34COE%3D" alt="screenshot_2026-02-06_15-37-57.png" loading="lazy"/></p>
<p>随后，他们采用了一个名为Siamese ResNet-50的深度学习模型（其架构见图3）。这个模型的核心任务是比较同一地点的新旧两张图片，判断其间是否发生了符合“社区定义”的新建绅士化。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/abc44832f19a49d0a0869e3b6580df54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=u95ytBahCVW34ouAqwPFu2NXLWk%3D" alt="screenshot_2026-02-06_15-38-14.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>结果：AI学到了什么？</strong></h2>
<p>模型的表现超出了预期。在测试中，它的准确率和AUC（衡量区分能力的指标）都达到了84%。特别是它的“召回率”高达88%，意味着它能捕捉到绝大多数真实的绅士化案例。这证明，AI确实能从复杂的街景中，学会识别那些被社区居民共同指认的、具有地域特色的建筑特征（详细性能指标见表2，分类结果见图5）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3bda9250dbbd423280680f1b18f08791~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=9UgPzKKIomz5optMxtThoVGHH6E%3D" alt="screenshot_2026-02-06_15-38-39.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44e484cbe60e412c81348b1cc77bddb7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=ahnCij%2BNOfQmHfhQgVrdxeSkoxg%3D" alt="screenshot_2026-02-06_15-38-57.png" loading="lazy"/></p>
<p>更有趣的是与市政许可数据的对比。团队将模型识别出的点位与费城新建许可数据制成热力图，两者在空间分布上呈现出高度相似的趋势：绅士化活动密集于Lower North Philadelphia、Riverwards及南费城等区域（对比结果见图4）。这交叉验证了模型发现的可信度。当然，也存在差异：许可数据显示某些工业区改造活跃，但街景图像却因过去是封闭厂区而缺乏历史影像；反之，一些视觉上翻天覆地的“内部全面翻新”，在许可分类上可能不算“新建”。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bee67271bde049a3b4e1f70a47f6cc89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771209831&amp;x-signature=sVkaFh8BOkRYxBou2jlp1mUIe7g%3D" alt="screenshot_2026-02-06_15-39-45.png" loading="lazy"/></p>
<h2 data-id="heading-4"><strong>反思：技术的光与影</strong></h2>
<p>这项研究的价值，或许不在于创造了一个多高的准确率纪录。实际上，相比在独栋住宅为主的渥太华进行的研究（准确率95.6%），在建筑密集、视觉干扰多的费城取得84%的成绩，更显得珍贵。</p>
<p>它真正启示我们的是方法论：在运用“黑箱”AI处理复杂社会议题时，将定义问题的权力交还给切身相关的社区，是打开透明度和可信度的一把钥匙。 这避免了研究者的个人审美或偏见被无意中编码进算法，也让冰冷的图像识别，接续上了鲜活的地方性知识。</p>
<p>当然，局限同样明显。街景图像的可用性受制于拍摄时间、遮挡物（车辆、行人、天桥），这使得产出完整细致的绅士化地图仍然困难。AI模型可以成为一个强大的补充或预警工具，但在数据噪点极高的密集城区，短期内还难以完全取代传统的行政数据。</p>
<h2 data-id="heading-5"><strong>尾声：不止于地图</strong></h2>
<p>最终，这项研究绘制的不仅是一张绅士化潜力地图，更提供了一种思考城市变迁的新视角。当城市规划者、社区组织者和政策制定者试图理解绅士化、缓解其带来的 displacement （ displacement ）时，他们需要的不只是“哪里变了”，更是“什么变了”以及“这对当地人意味着什么”。</p>
<p>费城的实验表明，通过融合社区智慧与机器学习的敏锐，我们或许能更早地“看见”那些正在改变街区的力量，并以更贴近在地感受的方式，进行记录、讨论与应对。技术终究是工具，而定义城市未来的，永远是人。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手]]></title>    <link>https://juejin.cn/post/7603574149774049332</link>    <guid>https://juejin.cn/post/7603574149774049332</guid>    <pubDate>2026-02-07T03:16:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603574149774049332" data-draft-id="7603588665567412264" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-07T03:16:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 封装 Axios 实战：从基础到生产级，新手也能秒上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T03:16:14.000Z" title="Sat Feb 07 2026 03:16:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Vue3 项目开发中，Axios 是最常用的 HTTP 请求库，但直接在组件中裸写 Axios 会导致代码冗余、难以维护——比如每个请求都要写重复的 baseURL、请求头、错误处理，接口变更时要改遍所有组件。</p>
<p>而<strong>合理封装 Axios</strong> 能解决这些问题：统一管理请求配置、全局处理拦截器、标准化错误提示、支持取消重复请求……既能提升开发效率，又能让代码更健壮。</p>
<p>今天这篇文章，就带你从零实现 Vue3 + Vite 项目中 Axios 的<strong>生产级封装</strong>，从基础结构到进阶优化，每一步都有完整代码示例，直接复制就能用！适配 Vue3 组合式 API（
</p><h2 data-id="heading-0">一、前置准备：安装 Axios</h2>
<p>首先确保你的 Vue3 项目已搭建完成（推荐用 Vite 搭建），然后安装 Axios，TS 项目需额外安装类型声明：</p>
<pre><code class="hljs language-js" lang="js"># 安装核心 <span class="hljs-title class_">Axios</span> 库
npm install axios
# 可选：<span class="hljs-variable constant_">TS</span> 项目必装（提供类型提示，避免报错）
npm install @types/axios --save-dev
</code></pre>
<h2 data-id="heading-1">二、基础版封装：核心结构（新手友好）</h2>
<p>基础版封装聚焦「统一配置 + 简化调用」，适合小型项目或新手入门，核心实现 3 个功能：统一 baseURL、全局请求/响应拦截、简化请求调用。</p>
<p>封装步骤：在 src 目录下新建 <code>utils/request.js</code>（JS 项目）或 <code>utils/request.ts</code>（TS 项目），作为 Axios 封装的核心文件。</p>
<h3 data-id="heading-2">2.1 JS 版本（基础版）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span> <span class="hljs-comment">// 可选：结合UI库做错误提示（推荐）</span>

<span class="hljs-comment">// 1. 创建 Axios 实例，配置基础参数</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>, <span class="hljs-comment">// 环境变量（推荐，区分开发/生产）</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 超时时间（单位：ms），超过则中断请求</span>
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span> <span class="hljs-comment">// 默认请求头</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器（请求发送前执行）</span>
<span class="hljs-comment">// 作用：添加token、统一修改请求参数格式等</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-comment">// 示例：添加token（登录后存储在localStorage，根据实际项目调整）</span>
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span> <span class="hljs-comment">// 拼接token格式（后端约定）</span>
    }
    <span class="hljs-keyword">return</span> config <span class="hljs-comment">// 必须返回config，否则请求会中断</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 请求发送失败（如网络中断、参数错误）</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error) <span class="hljs-comment">// 抛出错误，供组件捕获处理</span>
  }
)

<span class="hljs-comment">// 3. 响应拦截器（请求返回后执行，先于组件接收）</span>
<span class="hljs-comment">// 作用：统一处理响应数据、拦截错误（如token过期、接口报错）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-comment">// 只返回响应体中的data（多数后端接口会包裹一层code/message/data）</span>
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>

    <span class="hljs-comment">// 示例：根据后端约定的code判断请求是否成功（常见约定：200=成功）</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-comment">// 非200状态码，视为业务错误（如参数错误、权限不足）</span>
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span> <span class="hljs-comment">// 返回真正的业务数据，组件可直接使用</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 响应失败（如超时、后端报错、404/500状态码）</span>
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-comment">// 区分不同错误类型，给出更精准提示</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// 有响应，但状态码非2xx（如401token过期、404接口不存在、500后端报错）</span>
      <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
          errorMsg = <span class="hljs-string">'登录已过期，请重新登录'</span>
          <span class="hljs-comment">// 额外操作：清除过期token，跳转到登录页（结合Vue Router）</span>
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
          errorMsg = <span class="hljs-string">'请求的接口不存在'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
          errorMsg = <span class="hljs-string">'后端服务异常，请稍后重试'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-attr">default</span>:
          errorMsg = error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">message</span> || errorMsg
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      <span class="hljs-comment">// 无响应（如网络中断、超时）</span>
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装常用请求方法（get/post/put/delete），简化组件调用</span>
<span class="hljs-comment">// get请求：params传参（拼接在URL后）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
    params
  })
}

<span class="hljs-comment">// post请求：data传参（请求体中）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
    data
  })
}

<span class="hljs-comment">// put请求（修改数据）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">put</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
    data
  })
}

<span class="hljs-comment">// delete请求（删除数据）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">del</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'delete'</span>,
    params
  })
}

<span class="hljs-comment">// 导出Axios实例（特殊场景可直接使用，如取消请求）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service
</code></pre>
<h3 data-id="heading-3">2.2 TS 版本（基础版，补充类型提示）</h3>
<p>TS 项目需添加类型声明，避免类型报错，提升开发体验，核心修改的是「请求/响应类型」和「参数类型」：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.ts</span>
<span class="hljs-keyword">import</span> axios, { <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span>, <span class="hljs-title class_">AxiosError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 定义后端响应的统一格式（根据你的后端接口调整）</span>
interface <span class="hljs-title class_">ResponseData</span>&lt;T = any&gt; {
  <span class="hljs-attr">code</span>: number
  <span class="hljs-attr">message</span>: string
  <span class="hljs-attr">data</span>: T
}

<span class="hljs-comment">// 1. 创建Axios实例</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token &amp;&amp; config.<span class="hljs-property">headers</span>) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error: AxiosError</span>) =&gt;</span> {
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response: AxiosResponse&lt;ResponseData&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span> <span class="hljs-comment">// 返回业务数据，自动推导类型</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error: AxiosError&lt;ResponseData&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-keyword">const</span> status = error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>
      <span class="hljs-keyword">switch</span> (status) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
          errorMsg = <span class="hljs-string">'登录已过期，请重新登录'</span>
          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>)
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
          errorMsg = <span class="hljs-string">'请求的接口不存在'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
          errorMsg = <span class="hljs-string">'后端服务异常，请稍后重试'</span>
          <span class="hljs-keyword">break</span>
        <span class="hljs-attr">default</span>:
          errorMsg = error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">message</span> || errorMsg
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装请求方法，添加类型声明</span>
<span class="hljs-comment">// get请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> get = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, params?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
    params,
    ...config
  })
}

<span class="hljs-comment">// post请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> post = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, data?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
    data,
    ...config
  })
}

<span class="hljs-comment">// put请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> put = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, data?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
    data,
    ...config
  })
}

<span class="hljs-comment">// delete请求</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> del = &lt;T = any&gt;(<span class="hljs-attr">url</span>: string, params?: <span class="hljs-title class_">Record</span>&lt;string, any&gt;, config?: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>({
    url,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'delete'</span>,
    params,
    ...config
  })
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service
</code></pre>
<h3 data-id="heading-4">2.3 环境变量配置（关键步骤）</h3>
<p>上面封装中用到的<code>import.meta.env.VITE_API_BASE_URL</code>，是 Vite 的环境变量，用于区分「开发环境」和「生产环境」的接口地址，避免手动修改。</p>
<p>在项目根目录新建 2 个文件：<code>.env.development</code>（开发环境）和 <code>.env.production</code>（生产环境）：</p>
<pre><code class="hljs language-js" lang="js"># .<span class="hljs-property">env</span>.<span class="hljs-property">development</span>（开发环境，npm run dev 时生效）
<span class="hljs-variable constant_">VITE_API_BASE_URL</span> = <span class="hljs-string">'http://localhost:3000/api'</span> # 本地后端接口地址

# .<span class="hljs-property">env</span>.<span class="hljs-property">production</span>（生产环境，npm run build 时生效）
<span class="hljs-variable constant_">VITE_API_BASE_URL</span> = <span class="hljs-string">'https://api.yourdomain.com'</span> # 线上后端接口地址
</code></pre>
<p>注意：Vite 环境变量必须以<code>VITE_</code> 开头，否则无法读取。</p>
<h3 data-id="heading-5">2.4 组件中如何使用（简化调用）</h3>
<p>封装完成后，在 Vue3 组件（支持 
</p><pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-comment">// 导入封装好的请求方法</span>
<span class="hljs-keyword">import</span> { get, post } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> userList = <span class="hljs-title function_">ref</span>([])

<span class="hljs-comment">// 1. get请求（获取用户列表，params传参）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 直接调用，无需写baseURL、请求头</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/user/list'</span>, { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> })
    userList.<span class="hljs-property">value</span> = res <span class="hljs-comment">// 直接使用响应数据（已过滤外层code/message）</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 可选：组件内单独处理错误（全局已处理过，这里可省略）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取用户列表失败：'</span>, error)
  }
}

<span class="hljs-comment">// 2. post请求（提交表单，data传参）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">submitForm</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">formData</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/add'</span>, formData)
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'提交成功'</span>)
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 无需额外提示，全局响应拦截器已做错误提示</span>
  }
}

<span class="hljs-comment">// 页面挂载时调用get请求</span>
<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">getUserList</span>()
})
&lt;/script&gt;
</code></pre>
<p>对比裸写 Axios，封装后的调用更简洁，且所有请求的配置、错误处理都统一管理，后续修改接口地址、token 格式，只需改 <code>request.js/ts</code> 一个文件。</p>
<h2 data-id="heading-6">三、进阶版封装：生产级优化（必看）</h2>
<p>基础版封装能满足小型项目，但在中大型项目中，还需要补充「取消重复请求、请求loading、接口加密、异常重试」等功能，让封装更健壮、更贴合生产需求。</p>
<h3 data-id="heading-7">3.1 优化1：取消重复请求（避免接口冗余）</h3>
<p>场景：用户快速点击两次按钮，会发起两次相同的请求（如提交表单），导致后端重复处理。解决方案：用 Axios 的 CancelToken（Axios 0.x）或 AbortController（Axios 1.x+）取消重复请求。</p>
<p>以下是 Axios 1.x+ 版本（当前最新版）的实现方式（AbortController 更规范）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js（仅修改新增部分，其余代码不变）</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 存储正在请求的接口（key：请求标识，value：AbortController实例）</span>
<span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()

<span class="hljs-comment">// 生成请求标识（url + method + 参数，确保唯一）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">generateRequestKey</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> { url, method, params, data } = config
  <span class="hljs-comment">// 序列化参数，避免相同请求因参数顺序不同被误判为不同请求</span>
  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params || {})
  <span class="hljs-keyword">const</span> dataStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data || {})
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${url}</span>-<span class="hljs-subst">${method}</span>-<span class="hljs-subst">${paramsStr}</span>-<span class="hljs-subst">${dataStr}</span>`</span>
}

<span class="hljs-comment">// 取消重复请求</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">cancelPendingRequest</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
  <span class="hljs-comment">// 如果有重复请求，取消之前的</span>
  <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestKey)) {
    <span class="hljs-keyword">const</span> controller = pendingRequests.<span class="hljs-title function_">get</span>(requestKey)
    controller.<span class="hljs-title function_">abort</span>() <span class="hljs-comment">// 取消请求</span>
    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey) <span class="hljs-comment">// 移除取消的请求</span>
  }
}

<span class="hljs-comment">// 1. 创建Axios实例（新增signal配置）</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_BASE_URL</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json;charset=utf-8'</span>
  }
})

<span class="hljs-comment">// 2. 请求拦截器（修改：添加取消重复请求逻辑）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-comment">// 取消重复请求（发起当前请求前，取消之前相同的请求）</span>
    <span class="hljs-title function_">cancelPendingRequest</span>(config)
    <span class="hljs-comment">// 创建AbortController实例，用于取消请求</span>
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>()
    config.<span class="hljs-property">signal</span> = controller.<span class="hljs-property">signal</span>
    <span class="hljs-comment">// 存储当前请求</span>
    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
    pendingRequests.<span class="hljs-title function_">set</span>(requestKey, controller)
    
    <span class="hljs-comment">// 添加token（原有逻辑不变）</span>
    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器（修改：移除已完成的请求）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span>
    <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(config)
    pendingRequests.<span class="hljs-title function_">delete</span>(requestKey) <span class="hljs-comment">// 请求完成，移除存储</span>
    
    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span>
    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) {
      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'接口请求失败，请重试'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(res.<span class="hljs-property">message</span> || <span class="hljs-string">'请求失败'</span>))
    }
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-comment">// 处理取消请求的错误（单独捕获，不提示用户）</span>
    <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(error)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求已取消：'</span>, error.<span class="hljs-property">message</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求已取消'</span>))
    }
    
    <span class="hljs-comment">// 移除失败的请求</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {
      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-title function_">generateRequestKey</span>(error.<span class="hljs-property">config</span>)
      pendingRequests.<span class="hljs-title function_">delete</span>(requestKey)
    }
    
    <span class="hljs-comment">// 原有错误处理逻辑不变</span>
    <span class="hljs-keyword">let</span> errorMsg = <span class="hljs-string">'请求异常，请联系管理员'</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// ... 原有状态码判断逻辑</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      errorMsg = <span class="hljs-string">'网络异常或请求超时，请检查网络'</span>
    }
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(errorMsg)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 4. 封装请求方法（不变）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = {}</span>) =&gt; { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, data = {}</span>) =&gt; { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-comment">// ... 其余方法</span>
</code></pre>
<h3 data-id="heading-8">3.2 优化2：全局请求 Loading（提升交互体验）</h3>
<p>场景：请求耗时较长时，用户不知道是否在加载，容易重复点击。解决方案：添加全局 Loading，所有请求发起时显示 Loading，全部请求完成后隐藏。</p>
<p>结合 Element Plus 的 ElLoading 实现（需安装 Element Plus）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/utils/request.js（新增Loading相关逻辑）</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span>, <span class="hljs-title class_">ElLoading</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-comment">// 新增：Loading实例和请求计数</span>
<span class="hljs-keyword">let</span> loadingInstance = <span class="hljs-literal">null</span> <span class="hljs-comment">// Loading实例</span>
<span class="hljs-keyword">let</span> requestCount = <span class="hljs-number">0</span> <span class="hljs-comment">// 请求计数器（避免多个请求重复显示/隐藏Loading）</span>

<span class="hljs-comment">// 显示Loading</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">showLoading</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">if</span> (requestCount === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 只有当没有请求时，才显示Loading</span>
    loadingInstance = <span class="hljs-title class_">ElLoading</span>.<span class="hljs-title function_">service</span>({
      <span class="hljs-attr">lock</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">text</span>: <span class="hljs-string">'加载中...'</span>,
      <span class="hljs-attr">background</span>: <span class="hljs-string">'rgba(0, 0, 0, 0.5)'</span>
    })
  }
  requestCount++
}

<span class="hljs-comment">// 隐藏Loading</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">hideLoading</span> = (<span class="hljs-params"/>) =&gt; {
  requestCount--
  <span class="hljs-keyword">if</span> (requestCount === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 所有请求完成后，才隐藏Loading</span>
    loadingInstance?.<span class="hljs-title function_">close</span>()
  }
}

<span class="hljs-comment">// 1. 创建Axios实例（不变）</span>
<span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>({ <span class="hljs-comment">/* ... */</span> })

<span class="hljs-comment">// 2. 请求拦截器（新增：显示Loading）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    <span class="hljs-title function_">showLoading</span>() <span class="hljs-comment">// 发起请求时显示Loading</span>
    <span class="hljs-comment">// ... 原有取消重复请求、添加token逻辑</span>
    <span class="hljs-keyword">return</span> config
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 请求失败，隐藏Loading</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求发送失败，请检查网络或参数'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)

<span class="hljs-comment">// 3. 响应拦截器（新增：隐藏Loading）</span>
service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 请求成功，隐藏Loading</span>
    <span class="hljs-comment">// ... 原有移除重复请求、处理响应逻辑</span>
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  },
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-title function_">hideLoading</span>() <span class="hljs-comment">// 响应失败，隐藏Loading</span>
    <span class="hljs-comment">// ... 原有错误处理逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  }
)
</code></pre>
<p>注意：requestCount 计数器是关键，避免多个请求同时发起时，单个请求完成就隐藏 Loading。</p>
<h3 data-id="heading-9">3.3 优化3：接口模块化管理（中大型项目必做）</h3>
<p>场景：项目接口较多时，所有请求都写在组件中，会导致代码混乱，后续维护困难。解决方案：将接口按模块拆分，统一管理在 <code>api</code> 文件夹中。</p>
<p>步骤：在 src 目录下新建<code>api</code> 文件夹，按业务模块拆分文件（如 <code>api/user.js</code>、<code>api/goods.js</code>）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// src/api/user.js（用户模块接口）</span>
<span class="hljs-keyword">import</span> { get, post, put, del } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-comment">// 接口模块化封装，每个接口对应一个函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userApi = {
  <span class="hljs-comment">// 获取用户列表</span>
  <span class="hljs-attr">getUserList</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/user/list'</span>, params),
  <span class="hljs-comment">// 添加用户</span>
  <span class="hljs-attr">addUser</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/add'</span>, data),
  <span class="hljs-comment">// 修改用户信息</span>
  <span class="hljs-attr">editUser</span>: <span class="hljs-function">(<span class="hljs-params">id, data</span>) =&gt;</span> <span class="hljs-title function_">put</span>(<span class="hljs-string">`/user/<span class="hljs-subst">${id}</span>`</span>, data),
  <span class="hljs-comment">// 删除用户</span>
  <span class="hljs-attr">deleteUser</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">del</span>(<span class="hljs-string">'/user/delete'</span>, { id }),
  <span class="hljs-comment">// 用户登录</span>
  <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">'/user/login'</span>, data)
}

<span class="hljs-comment">// src/api/goods.js（商品模块接口）</span>
<span class="hljs-keyword">import</span> { get, post } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/request'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> goodsApi = {
  <span class="hljs-comment">// 获取商品详情</span>
  <span class="hljs-attr">getGoodsDetail</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">`/goods/<span class="hljs-subst">${id}</span>`</span>),
  <span class="hljs-comment">// 搜索商品</span>
  <span class="hljs-attr">searchGoods</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">'/goods/search'</span>, params)
}
</code></pre>
<p>组件中使用时，直接导入对应模块的接口，代码更清晰、更易维护：</p>
<pre><code class="hljs language-js" lang="js">&lt;script setup&gt;
<span class="hljs-comment">// 导入用户模块接口</span>
<span class="hljs-keyword">import</span> { userApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/user'</span>
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> userList = <span class="hljs-title function_">ref</span>([])

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 直接调用接口函数，参数清晰</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> userApi.<span class="hljs-title function_">getUserList</span>({ <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> })
    userList.<span class="hljs-property">value</span> = res
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)
  }
}

<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">getUserList</span>()
})
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-10">3.4 其他生产级优化（可选，按需添加）</h3>
<ol>
<li><strong>请求重试</strong>：针对网络波动导致的请求失败，自动重试 1-2 次（避免用户手动重试），用 axios-retry 插件实现。</li>
<li><strong>请求加密</strong>：敏感接口（如登录、支付）的参数加密（如 AES 加密），在请求拦截器中处理参数加密。</li>
<li><strong>接口日志</strong>：开发环境打印请求/响应日志（便于调试），生产环境关闭日志（避免泄露敏感信息）。</li>
<li><strong>自定义请求头</strong>：支持部分接口单独设置请求头（如文件上传接口设置 Content-Type: multipart/form-data）。</li>
</ol>
<h2 data-id="heading-11">四、避坑指南（新手必看）</h2>
<ol>
<li><strong>环境变量读取失败</strong>：Vite 环境变量必须以 <code>VITE_</code> 开头，且只能在客户端代码中读取，不能在服务端代码中使用。</li>
<li><strong>token 失效未跳转</strong>：确保响应拦截器中 401 状态码的判断逻辑正确，且 <code>window.location.href = '/login'</code> 没有被注释，同时检查 token 是否正确存储/清除。</li>
<li><strong>重复请求取消无效</strong>：请求标识（requestKey）必须唯一，确保 params 和 data 被正确序列化（避免因参数顺序不同导致标识不同）。</li>
<li><strong>Loading 闪烁</strong>：请求耗时过短（如 100ms 内完成），会导致 Loading 一闪而过，可添加 Loading 延迟显示（如 300ms 后显示，避免闪烁）。</li>
<li><strong>TS 类型报错</strong>：确保后端响应格式和定义的 <code>ResponseData</code> 接口一致，否则会出现类型不匹配报错。</li>
<li><strong>文件上传接口失败</strong>：文件上传接口需单独设置请求头 <code>'Content-Type': 'multipart/form-data'</code>，且传参用 FormData 格式。</li>
</ol>
<h2 data-id="heading-12">五、总结</h2>
<p>Vue3 封装 Axios 的核心是「统一管理 + 简化调用 + 异常处理」，从基础版的拦截器封装，到进阶版的重复请求取消、Loading 优化、接口模块化，一步步提升封装的健壮性和实用性。</p>
<p>总结几个关键要点：</p>
<ul>
<li>用 <code>axios.create()</code> 创建实例，统一配置 baseURL、超时时间等。</li>
<li>请求拦截器：添加 token、取消重复请求、显示 Loading。</li>
<li>响应拦截器：统一处理响应数据、拦截错误（token 过期、404/500）、隐藏 Loading。</li>
<li>中大型项目：接口按模块拆分，提升代码可维护性。</li>
<li>生产环境：补充取消重复请求、请求加密等优化，让封装更健壮。</li>
</ul>
<p>封装完成后，后续开发只需专注于业务逻辑，无需关注请求的底层配置，极大提升开发效率。本文的封装方案适配绝大多数 Vue3 项目，大家可根据自己的后端接口规范和业务需求，灵活调整拦截器逻辑和接口格式。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零实现富文本编辑器#11-Immutable状态维护与增量渲染]]></title>    <link>https://juejin.cn/post/7604084016510353449</link>    <guid>https://juejin.cn/post/7604084016510353449</guid>    <pubDate>2026-02-09T02:48:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604084016510353449" data-draft-id="7603895839557419071" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从零实现富文本编辑器#11-Immutable状态维护与增量渲染"/> <meta itemprop="keywords" content="前端,架构,前端框架"/> <meta itemprop="datePublished" content="2026-02-09T02:48:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="WindRunnerMax"/> <meta itemprop="url" content="https://juejin.cn/user/1829999989247214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从零实现富文本编辑器#11-Immutable状态维护与增量渲染
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1829999989247214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    WindRunnerMax
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-09T02:48:19.000Z" title="Mon Feb 09 2026 02:48:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在先前我们讨论了视图层的适配器设计，主要是全量的视图初始化渲染，包括生命周期同步、状态管理、渲染模式、<code>DOM</code>映射状态等。在这里我们需要处理变更的增量更新，这属于性能方面的考量，需要考虑如何实现不可变的状态对象，以此来实现<code>Op</code>操作以及最小化<code>DOM</code>变更。</p>
<ul>
<li>开源地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FBlockKit" target="_blank" title="https://github.com/WindRunnerMax/BlockKit" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
<li>在线编辑: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwindrunnermax.github.io%2FBlockKit%2F" target="_blank" title="https://windrunnermax.github.io/BlockKit/" ref="nofollow noopener noreferrer">windrunnermax.github.io/BlockKit/</a></li>
<li>项目笔记: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FBlockKit%2Fblob%2Fmaster%2FNOTE.md" target="_blank" title="https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
</ul>
<details>
<summary><strong>从零实现富文本编辑器系列文章</strong></summary>
<ul>
<li><a href="https://juejin.cn/post/7490554094412611636" target="_blank" title="https://juejin.cn/post/7490554094412611636">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>
<li><a href="https://juejin.cn/post/7492339631700377652" target="_blank" title="https://juejin.cn/post/7492339631700377652">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>
<li><a href="https://juejin.cn/post/7494920513967112227" target="_blank" title="https://juejin.cn/post/7494920513967112227">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>
<li><a href="https://juejin.cn/post/7508648111485665295" target="_blank" title="https://juejin.cn/post/7508648111485665295">从零实现富文本编辑器#4-浏览器选区模型的核心交互策略</a></li>
<li><a href="https://juejin.cn/post/7513183180091523107" target="_blank" title="https://juejin.cn/post/7513183180091523107">从零实现富文本编辑器#5-编辑器选区模型的状态结构表达</a></li>
<li><a href="https://juejin.cn/post/7534162607894347828" target="_blank" title="https://juejin.cn/post/7534162607894347828">从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步</a></li>
<li><a href="https://juejin.cn/post/7544561402783793192" target="_blank" title="https://juejin.cn/post/7544561402783793192">从零实现富文本编辑器#7-基于组合事件的半受控输入模式</a></li>
<li><a href="https://juejin.cn/post/7562526517516812331" target="_blank" title="https://juejin.cn/post/7562526517516812331">从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为</a></li>
<li><a href="https://juejin.cn/spost/7585778343352221759" target="_blank" title="https://juejin.cn/spost/7585778343352221759">从零实现富文本编辑器#9-编辑器文本结构变更的受控处理</a></li>
<li><a href="https://juejin.cn/spost/7593702885880725540" target="_blank" title="https://juejin.cn/spost/7593702885880725540">从零实现富文本编辑器#10-React视图层适配器的模式扩展</a></li>
<li><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer">从零实现富文本编辑器#11-Immutable状态维护与增量渲染</a></li>
</ul>
</details>
<h2 data-id="heading-0">行级不可变状态</h2>
<p>在这里我们先不引入视图层的渲染问题，而是仅在<code>Model</code>层面上实现精细化的处理，具体来说就是实现不可变的状态对象，仅更新的节点才会被重新创建，其他节点则直接复用。由此想来此模块的实现颇为复杂，也并未引入<code>immer</code>等框架，而是直接处理的状态对象，因此先从简单的更新模式开始考虑。</p>
<p>回到最开始实现的<code>State</code>模块更新文档内容，我们是直接重建了所有的<code>LineState</code>以及<code>LeafState</code>对象，然后在<code>React</code>视图层的<code>BlockModel</code>中监听了<code>OnContentChange</code>事件，以此来将<code>BlockState</code>的更新应用到视图层。</p>
<pre><code class="hljs language-js" lang="js">delta.<span class="hljs-title function_">eachLine</span>(<span class="hljs-function">(<span class="hljs-params">line, attributes, index</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> lineState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineState</span>(line, attributes, <span class="hljs-variable language_">this</span>);
  lineState.<span class="hljs-property">index</span> = index;
  lineState.<span class="hljs-property">start</span> = offset;
  lineState.<span class="hljs-property">key</span> = <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(lineState);
  offset = offset + lineState.<span class="hljs-property">length</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>[index] = lineState;
});
</code></pre>
<p>这种方式简单直接，全量更新状态能够保证在<code>React</code>的状态更新，然而这种方式的问题在于性能。当文档内容非常大的时候，全量计算将会导致大量的状态重建，并且其本身的改变也会导致<code>React</code>的<code>diff</code>差异进而全量更新文档视图，这样的性能开销通常是不可接受的。</p>
<p>那么通常来说我们就需要基于变更来确定状态的更新，首先我们需要确定更新的粒度，例如以行为基准则未变更的时候就直接取原有的<code>LineState</code>。相当于尽可能复用<code>Origin List</code>然后生成<code>Target List</code>，这样的方式自然可以避免部分状态的重建，尽可能复用原本的对象。</p>
<p>整体思路大概是先执行变成生成最新的列表，然后分别设置旧列表和新列表的<code>row</code>和<code>col</code>两个指针值，然后更新时记录起始<code>row</code>，删除和新增自然是正常处理，对于更新则认为是先删后增。对于内容的处理则需要分别讨论单行和跨行的问题，中间部分的内容就作为重建的操作。</p>
<p>最后可以将这部分增删<code>LineState</code>数据放置于<code>Changes</code>中，就可以得到实际增删的<code>Ops</code>了，这样我们就可以优化部分的性能，因为仅原列表和目标列表的中间部分才会重建，其他部分的行状态直接复用。此外这部分数据在<code>apply</code>的<code>delta</code>中是不存在的，同样可以认为是数据的补充。</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-title class_">Origin</span> <span class="hljs-title class_">List</span> (<span class="hljs-title class_">Old</span>)                          <span class="hljs-title class_">Target</span> <span class="hljs-title class_">List</span> (<span class="hljs-title class_">New</span>)
+-------------------+                      +-------------------+
| [<span class="hljs-number">0</span>] <span class="hljs-title class_">LineState</span> A   | &lt;---- Retain ------&gt; | [0] LineState A   | (Reused)
+-------------------+                      +-------------------+
| [1] LineState B   |          |           | [1] LineState B2  | (Update)
+-------------------+       Changes        |     (Modified)    | (Del C)
| [2] LineState C   |          |           +-------------------+
+-------------------+          V           | [2] NewState X    | (Inserted)
| [3] LineState D   | ---------------\     +-------------------+
+-------------------+                 --&gt; | [3] LineState D   | (Reused)
| [4] LineState E   | &lt;---- Retain ------&gt; | [4] LineState E   | (Reused)
+-------------------+                      +-------------------+
</code></pre>
<p>那么这里实际上是存在非常需要关注的点，我们现在维护的是状态模型，也就是说所有的更新就不再是直接的<code>compose</code>，而是操作我们实现的状态对象。本质上我们是需要实现行级别的<code>compose</code>方法，这里的实现非常重要，假如我们对于数据的处理存在偏差的话，那么就会导致状态出现问题。</p>
<p>此外在这种方式中，我们判断<code>LineState</code>是否需要新建则是根据整个行内的所有<code>LeafState</code>来重建的。也就是说这种时候我们是需要再次将所有的<code>op</code>遍历一遍，当然实际上由于最后还需要将<code>compose</code>后的<code>Delta</code>切割为行级别的内容，所以其实即使在应用变更后也最少需要再遍历两次。</p>
<p>那么此时我们需要思考优化方向，首先是首个<code>retain</code>，在这里我们应该直接完整复用原本的<code>LineState</code>，包括处理后的剩余节点也是如此。而对于中间的节点，我们就需要为其独立设计更新策略，这部分理论上来说是需要完全独立处理为新的状态对象的，这样可以减少部分<code>Leaf Op</code>的遍历。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Delta</span>().<span class="hljs-title function_">retain</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">insert</span>(<span class="hljs-string">"xx"</span>)
<span class="hljs-title function_">insert</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>) <span class="hljs-comment">// skip </span>
<span class="hljs-title function_">insert</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>) <span class="hljs-comment">// new line state</span>
</code></pre>
<p>其中，如果是新建的节点，我们直接构建新的<code>LineState</code>即可，删除的节点则不从原本的<code>LineState</code>中放置于新的列表。而对于更新的节点，我们需要更新原本的<code>LineState</code>对象，因为实际上行是存在更新的，而重点是我们需要将原本的<code>LineState</code>的<code>key</code>值复用。</p>
<p>这里我们先简单实现实现描述一下复用的问题，比较方便的实现则是直接以<code>\n</code>的标识为目标的<code>State</code>，这就意味着我们要独立<code>\n</code>为独立的状态。即如果在<code>123|456\n</code>的<code>|</code>位置插入<code>\n</code>的话，那么我们就是<code>123</code>是新的<code>LineState</code>，<code>456</code>是原本的<code>LineState</code>，以此来实现<code>key</code>的复用。</p>
<pre><code class="hljs language-js" lang="js">[
  <span class="hljs-title function_">insert</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>), 
  <span class="hljs-title function_">insert</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title function_">insert</span>(<span class="hljs-string">"\n"</span>)
]
<span class="hljs-comment">// ===&gt;</span>
[ 
  <span class="hljs-title class_">LineState</span>(<span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"123"</span>), <span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>)), 
  <span class="hljs-title class_">LineState</span>(<span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"456"</span>), <span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>))
]
</code></pre>
<p>其实这里有个非常值得关注的点是，<code>LineState</code>在<code>Delta</code>中是没有具体对应的<code>Op</code>的，而相对应的<code>LeafState</code>则是有具体的<code>Op</code>的。这就意味着我们在处理<code>LineState</code>的更新时，是不能直接根据变更控制的，因此必须要找到能够映射的状态，因此最简单的方案即根据<code>\n</code>节点映射。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">LeafState</span>(<span class="hljs-string">"\n"</span>, key=<span class="hljs-string">"1"</span>) &lt;=&gt; <span class="hljs-title class_">LineState</span>(key=<span class="hljs-string">"L1"</span>)
</code></pre>
<p>实际上我们可以总结一下，最开始我们考虑先更新再<code>diff</code>，后来考虑的是边更新边记录。边更新边记录的优点在于，可以避免再次遍历一边所有<code>Leaf</code>节点的消耗，同时也可以避免<code>diff</code>的复杂性。但是这里也存在个问题，如果内部进行了多次<code>retain</code>操作，则无法直接复用<code>LineState</code>。</p>
<p>不过通常来说，最高频的操作是输入内容，这种情况下首操作一般都是<code>retain</code>，尾操作为空会收集剩余文档内容，因此这部分优化是会被高频触发的。而如果是多次的内容部分变更操作，这部分虽然可以通过判断行内的叶子结点是否变更，来判断是否复用行对象，但是也存在一定复杂性。</p>
<p>关于这部分的具体实现，在编辑器的状态模块里存在独立的<code>Mutate</code>模块，这部分实现在后边实现各个模块时会独立介绍。到这里我们就可以实现一个简单的<code>Immutable</code>状态维护，如果<code>Leaf</code>节点发生变化之后，其父节点<code>Line</code>会触发更新，而其他节点则可以直接复用。</p>
<h2 data-id="heading-1">Key 值维护</h2>
<p>至此我们实现了一套简单的<code>Immutable Delta+Iterator</code>来处理更新，这种时候我们就可以借助不可变的方式来实现<code>React</code>视图的更新，那么在<code>React</code>的渲染模式中，<code>key</code>值的管理也是个值的探讨的问题。</p>
<p>在这里我们就可以根据状态不可变来生成<code>key</code>值，借助<code>WeakMap</code>映射关系获取对应的字符串<code>id</code>值，此时就可以借助<code>key</code>的管理以及<code>React.memo</code>来实现视图的复用。其实在这里初步看起来<code>key</code>值应该是需要主动控制强制刷新的时候，以及完全是新节点才会用得到的。</p>
<p>但是这种方式也是有问题的，因为此时我们即使输入简单的内容，也会导致整个行的<code>key</code>发生改变，而此时我们是不必要更新此时的<code>key</code>的。因此<code>key</code>值是需要单独维护的，不能直接使用不可变的对象来索引<code>key</code>值，那么如果是直接使用<code>index</code>作为<code>key</code>值的话，就会存在潜在的原地复用问题。</p>
<p><code>key</code>值原地复用会导致组件的状态被错误保留，例如此时有个非受控管理的<code>input</code>组件列表，在某个输入框内已经输入了内容，当其发生顺序变化时，原始输入内容会跟随着原地复用的策略留在原始的位置，而不是跟随到新的位置，因为其整体列表顺序<code>key</code>未发生变化导致<code>React</code>直接复用节点。</p>
<p>在<code>LineState</code>节点的<code>key</code>值维护中，如果是初始值则是根据<code>state</code>引用自增的值，在变更的时候则是尽可能地复用原始行的<code>key</code>，这样可以避免过多的行节点重建并且可以控制整行的强制刷新。</p>
<p>而对于<code>LeafState</code>节点的<code>key</code>值最开始是直接使用<code>index</code>值，这样实际上会存在隐性的问题，而如果直接根据<code>Immutable</code>来生成<code>key</code>值的话，任何文本内容的更改都会导致<code>key</code>值改变进而导致<code>DOM</code>节点的频繁重建。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NODE_TO_KEY</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">Object</span>.<span class="hljs-property">Any</span>, <span class="hljs-title class_">Key</span>&gt;();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span> {
  <span class="hljs-comment">/** 当前节点 id */</span>
  public <span class="hljs-attr">id</span>: string;
  <span class="hljs-comment">/** 自动递增标识符 */</span>
  public <span class="hljs-keyword">static</span> n = <span class="hljs-number">0</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">`<span class="hljs-subst">${Key.n++}</span>`</span>;
  }

  <span class="hljs-comment">/**
   * 根据节点获取 id
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">node</span>
   */</span>
  public <span class="hljs-keyword">static</span> <span class="hljs-title function_">getId</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property">Any</span>): string {
    <span class="hljs-keyword">let</span> key = <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">get</span>(node);
    <span class="hljs-keyword">if</span> (!key) {
      key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>();
      <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">set</span>(node, key);
    }
    <span class="hljs-keyword">return</span> key.<span class="hljs-property">id</span>;
  }
}
</code></pre>
<p>通常使用<code>index</code>作为<code>key</code>是可行的，然而在一些非受控场景下则会由于原地复用造成渲染问题，<code>diff</code>算法导致的性能问题我们暂时先不考虑。在下面的例子中我们可以看出，每次我们都是从数组顶部删除元素，而实际的<code>input</code>值效果表现出来则是删除了尾部的元素，这就是原地复用的问题。在非受控场景下比较明显，而我们的<code>ContentEditable</code>组件就是一个非受控场景，因此这里的<code>key</code>值需要再考虑一下。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> { useState, <span class="hljs-title class_">Fragment</span>, useRef, useEffect } = <span class="hljs-title class_">React</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> ref = useRef&lt;<span class="hljs-title class_">HTMLParagraphElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [nodes, setNodes] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i));

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> [_, ...rest] = nodes;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);
    <span class="hljs-title function_">setNodes</span>(rest);
  };

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> el = ref.<span class="hljs-property">current</span>;
    el &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(el.<span class="hljs-property">children</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">it, i</span>) =&gt;</span> ((it <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span> = i + <span class="hljs-string">""</span>));
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>&gt;</span>
        {nodes.map((_, i) =&gt; (<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{i}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>&gt;</span>slice<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
  );
}
</code></pre>
<p>考虑到先前提到的我们不希望任何文本内容的更改都导致<code>key</code>值改变引发重建，因此就不能直接使用计算的<code>immutable</code>对象引用来处理<code>key</code>值，而描述单个<code>op</code>的方法除了<code>insert</code>就只剩下<code>attributes</code>了。</p>
<p>但是如果基于<code>attributes</code>来获得就需要精准控制合并<code>insert</code>的时候取需要取旧的对象引用，且没有属性的<code>op</code>就不好处理了，因此这里可能只能将其转为字符串处理，但是这样同样不能保持<code>key</code>的完全稳定，因此前值的索引改变就会导致后续的值出现变更。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">LineState</span>, <span class="hljs-title class_">Record</span>&lt;string, number&gt;&gt;();
<span class="hljs-keyword">const</span> suffix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">LineState</span>, <span class="hljs-title class_">Record</span>&lt;string, number&gt;&gt;();
<span class="hljs-keyword">const</span> mapToString = (<span class="hljs-attr">map</span>: <span class="hljs-title class_">Record</span>&lt;string, string&gt;): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(map)
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${key}</span>:<span class="hljs-subst">${map[key]}</span>`</span>)
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">","</span>);
};
<span class="hljs-keyword">const</span> toKey = (<span class="hljs-attr">state</span>: <span class="hljs-title class_">LineState</span>, <span class="hljs-attr">op</span>: <span class="hljs-title class_">Op</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> key = op.<span class="hljs-property">attributes</span> ? <span class="hljs-title function_">mapToString</span>(op.<span class="hljs-property">attributes</span>) : <span class="hljs-string">""</span>;
  <span class="hljs-keyword">const</span> prefixMap = prefix.<span class="hljs-title function_">get</span>(state) || {};
  prefix.<span class="hljs-title function_">set</span>(state, prefixMap);
  <span class="hljs-keyword">const</span> suffixMap = suffix.<span class="hljs-title function_">get</span>(state) || {};
  suffix.<span class="hljs-title function_">set</span>(state, suffixMap);
  <span class="hljs-keyword">const</span> prefixKey = prefixMap[key] ? prefixMap[key] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> suffixKey = suffixMap[key] ? suffixMap[key] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  prefixMap[key] = prefixKey;
  suffixMap[key] = suffixKey;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${prefixKey}</span>-<span class="hljs-subst">${suffixKey}</span>`</span>;
};
</code></pre>
<p>在<code>slate</code>中我先前认为生成的<code>key</code>跟节点是完全一一对应的关系，例如当<code>A</code>节点变化时，其代表的层级<code>key</code>必然会发生变化。然而在关注这个问题之后，我发现其在更新生成新的<code>Node</code>之后，会同步更新<code>Path</code>以及<code>PathRef</code>对应的<code>Node</code>节点所对应的<code>key</code>值。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [pathRef, key] <span class="hljs-keyword">of</span> pathRefMatches) {
  <span class="hljs-keyword">if</span> (pathRef.<span class="hljs-property">current</span>) {
    <span class="hljs-keyword">const</span> [node] = <span class="hljs-title class_">Editor</span>.<span class="hljs-title function_">node</span>(e, pathRef.<span class="hljs-property">current</span>)
    <span class="hljs-variable constant_">NODE_TO_KEY</span>.<span class="hljs-title function_">set</span>(node, key)
  }
  pathRef.<span class="hljs-title function_">unref</span>()
}
</code></pre>
<p>在后续观察<code>Lexical</code>实现的选区模型时，发现其是用<code>key</code>值唯一地标识每个叶子结点的，选区也是基于<code>key</code>值来描述的。整体表达上比较类似于<code>Slate</code>的选区结构，或者说是<code>DOM</code>树的结构。这里仅仅是值得<code>Range</code>选区，<code>Lexical</code>实际上还有其他三种选区类型。</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-attr">anchor</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">"51"</span>, <span class="hljs-attr">offset</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span> },
  <span class="hljs-attr">focus</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">"51"</span>, <span class="hljs-attr">offset</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span> }
}
</code></pre>
<p>在这里比较重要的是<code>key</code>值变更时的状态保持，因为编辑器的内容实际上是需要编辑的。然而如果做到<code>immutable</code>话，很明显直接根据状态对象的引用来映射<code>key</code>会导致整个编辑器<code>DOM</code>无效的重建。例如调整标题的等级，就由于整个行<code>key</code>的变化导致整行重建。</p>
<p>那么如何尽可能地复用<code>key</code>值就成了需要研究的问题，我们的编辑器行级别的<code>key</code>是被特殊维护的，即实现了<code>immutable</code>以及<code>key</code>值复用。而目前叶子状态的<code>key</code>依赖了<code>index</code>值，因此如果调研<code>Lexical</code>的实现，同样可以将其应用到我们的<code>key</code>值维护中。</p>
<p>通过在<code>playground</code>中调试可以发现，即使我们不能得知其是否为<code>immutable</code>的实现，依然可以发现<code>Lexical</code>的<code>key</code>是以一种偏左的方式维护。因此在我们的编辑器实现中，也可以借助同样的方式，合并直接以左值为准复用，拆分时若以<code>0</code>起始直接复用，起始非<code>0</code>则创建新<code>key</code>。</p>
<ol>
<li><code>[123456(key1)][789(bold-key2)]</code>文本，将<code>789</code>的加粗取消，整段文本的<code>key</code>值保持为<code>key1</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>789</code>这段文本加粗，左侧<code>123456</code>文本的<code>key</code>值保持为<code>key1</code>，<code>789</code>则是新的<code>key</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>123</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456789</code>则是新的<code>key</code>。</li>
<li><code>[123456789(key1)]]</code>文本，将<code>456</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456</code>和<code>789</code>分别是新的<code>key</code>。</li>
</ol>
<p>因此，此时在编辑器中我们也是用类似偏左的方式维护<code>key</code>，由于我们需要保持<code>immutable</code>，所以这里的表达实际上是尽可能复用先前的<code>key</code>状态。这里与<code>LineState</code>的<code>key</code>值维护方式类似，都是先创建状态然后更新其<code>key</code>值，当然还有很多细节的地方需要处理。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 起始与裁剪位置等同 NextOp =&gt; Immutable 原地复用 State</span>
<span class="hljs-keyword">if</span> (offset === <span class="hljs-number">0</span> &amp;&amp; op.<span class="hljs-property">insert</span>.<span class="hljs-property">length</span> &lt;= length) {
  <span class="hljs-keyword">return</span> nextLeaf;
}
<span class="hljs-keyword">const</span> newLeaf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafState</span>(retOp, nextLeaf.<span class="hljs-property">parent</span>);
<span class="hljs-comment">// 若 offset 是 0, 则直接复用原始的 key 值</span>
offset === <span class="hljs-number">0</span> &amp;&amp; newLeaf.<span class="hljs-title function_">updateKey</span>(nextLeaf.<span class="hljs-property">key</span>);
</code></pre>
<p>这里还存在另一个小问题，我们创建<code>LeafState</code>就立即去获得对应的<code>key</code>值，然后再考虑去复用原始的<code>key</code>值。这样其实就会导致很多不再使用的<code>key</code>值被创建，导致每次更新的时候看起来<code>key</code>的数字差值比较大。当然这并不影响整体的功能与性能，只是调试的时候看起来比较怪。</p>
<p>因此我们在这里还可以优化这部分表现，也就是说我们在创建的时候不会去立即创建<code>key</code>值，而是在初始化以及更新的时候再从外部设置其<code>key</code>值。这个实现其实跟<code>index</code>、<code>offset</code>的处理方式比较类似，我们整体在<code>update</code>时处理所有的相关值，且开发模式渲染时进行了严格检查。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// BlockState</span>
<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">line, index</span>) =&gt;</span> {
  line.<span class="hljs-property">index</span> = index;
  line.<span class="hljs-property">start</span> = offset;
  line.<span class="hljs-property">key</span> = line.<span class="hljs-property">key</span> || <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(line);
  <span class="hljs-keyword">const</span> size = line.<span class="hljs-property">isDirty</span> ? line.<span class="hljs-title function_">updateLeaves</span>() : line.<span class="hljs-property">length</span>;
  offset = offset + size;
});
<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = offset;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lines</span>.<span class="hljs-property">length</span>;
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// LineState</span>
<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ops</span>: <span class="hljs-title class_">Op</span>[] = [];
<span class="hljs-variable language_">this</span>.<span class="hljs-property">leaves</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">leaf, index</span>) =&gt;</span> {
  ops.<span class="hljs-title function_">push</span>(leaf.<span class="hljs-property">op</span>);
  leaf.<span class="hljs-property">offset</span> = offset;
  leaf.<span class="hljs-property">parent</span> = <span class="hljs-variable language_">this</span>;
  leaf.<span class="hljs-property">index</span> = index;
  offset = offset + leaf.<span class="hljs-property">length</span>;
  leaf.<span class="hljs-property">key</span> = leaf.<span class="hljs-property">key</span> || <span class="hljs-title class_">Key</span>.<span class="hljs-title function_">getId</span>(leaf);
});
<span class="hljs-variable language_">this</span>.<span class="hljs-property">_ops</span> = ops;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = offset;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirty</span> = <span class="hljs-literal">false</span>;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">leaves</span>.<span class="hljs-property">length</span>;
</code></pre>
<p>此外，在实现单元测试时还发现，在<code>leaf</code>上独立维护了<code>key</code>值，那么<code>\n</code>这个特殊的节点自然也会有独立的<code>key</code>值。这种情况下在<code>line</code>级别上维护的<code>key</code>值倒是也可以直接复用<code>\n</code>这个<code>leaf</code>的<code>key</code>值。当然这只是理论上的实现，可能会导致一些意想不到的刷新问题。</p>
<h2 data-id="heading-2">视图增量渲染</h2>
<p>在视图模块最开始的设计上，我们的状态管理形式是直接全量更新<code>Delta</code>，然后使用<code>EachLine</code>遍历重建所有的状态。并且实际上我们维护了<code>Delta</code>与<code>State</code>两个数据模型，建立其关系映射关系本身也是一种损耗，渲染的时候的目标状态是<code>Delta</code>而非<code>State</code>。</p>
<p>这样的模型必然是耗费性能的，每次<code>Apply</code>的时候都需要全量更新文档并且再次遍历分割行状态。当然实际上只是计算迭代的话，实际上是不会太过于耗费性能，但是由于我们每次都是新的对象，那么在更新视图的时候，更容易造成性能的损耗，计算的性能通常可接受，而视图更新操作<code>DOM</code>成本更高。</p>
<p>实际上，我们上边复用其<code>key</code>值，解决的问题是避免整个行状态视图<code>re-mount</code>。而即使复用了<code>key</code>值，因为重建了整个<code>State</code>实例，<code>React</code>也会继续后边的<code>re-render</code>流程。因此我们在这里需要解决的问题是，如何在无变更的情况下尽可能避免其视图<code>re-render</code>。</p>
<p>由于我们实现了行级不可变状态维护，那么在视图中就可以直接对比状态对象的引用是否变化来决定是否需要重渲染。因此只需要对于<code>ViewModel</code>的节点补充了<code>React.memo</code>，在这个场景下甚至于不需要重写对比函数，只需要依赖我们的<code>immutable</code>状态复用能够正常起到效果。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LeafView</span>: <span class="hljs-variable constant_">FC</span>&lt;{ <span class="hljs-attr">editor</span>: <span class="hljs-title class_">Editor</span>; <span class="hljs-attr">leafState</span>: <span class="hljs-title class_">LeafState</span>; }&gt; = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> {<span class="hljs-attr">...</span>{ [<span class="hljs-attr">LEAF_KEY</span>]<span class="hljs-attr">:</span> <span class="hljs-attr">true</span> }} &gt;</span>
      {runtime.children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LeafModel</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">LeafView</span>);
</code></pre>
<p>同样的，针对<code>LineView</code>也需要补充<code>memo</code>，而且由于组件内本身可能存在状态变化，例如<code>Composing</code>组合输入的控制，所以针对于内部节点的计算也会采用<code>useMemo</code>来缓存结果，避免重复计算。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LineView</span>: <span class="hljs-variable constant_">FC</span>&lt;{ <span class="hljs-attr">editor</span>: <span class="hljs-title class_">Editor</span>; <span class="hljs-attr">lineState</span>: <span class="hljs-title class_">LineState</span>; }&gt; = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> elements = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
     <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> nodes;
  }, [editor, lineState]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...</span>{ [<span class="hljs-attr">NODE_KEY</span>]<span class="hljs-attr">:</span> <span class="hljs-attr">true</span> }} &gt;</span>
      {elements}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LineModel</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">LineView</span>);
</code></pre>
<p>而视图刷新仍然还是直接控制<code>lines</code>这个状态的引用即可，相当于核心层的内容变化与视图层的重渲染，是直接依赖于事件模块通信就可以实现的。由于每次取<code>lines</code>状态时都是新的引用，所以<code>React</code>会认为状态发生了变化，从而触发重渲染。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> onContentChange = <span class="hljs-title function_">useMemoFn</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (flushing.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  flushing.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    flushing.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-title function_">setLines</span>(state.<span class="hljs-title function_">getLines</span>());
  });
});
</code></pre>
<p>而虽然触发了渲染，但是由于<code>key</code>以及<code>memo</code>的存在，会以<code>line</code>的状态为基准进行对比。只有<code>LineState</code>对象的引用发生了变化，<code>LineModel</code>视图才会触发更新逻辑，否则会复用原有的视图，这部分我们可以直接依赖<code>React</code>的<code>devtools</code>录制或<code>Highlight</code>就可以观察到。</p>
<p>视图增量更新这部分其实比较简单，主要是实现不可变对象以及<code>key</code>值维护的逻辑都在核心层实现，视图层主要是依赖其做计算，对比是否需要重渲染。其实类似的实现在低代码的场景中也可以应用，毕竟实际上富文本也就是相当于一个零代码的编辑器，只不过组装的不是组件而是文本。</p>
<h2 data-id="heading-3">总结</h2>
<p>在先前我们主要讨论了视图层的适配器设计，主要是全量的视图初始化渲染，以及状态模型到<code>DOM</code>结构性的规则设定。在这里则主要考虑更新处理时性能的优化，主要是在增量更新时，如何最小化<code>DOM</code>以及<code>Op</code>操作、<code>key</code>值的维护、以及在<code>React</code>中实现增量渲染的方式。</p>
<p>其实接下来需要考虑输入内容时，如何避免规定的<code>DOM</code>的结构被破坏，主要涉及脏<code>DOM</code>检查、选区更新、渲染<code>Hook</code>等，这部分内容在<code>#8</code>和<code>#9</code>的输入法处理中已经有了详细的讨论，因此这里就不再次展开了。</p>
<p>那么接下来我们需要讨论的是编辑节点的组件预设，例如零宽字符、<code>Embed</code>节点、<code>Void</code>节点等。主要是为编辑器的插件扩展提供预设的组件，在这些组件内存在一些默认的行为，并且同样预设了部分<code>DOM</code>结构，以此来实现在规定范围内的编辑器操作。</p>
<h2 data-id="heading-4">每日一题</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWindRunnerMax%2FEveryDay" target="_blank" title="https://github.com/WindRunnerMax/EveryDay" ref="nofollow noopener noreferrer">github.com/WindRunnerM…</a></li>
</ul>
<h2 data-id="heading-5">参考</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2F" target="_blank" title="https://18.react.dev/" ref="nofollow noopener noreferrer">18.react.dev/</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2Freference%2Freact%2Fmemo" target="_blank" title="https://18.react.dev/reference/react/memo" ref="nofollow noopener noreferrer">18.react.dev/reference/r…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2F18.react.dev%2Freference%2Freact%2FuseMemo" target="_blank" title="https://18.react.dev/reference/react/useMemo" ref="nofollow noopener noreferrer">18.react.dev/reference/r…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>